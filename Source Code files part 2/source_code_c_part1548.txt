  // number of 1/4 notes per tick.
            //
            tkTime = (DWORD)clockTime(&pme->clock);
            if (((TICKS)tkTime) < 0)
                tkTime = 0;

            pmmt->u.midi.songptrpos =
                muldiv32(
                    tkTime,
                    4,
                    TICKS_PER_QN(pme->dwTimeDiv));

            break;


        case TIME_SMPTE:

            tkTime = (DWORD)clockTime(&pme->clock);
            if (((TICKS)tkTime) < 0)
                tkTime = 0;

            pmmt->u.smpte.fps = (BYTE)(-SMPTE_FORMAT(pme->dwTimeDiv));

            //
            // If this has managed to get set to something bizarre, just
            // do normal 30 nondrop.
            //
            if ((pmmt->u.smpte.fps != SMPTE_24) &&
                (pmmt->u.smpte.fps != SMPTE_25) &&
                (pmmt->u.smpte.fps != SMPTE_30DROP) &&
                (pmmt->u.smpte.fps != SMPTE_30))
            {
                pmmt->u.smpte.fps = SMPTE_30;
            }

            switch(pmmt->u.smpte.fps)
            {
                case SMPTE_24:
                    pmmt->u.smpte.frame = (BYTE)(tkTime%24);
                    tkTime /= 24;
                    break;

                case SMPTE_25:
                    pmmt->u.smpte.frame = (BYTE)(tkTime%25);
                    tkTime /= 25;
                    break;

                case SMPTE_30DROP:
                    //
                    // Calculate drop-frame stuff.
                    //
                    // We add 2 frames per 1-minute interval except
                    // on every 10th minute.
                    //
                    dw10Min      = tkTime/S30D_FRAMES_PER_10MIN;
                    dw10MinCycle = tkTime%S30D_FRAMES_PER_10MIN;
                    dw1Min       = (dw10MinCycle < 2
                        ? 0 :
                        (dw10MinCycle-2)/S30D_FRAMES_PER_MIN);
                    dwDropMe     = 18*dw10Min + 2*dw1Min;

                    tkTime      += dwDropMe;

                    //
                    // !!! Falling through to 30-nondrop case !!!
                    //

                case SMPTE_30:
                    pmmt->u.smpte.frame = (BYTE)(tkTime%30);
                    tkTime /= 30;
                    break;
            }
            pmmt->u.smpte.sec   = (BYTE)(tkTime%60);
            tkTime /= 60;
            pmmt->u.smpte.min   = (BYTE)(tkTime%60);
            tkTime /= 60;
            pmmt->u.smpte.hour  = (BYTE)(tkTime);

            break;

        case TIME_MS:
            //
            // Use msTotal + ms since time parms last updated; this
            // takes starvation/paused time into account.
            //
            pmmt->u.ms =
                    clockMsTime(&pme->clock);

            break;

        default:
            dprintf1(( "midiOutGetPosition: unexpected wType!!!"));
            return MMSYSERR_INVALPARAM;
    }

    return MMSYSERR_NOERROR;
}

MMRESULT FAR PASCAL mseGetVolume(
    PMIDIEMU                pme,
    LPDWORD                 lpdwVolume)
{
    MMRESULT                mmr = MMSYSERR_NOTSUPPORTED;
    UINT                    idx;

    // Walk the device list underneath us until someone knows the volume
    //
    for (idx = 0; idx < pme->chMidi; ++idx)
        if (MMSYSERR_NOERROR ==
            (midiOutGetVolume((HMIDIOUT)pme->rIds[idx].hMidi, lpdwVolume)))
        {
            mmr = MMSYSERR_NOERROR;
            break;
        }

    return mmr;
}

MMRESULT FAR PASCAL mseSetVolume(
    PMIDIEMU                pme,
    DWORD                   dwVolume)
{
    MMRESULT                mmr = MMSYSERR_NOERROR;
    MMRESULT                mmr2;
    UINT                    idx;

    // Try to set everyone's volume
    //
    for (idx = 0; idx < pme->chMidi; ++idx)
        if (MMSYSERR_NOERROR !=
            (mmr2 = midiOutSetVolume((HMIDIOUT)pme->rIds[idx].hMidi, dwVolume)))
            mmr = mmr2;

    return mmr;

}

MMRESULT FAR PASCAL mseOutReset(
    PMIDIEMU        pme)
{
    LPMIDIHDR       lpmh;
    LPMIDIHDR       lpmhWork;
    UINT            idx;
    MSG             msg;

    // If we have anything posted to mmtask to be cleaned up, process
    // it first
    //
    while (pme->cPostedBuffers)
    {
        Sleep(0);
    }

    //
    //  If we're running the timer, interrupt and force a reschedule
    //  of all remaining channels.
    //
    if (guMIDITimerID != TIMER_OFF)
    {
        dprintf2(( "mOR: About to take %u", guMIDITimerID));
        if (MMSYSERR_NOERROR != timeKillEvent(guMIDITimerID))
        {
            dprintf1(( "timeKillEvent() failed in midiOutPolyMsg"));
        }
        else
        {
            guMIDITimerID = TIMER_OFF;
        }

        midiOutTimerTick(
                     guMIDITimerID,                          // ID of our timer
                     0,                                      // wMsg is unused
                     timeGetTime(),                          // dwUser unused
                     0L,                                     // dw1 unused
                     0L);                                    // dw2 unused
        dprintf2(( "mOR: mOTT"));

        if (gfMinPeriod)
        {
            gfMinPeriod = FALSE;
            timeEndPeriod(guMIDIPeriodMin);
        }
    }

    //
    //  Kill anything queued for midiOutPolyMsg. This will ensure that
    //  sending will stop after the current buffer.
    //
    PDEVLOCK( pme );
    lpmh = pme->lpmhFront;
    pme->lpmhFront = NULL;
    pme->lpmhRear  = NULL;
    pme->dwPolyMsgState = PM_STATE_EMPTY;

    while (lpmh)
    {
        lpmh->dwFlags &= ~MHDR_INQUEUE;
        lpmh->dwFlags |= MHDR_DONE;
        lpmhWork = lpmh->lpNext;

        dprintf2(( "mOR: Next buffer to nuke %08lx", lpmhWork));

        midiOutNukePMBuffer(pme, lpmh);

        lpmh = lpmhWork;
    }

    //
    //  Check to see if our pme structure is still valid.   Someone
    //  might have called midiStreamClose in their callback and we
    //  don't want to touch it after it's closed and freed.  This
    //  is what the MidiPlyr sample application does.
    //
    try
    {
        if (MSE_SIGNATURE != pme->dwSignature)  // must have been freed
            return MMSYSERR_NOERROR;

        PDEVUNLOCK( pme );  // keep it in try for extra protection
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        return MMSYSERR_NOERROR;
    }

    //
    // We've just reset the stream; restart the tick clock at 0 and invalidate
    // the time division to force the time stuff to be reset when the next
    // polymsg comes in.
    //
    dprintf2(( "midiOutReset: clockInit()/ midiOutSetClockRate()"));
    clockInit(&pme->clock, 0, 0, mseTimebase);
    midiOutSetClockRate(pme, 0);

    pme->tkPlayed = 0;

    // Have a reset party on all the drivers under us
    //
    for (idx = 0; idx < pme->chMidi; idx++)
        midiOutReset((HMIDIOUT)pme->rIds[idx].hMidi);

    pme->dwPolyMsgState = PM_STATE_PAUSED;

    return MMSYSERR_NOERROR;
}

MMRESULT FAR PASCAL mseOutStop(
    PMIDIEMU        pme)
{
    LPMIDIHDR       lpmh;
    LPMIDIHDR       lpmhWork;
    MSG             msg;
    BOOL            fSetEvent = FALSE;

    // If we have anything posted to mmtask to be cleaned up, process
    // it first
    //
    while (pme->cPostedBuffers)
    {
        Sleep(0);
    }

    //
    //  If we're running the timer, interrupt and force a reschedule
    //  of all remaining channels.
    //
    if (guMIDITimerID != TIMER_OFF)
    {
        dprintf2(( "mOS: About to take %u", guMIDITimerID));
        if (MMSYSERR_NOERROR != timeKillEvent(guMIDITimerID))
        {
            dprintf1(( "timeKillEvent() failed in midiOutPolyMsg"));
        }
        else
        {
            guMIDITimerID = TIMER_OFF;
        }

        dprintf2(( "mOS: take -- About to mOTT"));

        midiOutTimerTick(
                     guMIDITimerID,                              // ID of our timer
                     0,                                      // wMsg is unused
                     timeGetTime(),                          // dwUser unused
                     0L,                                     // dw1 unused
                     0L);                                    // dw2 unused

        dprintf2(( "mOS: mOTT"));

        if (gfMinPeriod)
        {
            gfMinPeriod = FALSE;
            timeEndPeriod(guMIDIPeriodMin);
        }
    }

    //
    //  Kill anything queued for midiOutPolyMsg. This will ensure that
    //  sending will stop after the current buffer.
    //
    PDEVLOCK( pme );
    lpmh = pme->lpmhFront;
    pme->lpmhFront = NULL;
    pme->lpmhRear  = NULL;
    pme->dwPolyMsgState = PM_STATE_EMPTY;

    while (lpmh)
    {
        lpmh->dwFlags &= ~MHDR_INQUEUE;
        lpmh->dwFlags |= MHDR_DONE;
        lpmhWork = lpmh->lpNext;

        dprintf2(( "mOS: Next buffer to nuke %08lx", lpmhWork));

        midiOutNukePMBuffer(pme, lpmh);

        lpmh = lpmhWork;
    }

    //
    //  Check to see if our pme structure is still valid.   Someone
    //  might have called midiStreamClose in their callback and we
    //  don't want to touch it after it's closed and freed.  This
    //  is what the MidiPlyr sample application does.
    //
    try
    {
        if (MSE_SIGNATURE != pme->dwSignature)  // must have been freed
            return MMSYSERR_NOERROR;

        PDEVUNLOCK( pme );  // keep it in try for extra protection
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        return MMSYSERR_NOERROR;
    }

    //
    // We've just reset the stream; restart the tick clock at 0 and invalidate
    // the time division to force the time stuff to be reset when the next
    // polymsg comes in.
    //

    dprintf2(( "midiOutStop: clockInit()/ midiOutSetClockRate()"));
    clockInit(&pme->clock, 0, 0, mseTimebase);
    midiOutSetClockRate(pme, 0);

    pme->tkPlayed = 0;

    //
    //  In case someone queues up headers during the stop
    //  operation we want to make sure that all they have to
    //  do is restart the stream to get started again.
    //
    mseOutPause(pme);

    //midiOutAllNotesOff(pme);

    //pme->dwPolyMsgState = PM_STATE_STOPPED;

    return MMSYSERR_NOERROR;
}

MMRESULT FAR PASCAL mseOutPause(
    PMIDIEMU        pme)
{
    //
    // Emulating on this handle - do the pause ourselves.
    //
    if (pme->dwPolyMsgState == PM_STATE_PAUSED)
        return MMSYSERR_NOERROR;

    pme->dwSavedState   = pme->dwPolyMsgState;
    pme->dwPolyMsgState = PM_STATE_PAUSED;

    clockPause(&pme->clock, CLK_TK_NOW);

    midiOutAllNotesOff(pme);

    return MMSYSERR_NOERROR;
}

MMRESULT FAR PASCAL mseOutRestart(
    PMIDIEMU        pme,
    DWORD           msTime,
    DWORD           tkTime)
{
    //
    // Emulating on this handle - do the pause ourselves.
    //
    if (pme->dwPolyMsgState != PM_STATE_PAUSED)
        return MMSYSERR_NOERROR;

    pme->dwPolyMsgState = pme->dwSavedState;

    clockRestart(&pme->clock, tkTime, msTime);

    dprintf2(( "restart: state->%lu", pme->dwPolyMsgState));

    midiOutTimerTick(
            guMIDITimerID,               // ID of our timer
            0,                           // wMsg is unused
            timeGetTime(),
            0L,                          // dw1 unused
            0L);                         // dw2 unused

    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @api void | midiEmulatorInit | This function is called at init time to
 *   allow MMSYSTEM to initialize anything it needs to for the polymsg
 *   emulators. Right now, all we do is find the minimum period of the
 *   timeGetTime clock.
 *
 * @rdesc Currently always returns MMSYSERR_NOERROR.
 ****************************************************************************/

#ifdef DEBUG
STATIC SZCODE aszInit[] = "midiEmulatorInit: Using clock res of %lums.";
#endif

void NEAR PASCAL midiEmulatorInit
(
    void
)
{
    TIMECAPS        tc;

    if (MMSYSERR_NOERROR != timeGetDevCaps(&tc, sizeof(tc)))
    {
        dprintf1(( "***            MMSYSTEM IS HORKED             ***"));
        dprintf1(( "*** timeGetDevCaps failed in midiEmulatorInit ***"));

        return;
    }

    //
    // Select the larger of the period we would like to have or
    // the minimum period the timer supports.
    //
    guMIDIPeriodMin = max(MIN_PERIOD, tc.wPeriodMin);

//    guMIDIPeriodMin = MIN_PERIOD;

#ifdef DEBUG
    dprintf2(( aszInit, (DWORD)guMIDIPeriodMin));
#endif
}

/*****************************************************************************
 * @doc EXTERNAL MIDI M4
 *
 * @api UINT | mseOutSend | Plays or queues a buffer of
 * MIDI data to a MIDI output device.
 *
 * @parm PMIDIEMU | pme | Specifies the stream instance the data should
 * go to.
 *
 * @parm LPMIDIHDR | lpMidiOutHdr | Specifies a far pointer to a <t MIDIHDR>
 *   structure that identifies the MIDI data buffer.
 *
 * @parm UINT | cbMidiHdr | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise,
 * it returns an error number. Possible error values include the following:
 *
 *  @flag MMSYSERR_INVALHANDLE | The specified device handle is invalid.
 *  @flag MMSYSERR_INVALPARAM | The value of <p lpMidiOutHdr> is invalid.
 *  @flag MIDIERR_UNPREPARED | The output buffer header <p lpMidiOutHdr> has
 *  not been prepared.
 *  @flag MIDIERR_STILLPLAYING | <p lpMidiOutHdr> is still playing or
 *  queued from a previous call to <f midiOutPolyMsg>.
 *
 * @comm The polymessage buffer contains one or more MIDI messages. Entries in the
 * buffer can be of the following three types:
 *
 * @flag Short Message | Is two DWORDs. One contains time data, the other
 * contains message content. Time information is the time to wait between the
 * previous event and the event being described. Time units are based on the
 * time-division header in the MIDI file.
 *
 * Message content for short messages occupy the 24 least-significant bits of
 * the DWORD; the high-order byte contains a zero.
 *
 * @flag System Message | Is a multiple of two DWORDs. The first DWORD contains
 * time information that specifies the amount of time to wait between the
 * previous event and the event being described. Time units are based on the
 * time-division header in the MIDI file.
 *
 * The second DWORD contains the length of the system-message data (SysEx) in
 * the 24 least-significant bits of the DWORD; the high-order bit contains
 * a one.
 *
 * Remaining DWORDs in the system message contain SysEx data.
 *
 * @flag End-of-Buffer | Is two DWORDs, each with the value -1. This entry
 * indicates the end of data in the poly-message buffer. This message is not passed
 * to MIDI devices.
 *
 * @comm This function cannot be called at interrupt time.
 *
 * @xref <f midiOutLongMsg> <f midiOutPrepareHeader>
 ****************************************************************************/

#define ERROR_EXIT(x)                   \
{                                       \
    uRet = (x);                        \
    goto CLEANUP;                      \
}

#define SKIP_BYTES(x,s)                 \
{                                       \
    if (dwLength < (x))                 \
    {                                   \
        dprintf1(( "!midiOutPolyMsg: ran off end of polymsg buffer in parse!\r\n%ls\r\nOffset %lu", (LPSTR)(s), (DWORD)(((LPBYTE)lpdwBuffer) - lpMidiHdr->lpData))); \
        uRet = MMSYSERR_INVALPARAM;    \
        goto CLEANUP;                  \
    }                                   \
    ((LPBYTE)lpdwBuffer) += (x);       \
    dwLength -= (x);                   \
}

MMRESULT FAR PASCAL mseOutSend(
    PMIDIEMU        pme,
    LPMIDIHDR       lpMidiHdr,
    UINT            cbMidiHdr)
{
    UINT            uRet = MMSYSERR_NOERROR;
    UINT            idx;
    LPDWORD         lpdwBuffer;
    DWORD           dwLength;
    LPMIDIHDR       lpmhWork;
    LPMIDIHDREXT    lpExt;
    BOOL            fQueueWasEmpty;
    BYTE            bEvent;
    DWORD           dwParm;
    DWORD           dwStreamID;
    HMIDIOUT        hmo;
    DWORD_PTR       dwBase;
    UINT            cNewHeaders;

    dprintf2(( "mseOutSend pme %04X lpmh %08lX", (UINT_PTR)pme, (DWORD_PTR)lpMidiHdr));

    dwBase = lpMidiHdr->reserved;

    if ((lpExt = winmmAlloc(sizeof(MIDIHDREXT))) == NULL)
    {
        dprintf1(( "midiOutPolyMsg: No room for shadow"));
        ERROR_EXIT(MMSYSERR_NOMEM);
    }

    //
    //  This needs to be done ASAP in case we error out.
    //
    lpMidiHdr->reserved = (DWORD_PTR)(lpExt);
    lpMidiHdr->dwReserved[MH_BUFIDX] = 0;

    lpExt->nHeaders = 0;
    lpExt->lpmidihdr = (LPMIDIHDR)(lpExt+1);

    //
    //  Parse the poly msg buffer and see if there are any long msgs.
    //  If there are, allocate MIDIHDR's for them on the end of the
    //  main MIDIHDR extension and fill them in and prepare them.
    //
    lpdwBuffer = (LPDWORD)lpMidiHdr->lpData;
    dwLength = lpMidiHdr->dwBytesRecorded;

    while (dwLength)
    {
        //
        //  Skip over the delta time stamp
        //
        SKIP_BYTES(sizeof(DWORD), "d-time");
        dwStreamID = *lpdwBuffer;
        SKIP_BYTES(sizeof(DWORD), "stream-id");

        //
        // Extract the event type and parameter and skip the event DWORD
        //
        bEvent = MEVT_EVENTTYPE(*lpdwBuffer) & (BYTE)~(MEVT_F_CALLBACK >> 24);
        dwParm = MEVT_EVENTPARM(*lpdwBuffer);
        SKIP_BYTES(sizeof(DWORD), "event");

        if (bEvent == MEVT_LONGMSG)
        {
            LPMIDIHDREXT    lpExtRealloc;

            if (dwParm > dwLength)
            {
                dprintf1(( "parse: I don't like stuff that sucks!"));
                ERROR_EXIT(MMSYSERR_INVALPARAM);
            }

            cNewHeaders = 1;
            if (dwStreamID == (DWORD)-1L)
                cNewHeaders = pme->chMidi;

            lpExt->nHeaders += cNewHeaders;

            if ((lpExtRealloc = (LPMIDIHDREXT)HeapReAlloc(hHeap,
                                HEAP_ZERO_MEMORY, lpExt,
                                sizeof(MIDIHDREXT)+sizeof(MIDIHDR)*lpExt->nHeaders))
                                     == NULL)
            {
                lpExt->nHeaders -= cNewHeaders;
                ERROR_EXIT(MMSYSERR_NOMEM);
            }

            lpExt = lpExtRealloc;
            lpMidiHdr->reserved = (DWORD_PTR)(lpExt);

            lpmhWork = ((LPMIDIHDR)(lpExt+1)) + lpExt->nHeaders - cNewHeaders;

            while (cNewHeaders--)
            {
                lpmhWork->lpData          = (LPSTR)lpdwBuffer;
                lpmhWork->dwBufferLength  = dwParm;
                lpmhWork->dwBytesRecorded = 0;
                lpmhWork->dwUser          = 0;
                lpmhWork->dwFlags         =
                    (lpMidiHdr->dwFlags & MHDR_MAPPED) | MHDR_SHADOWHDR;

                if (dwStreamID == (DWORD)-1L)
                    lpmhWork->dwReserved[MH_STREAM] = cNewHeaders;
                else
                    lpmhWork->dwReserved[MH_STREAM] = dwStreamID;

                lpmhWork->dwReserved[MH_STRMPME] = (DWORD_PTR)pme;
                ++lpmhWork;
            }
            dwParm = (dwParm+3)&~3;
            SKIP_BYTES(dwParm, "longmsg parm");
        }
        else
        {
            //
            // Skip any additional paramters for other length-class messages
            //
            if (bEvent & (MEVT_F_LONG >> 24))
            {
                dwParm  = (dwParm+3)&~3;
//                    dprintf1(( "Length [%lu] rounded [%lu]", dwParm, (dwParm+3)&~3));
                SKIP_BYTES(dwParm, "generic long event data");
            }
        }
    }

    // Now prepare any headers we allocated
    //
    lpmhWork = (LPMIDIHDR)(lpExt+1);
    for (idx = 0; idx < lpExt->nHeaders; idx++, lpmhWork++)
    {
        hmo = (HMIDIOUT)mseIDtoHMidi(pme, (DWORD)lpmhWork->dwReserved[MH_STREAM]);
        if (NULL != hmo)
        {
            if ((uRet = midiOutPrepareHeader(hmo,
                                         lpmhWork,
                                         sizeof(MIDIHDR))) != MMSYSERR_NOERROR)
            {
                dprintf1(( "parse: pre-prepare of embedded long msg failed! (%lu)", (DWORD)uRet));
                ERROR_EXIT(uRet);
            }
        }
    }

    //
    //  Reset lpExt->lpmidihdr to the next header to play
    //
    lpExt->lpmidihdr = (LPMIDIHDR)(lpExt+1);

    //
    //  Prepare to update handle information to contain this header
    //
    PDEVLOCK( pme );

    //
    //  Shove the block in the queue, noting if it was empty
    //

    fQueueWasEmpty = FALSE;
    if (pme->lpmhRear == NULL)
    {
        fQueueWasEmpty = TRUE;
        pme->lpmhRear = pme->lpmhFront = lpMidiHdr;
    }
    else
    {
        pme->lpmhRear->lpNext = lpMidiHdr;
        pme->lpmhRear = lpMidiHdr;
    }

    lpMidiHdr->lpNext = NULL;
    lpMidiHdr->dwFlags |= MHDR_INQUEUE;

    PDEVUNLOCK( pme );

    if (pme->dwPolyMsgState == PM_STATE_PAUSED)
    {
        if (fQueueWasEmpty)
            pme->dwSavedState = PM_STATE_READY;
    }
    else
    {
        if (fQueueWasEmpty)
        {
            // We want to schedule this now. If the there's no timer
            // or we can kill the current one, send. If we can't kill the
            // pending timer, it's in the process of being scheduled anyway
            //
            if (guMIDITimerID == TIMER_OFF ||
                MMSYSERR_NOERROR == timeKillEvent(guMIDITimerID))
            {
                guMIDITimerID = TIMER_OFF;
                pme->dwPolyMsgState = PM_STATE_READY;

                dprintf2(( "mseSend take -- about to mot"));

                midiOutTimerTick(
                             guMIDITimerID,    // ID of our timer
                             0,                // wMsg is unused
                             timeGetTime(),    // dwUser unused
                             0L,               // dw1 unused
                             0L);              // dw2 unused

                dprintf2(( "mseSend mot"));
            }
        }
    }


CLEANUP:
    if (uRet != MMSYSERR_NOERROR)
    {
        if (lpExt != NULL)
        {
            lpMidiHdr = (LPMIDIHDR)(lpExt+1);
            while (lpExt->nHeaders--)
            {
                hmo = (HMIDIOUT)mseIDtoHMidi(pme, (DWORD)lpMidiHdr->dwReserved[MH_STREAM]);
#ifdef DEBUG
                if (NULL == hmo)
                    dprintf1(( "stream-id disappeared during cleanup!!!"));
#endif
                midiOutUnprepareHeader(hmo, lpMidiHdr++, sizeof(MIDIHDR));
            }

            winmmFree(lpExt);
        }
    }

    return uRet;

} /* midiOutPolyMsg() */

/**  void FAR PASCAL midiOutSetClockRate(PMIDIEMU pme, TICKS tkWhen)
 *
 *  DESCRIPTION:
 *
 *      This function is called whenever the clock rate for the stream
 *      needs to be changed.
 *
 *  ARGUMENTS:
 *      (PMIDIEMU pme, TICKS tkWhen)
 *
 *      pme indicates the handle to change the clock rate of.
 *
 *      tkWhen is the absolute tick time at which the time change occurs.
 *
 ** jfg */


void FAR PASCAL midiOutSetClockRate(
    PMIDIEMU        pme,
    TICKS           tkWhen)
{
    DWORD           dwNum;
    DWORD           dwDenom;


    if (pme->dwTimeDiv&IS_SMPTE)
    {
        switch(-SMPTE_FORMAT(pme->dwTimeDiv))
        {
            case SMPTE_24:
            dwNum = 24L;
            dwDenom = 1L;
            break;

            case SMPTE_25:
            dwNum = 25L;
            dwDenom = 1L;
            break;

            case SMPTE_30DROP:
            case SMPTE_30:
            //
            // Actual frame rate for 30 fps (color television) is
            // 29.97 fps.
            //
            dwNum = 2997L;
            dwDenom = 100L;
            break;

            default:
            dprintf1(( "Invalid SMPTE frames/sec in midiOutSetClockRate! (using 30)"));
            dwNum = 2997L;
            dwDenom = 100L;
            break;
        }

        dwNum   *= (DWORD)TICKS_PER_FRAME(pme->dwTimeDiv);
        dwDenom *= 1000L;
    }
    else
    {
        dwNum   = 1000L * TICKS_PER_QN(pme->dwTimeDiv);
        dwDenom = pme->dwTempo;
    }

    clockSetRate(&pme->clock, tkWhen, dwNum, dwDenom);
}

/** BOOL NEAR PASCAL midiOutScheduleNextEvent(PMIDIEMU pme)
 *
 *  DESCRIPTION:
 *
 *      Determine when (in ticks defined for this device) the next event
 *      is due.
 *
 *  ARGUMENTS:
 *      (PMIDIEMU pme)
 *
 *  RETURN (BOOL):
 *
 *      TRUE if there was an event in this buffer to schedule.
 *
 *  NOTES:
 *
 *      Just calculate how many ticks till next event and store in the
 *      device struct.
 *
 *      This function does NOT schedule across buffers; caller must
 *      link to next buffer if needed.
 *
 ** jfg */

BOOL NEAR PASCAL midiOutScheduleNextEvent(
    PMIDIEMU        pme)
{
    LPMIDIHDR       lpmhdr;
    LPBYTE          lpb;
    DWORD           tkDelta;

    if ((lpmhdr = pme->lpmhFront) == NULL ||
         lpmhdr->dwReserved[MH_BUFIDX] == lpmhdr->dwBytesRecorded)
    {
        pme->dwPolyMsgState = PM_STATE_EMPTY;
        return FALSE;
    }

    lpb = (LPBYTE)lpmhdr->lpData;
    tkDelta = *(LPDWORD)(lpb+lpmhdr->dwReserved[MH_BUFIDX]);

    pme->tkNextEventDue = pme->tkPlayed + tkDelta;
    pme->dwPolyMsgState = PM_STATE_READY;

    return TRUE;
} /* ScheduleNextEvent() */


/** void NEAR PASCAL midiOutPlayNextPolyEvent(PMIDIEMU pme)
 *
 *  DESCRIPTION:
 *
 *      Play the next event if there is one. Current buffer must
 *      be pointing at an event (*NOT* end-of-buffer).
 *
 *      - Plays all events which are due
 *
 *      - Schedules next event
 *
 *  ARGUMENTS:
 *      (PMIDIEMU pme)
 *
 *  NOTES:
 *
 *      First, play the event. If it's a short msg, just do it.
 *      If it's a SysEx, pull the appropriate (already prepared)
 *      header from the extension block and send it. Mark the state
 *      of the device as blocked so nothing else will be played
 *      until the SysEx is done.
 *
 *      Update dwReserved[MH_BUFIDX] to point at the next event.
 *
 *      Determine the next event and schedule it, crossing to the
 *      next buffer if needed. If the next event is already due
 *      (i.e. had a delta-time of zero), stick around and send that,
 *      too.
 *
 *
 *
 ** jfg */

void NEAR PASCAL midiOutPlayNextPolyEvent(
    PMIDIEMU        pme
#ifdef DEBUG
   ,DWORD           dwStartTime
#endif
)
{
    LPBYTE          lpb;
    LPMIDIHDR       lpmhdr;
    DWORD           dwMsg;
    LPMIDIHDREXT    lpExt;
    MMRESULT        mmrError;
    DWORD           tkDelta;
    BYTE            bEvent;
    DWORD           dwOffset;
    DWORD           dwStreamID;
    HMIDIOUT        hmo;
    UINT            cToSend;

#if 0
    if (NULL != pme->lpmhFront)
    {
        lpb = (LPBYTE)(pme->lpmhFront->lpData);
        _asm
        {
            mov     ax, word ptr lpb
            mov     dx, word ptr lpb+2
            int     3
        }
    }
#endif

    while (pme->dwPolyMsgState == PM_STATE_READY)
    {
        for(;;)
        {
            lpmhdr = pme->lpmhFront;
            if (!lpmhdr)
                return;

            // Make sure next buffer contains valid data and skip if it
            // doesn't
            //
            if (midiOutScheduleNextEvent(pme))
                break;

            // That buffer is done or empty
            //
            midiOutDequeueAndCallback(pme);
        }

        lpb = lpmhdr->lpData;
        tkDelta = *(LPDWORD)(lpb+lpmhdr->dwReserved[MH_BUFIDX]);

//        dprintf2(( "dwReserved[MH_BUFIDX] %lu tkDelta %lu", lpmhdr->dwReserved[0], tkDelta));

        pme->tkNextEventDue = pme->tkPlayed + tkDelta;
        if (pme->tkNextEventDue > pme->tkTime)
        {
            return;
        }

        //
        // There is an event pending and it's due; send it and update pointers
        //
        dwOffset = (DWORD)lpmhdr->dwReserved[MH_BUFIDX];

        pme->tkPlayed += tkDelta;

        // Skip tkDelta and stream-id
        //

        lpmhdr->dwReserved[MH_BUFIDX] += sizeof(DWORD);
        dwStreamID = *(LPDWORD)(lpb+lpmhdr->dwReserved[MH_BUFIDX]);
        lpmhdr->dwReserved[MH_BUFIDX] += sizeof(DWORD);

        // Will be NULL if dwStreamID == -1 (all IDs)
        //
        hmo = (HMIDIOUT)mseIDtoHMidi(pme, dwStreamID);

        //
        // Extract event type and parms and update past event
        //
        dwMsg  = *(LPDWORD)(lpb+lpmhdr->dwReserved[MH_BUFIDX]);
        bEvent = MEVT_EVENTTYPE(dwMsg);
        dwMsg  = MEVT_EVENTPARM(dwMsg);

        lpmhdr->dwReserved[MH_BUFIDX] += sizeof(DWORD);

        if (hmo && (bEvent & (MEVT_F_CALLBACK >> 24)))
        {
            lpmhdr->dwOffset = dwOffset;
            DriverCallback(
            pme->dwCallback,
            HIWORD(pme->dwFlags),
            (HDRVR)pme->hStream,
            MM_MOM_POSITIONCB,
            pme->dwInstance,
            (DWORD_PTR)lpmhdr,
            0L);

        }

        bEvent &= ~(MEVT_F_CALLBACK >> 24);

        switch(bEvent)
        {
            case MEVT_SHORTMSG:
            {
                BYTE    bEventType;
                BYTE    bNote;
                BYTE    bVelocity;
                LPBYTE  pbEntry = pme->rbNoteOn;

                if (NULL == hmo)
                {
                    dprintf1(( "Event skipped - not ours"));
                    break;
                }

                //
                // If we're sending a note on or note off, track note-on
                // count.
                //
                bEventType = (BYTE)(dwMsg&0xFF);

                if (!(bEventType & 0x80))
                {
                    bEventType = pme->bRunningStatus;
                    bNote     = (BYTE)(dwMsg&0xFF);
                    bVelocity = (BYTE)((dwMsg >> 8)&0xFF);

                    // ALWAYS expand running status - individual dev's can't
                    // track running status of entire stream.
                    //
                    dwMsg = (dwMsg << 8) | (DWORD)(bEventType);
                }
                else
                {
                    pme->bRunningStatus = bEventType;
                    bNote     = (BYTE)((dwMsg >> 8)&0xFF);
                    bVelocity = (BYTE)((dwMsg >> 16)&0xFF);
                }

                if ((bEventType&0xF0) == MIDI_NOTEON ||
                    (bEventType&0xF0) == MIDI_NOTEOFF)
                {
                    BYTE bChannel = (bEventType & 0x0F);
                    UINT cbOffset = (bChannel * NUM_NOTES + bNote) / 2;

                    //
                    // Note-on with a velocity of 0 == note off
                    //
                    if ((bEventType&0xF0) == MIDI_NOTEOFF || bVelocity == 0)
                    {
                        if (bNote&0x01)  // odd
                        {
                            if ((*(pbEntry + cbOffset)&0xF0) != 0)
                                *(pbEntry + cbOffset) -= 0x10;
                        }
                        else //even
                        {
                            if ((*(pbEntry + cbOffset)&0xF) != 0)
                                *(pbEntry + cbOffset) -= 0x01;
                        }
                    }
                    else
                    {
                        if (bNote&0x01)  // odd
                        {
                            if ((*(pbEntry + cbOffset)&0xF0) != 0xF0)
                                *(pbEntry + cbOffset) += 0x10;
                        }
                        else //even
                        {
                            if ((*(pbEntry + cbOffset)&0xF) != 0xF)
                                *(pbEntry + cbOffset) += 0x01;
                        }
                    }

                }

                mmrError = midiOutShortMsg(hmo, dwMsg);
                if (MMSYSERR_NOERROR != mmrError)
                {
                    dprintf(("Short msg returned %08lX!!!", (DWORD)mmrError));
                }
            }
            break;

            case MEVT_TEMPO:
                pme->dwTempo = dwMsg;
                dprintf1(( "dwTempo %lu", pme->dwTempo));
                midiOutSetClockRate((PMIDIEMU)pme, pme->tkPlayed);
            break;

            case MEVT_LONGMSG:
                //
                //  Advance lpmhdr past the message; the header is already
                //  prepared with the proper address and length, so we set
                //  the polymsg header so that it points at the next message
                //  when this long msg completes.
                //
                //  Keep low 24 bits of dwMsg (SysEx length, byte aligned),
                //  round to next DWORD (buffer must be padded to match this),
                //  and skip past dwMsg and the SysEx buffer.
                //
                dwMsg = (dwMsg+3)&~3;

                lpmhdr->dwReserved[MH_BUFIDX] += dwMsg;


                cToSend = 1;
                if (dwStreamID == (DWORD)-1L)
                    cToSend = pme->chMidi;

                lpExt = (LPMIDIHDREXT)lpmhdr->reserved;

                pme->cSentLongMsgs = 0;
                pme->dwPolyMsgState = PM_STATE_BLOCKED;
                pme->fdwDev |= MDV_F_SENDING;

                while (cToSend--)
                {
                    lpmhdr = lpExt->lpmidihdr;
                    ++lpExt->lpmidihdr;

                    hmo = (HMIDIOUT)mseIDtoHMidi(pme,
                                                 (DWORD)lpmhdr->dwReserved[MH_STREAM]);


                    if (hmo) 
                        mmrError = midiOutLongMsg(hmo, lpmhdr, sizeof(MIDIHDR));
                    else
                        dprintf1(( "mseIDtoHMidi() failed and returned a NULL" ));


                    if ((hmo) && (MMSYSERR_NOERROR == mmrError))
                        ++pme->cSentLongMsgs;
                    else
                        dprintf1(( "MODM_LONGDATA returned %u in emulator!",
                                 (UINT)mmrError));
                }

                if (0 == pme->cSentLongMsgs)
                    pme->dwPolyMsgState = PM_STATE_READY;
                pme->fdwDev &= ~MDV_F_SENDING;

            break;

            default:
            //
            // If we didn't understand a length-class message, skip it.
            //
                if (bEvent&(MEVT_F_LONG >> 24))
                {
                    dwMsg = (dwMsg+3)&~3;
                    lpmhdr->dwReserved[MH_BUFIDX] += dwMsg;
                }
            break;
        }

        //
        // Find the next schedulable polyMsg
        //
        while (!midiOutScheduleNextEvent(pme))
        {
            midiOutDequeueAndCallback(pme);
            if (pme->lpmhFront == NULL)
                break;
        }
    }
}

/** void NEAR PASCAL midiOutDequeueAndCallback(PMIDIEMU pme)
 *
 *  DESCRIPTION:
 *
 *      The current polymsg buffer has finished. Pull it off the queue
 *      and do a callback.
 *
 *  ARGUMENTS:
 *      (PMIDIEMU pme)
 *
 *  NOTES:
 *
 ** jfg */

void NEAR PASCAL midiOutDequeueAndCallback(
    PMIDIEMU        pme)
{
    LPMIDIHDR       lpmidihdr;
    BOOL            fPosted;

        dprintf2(( "DQ"));
    //
    //  A polymsg buffer has finished. Pull it off the queue and
    //  call back the app.
    //
    if ((lpmidihdr = pme->lpmhFront) == NULL)
        return;

    if ((pme->lpmhFront = lpmidihdr->lpNext) == NULL)
    {
        dprintf2(( "DQ/CB -- last buffer"));
        pme->lpmhRear = NULL;
    }

    //
    // Can't be at interrupt callback time to unprepare possible
    // embedded long messages in this thing. The notify window's
    // wndproc will call midiOutNukePMBuffer to clean up.
    //
    dprintf2(( "!DQ/CB %08lX", (DWORD_PTR)lpmidihdr));

    ++pme->cPostedBuffers;
    fPosted = PostMessage(
                hwndNotify,
                MM_POLYMSGBUFRDONE,
                (WPARAM)pme,
                (DWORD_PTR)lpmidihdr);

    WinAssert(fPosted);

    if (!fPosted)
    {
        GetLastError();
        --pme->cPostedBuffers;
    }
}

void FAR PASCAL midiOutNukePMBuffer(
    PMIDIEMU        pme,
    LPMIDIHDR       lpmh)
{
    LPMIDIHDREXT    lpExt;
    LPMIDIHDR       lpmhWork;
    MMRESULT        mmrc;
    HMIDIOUT        hmo;

    dprintf2(( "Nuke %08lX", (DWORD_PTR)lpmh));

    //
    // Unprepare internal stuff and do user callback
    //
    lpExt    = (LPMIDIHDREXT)(lpmh->reserved);
    lpmhWork = (LPMIDIHDR)(lpExt+1);

    while (lpExt->nHeaders--)
    {
        if ((lpmhWork->dwFlags&MHDR_PREPARED) &&
           (!(lpmhWork->dwFlags&MHDR_INQUEUE)))
        {
            hmo = (HMIDIOUT)mseIDtoHMidi(pme, (DWORD)lpmhWork->dwReserved[MH_STREAM]);
            mmrc = midiOutUnprepareHeader(hmo, lpmhWork, sizeof(*lpmhWork));
#ifdef DEBUG
            if (MMSYSERR_NOERROR != mmrc)
            {
                dprintf1(( "midiOutNukePMBuffer: Could not unprepare! (%lu)", (DWORD)mmrc));
            }
#endif
        }
        else
        {
            dprintf1(( "midiOutNukePMBuffer: Emulation header flags bogus!!!"));
        }

        lpmhWork++;
    }

    winmmFree(lpExt);
    lpmh->reserved = 0L;

    lpmh->dwFlags &= ~MHDR_INQUEUE;
    lpmh->dwFlags |= MHDR_DONE;

//    dprintf2(( "Nuke: callback"));

    DriverCallback(
            pme->dwCallback,
            HIWORD(pme->dwFlags),
            (HDRVR)pme->hStream,
            MM_MOM_DONE,
            pme->dwInstance,
            (DWORD_PTR)lpmh,
            0L);
}



/*****************************************************************************
 *
 * @doc INTERNAL MIDI
 *
 * @api void | midiOutTimerTick |
 *  This function handles the timing of polymsg out buffers. One timer instance
 *  is shared by all polymsg out streams. When <f midiOutPolyMsg> is called
 *  and the timer is not running, or <f midiOutTimerTick> finished processing,
 *  the timer is set to go off based on the time until the event with the
 *  shortest time remaining of all events. All timers are one-shot timers.
 *
 * @parm UINT | uTimerID |
 *  The timer ID of the timer that fired.
 *
 * @parm UINT | wMsg |
 *  Unused.
 *
 * @parm DWORD | dwUser |
 *  User instance data for the timer callback (unused).
 *
 * @parm DWORD | dwParam1 |
 *  Unused.
 *
 * @parm DWORD | dwParam2 |
 *  Unused.
 *
 * @comm Determine elapsed microseconds using <f timeGetTime>.
 *
 *  Traverse the list of output handles. Update the tick clock for each handle. If there are
 *  events to do on that handle, start them.
 *
 *  Determine the next event due on any stream. Start another one-shot timer
 *  to call <f midiOutTimerTick> when this interval has expired.
 *
 *****************************************************************************/

STATIC UINT uTimesIn = 0;

void CALLBACK midiOutTimerTick(
    UINT        uTimerID,
    UINT        wMsg,
    DWORD_PTR   dwUser,
    DWORD_PTR   dw1,
    DWORD_PTR   dw2)
{
    PMIDIEMU    pme;
    DWORD       msNextEventMin = (DWORD)-1L;
    DWORD       msNextEvent;
    UINT        uDelay;
#ifdef DEBUG
    DWORD       dwNow = timeGetTime();
#endif

    if (guMIDIInTimer)
    {
        dprintf2(( "midiOutTimerTick() re-entered (%u)", guMIDIInTimer));
        return;
    }

    guMIDIInTimer++;

#ifdef DEBUG
    {
        DWORD dwDelta = dwNow - (DWORD)dwUser;
        if (dwDelta > 1)
            dprintf2(( "Timer event delivered %lu ms late", dwDelta));
    }
#endif

    for (pme = gpEmuList; pme; pme = pme->pNext)
    {
        pme->tkTime = clockTime(&pme->clock);

        //
        // Play all events on this pdev that are due
        //
        if (pme->dwPolyMsgState == PM_STATE_READY)
        {
            //
            //  Lock starts at -1.  When incrementing the lock
            //  if we are the only one with the lock the count
            //  will be 0, otherwise it will be some non-zero
            //  value determined by InterlockedIncrement.
            //
            if (PDEVLOCK( pme ) == 0)

                midiOutPlayNextPolyEvent(pme
#ifdef DEBUG
                                         ,dwNow
#endif
                                         );

            PDEVUNLOCK( pme );
        }

        //
        // If there's still data to play on this stream, figure out when
        // it'll be due so we can schedule the next nearest event.
        //
        if (pme->dwPolyMsgState != PM_STATE_EMPTY)
        {
            //            dprintf1(( "tkNextEventDue %lu pdev->tkTime %lu", pme->tkNextEventDue, pme->tkTime));
            if (pme->tkNextEventDue <= pme->tkTime)
            {
                //
                // This can happen if we send a long embedded SysEx and the
                // next event is scheduled a short time away (comes due before
                // SysEx finishes). In this case, we want the timer to fire
                // again ASAP.
                //
                msNextEvent = 0;
            }
            else
            {
                msNextEvent =
                       clockOffsetTo(&pme->clock, pme->tkNextEventDue);
            }

            if (msNextEvent < msNextEventMin)
            {
                msNextEventMin = msNextEvent;
            }
        }
        else
        {
            dprintf1(( "dwPolyMsgState == PM_STATE_EMPTY"));
        }
    }

    if (0 == msNextEventMin)
    {
        dprintf1(( "midiEmu: Next event due now!!!"));
    }

    --guMIDIInTimer;

    //
    // Schedule the next event. In no case schedule an event less than
    // guMIDIPeriodMin away (no point in coming back w/ no time elapsed).
    //
    if (msNextEventMin != (DWORD)-1L)
    {
        uDelay = max(guMIDIPeriodMin, (UINT)msNextEventMin);

//        dprintf1(("PM Resched %u ms (ID=%u)", uDelay, guMIDITimerID));

        if (!gfMinPeriod)
        {
            timeBeginPeriod(guMIDIPeriodMin);
            gfMinPeriod = TRUE;
        }

#ifdef DEBUG
        guMIDITimerID = timeSetEvent(uDelay, guMIDIPeriodMin, midiOutTimerTick, timeGetTime()+uDelay, TIME_ONESHOT | TIME_KILL_SYNCHRONOUS);
#else
        guMIDITimerID = timeSetEvent(uDelay, guMIDIPeriodMin, midiOutTimerTick, uDelay, TIME_ONESHOT | TIME_KILL_SYNCHRONOUS);
#endif

            dprintf2(( "mOTT tse(%u) = %u", guMIDIPeriodMin, guMIDITimerID));

            if (guMIDITimerID == TIMER_OFF)
                dprintf1(( "timeSetEvent(%u) failed in midiOutTimerTick!!!", uDelay));
        }
        else
        {
            dprintf1(( "Stop in the name of all that which does not suck!"));
            guMIDITimerID = TIMER_OFF;
            if (gfMinPeriod)
            {
                dprintf1(( "timeEndPeriod"));
                gfMinPeriod = FALSE;
                timeEndPeriod(guMIDIPeriodMin);
            }
        }

#ifdef DEBUG
    {
        DWORD dwDelta = timeGetTime() - dwNow;
        if (dwDelta > 1)
            dprintf2(( "Spent %lu ms in midiOutTimerTick", dwDelta));
    }
#endif
} /* TimerTick() */


/*****************************************************************************
 *
 * @doc INTERNAL MIDI
 *
 * @api void | midiOutCallback |
 *  This function is called by the midi output driver whenever an event
 *  completes. It filters long message completions when we are emulating
 *  polymsg out.
 *
 * @parm HMIDIOUT | hMidiOut |
 *  Handle of the device which completed something.
 *
 * @parm UINT | wMsg |
 *  Specifies the event which completed.
 *
 * @parm DWORD | dwInstance |
 *  User instance data for the callback.
 *
 * @parm DWORD | dwParam1 |
 *  Message specific parameter.
 *
 * @parm DWORD | dwParam2 |
 *  Message specific parameter.
 *
 * @comm
 *
 *  If this is a completion for a long message buffer on a stream we are
 *  emulating polymsg out for, mark the stream as ready to play.
 *
 *****************************************************************************/

void CALLBACK midiOutCallback(
    HMIDIOUT    hMidiOut,
    WORD        wMsg,
    DWORD_PTR   dwInstance,
    DWORD_PTR   dwParam1,
    DWORD_PTR   dwParam2)
{
    PMIDIEMU    pme;
    LPMIDIHDR   lpmh;

    if (MM_MOM_DONE != wMsg)
        return;

    lpmh = (LPMIDIHDR)dwParam1;
    pme = (PMIDIEMU)lpmh->dwReserved[MH_STRMPME];

#ifdef DEBUG
    if (lpmh->dwFlags & MHDR_ISSTRM)
        dprintf1(( "Uh-oh, got stream header back from 3.1 driver???"));
#endif

    if (MM_MOM_DONE == wMsg)
    {
        if (0 == --pme->cSentLongMsgs &&
            !(pme->fdwDev & MDV_F_SENDING))
            pme->dwPolyMsgState = PM_STATE_READY;
    }

}

/*****************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @api void | midiOutAllNotesOff | This function turns off all notes
 *   by using the map kept in polymsg emulation. It only works if we're
 *   opened with MIDI_IO_COOKED and are emulating on that device.
 *
 * @parm PMIDIEMU | pme | The device to turn off notes on.
 *
 * @xref midiOutPause midiOutStop
 ****************************************************************************/
void NEAR PASCAL midiOutAllNotesOff(
    PMIDIEMU        pme)
{
    UINT            uChannel;
    UINT            uNote;
    BYTE            bCount;
    DWORD           dwMsg;
    UINT            idx;
    LPBYTE          pbEntry = pme->rbNoteOn;

    for (uChannel=0; uChannel < NUM_CHANNELS; uChannel++)
    {
        // Turn off any sustained notes so the note off won't be ignored
        //
        dwMsg = ((DWORD)MIDI_CONTROLCHANGE) |
            ((DWORD)uChannel)|
            (((DWORD)MIDI_SUSTAIN)<<8);

        for (idx = 0; idx < pme->chMidi; idx++)
            midiOutShortMsg((HMIDIOUT)pme->rIds[idx].hMidi, dwMsg);

        for (uNote=0; uNote < NUM_NOTES; uNote++)
        {
            if (uNote&0x01)  // odd
            {
                bCount = (*(pbEntry + (uChannel * NUM_NOTES + uNote)/2) & 0xF0)>>4;
            }
            else  // even
            {
                bCount = *(pbEntry + (uChannel * NUM_NOTES + uNote)/2) & 0xF;
            }

            if (bCount != 0)
            {
                //
                // Message is Note off on this channel and note
                // with a turn off velocity of 127
                //
                dwMsg =
                    ((DWORD)MIDI_NOTEOFF)|
                    ((DWORD)uChannel)|
                    ((DWORD)(uNote<<8))|
                    0x007F0000L;

                dprintf1(( "mOANO: dwMsg %08lX count %u", dwMsg, (UINT)bCount));

                while (bCount--)
                {
                    for (idx = 0; idx < pme->chMidi; idx++)
                        midiOutShortMsg((HMIDIOUT)pme->rIds[idx].hMidi, dwMsg);
                }
            }
        }
    }
}


MMRESULT FAR PASCAL mseOutCachePatches(
    PMIDIEMU        pme,
    UINT            uBank,
    LPWORD          pwpa,
    UINT            fuCache)
{
    UINT            cmesi;
    PMIDIEMUSID     pmesi;
    MMRESULT        mmrc;
    MMRESULT        mmrc2;

    cmesi = pme->chMidi;
    pmesi = pme->rIds;

    mmrc2 = MMSYSERR_NOERROR;
    while (cmesi--)
    {
        mmrc = midiOutCachePatches((HMIDIOUT)pmesi->hMidi, uBank, pwpa, fuCache);
        if (MMSYSERR_NOERROR != mmrc && MMSYSERR_NOTSUPPORTED != mmrc)
            mmrc2 = mmrc;
    }

    return mmrc2;
}


MMRESULT FAR PASCAL mseOutCacheDrumPatches(
    PMIDIEMU        pme,
    UINT            uPatch,
    LPWORD          pwkya,
    UINT            fuCache)
{
    UINT            cmesi;
    PMIDIEMUSID     pmesi;
    MMRESULT        mmrc;
    MMRESULT        mmrc2;

    cmesi = pme->chMidi;
    pmesi = pme->rIds;

    mmrc2 = MMSYSERR_NOERROR;
    while (cmesi--)
    {
        mmrc = midiOutCacheDrumPatches((HMIDIOUT)pmesi->hMidi, uPatch, pwkya, fuCache);
        if (MMSYSERR_NOERROR != mmrc && MMSYSERR_NOTSUPPORTED != mmrc)
            mmrc2 = mmrc;
    }

    return mmrc2;
}

DWORD FAR PASCAL mseOutBroadcast(
    PMIDIEMU        pme,
    UINT            msg,
    DWORD_PTR       dwParam1,
    DWORD_PTR       dwParam2)
{
    UINT            idx;
    DWORD           dwRet;
    DWORD           dwRetImmed;

    dwRet = 0;
    for (idx = 0; idx < pme->chMidi; idx++)
    {
        dwRetImmed = midiOutMessage((HMIDIOUT)pme->rIds[idx].hMidi, msg, dwParam1, dwParam2);
        if (dwRetImmed)
            dwRet = dwRetImmed;
    }

    return dwRet;
}

DWORD FAR PASCAL mseTimebase(
    PCLOCK                      pclock)
{
    return timeGetTime();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\midi.c ===
/*****************************************************************************
    midi.c

    Level 1 kitchen sink DLL midi support module

    Copyright (c) 1990-2001 Microsoft Corporation

*****************************************************************************/

#include "winmmi.h"
#define DO_DEFAULT_MIDI_MAPPER

/*****************************************************************************

    local structures

*****************************************************************************/


/*****************************************************************************

    internal prototypes

*****************************************************************************/


/*****************************************************************************

    segmentation

*****************************************************************************/

/*****************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @api MMRESULT | midiPrepareHeader | This function prepares the header and data
 *   if the driver returns MMSYSERR_NOTSUPPORTED.
 *
 * @rdesc Currently always returns MMSYSERR_NOERROR.
 ****************************************************************************/
STATIC MMRESULT   midiPrepareHeader(LPMIDIHDR lpMidiHdr, UINT wSize)
{
    if (!HugePageLock(lpMidiHdr, (DWORD)sizeof(MIDIHDR)))
    return MMSYSERR_NOMEM;

    if (!HugePageLock(lpMidiHdr->lpData, lpMidiHdr->dwBufferLength)) {
    HugePageUnlock(lpMidiHdr, (DWORD)sizeof(MIDIHDR));
    return MMSYSERR_NOMEM;
    }

    lpMidiHdr->dwFlags |= MHDR_PREPARED;

    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @api MMRESULT | midiUnprepareHeader | This function unprepares the header and
 *   data if the driver returns MMSYSERR_NOTSUPPORTED.
 *
 * @rdesc Currently always returns MMSYSERR_NOERROR.
 ****************************************************************************/
STATIC MMRESULT midiUnprepareHeader(LPMIDIHDR lpMidiHdr, UINT wSize)
{
    HugePageUnlock(lpMidiHdr->lpData, lpMidiHdr->dwBufferLength);
    HugePageUnlock(lpMidiHdr, (DWORD)sizeof(MIDIHDR));

    lpMidiHdr->dwFlags &= ~MHDR_PREPARED;

    return MMSYSERR_NOERROR;
}

/***************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @api MMRESULT | midiReferenceDriverById | This function maps a logical
 *      id to a device driver table index and physical id.
 *
 * @parm IN MIDIDRV | pmididrvZ | The list of midi drivers.
 *
 * @parm IN UINT | id | The logical id to be mapped.
 *
 * @parm OUT PMIDIDRV* OPTIONAL | ppmididrv | Pointer to MIDIDRV structure
 *    describing the driver supporting the id.
 *
 * @parm OUT UINT* OPTIONAL | pport | The driver-relative device number. If
 *    the caller supplies this buffer then it must also supply ppmididrv.
 *
 * @comm If the caller specifies ppmididrv then this function increments
 *       the mididrv's usage before returning.  The caller must ensure
 *       the usage is eventually decremented.
 *
 * @rdesc The return value is zero if successful, MMSYSERR_BADDEVICEID if
 *   the id is out of range.
 *
 * @rdesc The return value contains the dev[] array element in the high UINT and
 *   the driver physical device number in the low UINT.
 *
 * @comm Out of range values map to FFFF:FFFF
 ***************************************************************************/
MMRESULT midiReferenceDriverById(IN PMIDIDRV pmididrvZ, IN UINT id, OUT PMIDIDRV *ppmididrv OPTIONAL, OUT UINT *pport)
{
    PMIDIDRV pmididrv;
    MMRESULT mmr;
    
    // Should not be called asking for port but not mididrv
    WinAssert(!(pport && !ppmididrv));

    if (id == MIDI_MAPPER) {
        /*
        **  Make sure we tried to load the mapper
        */
        MidiMapperInit();
    }

    EnterNumDevs("midiReferenceDriverById");
    
    if (MIDI_MAPPER == id)
    {
        id = 0;
    	for (pmididrv = pmididrvZ->Next; pmididrv != pmididrvZ; pmididrv = pmididrv->Next)
    	{
    	    if (pmididrv->fdwDriver & MMDRV_MAPPER) break;
    	}
    } else {
    	for (pmididrv = pmididrvZ->Next; pmididrv != pmididrvZ; pmididrv = pmididrv->Next)
        {
            if (pmididrv->fdwDriver & MMDRV_MAPPER) continue;
            if (pmididrv->NumDevs > id) break;
            id -= pmididrv->NumDevs;
        }
    }

    if (pmididrv != pmididrvZ)
    {
    	if (ppmididrv)
    	{
    	    mregIncUsagePtr(pmididrv);
    	    *ppmididrv = pmididrv;
    	    if (pport) *pport = id;
    	}
    	mmr = MMSYSERR_NOERROR;
    } else {
        mmr = MMSYSERR_BADDEVICEID;
    }

    LeaveNumDevs("midiReferenceDriverById");
    
    return mmr;
}

PCWSTR midiReferenceDevInterfaceById(PMIDIDRV pdrvZ, UINT_PTR id)
{
    PMIDIDRV pdrv;
    PCWSTR DeviceInterface;
    
    if ((pdrvZ == &midioutdrvZ && ValidateHandle((HANDLE)id, TYPE_MIDIOUT)) ||
        (pdrvZ == &midiindrvZ  && ValidateHandle((HANDLE)id, TYPE_MIDIIN)))
    {
    	DeviceInterface = ((PMIDIDEV)id)->mididrv->cookie;
    	if (DeviceInterface) wdmDevInterfaceInc(DeviceInterface);
    	return DeviceInterface;
    }
    
    if (!midiReferenceDriverById(pdrvZ, (UINT)id, &pdrv, NULL))
    {
    	DeviceInterface = pdrv->cookie;
    	if (DeviceInterface) wdmDevInterfaceInc(DeviceInterface);
    	mregDecUsagePtr(pdrv);
    	return DeviceInterface;
    }

    return NULL;
}

/****************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @api MMRESULT | midiMessage | This function sends messages to the MIDI device
 *   drivers.
 *
 * @parm HMIDI | hMidi | The handle to the MIDI device.
 *
 * @parm UINT | wMsg | The message to send.
 *
 * @parm DWORD | dwP1 | Parameter 1.
 *
 * @parm DWORD | dwP2 | Parameter 2.
 *
 * @rdesc Returns the value of the message sent.
 ***************************************************************************/
STATIC MMRESULT midiMessage(HMIDI hMidi, UINT msg, DWORD_PTR dwP1, DWORD_PTR dwP2)
{
    MMRESULT mrc;
    
    ENTER_MM_HANDLE(hMidi);
    
    ReleaseHandleListResource();
    
    // Is handle deserted?
    
    if (IsHandleDeserted(hMidi))
    {
        LEAVE_MM_HANDLE(hMidi);
        return (MMSYSERR_NODRIVER);
    }
    
    //  Are we busy (in the middle of an open/close)?
    if (IsHandleBusy(hMidi))
    {
        LEAVE_MM_HANDLE(hMidi);
        return (MMSYSERR_HANDLEBUSY);
    }
    
    if (BAD_HANDLE(hMidi, TYPE_MIDIOUT) && BAD_HANDLE(hMidi, TYPE_MIDISTRM) &&
        BAD_HANDLE(hMidi, TYPE_MIDIIN) ) {
	    WinAssert(!"Bad Handle within midiMessage");
        mrc = MMSYSERR_INVALHANDLE;
    } else {
        mrc = (*(((PMIDIDEV)hMidi)->mididrv->drvMessage))
        (((PMIDIDEV)hMidi)->wDevice, msg, ((PMIDIDEV)hMidi)->dwDrvUser, dwP1, dwP2);
    }

    LEAVE_MM_HANDLE(hMidi);

    return mrc;
}

/****************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @func MMRESULT | midiIDMessage | This function sends a message to the device
 * ID specified.  It also performs error checking on the ID passed.
 *
 * @parm PMIDIDRV | mididrv | Pointer to the input or output device list.
 *
 * @parm UINT | wTotalNumDevs | Total number of devices in device list.
 *
 * @parm UINT | uDeviceID | Device ID to send message to.
 *
 * @parm UINT | wMessage | The message to send.
 *
 * @parm DWORD | dwParam1 | Parameter 1.
 *
 * @parm DWORD | dwParam2 | Parameter 2.
 *
 * @rdesc The return value is the low UINT of the returned message.
 ***************************************************************************/
STATIC  MMRESULT   midiIDMessage(
    PMIDIDRV    pmididrvZ,
    UINT        wTotalNumDevs,
    UINT_PTR    uDeviceID,
    UINT        wMessage,
    DWORD_PTR   dwParam1,
    DWORD_PTR   dwParam2)
{
    PMIDIDRV  mididrv;
    UINT      port;
    DWORD     mmr;
    DWORD     dwClass;

    if (uDeviceID>=wTotalNumDevs && uDeviceID!=MIDI_MAPPER) {
    // this cannot be a device ID.
    // it could be a device handle.  Try it.
    // First we have to verify which type of handle it is (OUT or IN)
    // We can work this out as midiIDMessage is only ever called with
    // mididrv== midioutdrv or midiindrv

    if ((pmididrvZ == &midioutdrvZ && ValidateHandle((HANDLE)uDeviceID, TYPE_MIDIOUT))
     || (pmididrvZ == &midiindrvZ && ValidateHandle((HANDLE)uDeviceID, TYPE_MIDIIN) )) {

        // to preserve as much compatibility with previous code paths
        // we do NOT call midiMessage as that calls ENTER_MM_HANDLE

        return (MMRESULT)(*(((PMIDIDEV)uDeviceID)->mididrv->drvMessage))
            (((PMIDIDEV)uDeviceID)->wDevice,
            wMessage,
            ((PMIDIDEV)uDeviceID)->dwDrvUser, dwParam1, dwParam2);
    } else {
        return(MMSYSERR_BADDEVICEID);
    }
    }

    // Get Physical Device, and Port
    mmr = midiReferenceDriverById(pmididrvZ, (UINT)uDeviceID, &mididrv, &port);
    if (mmr)
    {
        return mmr;
    }

    if (pmididrvZ == &midiindrvZ)
       dwClass = TYPE_MIDIIN;
    else if (pmididrvZ == &midioutdrvZ)
       dwClass = TYPE_MIDIOUT;
    else
       dwClass = TYPE_UNKNOWN;

    if (!mididrv->drvMessage)
        return MMSYSERR_NODRIVER;

    // Handle Internal Messages
    if (!mregHandleInternalMessages (mididrv, dwClass, port, wMessage, dwParam1, dwParam2, &mmr))
    {
        // Call Physical Device at Port
        mmr = (MMRESULT)((*(mididrv->drvMessage))(port, wMessage, 0L, dwParam1, dwParam2));
    }

    mregDecUsagePtr(mididrv);
    return mmr;
}


/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutGetNumDevs | This function retrieves the number of MIDI
 *   output devices present in the system.
 *
 * @rdesc Returns the number of MIDI output devices present in the system.
 *
 * @xref midiOutGetDevCaps
 ****************************************************************************/
UINT APIENTRY midiOutGetNumDevs(void)
{
    UINT cDevs;

    ClientUpdatePnpInfo();

    EnterNumDevs("midiOutGetNumDevs");
    cDevs = wTotalMidiOutDevs;
    LeaveNumDevs("midiOutGetNumDevs");

    return cDevs;
}

/****************************************************************************
 * @doc EXTERNAL MIDI
 *
 * @api MMRESULT | midiOutMessage | This function sends messages to the MIDI device
 *   drivers.
 *
 * @parm HMIDIOUT | hMidiOut | The handle to the MIDI device.
 *
 * @parm UINT  | msg | The message to send.
 *
 * @parm DWORD | dw1 | Parameter 1.
 *
 * @parm DWORD | dw2 | Parameter 2.
 *
 * @rdesc Returns the value of the message sent.
 ***************************************************************************/
MMRESULT APIENTRY midiOutMessage(HMIDIOUT hMidiOut, UINT msg, DWORD_PTR dw1, DWORD_PTR dw2)
{
    ClientUpdatePnpInfo();

    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE(hMidiOut, TYPE_MIDIOUT) && BAD_HANDLE(hMidiOut, TYPE_MIDISTRM))
    {
        ReleaseHandleListResource();
        return midiIDMessage(&midioutdrvZ, wTotalMidiOutDevs, (UINT_PTR)hMidiOut, msg, dw1, dw2);
    }

    switch(GetHandleType(hMidiOut))
    {
        case TYPE_MIDIOUT:
        return midiMessage((HMIDI)hMidiOut, msg, dw1, dw2);

        case TYPE_MIDISTRM:
        ReleaseHandleListResource();
        return midiStreamBroadcast(HtoPT(PMIDISTRM, hMidiOut), msg, dw1, dw2);
    }

    ReleaseHandleListResource();
    Squirt("We should never get here.");
    WinAssert(FALSE);

    //  Getting rid of warning.
    return MMSYSERR_INVALHANDLE;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiOutGetDevCaps | This function queries a specified
 *   MIDI output device to determine its capabilities.
 *
 * @parm UINT | uDeviceID | Identifies the MIDI output device.
 *
 * @parm LPMIDIOUTCAPS | lpCaps | Specifies a far pointer to a <t MIDIOUTCAPS>
 *   structure.  This structure is filled with information about the
 *   capabilities of the device.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIOUTCAPS> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *   @flag MMSYSERR_NOMEM | Unable load mapper string description.
 *
 * @comm Use <f midiOutGetNumDevs> to determine the number of MIDI output
 *   devices present in the system.  The device ID specified by <p uDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The MIDI_MAPPER constant may also be used as a device id. Only
 *   <p wSize> bytes (or less) of information is copied to the location
 *   pointed to by <p lpCaps>.  If <p wSize> is zero, nothing is copied,
 *   and the function returns zero.
 *
 * @xref midiOutGetNumDevs
 ****************************************************************************/
MMRESULT APIENTRY midiOutGetDevCapsW(UINT_PTR uDeviceID, LPMIDIOUTCAPSW lpCaps, UINT wSize)
{
    DWORD_PTR       dwParam1, dwParam2;
    MDEVICECAPSEX   mdCaps;
    PMIDIDRV        midioutdrv;
    PCWSTR          DevInterface;
    MMRESULT        mmr;

    if (wSize == 0)
    return MMSYSERR_NOERROR;

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    DevInterface = midiReferenceDevInterfaceById(&midioutdrvZ, uDeviceID);
    dwParam2 = (DWORD_PTR)DevInterface;
    
    if (0 == dwParam2)
    {
        dwParam1 = (DWORD_PTR)lpCaps;
        dwParam2 = (DWORD)wSize;
    }
    else
    {
        mdCaps.cbSize = (DWORD)wSize;
        mdCaps.pCaps  = lpCaps;
        dwParam1      = (DWORD_PTR)&mdCaps;
    }

    //
    //  Don't allow non proper drivers in TS environement
    //
    // ISSUE-2001/01/09-FrankYe Instead of cast to UINT.  Should check whether
    //    this is a handle and get wavedrv from handle if it is.
    midioutdrv = NULL;
    if ((!midiReferenceDriverById(&midioutdrvZ, (UINT)uDeviceID, &midioutdrv, NULL)) &&
    	lstrcmpW(midioutdrv->wszSessProtocol, SessionProtocolName))
    {
        mmr = MMSYSERR_NODRIVER;
    }
    else
    {
        AcquireHandleListResourceShared();

        if (BAD_HANDLE((HMIDI)uDeviceID, TYPE_MIDIOUT))
        {
            ReleaseHandleListResource();
    	    mmr = midiIDMessage( &midioutdrvZ, wTotalMidiOutDevs, uDeviceID, MODM_GETDEVCAPS, dwParam1, dwParam2 );
        }
        else
        {
    	    mmr = (MMRESULT)midiMessage((HMIDI)uDeviceID, MODM_GETDEVCAPS, dwParam1, dwParam2);
        }
    }

    if (midioutdrv) mregDecUsagePtr(midioutdrv);
    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    return mmr;
}

MMRESULT APIENTRY midiOutGetDevCapsA(UINT_PTR uDeviceID, LPMIDIOUTCAPSA lpCaps, UINT wSize)
{
    MIDIOUTCAPS2W   wDevCaps2;
    MIDIOUTCAPS2A   aDevCaps2;
    DWORD_PTR       dwParam1, dwParam2;
    MDEVICECAPSEX   mdCaps;
    MMRESULT        mmRes;
    PMIDIDRV        midioutdrv;
    CHAR            chTmp[ MAXPNAMELEN * sizeof(WCHAR) ];
    PCWSTR          DevInterface;

    if (wSize == 0)
    return MMSYSERR_NOERROR;

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    DevInterface = midiReferenceDevInterfaceById(&midioutdrvZ, uDeviceID);
    dwParam2 = (DWORD_PTR)DevInterface;

    memset(&wDevCaps2, 0, sizeof(wDevCaps2));

    if (0 == dwParam2)
    {
        dwParam1 = (DWORD_PTR)&wDevCaps2;
        dwParam2 = (DWORD)sizeof(wDevCaps2);
    }
    else
    {
        mdCaps.cbSize = (DWORD)sizeof(wDevCaps2);
        mdCaps.pCaps  = &wDevCaps2;
        dwParam1      = (DWORD_PTR)&mdCaps;
    }

    //
    //  Don't allow non proper drivers in TS environement
    //
    // ISSUE-2001/01/09-FrankYe Bad cast to UINT.  Should check whether this
    //    is a handle and get wavedrv from handle if it is.
    midioutdrv = NULL;
    if ( uDeviceID < wTotalMidiOutDevs &&
         !midiReferenceDriverById(&midioutdrvZ, (UINT)uDeviceID, &midioutdrv, NULL) &&
    	 lstrcmpW(midioutdrv->wszSessProtocol, SessionProtocolName) )
    {
    	mregDecUsagePtr(midioutdrv);
    	if (DevInterface) wdmDevInterfaceDec(DevInterface);
    	return MMSYSERR_NODRIVER;
    }

    AcquireHandleListResourceShared();
    if (BAD_HANDLE((HMIDI)uDeviceID, TYPE_MIDIOUT))
    {
        ReleaseHandleListResource();
        mmRes = midiIDMessage( &midioutdrvZ, wTotalMidiOutDevs, (UINT)uDeviceID,
                               MODM_GETDEVCAPS, dwParam1,
                               dwParam2);
    }
    else
    {
        mmRes = midiMessage((HMIDI)uDeviceID, MODM_GETDEVCAPS,
                            dwParam1, dwParam2);
    }

    if (midioutdrv) mregDecUsagePtr(midioutdrv);
    if (DevInterface) wdmDevInterfaceDec(DevInterface);

    //
    // Make sure the call worked before proceeding with the thunk.
    //
    if ( mmRes != MMSYSERR_NOERROR ) {
    return  mmRes;
    }

    aDevCaps2.wMid             = wDevCaps2.wMid;
    aDevCaps2.wPid             = wDevCaps2.wPid;
    aDevCaps2.vDriverVersion   = wDevCaps2.vDriverVersion;
    aDevCaps2.wTechnology      = wDevCaps2.wTechnology;
    aDevCaps2.wVoices          = wDevCaps2.wVoices;
    aDevCaps2.wNotes           = wDevCaps2.wNotes;
    aDevCaps2.wChannelMask     = wDevCaps2.wChannelMask;
    aDevCaps2.dwSupport        = wDevCaps2.dwSupport;
    aDevCaps2.ManufacturerGuid = wDevCaps2.ManufacturerGuid;
    aDevCaps2.ProductGuid      = wDevCaps2.ProductGuid;
    aDevCaps2.NameGuid         = wDevCaps2.NameGuid;

    // copy and convert lpwText to lpText here.
    UnicodeStrToAsciiStr( chTmp, chTmp + sizeof( chTmp ), wDevCaps2.szPname );
    strcpy( aDevCaps2.szPname, chTmp );

    //
    // now copy the required amount into the callers buffer.
    //
    CopyMemory( lpCaps, &aDevCaps2, min(wSize, sizeof(aDevCaps2)));

    return mmRes;
}

/*****************************************************************************
 * @doc EXTERNAL MIDI
 *
 * @api MMRESULT | midiOutGetVolume | This function returns the current volume
 *   setting of a MIDI output device.
 *
 * @parm UINT | uDeviceID | Identifies the MIDI output device.
 *
 * @parm LPDWORD | lpdwVolume | Specifies a far pointer to a location
 *   to be filled with the current volume setting. The low-order UINT of
 *   this location contains the left channel volume setting, and the high-order
 *   UINT contains the right channel setting. A value of 0xFFFF represents
 *   full volume, and a value of 0x0000 is silence.
 *
 *   If a device does not support both left and right volume
 *   control, the low-order UINT of the specified location contains
 *   the mono volume level.
 *
 *   The full 16-bit setting(s)
 *   set with <f midiOutSetVolume> is returned, regardless of whether
 *   the device supports the full 16 bits of volume level control.
 *
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Not all devices support volume control. To determine whether the
 *   device supports volume control, use the MIDICAPS_VOLUME
 *   flag to test the <e MIDIOUTCAPS.dwSupport> field of the <t MIDIOUTCAPS>
 *   structure (filled by <f midiOutGetDevCaps>).
 *
 *   To determine whether the device supports volume control on both the
 *   left and right channels, use the MIDICAPS_LRVOLUME flag to test
 *   the <e MIDIOUTCAPS.dwSupport> field of the <t MIDIOUTCAPS>
 *   structure (filled by <f midiOutGetDevCaps>).
 *
 * @xref midiOutSetVolume
 ****************************************************************************/
MMRESULT APIENTRY midiOutGetVolume(HMIDIOUT hmo, LPDWORD lpdwVolume)
{
    PCWSTR      DevInterface;
    MMRESULT    mmr;

    V_WPOINTER(lpdwVolume, sizeof(DWORD), MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    DevInterface = midiReferenceDevInterfaceById(&midioutdrvZ, (UINT_PTR)hmo);

    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE(hmo, TYPE_MIDIOUT) && BAD_HANDLE(hmo, TYPE_MIDISTRM))
    {
        ReleaseHandleListResource();
    	mmr = midiIDMessage(&midioutdrvZ, wTotalMidiOutDevs, (UINT_PTR)hmo, MODM_GETVOLUME, (DWORD_PTR)lpdwVolume, (DWORD_PTR)DevInterface);
    }
    else
    {
        switch(GetHandleType(hmo))
        {
        case TYPE_MIDIOUT:
            mmr = (MMRESULT)midiMessage((HMIDI)hmo, MODM_GETVOLUME, (DWORD_PTR)lpdwVolume, (DWORD_PTR)DevInterface);
            break;

        case TYPE_MIDISTRM:
            ENTER_MM_HANDLE((HMIDI)hmo);    
            ReleaseHandleListResource();
            mmr = (MMRESULT)midiStreamMessage(HtoPT(PMIDISTRM, hmo)->rgIds, MODM_GETVOLUME, (DWORD_PTR)lpdwVolume, (DWORD_PTR)DevInterface);
            LEAVE_MM_HANDLE((HMIDI)hmo);    
            break;

        default:
            WinAssert(FALSE);
            ReleaseHandleListResource();
            mmr = MMSYSERR_INVALHANDLE;
            break;
        }
    }

    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    return mmr;

}

/*****************************************************************************
 * @doc EXTERNAL MIDI
 *
 * @api MMRESULT | midiOutSetVolume | This function sets the volume of a
 *      MIDI output device.
 *
 * @parm UINT | uDeviceID | Identifies the MIDI output device.
 *
 * @parm DWORD | dwVolume | Specifies the new volume setting.
 *   The low-order UINT contains the left channel volume setting, and the
 *   high-order UINT contains the right channel setting. A value of
 *   0xFFFF represents full volume, and a value of 0x0000 is silence.
 *
 *   If a device does not support both left and right volume
 *   control, the low-order UINT of <p dwVolume> specifies the volume
 *   level, and the high-order UINT is ignored.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Not all devices support volume changes. To determine whether the
 *   device supports volume control, use the MIDICAPS_VOLUME
 *   flag to test the <e MIDIOUTCAPS.dwSupport> field of the <t MIDIOUTCAPS>
 *   structure (filled by <f midiOutGetDevCaps>).
 *
 *   To determine whether the device supports volume control on both the
 *   left and right channels, use the MIDICAPS_LRVOLUME flag to test
 *   the <e MIDIOUTCAPS.dwSupport> field of the <t MIDIOUTCAPS>
 *   structure (filled by <f midiOutGetDevCaps>).
 *
 *   Most devices do not support the full 16 bits of volume level control
 *   and will use only the high-order bits of the requested volume setting.
 *   For example, for a device that supports 4 bits of volume control,
 *   requested volume level values of 0x4000, 0x4fff, and 0x43be will
 *   all produce the same physical volume setting, 0x4000. The
 *   <f midiOutGetVolume> function will return the full 16-bit setting set
 *   with <f midiOutSetVolume>.
 *
 *   Volume settings are interpreted logarithmically. This means the
 *   perceived increase in volume is the same when increasing the
 *   volume level from 0x5000 to 0x6000 as it is from 0x4000 to 0x5000.
 *
 * @xref midiOutGetVolume
 ****************************************************************************/
MMRESULT APIENTRY midiOutSetVolume(HMIDIOUT hmo, DWORD dwVolume)
{
    PCWSTR   DevInterface;
    MMRESULT mmr;
 
    ClientUpdatePnpInfo();

    DevInterface = midiReferenceDevInterfaceById(&midioutdrvZ, (UINT_PTR)hmo);

    AcquireHandleListResourceShared();
    if (BAD_HANDLE(hmo, TYPE_MIDIOUT) && BAD_HANDLE(hmo, TYPE_MIDISTRM))
    {
        ReleaseHandleListResource();
    	mmr = midiIDMessage(&midioutdrvZ, wTotalMidiOutDevs, (UINT_PTR)hmo, MODM_SETVOLUME, dwVolume, (DWORD_PTR)DevInterface);
    }
    else
    {
        switch(GetHandleType(hmo))
        {
            case TYPE_MIDIOUT:
               mmr = (MMRESULT)midiMessage((HMIDI)hmo, MODM_SETVOLUME, (DWORD)dwVolume, (DWORD_PTR)DevInterface);
               break;

            case TYPE_MIDISTRM:
                ReleaseHandleListResource();
                mmr = (MMRESULT)midiStreamBroadcast(HtoPT(PMIDISTRM, hmo), MODM_SETVOLUME, (DWORD)dwVolume, (DWORD_PTR)DevInterface);
                break;

            default:
                ReleaseHandleListResource();
            	WinAssert(FALSE);
            	mmr = MMSYSERR_INVALHANDLE;
            	break;
        }
    }

    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    return mmr;
}

/*****************************************************************************
 * @doc INTERNAL MIDI
 *
 * @func MMRESULT | midiGetErrorText | This function retrieves a textual
 *   description of the error identified by the specified error number.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPTSTR | lpText | Specifies a far pointer to a buffer which
 *   is filled with the textual error description.
 *
 * @parm UINT | wSize | Specifies the length in characters of the buffer
 *   pointed to by <p lpText>.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADERRNUM | Specified error number is out of range.
 *
 * @comm If the textual error description is longer than the specified buffer,
 *   the description is truncated.  The returned error string is always
 *   null-terminated. If <p wSize> is zero, nothing is copied and MMSYSERR_NOERROR
 *   is returned.  All error descriptions are less than 80 characters long.
 ****************************************************************************/

STATIC MMRESULT midiGetErrorTextW(UINT wError, LPWSTR lpText, UINT wSize)
{
    lpText[0] = 0;

#if MMSYSERR_BASE
    if (((wError < MMSYSERR_BASE) || (wError > MMSYSERR_LASTERROR)) && ((wError < MIDIERR_BASE) || (wError > MIDIERR_LASTERROR)))
#else
    if ((wError > MMSYSERR_LASTERROR) && ((wError < MIDIERR_BASE) || (wError > MIDIERR_LASTERROR)))
#endif
    return MMSYSERR_BADERRNUM;

    if (wSize > 1)
    {
    if (!LoadStringW(ghInst, wError, lpText, wSize))
        return MMSYSERR_BADERRNUM;
    }

    return MMSYSERR_NOERROR;
}

STATIC MMRESULT midiGetErrorTextA(UINT wError, LPSTR lpText, UINT wSize)
{
    lpText[0] = 0;

#if MMSYSERR_BASE
    if (((wError < MMSYSERR_BASE) || (wError > MMSYSERR_LASTERROR)) && ((wError < MIDIERR_BASE) || (wError > MIDIERR_LASTERROR)))
#else
    if ((wError > MMSYSERR_LASTERROR) && ((wError < MIDIERR_BASE) || (wError > MIDIERR_LASTERROR)))
#endif
    return MMSYSERR_BADERRNUM;

    if (wSize > 1)
    {
    if (!LoadStringA(ghInst, wError, lpText, wSize))
        return MMSYSERR_BADERRNUM;
    }

    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiOutGetErrorText | This function retrieves a textual
 *   description of the error identified by the specified error number.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPTSTR | lpText | Specifies a far pointer to a buffer to be
 *   filled with the textual error description.
 *
 * @parm UINT | wSize | Specifies the length in characters of the buffer
 *   pointed to by <p lpText>.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADERRNUM | Specified error number is out of range.
 *
 * @comm If the textual error description is longer than the specified buffer,
 *   the description is truncated.  The returned error string is always
 *   null-terminated. If <p wSize> is zero, nothing is copied, and the
 *   function returns MMSYSERR_NOERROR.  All error descriptions are
 *   less than MAXERRORLENGTH characters long.
 ****************************************************************************/
MMRESULT APIENTRY midiOutGetErrorTextW(UINT wError, LPWSTR lpText, UINT wSize)
{
    if(wSize == 0)
    return MMSYSERR_NOERROR;

    V_WPOINTER(lpText, wSize*sizeof(WCHAR), MMSYSERR_INVALPARAM);

    return midiGetErrorTextW(wError, lpText, wSize);
}

MMRESULT APIENTRY midiOutGetErrorTextA(UINT wError, LPSTR lpText, UINT wSize)
{
    if(wSize == 0)
    return MMSYSERR_NOERROR;

    V_WPOINTER(lpText, wSize, MMSYSERR_INVALPARAM);

    return midiGetErrorTextA(wError, lpText, wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiOutOpen | This function opens a specified MIDI
 *   output device for playback.
 *
 * @parm LPHMIDIOUT | lphMidiOut | Specifies a far pointer to an HMIDIOUT
 *   handle.  This location is filled with a handle identifying the opened
 *   MIDI output device.  Use the handle to identify the device when calling
 *   other MIDI output functions.
 *
 * @parm UINT | uDeviceID | Identifies the MIDI output device that is
 *   to be opened.
 *
 * @parm DWORD | dwCallback | Specifies the address of a fixed callback
 *   function or
 *   a handle to a window called during MIDI playback to process
 *   messages related to the progress of the playback.  Specify NULL
 *   for this parameter if no callback is desired.
 *
 * @parm DWORD | dwCallbackInstance | Specifies user instance data
 *   passed to the callback.  This parameter is not used with
 *   window callbacks.
 *
 * @parm DWORD | dwFlags | Specifies a callback flag for opening the device.
 *   @flag CALLBACK_WINDOW | If this flag is specified, <p dwCallback> is
 *      assumed to be a window handle.
 *   @flag CALLBACK_FUNCTION | If this flag is specified, <p dwCallback> is
 *      assumed to be a callback procedure address.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are as follows:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_ALLOCATED | Specified resource is already allocated.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *   @flag MIDIERR_NOMAP | There is no current MIDI map. This occurs only
 *   when opening the mapper.
 *   @flag MIDIERR_NODEVICE | A port in the current MIDI map doesn't exist.
 *   This occurs only when opening the mapper.
 *
 * @comm Use <f midiOutGetNumDevs> to determine the number of MIDI output
 *   devices present in the system.  The device ID specified by <p uDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   You may also specify MIDI_MAPPER as the device ID to open the MIDI mapper.
 *
 *   If a window is chosen to receive callback information, the following
 *   messages are sent to the window procedure function to indicate the
 *   progress of MIDI output:  <m MM_MOM_OPEN>, <m MM_MOM_CLOSE>,
 *   <m MM_MOM_DONE>.
 *
 *   If a function is chosen to receive callback information, the following
 *   messages are sent to the function to indicate the progress of MIDI
 *   output: <m MOM_OPEN>, <m MOM_CLOSE>, <m MOM_DONE>.  The callback function
 *   must reside in a DLL.  You do not have to use <f MakeProcInstance> to
 *   get a procedure-instance address for the callback function.
 *
 * @cb void CALLBACK | MidiOutFunc | <f MidiOutFunc> is a placeholder for
 *   the application-supplied function name.  The actual name must be
 *   exported by including it in an EXPORTS statement in the DLL's
 *   module-definition file.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI device
 *   associated with the callback.
 *
 * @parm UINT | wMsg | Specifies a MIDI output message.
 *
 * @parm DWORD | dwInstance | Specifies the instance data
 *   supplied with <f midiOutOpen>.
 *
 * @parm DWORD | dwParam1 | Specifies a parameter for the message.
 *
 * @parm DWORD | dwParam2 | Specifies a parameter for the message.
 *
 * @comm Because the callback is accessed at interrupt time, it must reside
 *   in a DLL and its code segment must be specified as FIXED in the
 *   module-definition file for the DLL.  Any data that the callback accesses
 *   must be in a FIXED data segment as well. The callback may not make any
 *   system calls except for <f PostMessage>, <f timeGetSystemTime>,
 *   <f timeGetTime>, <f timeSetEvent>, <f timeKillEvent>,
 *   <f midiOutShortMsg>, <f midiOutLongMsg>, and <f OutputDebugStr>.
 *
 * @xref midiOutClose
 ****************************************************************************/
MMRESULT APIENTRY midiOutOpen(LPHMIDIOUT lphMidiOut, UINT uDeviceID,
    DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD dwFlags)
{
    MIDIOPENDESC mo;
    PMIDIDEV     pdev;
    PMIDIDRV     mididrv;
    UINT         port;
    MMRESULT     wRet;

    V_WPOINTER(lphMidiOut, sizeof(HMIDIOUT), MMSYSERR_INVALPARAM);
    if (uDeviceID == MIDI_MAPPER) {
    V_FLAGS(LOWORD(dwFlags), MIDI_O_VALID & ~LOWORD(MIDI_IO_SHARED | MIDI_IO_COOKED), midiOutOpen, MMSYSERR_INVALFLAG);
    } else {
    V_FLAGS(LOWORD(dwFlags), MIDI_O_VALID & ~LOWORD(MIDI_IO_COOKED), midiOutOpen, MMSYSERR_INVALFLAG);
    }
    V_DCALLBACK(dwCallback, HIWORD(dwFlags), MMSYSERR_INVALPARAM);

    *lphMidiOut = NULL;

    ClientUpdatePnpInfo();

    wRet = midiReferenceDriverById(&midioutdrvZ, uDeviceID, &mididrv, &port);
    if (wRet)
    {
        return wRet;
    }

    //
    //  check if the device is appropriate for the current TS session
    //
    if (!(mididrv->fdwDriver & MMDRV_MAPPER) &&
    	lstrcmpW(mididrv->wszSessProtocol, SessionProtocolName))
    {
    	mregDecUsagePtr(mididrv);
        return MMSYSERR_NODRIVER;
    }

#ifdef DO_DEFAULT_MIDI_MAPPER
    /* Default midi mapper :
     *
     * If a midi mapper is installed as a separate DLL then all midi mapper
     * messages are routed to it. If no midi mapper is installed, simply
     * loop through the midi devices looking for a match.
     */
    if ((uDeviceID == MIDI_MAPPER && !mididrv->drvMessage)) {
        UINT    wErr = MMSYSERR_NODRIVER;
        UINT    cMax;

        mregDecUsagePtr(mididrv);
        
        cMax = wTotalMidiOutDevs;

        for (uDeviceID=0; uDeviceID<cMax; uDeviceID++) {
            wErr = midiOutOpen(lphMidiOut, uDeviceID, dwCallback, dwInstance, dwFlags);
            if (wErr == MMSYSERR_NOERROR)
                break;
        }
        return wErr;
    }
#endif // DO_DEFAULT_MIDI_MAPPER

    if (!mididrv->drvMessage)
    {
    	mregDecUsagePtr(mididrv);
        return MMSYSERR_NODRIVER;
    }

    pdev = (PMIDIDEV)NewHandle(TYPE_MIDIOUT, mididrv->cookie, sizeof(MIDIDEV));
    if( pdev == NULL)
    {
    	mregDecUsagePtr(mididrv);
        return MMSYSERR_NOMEM;
    }
    
    ENTER_MM_HANDLE(pdev);
    SetHandleFlag(pdev, MMHANDLE_BUSY);
    ReleaseHandleListResource();

    pdev->mididrv = mididrv;
    pdev->wDevice = port;
    pdev->uDeviceID = uDeviceID;
    pdev->fdwHandle = 0;

    mo.hMidi      = (HMIDI)pdev;
    mo.dwInstance = dwInstance;
    mo.dwCallback = dwCallback;
    mo.dnDevNode  = (DWORD_PTR)pdev->mididrv->cookie;

    wRet = (MMRESULT)((*(mididrv->drvMessage))
                     (pdev->wDevice, MODM_OPEN, (DWORD_PTR)&pdev->dwDrvUser, (DWORD_PTR)(LPMIDIOPENDESC)&mo, dwFlags));

    //  Mark as not busy on successful open...
    if (!wRet)
        ClearHandleFlag(pdev, MMHANDLE_BUSY);
        
    LEAVE_MM_HANDLE(pdev);

    if (wRet)
        FreeHandle((HMIDIOUT)pdev);
    else {
        //  Workaround for Bug#330817
        mregIncUsagePtr(mididrv);
        *lphMidiOut = (HMIDIOUT)pdev;
    }

    mregDecUsagePtr(mididrv);
    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiOutClose | This function closes the specified MIDI
 *   output device.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output device.
 *  If the function is successful, the handle is no longer
 *   valid after this call.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_STILLPLAYING | There are still buffers in the queue.
 *
 * @comm If there are output buffers that have been sent with
 *   <f midiOutLongMsg> and haven't been returned to the application,
 *   the close operation will fail.  Call <f midiOutReset> to mark all
 *   pending buffers as being done.
 *
 * @xref midiOutOpen midiOutReset
 ****************************************************************************/
MMRESULT APIENTRY midiOutClose(HMIDIOUT hMidiOut)
{
    MMRESULT        wRet;
    PMIDIDRV        pmididrv;
    PMIDIDEV        pDev = (PMIDIDEV)hMidiOut;

    ClientUpdatePnpInfo();
    
    V_HANDLE_ACQ(hMidiOut, TYPE_MIDIOUT, MMSYSERR_INVALHANDLE);
    
    ENTER_MM_HANDLE((HMIDI)hMidiOut);
    ReleaseHandleListResource();
    
    if (IsHandleDeserted(hMidiOut))
    {
        //  This handle has been deserted.  Let's just free it.

        LEAVE_MM_HANDLE((HMIDI)hMidiOut);
        FreeHandle(hMidiOut);
        return MMSYSERR_NOERROR;
    }

    if (IsHandleBusy(hMidiOut))
    {
        //  Not quite invalid, but marked as closed.
    
        LEAVE_MM_HANDLE(hMidiOut);
        return (MMSYSERR_HANDLEBUSY);
    }

    //  Marking handle as 'invalid/closed'.
    SetHandleFlag(hMidiOut, MMHANDLE_BUSY);
    
    pmididrv = pDev->mididrv;
    
    wRet = (MMRESULT)(*pmididrv->drvMessage)(pDev->wDevice, MODM_CLOSE, pDev->dwDrvUser, 0L, 0L);
    
    if (MMSYSERR_NOERROR != wRet)
    {
        //  Error closing, set the flag as valid.
        ClearHandleFlag(hMidiOut, MMHANDLE_BUSY);
    }
    
    LEAVE_MM_HANDLE((HMIDI)hMidiOut);
    
    if (!wRet)
    {
        FreeHandle(hMidiOut);
    	mregDecUsagePtr(pmididrv);
        return wRet;
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiOutPrepareHeader | This function prepares a MIDI
 *   system-exclusive data block for output.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output
 *   device.
 *
 * @parm LPMIDIHDR | lpMidiOutHdr | Specifies a far pointer to a <t MIDIHDR>
 *   structure that identifies the data block to be prepared.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *
 * @comm The <t MIDIHDR> data structure and the data block pointed to by its
 *   <e MIDIHDR.lpData> field must be allocated with <f GlobalAlloc> using the
 *   GMEM_MOVEABLE and GMEM_SHARE flags and locked with <f GlobalLock>.
 *   Preparing a header that has already been prepared has no effect, and
 *   the function returns zero.
 *
 * @xref midiOutUnprepareHeader
 ****************************************************************************/
MMRESULT APIENTRY midiOutPrepareHeader(HMIDIOUT hMidiOut, LPMIDIHDR lpMidiOutHdr, UINT wSize)
{
    MMRESULT         wRet;
    LPMIDIHDR        lpmh;
    PMIDISTRM        pms;
    PMIDISTRMID      pmsi;
    DWORD            idx;
#ifdef DEBUG
    DWORD            cDrvrs;
#endif
    DWORD            dwSaveFlags;


    V_HEADER(lpMidiOutHdr, wSize, TYPE_MIDIOUT, MMSYSERR_INVALPARAM);

    if (lpMidiOutHdr->dwFlags & MHDR_PREPARED)
        return MMSYSERR_NOERROR;

    lpMidiOutHdr->dwFlags = 0;

    ClientUpdatePnpInfo();

    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE(hMidiOut, TYPE_MIDIOUT) && BAD_HANDLE(hMidiOut, TYPE_MIDISTRM))
    {
        ReleaseHandleListResource();
        return MMSYSERR_INVALHANDLE;
    }
    
    switch(GetHandleType(hMidiOut))
    {
        case TYPE_MIDIOUT:
            dwSaveFlags = lpMidiOutHdr->dwFlags & MHDR_SAVE;
            wRet = midiMessage((HMIDI)hMidiOut, MODM_PREPARE, (DWORD_PTR)lpMidiOutHdr, (DWORD)wSize);
            lpMidiOutHdr->dwFlags &= ~MHDR_SAVE;
            lpMidiOutHdr->dwFlags |= dwSaveFlags;

            if (MMSYSERR_NOTSUPPORTED == wRet)
                return midiPrepareHeader(lpMidiOutHdr, wSize);

            return wRet;

        case TYPE_MIDISTRM:
            ENTER_MM_HANDLE((HMIDI)hMidiOut);
            ReleaseHandleListResource(); 
    
            pms = HtoPT(PMIDISTRM, hMidiOut);

            if (lpMidiOutHdr->dwBufferLength > 65536L)
            {
                LEAVE_MM_HANDLE((HMIDI)hMidiOut);
                return MMSYSERR_INVALPARAM;
            }

            lpmh = (LPMIDIHDR)winmmAlloc(sizeof(MIDIHDR) *
                                                pms->cDrvrs);
            if (NULL == lpmh)
            {
                LEAVE_MM_HANDLE((HMIDI)hMidiOut);
                return MMSYSERR_NOMEM;
            }

            lpMidiOutHdr->dwReserved[MH_SHADOW] = (DWORD_PTR)lpmh;

//                 assert ((HIWORD(lpmh) & 0xFFFE) != (HIWORD(lpMidiOutHdr) & 0xFFFE));

#ifdef DEBUG
            cDrvrs = 0;
#endif
            wRet = MMSYSERR_ERROR;
            for (idx = 0, pmsi = pms->rgIds; idx < pms->cIds; idx++, pmsi++)
                if (pmsi->fdwId & MSI_F_FIRST)
                {
                    *lpmh = *lpMidiOutHdr;

                    lpmh->dwReserved[MH_PARENT] = (DWORD_PTR)lpMidiOutHdr;
                    lpmh->dwReserved[MH_SHADOW] = 0;
                    lpmh->dwFlags =
                        (lpMidiOutHdr->dwFlags & MHDR_MAPPED) | MHDR_SHADOWHDR;


                    dwSaveFlags = lpmh->dwFlags & MHDR_SAVE;
                    wRet = (MMRESULT)midiStreamMessage(pmsi, MODM_PREPARE, (DWORD_PTR)lpmh, (DWORD)sizeof(MIDIHDR));
                    lpmh->dwFlags &= ~MHDR_SAVE;
                    lpmh->dwFlags |= dwSaveFlags;
                    if (MMSYSERR_NOTSUPPORTED == wRet)
                        wRet = midiPrepareHeader(lpmh, sizeof(MIDIHDR));

                    if (MMSYSERR_NOERROR != wRet)
                        break;


                    lpmh++;
#ifdef DEBUG
                    ++cDrvrs;
                    if (cDrvrs > pms->cDrvrs)
                        dprintf1(("!Too many drivers in midiOutPrepareHeader()!!!"));
#endif
                }

            if (MMSYSERR_NOERROR == wRet)
                wRet = midiPrepareHeader(lpMidiOutHdr, wSize);
            else
            {
                for (idx = 0, pmsi = pms->rgIds; idx < pms->cIds; idx++, pmsi++)
                    if (pmsi->fdwId & MSI_F_FIRST)
                    {
                        dwSaveFlags = lpmh->dwFlags & MHDR_SAVE;
                        wRet = (MMRESULT)midiStreamMessage(pmsi, MODM_UNPREPARE, (DWORD_PTR)lpmh, (DWORD)sizeof(MIDIHDR));
                        lpmh->dwFlags &= ~MHDR_SAVE;
                        lpmh->dwFlags |= dwSaveFlags;
                        if (MMSYSERR_NOTSUPPORTED == wRet)
                            wRet = midiUnprepareHeader(lpmh, sizeof(MIDIHDR));
                    }
            }

            LEAVE_MM_HANDLE((HMIDI)hMidiOut);

            return wRet;
            
        default:
            ReleaseHandleListResource(); 
            break;
    }

    return MMSYSERR_INVALHANDLE;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiOutUnprepareHeader | This function cleans up the
 * preparation performed by <f midiOutPrepareHeader>. The
 * <f midiOutUnprepareHeader> function must be called
 * after the device driver fills a data buffer and returns it to the
 * application. You must call this function before freeing the data
 * buffer.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output
 *   device.
 *
 * @parm LPMIDIHDR | lpMidiOutHdr |  Specifies a pointer to a <t MIDIHDR>
 *   structure identifying the buffer to be cleaned up.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_STILLPLAYING | <p lpMidiOutHdr> is still in the queue.
 *
 * @comm This function is the complementary function to
 * <f midiOutPrepareHeader>.
 * You must call this function before freeing the data buffer with
 * <f GlobalFree>.
 * After passing a buffer to the device driver with <f midiOutLongMsg>, you
 * must wait until the driver is finished with the buffer before calling
 * <f midiOutUnprepareHeader>.
 *
 * Unpreparing a buffer that has not been
 * prepared has no effect, and the function returns zero.
 *
 * @xref midiOutPrepareHeader
 ****************************************************************************/
MMRESULT APIENTRY midiOutUnprepareHeader(HMIDIOUT hMidiOut, LPMIDIHDR lpMidiOutHdr, UINT wSize)
{
    MMRESULT         wRet;
    MMRESULT                 mmrc;
    PMIDISTRM        pms;
    PMIDISTRMID      pmsi;
    DWORD            idx;
    LPMIDIHDR        lpmh;
    DWORD            dwSaveFlags;

    V_HEADER(lpMidiOutHdr, wSize, TYPE_MIDIOUT, MMSYSERR_INVALPARAM);
    
    if (!(lpMidiOutHdr->dwFlags & MHDR_PREPARED))
        return MMSYSERR_NOERROR;

    if(lpMidiOutHdr->dwFlags & MHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING, "midiOutUnprepareHeader: header still in queue\r\n");
        return MIDIERR_STILLPLAYING;
    }
    
    ClientUpdatePnpInfo();
    
    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE(hMidiOut, TYPE_MIDIOUT) && BAD_HANDLE(hMidiOut, TYPE_MIDISTRM))
    {
        ReleaseHandleListResource();
        return MMSYSERR_INVALHANDLE;
    }

    switch(GetHandleType(hMidiOut))
    {
        case TYPE_MIDIOUT:
            dwSaveFlags = lpMidiOutHdr->dwFlags & MHDR_SAVE;
            wRet = midiMessage((HMIDI)hMidiOut, MODM_UNPREPARE, (DWORD_PTR)lpMidiOutHdr, (DWORD)wSize);
            lpMidiOutHdr->dwFlags &= ~MHDR_SAVE;
            lpMidiOutHdr->dwFlags |= dwSaveFlags;

            if (wRet == MMSYSERR_NOTSUPPORTED)
                return midiUnprepareHeader(lpMidiOutHdr, wSize);

            if ((wRet == MMSYSERR_NODRIVER) && (IsHandleDeserted(hMidiOut)))
            {
                //  if the driver for the handle has been removed, succeed
                //  the call.

                wRet = MMSYSERR_NOERROR;
            }

            return wRet;

         case TYPE_MIDISTRM:
            ENTER_MM_HANDLE((HMIDI)hMidiOut);
            ReleaseHandleListResource(); 
    
            pms = HtoPT(PMIDISTRM, hMidiOut);
            wRet = MMSYSERR_NOERROR;
            lpmh = (LPMIDIHDR)lpMidiOutHdr->dwReserved[MH_SHADOW];

//                       assert ((HIWORD(lpmh) & 0xFFFE) != (HIWORD(lpMidiOutHdr) & 0xFFFE));

            for (idx = 0, pmsi = pms->rgIds; idx < pms->cIds; idx++, pmsi++)
                if (pmsi->fdwId & MSI_F_FIRST)
                {
                    dwSaveFlags = lpmh->dwFlags & MHDR_SAVE;
                    mmrc = (MMRESULT)midiStreamMessage(pmsi, MODM_UNPREPARE, (DWORD_PTR)lpmh, (DWORD)sizeof(MIDIHDR));
                    lpmh->dwFlags &= ~MHDR_SAVE;
                    lpmh->dwFlags |= dwSaveFlags;
                    if (MMSYSERR_NOTSUPPORTED == mmrc)
                        mmrc = midiUnprepareHeader(lpmh, sizeof(MIDIHDR));

                    if (MMSYSERR_NOERROR != mmrc)
                        wRet = mmrc;

                    lpmh++;
                }

//                       assert (HIWORD(lpmh) == HIWORD(lpMidiOutHdr->dwReserved[MH_SHADOW]));

            GlobalFree(GlobalHandle((LPMIDIHDR)lpMidiOutHdr->dwReserved[MH_SHADOW]));
            lpMidiOutHdr->dwReserved[MH_SHADOW] = 0;

            mmrc = midiUnprepareHeader(lpMidiOutHdr, wSize);
            if (MMSYSERR_NOERROR != mmrc)
                wRet = mmrc;

            LEAVE_MM_HANDLE((HMIDI)hMidiOut);

            return wRet;
            
        default:
            ReleaseHandleListResource(); 
            break;
     }

     return MMSYSERR_INVALHANDLE;

}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiOutShortMsg | This function sends a short MIDI message to
 *   the specified MIDI output device.  Use this function to send any MIDI
 *   message except for system-exclusive messages.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output
 *   device.
 *
 * @parm DWORD | dwMsg | Specifies the MIDI message.  The message is packed
 *   into a DWORD with the first byte of the message in the low-order byte.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_NOTREADY | The hardware is busy with other data.
 *
 * @comm This function may not return until the message has been sent to the
 *   output device.
 *
 * @xref midiOutLongMsg
 ****************************************************************************/
MMRESULT APIENTRY midiOutShortMsg(HMIDIOUT hMidiOut, DWORD dwMsg)
{
    MMRESULT    mmr;

    ClientUpdatePnpInfo();

    AcquireHandleListResourceShared();

    if (BAD_HANDLE(hMidiOut, TYPE_MIDIOUT) && BAD_HANDLE(hMidiOut, TYPE_MIDISTRM))
    {
        ReleaseHandleListResource();
        return MMSYSERR_INVALHANDLE;
    }

    switch(GetHandleType(hMidiOut))
    {
    case TYPE_MIDIOUT:
        return (MMRESULT)midiMessage((HMIDI)hMidiOut, MODM_DATA, dwMsg, 0L);

    case TYPE_MIDISTRM:
        ENTER_MM_HANDLE((HMIDI)hMidiOut);
        ReleaseHandleListResource();
        mmr = (MMRESULT)midiStreamMessage(HtoPT(PMIDISTRM, hMidiOut)->rgIds, MODM_DATA, dwMsg, 0L);
        LEAVE_MM_HANDLE((HMIDI)hMidiOut);
        return (mmr);
    }

    ReleaseHandleListResource();
    return MMSYSERR_INVALHANDLE;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiOutLongMsg | This function sends a system-exclusive
 *   MIDI message to the specified MIDI output device.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output
 *   device.
 *
 * @parm LPMIDIHDR | lpMidiOutHdr | Specifies a far pointer to a <t MIDIHDR>
 *   structure that identifies the MIDI data buffer.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_UNPREPARED | <p lpMidiOutHdr> hasn't been prepared.
 *   @flag MIDIERR_NOTREADY | The hardware is busy with other data.
 *
 * @comm The data buffer must be prepared with <f midiOutPrepareHeader>
 *   before it is passed to <f midiOutLongMsg>.  The <t MIDIHDR> data
 *   structure and the data buffer pointed to by its <e MIDIHDR.lpData>
 *   field must be allocated with <f GlobalAlloc> using the GMEM_MOVEABLE
 *   and GMEM_SHARE flags, and locked with <f GlobalLock>. The MIDI output
 *   device driver determines whether the data is sent synchronously or
 *   asynchronously.
 *
 * @xref midiOutShortMsg midiOutPrepareHeader
 ****************************************************************************/
MMRESULT APIENTRY midiOutLongMsg(HMIDIOUT hMidiOut, LPMIDIHDR lpMidiOutHdr, UINT wSize)
{
    V_HEADER(lpMidiOutHdr, wSize, TYPE_MIDIOUT, MMSYSERR_INVALPARAM);

    if (lpMidiOutHdr->dwFlags & ~MHDR_VALID)
    return MMSYSERR_INVALFLAG;

    if (!(lpMidiOutHdr->dwFlags & MHDR_PREPARED))
    return MIDIERR_UNPREPARED;

    if (lpMidiOutHdr->dwFlags & MHDR_INQUEUE)
    return MIDIERR_STILLPLAYING;

    if (!lpMidiOutHdr->dwBufferLength)
        return MMSYSERR_INVALPARAM;

    lpMidiOutHdr->dwFlags &= ~MHDR_ISSTRM;

    ClientUpdatePnpInfo();

    AcquireHandleListResourceShared();

    if (BAD_HANDLE(hMidiOut, TYPE_MIDIOUT) && BAD_HANDLE(hMidiOut, TYPE_MIDISTRM))
    {
        ReleaseHandleListResource();
        return MMSYSERR_INVALHANDLE;
    }
       
    switch(GetHandleType(hMidiOut))
    {
        case TYPE_MIDIOUT:
         return (MMRESULT)midiMessage((HMIDI)hMidiOut, MODM_LONGDATA, (DWORD_PTR)lpMidiOutHdr, (DWORD)wSize);

        case TYPE_MIDISTRM:
         ReleaseHandleListResource();
         return MMSYSERR_NOTSUPPORTED;
         
        default:
         ReleaseHandleListResource();
         break;
    }

    return MMSYSERR_INVALHANDLE;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiOutReset | This function turns off all notes on all MIDI
 *   channels for the specified MIDI output device. Any pending
 *   system-exclusive output buffers are marked as done and
 *   returned to the application.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output
 *   device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm To turn off all notes, a note-off message for each note for each
 *   channel is sent. In addition, the sustain controller is turned off for
 *   each channel.
 *
 * @xref midiOutLongMsg midiOutClose
 ****************************************************************************/
MMRESULT APIENTRY midiOutReset(HMIDIOUT hMidiOut)
{
    PMIDISTRM   pms;
    MMRESULT    mmr;

    ClientUpdatePnpInfo();
    
    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE(hMidiOut, TYPE_MIDIOUT) && BAD_HANDLE(hMidiOut, TYPE_MIDISTRM))
    {
        ReleaseHandleListResource();
        return MMSYSERR_INVALHANDLE;
    }

    switch(GetHandleType(hMidiOut))
    {
    case TYPE_MIDIOUT:
        mmr = (MMRESULT)midiMessage((HMIDI)hMidiOut, MODM_RESET, 0, 0);
        break;

    case TYPE_MIDISTRM:
        pms = HtoPT(PMIDISTRM, hMidiOut);
        ReleaseHandleListResource();
        mmr = (MMRESULT)midiStreamBroadcast(pms, MODM_RESET, 0, 0);
        break;

    default:
        ReleaseHandleListResource();
        mmr = MMSYSERR_INVALHANDLE;
        break;
    }

    if ((mmr == MMSYSERR_NODRIVER) && (IsHandleDeserted(hMidiOut)))
    {
        mmr = MMSYSERR_NOERROR;
    }

    return mmr;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiOutCachePatches | This function requests that an internal
 *   MIDI synthesizer device preload a specified set of patches. Some
 *   synthesizers are not capable of keeping all patches loaded simultaneously
 *   and must load data from disk when they receive MIDI program change
 *   messages. Caching patches ensures specified patches are immediately
 *   available.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the opened MIDI output
 *   device. This device must be an internal MIDI synthesizer.
 *
 * @parm UINT | wBank | Specifies which bank of patches should be used.
 *   This parameter should be set to zero to cache the default patch bank.
 *
 * @parm LPWORD | lpPatchArray | Specifies a pointer to a <t PATCHARRAY>
 *   array indicating the patches to be cached or uncached.
 *
 * @parm UINT | wFlags | Specifies options for the cache operation. Only one
 *   of the following flags can be specified:
 *      @flag MIDI_CACHE_ALL | Cache all of the specified patches. If they
 *         can't all be cached, cache none, clear the <t PATCHARRAY> array,
 *         and return MMSYSERR_NOMEM.
 *      @flag MIDI_CACHE_BESTFIT | Cache all of the specified patches.
 *         If all patches can't be cached, cache as many patches as
 *         possible, change the <t PATCHARRAY> array to reflect which
 *         patches were cached, and return MMSYSERR_NOMEM.
 *      @flag MIDI_CACHE_QUERY | Change the <t PATCHARRAY> array to indicate
 *         which patches are currently cached.
 *      @flag MIDI_UNCACHE | Uncache the specified patches and clear the
 *         <t PATCHARRAY> array.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   one of the following error codes:
 *      @flag MMSYSERR_INVALHANDLE | The specified device handle is invalid.
 *      @flag MMSYSERR_NOTSUPPORTED | The specified device does not support
 *          patch caching.
 *      @flag MMSYSERR_NOMEM | The device does not have enough memory to cache
 *          all of the requested patches.
 *
 * @comm The <t PATCHARRAY> data type is defined as:
 *
 *   typedef UINT PATCHARRAY[MIDIPATCHSIZE];
 *
 *   Each element of the array represents one of the 128 patches and
 *   has bits set for
 *   each of the 16 MIDI channels that use that particular patch. The
 *   least-significant bit represents physical channel 0; the
 *   most-significant bit represents physical channel 15 (0x0F). For
 *   example, if patch 0 is used by physical channels 0 and 8, element 0
 *   would be set to 0x0101.
 *
 *   This function only applies to internal MIDI synthesizer devices.
 *   Not all internal synthesizers support patch caching. Use the
 *   MIDICAPS_CACHE flag to test the <e MIDIOUTCAPS.dwSupport> field of the
 *   <t MIDIOUTCAPS> structure filled by <f midiOutGetDevCaps> to see if the
 *   device supports patch caching.
 *
 * @xref midiOutCacheDrumPatches
 ****************************************************************************/
MMRESULT APIENTRY midiOutCachePatches(HMIDIOUT hMidiOut, UINT wBank,
                     LPWORD lpPatchArray, UINT wFlags)
{
    V_WPOINTER(lpPatchArray, sizeof(PATCHARRAY), MMSYSERR_INVALPARAM);
    V_FLAGS(wFlags, MIDI_CACHE_VALID, midiOutCacheDrumPatches, MMSYSERR_INVALFLAG);

    ClientUpdatePnpInfo();

    AcquireHandleListResourceShared();

    if (BAD_HANDLE(hMidiOut, TYPE_MIDIOUT) && BAD_HANDLE(hMidiOut, TYPE_MIDISTRM))
    {
        ReleaseHandleListResource();
        return MMSYSERR_INVALHANDLE;
    }

    switch(GetHandleType(hMidiOut))
    {
    case TYPE_MIDIOUT:
        return (MMRESULT)midiMessage((HMIDI)hMidiOut,
                     MODM_CACHEPATCHES,
                     (DWORD_PTR)lpPatchArray,
                     MAKELONG(wFlags, wBank));

    case TYPE_MIDISTRM:
        ReleaseHandleListResource();
        return (MMRESULT)midiStreamBroadcast((PMIDISTRM)hMidiOut,
                         MODM_CACHEPATCHES,
                         (DWORD_PTR)lpPatchArray,
                         MAKELONG(wFlags, wBank));
                    
    default:
        ReleaseHandleListResource();
        break;     
    }

    return MMSYSERR_INVALHANDLE;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiOutCacheDrumPatches | This function requests that an
 *   internal MIDI synthesizer device preload a specified set of key-based
 *   percussion patches. Some synthesizers are not capable of keeping all
 *   percussion patches loaded simultaneously. Caching patches ensures
 *   specified patches are available.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the opened MIDI output
 *   device. This device should be an internal MIDI synthesizer.
 *
 * @parm UINT | wPatch | Specifies which drum patch number should be used.
 *   This parameter should be set to zero to cache the default drum patch.
 *
 * @parm LPWORD | lpKeyArray | Specifies a pointer to a <t KEYARRAY>
 *   array indicating the key numbers of the specified percussion patches
 *  to be cached or uncached.
 *
 * @parm UINT | wFlags | Specifies options for the cache operation. Only one
 *   of the following flags can be specified:
 *      @flag MIDI_CACHE_ALL | Cache all of the specified patches. If they
 *         can't all be cached, cache none, clear the <t KEYARRAY> array,
 *       and return MMSYSERR_NOMEM.
 *      @flag MIDI_CACHE_BESTFIT | Cache all of the specified patches.
 *         If all patches can't be cached, cache as many patches as
 *         possible, change the <t KEYARRAY> array to reflect which
 *         patches were cached, and return MMSYSERR_NOMEM.
 *      @flag MIDI_CACHE_QUERY | Change the <t KEYARRAY> array to indicate
 *         which patches are currently cached.
 *      @flag MIDI_UNCACHE | Uncache the specified patches and clear the
 *       <t KEYARRAY> array.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   one of the following error codes:
 *      @flag MMSYSERR_INVALHANDLE | The specified device handle is invalid.
 *      @flag MMSYSERR_NOTSUPPORTED | The specified device does not support
 *          patch caching.
 *      @flag MMSYSERR_NOMEM | The device does not have enough memory to cache
 *          all of the requested patches.
 *
 * @comm The <t KEYARRAY> data type is defined as:
 *
 *   typedef UINT KEYARRAY[MIDIPATCHSIZE];
 *
 *   Each element of the array represents one of the 128 key-based percussion
 *   patches and has bits set for
 *   each of the 16 MIDI channels that use that particular patch. The
 *   least-significant bit represents physical channel 0; the
 *   most-significant bit represents physical channel 15. For
 *   example, if the patch on key number 60 is used by physical channels 9
 *   and 15, element 60 would be set to 0x8200.
 *
 *   This function applies only to internal MIDI synthesizer devices.
 *   Not all internal synthesizers support patch caching. Use the
 *   MIDICAPS_CACHE flag to test the <e MIDIOUTCAPS.dwSupport> field of the
 *   <t MIDIOUTCAPS> structure filled by <f midiOutGetDevCaps> to see if the
 *   device supports patch caching.
 *
 * @xref midiOutCachePatches
 ****************************************************************************/
MMRESULT APIENTRY midiOutCacheDrumPatches(HMIDIOUT hMidiOut, UINT wPatch,
                     LPWORD lpKeyArray, UINT wFlags)
{
    V_WPOINTER(lpKeyArray, sizeof(KEYARRAY), MMSYSERR_INVALPARAM);
    V_FLAGS(wFlags, MIDI_CACHE_VALID, midiOutCacheDrumPatches, MMSYSERR_INVALFLAG);

    ClientUpdatePnpInfo();

    AcquireHandleListResourceShared();

    if (BAD_HANDLE(hMidiOut, TYPE_MIDIOUT) && BAD_HANDLE(hMidiOut, TYPE_MIDISTRM))
    {
        ReleaseHandleListResource();
        return MMSYSERR_INVALHANDLE;
    }

    switch(GetHandleType(hMidiOut))
    {
    case TYPE_MIDIOUT:
        return (MMRESULT)midiMessage((HMIDI)hMidiOut,
                     MODM_CACHEDRUMPATCHES,
                     (DWORD_PTR)lpKeyArray,
                     MAKELONG(wFlags, wPatch));

    case TYPE_MIDISTRM:
        ReleaseHandleListResource();
        return (MMRESULT)midiStreamBroadcast((PMIDISTRM)hMidiOut,
                         MODM_CACHEDRUMPATCHES,
                         (DWORD_PTR)lpKeyArray,
                         MAKELONG(wFlags, wPatch));
                    
    default:
        ReleaseHandleListResource();
        break;     
    }

    return MMSYSERR_INVALHANDLE;
}


//--------------------------------------------------------------------------;
//
//  MMRESULT midiOutDesertHandle
//
//  Description:
//      Cleans up the midi out handle and marks it as deserted.
//
//  Arguments:
//      HMIDIOUT hMidiOut:  MIDI out handle.
//
//  Return (MMRESULT):  Error code.
//
//  History:
//      01/25/99    Fwong       Adding Pnp Support.
//
//--------------------------------------------------------------------------;

MMRESULT midiOutDesertHandle
(
    HMIDIOUT    hMidiOut
)
{
    MMRESULT    mmr;
    PMIDIDEV    pDev = (PMIDIDEV)hMidiOut;

    V_HANDLE_ACQ(hMidiOut, TYPE_MIDIOUT, MMSYSERR_INVALHANDLE);

    ENTER_MM_HANDLE((HMIDI)hMidiOut);
    ReleaseHandleListResource();

    if (IsHandleDeserted(hMidiOut))
    {
        //  Handle has already been deserted...
        LEAVE_MM_HANDLE((HMIDI)hMidiOut);
        return(MMSYSERR_NOERROR);
    }

    if (IsHandleBusy(hMidiOut))
    {
        //  Not quite invalid, but marked as closed.
    
        LEAVE_MM_HANDLE(hMidiOut);
        return (MMSYSERR_HANDLEBUSY);
    }

    //  Marking handle as deserted
    SetHandleFlag(hMidiOut, MMHANDLE_DESERTED);

    //  Since the handle was invalidated, we have to send the message ourselves...

    (*(pDev->mididrv->drvMessage))(pDev->wDevice, MODM_RESET, pDev->dwDrvUser, 0L, 0L);
    (*(pDev->mididrv->drvMessage))(pDev->wDevice, MODM_CLOSE, pDev->dwDrvUser, 0L, 0L);

    LEAVE_MM_HANDLE((HMIDI)hMidiOut);

    // ISSUE-2001/01/14-FrankYe Probably don't want to dec usage here,
    //    dec on close instead.
    mregDecUsage(PTtoH(HMD, pDev->mididrv));

    //  Mark handle as deserted, but not freeing.

    return MMSYSERR_NOERROR;
} // midiOutDesertHandle()


/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiInGetNumDevs | This function retrieves the number of MIDI
 *   input devices in the system.
 *
 * @rdesc Returns the number of MIDI input devices present in the system.
 *
 * @xref midiInGetDevCaps
 ****************************************************************************/
UINT APIENTRY midiInGetNumDevs(void)
{
    UINT    cDevs;

    ClientUpdatePnpInfo();

    EnterNumDevs("midiInGetNumDevs");
    cDevs = wTotalMidiInDevs;
    LeaveNumDevs("midiInGetNumDevs");

    return cDevs;
}

/****************************************************************************
 * @doc EXTERNAL MIDI
 *
 * @api MMRESULT | midiInMessage | This function sends messages to the MIDI device
 *   drivers.
 *
 * @parm HMIDIIN | hMidiIn | The handle to the MIDI device.
 *
 * @parm UINT  | msg | The message to send.
 *
 * @parm DWORD | dw1 | Parameter 1.
 *
 * @parm DWORD | dw2 | Parameter 2.
 *
 * @rdesc Returns the value of the message sent.
 ***************************************************************************/
MMRESULT APIENTRY midiInMessage(HMIDIIN hMidiIn, UINT msg, DWORD_PTR dw1, DWORD_PTR dw2)
{
    ClientUpdatePnpInfo();

    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE(hMidiIn, TYPE_MIDIIN))
    {
        ReleaseHandleListResource();
        return midiIDMessage(&midiindrvZ, wTotalMidiInDevs, (UINT_PTR)hMidiIn, msg, dw1, dw2);
    }
    
    return midiMessage((HMIDI)hMidiIn, msg, dw1, dw2);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiInGetDevCaps | This function queries a specified MIDI input
 *    device to determine its capabilities.
 *
 * @parm UINT | uDeviceID | Identifies the MIDI input device.
 *
 * @parm LPMIDIINCAPS | lpCaps | Specifies a far pointer to a <t MIDIINCAPS>
 *   data structure.  This structure is filled with information about
 *   the capabilities of the device.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIINCAPS> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Use <f midiInGetNumDevs> to determine the number of MIDI input
 *   devices present in the system.  The device ID specified by <p uDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The MIDI_MAPPER constant may also be used as a device id. Only
 *   <p wSize> bytes (or less) of information is copied to the location
 *   pointed to by <p lpCaps>.  If <p wSize> is zero, nothing is copied,
 *   and the function returns zero.
 *
 * @xref midiInGetNumDevs
 ****************************************************************************/
MMRESULT APIENTRY midiInGetDevCapsW(UINT_PTR uDeviceID, LPMIDIINCAPSW lpCaps, UINT wSize)
{
    DWORD_PTR       dwParam1, dwParam2;
    MDEVICECAPSEX   mdCaps;
    PCWSTR          DevInterface;
    MMRESULT        mmr;

    if (wSize == 0)
     return MMSYSERR_NOERROR;

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    DevInterface = midiReferenceDevInterfaceById(&midiindrvZ, uDeviceID);
    dwParam2 = (DWORD_PTR)DevInterface;

    if (0 == dwParam2)
    {
        dwParam1 = (DWORD_PTR)lpCaps;
        dwParam2 = (DWORD)wSize;
    }
    else
    {
        mdCaps.cbSize = (DWORD)wSize;
        mdCaps.pCaps  = lpCaps;
        dwParam1      = (DWORD_PTR)&mdCaps;
    }

    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE((HMIDI)uDeviceID, TYPE_MIDIIN))
    {
        ReleaseHandleListResource();
    	mmr = midiIDMessage(&midiindrvZ, wTotalMidiInDevs, uDeviceID, MIDM_GETDEVCAPS, dwParam1, dwParam2);
    }
    else
    {
    	mmr = (MMRESULT)midiMessage((HMIDI)uDeviceID, MIDM_GETDEVCAPS, dwParam1, dwParam2);
    }

    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    return mmr;
}

MMRESULT APIENTRY midiInGetDevCapsA(UINT_PTR uDeviceID, LPMIDIINCAPSA lpCaps, UINT wSize)
{
    MIDIINCAPS2W   wDevCaps2;
    MIDIINCAPS2A   aDevCaps2;
    DWORD_PTR      dwParam1, dwParam2;
    MDEVICECAPSEX  mdCaps;
    PCWSTR         DevInterface;
    MMRESULT       mmRes;
    CHAR           chTmp[ MAXPNAMELEN * sizeof(WCHAR) ];

    if (wSize == 0)
    return MMSYSERR_NOERROR;

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    DevInterface = midiReferenceDevInterfaceById(&midiindrvZ, uDeviceID);
    dwParam2 = (DWORD_PTR)DevInterface;

    memset(&wDevCaps2, 0, sizeof(wDevCaps2));

    if (0 == dwParam2)
    {
        dwParam1 = (DWORD_PTR)&wDevCaps2;
        dwParam2 = (DWORD)sizeof(wDevCaps2);
    }
    else
    {
        mdCaps.cbSize = (DWORD)sizeof(wDevCaps2);
        mdCaps.pCaps  = &wDevCaps2;
        dwParam1      = (DWORD_PTR)&mdCaps;
    }

    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE((HMIDI)uDeviceID, TYPE_MIDIIN))
    {
        ReleaseHandleListResource();
        mmRes = midiIDMessage( &midiindrvZ, wTotalMidiInDevs, uDeviceID,
                               MIDM_GETDEVCAPS, dwParam1, dwParam2);
    }
    else
    {
        mmRes = midiMessage((HMIDI)uDeviceID, MIDM_GETDEVCAPS,
                            (DWORD)dwParam1, (DWORD)dwParam2);
    }

    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    
    //
    // Make sure the call worked before proceeding with the thunk.
    //
    if ( mmRes != MMSYSERR_NOERROR ) {
    return  mmRes;
    }

    aDevCaps2.wMid             = wDevCaps2.wMid;
    aDevCaps2.wPid             = wDevCaps2.wPid;
    aDevCaps2.vDriverVersion   = wDevCaps2.vDriverVersion;
    aDevCaps2.dwSupport        = wDevCaps2.dwSupport;
    aDevCaps2.ManufacturerGuid = wDevCaps2.ManufacturerGuid;
    aDevCaps2.ProductGuid      = wDevCaps2.ProductGuid;
    aDevCaps2.NameGuid         = wDevCaps2.NameGuid;

    // copy and convert unicode to ascii here.
    UnicodeStrToAsciiStr( chTmp, chTmp +  sizeof( chTmp ), wDevCaps2.szPname );
    strcpy( aDevCaps2.szPname, chTmp );

    //
    // now copy the required amount into the callers buffer.
    //
    CopyMemory( lpCaps, &aDevCaps2, min(wSize, sizeof(aDevCaps2)));

    return mmRes;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiInGetErrorText | This function retrieves a textual
 *   description of the error identified by the specified error number.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPTSTR | lpText | Specifies a far pointer to the buffer to be
 *   filled with the textual error description.
 *
 * @parm UINT | wSize | Specifies the length in characters of the buffer
 *   pointed to by <p lpText>.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADERRNUM | Specified error number is out of range.
 *
 * @comm If the textual error description is longer than the specified buffer,
 * the description is truncated.  The returned error string is always
 * null-terminated. If <p wSize> is zero, nothing is copied, and
 * the function returns zero. All error descriptions are
 * less than MAXERRORLENGTH characters long.
 ****************************************************************************/
MMRESULT APIENTRY midiInGetErrorTextW(UINT wError, LPWSTR lpText, UINT wSize)
{
    if(wSize == 0)
    return MMSYSERR_NOERROR;

    V_WPOINTER(lpText, wSize*sizeof(WCHAR), MMSYSERR_INVALPARAM);

    return midiGetErrorTextW(wError, lpText, wSize);
}

MMRESULT APIENTRY midiInGetErrorTextA(UINT wError, LPSTR lpText, UINT wSize)
{
    if(wSize == 0)
    return MMSYSERR_NOERROR;

    V_WPOINTER(lpText, wSize, MMSYSERR_INVALPARAM);

    return midiGetErrorTextA(wError, lpText, wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiInOpen | This function opens a specified MIDI input device.
 *
 * @parm LPHMIDIIN | lphMidiIn | Specifies a far pointer to an HMIDIIN handle.
 *   This location is filled with a handle identifying the opened MIDI
 *   input device.  Use the handle to identify the device when calling
 *   other MIDI input functions.
 *
 * @parm UINT | uDeviceID | Identifies the MIDI input device to be
 *   opened.
 *
 * @parm DWORD | dwCallback | Specifies the address of a fixed callback
 *   function or a handle to a window called with information
 *   about incoming MIDI messages.
 *
 * @parm DWORD | dwCallbackInstance | Specifies user instance data
 *   passed to the callback function.  This parameter is not
 *   used with window callbacks.
 *
 * @parm DWORD | dwFlags | Specifies a callback flag for opening the device.
 *   @flag CALLBACK_WINDOW | If this flag is specified, <p dwCallback> is
 *      assumed to be a window handle.
 *   @flag CALLBACK_FUNCTION | If this flag is specified, <p dwCallback> is
 *      assumed to be a callback procedure address.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_ALLOCATED | Specified resource is already allocated.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *
 * @comm Use <f midiInGetNumDevs> to determine the number of MIDI input
 *   devices present in the system.  The device ID specified by <p uDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The MIDI_MAPPER constant may also be used as a device id.
 *
 *   If a window is chosen to receive callback information, the following
 *   messages are sent to the window procedure function to indicate the
 *   progress of MIDI input:  <m MM_MIM_OPEN>, <m MM_MIM_CLOSE>,
 *   <m MM_MIM_DATA>, <m MM_MIM_LONGDATA>, <m MM_MIM_ERROR>,
 *   <m MM_MIM_LONGERROR>.
 *
 *   If a function is chosen to receive callback information, the following
 *   messages are sent to the function to indicate the progress of MIDI
 *   input:  <m MIM_OPEN>, <m MIM_CLOSE>, <m MIM_DATA>, <m MIM_LONGDATA>,
 *   <m MIM_ERROR>, <m MIM_LONGERROR>.  The callback function must reside in
 *   a DLL.  You do not have to use <f MakeProcInstance> to get a
 *   procedure-instance address for the callback function.
 *
 * @cb void CALLBACK | MidiInFunc | <f MidiInFunc> is a placeholder for
 *   the application-supplied function name.  The actual name must be
 *   exported by including it in an EXPORTS statement in the DLL's module
 *   definition file.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input device.
 *
 * @parm UINT | wMsg | Specifies a MIDI input message.
 *
 * @parm DWORD | dwInstance | Specifies the instance data supplied
 *      with <f midiInOpen>.
 *
 * @parm DWORD | dwParam1 | Specifies a parameter for the message.
 *
 * @parm DWORD | dwParam2 | Specifies a parameter for the message.
 *
 * @comm Because the callback is accessed at interrupt time, it must reside
 *   in a DLL, and its code segment must be specified as FIXED in the
 *   module-definition file for the DLL.  Any data that the callback accesses
 *   must be in a FIXED data segment as well. The callback may not make any
 *   system calls except for <f PostMessage>, <f timeGetSystemTime>,
 *   <f timeGetTime>, <f timeSetEvent>, <f timeKillEvent>,
 *   <f midiOutShortMsg>, <f midiOutLongMsg>, and <f OutputDebugStr>.
 *
 * @xref midiInClose
 ****************************************************************************/
MMRESULT APIENTRY midiInOpen(LPHMIDIIN lphMidiIn, UINT uDeviceID,
    DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD dwFlags)
{
    MIDIOPENDESC mo;
    PMIDIDEV     pdev;
    PMIDIDRV     mididrv;
    UINT         port;
    MMRESULT     wRet;

    V_WPOINTER(lphMidiIn, sizeof(HMIDIIN), MMSYSERR_INVALPARAM);
    if (uDeviceID == MIDI_MAPPER) {
    V_FLAGS(LOWORD(dwFlags), MIDI_I_VALID & ~LOWORD(MIDI_IO_COOKED | MIDI_IO_SHARED), midiInOpen, MMSYSERR_INVALFLAG);
    } else {
    V_FLAGS(LOWORD(dwFlags), MIDI_I_VALID & ~LOWORD(MIDI_IO_COOKED) , midiInOpen, MMSYSERR_INVALFLAG);
    }
    V_DCALLBACK(dwCallback, HIWORD(dwFlags), MMSYSERR_INVALPARAM);

    *lphMidiIn = NULL;

    ClientUpdatePnpInfo();

    wRet = midiReferenceDriverById(&midiindrvZ, uDeviceID, &mididrv, &port);
    if (wRet)
    {
        return wRet;
    }

    if (!mididrv->drvMessage)
    {
    	mregDecUsagePtr(mididrv);
    	return MMSYSERR_NODRIVER;
    }

    pdev = (PMIDIDEV)NewHandle(TYPE_MIDIIN, mididrv->cookie, sizeof(MIDIDEV));
    if( pdev == NULL)
    {
    	mregDecUsagePtr(mididrv);
    	return MMSYSERR_NOMEM;
    }

    ENTER_MM_HANDLE(pdev);
    SetHandleFlag(pdev, MMHANDLE_BUSY);
    ReleaseHandleListResource();

    pdev->mididrv = mididrv;
    pdev->wDevice = port;
    pdev->uDeviceID = uDeviceID;
    pdev->fdwHandle = 0;

    mo.hMidi      = (HMIDI)pdev;
    mo.dwCallback = dwCallback;
    mo.dwInstance = dwInstance;
    mo.dnDevNode  = (DWORD_PTR)pdev->mididrv->cookie;

    wRet = (MMRESULT)((*(mididrv->drvMessage))
    (pdev->wDevice, MIDM_OPEN, (DWORD_PTR)&pdev->dwDrvUser, (DWORD_PTR)(LPMIDIOPENDESC)&mo, dwFlags));

    if (!wRet)
        ClearHandleFlag(pdev, MMHANDLE_BUSY);
        
    LEAVE_MM_HANDLE(pdev);

    if (wRet)
        FreeHandle((HMIDIIN)pdev);
    else {
        mregIncUsagePtr(mididrv);
        *lphMidiIn = (HMIDIIN)pdev;
    }

    mregDecUsagePtr(mididrv);
    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiInClose | This function closes the specified MIDI input
 *   device.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input device.
 *  If the function is successful, the handle is no longer
 *   valid after this call.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_STILLPLAYING | There are still buffers in the queue.
 *
 * @comm If there are input buffers that have been sent with
 *   <f midiInAddBuffer> and haven't been returned to the application,
 *   the close operation will fail.  Call <f midiInReset> to mark all
 *   pending buffers as being done.
 *
 * @xref midiInOpen midiInReset
 ****************************************************************************/
MMRESULT APIENTRY midiInClose(HMIDIIN hMidiIn)
{
    MMRESULT         wRet;
    PMIDIDRV         pmididrv;
    PMIDIDEV         pDev = (PMIDIDEV)hMidiIn;

    ClientUpdatePnpInfo();
    
    V_HANDLE_ACQ(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);
    
    ENTER_MM_HANDLE((HMIDI)hMidiIn);
    ReleaseHandleListResource();
    
    if (IsHandleDeserted(hMidiIn))
    {
        //  This handle has been deserted.  Let's just free it.

        LEAVE_MM_HANDLE((HMIDI)hMidiIn);
        FreeHandle(hMidiIn);
        return MMSYSERR_NOERROR;
    }
    
    if (IsHandleBusy(hMidiIn))
    {
        //  Not quite invalid, but marked as closed.
    
        LEAVE_MM_HANDLE(hMidiIn);
        return (MMSYSERR_HANDLEBUSY);
    }

    //  Marking handle as 'invalid/closed'.
    SetHandleFlag(hMidiIn, MMHANDLE_BUSY);
    
    pmididrv = pDev->mididrv;
    
    wRet = (MMRESULT)(*(pmididrv->drvMessage))(pDev->wDevice, MIDM_CLOSE, pDev->dwDrvUser, 0L, 0L);
    
    if (MMSYSERR_NOERROR != wRet)
    {
        ClearHandleFlag(hMidiIn, MMHANDLE_BUSY);
    }
    
    LEAVE_MM_HANDLE((HWAVE)hMidiIn);
    
    if (!wRet)
    {
        FreeHandle(hMidiIn);
    	mregDecUsagePtr(pmididrv);
        return wRet;
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiInPrepareHeader | This function prepares a buffer for
 *   MIDI input.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input
 *   device.
 *
 * @parm LPMIDIHDR | lpMidiInHdr | Specifies a pointer to a <t MIDIHDR>
 *   structure that identifies the buffer to be prepared.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *
 * @comm The <t MIDIHDR> data structure and the data block pointed to by its
 *   <e MIDIHDR.lpData> field must be allocated with <f GlobalAlloc> using the
 *   GMEM_MOVEABLE and GMEM_SHARE flags, and locked with <f GlobalLock>.
 *   Preparing a header that has already been prepared has no effect,
 *   and the function returns zero.
 *
 * @xref midiInUnprepareHeader
 ****************************************************************************/
MMRESULT APIENTRY midiInPrepareHeader(HMIDIIN hMidiIn, LPMIDIHDR lpMidiInHdr, UINT wSize)
{
    MMRESULT         wRet;

    V_HEADER(lpMidiInHdr, wSize, TYPE_MIDIIN, MMSYSERR_INVALPARAM);

    if (lpMidiInHdr->dwFlags & MHDR_PREPARED)
    return MMSYSERR_NOERROR;

    lpMidiInHdr->dwFlags = 0;

    ClientUpdatePnpInfo();
    
    V_HANDLE_ACQ(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);

    wRet = midiMessage((HMIDI)hMidiIn, MIDM_PREPARE, (DWORD_PTR)lpMidiInHdr, (DWORD)wSize);

    if (wRet == MMSYSERR_NOTSUPPORTED)
        return midiPrepareHeader(lpMidiInHdr, wSize);

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiInUnprepareHeader | This function cleans up the
 * preparation performed by <f midiInPrepareHeader>. The
 * <f midiInUnprepareHeader> function must be called
 * after the device driver fills a data buffer and returns it to the
 * application. You must call this function before freeing the data
 * buffer.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input
 *   device.
 *
 * @parm LPMIDIHDR | lpMidiInHdr |  Specifies a pointer to a <t MIDIHDR>
 *   structure identifying the data buffer to be cleaned up.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_STILLPLAYING | <p lpMidiInHdr> is still in the queue.
 *
 * @comm This function is the complementary function to <f midiInPrepareHeader>.
 * You must call this function before freeing the data buffer with
 * <f GlobalFree>.
 * After passing a buffer to the device driver with <f midiInAddBuffer>, you
 * must wait until the driver is finished with the buffer before calling
 * <f midiInUnprepareHeader>.  Unpreparing a buffer that has not been
 *   prepared has no effect, and the function returns zero.
 *
 * @xref midiInPrepareHeader
 ****************************************************************************/
MMRESULT APIENTRY midiInUnprepareHeader(HMIDIIN hMidiIn, LPMIDIHDR lpMidiInHdr, UINT wSize)
{
    MMRESULT         wRet;

    V_HEADER(lpMidiInHdr, wSize, TYPE_MIDIIN, MMSYSERR_INVALPARAM);

    if (!(lpMidiInHdr->dwFlags & MHDR_PREPARED))
    return MMSYSERR_NOERROR;

    if(lpMidiInHdr->dwFlags & MHDR_INQUEUE)
    {
    DebugErr(DBF_WARNING, "midiInUnprepareHeader: header still in queue\r\n");
    return MIDIERR_STILLPLAYING;
    }

    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);
    
    wRet = midiMessage((HMIDI)hMidiIn, MIDM_UNPREPARE, (DWORD_PTR)lpMidiInHdr, (DWORD)wSize);

    if (wRet == MMSYSERR_NOTSUPPORTED)
        return midiUnprepareHeader(lpMidiInHdr, wSize);

    if ((wRet == MMSYSERR_NODRIVER) && (IsHandleDeserted(hMidiIn)))
    {
        //  if the driver for the handle has been removed, succeed the call.

        wRet = MMSYSERR_NOERROR;
    }

    return wRet;
}

/******************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiInAddBuffer | This function sends an input buffer
 *   to a specified opened MIDI input device.  When the buffer is filled,
 *   it is sent back to the application.  Input buffers are
 *   used only for system-exclusive messages.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input device.
 *
 * @parm LPMIDIHDR | lpMidiInHdr | Specifies a far pointer to a <t MIDIHDR>
 *   structure that identifies the buffer.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_UNPREPARED | <p lpMidiInHdr> hasn't been prepared.
 *
 * @comm The data buffer must be prepared with <f midiInPrepareHeader> before
 *   it is passed to <f midiInAddBuffer>.  The <t MIDIHDR> data structure
 *   and the data buffer pointed to by its <e MIDIHDR.lpData> field must be allocated
 *   with <f GlobalAlloc> using the GMEM_MOVEABLE and GMEM_SHARE flags, and
 *   locked with <f GlobalLock>.
 *
 * @xref midiInPrepareHeader
 *****************************************************************************/
MMRESULT APIENTRY midiInAddBuffer(HMIDIIN hMidiIn, LPMIDIHDR lpMidiInHdr, UINT wSize)
{
    V_HEADER(lpMidiInHdr, wSize, TYPE_MIDIIN, MMSYSERR_INVALPARAM);

    if (!(lpMidiInHdr->dwFlags & MHDR_PREPARED))
    {
    DebugErr(DBF_WARNING, "midiInAddBuffer: buffer not prepared\r\n");
    return MIDIERR_UNPREPARED;
    }

    if (lpMidiInHdr->dwFlags & MHDR_INQUEUE)
    {
    DebugErr(DBF_WARNING, "midiInAddBuffer: buffer already in queue\r\n");
    return MIDIERR_STILLPLAYING;
    }

    ClientUpdatePnpInfo();
    
    V_HANDLE_ACQ(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);

    return midiMessage((HMIDI)hMidiIn, MIDM_ADDBUFFER, (DWORD_PTR)lpMidiInHdr, (DWORD)wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiInStart | This function starts MIDI input on the
 *   specified MIDI input device.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm This function resets the timestamps to zero; timestamp values for
 *   subsequently received messages are relative to the time this
 *   function was called.
 *
 *   All messages other than system-exclusive messages are sent
 *   directly to the client when received. System-exclusive
 *   messages are placed in the buffers supplied by <f midiInAddBuffer>;
 *   if there are no buffers in the queue,
 *   the data is thrown away without notification to the client, and input
 *   continues.
 *
 *   Buffers are returned to the client when full, when a
 *   complete system-exclusive message has been received,
 *   or when <f midiInReset> is
 *   called. The <e MIDIHDR.dwBytesRecorded> field in the header will contain the
 *   actual length of data received.
 *
 *   Calling this function when input is already started has no effect, and
 *   the function returns zero.
 *
 * @xref midiInStop midiInReset
 ****************************************************************************/
MMRESULT APIENTRY midiInStart(HMIDIIN hMidiIn)
{
    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);

    return midiMessage((HMIDI)hMidiIn, MIDM_START, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiInStop | This function terminates MIDI input on the
 *   specified MIDI input device.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm Current status (running status, parsing state, etc.) is maintained
 *   across calls to <f midiInStop> and <f midiInStart>.
 *   If there are any system-exclusive message buffers in the queue,
 *   the current buffer
 *   is marked as done (the <e MIDIHDR.dwBytesRecorded> field in the header will
 *   contain the actual length of data), but any empty buffers in the queue
 *   remain there.  Calling this function when input is not started has no
 *   no effect, and the function returns zero.
 *
 * @xref midiInStart midiInReset
 ****************************************************************************/
MMRESULT APIENTRY midiInStop(HMIDIIN hMidiIn)
{
    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);

    return midiMessage((HMIDI)hMidiIn, MIDM_STOP, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiInReset | This function stops input on a given MIDI
 *  input device and marks all pending input buffers as done.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @xref midiInStart midiInStop midiInAddBuffer midiInClose
 ****************************************************************************/
MMRESULT APIENTRY midiInReset(HMIDIIN hMidiIn)
{
    MMRESULT    mmr;

    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);

    mmr = midiMessage((HMIDI)hMidiIn, MIDM_RESET, 0L, 0L);

    if ((mmr == MMSYSERR_NODRIVER) && (IsHandleDeserted(hMidiIn)))
    {
        mmr = MMSYSERR_NOERROR;
    }

    return mmr;
}


//--------------------------------------------------------------------------;
//
//  MMRESULT midiInDesertHandle
//
//  Description:
//      Cleans up the midi in handle and marks it as deserted.
//
//  Arguments:
//      HMIDIIN hMidiIn:  MIDI in handle.
//
//  Return (MMRESULT):  Error code.
//
//  History:
//      01/25/99    Fwong       Adding Pnp Support.
//
//--------------------------------------------------------------------------;

MMRESULT midiInDesertHandle
(
    HMIDIIN hMidiIn
)
{
    MMRESULT    mmr;
    PMIDIDEV    pDev = (PMIDIDEV)hMidiIn;

    V_HANDLE_ACQ(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);
    
    ENTER_MM_HANDLE((HMIDI)hMidiIn);
    ReleaseHandleListResource();

    if (IsHandleDeserted(hMidiIn))
    {
        LEAVE_MM_HANDLE((HMIDI)hMidiIn);
        return (MMSYSERR_NOERROR);
    }
    
    if (IsHandleBusy(hMidiIn))
    {
        //  Not quite invalid, but marked as closed.
    
        LEAVE_MM_HANDLE(hMidiIn);
        return (MMSYSERR_HANDLEBUSY);
    }

    //  Marking handle as deserted
    SetHandleFlag(hMidiIn, MMHANDLE_DESERTED);
    
    //  Since the handle was invalidated, we have to send the message ourselves...
    
    (*(pDev->mididrv->drvMessage))(pDev->wDevice, MIDM_RESET, pDev->dwDrvUser, 0L, 0L);
    (*(pDev->mididrv->drvMessage))(pDev->wDevice, MIDM_CLOSE, pDev->dwDrvUser, 0L, 0L);

    LEAVE_MM_HANDLE((HWAVE)hMidiIn);
    
    // ISSUE-2001/01/14-FrankYe Probably don't want to dec usage here,
    //    dec on close instead.
    mregDecUsage(PTtoH(HMD, pDev->mididrv));

    return MMSYSERR_NOERROR;
} // midiInDesertHandle()


/*****************************************************************************
 * @doc EXTERNAL MIDI
 *
 * @api MMRESULT | midiInGetID | This function gets the device ID for a
 * MIDI input device.
 *
 * @parm HMIDIIN | hMidiIn     | Specifies the handle to the MIDI input
 * device.
 * @parm PUINT  | lpuDeviceID | Specifies a pointer to the UINT-sized
 * memory location to be filled with the device ID.
 *
 * @rdesc Returns zero if successful. Otherwise, returns
 * an error number. Possible error returns are:
 *
 * @flag MMSYSERR_INVALHANDLE | The <p hMidiIn> parameter specifies an
 * invalid handle.
 *
 ****************************************************************************/
MMRESULT APIENTRY midiInGetID(HMIDIIN hMidiIn, PUINT lpuDeviceID)
{
    V_WPOINTER(lpuDeviceID, sizeof(UINT), MMSYSERR_INVALPARAM);
    V_HANDLE_ACQ(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);

    *lpuDeviceID = ((PMIDIDEV)hMidiIn)->uDeviceID;
    
    ReleaseHandleListResource();
    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc EXTERNAL MIDI
 *
 * @api MMRESULT | midiOutGetID | This function gets the device ID for a
 * MIDI output device.
 *
 * @parm HMIDIOUT | hMidiOut    | Specifies the handle to the MIDI output
 * device.
 * @parm PUINT  | lpuDeviceID | Specifies a pointer to the UINT-sized
 * memory location to be filled with the device ID.
 *
 * @rdesc Returns MMSYSERR_NOERROR if successful. Otherwise, returns
 * an error number. Possible error returns are:
 *
 * @flag MMSYSERR_INVALHANDLE | The <p hMidiOut> parameter specifies an
 * invalid handle.
 *
 ****************************************************************************/
MMRESULT APIENTRY midiOutGetID(HMIDIOUT hMidiOut, PUINT lpuDeviceID)
{
    V_WPOINTER(lpuDeviceID, sizeof(UINT), MMSYSERR_INVALPARAM);
    V_HANDLE_ACQ(hMidiOut, TYPE_MIDIOUT, MMSYSERR_INVALHANDLE);

    *lpuDeviceID = ((PMIDIDEV)hMidiOut)->uDeviceID;
    
    ReleaseHandleListResource();
    return MMSYSERR_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\mcisys.c ===
/*****************************Module*Header*********************************\
* Module Name: mcisys.c
*
* Media Control Architecture System Functions
*
* Created: 2/28/90
* Author:  DLL (DavidLe)
* 5/22/91: Ported to Win32 - NigelT
*
* History:
* Mar 92   SteveDav - brought up to Win 3.1 ship level
*
* Copyright (c) 1991-1999 Microsoft Corporation
*
\******************************************************************************/

#define UNICODE

#define _CTYPE_DISABLE_MACROS
#include "winmmi.h"
#include "mci.h"
#include "wchar.h"
#include "ctype.h"

extern   WSZCODE wszOpen[];          // in MCI.C
STATICDT WSZCODE wszMciExtensions[] = L"Mci Extensions";

#define MCI_EXTENSIONS wszMciExtensions

#define MCI_PROFILE_STRING_LENGTH 255

//#define TOLOWER(c) ((c) >= 'A' && (c) <= 'Z' ? (c) + 'a' - 'A' : c)

// The device list is initialized on the first call to mciSendCommand or
// to mciSendString or to mciGetDeviceID or to mciGetErrorString
// We could do it when WINMM is loaded - but that is a bit excessive.
// The user may not need MCI functions.
BOOL MCI_bDeviceListInitialized = FALSE;

// The next device ID to use for a new device
MCIDEVICEID MCI_wNextDeviceID = 1;

// The list of MCI devices.  This list grows and shrinks as needed.
// The first offset MCI_lpDeviceList[0] is a placeholder and is unused
// because device 0 is defined as no device.
LPMCI_DEVICE_NODE FAR * MCI_lpDeviceList = NULL;

// The current size of the list of MCI devices
UINT MCI_wDeviceListSize = 0;

#if 0 // we don't use this (NigelT)
// The internal mci heap used by mciAlloc and mciFree
HANDLE hMciHeap = NULL;
#endif

STATICDT WSZCODE wszAllDeviceName[] = L"all";

STATICDT WSZCODE szUnsignedFormat[] = L"%u";

STATICFN void mciFreeDevice(LPMCI_DEVICE_NODE nodeWorking);


//------------------------------------------------------------------
// Initialize device list
// Called once by mciSendString or mciSendCommand
// Returns TRUE on success
//------------------------------------------------------------------

BOOL mciInitDeviceList(void)
{
    BOOL fReturn=FALSE;

#if 0 // we don't use this (NigelT)
    if ((hMciHeap = HeapCreate(0)) == 0)
    {
        dprintf1(("Mci heap create failed!"));
        return FALSE;
    }
#endif

  try {
    mciEnter("mciInitDeviceList");
    if (!MCI_bDeviceListInitialized) {
        // We have to retest the init flag to be totally thread safe.
        // Otherwise in theory we could end up initializing twice.
        if ((MCI_lpDeviceList = mciAlloc( sizeof (LPMCI_DEVICE_NODE) *
                                         (MCI_INIT_DEVICE_LIST_SIZE + 1))) != NULL)
        {
            MCI_wDeviceListSize = MCI_INIT_DEVICE_LIST_SIZE;
            MCI_bDeviceListInitialized = TRUE;
            fReturn = TRUE;
        } else {
            dprintf1(("MCIInit: could not allocate master MCI device list"));
            fReturn = FALSE;
        }
    }

  } finally {
    mciLeave("mciInitDeviceList");
  }

    return(fReturn);
}

/*
 * @doc EXTERNAL MCI
 * @api MCIDEVICEID | mciGetDeviceIDFromElementID | This function
 * retrieves the MCI device ID corresponding to and element ID
 *
 * @parm DWORD | dwElementID | The element ID
 *
 * @parm LPCTSTR | lpstrType | The type name this element ID belongs to
 *
 * @rdesc Returns the device ID assigned when it was opened and used in the
 * <f mciSendCommand> function.  Returns zero if the device name was not known,
 * if the device was not open, or if there was not enough memory to complete
 * the operation or if lpstrType is NULL.
 *
 */
MCIDEVICEID APIENTRY mciGetDeviceIDFromElementIDA (
    DWORD dwElementID,
    LPCSTR lpstrType)
{
    LPCWSTR lpwstr;
    MCIDEVICEID mr;

    lpwstr = AllocUnicodeStr( (LPSTR)lpstrType );
    if ( lpwstr == NULL ) {
        return (MCIDEVICEID)(UINT_PTR)NULL;
    }

    mr = mciGetDeviceIDFromElementIDW( dwElementID, lpwstr );

    FreeUnicodeStr( (LPWSTR)lpwstr );

    return mr;
}

MCIDEVICEID APIENTRY mciGetDeviceIDFromElementIDW (
    DWORD dwElementID,
    LPCWSTR lpstrType)
{
    MCIDEVICEID wID;
    LPMCI_DEVICE_NODE nodeWorking, FAR *nodeCounter;
    WCHAR strTemp[MCI_MAX_DEVICE_TYPE_LENGTH];

    if (lpstrType == NULL) {
        return 0;
    }

    mciEnter("mciGetDeviceIDFromElementID");

    nodeCounter = &MCI_lpDeviceList[1];

    for (wID = 1; wID < MCI_wNextDeviceID; ++wID)
    {

        if (NULL == (nodeWorking = *nodeCounter++)) {
            continue;
        }

        if (nodeWorking->dwMCIOpenFlags & MCI_OPEN_ELEMENT_ID &&
            nodeWorking->dwElementID == dwElementID) {

            if (LoadStringW( ghInst, nodeWorking->wDeviceType, strTemp,
                             sizeof(strTemp) / sizeof(WCHAR) ) != 0
                && lstrcmpiW( strTemp, lpstrType) == 0) {

                mciLeave("mciGetDeviceIDFromElementID");
                return wID;
            }
        }
    }

    mciLeave("mciGetDeviceIDFromElementID");
    return 0;
}

// Retrieves the device ID corresponding to the name of an opened device
// matching the given task
STATICFN MCIDEVICEID mciGetDeviceIDInternal (
    LPCWSTR lpstrName,
    HANDLE hCurrentTask)
{
    MCIDEVICEID wID;
    LPMCI_DEVICE_NODE nodeWorking, FAR *nodeCounter;

#if DBG
    if (!lpstrName) {
        dprintf(("!! NULL POINTER !!  Internal error"));
        return(0);
    }
#endif

    if ( lstrcmpiW(wszAllDeviceName, lpstrName) == 0)
        return MCI_ALL_DEVICE_ID;

    if (MCI_lpDeviceList == NULL)
        return 0;

// Loop through the MCI device list. Skip any 16-bit devices.

    mciEnter("mciGetDeviceIDInternal");

    nodeCounter = &MCI_lpDeviceList[1];
    for (wID = 1; wID < MCI_wNextDeviceID; ++wID)
    {

        if (NULL == (nodeWorking = *nodeCounter++)) {
            continue;
        }

        // If this device is 16-bit then skip it
        if (nodeWorking->dwMCIFlags & MCINODE_16BIT_DRIVER) {
            continue;
        }

        // If this device does not have a name then skip it
        if (nodeWorking->dwMCIOpenFlags & MCI_OPEN_ELEMENT_ID) {
            continue;
        }

        // If the names match, and the previous device is not being closed
        if ( lstrcmpiW( nodeWorking->lpstrName, lpstrName ) == 0 ) {
            if (ISAUTOCLOSING(nodeWorking))
            {
                // As this auto opened device is being closed we do not match
                // against its name.  The result is that a new auto opened
                // device will be used.  This would be the case if this
                // command was issued momentarily later by which time we
                // would have finished closing the existing device.
            } else {
                // If the device belongs to the current task
                if (nodeWorking->hOpeningTask == hCurrentTask ||
                    nodeWorking->hCreatorTask == hCurrentTask) {
                    // Return this device ID
                    mciLeave("mciGetDeviceIDInternal");
                    return wID;
                }
            }
        }
    }
    mciLeave("mciGetDeviceIDInternal");
    return 0;
}


/*
 * @doc EXTERNAL MCI
 * @api MCIDEVICEID | mciGetDeviceID | This function retrieves the device
 * ID corresponding to the name of an opened device.
 *
 * @parm LPCTSTR | lpstrName | Points to the device name from SYSTEM.INI, or
 * the alias name by which the device is known.
 *
 * @rdesc Returns the device ID assigned when it was opened and used in the
 * <f mciSendCommand> function.  Returns zero if the device name was not known,
 * if the device was not open, or if there was not enough memory to complete
 * the operation.  Each compound device element has a unique device ID.
 * The ID of the "all" device is MCI_ALL_DEVICE_ID
 *
 * @xref MCI_OPEN
 *
 */
MCIDEVICEID mciGetDeviceIDW (
    LPCWSTR lpstrName)
{
    return mciGetDeviceIDInternal (lpstrName, GetCurrentTask());
}

MCIDEVICEID mciGetDeviceIDA (
    LPCSTR lpstrName)
{
    LPCWSTR lpwstr;
    MCIDEVICEID mr;

    lpwstr = AllocUnicodeStr( (LPSTR)lpstrName );
    if ( lpwstr == NULL ) {
        return (MCIDEVICEID)(UINT_PTR)NULL;
    }

    mr = mciGetDeviceIDInternal( lpwstr, GetCurrentTask() );

    FreeUnicodeStr( (LPWSTR)lpwstr );

    return mr;
}

/*
 * @doc EXTERNAL MCI
 * @api HMODULE | mciGetCreatorTask | This function retrieves the creator task
 * corresponding with the device ID passed.
 *
 * @parm MCIDEVICEID | wDeviceID | Specifies the device ID whose creator task is to
 * be returned.
 *
 * @rdesc Returns the creator task responsible for opening the device, else
 * NULL if the device ID passed is invalid.
 *
 */
HTASK APIENTRY mciGetCreatorTask (
    MCIDEVICEID wDeviceID)
{
    HTASK hCreatorTask;

    mciEnter("mciGetCreatorTask");

    if (MCI_VALID_DEVICE_ID(wDeviceID)) {
        hCreatorTask = MCI_lpDeviceList[wDeviceID]->hCreatorTask;
    } else {
        hCreatorTask = NULL;
    }

    mciLeave("mciGetCreatorTask");

    return hCreatorTask;
}


/*
 * @doc INTERNAL MCI
 * @api BOOL FAR | mciDeviceMatch | Match the first string with the second.
 * Any single trailing digit on the first string is ignored.  Each string
 * must have at least one character
 *
 * @parm LPWSTR | lpstrDeviceName | The device name, possibly
 * with trailing digits but no blanks.
 *
 * @parm LPWSTR | lpstrDeviceType | The device type with no trailing digits
 * or blanks
 *
 * @rdesc TRUE if the strings match the above test, FALSE otherwise
 *
 */
STATICFN BOOL     mciDeviceMatch (
    LPCWSTR lpstrDeviceName,
    LPCWSTR lpstrDeviceType)
{
    BOOL bRetVal = TRUE, bAtLeastOne = FALSE;

// Scan until one of the strings ends
    dprintf2(("mciDeviceMatch: %ls Vs %ls",lpstrDeviceName,lpstrDeviceType));
    while (*lpstrDeviceName != '\0' && *lpstrDeviceType != '\0') {
        if (towlower(*lpstrDeviceName++) == towlower(*lpstrDeviceType++)) {
            bAtLeastOne = TRUE;
        } else {
            break;
        }
    }

// If end of device type, scan to the end of device name, trailing digits
// are OK
    if (!bAtLeastOne || *lpstrDeviceType != '\0') {
        return FALSE;
    }

    while (*lpstrDeviceName != '\0')
    {
// No match, but that is OK if a digit trails

        // Is the remainder of the string a digit?  We could check using
        // a simple if test (<0 or >9) but that would run into problems if
        // anyone ever passed a unicode "numeric" string outside the ascii
        // number range.  Using isdigit should be safer if marginally slower.

        if (!isdigit(*lpstrDeviceName)) {

            // No match - a non digit trails
            return FALSE;
        }

        ++lpstrDeviceName;
    }
    return TRUE;
}

/*
 * @doc INTERNAL MCI
 * @api UINT | mciLookUpType | Look up the type given a type name
 *
 * @parm LPCWSTR | lpstrTypeName | The type name to look up.  Trailing
 * digits are ignored.
 *
 * @rdesc The MCI type number (MCI_DEVTYPE_<x>) or 0 if not found
 *
 */
UINT mciLookUpType (
    LPCWSTR lpstrTypeName)
{
    UINT wType;
    WCHAR strType[MCI_MAX_DEVICE_TYPE_LENGTH];

    for (wType = MCI_DEVTYPE_FIRST; wType <= MCI_DEVTYPE_LAST; ++wType)
    {
        if ( LoadStringW( ghInst,
                          wType,
                          strType,
                          sizeof(strType) / sizeof(WCHAR) ) == 0)
        {
            dprintf1(("mciLookUpType:  could not load string for type"));
            continue;
        }

        if (mciDeviceMatch (lpstrTypeName, strType)) {
            return wType;
        }
    }
    return 0;
}

/*
 * @doc INTERNAL MCI
 * @api DWORD | mciSysinfo | Get system information about a device
 *
 * @parm MCIDEVICEID | wDeviceID | Device ID, may be 0
 *
 * @parm DWORD | dwFlags | SYSINFO flags
 *
 * @parm LPMCI_SYSINFO_PARMS | lpSysinfo | SYSINFO parameters
 *
 * @rdesc 0 if successful, otherwise error code
 *
 */
DWORD     mciSysinfo (
    MCIDEVICEID wDeviceID,
    DWORD dwFlags,
    LPMCI_SYSINFO_PARMSW lpSysinfo)
{
    UINT nCounted;
    WCHAR              strBuffer[MCI_PROFILE_STRING_LENGTH];
    LPWSTR             lpstrBuffer = strBuffer, lpstrStart;

    if (dwFlags & MCI_SYSINFO_NAME && lpSysinfo->dwNumber == 0)
        return MCIERR_OUTOFRANGE;

    if (lpSysinfo->lpstrReturn == NULL || lpSysinfo->dwRetSize == 0)
        return MCIERR_PARAM_OVERFLOW;

#ifdef LATER
//    if ((dwFlags & (MCI_SYSINFO_NAME | MCI_SYSINFO_INSTALLNAME))
//        && (dwFlags & MCI_SYSINFO_QUANTITY))
//    Should be invalid to ask for Quantity and any sort of name
#endif
    if (dwFlags & MCI_SYSINFO_NAME && dwFlags & MCI_SYSINFO_QUANTITY)
        return MCIERR_FLAGS_NOT_COMPATIBLE;

    if (dwFlags & MCI_SYSINFO_INSTALLNAME)
    {
        LPMCI_DEVICE_NODE nodeWorking;

        if (wDeviceID == MCI_ALL_DEVICE_ID)
            return MCIERR_CANNOT_USE_ALL;

        mciEnter("mciSysinfo");
        if (!MCI_VALID_DEVICE_ID (wDeviceID)) {
            mciLeave("mciSysinfo");
            return MCIERR_INVALID_DEVICE_NAME;
        }


#if DBG
        if ((nodeWorking = MCI_lpDeviceList[wDeviceID]) == NULL ||
            nodeWorking->lpstrInstallName == NULL)
        {
            dprintf1(("mciSysinfo:  NULL device node or installname"));
            mciLeave("mciSysinfo");
            return MCIERR_INTERNAL;
        }
#else
        nodeWorking = MCI_lpDeviceList[wDeviceID];
#endif


        if ( (DWORD)wcslen( nodeWorking->lpstrInstallName ) >=
               lpSysinfo->dwRetSize )
        {
            mciLeave("mciSysinfo");
            return MCIERR_PARAM_OVERFLOW;
        }

        wcscpy (lpSysinfo->lpstrReturn, nodeWorking->lpstrInstallName);
        mciLeave("mciSysinfo");
        return 0;

    } else if (!(dwFlags & MCI_SYSINFO_OPEN))
    {
        if (wDeviceID != MCI_ALL_DEVICE_ID &&
            lpSysinfo->wDeviceType == 0) {
            return MCIERR_DEVICE_TYPE_REQUIRED;
        }

        if ((dwFlags & (MCI_SYSINFO_QUANTITY | MCI_SYSINFO_NAME)) == 0)
            return MCIERR_MISSING_PARAMETER;

        GetPrivateProfileStringW( MCI_HANDLERS, NULL, wszNull,
                                 lpstrBuffer,
                                 MCI_PROFILE_STRING_LENGTH,
                                 MCIDRIVERS_INI_FILE);
        nCounted = 0;
        while (TRUE)
        {
            if (dwFlags & MCI_SYSINFO_QUANTITY)
            {

                if (*lpstrBuffer == '\0')
                {
                    if ( (lpSysinfo->lpstrReturn == NULL) ||
                         (sizeof(DWORD) > lpSysinfo->dwRetSize))
                        return MCIERR_PARAM_OVERFLOW;

                    *(UNALIGNED DWORD *)lpSysinfo->lpstrReturn = (DWORD)nCounted;
                    return MCI_INTEGER_RETURNED;
                }

                if (wDeviceID == MCI_ALL_DEVICE_ID ||
                    mciLookUpType (lpstrBuffer) == lpSysinfo->wDeviceType)
                    ++nCounted;

                // Skip past the terminating '\0'
                while (*lpstrBuffer++ != '\0') {}

            }
            else if (dwFlags & MCI_SYSINFO_NAME)   // if test is redundant
            {
                if (nCounted == lpSysinfo->dwNumber)
                {
                    /* NOTE:
                     * We know that lpSysinfo->dwNumber > 0
                     * Hence we will have been through the loop at least once
                     * Hence lpstrStart has been set up
                     */
                    if ( (DWORD)wcslen( lpstrStart ) >= lpSysinfo->dwRetSize )
                    {
                        return MCIERR_PARAM_OVERFLOW;
                    }
                    wcscpy (lpSysinfo->lpstrReturn, lpstrStart);
                    return 0L;

                } else if (*lpstrBuffer == '\0')
                    return MCIERR_OUTOFRANGE;
                else
                {
                    lpstrStart = lpstrBuffer;
                    if (wDeviceID == MCI_ALL_DEVICE_ID ||
                        mciLookUpType (lpstrBuffer) == lpSysinfo->wDeviceType)
                        ++nCounted;

                    // Skip past the terminating '\0'
                    while (*lpstrBuffer++ != '\0') {}
                }
            }
        }
    } else
// Process MCI_SYSINFO_OPEN cases
    {
        MCIDEVICEID wID;
        HANDLE hCurrentTask = GetCurrentTask();
        LPMCI_DEVICE_NODE Node;

        if (wDeviceID != MCI_ALL_DEVICE_ID &&
            lpSysinfo->wDeviceType == 0)
            return MCIERR_DEVICE_TYPE_REQUIRED;

        if ((dwFlags & (MCI_SYSINFO_QUANTITY | MCI_SYSINFO_NAME)) == 0)
            return MCIERR_MISSING_PARAMETER;

        nCounted = 0;

        mciEnter("mciSysinfo");

        for (wID = 1; wID < MCI_wNextDeviceID; ++wID)
        {
            if ((Node = MCI_lpDeviceList[wID]) == 0)
                continue;

            if (wDeviceID == MCI_ALL_DEVICE_ID &&
                 Node->hOpeningTask == hCurrentTask) {
                ++nCounted;
            }
            else
            {
                if (Node->wDeviceType == lpSysinfo->wDeviceType &&
                    Node->hOpeningTask == hCurrentTask)
                    ++nCounted;
            }

            if (dwFlags & MCI_SYSINFO_NAME &&
                nCounted == lpSysinfo->dwNumber)
            {
                DWORD dwReturn;
                if ( (DWORD)wcslen( Node->lpstrName ) >= lpSysinfo->dwRetSize )
                {
                    dwReturn = MCIERR_PARAM_OVERFLOW;
                } else {
                    wcscpy (lpSysinfo->lpstrReturn, Node->lpstrName);
                    dwReturn = 0;
                }
                mciLeave("mciSysinfo");
                return dwReturn;
            }
        }

        mciLeave("mciSysinfo");

        if (dwFlags & MCI_SYSINFO_NAME)
        {
            if (lpSysinfo->lpstrReturn != NULL)
                lpSysinfo->lpstrReturn = '\0';
            return MCIERR_OUTOFRANGE;

        } else if (dwFlags & MCI_SYSINFO_QUANTITY &&  // checking for QUANTITY is redundant
                   lpSysinfo->lpstrReturn != NULL &&
                   lpSysinfo->dwRetSize >= 4) {

            *(UNALIGNED DWORD *)lpSysinfo->lpstrReturn = nCounted;
            return MCI_INTEGER_RETURNED;
        }
    }
    return MCIERR_PARAM_OVERFLOW;
}

/*
 * @doc INTERNAL MCI
 * @api MCIDEVICEID | wReserveDeviceID | Copy the given global handle into the
 * first free entry in the MCI device table and return that entry's ID#
 *
 * @parm HANDLE | hNode | Local handle to device description
 *
 * @rdesc The ID value that has been reserved for this device or 0 if
 * there are no more free entries
 *
 */

STATICFN MCIDEVICEID wReserveDeviceID (
    LPMCI_DEVICE_NODE node)
{
    UINT wDeviceID;
    LPMCI_DEVICE_NODE FAR *lpTempList;

    mciEnter("wReserveDeviceID");
// Search for an empty slot
    for (wDeviceID = 1; wDeviceID < MCI_wNextDeviceID; ++wDeviceID)
        if (MCI_lpDeviceList[wDeviceID] == NULL) {
            goto slot_found;
        }
    // No empty slots found so add to end

    if (wDeviceID >= MCI_wDeviceListSize)
    {
        // The list is full (or non existent) so try to grow it
        if ((lpTempList = mciReAlloc (MCI_lpDeviceList,
                    sizeof (LPMCI_DEVICE_NODE) * (MCI_wDeviceListSize + 1 +
                                                  MCI_DEVICE_LIST_GROW_SIZE)))
            == NULL)
        {
            dprintf1(("wReserveDeviceID:  cannot grow device list"));
            mciLeave("wReserveDeviceID");
            return 0;
        }

        MCI_lpDeviceList = lpTempList;
        MCI_wDeviceListSize += MCI_DEVICE_LIST_GROW_SIZE;
    }

    ++MCI_wNextDeviceID;

slot_found:;

    MCI_lpDeviceList[wDeviceID] = node;

    mciLeave("wReserveDeviceID");

    return (MCIDEVICEID)wDeviceID;
}

//
// Allocate space for the given string and assign the name to the given
// device.
// Return FALSE if could not allocate memory
//
STATICFN BOOL NEAR mciAddDeviceName(
    LPMCI_DEVICE_NODE nodeWorking,
    LPCWSTR lpDeviceName)
{
    nodeWorking->lpstrName = (LPWSTR)mciAlloc(
                                BYTE_GIVEN_CHAR( wcslen(lpDeviceName) + 1 ) );

    if (nodeWorking->lpstrName == NULL)
    {
        dprintf1(("mciAddDeviceName:  Out of memory allocating device name"));
        return FALSE;
    }

    // copy device name to mci node and lowercase it

    wcscpy(nodeWorking->lpstrName, (LPWSTR)lpDeviceName);
//!!    mciToLower(nodeWorking->lpstrName);

    return TRUE;
}

/*
 * @doc INTERNAL MCI
 * @api HANDLE | mciAllocateNode | Allocate a new driver entry
 *
 * @parm DWORD | dwFlags | As sent with MCI_OPEN message
 * @parm LPCWSTR | lpDeviceName | The device name
 * @parm LPMCI_DEVICE_NODE * | *lpNewNode | Return pointer location
 *
 * @rdesc The device ID to the new node.  0 on error.
 *
 * @comm Leaves the new node locked
 *
 */
STATICFN MCIDEVICEID NEAR mciAllocateNode (
    DWORD dwFlags,
    LPCWSTR lpDeviceName,
    LPMCI_DEVICE_NODE FAR *lpnodeNew)
{
    LPMCI_DEVICE_NODE   nodeWorking;

    if ((nodeWorking = mciAlloc(sizeof(MCI_DEVICE_NODE))) == NULL)
    {
        dprintf1(("Out of memory in mciAllocateNode"));
        return 0;
    }

/* Fill in the new node */

/* Get a new device ID, if there are none available then bail */
    if ((nodeWorking->wDeviceID = wReserveDeviceID(nodeWorking)) == 0)
    {
        dprintf1(("mciAllocateNode:  Cannot allocate new node"));
        mciFree(nodeWorking);
        return 0;
    }

// Initialize node
    nodeWorking->dwMCIOpenFlags = dwFlags;
    nodeWorking->hCreatorTask = GetCurrentTask ();
    nodeWorking->hOpeningTask = nodeWorking->hCreatorTask;
// The new node is zeroed
//  nodeWorking->fpYieldProc = NULL;
//  nodeWorking->dwMCIFlags  = 0;

    if (dwFlags & MCI_OPEN_ELEMENT_ID)
// No device name, just an element ID
        nodeWorking->dwElementID = PtrToUlong(lpDeviceName);

    else
        if (!mciAddDeviceName (nodeWorking, lpDeviceName))
        {
            mciFree (nodeWorking);
            return 0;
        }

    *lpnodeNew = nodeWorking;
    return nodeWorking->wDeviceID;
}

//
// Reparse the original command parameters
// Returns MCIERR code.  If the reparse fails the original error code
// from the first parsing is returned.
//
STATICFN UINT mciReparseOpen (
    LPMCI_INTERNAL_OPEN_INFO lpOpenInfo,
    UINT wCustomTable,
    UINT wTypeTable,
    LPDWORD lpdwFlags,
    LPMCI_OPEN_PARMSW FAR *lplpOpen,
    MCIDEVICEID wDeviceID)
{
    LPWSTR               lpCommand;
    LPDWORD             lpdwParams = NULL;
    UINT                wErr;
    UINT                wTable = wCustomTable;
    DWORD               dwOldFlags = *lpdwFlags;

     // If the custom table contains no open command
    if (wCustomTable == MCI_TABLE_NOT_PRESENT ||
        (lpCommand = FindCommandInTable (wCustomTable, wszOpen, NULL)) == NULL)
    {
        // Try the type specific table
        lpCommand = FindCommandInTable (wTypeTable, wszOpen, NULL);

        // If it still cannot be parsed
        if (lpCommand == NULL)
            return lpOpenInfo->wParsingError;
        wCustomTable = wTypeTable;
    }

    // A new version of 'open' was found
    // Free previous set of parameters
    mciParserFree (lpOpenInfo->lpstrPointerList);
    *lpdwFlags = 0;

    if ((lpdwParams =
            (LPDWORD)mciAlloc (sizeof(DWORD_PTR) * MCI_MAX_PARAM_SLOTS))
        == NULL)
            return MCIERR_OUT_OF_MEMORY;

    wErr = mciParseParams ( MCI_OPEN ,
                            lpOpenInfo->lpstrParams, lpCommand,
                            lpdwFlags,
                            (LPWSTR)lpdwParams,
                            sizeof(DWORD_PTR) * MCI_MAX_PARAM_SLOTS,
                            &lpOpenInfo->lpstrPointerList, NULL);

    // We don't need this around anymore
    mciUnlockCommandTable (wTable);

    // If there was a parsing error
    if (wErr != 0)
    {
        // Close device down
        mciCloseDevice (wDeviceID, 0L, NULL, FALSE);

        // Make sure this does not get free'd by mciSendString
        lpOpenInfo->lpstrPointerList = NULL;

        mciFree (lpdwParams);
        return wErr;
    }

    if (dwOldFlags & MCI_OPEN_TYPE)
    {
        // Device type was already extracted so add it manually
        ((LPMCI_OPEN_PARMSW)lpdwParams)->lpstrDeviceType
            = (*lplpOpen)->lpstrDeviceType;
        *lpdwFlags |= MCI_OPEN_TYPE;
    }

    if (dwOldFlags & MCI_OPEN_ELEMENT)
    {
        // Element name was already extracted so add it manually
        ((LPMCI_OPEN_PARMSW)lpdwParams)->lpstrElementName
            = (*lplpOpen)->lpstrElementName;
        *lpdwFlags |= MCI_OPEN_ELEMENT;
    }

    if (dwOldFlags & MCI_OPEN_ALIAS)
    {
        // Alias name was already extracted so add it manually
        ((LPMCI_OPEN_PARMSW)lpdwParams)->lpstrAlias
            = (*lplpOpen)->lpstrAlias;
        *lpdwFlags |= MCI_OPEN_ALIAS;
    }

    if (dwOldFlags & MCI_NOTIFY)
        // Notify was already extracted so add it manually
        ((LPMCI_OPEN_PARMSW)lpdwParams)->dwCallback
            = (*lplpOpen)->dwCallback;

    // Replace old parameter list with new list
    *lplpOpen = (LPMCI_OPEN_PARMSW)lpdwParams;

    return 0;
}

//**************************************************************************
// mciFindDriverName
//
// See if lpstrDriverName exists in the profile strings of the [mci]
// section and return the keyname in lpstrDevice and the
// profile string in lpstrProfString
// Returns 0 on success or an error code
//**************************************************************************
STATICFN DWORD mciFindDriverName (
    LPCWSTR lpstrDriverName,
    LPWSTR lpstrDevice,
    LPWSTR lpstrProfString,
    UINT wProfLength)    // this should be a character count
{
    LPWSTR lpstrEnum, lpstrEnumStart;
    UINT wEnumLen = 100;
    DWORD wErr;
    LPWSTR lpstrDriverTemp, lpstrProfTemp;

// Enumerate values, trying until they fit into the buffer
    while (TRUE) {
        if ((lpstrEnum = mciAlloc( BYTE_GIVEN_CHAR(wEnumLen) ) ) == NULL)
            return MCIERR_OUT_OF_MEMORY;

        wErr = GetPrivateProfileStringW( MCI_HANDLERS,
                                        NULL, wszNull,
                                        lpstrEnum,
                                        wEnumLen,
                                        MCIDRIVERS_INI_FILE );

        if (*lpstrEnum == '\0')
        {
            mciFree (lpstrEnum);
            return MCIERR_DEVICE_NOT_INSTALLED;
        }

        if (wErr == wEnumLen - 2)
        {
            wEnumLen *= 2;
            mciFree (lpstrEnum);
        } else
            break;
    }

    lpstrEnumStart = lpstrEnum;
    if ( wcslen(lpstrDriverName) >= MCI_MAX_DEVICE_TYPE_LENGTH ) {
        wErr = MCIERR_DEVICE_LENGTH;
        goto exit_fn;
    }
    wcscpy(lpstrDevice, lpstrDriverName);
//!!    mciToLower (lpstrDevice);

// Walk through each string
    while (TRUE) {
        wErr = GetPrivateProfileStringW( MCI_HANDLERS,
                                        lpstrEnum, wszNull, lpstrProfString,
                                        wProfLength,
                                        MCIDRIVERS_INI_FILE );
        if (*lpstrProfString == '\0')
        {
            dprintf1(("mciFindDriverName: cannot load valid keyname"));
            wErr = MCIERR_CANNOT_LOAD_DRIVER;
            goto exit_fn;
        }
// See if driver pathname matches input
//!!        mciToLower (lpstrProfString);
        lpstrDriverTemp = lpstrDevice;
        lpstrProfTemp = lpstrProfString;
// Find end of file name
        while (*lpstrProfTemp != '\0' && *lpstrProfTemp != ' ')
            ++lpstrProfTemp;
// Find begining of simple file name
        --lpstrProfTemp;
        while (*lpstrProfTemp != '\\' && *lpstrProfTemp != '/' &&
               *lpstrProfTemp != ':')
            if (--lpstrProfTemp < lpstrProfString)
                break;
        ++lpstrProfTemp;
// Compare to input
        while (*lpstrDriverTemp != '\0')
            if (*lpstrDriverTemp++ != *lpstrProfTemp++ ||
                (UINT)(lpstrProfTemp - lpstrProfString) >= wProfLength)
            {
                --lpstrProfTemp;
                break;
            }
// If the input was contained in the profile string and followed by
// a space or a '.' then we've got it!
        if (*lpstrDriverTemp == '\0' &&
            (*lpstrProfTemp == ' ' || *lpstrProfTemp == '.'))
        {
            if (wcslen (lpstrEnum) >= MCI_MAX_DEVICE_TYPE_LENGTH)
            {
                dprintf1(("mciFindDriverName: device name too long"));
                wErr = MCIERR_DEVICE_LENGTH;
                goto exit_fn;
            }
            wcscpy (lpstrDevice, lpstrEnum);
            wErr = 0;
            goto exit_fn;
        }
// Skip to next keyname
        while (*lpstrEnum++ != '\0') {}
// Error if no more left
        if (*lpstrEnum == 0)
        {
            wErr = MCIERR_INVALID_DEVICE_NAME;
            goto exit_fn;
        }
    }

exit_fn:
    mciFree (lpstrEnumStart);
    return wErr;
}

//
// Identifies the driver name to load
// Loads the driver
// Reparses open command if necessary
// Sets a default break key
//
// lpOpenInfo contains various info for reparsing
//
// bDefaultAlias indicates that the alias need not be verified because
// it was internally assigned
//
STATICFN DWORD mciLoadDevice (
    DWORD dwFlags,
    LPMCI_OPEN_PARMSW lpOpen,
    LPMCI_INTERNAL_OPEN_INFO lpOpenInfo,
    BOOL bDefaultAlias)
{
    LPMCI_DEVICE_NODE       nodeWorking;
    HANDLE                  hDriver;
    MCIDEVICEID             wID;
    DWORD                   wErr;
    WCHAR                   strProfileString[MCI_PROFILE_STRING_LENGTH];
    WCHAR                   szDriverParms[128];
    MCI_OPEN_DRIVER_PARMS   DriverOpen;
    HANDLE                  hDrvDriver;
    LPWSTR                  lpstrParams;
    LPCWSTR                 lpstrInstallName, lpstrDeviceName;
    LPWSTR                  lpstrCopy = NULL;
    LPMCI_OPEN_PARMSW       lpOriginalOpenParms = lpOpen;

    /* Open a normal device */

#if DBG
    if (lpOpen && lpOpen->lpstrDeviceType) {
        dprintf2(("mciLoadDevice(%ls)", lpOpen->lpstrDeviceType));
    } else {
        dprintf2(("mciLoadDevice()"));
    }

#endif

    /* Check for the device name in MCIDRIVERS_INI_FILE */
    lpstrInstallName = lpOpen->lpstrDeviceType;
    wErr = GetPrivateProfileStringW( MCI_HANDLERS,
                                    lpstrInstallName,
                                    wszNull,
                                    strProfileString,
                                    MCI_PROFILE_STRING_LENGTH,
                                    MCIDRIVERS_INI_FILE );

    // If device name not found
    if (wErr == 0)
    {
        int nLen = wcslen(lpstrInstallName);
        int index;

        // Try for the device name with a '1' thru a '9' appended to it

        if ((lpstrCopy = (LPWSTR)mciAlloc( BYTE_GIVEN_CHAR(nLen+2)
                /* space for digit too */  ) ) == NULL)
        {
            dprintf1(("mciLoadDevice:  cannot allocate device name copy"));
            return MCIERR_OUT_OF_MEMORY;
        }
        wcscpy( lpstrCopy, lpstrInstallName );

        lpstrCopy[nLen + 1] = '\0';

        for (index = 1; index <= 9; ++index)
        {
            lpstrCopy[nLen] = (WCHAR)('0' + index);
            wErr = GetPrivateProfileStringW(
                        MCI_HANDLERS,
                        lpstrCopy,
                        wszNull,
                        strProfileString,
                        MCI_PROFILE_STRING_LENGTH,
                        MCIDRIVERS_INI_FILE );

            if (wErr != 0) {
            dprintf2(("Loaded driver name %ls >> %ls", lpstrCopy, strProfileString));
                break;
            }
        }

        if (wErr == 0)
        {
            mciFree (lpstrCopy);
            if ((lpstrCopy = (LPWSTR)mciAlloc( BYTE_GIVEN_CHAR( MCI_MAX_DEVICE_TYPE_LENGTH )))
                == NULL)
            {
                dprintf1(("mciLoadDevice:  cannot allocate device name copy"));
                return MCIERR_OUT_OF_MEMORY;
            }
            if ((wErr = mciFindDriverName(
                            lpstrInstallName,
                            lpstrCopy,
                            strProfileString,
                            MCI_PROFILE_STRING_LENGTH )) != 0)
            {
                dprintf1(("mciLoadDevice - invalid device name %ls", lpstrInstallName));
                goto exit_fn;
            }
        }
        lpstrInstallName = lpstrCopy;
    }

    // Break out the device driver pathname and the parameter list

    lpstrParams = strProfileString;

    // Eat characters until blank or null reached
    while (*lpstrParams != ' ' && *lpstrParams != '\0') {
        ++lpstrParams;
    }

    // Terminate driver file name, and separate the driver file name from its
    // parameters.  If there are no parameters, i.e. *lpstrParams=='\0',
    // leave lpstrParams pointing at the null.  Otherwise put a null
    // character to terminate the driver file name and step the pointer to
    // the first character in the parameter string.

    if (*lpstrParams == ' ') { *lpstrParams++ = '\0'; }

    //
    // We have changed from Win 3.1.  Because users cannot write to
    // system.ini the parameters have to be read from Win.Ini
    // section name [dll_name]
    // keyword         alias=parameters
    // If there are any parameters on the line read from [Drivers] use
    // them as a default.  This does preserve compatibility for those
    // applications that write directly to system.ini (and have the
    // privileges to get away with it).
    //
    // LATER: This stuff will be in the registry once the drivers themselves
    // (or it could be the drivers applet) creates a registry mapping.

    GetProfileString(strProfileString, lpstrInstallName, lpstrParams,
                     szDriverParms, sizeof(szDriverParms)/sizeof(WCHAR));
    lpstrParams = szDriverParms;
    dprintf3(("Parameters for device %ls (Driver %ls) >%ls<",
              lpstrInstallName, strProfileString, szDriverParms));

    //Now "strProfileString" is the device driver and "lpstrParams" is
    //the parameter string
    if (dwFlags & (MCI_OPEN_ELEMENT | MCI_OPEN_ELEMENT_ID)) {
        lpstrDeviceName = lpOpen->lpstrElementName;
    } else {
        lpstrDeviceName = lpOpen->lpstrDeviceType;
    }

    if (dwFlags & MCI_OPEN_ALIAS)
    {
        // If the alias is default then we've already checked its uniqueness
        if (!bDefaultAlias
        &&  mciGetDeviceIDInternal (lpOpen->lpstrAlias,
                                    lpOpenInfo->hCallingTask) != 0)
        {
            wErr = MCIERR_DUPLICATE_ALIAS;
            dprintf1(("mciLoadDevice - duplicate alias"));
            goto exit_fn;
        }
        lpstrDeviceName = lpOpen->lpstrAlias;
    }

    wID = mciAllocateNode (dwFlags, lpstrDeviceName, &nodeWorking);

    if (wID == 0)
    {
        dprintf1(("mciLoadDevice - cannot allocate new node, driver not loaded"));
        wErr = MCIERR_CANNOT_LOAD_DRIVER;
        goto exit_fn;
    }

    // Identify the task which initiated the open command
    if (lpOpenInfo->hCallingTask != NULL) {
        nodeWorking->hOpeningTask = lpOpenInfo->hCallingTask;
    } else {
        nodeWorking->hOpeningTask = GetCurrentTask();
    }

    if (nodeWorking->hOpeningTask != nodeWorking->hCreatorTask)
        nodeWorking->dwMCIFlags |= MCINODE_ISAUTOOPENED;

    // Initialize the driver
    DriverOpen.lpstrParams = lpstrParams;
    DriverOpen.wCustomCommandTable = MCI_TABLE_NOT_PRESENT;
    DriverOpen.wType = 0;
    DriverOpen.wDeviceID = wID;


    // Load the driver
    hDrvDriver = DrvOpen (strProfileString, MCI_HANDLERS,
                          (DWORD_PTR)(LPMCI_OPEN_DRIVER_PARMS)&DriverOpen);

    if (hDrvDriver == NULL)
    {
        dprintf1(("mciLoadDevice:  DrvOpen failed"));
        // Assume driver has free'd any custom command table when it failed the open
        mciFreeDevice (nodeWorking);
        wErr = MCIERR_CANNOT_LOAD_DRIVER;
        goto exit_fn;
    }

    lpOpen->wDeviceID = wID;
    //lpOpen->wReserved0 = 0;  Field does not exist in 32bit NT

    hDriver = DrvGetModuleHandle (hDrvDriver);

    nodeWorking->hDrvDriver = hDrvDriver;
    nodeWorking->hDriver = hDriver;

    // Driver provides custom device table and type
    nodeWorking->wCustomCommandTable = DriverOpen.wCustomCommandTable;
    nodeWorking->wDeviceType = DriverOpen.wType;

    // Load driver's type table
    if ((nodeWorking->wCommandTable = mciLoadTableType (DriverOpen.wType))
        == MCI_TABLE_NOT_PRESENT) {
        // Load from a file if necessary
        nodeWorking->wCommandTable =
            mciLoadCommandResource (ghInst, lpOpen->lpstrDeviceType,
                                    DriverOpen.wType);
        dprintf3(("  Command table id: %08XH", nodeWorking->wCommandTable));
    }


    // Record this for 'sysinfo installname'
    if ((nodeWorking->lpstrInstallName =
                  mciAlloc( BYTE_GIVEN_CHAR( wcslen( lpstrInstallName ) + 1 )))
        == NULL)
    {
        mciCloseDevice (wID, 0L, NULL, FALSE);
        dprintf1(("mciLoadDevice - out of memory"));
        wErr = MCIERR_OUT_OF_MEMORY;
        goto exit_fn;
    } else
        wcscpy( nodeWorking->lpstrInstallName, lpstrInstallName );

    // Reparse the input command if no type was known the first time or if
    // there was a custom command table
    // and there were any open command parameters
    if (lpOpenInfo->lpstrParams != NULL)
    {
        if ((wErr = mciReparseOpen (lpOpenInfo,
                                    nodeWorking->wCustomCommandTable,
                                    nodeWorking->wCommandTable,
                                    &dwFlags, &lpOpen, wID)) != 0)
        {
            dprintf1(("mciLoadDevice - error reparsing input command"));
            mciCloseDevice (wID, 0L, NULL, FALSE);
            goto exit_fn;
        }
        // If there is no custom command table but mciSendString had a parsing
        // error then close the device and report the error now
    } else if (lpOpenInfo->wParsingError != 0)
    {
        mciCloseDevice (wID, 0L, NULL, FALSE);
        wErr = lpOpenInfo->wParsingError;
        goto exit_fn;
    }

    /* Send MCI_OPEN_DRIVER command to device */
    wErr = LOWORD(mciSendCommandW(wID, MCI_OPEN_DRIVER,
                                 dwFlags, (DWORD_PTR)lpOpen));

    // If the OPEN failed then close the device (don't send a CLOSE though)
    if (wErr != 0)
        mciCloseDevice (wID, 0L, NULL, FALSE);
    else
        // Set default break key
        mciSetBreakKey (wID, VK_CANCEL, NULL);

    // If we replaced the open parms here then free them
    if (lpOriginalOpenParms != lpOpen && lpOpen != NULL)
        mciFree (lpOpen);

exit_fn:
    if (lpstrCopy != NULL)
        mciFree (lpstrCopy);

    return wErr;
}

/*
 * @doc INTERNAL MCI
 * @api BOOL | mciExtractDeviceType | If the given device name ends with
 * a file extension (.???) then try to get a typename from the
 * [mci extensions] section of WIN.INI
 *
 * @parm LPCWSTR | lpstrDeviceName | The name to get the type from
 *
 * @parm LPWSTR | lpstrDeviceType | The device type, returned to caller.
 *
 * @parm UINT | wBufLen | The length of the output buffer
 *
 * @rdesc TRUE if the type was found, FALSE otherwise
 *
 */
BOOL mciExtractDeviceType (
    LPCWSTR lpstrDeviceName,
    LPWSTR  lpstrDeviceType,
    UINT   wBufLen)
{
    LPCWSTR lpstrExt = lpstrDeviceName;
    int i;

    dprintf2(("mciExtractDeviceType(%ls)", lpstrDeviceName));

#if 0
#ifdef BAD_CODE
//This block cannot be used because it returns FALSE whenever a ! is found.
//Hence if the directory name has a ! ...
//N.B. The ! is used by MCI as a compound device name separator, but that is
//not applicable when going through this routine.

    // Goto end of string
    while (*lpstrExt != '\0')
    {
        // WARNING: This causes problems when the directory name has a !
        // '!' case is handled elsewhere
        if (*lpstrExt++ == '!')
            return FALSE;

        // Pointer has been incremented in the test
    }
#else
    // Goto end of string
    lpstrExt += wcslen(lpstrExt);
#endif
#else

    /*
    ** scan the string looking for a '!' character.  If we find one
    ** replace it with a NULL and see if the string to its left is a
    ** supported device type.  If it is return FALSE, either way replace the
    ** '\0' character with a '!'.
    */
    {
        LPWSTR lpwstr = wcschr(lpstrExt, '!' );

        /*
        ** If we found a '!' and it wasn't the first character in the
        ** the string we might have a compound device name.
        */
        if ( (lpwstr != NULL) && (lpwstr != lpstrExt) ) {

            int     nResult;
            WCHAR   wTmp[33];

            /*
            ** We're not interested in the actual string returned only if
            ** it is present in the list of mci devices.  A return code
            ** of 0 from GetPrivateProfileStringW means we don't have a
            ** compound name.
            */
            *lpwstr = '\0';
            nResult = GetPrivateProfileStringW( MCI_HANDLERS, lpstrExt, wszNull,
                                          wTmp, sizeof(wTmp) / sizeof(WCHAR),
                                          MCIDRIVERS_INI_FILE);
            /*
            ** Restore the original string
            */
            *lpwstr = '!';

            if ( nResult != 0 ) {
                return FALSE;
            }
        }
    }

    // Goto end of string
    lpstrExt += wcslen(lpstrExt);

#endif

    // Must be at least 2 characters in string
    if (lpstrExt - lpstrDeviceName < 2) {
        return FALSE;
    }

    // Now looking at the NULL terminator.  Check the
    // previous characters for a '.'

    for (i=1; i<=32; ++i)
    {
        --lpstrExt;

        // Cannot have path separator here
        if (*lpstrExt == '/' || *lpstrExt == '\\') {
            return FALSE;
        }

        if (*lpstrExt == '.')
        {
            if (1==i) {
            return(FALSE);
            // Would mean that extension is a null string
            }

#if DBG
            if (0 != (GetProfileStringW(MCI_EXTENSIONS, ++lpstrExt,
                                            wszNull, lpstrDeviceType, wBufLen))) {
                dprintf2(("Read extension %ls from section %ls. Driver=%ls", lpstrExt, MCI_EXTENSIONS, lpstrDeviceType));
                return(TRUE);
            } else {
                dprintf2(("Failed to read extension %s from section %s.", lpstrExt, MCI_EXTENSIONS));
                return(FALSE);
            }
#else
            return(0 != (GetProfileStringW(MCI_EXTENSIONS, ++lpstrExt,
                                           wszNull, lpstrDeviceType, wBufLen)));
#endif
        }

        if (lpstrExt == lpstrDeviceName) {
            return FALSE;
            // We have run out of string
        }

    }
    return FALSE;
}

// Copy characters up to cSeparater into output which is allocated
// by this function using mciAlloc.  Return the input pointer pointing
// to the character after cSeparator
// unless the separator is '\0' in which case it points to the end.
//
// Return the allocated pointer
//
// If bMustFind then the output string is created only if the token
// is found and is otherwise NULL.  Else the output string is always created.
//
// cSeparator is ignored inside matching quotes ("abd"), the quotes
// are not coppied and doubled
// quotes inside are compressed to one.  There must be a terminating quote.
// Quotes are treated normally unless the first character is a quote
//
// Function return value is 0 or an MCIERR code.  A missing separator does
// not cause an error return.
UINT mciEatToken (
    LPCWSTR *lplpstrInput,
    WCHAR cSeparater,
    LPWSTR *lplpstrOutput,
    BOOL bMustFind)
{
    LPCWSTR lpstrEnd = *lplpstrInput, lpstrCounter;
    LPWSTR  lpstrOutput;
    UINT wLen;
    BOOL bInQuotes = FALSE, bParseQuotes = TRUE, bQuoted = FALSE;

// Clear output
   *lplpstrOutput = NULL;

// Scan for token or end of string
    while ((*lpstrEnd != cSeparater || bInQuotes) && *lpstrEnd != '\0')
    {
// If quote
        if (*lpstrEnd == '"' && bParseQuotes)
        {
// If inside quotes
            if (bInQuotes)
            {
// If next character is a quote also
                if (*(lpstrEnd + 1) == '"')
// Skip it
                    ++lpstrEnd;
                else
                    bInQuotes = FALSE;
            } else {
                bInQuotes = TRUE;
                bQuoted = TRUE;
            }
        } else if (!bInQuotes)
        {
            if (bQuoted)
                return MCIERR_EXTRA_CHARACTERS;
// A non-quote was read first so treat any quotes as normal characters
            bParseQuotes = FALSE;
        }
        ++lpstrEnd;
    }

    if (bInQuotes)
        return MCIERR_NO_CLOSING_QUOTE;

// Fail if the token was not found and bMustFind is TRUE
    if (*lpstrEnd != cSeparater && bMustFind)
        return 0;

// Length of new string (INCLUDES QUOTES NOT COPIED)
    wLen = (UINT)(lpstrEnd - *lplpstrInput + 1);

    if ((*lplpstrOutput = mciAlloc( BYTE_GIVEN_CHAR( wLen ) )) == NULL)
        return MCIERR_OUT_OF_MEMORY;

// Copy into allocated space
    lpstrCounter = *lplpstrInput;
    lpstrOutput = *lplpstrOutput;
    bInQuotes = FALSE;

    while (lpstrCounter != lpstrEnd)
    {
        if (*lpstrCounter == '"' && bParseQuotes)
        {
            if (bInQuotes)
            {
// If this is a doubled quote
                if (*(lpstrCounter + 1) == '"')
// Copy it
                    *lpstrOutput++ = *lpstrCounter++;
                else
                    bInQuotes = FALSE;
            } else
                bInQuotes = TRUE;
// Skip the quote
            ++lpstrCounter;
        } else
            *lpstrOutput++ = *lpstrCounter++;
    }

    *lpstrOutput = '\0';
    if (*lpstrEnd == '\0')
        *lplpstrInput = lpstrEnd;
    else
        *lplpstrInput = lpstrEnd + 1;

    return 0;
}

// Take the type number from the open parameters and return
// it as a string in lplpstrType which must be free'd with mciFree
// Returns 0 or an MCI error code
UINT mciExtractTypeFromID (
    LPMCI_OPEN_PARMSW lpOpen)
{
    int nSize;
    LPWSTR lpstrType;

    if ((lpstrType = mciAlloc( BYTE_GIVEN_CHAR( MCI_MAX_DEVICE_TYPE_LENGTH ))) == NULL)
        return MCIERR_OUT_OF_MEMORY;

    // Load the type string corresponding to the ID
    if ((nSize = LoadStringW( ghInst,
                              LOWORD (PtrToUlong(lpOpen->lpstrDeviceType)),
                              lpstrType, MCI_MAX_DEVICE_TYPE_LENGTH ) ) == 0) {
        mciFree(lpstrType);
        return MCIERR_EXTENSION_NOT_FOUND;
    }

    // Add ordinal (if any) onto the end of the device type name
    if (HIWORD (lpOpen->lpstrDeviceType) != 0)
    {
        if (nSize > MCI_MAX_DEVICE_TYPE_LENGTH - 11)
        {
            dprintf1(("mciExtractTypeFromID:  type + ordinal too long"));
            mciFree(lpstrType);
            return MCIERR_DEVICE_ORD_LENGTH;
        }

        wsprintfW (lpstrType + nSize, szUnsignedFormat,
                    HIWORD (PtrToUlong(lpOpen->lpstrDeviceType)));
    }
    lpOpen->lpstrDeviceType = lpstrType;
    return 0;
}

/*
 * @doc INTERNAL MCI
 * @func UINT | mciOpenDevice | Open an MCI device for access.
 * Used in processing the MCI_OPEN message.
 *
 * @parm DWORD | dwFlags | Open Flags
 * @parm LPMCI_OPEN_PARMS | lpOpen | Description of device
 * @parm LPMCI_INTERNAL_OPEN_PARMS | lpOpenInfo | Internal device description
 *
 * @rdesc 0 if successful or an error code
 * @flag MCIERR_INVALID_DEVICE_NAME | Name not known
 * @flag MCIERR_DEVICE_OPEN | Device is already open and is not sharable
 *
 * @comm This function does the following:
 * 1) Check to see if device is already open.  If so, increase the use count
 *    and return the device ID
 *
 * Otherwise:
 *
 * 2) Locate the device name in the SYSTEM.INI file and load
 *    the corresponding device driver DLL
 *
 * 3) Allocate and initialize a new device description block
 *
 */
UINT mciOpenDevice (
    DWORD dwStartingFlags,
    LPMCI_OPEN_PARMSW lpOpen,
    LPMCI_INTERNAL_OPEN_INFO lpOpenInfo)
{
    LPWSTR               lpstrNewType = NULL;
    UINT                 wID;
    DWORD                wReturn;
    LPCWSTR              lpstrDeviceName;
    LPWSTR               lpstrNewElement = NULL;
    BOOL                 bFromTypeID = FALSE;
    LPCWSTR              lpstrOriginalType;
    LPCWSTR              lpstrOriginalElement;
    LPCWSTR              lpstrOriginalAlias;
    DWORD                dwFlags = dwStartingFlags;
    BOOL                 bDefaultAlias = FALSE;


// Initialize
    if (lpOpen == NULL) {
        dprintf2(("mciOpenDevice()   NULL parameter block"));
        return MCIERR_NULL_PARAMETER_BLOCK;
    }

    ClientUpdatePnpInfo();

    lpstrOriginalType = lpOpen->lpstrDeviceType;
    lpstrOriginalElement = lpOpen->lpstrElementName;
    lpstrOriginalAlias = lpOpen->lpstrAlias;

    // The type number is given explicitly, convert it to a type name
    if (dwFlags & MCI_OPEN_TYPE_ID) {
        if ((wReturn = mciExtractTypeFromID (lpOpen)) != 0)
            return (UINT)wReturn;
        else
            bFromTypeID = TRUE;
    }

    // The device name is the device type of a simple device or the device
    // element of a compound device

    if (dwFlags & MCI_OPEN_ELEMENT)
        lpstrDeviceName = lpstrOriginalElement;
    else if (dwFlags & MCI_OPEN_TYPE)
        lpstrDeviceName = lpOpen->lpstrDeviceType;
    else
        return MCIERR_MISSING_PARAMETER;

    if (lpstrDeviceName == NULL)
    {
        dprintf1(("mciOpenDevice:  Device name is NULL"));
        return MCIERR_INVALID_DEVICE_NAME;
    }

    // Is the device already open?
    if (dwFlags & MCI_OPEN_ELEMENT_ID)
        wID = mciGetDeviceIDFromElementIDW( PtrToUlong(lpstrDeviceName),
                                            lpOpen->lpstrDeviceType);
    else
        wID = mciGetDeviceIDInternal ((dwFlags & MCI_OPEN_ALIAS ?
                                       lpOpen->lpstrAlias : lpstrDeviceName),
                                       lpOpenInfo->hCallingTask);

    // If the device is open already then return an error
    if (wID != 0)
        return dwFlags & MCI_OPEN_ALIAS ? MCIERR_DUPLICATE_ALIAS :
                                          MCIERR_DEVICE_OPEN;

    // The device is not already open in that task by the name

    // If the type was derived then skip all this crap
    if (bFromTypeID)
        goto load_device;

    // If an element name is given but no type name (only via mciSendCommand)
    if (dwFlags & MCI_OPEN_ELEMENT && !(dwFlags & MCI_OPEN_TYPE))
    {

        // Allocate a piece of memory for resolving the device type
        lpstrNewType = mciAlloc( BYTE_GIVEN_CHAR(MCI_MAX_DEVICE_TYPE_LENGTH) );
        if (lpstrNewType == NULL) {
            return MCIERR_OUT_OF_MEMORY;
        }

        // Try to get the device type from the element name via a file extension
        if (mciExtractDeviceType( lpstrOriginalElement, lpstrNewType,
                                  MCI_MAX_DEVICE_TYPE_LENGTH))
        {
            lpOpen->lpstrDeviceType = lpstrNewType;
            dwFlags |= MCI_OPEN_TYPE;
        } else
        {
            mciFree (lpstrNewType);
            return MCIERR_EXTENSION_NOT_FOUND;
        }
    } else if (dwFlags & MCI_OPEN_TYPE && !(dwFlags & MCI_OPEN_ELEMENT))
    // A type name is given but no element
    {
        // Allocate a piece of memory for resolving the device type
        lpstrNewType = mciAlloc( BYTE_GIVEN_CHAR(MCI_MAX_DEVICE_TYPE_LENGTH) );
        if (lpstrNewType == NULL) {
            return MCIERR_OUT_OF_MEMORY;
        }

        // Try to extract a device type from the given device name via a file extension
        if (mciExtractDeviceType (lpOpen->lpstrDeviceType, lpstrNewType,
                                    MCI_MAX_DEVICE_TYPE_LENGTH))
        {
            // Fix up the type and element names
            dwFlags |= MCI_OPEN_ELEMENT;
            lpOpen->lpstrElementName = lpOpen->lpstrDeviceType;
            lpOpen->lpstrDeviceType = lpstrNewType;
        } else
        // Failed to extract type so...
        // Try to get a compound element name ('!' separator)
        {
            LPCWSTR lpstrTemp = lpOpen->lpstrDeviceType;

            mciFree (lpstrNewType);
            lpstrNewType = NULL;

            if ((wReturn = mciEatToken (&lpstrTemp, '!', &lpstrNewType, TRUE))
                != 0)
                goto cleanup;
            else if (lpstrNewType != NULL)
            {
                if ((wReturn = mciEatToken (&lpstrTemp, '\0',
                                            &lpstrNewElement, TRUE))
                    != 0)
                    goto cleanup;
                else if (lpstrNewElement != NULL &&
                           *lpstrNewElement != '\0')
                {
                    // See if this element name is in use
                    if (!(dwFlags & MCI_OPEN_ALIAS))
                        if (mciGetDeviceIDInternal (lpstrNewElement,
                                                    lpOpenInfo->hCallingTask))
                        {
                            wReturn = MCIERR_DEVICE_OPEN;
                            goto cleanup;
                        }
                    // Swap type and element for new ones
                    lpOpen->lpstrElementName = lpstrNewElement;
                    lpOpen->lpstrDeviceType = lpstrNewType;
                    dwFlags |= MCI_OPEN_ELEMENT;
                }
            }
        }
    } else
        lpstrNewType = NULL;

    // Tack on a default alias if none is given
    if (! (dwFlags & MCI_OPEN_ALIAS))
    {
        LPCWSTR lpstrAlias;

        // If an element name exists then the alias is the element name
        if (dwFlags & MCI_OPEN_ELEMENT)
        {
        // If a device ID was specified then there is no alias
            if (dwFlags & MCI_OPEN_ELEMENT_ID)
                lpstrAlias = NULL;
            else
                lpstrAlias = lpOpen->lpstrElementName;
        // Otherwise the alias is the device type
        } else
            lpstrAlias = lpOpen->lpstrDeviceType;

        if (lpstrAlias != NULL)
        {
            lpOpen->lpstrAlias = lpstrAlias;
            dwFlags |= MCI_OPEN_ALIAS;
            bDefaultAlias = TRUE;
        }
    }

load_device:;
    wReturn = mciLoadDevice (dwFlags, lpOpen, lpOpenInfo, bDefaultAlias);

cleanup:
    if (lpstrNewElement != NULL)
        mciFree (lpstrNewElement);
    if (lpstrNewType != NULL)
        mciFree (lpstrNewType);
    if (bFromTypeID)
        mciFree (lpOpen->lpstrDeviceType);

    // Replace original items
    lpOpen->lpstrDeviceType = lpstrOriginalType;
    lpOpen->lpstrElementName = lpstrOriginalElement;
    lpOpen->lpstrAlias = lpstrOriginalAlias;

    return (UINT)wReturn;
}

STATICFN void mciFreeDevice (LPMCI_DEVICE_NODE nodeWorking)
{
    LPMCI_DEVICE_NODE FAR *lpTempList;
    MCIDEVICEID uID = nodeWorking->wDeviceID;

    mciEnter("mciFreeDevice");

    if (nodeWorking->lpstrName != NULL)
        mciFree (nodeWorking->lpstrName);

    if (nodeWorking->lpstrInstallName != NULL)
        mciFree (nodeWorking->lpstrInstallName);

    mciFree(MCI_lpDeviceList[uID]);

    MCI_lpDeviceList[uID] = NULL;

/* If this was the last device in the list, decrement next ID value */
    if (uID + (MCIDEVICEID)1 == MCI_wNextDeviceID)
    {
        --MCI_wNextDeviceID;

// Try to reclaim any excess free space
        if (MCI_wDeviceListSize - MCI_wNextDeviceID + 1
            > MCI_DEVICE_LIST_GROW_SIZE)
        {
            MCI_wDeviceListSize -= MCI_DEVICE_LIST_GROW_SIZE;

            if ((lpTempList =
                mciReAlloc (MCI_lpDeviceList, sizeof (LPMCI_DEVICE_NODE) *
                                              MCI_wDeviceListSize)) == NULL)
                MCI_wDeviceListSize += MCI_DEVICE_LIST_GROW_SIZE;
            else
                MCI_lpDeviceList = lpTempList;
        }
    }

    mciLeave("mciFreeDevice");
}

typedef struct tagNotificationMsg {
    WPARAM wParam;
    LPARAM lParam;
} NOTIFICATIONMSG;

/*
 * @doc INTERNAL MCI
 * @api void | FilterNotification | Removes notifications for a given node
 *   from our notification window's message queue
 *
 * @parm LPMCI_DEVICE_NODE | nodeWorking | The internal device node
 *
 * @comm This function removes all MM_MCINOTIFY messages from hwndNotify's
 * message queue by removing all notifications for devices that have been
 * closed (i.e. do not belong to us), then putting the others back
 */
void FilterNotification(
LPMCI_DEVICE_NODE nodeWorking)
{
    NOTIFICATIONMSG anotmsg[256];
    UINT   uCurrentMsg;
    MSG    msg;

    /* We can't have the mci critical section on here because this PeekMessage
       will dispatch other messages in the queue */

    uCurrentMsg = 0;
    while (PeekMessage(&msg, hwndNotify, MM_MCINOTIFY, MM_MCINOTIFY, PM_NOYIELD | PM_REMOVE)) {
        if (LOWORD(msg.lParam) != nodeWorking->wDeviceID) {
            anotmsg[uCurrentMsg].wParam = msg.wParam;
            anotmsg[uCurrentMsg].lParam = msg.lParam;
            uCurrentMsg++;
        }
    }
    for (; uCurrentMsg;) {
        uCurrentMsg--;
        PostMessage(hwndNotify, MM_MCINOTIFY, anotmsg[uCurrentMsg].wParam, anotmsg[uCurrentMsg].lParam);
    }
}

/*
 * @doc INTERNAL MCI
 * @api UINT | mciCloseDevice | Close an MCI device.  Used in
 * processing the MCI_CLOSE message.
 *
 * @parm MCIDEVICEID | uID | The ID of the device to close
 * @parm DWORD | dwFlags | Close Flags
 * @parm LPMCI_GENERIC_PARMS | lpClose | Generic parameters
 * @parm BOOL | bCloseDriver | TRUE if the CLOSE command should be sent
 * on to the driver.
 *
 * @rdesc 0 if successful or an error code
 *
 * @comm This function sends an MCI_CLOSE_DEVICE message to the corresponding
 * driver if the use count is zero and then unloads the driver DLL
 *
 */
UINT mciCloseDevice (
    MCIDEVICEID uID,
    DWORD dwFlags,
    LPMCI_GENERIC_PARMS lpGeneric,
    BOOL bCloseDriver)
{
    LPMCI_DEVICE_NODE nodeWorking;
    UINT wErr;
    UINT wTable;

    mciEnter("mciCloseDevice");

    nodeWorking = MCI_lpDeviceList[uID];

    if (nodeWorking == NULL)
    {
        mciLeave("mciCloseDevice");
        dprintf1(("mciCloseDevice:  NULL node from device ID--error if not auto-close"));
        return 0;
    }

    // We should never be closed from the wrong task
#if 0
    WinAssert(nodeWorking->hCreatorTask == GetCurrentTask());
#endif

// If a close is in progress (usually this message comes from a Yield
// after a mciDriverNotify actuated by the active close) then exit
    if (ISCLOSING(nodeWorking)) {
        mciLeave("mciCloseDevice");
        return 0;
    }

    SETISCLOSING(nodeWorking);

    if (bCloseDriver)
    {
        MCI_GENERIC_PARMS   GenericParms;

        mciLeave("mciCloseDevice");
// Make fake generic params if close came internally
        if (lpGeneric == NULL) {
            lpGeneric = &GenericParms;
        }

        wErr = LOWORD(mciSendCommandW(uID, MCI_CLOSE_DRIVER, dwFlags,
                                            (DWORD_PTR)lpGeneric));
        mciEnter("mciCloseDevice");
    }
    else
        wErr = 0;

    wTable = nodeWorking->wCustomCommandTable;

    //
    // Must zero this to allow the table to be freed later by driver
    //
    // We mustn't call mciFreeCommandResource for the custom table
    // because the driver is going to do that when it gets DRV_FREE
    //
    nodeWorking->wCustomCommandTable = 0;

    wTable = nodeWorking->wCommandTable;
    nodeWorking->wCommandTable = 0;

    mciLeave("mciCloseDevice");

    mciFreeCommandResource (wTable);

    //
    // We're closing this node so remove any notifications queued to
    // hwndNotify because these would cause this node to be erroneously
    // closed again
    //

    if (ISAUTOOPENED(nodeWorking)) {
       FilterNotification(nodeWorking);
    }

    DrvClose (nodeWorking->hDrvDriver, 0L, 0L);  // ala CloseDriver

    mciFreeDevice (nodeWorking);

    return wErr;
}

/*
 * @doc INTERNAL MCI DDK
 * @api DWORD | mciGetDriverData | Returns a pointer to the instance
 * data associated with an MCI device
 *
 * @parm MCIDEVICEID | wDeviceID | The MCI device ID
 *
 * @rdesc The driver instance data.  On error, returns 0 but since
 * the driver data might be zero, this cannot be verified by the caller
 * unless the instance data is known to be non-zero (e.g. a pointer)
 *
 * @xref mciSetDriverData
 */
DWORD_PTR mciGetDriverData (
    MCIDEVICEID wDeviceID)
{
    DWORD_PTR   lpDriverData;

    mciEnter("mciGetDriverData");

    if (!MCI_VALID_DEVICE_ID(wDeviceID))
    {
        dprintf1(("mciGetDriverData:  invalid device ID"));
        lpDriverData = 0;
    } else {
        if (NULL == MCI_lpDeviceList[wDeviceID])
        {
            dprintf1(("mciGetDriverData:  NULL node from device ID"));
            lpDriverData = 0;
        } else {
            lpDriverData = MCI_lpDeviceList[wDeviceID]->lpDriverData;
        }
    }

    mciLeave("mciGetDriverData");

    return lpDriverData;
}

/*
 * @doc INTERNAL MCI DDK
 * @api BOOL | mciSetDriverData | Sets the instance
 * data associated with an MCI device
 *
 * @parm MCIDEVICEID | uDeviceID | The MCI device ID
 *
 * @parm DWORD | dwData | Driver data to set
 *
 * @rdesc 0 if the device ID is not known or there is insufficient
 * memory to load the device description.
 *
 */
BOOL mciSetDriverData (
    MCIDEVICEID wDeviceID,
    DWORD_PTR dwData)
{
    BOOL fReturn = TRUE;
    mciEnter("mciSetDriverData");

    if (!MCI_VALID_DEVICE_ID(wDeviceID))
    {
        dprintf1(("mciSetDriverData:  NULL node from device ID"));

        fReturn = FALSE;
    } else {
        MCI_lpDeviceList[wDeviceID]->lpDriverData = dwData;
    }

    mciLeave("mciSetDriverData");

    return fReturn;
}

/*
 * @doc INTERNAL MCI DDK
 * @api UINT | mciDriverYield | Used in a driver's idle loop
 * to yield to Windows
 *
 * @parm MCIDEVICEID | wDeviceID | Device ID that is yielding.
 *
 * @rdesc Non-zero if the driver should abort the operation.
 *
 */
UINT mciDriverYield (
    MCIDEVICEID  wDeviceID)
{
    mciEnter("mciDriverYield");

    if (MCI_VALID_DEVICE_ID(wDeviceID))
    {
        YIELDPROC YieldProc = (MCI_lpDeviceList[wDeviceID])->fpYieldProc;

        if (YieldProc != NULL) {
            DWORD YieldData = (MCI_lpDeviceList[wDeviceID])->dwYieldData;
            mciLeave("mciDriverYield");
            mciCheckOut();
            return (YieldProc)(wDeviceID, YieldData);
        }
    }

    mciLeave("mciDriverYield");

    Yield();
    return 0;
}


/*
 * @doc EXTERNAL MCI
 * @api BOOL | mciSetYieldProc | This function sets the address
 * of a procedure to be called periodically
 * when an MCI device is waiting for a command to complete because the WAIT
 * parameter was specified.
 *
 * @parm MCIDEVICEID | wDeviceID | Specifies the device ID to assign a procedure to.
 *
 * @parm YIELDPROC | fpYieldProc | Specifies the procedure to call
 * when yielding for the given device.  Set to NULL to disable
 * any existing yield proc.
 *
 * @parm DWORD | dwYieldData | Specifies the data sent to the yield procedure
 * when it is called for the given device.
 *
 * @rdesc Returns TRUE if successful. Returns FALSE for an invalid device ID.
 *
 * @comm This call overides any previous yield procedure for this device.
 *
 */
BOOL APIENTRY mciSetYieldProc (
    MCIDEVICEID wDeviceID,
    YIELDPROC fpYieldProc,
    DWORD dwYieldData)
{
    BOOL fReturn = FALSE;

    mciEnter("mciSetYieldProc");

    if (MCI_VALID_DEVICE_ID(wDeviceID))
    {
        LPMCI_DEVICE_NODE node = MCI_lpDeviceList[wDeviceID];

        node->fpYieldProc = fpYieldProc;
        node->dwYieldData = dwYieldData;

        fReturn = TRUE;
    } else
        fReturn = FALSE;

    mciLeave("mciSetYieldProc");

    return fReturn;
}

/*
 * @doc EXTERNAL MCI
 * @api YIELDPROC | mciGetYieldProc | This function gets the address
 * of the callback procedure to be called periodically when an MCI device
 * is completing a command specified with the WAIT flag.
 *
 * @parm UINT | wDeviceID | Specifies the device ID of the MCI device to
 * which the yield procedure is to be retrieved from.
 *
 * @parm LPDWORD | lpdwYieldData | Optionally specifies a buffer to place
 * the yield data passed to the function in.  If the parameter is NULL, it
 * is ignored.
 *
 * @rdesc Returns the current yield proc if any, else returns NULL for an
 * invalid device ID.
 *
 */
YIELDPROC WINAPI mciGetYieldProc (
    UINT wDeviceID,
    LPDWORD lpdwYieldData)
{
    YIELDPROC fpYieldProc;

    mciEnter("mciGetYieldProc");

    if (MCI_VALID_DEVICE_ID(wDeviceID))
    {
        if (lpdwYieldData != NULL) {
            V_WPOINTER(lpdwYieldData, sizeof(DWORD), NULL);
            *lpdwYieldData = MCI_lpDeviceList[wDeviceID]->dwYieldData;
        }
        fpYieldProc =  MCI_lpDeviceList[wDeviceID]->fpYieldProc;
    } else {
        fpYieldProc = NULL;
    }

    mciLeave("mciGetYieldProc");

    return fpYieldProc;
}


/*
 * @doc INTERNAL MCI
 * @api int | mciBreakKeyYieldProc | Procedure called to check a
 * key state for the given device
 *
 * @parm MCIDEVICEID | wDeviceID | Device ID which is yielding
 *
 * @parm DWORD | dwYieldData | Data for this device's yield proc
 *
 * @rdesc Non-zero if the driver should abort the operation. Currently
 * always returns 0.
 *
 */
UINT mciBreakKeyYieldProc (
    MCIDEVICEID wDeviceID,
    DWORD dwYieldData)
{
    HWND hwndCheck = NULL;
    int nVirtKey, nState;
    nVirtKey = dwYieldData;

    UNREFERENCED_PARAMETER(wDeviceID);

    nState = GetAsyncKeyState (nVirtKey);

// Break if key is down or has been down
    if (nState & 1 /* used to be 0x8000*/ )
    {
        MSG msg;
        while (PeekMessage (&msg, hwndCheck, WM_KEYFIRST, WM_KEYLAST,
               PM_REMOVE));
        return MCI_ERROR_VALUE;
    }

    Yield();
    return 0;
}

/*
 * @doc INTERNAL MCI
 * @api UINT FAR | mciSetBreakKey | Set a key which will break a wait loop
 * for a given driver
 *
 * @parm UINT | uDeviceID | The device ID to assign a break key to
 *
 * @parm int | nVirtKey | Virtual key code to trap
 *
 * @parm HWND | hwndTrap | The handle to a window that must be active
 * for the key to be trapped.  If NULL then all windows will be checked
 *
 * @rdesc TRUE if successful, FALSE if invalid device ID
 *
 */
UINT FAR mciSetBreakKey (
    MCIDEVICEID wDeviceID,
    int nVirtKey,
    HWND hwndTrap)
{
    dprintf2(("Setting break key for device %d to %x", wDeviceID, nVirtKey));
    return mciSetYieldProc (wDeviceID, mciBreakKeyYieldProc, nVirtKey);
    // Note: we have no way of passing hwndTrap... will check all windows
    // on this thread of the application
}

/*
 * @doc INTERNAL MCI
 * @api BOOL | mciDriverNotify | Used by a driver to send
 * a notification message
 *
 * @parm HANDLE | hCallback | The window to notify
 *
 * @parm UINT | wDeviceID | The device ID which triggered the callback
 *
 * @parm UINT | wStatus | The status of the callback.  May be one of
 * MCI_NOTIFY_SUCCESSFUL or MCI_NOTIFY_SUPERSEDED or MCI_NOTIFY_ABORTED or
 * MCI_NOTIFY_FAILURE
 *
 * @rdesc returns TRUE if notify was successfully sent, FALSE otherwise.
 *
 * @comm This function is callable at interrupt time
 *
 */
BOOL mciDriverNotify (
    HANDLE hCallback,
    MCIDEVICEID wDeviceID,
    UINT uStatus)
{
    BOOL f;

#if DBG
// IsWindow() is in segment marked PRELOAD for WIN3.0 so OK at interrupt time
    if (hCallback != NULL && !IsWindow(hCallback))
    {
        dprintf1(("mciDriverNotify: invalid window!"));
        return FALSE;
    }
#endif

    f = PostMessage(hCallback, MM_MCINOTIFY, uStatus, wDeviceID);

#if DBG
    if (!f)
        dprintf1(("mciDriverNotify: PostMessage failed!"));
#endif

    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\midistrm.c ===
/*******************************************************************************
*
* Module Name: midistrm.c
*
* MIDI Streams implementation
*
* Created: 9 Feb 1995   SteveDav
*
* Copyright (c) 1995-1999 Microsoft Corporation
*
\******************************************************************************/
#include "winmmi.h"

/*
 * MIDI Streaming API Port: For the time being, the assumption
 * is that the devices are static.  This code was designed to
 * be PnP friendly, with devices coming and going.  The
 * validation of devices will be commented out for now, but in
 * the future when NT is a more dynamic OS, the validation will
 * need to be added back.
 *
 */

extern BOOL CreatehwndNotify(VOID);

CRITICAL_SECTION midiStrmHdrCritSec;


WINMMAPI MMRESULT WINAPI midiDisconnect (
    HMIDI    hmi,
    HMIDIOUT hmo,
    LPVOID   lpv)
{
    dprintf2(("midiDisconnect(%08X,%08X,%08X)", hmi, hmo, lpv));
    return midiInSetThru (hmi, hmo, FALSE);
}

WINMMAPI MMRESULT WINAPI midiConnect (
    HMIDI    hmi,
    HMIDIOUT hmo,
    LPVOID   lpv)
{
    dprintf2(("midiConnect(%08X,%08X,%08X)", hmi, hmo, lpv));
    return midiInSetThru (hmi, hmo, TRUE);
}

/*+ midiInSetThru
 *
 *  Establish a thruing midiOut handle for a midiIn device.  This is
 *  done by first calling the driver to let the driver do the thruing,
 *  if the driver returns UNSUPPORTED a single thruing handle can
 *  be established by simulation in DriverCallback
 *
 *-====================================================================*/

MMRESULT midiInSetThru (
    HMIDI    hmi,
    HMIDIOUT hmo,
    BOOL     bAdd)
{
    MMRESULT mmr = MMSYSERR_ERROR; // this value should never get returned....
    UINT     uType;

    dprintf2(("midiInSetThru(%X,%X,%d)", hmi, hmo, bAdd));

    AcquireHandleListResourceShared();

    // allow first handle to be either midi in or midi out
    // (so that we can send DRVM_ADD_THRU messages to dummy
    // output drivers.)
    //
    // we simulate thruing only for input handles though...
    //
    if (BAD_HANDLE(hmi, TYPE_MIDIIN) && BAD_HANDLE(hmi, TYPE_MIDIOUT))
    {
        ReleaseHandleListResource();
        return MMSYSERR_INVALHANDLE;
    }

    uType = GetHandleType(hmi);
    if (bAdd)
    {
        if (BAD_HANDLE(hmo, TYPE_MIDIOUT))
        {
            ReleaseHandleListResource();
            return (MMSYSERR_INVALHANDLE);
        }

        //      !!! Devices are static on NT for now.
        //
        //if (!mregQueryValidHandle(HtoPT(PMIDIDEV, hmo)->hmd))
        //    return MMSYSERR_NODRIVER;
        mmr = (MMRESULT)midiMessage ((HMIDI)hmi, DRVM_ADD_THRU, (DWORD_PTR)(UINT_PTR)hmo, 0l);
        if (mmr == MMSYSERR_NOTSUPPORTED && uType == TYPE_MIDIIN)
        {
            // dont allow more than one handle to be added
            //
            if (HtoPT(PMIDIDEV, hmi)->pmThru)
                mmr = MIDIERR_NOTREADY;
            else
            {
                // add the handle.
                //
                HtoPT(PMIDIDEV, hmi)->pmThru = HtoPT(PMIDIDEV, hmo);
                mmr = MMSYSERR_NOERROR;
            }
        }
    }
    else
    {
            mmr = (MMRESULT)midiMessage ((HMIDI)hmi, DRVM_REMOVE_THRU, (DWORD_PTR)(UINT_PTR)hmo, 0l);
            if (mmr == MMSYSERR_NOTSUPPORTED && uType == TYPE_MIDIIN)
                mmr = MMSYSERR_NOERROR;

            if ( ! hmo || (PMIDIDEV)hmo == HtoPT(PMIDIDEV, hmi)->pmThru)
                HtoPT(PMIDIDEV, hmi)->pmThru = NULL;
            else
                mmr = MMSYSERR_INVALPARAM;
    }

    return mmr;
}


WINMMAPI MMRESULT WINAPI midiStreamOpen(
    LPHMIDISTRM     phms,
    LPUINT          puDeviceID,
    DWORD           cMidi,
    DWORD_PTR       dwCallback,
    DWORD_PTR       dwInstance,
    DWORD           fdwOpen)
{
    PMIDISTRM       pms             = NULL;
    PMIDISTRMID     pmsi;
    PMIDISTRMID     pmsiSave;
    MIDIOPENDESC*   pmod            = NULL;
    DWORD           cbHandle;
    DWORD           idx;
    MIDIOUTCAPS     moc;
    MMRESULT        mmrc            = MMSYSERR_NOERROR;
    MMRESULT        mmrc2;
    UINT            msg;

    V_WPOINTER((LPVOID)phms, sizeof(HMIDISTRM), MMSYSERR_INVALPARAM);
    V_DCALLBACK(dwCallback, HIWORD(fdwOpen), MMSYSERR_INVALPARAM);

    *phms = NULL;

    // Allocate both the handle and the OPENDESC structure.
    //
    // NOTE: Using cMidi-1 because rgIds is defined as having 1 element
    //
    cbHandle = sizeof(MIDISTRM) + cMidi * ELESIZE(MIDISTRM, rgIds[0]);
    if ((0 == cMidi) || (cbHandle >= 0x00010000L))
        return MMSYSERR_INVALPARAM;

    pms = HtoPT(PMIDISTRM, NewHandle(TYPE_MIDISTRM, NULL, (UINT)cbHandle));
    if (NULL == pms)
    {
        dprintf1(("mSO: NewHandle() failed!"));
        return MMSYSERR_NOMEM;
    }

    //  Implicitly acquired with NewHandle()...
    ReleaseHandleListResource();

    pmod = (MIDIOPENDESC*)LocalAlloc(LPTR,
           (UINT)(sizeof(MIDIOPENDESC) + (cMidi-1) * ELESIZE(MIDIOPENDESC, rgIds[0])));
    if (NULL == pmod)
    {
        dprintf1(("mSO: !LocalAlloc(MIDIOPENDESC)"));
        mmrc = MMSYSERR_NOMEM;
        goto midiStreamOpen_Cleanup;
    }

    pms->fdwOpen = fdwOpen;
    pms->dwCallback = dwCallback;
    pms->dwInstance = dwInstance;
    pms->cIds = cMidi;


    // Scan through the given device ID's. Determine if the underlying
    // driver supports stream directly. If so, then get it's HMD and uDeviceID,
    // etc. Else flag this as an emulator ID.
    //
    pmsi = pms->rgIds;
    for (idx = 0; idx < cMidi; idx++, pmsi++)
    {
        dprintf1(("mSO: pmsi->fdwId %08lX", (DWORD)pmsi->fdwId));

        mmrc = midiOutGetDevCaps(puDeviceID[idx], &moc, sizeof(moc));
        if (MMSYSERR_NOERROR != mmrc)
        {
            puDeviceID[idx] = (UINT)MIDISTRM_ERROR;
            goto midiStreamOpen_Cleanup;
        }

        if (moc.dwSupport & MIDICAPS_STREAM)
        {
            // Find the driver supporting the device ID.  Note that mregFindDevice implicitly
            // adds a referance (usage) to the driver (i.e. the hmd).
            dprintf1(("mSO: Dev %u MIDICAPS_STREAM! dwSupport %08lX", (UINT)idx, moc.dwSupport));
            mmrc = mregFindDevice(puDeviceID[idx], TYPE_MIDIOUT, &pmsi->hmd, &pmsi->uDevice);
            if (MMSYSERR_NOERROR != mmrc)
            {
                dprintf(("mregFindDevice barfed %u", (UINT)mmrc));
                puDeviceID[idx] = (UINT)MIDISTRM_ERROR;
                goto midiStreamOpen_Cleanup;
            }
            else
            {
                dprintf1(("mregFindDevice: hmd %04X", (UINT_PTR)pmsi->hmd));
            }
        }
        else
        {
            dprintf1(("mSO: Dev %u emulated.", (UINT)idx));

            pmsi->fdwId |= MSI_F_EMULATOR;
            pmsi->hmd = NULL;
            pmsi->uDevice = puDeviceID[idx];
        }
    }

    // At this point, the puDeviceID array's elements contain either device    |
    // IDs or the error value MIDISTRM_ERROR.  Also the pmsi array elements
    // corresponding to device IDs supporting MIDICAPS_STREAM will have a
    // non-NULL pmsi->hmd with a reference count (usage) on it.  pmsi->uDevice
    // will be a driver-relative device ID.  Other pmsi elements will have a
    // NULL pmsi->hmd and pmsi->fdwId will have MSI_F_EMULATOR set.
    // pmsi->uDevice will be a midiOut device ID (not a driver relative ID).

    // Scan through the list again, but this time actually open the devices.
    //
    pmod->hMidi = PTtoH(HMIDI, pms);
    pmod->dwCallback = (DWORD_PTR)midiOutStreamCallback;
    pmod->dwInstance = 0;

    msg = MODM_OPEN;
    pms->cDrvrs = 0;
    for(;;)
    {
    	//
    	// Set pmsiSave to identify the first unopened device. Break loop
    	// if all are opened.
    	//
        pmsiSave = NULL;
        pmsi = pms->rgIds;
        for (idx = 0; idx < cMidi; idx++, pmsi++)
        {
            if (!(pmsi->fdwId & MSI_F_OPENED))
            {
                pmsiSave = pmsi;
                break;
            }
        }

        if (NULL == pmsiSave)
            break;

        //
        // Group together all IDs implemented by the same driver
        //
        pmod->cIds = 0;
        for(; idx < cMidi; idx++, pmsi++)
        {
            if (pmsi->hmd == pmsiSave->hmd)
            {
                pmod->rgIds[pmod->cIds].uDeviceID = pmsi->uDevice;
                pmod->rgIds[pmod->cIds++].dwStreamID = idx;
            }
        }

        pmsiSave->fdwId |= MSI_F_FIRST;

        //
        // Open the driver
        //
        if (!(pmsiSave->fdwId & MSI_F_EMULATOR))
        {
            pmsiSave->drvMessage = HtoPT(PMMDRV, pmsiSave->hmd)->drvMessage;
//          pmsiSave->dnDevNode  = pmod->dnDevNode = mregQueryDevNode(pmsiSave->hmd);

            mmrc = (MMRESULT)((*pmsiSave->drvMessage)(
                    0,
                    msg,
                    (DWORD_PTR)(LPDWORD)&pmsiSave->dwDrvUser,
                    (DWORD_PTR)(LPMIDIOPENDESC)pmod,
                    CALLBACK_FUNCTION|MIDI_IO_COOKED));

            if (MMSYSERR_NOERROR == mmrc)
            {
                mregIncUsage(pmsiSave->hmd);
            }
        }
        else
        {
            mmrc = (MMRESULT)mseMessage(msg,
                                    (DWORD_PTR)(LPDWORD)&pmsiSave->dwDrvUser,
                                    (DWORD_PTR)(LPMIDIOPENDESC)pmod,
                                    CALLBACK_FUNCTION);
        }

        if (MMSYSERR_NOERROR != mmrc)
        {
            idx = (DWORD)(pmsiSave - pms->rgIds);
            puDeviceID[idx] = (UINT)MIDISTRM_ERROR;
            goto midiStreamOpen_Cleanup;
        }

        //
        // Now flag all IDs implemented by the same driver as MSI_F_OPENED
        //

        ++pms->cDrvrs;
        pmsi = pms->rgIds;
        for (idx = 0; idx < cMidi; idx++, pmsi++)
        {
            if (pmsi->hmd == pmsiSave->hmd)
            {
                pmsi->fdwId |= MSI_F_OPENED;
                if (!(pmsiSave->fdwId & MSI_F_EMULATOR))
                {
                    if (mmInitializeCriticalSection(&pmsi->CritSec))
                    {
                        pmsi->fdwId |= MSI_F_INITIALIZEDCRITICALSECTION;
                    } else {
                        mmrc = MMSYSERR_NOMEM;
                    }
                }
            }
        }
    }


    if (MMSYSERR_NOERROR == mmrc && !CreatehwndNotify())
    {
        dprintf(("Cannot create hwndNotify for async messages!"));
        mmrc = MMSYSERR_ERROR;
    }

    dprintf2(("midiStreamOpen: HMIDISTRM %04X", (WORD)pms));

midiStreamOpen_Cleanup:
    if (NULL != pmod) LocalFree((HLOCAL)pmod);

    //
    // If there was an error, close any drivers we opened and free resources
    // associated with them.  Note do not free pms yet here, as we need it in
    // additional cleanup further below.
    //
    if (MMSYSERR_NOERROR != mmrc)
    {
        if (NULL != pms)
        {
            msg = MODM_CLOSE;

            pmsi = pms->rgIds;
            for (idx = 0; idx < pms->cIds; idx++, pmsi++)
            {
                if ((pmsi->fdwId & (MSI_F_OPENED|MSI_F_FIRST)) == (MSI_F_OPENED|MSI_F_FIRST))
                {
                    mmrc2 = (MMRESULT)midiStreamMessage(pmsi, msg, 0L, 0L);

                    if (MMSYSERR_NOERROR == mmrc2 &&
                        !(pmsi->fdwId & MSI_F_EMULATOR))
                    {
                        if (pmsi->fdwId & MSI_F_INITIALIZEDCRITICALSECTION) {
                            DeleteCriticalSection(&pmsi->CritSec);
                            pmsi->fdwId &= ~MSI_F_INITIALIZEDCRITICALSECTION;
                        }
                        mregDecUsage(pmsi->hmd);
                    }
                    else
                    {
                        dprintf1(("midiStreamOpen_Cleanup: Close returned %u", mmrc2));
                    }
                }
            }

        }
    }
    else
    {
        *phms = PTtoH(HMIDISTRM, pms);

        msg = MM_MOM_OPEN;
        DriverCallback(pms->dwCallback,
                   HIWORD(pms->fdwOpen),
                   (HDRVR)PTtoH(HMIDISTRM, pms),
                   msg,
                   pms->dwInstance,
                   0,
                   0);
    }

    //
    // Now release driver references added by mregFindDevice.  Those that are
    // actually still in use have had an extra reference added and thus will
    // still have a reference count on them even after the release done here.
    //
    if (pms)
    {
    	pmsi = pms->rgIds;
    	for (pmsi = pms->rgIds, idx = 0;
    	     idx < pms->cIds;
    	     idx++, pmsi++)
    	{
    	    if (pmsi->hmd) mregDecUsage(pmsi->hmd);
    	}
    }

    //
    // Free pms if there was an error
    //
    if ((MMSYSERR_NOERROR != mmrc) && (pms)) FreeHandle((PTtoH(HMIDI, pms)));

    return mmrc;
}

WINMMAPI MMRESULT WINAPI midiStreamClose(
    HMIDISTRM       hms)
{
    PMIDISTRM       pms;
    PMIDISTRMID     pmsi;
    DWORD           idx;
    MMRESULT        mmrc;

    V_HANDLE(hms, TYPE_MIDISTRM, MMSYSERR_INVALHANDLE);

    dprintf1(("midiStreamClose(%04X)", (WORD)hms));

    pms = HtoPT(PMIDISTRM, hms);

    pmsi = pms->rgIds;
    for (idx = 0; idx < pms->cIds; idx++, pmsi++)
    {
        if ((pmsi->fdwId & (MSI_F_OPENED|MSI_F_FIRST)) == (MSI_F_OPENED|MSI_F_FIRST))
        {
            mmrc = (MMRESULT)midiStreamMessage(pmsi, MODM_CLOSE, 0L, 0L);

            if (MMSYSERR_NOERROR == mmrc &&
                !(pmsi->fdwId & MSI_F_EMULATOR))
            {
                WinAssert(pmsi->fdwId & MSI_F_INITIALIZEDCRITICALSECTION);
                DeleteCriticalSection(&pmsi->CritSec);
                pmsi->fdwId &= ~MSI_F_INITIALIZEDCRITICALSECTION;
                mregDecUsage(pmsi->hmd);
            }
            else
            {
                dprintf1(("midiStreamClose: Close returned %u", mmrc));
            }
        }
    }

    dprintf1(("DriverCallback(%04X)", (WORD)hms));
    DriverCallback(pms->dwCallback,
           HIWORD(pms->fdwOpen),
           (HDRVR)hms,
           MM_MOM_CLOSE,
           pms->dwInstance,
           0,
           0);

    dprintf1(("FreeHandle(%04X)", (WORD)hms));
    FreeHandle(hms);

    return MMSYSERR_NOERROR;
}


/****************************************************************************
 * @doc EXTERNAL MIDI M5
 *
 * @func MMRESULT | midiStreamProperty | Sets or retrieves properties
 *  of a MIDI data stream associated with a MIDI input or output device.
 *
 * @parm HMIDI | hm | Specifies the handle of the MIDI device that the
 *  property is associated with.
 *
 * @parm LPBYTE | lppropdata | Specifies a pointer to the property data.
 *
 * @parm DWORD | dwProperty | Contains flags that specify the action
 *  to perform and identify the appropriate property of the MIDI data stream.
 *  <f midiStreamProperty> requires setting two flags in each use. One flag
 *  (either MIDIPROP_GET or MIDIPROP_SET) specifies an action. The other
 *  identifies a specific property to examine or edit.
 *
 *  @flag MIDIPROP_SET | Set the given property.
 *  @flag MIDIPROP_GET | Retrieve the current setting of the given property.
 *  @flag MIDIPROP_TIMEDIV | Time division property.
 *   This property is valid for both input and output devices. <p lppropdata>
 *   points to a <t MIDIPROPTIMEDIV> structure. This property can be set only
 *   when the device is stopped.
 *
 *  @flag MIDIPROP_TEMPO | Tempo property.
 *   This property is valid for both input and output devices. <p lppropdata>
 *   points to a <t MIDIPROPTEMPO> structure. The current tempo value can be
 *   retrieved at any time. This function can set the tempo for input devices.
 *   Output devices set the tempo by inserting PMSG_TEMPO events into the
 *   MIDI data.
 *
 *  @flag MIDIPROP_CBTIMEOUT | Timeout value property.
 *   This property specifies the timeout value for loading buffers when a
 *   MIDI device is in MIDI_IO_COOKED and MIDI_IO_RAW modes. The current
 *   timeout value sets the maximum number of milliseconds that a buffer will
 *   be held once any data is placed in it. If this timeout expires, the
 *   buffer will be returned to the application even though it might not be
 *   completely full. <p lppropdata> points to a <t MIDIPROPCBTIMEOUT> structure.
 *
 * @comm These properties are the default properties defined by MMSYSTEM.
 *   Driver writers may implement and document their own properties.
 *
 * @rdesc The return value is one of the following values:
 *  @flag MMSYSERR_INVALPARAM | The given handle or flags are invalid.
 *  @flag MIDIERR_BADOPENMODE | The given handle is not open in MIDI_IO_COOKED
 *   or MIDI_IO_RAW mode.
 *
 ***************************************************************************/
MMRESULT WINAPI midiStreamProperty(
    HMIDISTRM   hms,
    LPBYTE      lppropdata,
    DWORD       dwProperty)
{
    MMRESULT mmrc;

    V_HANDLE(hms, TYPE_MIDISTRM, MMSYSERR_INVALHANDLE);

    if ((!(dwProperty&MIDIPROP_SET)) && (!(dwProperty&MIDIPROP_GET)))
        return MMSYSERR_INVALPARAM;

    V_RPOINTER(lppropdata, sizeof(DWORD), MMSYSERR_INVALPARAM);

    if (dwProperty&MIDIPROP_SET)
    {
        V_RPOINTER(lppropdata, (UINT)(*(LPDWORD)(lppropdata)), MMSYSERR_INVALPARAM);
    }
    else
    {
        V_WPOINTER(lppropdata, (UINT)(*(LPDWORD)(lppropdata)), MMSYSERR_INVALPARAM);
    }

    mmrc = (MMRESULT)midiStreamBroadcast(HtoPT(PMIDISTRM, hms),
                                         MODM_PROPERTIES,
                                         (DWORD_PTR)lppropdata,
                                         dwProperty);

    return mmrc;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiOutGetPosition | Retrieves the current
 *   playback position of the specified MIDI output device.
 *
 * @parm HMIDIOUT | hmo | Specifies a handle to the MIDI output device.
 *
 * @parm LPMMTIME | pmmt | Specifies a far pointer to an <t MMTIME>
 *   structure.
 *
 * @parm UINT | cbmmt | Specifies the size of the <t MMTIME> structure.
 *
 * @rdesc Returns zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm Before calling <f midiOutGetPosition>, set the <e MMTIME.wType> field
 *   of <t MMTIME> to indicate the time format that you desire. After
 *   calling <f midiOutGetPosition>, check the <e MMTIME.wType> field
 *   to determine if the desired time format is supported. If the desired
 *   format is not supported, <e MMTIME.wType> will specify an alternative
 *   format.
 *
 *  The position is set to zero when the device is opened, reset, or
 *  stopped.
 ****************************************************************************/
MMRESULT WINAPI midiStreamPosition(
    HMIDISTRM       hms,
    LPMMTIME        pmmt,
    UINT            cbmmt)
{
    MMRESULT mmrc;

    V_HANDLE(hms, TYPE_MIDISTRM, MMSYSERR_INVALHANDLE);
    V_WPOINTER(pmmt, cbmmt, MMSYSERR_INVALPARAM);

    mmrc = (MMRESULT)midiStreamMessage(HtoPT(PMIDISTRM, hms)->rgIds,
                                       MODM_GETPOS,
                                       (DWORD_PTR)pmmt,
                                       (DWORD)cbmmt);

    return mmrc;
}


/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiStreamStop | Turns off all notes on all MIDI
 *   channels for the specified MIDI output device. Any pending
 *   system-exclusive or polymessage output buffers are marked as done and
 *   returned to the application. While <f midiOutReset> turns off all notes,
 *   <f midiStreamStop> turns off only those notes that have been turned on
 *   by a MIDI note-on message.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output
 *   device.
 *
 * @rdesc Returns zero if the function is successful.  Otherwise, it returns
 *   an error number.  Possible error values are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_BADOPENMODE | Specified device handle is not opened in
 *     MIDI_IO_COOKED mode.
 *
 * @comm To turn off all notes, a note-off message for each note for each
 *   channel is sent. In addition, the sustain controller is turned off for
 *   each channel.
 *
 * @xref midiOutLongMsg midiOutClose midiOutReset
 ****************************************************************************/
MMRESULT WINAPI midiStreamStop(HMIDISTRM hms)
{
    PMIDISTRM               pms;
    MMRESULT                mmrc;

    V_HANDLE(hms, TYPE_MIDISTRM, MMSYSERR_INVALHANDLE);

    pms = HtoPT(PMIDISTRM, hms);

    mmrc = (MMRESULT)midiStreamBroadcast(pms, MODM_STOP, 0, 0);

    return mmrc;
}


/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiStreamPause | Pauses playback on a specified
 *   MIDI output device. The current playback position is saved. Use
 *   <f midiStreamRestart> to resume playback from the current playback position.
 *   This call is only valid for handles opened in MIDI_IO_COOKED mode.
 *
 * @parm HMIDIOUT | hmo | Specifies a handle to the MIDI output
 *   device.
 *
 * @rdesc Returns zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_INVALPARAM | Specified device was not opened with
 *     the MIDI_IO_COOKED flag.
 *
 * @comm Calling this function when the output is already paused has no
 *   effect, and the function returns zero.
 *
 * @xref midiStreamRestart
 ****************************************************************************/
MMRESULT WINAPI midiStreamPause(
    HMIDISTRM       hms)
{
    MMRESULT mmrc;

    V_HANDLE(hms, TYPE_MIDISTRM, MMSYSERR_INVALHANDLE);

    mmrc = (MMRESULT)midiStreamBroadcast(HtoPT(PMIDISTRM, hms), MODM_PAUSE, 0, 0);

    return mmrc;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiStreamRestart | Restarts a paused MIDI
 *   output device.
 *
 * @parm HMIDIOUT | hmo | Specifies a handle to the MIDI output
 *   device.
 *
 * @rdesc Returns zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_INVALPARAM | Specified device was not opened with
 *     the MIDI_IO_COOKED flag.
 *
 * @comm Calling this function when the output is not paused has no
 *   effect, and the function returns zero.
 *
 * @xref midiOutPause
 ****************************************************************************/
MMRESULT WINAPI midiStreamRestart(
    HMIDISTRM       hms)
{
    MMRESULT        mmrc;
    MMTIME          mmt;
    DWORD           tkTime;
    DWORD           msTime;
    PMIDISTRM       pms;
    PMIDISTRMID     pmsi;
    DWORD           idx;


    V_HANDLE(hms, TYPE_MIDISTRM, MMSYSERR_INVALHANDLE);

    tkTime = 0;
    pms = HtoPT(PMIDISTRM, hms);

    for (idx = 0, pmsi = pms->rgIds; idx < pms->cIds; idx++, pmsi++)
        if (pmsi->fdwId & MSI_F_FIRST)
        {
            mmt.wType = TIME_TICKS;

            mmrc = (MMRESULT)midiStreamMessage(pmsi,
                                               MODM_GETPOS,
                                               (DWORD_PTR)&mmt,
                                               sizeof(mmt));

            if (mmrc)
            {
                dprintf(("midiOutRestart: Device %u returned %u", idx, mmrc));
                return mmrc;
            }

            if (mmt.wType == TIME_TICKS)
            {
                if (mmt.u.ticks > tkTime)
                    tkTime = mmt.u.ticks;
            }
            else
            {
                dprintf(("midiOutRestart: Device %u does not support ticks", idx));
                return MIDIERR_NOTREADY;
            }
        }

    // Fudge time to allow device setup
    //
    msTime = timeGetTime();
    dprintf(("midiOutRestart: Tick %lu  timeGetTime %lu", tkTime, msTime));
    mmrc = (MMRESULT)midiStreamBroadcast(pms,
                                         MODM_RESTART,
                                         msTime,
                                         tkTime);

    return mmrc;
}


MMRESULT WINAPI midiStreamOut(
    HMIDISTRM       hMidiStrm,
    LPMIDIHDR       lpMidiHdr,
    UINT            cbMidiHdr)
{
    PMIDISTRMID     pmsi;
    PMIDISTRM       pms;
    UINT            idx;
    UINT            cSent;
    LPMIDIHDR       lpmhWork;
    BOOL            fCallback;
    MMRESULT        mmrc;

    dprintf2(( "midiStreamOut(%04X, %08lX, %08lX)", (UINT_PTR)hMidiStrm, (DWORD_PTR)lpMidiHdr, lpMidiHdr->dwBytesRecorded));

    V_HANDLE(hMidiStrm, TYPE_MIDISTRM, MMSYSERR_INVALHANDLE);
    V_HEADER(lpMidiHdr, cbMidiHdr, TYPE_MIDIOUT, MMSYSERR_INVALPARAM);

    pms = HtoPT(PMIDISTRM, hMidiStrm);

    for (pmsi = pms->rgIds, idx = 0; idx < pms->cIds; idx++, pmsi++)
        if ( (!(pmsi->fdwId & MSI_F_EMULATOR)) && (!(pmsi->hmd)) )
            return MMSYSERR_NODRIVER;

    if (!(lpMidiHdr->dwFlags&MHDR_PREPARED))
    {
        dprintf1(( "midiOutPolyMsg: !MHDR_PREPARED"));
        return MIDIERR_UNPREPARED;
    }

    if (lpMidiHdr->dwFlags&MHDR_INQUEUE)
    {
        dprintf1(( "midiOutPolyMsg: Still playing!"));
        return MIDIERR_STILLPLAYING;
    }

    if (lpMidiHdr->dwBytesRecorded > lpMidiHdr->dwBufferLength ||
        (lpMidiHdr->dwBytesRecorded & 3))
    {
        dprintf1(( "Bytes recorded too long or not DWORD aligned."));
        return MMSYSERR_INVALPARAM;
    }

    //
    // Polymsg buffers are limited to 64k in order that we (and the driver)
    // not have to do huge pointer manipulation.
    // Length must also be DWORD aligned.
    //
    if ((lpMidiHdr->dwBufferLength > 65535L) ||
            (lpMidiHdr->dwBufferLength&3))
    {
        dprintf1(( "midiOutPolyMsg: Buffer > 64k or not DWORD aligned"));
        return MMSYSERR_INVALPARAM;
    }

    EnterCriticalSection(&midiStrmHdrCritSec);

    LeaveCriticalSection(&midiStrmHdrCritSec);

    lpMidiHdr->dwReserved[MH_REFCNT] = 0;
    lpMidiHdr->dwFlags |= (MHDR_SENDING|MHDR_INQUEUE|MHDR_ISSTRM);

    lpmhWork = (LPMIDIHDR)lpMidiHdr->dwReserved[MH_SHADOW];

    pmsi = pms->rgIds;
    for (idx = 0, cSent = 0; idx < pms->cIds; idx++, pmsi++)
    {
       if (pmsi->fdwId & MSI_F_FIRST)
       {
           lpmhWork->dwBytesRecorded = lpMidiHdr->dwBytesRecorded;
           lpmhWork->dwFlags |= MHDR_ISSTRM;

           mmrc = (MMRESULT)midiStreamMessage(pmsi, MODM_STRMDATA, (DWORD_PTR)lpmhWork, sizeof(*lpmhWork));

           if (mmrc == MMSYSERR_NOERROR)
               ++lpMidiHdr->dwReserved[MH_REFCNT], ++cSent;

           lpmhWork++;
       }
    }

    fCallback = FALSE;

    EnterCriticalSection(&midiStrmHdrCritSec);

    lpMidiHdr->dwFlags &= ~MHDR_SENDING;
    if (cSent && 0 == lpMidiHdr->dwReserved[MH_REFCNT])
    {
        fCallback = TRUE;
    }

    LeaveCriticalSection(&midiStrmHdrCritSec);

    if (fCallback)
    {
        lpMidiHdr->dwFlags &= ~MHDR_INQUEUE;
        lpMidiHdr->dwFlags |= MHDR_DONE;
        DriverCallback(pms->dwCallback,
                   HIWORD(pms->fdwOpen),
                       (HDRVR)hMidiStrm,
                   MM_MOM_DONE,
                   pms->dwInstance,
                   (DWORD_PTR)lpMidiHdr,
                   0);
    }

    if (!cSent)
    {
        lpMidiHdr->dwFlags &= ~MHDR_INQUEUE;
        return mmrc;
    }
    else
        return MMSYSERR_NOERROR;
}


DWORD FAR PASCAL midiStreamMessage(PMIDISTRMID pmsi, UINT msg, DWORD_PTR dwP1, DWORD_PTR dwP2)
{
    MMRESULT mrc;

    if (!(pmsi->fdwId & MSI_F_EMULATOR))
    {
        EnterCriticalSection(&pmsi->CritSec);

        mrc = (*(pmsi->drvMessage))
                      (0, msg, pmsi->dwDrvUser, dwP1, dwP2);

        try
        {
            LeaveCriticalSection(&pmsi->CritSec);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {

        }
        return mrc;
    }
    else
    {
        mrc = mseMessage(msg, pmsi->dwDrvUser, dwP1, dwP2);
    }

    return mrc;
}

DWORD FAR PASCAL midiStreamBroadcast(
    PMIDISTRM   pms,
    UINT        msg,
    DWORD_PTR   dwP1,
    DWORD_PTR   dwP2)
{
    DWORD       idx;
    DWORD       mmrc;
    DWORD       mmrcRet;
    PMIDISTRMID pmsi;

    ENTER_MM_HANDLE((HMIDI)pms);

    mmrcRet = MMSYSERR_NOERROR;

    pmsi = pms->rgIds;

    for (idx = pms->cIds; idx; idx--, pmsi++)
    {
        if (pmsi->fdwId & MSI_F_FIRST)
        {
            mmrc = midiStreamMessage(pmsi, msg, dwP1, dwP2);
            if (MMSYSERR_NOERROR != mmrc)
                mmrcRet = mmrc;
        }
    }

    LEAVE_MM_HANDLE((HMIDI)pms);
    return mmrcRet;
}

void CALLBACK midiOutStreamCallback(
    HMIDISTRM               hMidiOut,
    WORD                    wMsg,
    DWORD_PTR               dwInstance,
    DWORD_PTR               dwParam1,
    DWORD_PTR               dwParam2)
{
    PMIDISTRM               pms         = HtoPT(PMIDISTRM, hMidiOut);
    LPMIDIHDR               lpmh        = (LPMIDIHDR)dwParam1;

    if (MM_MOM_POSITIONCB == wMsg)
    {
        LPMIDIHDR lpmh2 = (LPMIDIHDR)lpmh->dwReserved[MH_PARENT];
        lpmh2->dwOffset = lpmh->dwOffset;

        DriverCallback(pms->dwCallback,
                   HIWORD(pms->fdwOpen),
                   (HDRVR)hMidiOut,
                   MM_MOM_POSITIONCB,
                   pms->dwInstance,
                   (DWORD_PTR)lpmh2,
                   0);
        return;
    }
    else if (MM_MOM_DONE != wMsg)
        return;

#ifdef DEBUG
    {
        DWORD dwDelta = timeGetTime() - (DWORD)lpmh->dwReserved[7];
        if (dwDelta > 1)
            dprintf1(("Took %lu ms to deliver callback!", dwDelta));
    }
#endif

    lpmh = (LPMIDIHDR)lpmh->dwReserved[MH_PARENT];

    dprintf2(("mOSCB PMS %04X HDR %08lX", (UINT_PTR)pms, (DWORD_PTR)lpmh));

    EnterCriticalSection(&midiStrmHdrCritSec);

    --lpmh->dwReserved[MH_REFCNT];

    if (0 == lpmh->dwReserved[MH_REFCNT] && (!(lpmh->dwFlags & MHDR_SENDING)))
    {
        lpmh->dwFlags &= ~MHDR_INQUEUE;
        lpmh->dwFlags |= MHDR_DONE;

        LeaveCriticalSection(&midiStrmHdrCritSec);

#ifdef DEBUG
        lpmh->dwReserved[7] = timeGetTime();
#endif
        DriverCallback(pms->dwCallback,
                       HIWORD(pms->fdwOpen),
                       (HDRVR)hMidiOut,
                       MM_MOM_DONE,
                       pms->dwInstance,
                       (DWORD_PTR)lpmh,
                       0);

    }
    else
    {
        LeaveCriticalSection(&midiStrmHdrCritSec);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\mixer.c ===
//==========================================================================;
//
//  mixer.c
//
//  Copyright (c) 1992-2001 Microsoft Corporation
//
//  Description:
//
//
//  History:
//       6/27/93    cjp     [curtisp]
//
//==========================================================================;
#define  UNICODE
#include "winmmi.h"
#include "mixer.h"  // This file drags in a ton of stuff to support the mixers



PMIXERDEV   gpMixerDevHeader = NULL;    /* A LL of open devices */
UINT        guTotalMixerDevs;           // total mixer devices

//
//  mixer device driver list--add one to accomodate the MIXER_MAPPER. note
//  that even if we are not compiling with mapper support we need to add
//  one because other code relies on it (for other device mappers).
//
MIXERDRV mixerdrvZ;

char    gszMxdMessage[]     = "mxdMessage";
TCHAR   gszMixer[]          = TEXT("mixer");

#ifdef MIXER_MAPPER
TCHAR   gszMixerMapper[]    = TEXT("mixermapper");
#endif

#ifdef MIXER_MAPPER
#define MMDRVI_MAPPER        0x8000     // install this driver as the mapper
#endif

//#define MMDRVI_MIXER         0x0006
#define MMDRVI_HDRV          0x4000     // hdrvr is an installable driver
#define MMDRVI_REMOVE        0x2000     // remove the driver

//--------------------------------------------------------------------------;
//
//  BOOL MixerCallbackFunc
//
//  Description:
//
//      NOTE! we document that a mixer must NEVER call this function at
//      interrupt time! we don't want to fix our code or data segments.
//
//  Arguments:
//      HMIXER hmx:
//
//      UINT uMsg:
//
//      DWORD dwInstance:
//
//      DWORD dwParam1:
//
//      DWORD dwParam2:
//
//  Return (BOOL):
//
//  History:
//      07/21/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL CALLBACK MixerCallbackFunc(
    HMIXER                  hmx,
    UINT                    uMsg,
    DWORD_PTR               dwInstance,
    DWORD_PTR               dwParam1,
    DWORD_PTR               dwParam2
)
{
    PMIXERDEV           pmxdev;

    //
    //  step through all open handles and do callbacks to the appropriate
    //  clients...
    //

    //
    // Serialize access to hande list - only necessary for Win32
    //
    MIXMGR_ENTER;

    for (pmxdev = gpMixerDevHeader; pmxdev; pmxdev = pmxdev->pmxdevNext)
    {
        //
        //  same device? (could also use hmx->uDeviceID)
        //
        if (pmxdev->uDeviceID != dwInstance)
            continue;

        DriverCallback(pmxdev->dwCallback,
                        (HIWORD(pmxdev->fdwOpen) | DCB_NOSWITCH),

                        GetWOWHandle((HANDLE)pmxdev)
                            ? (HANDLE)(UINT_PTR)GetWOWHandle((HANDLE)pmxdev)
                            : (HANDLE)pmxdev,

                        uMsg,
                        pmxdev->dwInstance,
                        dwParam1,
                        dwParam2);
    }

    MIXMGR_LEAVE;

    return (TRUE);
} // MixerCallbackFunc()


//--------------------------------------------------------------------------;
//
//  MMRESULT mixerReferenceDriveryById
//
//  Description:
//      This function maps a logical id to a device driver and physical id.
//
//  Arguments:
//      IN UINT uId: The logical id to be mapped.
//
//      OUT PMIXERDRV* OPTIONAL ppmixerdrv: Pointer to the MIXERDRV structure
//         describing describing the driver supporing the id.
//
//      OUT UINT* OPTIONAL pport: The driverj-relative device number.  If the
//         caller supplies this buffer then it must also supply ppmixerdrv.
//
//  Return (MMRESULT):
//      The return value is zero if successful, MMSYSERR_BADDEVICEID if the id
//      is out of range.
//
//  Comments:
//      If the caller specifies ppmixerdrv then this function increments the
//      mixerdrv's usage before returning.  The caller must ensure the usage
//      is eventually decremented.
//
//  History:
//      03/17/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT mixerReferenceDriverById(
    IN UINT id,
    OUT PMIXERDRV *ppdrv OPTIONAL,
    OUT UINT *pport OPTIONAL
)
{
    PMIXERDRV pdrv;
    MMRESULT mmr;

    // Should not be called asking for port but not mixerdrv
    WinAssert(!(pport && !ppdrv));
    
    EnterNumDevs("mixerReferenceDriverById");
    
#ifdef MIXER_MAPPER
    if (MIXER_MAPPER == id)
    {
    	id = 0;
    	for (pdrv = mixerdrvZ.Next; pdrv != &mixerdrvZ; pdrv = pdrv->Next)
	{
	    if (pdrv->fdwDriver & MMDRV_MAPPER) break;
	}
    }
    else
#endif
    {
    	for (pdrv = mixerdrvZ.Next; pdrv != &mixerdrvZ; pdrv = pdrv->Next)
	{
	    if (pdrv->fdwDriver & MMDRV_MAPPER) continue;
	    if (pdrv->NumDevs > id) break;
	    id -= pdrv->NumDevs;
	}
    }

    if (pdrv != &mixerdrvZ)
    {
    	if (ppdrv)
    	{
    	    mregIncUsagePtr(pdrv);
    	    *ppdrv = pdrv;
    	    if (pport) *pport = id;
    	}
    	mmr = MMSYSERR_NOERROR;
    } else {
    	mmr = MMSYSERR_BADDEVICEID;
    }

    LeaveNumDevs("mixerReferenceDriverById");

    return mmr;
;
} // IMixerMapId()


PCWSTR mixerReferenceDevInterfaceById(UINT_PTR id)
{
    PMIXERDRV pdrv;
    PCWSTR DevInterface;
    
    if (ValidateHandle((HANDLE)id, TYPE_MIXER))
    {
    	DevInterface = ((PMIXERDEV)id)->pmxdrv->cookie;
    	if (DevInterface) wdmDevInterfaceInc(DevInterface);
    	return DevInterface;
    }
    
    if (!mixerReferenceDriverById((UINT)id, &pdrv, NULL))
    {
    	DevInterface = pdrv->cookie;
    	if (DevInterface) wdmDevInterfaceInc(DevInterface);
    	mregDecUsagePtr(pdrv);
    	return DevInterface;
    }

    return NULL;
}

//--------------------------------------------------------------------------;
//
//  DWORD IMixerMessageHandle
//
//  Description:
//
//
//  Arguments:
//      HMIXER hmx:
//
//      UINT uMsg:
//
//      DWORD dwP1:
//
//      DWORD dwP2:
//
//  Return (DWORD):
//
//  History:
//      03/17/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

DWORD NEAR PASCAL IMixerMessageHandle(
    HMIXER          hmx,
    UINT            uMsg,
    DWORD_PTR       dwP1,
    DWORD_PTR       dwP2
)
{
    PMIXERDEV   pmxd;
    DWORD       dwRc;

    pmxd = (PMIXERDEV)hmx;

    ENTER_MM_HANDLE(hmx);
    ReleaseHandleListResource();
    
    //  Is handle deserted?
    if (IsHandleDeserted(hmx))
    {
        LEAVE_MM_HANDLE(hmx);
        return (MMSYSERR_NODRIVER);
    }

    if (IsHandleBusy(hmx))
    {
        LEAVE_MM_HANDLE(hmx);
        return (MMSYSERR_HANDLEBUSY);
    }

    EnterCriticalSection(&pmxd->pmxdrv->MixerCritSec);
    
    if (BAD_HANDLE(hmx, TYPE_MIXER))
    {
        //  Do we still need to check for this?
    
	    WinAssert(!"Bad Handle within IMixerMessageHandle");
        dwRc = MMSYSERR_INVALHANDLE;
    }
    else
    {
        dwRc = ((*(pmxd->pmxdrv->drvMessage))
                (pmxd->wDevice, uMsg, pmxd->dwDrvUser, dwP1, dwP2));
    }

    LeaveCriticalSection(&pmxd->pmxdrv->MixerCritSec);
    LEAVE_MM_HANDLE(hmx);

    return dwRc;
} // IMixerMessageHandle()


//--------------------------------------------------------------------------;
//
//  DWORD IMixerMessageId
//
//  Description:
//
//
//  Arguments:
//      PMIXERDRV pmxdrv:
//
//      UINT uTotalNumDevs:
//
//      UINT uDeviceID:
//
//      UINT uMsg:
//
//      DWORD dwParam1:
//
//      DWORD dwParam2:
//
//  Return (DWORD):
//
//  History:
//      03/17/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

extern void lstrncpyW (LPWSTR pszTarget, LPCWSTR pszSource, size_t cch);

DWORD NEAR PASCAL IMixerMessageId(
    UINT            uDeviceID,
    UINT            uMsg,
    DWORD_PTR       dwParam1,
    DWORD_PTR       dwParam2
)
{
    PMIXERDRV   pmxdrv;
    UINT        port;
    DWORD       dwRc;
    HMIXER      hmx;
    PMIXERDEV   pmxdev;
    MMRESULT    mmr;

    mmr = mixerReferenceDriverById(uDeviceID, &pmxdrv, &port);

    if (mmr)
    {
        return mmr;
    }

    if (mregHandleInternalMessages(pmxdrv, TYPE_MIXER, port, uMsg, dwParam1, dwParam2, &mmr))
    {
    	mregDecUsagePtr(pmxdrv);
        return mmr;
    }

    dwRc = mixerOpen(&hmx, uDeviceID, 0L, 0L, MIXER_OBJECTF_MIXER);
    
    // Should we go through IMixerMessageHandle???
    if (MMSYSERR_NOERROR == dwRc)
    {
        pmxdev = (PMIXERDEV)hmx;
        pmxdrv = pmxdev->pmxdrv;

        if (!pmxdrv->drvMessage)
        {
            dwRc = MMSYSERR_NODRIVER;
        }
        else
        {
            EnterCriticalSection( &pmxdrv->MixerCritSec);

            dwRc = ((*(pmxdrv->drvMessage))
                    (port, uMsg, pmxdev->dwDrvUser, dwParam1, dwParam2));

            LeaveCriticalSection( &pmxdrv->MixerCritSec);
        }

        mixerClose(hmx);
    }

    mregDecUsagePtr(pmxdrv);

    return dwRc;

} // IMixerMessageId()


//==========================================================================;
//
//
//
//
//==========================================================================;

/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK API
 *
 *  @api UINT | mixerGetNumDevs | The <f mixerGetNumDevs> function retrieves
 *      the number of audio mixer devices present in the system.
 *
 *  @rdesc Returns the number of audio mixer devices present in the system.
 *      If no audio mixer devices are available, zero is returned.
 *
 *  @xref <f mixerGetDevCaps>, <f mixerOpen>
 *
 **/

UINT APIENTRY mixerGetNumDevs(
    void
)
{
    UINT cDevs;

    ClientUpdatePnpInfo();

    EnterNumDevs("mixerGetNumDevs");
    cDevs = guTotalMixerDevs;
    LeaveNumDevs("mixerGetNumDevs");

    return cDevs;
} // mixerGetNumDevs()


/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK STRUCTURE
 *
 *  @types MIXERCAPS | The <t MIXERCAPS> structure describes the capabilities
 *      of a mixer device.
 *
 *  @field WORD | wMid | Specifies a manufacturer identifier for the mixer
 *      device driver. Manufacturer identifiers are defined in Appendix B,
 *      <lq>Manufacturer ID and Product ID Lists.<rq>
 *
 *  @field WORD | wPid | Specifies a product identifier for the mixer device
 *      driver. Product identifiers are defined in Appendix B,
 *      <lq>Manufacturer ID and Product ID Lists.<rq>
 *
 *  @field MMVERSION | vDriverVersion | Specifies the version number of the
 *      mixer device driver. The high-order byte is the major version
 *      number, and the low-order byte is the minor version number.
 *
 *  @field char | szPname[MAXPNAMELEN] | Specifies the name of the product.
 *      If the mixer device driver supports multiple cards, this string must
 *      uniquely and easily identify (potentially to a user) this specific
 *      card. For example, szPname = <lq>Sound Card Mixer, I/O address 200<rq>
 *      would uniquely identify (to the user) this particular card as a
 *      Sound Card Mixer for the physical card based at I/O address 200. If
 *      only one device is installed, it is recommended that only the base
 *      name be returned. For example, szPname should be <lq>Sound Card Mixer<rq>
 *      if only one device is present.
 *
 *  @field DWORD | fdwSupport | Specifies various support information for
 *      the mixer device driver. No extended support bits are currently
 *      defined.
 *
 *  @field DWORD | cDestinations | The number of audio mixer line destinations
 *      available through the mixer. All mixer devices must support at least
 *      one destination line, so this member can never be zero. Destination
 *      indexes used in the <e MIXERLINE.dwDestination> member of the
 *      <t MIXERLINE> structure range from zero to the value specified in the
 *      <e MIXERCAPS.cDestinations> member minus one.
 *
 *  @tagname tMIXERCAPS
 *
 *  @othertype MIXERCAPS FAR * | LPMIXERCAPS | A pointer to a <t MIXERCAPS>
 *      structure.
 *
 *  @othertype MIXERCAPS * | PMIXERCAPS | A pointer to a <t MIXERCAPS>
 *      structure.
 *
 *  @xref <f mixerGetDevCaps>, <f mixerOpen>, <f mixerGetLineInfo>
 *
 **/

/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK API
 *
 *  @api MMRESULT | mixerGetDevCaps | The <f mixerGetDevCaps> function
 *      queries a specified audio mixer device to determine its capabilities.
 *
 *  @parm UINT | uMxId | Identifies the audio mixer device with either
 *      an audio mixer device identifier or a handle to an opened audio mixer
 *      device.
 *
 *  @parm LPMIXERCAPS | pmxcaps | Pointer to a <t MIXERCAPS> structure that
 *      receives information about the capabilities of the device.
 *
 *  @parm UINT | cbmxcaps | Specifies the size, in bytes, of the <t MIXERCAPS>
 *      structure.
 *
 *  @rdesc The return value is zero if the function is successful. Otherwise,
 *      it returns a non-zero error number. Possible error returns include
 *      the following:
 *
 *      @flag <c MMSYSERR_BADDEVICEID> | The specified device identifier is
 *      out of range.
 *
 *      @flag <c MMSYSERR_INVALHANDLE> | The audio mixer device handle passed
 *      is invalid.
 *
 *      @flag <c MMSYSERR_INVALPARAM> | One or more arguments passed is
 *      invalid.
 *
 *  @comm Use the <f mixerGetNumDevs> function to determine the number of
 *      audio mixer devices present in the system. The device identifier
 *      specified by <p uMxId> varies from zero to one less than the number
 *      of mixer devices present.
 *
 *      Only <p cbmxcaps> bytes (or less) of information is copied to the
 *      location pointed to by <p pmxcaps>. If <p cbmxcaps> is zero, nothing
 *      is copied, and the function returns success.
 *
 *      This function also accepts an audio mixer device handle returned by
 *      the <f mixerOpen> function as the <p uMxId> argument. The calling
 *      application should cast the <c HMIXER> handle to a UINT.
 *
 *  @xref <f mixerGetNumDevs>, <t MIXERCAPS>, <f mixerOpen>
 *
 **/

MMRESULT APIENTRY mixerGetDevCapsA(
    UINT_PTR                uMxId,
    LPMIXERCAPSA            pmxcapsA,
    UINT                    cbmxcaps
)
{
    MIXERCAPS2W    mxcaps2W;
    MIXERCAPS2A    mxcaps2A;
    MMRESULT       mmr;

    if (0 == cbmxcaps)
        return (MMSYSERR_NOERROR);

    V_WPOINTER(pmxcapsA, cbmxcaps, MMSYSERR_INVALPARAM);

    memset(&mxcaps2W, 0, sizeof(mxcaps2W));

    mmr = mixerGetDevCaps(uMxId, (LPMIXERCAPSW)&mxcaps2W, sizeof(mxcaps2W));

    if (mmr != MMSYSERR_NOERROR) {
        return mmr;
    }

    //
    //  Copy the structure back as cleanly as possible.  This would
    //  Be a little easier if all the strings were at the end of structures.
    //  Things would be a LOT more sensible if they could ONLY ask for the
    //  whole structure (then we could copy the result direct to the
    //  caller's memory).
    //
    //  Because of all this it's easiest to get the whole UNICODE structure,
    //  massage it into an ASCII stucture then (for the 0.001% of such apps)
    //  copy back the part they actually asked for.  The definition of the
    //  API means that, far from these apps going faster, everyone goes slow.
    //

    Iwcstombs(mxcaps2A.szPname, mxcaps2W.szPname, MAXPNAMELEN);
    mxcaps2A.wMid = mxcaps2W.wMid;
    mxcaps2A.wPid = mxcaps2W.wPid;
    mxcaps2A.vDriverVersion = mxcaps2W.vDriverVersion;
    mxcaps2A.fdwSupport = mxcaps2W.fdwSupport;
    mxcaps2A.cDestinations = mxcaps2W.cDestinations;
    mxcaps2A.ManufacturerGuid = mxcaps2W.ManufacturerGuid;
    mxcaps2A.ProductGuid      = mxcaps2W.ProductGuid;
    mxcaps2A.NameGuid      = mxcaps2W.NameGuid;

    CopyMemory((PVOID)pmxcapsA, &mxcaps2A, min(sizeof(mxcaps2A), cbmxcaps));

    return mmr;

} // mixerGetDevCapsA()

MMRESULT APIENTRY mixerGetDevCaps(
    UINT_PTR                uMxId,
    LPMIXERCAPS             pmxcaps,
    UINT                    cbmxcaps
)
{
    DWORD_PTR       dwParam1, dwParam2;
    MDEVICECAPSEX   mdCaps;
    PCWSTR          DevInterface;
    MMRESULT        mmr;

    if (0 == cbmxcaps)
        return (MMSYSERR_NOERROR);

    V_WPOINTER(pmxcaps, cbmxcaps, MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    DevInterface = mixerReferenceDevInterfaceById(uMxId);
    dwParam2 = (DWORD_PTR)DevInterface;
    
    if (0 == dwParam2)
    {
        dwParam1 = (DWORD_PTR)pmxcaps;
        dwParam2 = (DWORD)cbmxcaps;
    }
    else
    {
        mdCaps.cbSize = (DWORD)cbmxcaps;
        mdCaps.pCaps  = pmxcaps;
        dwParam1      = (DWORD_PTR)&mdCaps;
    }

    AcquireHandleListResourceShared();

    if ((uMxId >= guTotalMixerDevs) && !BAD_HANDLE((HMIXER)uMxId, TYPE_MIXER))
    {
       mmr = (MMRESULT)IMixerMessageHandle((HMIXER)uMxId,
                                           MXDM_GETDEVCAPS,
                                           dwParam1,
                                           dwParam2);
    }
    else
    {
        ReleaseHandleListResource();
        mmr = (MMRESULT)IMixerMessageId((UINT)uMxId,
                                       MXDM_GETDEVCAPS,
                                       (DWORD_PTR)dwParam1,
                                       (DWORD_PTR)dwParam2);
    }

    if (DevInterface) wdmDevInterfaceDec(DevInterface);

    return (mmr);

} // mixerGetDevCaps()



/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK API
 *
 *  @api MMRESULT | mixerGetID | The <f mixerGetID> function gets the device
 *      identifier for an audio mixer device that corresponds to audio mixer
 *      object handle <p hmxobj>.
 *
 *  @parm <c HMIXEROBJ> | hmxobj | Identifies the audio mixer object handle
 *      to map to an audio mixer device identifier.
 *
 *  @parm UINT FAR * | puMxId | Points to a UINT-sized variable that will
 *      receive the audio mixer device identifier. If no mixer device is
 *      available for the <p hmxobj> object, then '-1' is placed in this
 *      location (an error code of <c MMSYSERR_NODRIVER> is also returned).
 *
 *  @parm DWORD | fdwId | Specifies flags for how to map the audio mixer
 *      object <p hmxobj>.
 *
 *      @flag <c MIXER_OBJECTF_MIXER> | Specifies that <p hmxobj> is an audio
 *      mixer device identifier in the range of zero to one less than the
 *      number of devices returned by <f mixerGetNumDevs>. This flag is
 *      optional.
 *
 *      @flag <c MIXER_OBJECTF_HMIXER> | Specifies that <p hmxobj> is a mixer
 *      device handle returned by <f mixerOpen>. This flag is optional.
 *
 *      @flag <c MIXER_OBJECTF_WAVEOUT> | Specifies that <p hmxobj> is a
 *      waveform output device identifier in the range of zero to one less
 *      than the number of devices returned by <f waveOutGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HWAVEOUT> | Specifies that <p hmxobj> is a
 *      waveform output handle returned by <f waveOutOpen>.
 *
 *      @flag <c MIXER_OBJECTF_WAVEIN> | Specifies that <p hmxobj> is a
 *      waveform input device identifier in the range of zero to one less
 *      than the number of devices returned by <f waveInGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HWAVEIN> | Specifies that <p hmxobj> is a
 *      waveform input handle returned by <f midiInOpen>.
 *
 *      @flag <c MIXER_OBJECTF_MIDIOUT> | Specifies that <p hmxobj> is a MIDI
 *      output device identifier in the range of zero to one less than the
 *      number of devices returned by <f midiOutGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HMIDIOUT> | Specifies that <p hmxobj> is a
 *      MIDI output handle returned by <f midiOutOpen>.
 *
 *      @flag <c MIXER_OBJECTF_MIDIIN> | Specifies that <p hmxobj> is a MIDI
 *      input device identifier in the range of zero to one less than the
 *      number of devices returned by <f midiInGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HMIDIIN> | Specifies that <p hmxobj> is a MIDI
 *      input handle returned by <f midiInOpen>.
 *
 *      @flag <c MIXER_OBJECTF_AUX> | Specifies that <p hmxobj> is an
 *      auxiliary device identifier in the range of zero to one less than the
 *      number of devices returned by <f auxGetNumDevs>.
 *
 *  @rdesc The return value is zero if the function is successful. Otherwise,
 *      it returns a non-zero error number. Possible error returns include
 *      the following:
 *
 *      @flag <c MMSYSERR_BADDEVICEID> | The <p hmxobj> argument specifies an
 *      invalid device identifier.
 *
 *      @flag <c MMSYSERR_INVALHANDLE> | The <p hmxobj> argument specifies an
 *      invalid handle.
 *
 *      @flag <c MMSYSERR_INVALFLAG> | One or more flags are invalid.
 *
 *      @flag <c MMSYSERR_INVALPARAM> | One or more arguments passed is
 *      invalid.
 *
 *      @flag <c MMSYSERR_NODRIVER> | No audio mixer device is available for
 *      the object specified by <p hmxobj>. Note that the location referenced
 *      by <p puMxId> will also contain the value '-1'.
 *
 *  @comm Use the <f mixerGetID> function to determine what audio mixer
 *      device (if any) is responsible for performing mixing functions on a
 *      media device. For example, an application can use <f mixerGetID> to
 *      get the mixer device identifier responsible for setting the volume
 *      on a waveform output handle. Or the application may want to display
 *      a peak meter for waveform input device.
 *
 *  @xref <f mixerGetNumDevs>, <f mixerGetDevCaps>, <f mixerOpen>
 *
 **/
MMRESULT APIENTRY mixerGetID(
    HMIXEROBJ               hmxobj,
    UINT FAR               *puMxId,
    DWORD                   fdwId
)
{
    ClientUpdatePnpInfo();

    return IMixerGetID( hmxobj, (PUINT)puMxId, NULL, fdwId );
} // mixerGetID()

//--------------------------------------------------------------------------;
//
//  MMRESULT IMixerGetID
//
//  Description:
//
//
//  Arguments:
//      HMIXEROBJ hmxobj:
//
//      UINT FAR *puMxId:
//
//      DWORD fdwId:
//
//  Return (MMRESULT):
//
//  History:
//      06/27/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT IMixerGetID(
    HMIXEROBJ           hmxobj,
    PUINT               puMxId,
    LPMIXERLINE         pmxl,
    DWORD               fdwId
)
{
    MMRESULT        mmr;
    MIXERLINE       mxl;
    UINT            u;

    V_DFLAGS(fdwId, MIXER_GETIDF_VALID, IMixerGetID, MMSYSERR_INVALFLAG);
    V_WPOINTER(puMxId, sizeof(UINT), MMSYSERR_INVALPARAM);


    //
    //  set to '-1' which would be the mixer mapper (if there was one)
    //  this way we will definitely fail any calls made on this id if
    //  this function fails and the caller doesn't check his return value.
    //
    *puMxId = (UINT)-1;


    //
    //
    //
    switch (MIXER_OBJECTF_TYPEMASK & fdwId)
    {
        case MIXER_OBJECTF_MIXER:
        case MIXER_OBJECTF_HMIXER:
        {
            mmr = (fdwId & MIXER_OBJECTF_HANDLE) ? MMSYSERR_INVALHANDLE : MMSYSERR_BADDEVICEID;
            
            if ((UINT_PTR)hmxobj >= guTotalMixerDevs)
            {
                V_HANDLE_ACQ(hmxobj, TYPE_MIXER, mmr);
                *puMxId = ((PMIXERDEV)hmxobj)->uDeviceID;
                ReleaseHandleListResource();
            } else {
            	*puMxId = PtrToUint(hmxobj);
            }
            return (MMSYSERR_NOERROR);
        }
        
        case MIXER_OBJECTF_HWAVEOUT:
        {
            UINT        uId;
            DWORD       dwId;

            mmr = waveOutGetID((HWAVEOUT)hmxobj, &uId);
            if (MMSYSERR_NOERROR != mmr)
            {
                return (MMSYSERR_INVALHANDLE);
            }

            if (WAVE_MAPPER == uId)
            {
                mmr = (MMRESULT)waveOutMessage((HWAVEOUT)hmxobj,
                                               WODM_MAPPER_STATUS,
                                               WAVEOUT_MAPPER_STATUS_DEVICE,
                                               (DWORD_PTR)(LPVOID)&dwId);

                if (MMSYSERR_NOERROR == mmr)
                {
                    uId = (UINT)dwId;
                }
            }

            hmxobj = (HMIXEROBJ)(UINT_PTR)uId;
        }

        case MIXER_OBJECTF_WAVEOUT:
        {
            WAVEOUTCAPS     woc;

            mmr = waveOutGetDevCaps((UINT_PTR)hmxobj, &woc, sizeof(woc));
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_BADDEVICEID);

            woc.szPname[SIZEOF(woc.szPname) - 1] = '\0';

            mxl.Target.dwType         = MIXERLINE_TARGETTYPE_WAVEOUT;
            mxl.Target.dwDeviceID     = PtrToUlong(hmxobj);
            mxl.Target.wMid           = woc.wMid;
            mxl.Target.wPid           = woc.wPid;
            mxl.Target.vDriverVersion = woc.vDriverVersion;
            lstrcpy(mxl.Target.szPname, woc.szPname);
            break;
        }


        case MIXER_OBJECTF_HWAVEIN:
        {
            UINT        uId;
            DWORD       dwId;

            mmr = waveInGetID((HWAVEIN)hmxobj, &uId);
            if (MMSYSERR_NOERROR != mmr)
            {
                return (MMSYSERR_INVALHANDLE);
            }

            if (WAVE_MAPPER == uId)
            {
                mmr = (MMRESULT)waveInMessage((HWAVEIN)hmxobj,
                                              WIDM_MAPPER_STATUS,
                                              WAVEIN_MAPPER_STATUS_DEVICE,
                                              (DWORD_PTR)(LPVOID)&dwId);

                if (MMSYSERR_NOERROR == mmr)
                {
                    uId = (UINT)dwId;
                }
            }

            hmxobj = (HMIXEROBJ)(UINT_PTR)uId;
        }

        case MIXER_OBJECTF_WAVEIN:
        {
            WAVEINCAPS      wic;

            mmr = waveInGetDevCaps((UINT_PTR)hmxobj, &wic, sizeof(wic));
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_BADDEVICEID);

            wic.szPname[SIZEOF(wic.szPname) - 1] = '\0';

            mxl.Target.dwType         = MIXERLINE_TARGETTYPE_WAVEIN;
            mxl.Target.dwDeviceID     = PtrToUlong(hmxobj);
            mxl.Target.wMid           = wic.wMid;
            mxl.Target.wPid           = wic.wPid;
            mxl.Target.vDriverVersion = wic.vDriverVersion;
            lstrcpy(mxl.Target.szPname, wic.szPname);
            break;
        }


        case MIXER_OBJECTF_HMIDIOUT:
            mmr = midiOutGetID((HMIDIOUT)hmxobj, (UINT FAR *)&hmxobj);
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_INVALHANDLE);

        case MIXER_OBJECTF_MIDIOUT:
        {
            MIDIOUTCAPS     moc;

            mmr = midiOutGetDevCaps((UINT_PTR)hmxobj, &moc, sizeof(moc));
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_BADDEVICEID);

            moc.szPname[SIZEOF(moc.szPname) - 1] = '\0';

            mxl.Target.dwType         = MIXERLINE_TARGETTYPE_MIDIOUT;
            mxl.Target.dwDeviceID     = PtrToUlong(hmxobj);
            mxl.Target.wMid           = moc.wMid;
            mxl.Target.wPid           = moc.wPid;
            mxl.Target.vDriverVersion = moc.vDriverVersion;
            lstrcpy(mxl.Target.szPname, moc.szPname);
            break;
        }


        case MIXER_OBJECTF_HMIDIIN:
            mmr = midiInGetID((HMIDIIN)hmxobj, (UINT FAR *)&hmxobj);
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_INVALHANDLE);

        case MIXER_OBJECTF_MIDIIN:
        {
            MIDIINCAPS      mic;

            mmr = midiInGetDevCaps((UINT_PTR)hmxobj, &mic, sizeof(mic));
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_BADDEVICEID);

            mic.szPname[SIZEOF(mic.szPname) - 1] = '\0';

            mxl.Target.dwType         = MIXERLINE_TARGETTYPE_MIDIIN;
            mxl.Target.dwDeviceID     = PtrToUlong(hmxobj);
            mxl.Target.wMid           = mic.wMid;
            mxl.Target.wPid           = mic.wPid;
            mxl.Target.vDriverVersion = mic.vDriverVersion;
            lstrcpy(mxl.Target.szPname, mic.szPname);
            break;
        }


        case MIXER_OBJECTF_AUX:
        {
            AUXCAPS         ac;

            mmr = auxGetDevCaps((UINT_PTR)hmxobj, &ac, sizeof(ac));
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_BADDEVICEID);

            ac.szPname[SIZEOF(ac.szPname) - 1] = '\0';

            mxl.Target.dwType         = MIXERLINE_TARGETTYPE_AUX;
            mxl.Target.dwDeviceID     = PtrToUlong(hmxobj);
            mxl.Target.wMid           = ac.wMid;
            mxl.Target.wPid           = ac.wPid;
            mxl.Target.vDriverVersion = ac.vDriverVersion;
            lstrcpy(mxl.Target.szPname, ac.szPname);
            break;
        }

        default:
            DebugErr1(DBF_ERROR,
                      "mixerGetID: unknown mixer object flag (%.08lXh).",
                      MIXER_OBJECTF_TYPEMASK & fdwId);
            return (MMSYSERR_INVALFLAG);
    }


    //
    //
    //
    //
    mxl.cbStruct        = sizeof(mxl);
    mxl.dwDestination   = (DWORD)-1L;
    mxl.dwSource        = (DWORD)-1L;
    mxl.dwLineID        = (DWORD)-1L;
    mxl.fdwLine         = 0;
    mxl.dwUser          = 0;
    mxl.dwComponentType = (DWORD)-1L;
    mxl.cChannels       = 0;
    mxl.cConnections    = 0;
    mxl.cControls       = 0;
    mxl.szShortName[0]  = '\0';
    mxl.szName[0]       = '\0';


    for (u = 0; u < guTotalMixerDevs; u++)
    {
        mmr = (MMRESULT)IMixerMessageId(u,
                                        MXDM_GETLINEINFO,
                                        (DWORD_PTR)(LPVOID)&mxl,
                                        MIXER_GETLINEINFOF_TARGETTYPE);

        if (MMSYSERR_NOERROR == mmr)
        {
            *puMxId = u;

            if (NULL != pmxl)
            {
                DWORD       cbStruct;

                cbStruct = pmxl->cbStruct;

                CopyMemory(pmxl, &mxl, (UINT)cbStruct);

                pmxl->cbStruct = cbStruct;
            }

            return (mmr);
        }
    }

    return (MMSYSERR_NODRIVER);
} // IMixerGetID()


/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK API
 *
 *  @api MMRESULT | mixerOpen | The <f mixerOpen> function opens a specified
 *      audio mixer device for use. An application must open a mixer device
 *      if it wishes to receive notifications of mixer line and control
 *      changes. This function also ensures that the device will not be
 *      removed until the application closes the handle.
 *
 *  @parm LPHMIXER | phmx | Points to a variable that will receive a handle
 *      that identifies the opened audio mixer device. Use this handle to
 *      identify the device when calling other audio mixer functions. This
 *      argument may not be NULL. If an application wishes to query for
 *      audio mixer support on a media device, the <f mixerGetID> function
 *      may be used.
 *
 *  @parm UINT | uMxId | Identifies the audio mixer device to open. Use a
 *      valid device identifier or any <c HMIXEROBJ> (see <f mixerGetID> for
 *      a description of mixer object handles). Note that there is currently
 *      no 'mapper' for audio mixer devices, so a mixer device identifier of
 *      '-1' is not valid.
 *
 *  @parm DWORD | dwCallback | Specifies a handle to a window called when the
 *      state of an audio mixer line and/or control associated with the
 *      device being opened is changed. Specify zero for this argument
 *      if no callback mechanism is to be used.
 *
 *  @parm DWORD | dwInstance | This parameter is currently not used and
 *      should be set to zero.
 *
 *  @parm DWORD | fdwOpen | Specifies flags for opening the device.
 *
 *      @flag CALLBACK_WINDOW | If this flag is specified, <p dwCallback> is
 *      assumed to be a window handle.
 *
 *      @flag <c MIXER_OBJECTF_MIXER> | Specifies that <p uMxId> is an audio
 *      mixer device identifier in the range of zero to one less than the
 *      number of devices returned by <f mixerGetNumDevs>. This flag is
 *      optional.
 *
 *      @flag <c MIXER_OBJECTF_HMIXER> | Specifies that <p uMxId> is a mixer
 *      device handle returned by <f mixerOpen>. This flag is optional.
 *
 *      @flag <c MIXER_OBJECTF_WAVEOUT> | Specifies that <p uMxId> is a
 *      waveform output device identifier in the range of zero to one less
 *      than the number of devices returned by <f waveOutGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HWAVEOUT> | Specifies that <p uMxId> is a
 *      waveform output handle returned by <f waveOutOpen>.
 *
 *      @flag <c MIXER_OBJECTF_WAVEIN> | Specifies that <p uMxId> is a
 *      waveform input device identifier in the range of zero to one less
 *      than the number of devices returned by <f waveInGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HWAVEIN> | Specifies that <p uMxId> is a
 *      waveform input handle returned by <f midiInOpen>.
 *
 *      @flag <c MIXER_OBJECTF_MIDIOUT> | Specifies that <p uMxId> is a MIDI
 *      output device identifier in the range of zero to one less than the
 *      number of devices returned by <f midiOutGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HMIDIOUT> | Specifies that <p uMxId> is a
 *      MIDI output handle returned by <f midiOutOpen>.
 *
 *      @flag <c MIXER_OBJECTF_MIDIIN> | Specifies that <p uMxId> is a MIDI
 *      input device identifier in the range of zero to one less than the
 *      number of devices returned by <f midiInGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HMIDIIN> | Specifies that <p uMxId> is a MIDI
 *      input handle returned by <f midiInOpen>.
 *
 *      @flag <c MIXER_OBJECTF_AUX> | Specifies that <p uMxId> is an
 *      auxiliary device identifier in the range of zero to one less than the
 *      number of devices returned by <f auxGetNumDevs>.
 *
 *  @rdesc The return value is zero if the function is successful. Otherwise,
 *      it returns a non-zero error number. Possible error returns include
 *      the following:
 *
 *      @flag <c MMSYSERR_BADDEVICEID> | The <p uMxId> argument specifies an
 *      invalid device identifier.
 *
 *      @flag <c MMSYSERR_INVALHANDLE> | The <p uMxId> argument specifies an
 *      invalid handle.
 *
 *      @flag <c MMSYSERR_INVALFLAG> | One or more flags are invalid.
 *
 *      @flag <c MMSYSERR_INVALPARAM> | One or more arguments passed is
 *      invalid.
 *
 *      @flag <c MMSYSERR_NODRIVER> | No audio mixer device is available for
 *      the object specified by <p uMxId>. Note that the location referenced
 *      by <p uMxId> will also contain the value '-1'.
 *
 *      @flag <c MMSYSERR_ALLOCATED> | The specified resource is already
 *      allocated by the maximum number of clients possible.
 *
 *      @flag <c MMSYSERR_NOMEM> | Unable to allocate resources.
 *
 *  @comm Use the <f mixerGetNumDevs> function to determine the number of
 *      audio mixer devices present in the system. The device identifier
 *      specified by <p uMxId> varies from zero to one less than the number
 *      of devices present.
 *
 *      If a window is chosen to receive callback information, the following
 *      messages are sent to the window procedure function to indicate when
 *      a line or control state changes: <m MM_MIXM_LINE_CHANGE>,
 *      <m MM_MIXM_CONTROL_CHANGE>. <p wParam> is the handle to the mixer
 *      device. <p lParam> is the line identifier for <m MM_MIXM_LINE_CHANGE>
 *      or the control identifier for <m MM_MIXM_CONTROL_CHANGE> that
 *      changed state.
 *
 *  @xref <f mixerClose>, <f mixerGetNumDevs>, <f mixerGetID>,
 *      <f mixerGetLineInfo>
 *
 **/

MMRESULT APIENTRY mixerOpen(
    LPHMIXER                phmx,
    UINT                    uMxId,
    DWORD_PTR               dwCallback,
    DWORD_PTR               dwInstance,
    DWORD                   fdwOpen
)
{
    MMRESULT        mmr;
    PMIXERDRV       pmxdrv;
    UINT            port;
    PMIXERDEV       pmxdev;
    PMIXERDEV       pmxdevRunList;
    MIXEROPENDESC   mxod;
    DWORD_PTR       dwDrvUser;

    //
    //
    //
    V_WPOINTER(phmx, sizeof(HMIXER), MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    *phmx = NULL;

    //
    //  Don't allow callback functions - they're not useful and they
    //  cause headaches.   Specifically for Windows NT the only way
    //  to cause an asynchronous callback to 16-bit land from a 32-bit DLL
    //  is to cause an interrupt but we don't want to require mixer stuff
    //  to be locked down to allow for this.
    //

    if ((fdwOpen & CALLBACK_TYPEMASK) == CALLBACK_FUNCTION)
    {
        DebugErr(DBF_ERROR, "mixerOpen: CALLBACK_FUNCTION is not supported");
        return MMSYSERR_INVALFLAG;
    }

    V_DCALLBACK(dwCallback, HIWORD(fdwOpen & CALLBACK_TYPEMASK), MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwOpen, MIXER_OPENF_VALID, mixerOpen, MMSYSERR_INVALFLAG);

    mmr = IMixerGetID((HMIXEROBJ)(UINT_PTR)uMxId, &uMxId, NULL, (MIXER_OBJECTF_TYPEMASK & fdwOpen));
    if (MMSYSERR_NOERROR != mmr)
        return (mmr);


    //
    //
    //
    //
    mmr = mixerReferenceDriverById(uMxId, &pmxdrv, &port);
    if (mmr)
    {
        return mmr;
    }

#ifdef MIXER_MAPPER
    //
    //  Default Mixer Mapper:
    //
    //  If a mixer mapper is installed as a separate DLL then all mixer
    //  mapper messages are routed to it. If no mixer mapper is installed,
    //  simply loop through the mixer devices looking for a match.
    //
    if ((MIXER_MAPPER == uMxId) && (NULL == pmxdrv->drvMessage))
    {
        for (uMxId = 0; uMxId < guTotalMixerDevs; uMxId++)
        {
            // try to open it
            if (MMSYSERR_NOERROR == mmr)
                break;

        }

        mregDecUsagePtr(pmxdrv);
        return (mmr);
    }
#endif


    //
    // Get some memory for the dev structure
    //
    pmxdev = (PMIXERDEV)NewHandle(TYPE_MIXER, pmxdrv->cookie, sizeof(MIXERDEV));
    if (NULL == pmxdev)
    {
    	mregDecUsagePtr(pmxdrv);
        return (MMSYSERR_NOMEM);
    }

    ENTER_MM_HANDLE(pmxdev);
    SetHandleFlag(pmxdev, MMHANDLE_BUSY);
    ReleaseHandleListResource();

    //
    //  initialize our open instance struct for the client
    //
    pmxdev->uHandleType = TYPE_MIXER;
    pmxdev->pmxdrv      = pmxdrv;
    pmxdev->wDevice     = port;
    pmxdev->uDeviceID   = uMxId;
    pmxdev->fdwHandle   = 0;

    //
    //  save the client's callback info
    //
    pmxdev->dwCallback  = dwCallback;
    pmxdev->dwInstance  = dwInstance;
    pmxdev->fdwOpen     = fdwOpen;

    MIXMGR_ENTER;

    //
    // Check to see if we already have this device open
    //
    for (pmxdevRunList = gpMixerDevHeader; pmxdevRunList; pmxdevRunList = pmxdevRunList->pmxdevNext)
    {
    	if (pmxdevRunList->pmxdrv != pmxdrv) continue;
    	if (pmxdevRunList->wDevice != port) continue;
    	break;
    }
         
    //
    // Have we found a match?
    //
    if (NULL != pmxdevRunList)
    {
        //
        // Set the driver's dwUser to the value we got before.
        //
        pmxdev->dwDrvUser = pmxdevRunList->dwDrvUser;

        //
        // We have a match, add the caller to the devlist chain (next in
        // line AFTER the one we just found).
        //
        pmxdev->pmxdevNext = pmxdevRunList->pmxdevNext;
        pmxdevRunList->pmxdevNext = pmxdev;

        ClearHandleFlag(pmxdev, MMHANDLE_BUSY);

        MIXMGR_LEAVE;
        LEAVE_MM_HANDLE(pmxdev);

        //
        // Tell the caller the good news
        //
        *phmx = (HMIXER)pmxdev;

        //
        // All done.  Note we don't dec usage on pmxdrv.
        //
        return (MMSYSERR_NOERROR);
    }
    
    //
    // If we get here, no one has the device currently open.  Let's
    // go open it, then.
    //

    //
    // Load up our local MIXEROPENDESC struct
    //

    mxod.hmx         = (HMIXER)pmxdev;
    mxod.pReserved0  = (LPVOID)NULL;
    mxod.dwCallback  = (DWORD_PTR)MixerCallbackFunc;
    mxod.dwInstance  = (DWORD_PTR)uMxId;
    mxod.dnDevNode   = (DWORD_PTR)pmxdev->pmxdrv->cookie;
    
    EnterCriticalSection(&pmxdrv->MixerCritSec);
    
    mmr = (MMRESULT)((*(pmxdrv->drvMessage))(port,
                                             MXDM_OPEN,
                                             (DWORD_PTR)(LPDWORD)&dwDrvUser,
                                             (DWORD_PTR)(LPVOID)&mxod,
                                             CALLBACK_FUNCTION));
                                        
    LeaveCriticalSection(&pmxdrv->MixerCritSec);

    if (MMSYSERR_NOERROR != mmr)
    {
        //  Should we do this after the MIXMGR_LEAVE???
        LEAVE_MM_HANDLE(pmxdev);
        MIXMGR_LEAVE;
        FreeHandle((HMIXER)pmxdev);
    }
    else
    {
        MIXERCAPS       mxcaps;
        DWORD_PTR       dwParam1, dwParam2;
        MDEVICECAPSEX   mdCaps;

        mregIncUsagePtr(pmxdrv);

        dwParam2 = (DWORD_PTR)pmxdev->pmxdrv->cookie;

        if (0 == dwParam2)
        {
            dwParam1 = (DWORD_PTR)&mxcaps;
            dwParam2 = (DWORD)sizeof(mxcaps);
        }
        else
        {
            mdCaps.cbSize = (DWORD)sizeof(mxcaps);
            mdCaps.pCaps  = &mxcaps;
            dwParam1      = (DWORD_PTR)&mdCaps;
        }

        //  Calling manually since we don't have the HandleList resource...
        EnterCriticalSection(&pmxdrv->MixerCritSec);
        (*(pmxdrv->drvMessage))(port, MXDM_GETDEVCAPS, dwDrvUser, dwParam1, dwParam2);
        LeaveCriticalSection(&pmxdrv->MixerCritSec);

        //
        //  cache some stuff for parameter validation
        //
        pmxdev->fdwSupport    = mxcaps.fdwSupport;
        pmxdev->cDestinations = mxcaps.cDestinations;
        pmxdev->dwDrvUser = dwDrvUser;
        *phmx = (HMIXER)pmxdev;

        //
        // Put this new device into the devlist chain.
        //

        pmxdev->pmxdevNext = gpMixerDevHeader;
        gpMixerDevHeader = pmxdev;
        
        ClearHandleFlag(pmxdev, MMHANDLE_BUSY);
        LEAVE_MM_HANDLE(pmxdev);
        MIXMGR_LEAVE;
    }
    
    mregDecUsagePtr(pmxdrv);

    return (mmr);

} // mixerOpen()


/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK API
 *
 *  @api MMRESULT | mixerClose | The <f mixerClose> function closes the
 *      specified audio mixer device. An application must close all mixer
 *      handles before exiting (or when the application is finished using
 *      the device).
 *
 *  @parm <c HMIXER> | hmx | Specifies a handle to the audio mixer device.
 *      This handle must have been returned successfully by <f mixerOpen>. If
 *      <f mixerClose> is successful, <p hmx> is no longer valid.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag <c MMSYSERR_INVALHANDLE> | Specified device handle is invalid.
 *
 *  @xref <f mixerOpen>
 *
 **/

MMRESULT APIENTRY mixerClose(
    HMIXER                  hmx
)
{
    MMRESULT    mmr;
    PMIXERDEV   pmxdev;
    PMIXERDRV   pmxdrv;
    BOOL        closemixerdriver;

    ClientUpdatePnpInfo();
    
    V_HANDLE_ACQ(hmx, TYPE_MIXER, MMSYSERR_INVALHANDLE);

    ENTER_MM_HANDLE(hmx);
    ReleaseHandleListResource();
    
    if (IsHandleDeserted(hmx))
    {
        //  This handle has been deserted.  Let's just free it.

        LEAVE_MM_HANDLE(hmx);
        FreeHandle(hmx);
        return MMSYSERR_NOERROR;
    }

    //
    //  remove the mixer handle from the linked list
    //
    //  BUGBUG:  We're removing the driver from the list BEFORE we know if 
    //  the close is successful (for the last handle).
    //

    MIXMGR_ENTER;

    pmxdev = (PMIXERDEV)hmx;
    pmxdrv = pmxdev->pmxdrv;

    if (pmxdev == gpMixerDevHeader)
    {
        gpMixerDevHeader = pmxdev->pmxdevNext;
    }
    else
    {
        PMIXERDEV   pmxdevT;
            
        for (pmxdevT = gpMixerDevHeader;
            pmxdevT && (pmxdevT->pmxdevNext != pmxdev);
            pmxdevT = pmxdevT->pmxdevNext)
            ;

        if (NULL == pmxdevT)
        {
            DebugErr1(DBF_ERROR,
                    "mixerClose: invalid mixer handle (%.04Xh).",
                    hmx);

            MIXMGR_LEAVE;
            LEAVE_MM_HANDLE(hmx);

            return (MMSYSERR_INVALHANDLE);
        }

        pmxdevT->pmxdevNext = pmxdev->pmxdevNext;
    }

    //
    // see if this is the last handle on this open instance
    //
    closemixerdriver = TRUE;
    if (gpMixerDevHeader)
    {
        PMIXERDEV pmxdevT;
        for (pmxdevT = gpMixerDevHeader; pmxdevT; pmxdevT = pmxdevT->pmxdevNext)
        {
    	    if (pmxdevT->pmxdrv != pmxdev->pmxdrv) continue;
    	    if (pmxdevT->wDevice != pmxdev->wDevice) continue;
    	    closemixerdriver = FALSE;
    	    break;
        }
    }

    MIXMGR_LEAVE;

    //  handle should be marked as "busy" even if we don't send the driver
    //  message.
    SetHandleFlag(hmx, MMHANDLE_BUSY);

    //
    //  if last open instance, then close it
    //
    mmr = MMSYSERR_NOERROR;
        
    if (closemixerdriver)
    {
        EnterCriticalSection(&pmxdrv->MixerCritSec);
        mmr = (MMRESULT)(*(pmxdrv->drvMessage))(pmxdev->wDevice, MXDM_CLOSE, pmxdev->dwDrvUser, 0L, 0L);
        LeaveCriticalSection(&pmxdrv->MixerCritSec);

        if (MMSYSERR_NOERROR != mmr)
        {
            //  Should we put the handle back in the list???
            ClearHandleFlag(hmx, MMHANDLE_BUSY);
        }
    }

    LEAVE_MM_HANDLE(hmx);
    mregDecUsagePtr(pmxdev->pmxdrv);
        
    if (MMSYSERR_NOERROR == mmr)
    {
        //
        //  we're done with the memory block. now free the memory and return.
        //
        FreeHandle(hmx);
    }

    return (mmr);
} // mixerClose()


/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK API
 *
 *  @api DWORD | mixerMessage | The <f mixerMessage> function sends a user
 *      defined audio mixer driver message directly to a mixer driver.
 *
 *  @parm <c HMIXER> | hmx | Specifies a handle to an open instance of a
 *      mixer device. This handle is returned by <f mixerOpen>.
 *
 *  @parm UINT | uMsg | Specifies the user defined mixer driver message to
 *      send to the mixer driver. This message must be above or equal to
 *      the <m MXDM_USER> message.
 *
 *  @parm DWORD | dwParam1 | Contains the first argument associated with the
 *      message being sent.
 *
 *  @parm DWORD | dwParam2 | Contains the second argument associated with the
 *      message being sent.
 *
 *  @rdesc The return value is specific to the user defined mixer driver
 *      message <p uMsg> sent. However, the following return values are
 *      possible:
 *
 *      @flag <c MMSYSERR_INVALHANDLE> | Specified device handle is invalid.
 *
 *      @flag <c MMSYSERR_INVALPARAM> | <p uMsg> is not in the <m MXDM_USER>
 *      range.
 *
 *      @flag <c MMSYSERR_NOTSUPPORTED> | The mixer device did not process
 *      the message.
 *
 *  @comm The <f mixerMessage> function is provided to allow audio mixer
 *      driver specific messages to be sent to a mixer device. The messages
 *      that may be sent through this function must be above or equal to the
 *      <m MXDM_USER> message.
 *
 *      User defined messages must only be sent to a mixer driver that
 *      specifically supports the messages. The caller should verify that
 *      the mixer driver is in fact the correct driver by getting the
 *      mixer capabilities and checking the <e MIXERCAPS.wMid>,
 *      <e MIXERCAPS.wPid>, <e MIXERCAPS.vDriverVersion> and
 *      <e MIXERCAPS.szPname> members of the <t MIXERCAPS> structure.
 *
 *      It is important for an application to verify all members specified
 *      above due to many driver writers releasing drivers with improper
 *      or unregistered manufacturer and product identifiers.
 *
 *      Never send user defined messages to an unknown audio mixer driver.
 *
 *  @xref <f mixerOpen>, <f mixerGetDevCaps>
 *
 **/

DWORD APIENTRY mixerMessage(
    HMIXER                  hmx,
    UINT                    uMsg,
    DWORD_PTR               dwParam1,
    DWORD_PTR               dwParam2
)
{
    DWORD       dw;

    ClientUpdatePnpInfo();

    AcquireHandleListResourceShared();

    if (BAD_HANDLE(hmx, TYPE_MIXER))
    {
        ReleaseHandleListResource();
        return IMixerMessageId (PtrToUint(hmx), uMsg, dwParam1, dwParam2);
    }

    //
    //  don't allow any non-user range messages through this API
    //
    if (MXDM_USER > uMsg)
    {
        DebugErr1(DBF_ERROR, "mixerMessage: message must be in MXDM_USER range--what's this (%u)?", uMsg);
        ReleaseHandleListResource();
        return (MMSYSERR_INVALPARAM);
    }


    dw = IMixerMessageHandle(hmx, uMsg, dwParam1, dwParam2);

    return (dw);

} // mixerMessage()


//--------------------------------------------------------------------------;
//
//  BOOL IMixerIsValidComponentType
//
//  Description:
//
//
//  Arguments:
//      DWORD dwComponentType:
//
//      UINT uSrcDst:
//
//  Return (BOOL):
//
//  History:
//      10/06/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL IMixerIsValidComponentType
(
    DWORD           dwComponentType,
    DWORD           fdwLine
)
{

    if (0 == (MIXERLINE_LINEF_SOURCE & fdwLine))
    {
        if (dwComponentType > MIXERLINE_COMPONENTTYPE_DST_LAST)
            return (FALSE);

        return (TRUE);
    }
    else
    {
        if (dwComponentType < MIXERLINE_COMPONENTTYPE_SRC_FIRST)
            return (FALSE);

        if (dwComponentType > MIXERLINE_COMPONENTTYPE_SRC_LAST)
            return (FALSE);

        return (TRUE);
    }

} // IMixerIsValidComponentType()



/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK STRUCTURE
 *
 *  @types MIXERLINE | The <t MIXERLINE> structure describes the state
 *      and metrics of an audio mixer device line.
 *
 *  @syntaxex
 *      typedef struct tMIXERLINE
 *      {
 *          DWORD       cbStruct;
 *          DWORD       dwDestination;
 *          DWORD       dwSource;
 *          DWORD       dwLineID;
 *          DWORD       fdwLine;
 *          DWORD       dwUser;
 *          DWORD       dwComponentType;
 *          DWORD       cChannels;
 *          DWORD       cConnections;
 *          DWORD       cControls;
 *          char        szShortName[MIXER_SHORT_NAME_CHARS];
 *          char        szName[MIXER_LONG_NAME_CHARS];
 *          struct
 *          {
 *              DWORD       dwType;
 *              DWORD       dwDeviceID;
 *              WORD        wMid;
 *              WORD        wPid;
 *              MMVERSION   vDriverVersion;
 *              char        szPname[MAXPNAMELEN];
 *          } Target;
 *      } MIXERLINE;
 *
 *  @field DWORD | cbStruct | Specifies the size, in bytes, of the
 *      <t MIXERLINE> structure. This member must be initialized before
 *      calling the <f mixerGetLineInfo> function. The size specified in this
 *      member must be large enough to contain the base <t MIXERLINE>
 *      structure. When the <f mixerGetLineInfo> function returns, this
 *      member contains the actual size of the information returned. The
 *      returned information will never exceed the requested size.
 *
 *  @field DWORD | dwDestination | Specifies the destination line index.
 *      This member ranges from zero to one less than the value specified
 *      in the <e MIXERCAPS.cDestinations> member of the <t MIXERCAPS>
 *      structure retrieved by the <f mixerGetDevCaps> function. When the
 *      <f mixerGetLineInfo> function is called with the
 *      <c MIXER_GETLINEINFOF_DESTINATION> flag specified, the details for
 *      the destination line are returned. Note that the
 *      <e MIXERLINE.dwSource> member must be set to zero in this case. When
 *      called with the <c MIXER_GETLINEINFOF_SOURCE> flag specified, the
 *      details for the source given by the <e MIXERLINE.dwSource> member
 *      associated with the <e MIXERLINE.dwDestination> member are returned.
 *
 *  @field DWORD | dwSource | Specifies the source line index for the source
 *      line associated with the <e MIXERLINE.dwDestination> member. That
 *      is, this member specifies the nth source line associated with the
 *      specified destination line. This member is not used for destination
 *      lines and must be set to zero when <c MIXER_GETLINEINFOF_DESTINATION>
 *      is specified for <f mixerGetLineInfo>. When the
 *      <c MIXER_GETLINEINFOF_SOURCE> flag is specified, this member ranges
 *      from zero to one less than the value specified in the
 *      <e MIXERLINE.cConnections> of the <t MIXERLINE> structure for the
 *      destination line given in the <e MIXERLINE.dwDestination> member.
 *
 *  @field DWORD | dwLineID | Specifies an audio mixer defined identifier
 *      that uniquely refers to the line described by the <t MIXERLINE>
 *      structure. This identifier is unique only to a single mixer device
 *      and may be of any format that the mixer device wishes. An application
 *      should only use this identifier as an abstract handle. No two
 *      lines for a single mixer device will have the same line identifier
 *      under any circumstances.
 *
 *  @field DWORD | fdwLine | Specifies status and support flags for the
 *      audio mixer line. This member is always returned to the application
 *      and requires no initialization.
 *
 *      @flag <c MIXERLINE_LINEF_SOURCE> | Specifies that this audio mixer
 *      line is a source line associated with a single destination line. If
 *      this flag is not set, then this line is a destination line associated
 *      with zero or more source lines.
 *
 *      @flag <c MIXERLINE_LINEF_DISCONNECTED> | Specifies that this audio
 *      mixer line is disconnected. A disconnected line's associated controls
 *      can still be modified but the changes will have no effect until the
 *      line becomes connected. An application may want to modify its
 *      behavior if a mixer line is disconnected.
 *
 *      @flag <c MIXERLINE_LINEF_ACTIVE> | Specifies that this audio mixer
 *      line is active. An active line specifies that a signal is (probably)
 *      passing through the line. For example, if a waveform output device
 *      is not in use by an application, then the line associated with that
 *      device would not be active (the <c MIXERLINE_LINEF_ACTIVE> flag would
 *      not be set). If the waveform output device is opened, then the
 *      the line is considered active and the <c MIXERLINE_LINEF_ACTIVE> flag
 *      will be set. Note that a 'paused' or 'starved' waveform output device
 *      is still considered active. In other words, if the waveform output
 *      device is opened by an application regardless of whether data is
 *      being played, the associated line is considered active. If a line
 *      cannot be strictly defined as 'active' verses 'inactive', then the
 *      audio mixer device will always set the <c MIXERLINE_LINEF_ACTIVE>
 *      flag. An example of where this information can be used by an
 *      application is displaying a 'peak meter.' Peak meters are polled
 *      meters. An application may want to disable its polling timer while
 *      the line is inactive to improve system performance. Note that the
 *      <c MIXERLINE_LINEF_ACTIVE> flag is also affected by the status of
 *      the mixer line's mute control. Muted mixer lines are never active.
 *
 *  @field DWORD | dwUser | Specifies 32-bits of audio mixer device defined
 *      instance data for the line. This member is intended for custom
 *      audio mixer applications designed specifically for the mixer device
 *      returning this information. An application that is not specifically
 *      tailored to understand this member should simply ignore this data.
 *
 *  @field DWORD | dwComponentType | Specifies the component type for this
 *      line. An application may use this information to display tailored
 *      graphics or search for a particular component. If an application
 *      does not know about a component type, then this member should be
 *      ignored. Currently, this member may be one of the following values:
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_DST_UNDEFINED> | Specifies that the
 *      line is a destination that cannot be defined by one of the standard
 *      component types. An audio mixer device is required to use this
 *      component type for line component types that have not been defined
 *      by Microsoft.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_DST_DIGITAL> | Specifies that the
 *      line is a digital destination (for example, digital input to a DAT
 *      or CD Audio Disc).
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_DST_LINE> | Specifies that the line
 *      is a line level destination (for example, line level input from
 *      a CD Audio Disc) that will be the final recording source for the
 *      ADC. Most audio cards for the PC provide some sort of gain for the
 *      recording source line, so the mixer device will use the
 *      <c MIXERLINE_COMPONENTTYPE_DST_WAVEIN> type.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_DST_MONITOR> | Specifies that the
 *      line is a destination used for a monitor.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_DST_SPEAKERS> | Specifies that the
 *      line is an adjustable (gain and/or attenuation) destination intended
 *      to drive speakers. This is the normal component type for the audio
 *      output of most audio cards for the PC.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_DST_HEADPHONES> | Specifies that the
 *      line is an adjustable (gain and/or attenuation) destination intended
 *      to driver headphones. Most audio cards use the same destination
 *      line for speakers and headphones--in which case the mixer device
 *      will simply use the <c MIXERLINE_COMPONENTTYPE_DST_SPEAKERS> type.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_DST_TELEPHONE> | Specifies that the
 *      line is a destination that will be routed to the telephone line.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_DST_WAVEIN> | Specifies that the
 *      line is a destination that will be the final recording source for the
 *      waveform input (ADC). This line will normally provide some sort of
 *      gain or attenuation. This is the normal component type for the
 *      recording line of most audio cards for the PC.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_DST_VOICEIN> | Specifies that the
 *      line is a destination that will be the final recording source for
 *      voice input. This component type is exactly like
 *      <c MIXERLINE_COMPONENTTYPE_DST_WAVEIN> but is intended specifically
 *      for settings used during voice recording/recognition. This line
 *      is entirely optional for a mixer device to support--many mixer
 *      devices may only provide <c MIXERLINE_COMPONENTTYPE_DST_WAVEIN>.
 *
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED> | Specifies that the
 *      line is a source that cannot be defined by one of the standard
 *      component types. An audio mixer device is required to use this
 *      component type for line component types that have not been defined
 *      by Microsoft.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_SRC_DIGITAL> | Specifies that the
 *      line is a digital source (for example, digital output from a DAT or
 *      CD Audio Disc).
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_SRC_LINE> | Specifies that the line
 *      is a line level source (for example, line level input from
 *      an external stereo) that will be used as a, perhaps, optional source
 *      for recording. Most audio cards for the PC provide some sort of gain
 *      for the recording source line, so the mixer device will use the
 *      <c MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY> type.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE> | Specifies that the
 *      line is a microphone recording source. Most audio cards for the
 *      PC provide at least two types of recording sources: an auxiliary
 *      line and microphone input. A microphone line normally provides
 *      some sort of gain. Audio cards that use a single input for use
 *      with a microphone or auxiliary line should use the
 *      <c MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE> component type.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER> | Specifies that
 *      the line is a source originating from the output of an internal
 *      synthesizer. Most audio cards for the PC provide some sort of
 *      MIDI synthesizer (for example, an Ad Lib compatible or OPL/3 FM
 *      synthesizer).
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC> | Specifies that
 *      the line is a source originating from the output of an internal audio
 *      compact disc. This component type is provided for those audio cards
 *      that provide a source line solely intended to be connected to an
 *      audio compact disc (or CD-ROM playing a Redbook Audio CD).
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_SRC_TELEPHONE> | Specifies that the
 *      line is a source originating from an incoming telephone line.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_SRC_PCSPEAKER> | Specifies that the
 *      line is a source originating from the PC speaker. Several audio cards
 *      for the PC provide the ability to mix what would normally be played
 *      on the internal speaker with the output of an audio card. The
 *      ability to use this output as a source for recording has also been
 *      exploited by some audio cards.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT> | Specifies that the
 *      line is a source originating from the waveform output (DAC). Most
 *      cards for the PC provide this component type as a source to the
 *      <c MIXERLINE_COMPONENTTYPE_DST_SPEAKERS> destination. Some cards will
 *      also allow this source to be routed to the
 *      <c MIXERLINE_COMPONENTTYPE_DST_WAVEIN> destination.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY> | Specifies that the
 *      line is a source originating from the auxiliary line. This line type
 *      is intended as a source with gain or attenuation that can be routed
 *      to the <c MIXERLINE_COMPONENTTYPE_DST_SPEAKERS> destination and/or
 *      recorded from through the <c MIXERLINE_COMPONENTTYPE_DST_WAVEIN>
 *      destination.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_SRC_ANALOG> | Specifies that the
 *      line is a source originating from one or more lines. This line type
 *      is intended for audio mixers that can mix multiple lines into a
 *      single source for that can be routed to the
 *      <c MIXERLINE_COMPONENTTYPE_DST_SPEAKERS> destination and/or
 *      recorded from through the <c MIXERLINE_COMPONENTTYPE_DST_WAVEIN>
 *      destination.
 *
 *  @field DWORD | cChannels | Specifies the maximum number of separate
 *      channels that can be manipulated independantly for the line. Most
 *      of the modern audio cards for the PC are stereo devices, so this
 *      member will be two. Channel one is assumed to be the left channel;
 *      channel two is assumed to be the right channel. Note that a
 *      multi-channel line may have one or more uniform controls (controls
 *      that affect all channels of a line uniformly) associated with it.
 *      An example of a uniform control is a Mute that mutes all channels
 *      of a line simultaneously. A line must have at least one channel--
 *      this member will never be zero.
 *
 *  @field DWORD | cConnections | Specifies the number of connections that
 *      are associated with the line. Currently, this member is used only
 *      for destination lines and specifies the number of source lines
 *      that are associated with it. This number may be zero. For source
 *      lines, this member is always zero.
 *
 *  @field DWORD | cControls | Specifies the number of controls associated
 *      with the line. This value may be zero. If no controls are associated
 *      with the line, then the line is probably (but not always) just a
 *      source that may be selected in a MUX or Mixer but allows no
 *      manipulation of the signal. For example, a digital source may have
 *      this attribute.
 *
 *  @field char | szShortName[<c MIXER_SHORT_NAME_CHARS>] | Specifies a short
 *      string that describes the <e MIXERLINE.dwLineID> audio mixer line.
 *      This description is appropriate for using as a displayable label for
 *      the line that can fit in small spaces.
 *
 *  @field char | szName[<c MIXER_LONG_NAME_CHARS>] | Specifies a string
 *      that describes the <e MIXERLINE.dwLineID> audio mixer line. This
 *      description is appropriate for using as a displayable description
 *      for the line that is not limited by screen space.
 *
 *  @field struct | Target | Contains the target media information.
 *
 *  @field2 DWORD | dwType | Specifies the target media device type
 *      associated with the audio mixer line described in the <t MIXERLINE>
 *      structure. An application must ignore target information for media
 *      device types that it does not understand. Currently, this member may
 *      be one of the following:
 *
 *      @flag <c MIXERLINE_TARGETTYPE_UNDEFINED> | Specifies that the line
 *      described by this <t MIXERLINE> structure is not strictly bound
 *      to a defined media type. All remaining <e MIXERLINE.Target> structure
 *      members of the <t MIXERLINE> structure should be ignored. Note that
 *      an application may not use the <c MIXERLINE_TARGETTYPE_UNDEFINED>
 *      target type when calling the <f mixerGetLineInfo> function with the
 *      <c MIXER_GETLINEINFOF_TARGETTYPE> flag.
 *
 *      @flag <c MIXERLINE_TARGETTYPE_WAVEOUT> | Specifies that the line
 *      described by this <t MIXERLINE> structure is strictly bound to
 *      the waveform output device detailed in the remaining members of
 *      the <e MIXERLINE.Target> structure member of the <t MIXERLINE>
 *      structure.
 *
 *      @flag <c MIXERLINE_TARGETTYPE_WAVEIN> | Specifies that the line
 *      described by this <t MIXERLINE> structure is strictly bound to
 *      the waveform input device detailed in the remaining members of
 *      the <e MIXERLINE.Target> structure member of the <t MIXERLINE>
 *      structure.
 *
 *      @flag <c MIXERLINE_TARGETTYPE_MIDIOUT> | Specifies that the line
 *      described by this <t MIXERLINE> structure is strictly bound to
 *      the MIDI output device detailed in the remaining members of
 *      the <e MIXERLINE.Target> structure member of the <t MIXERLINE>
 *      structure.
 *
 *      @flag <c MIXERLINE_TARGETTYPE_MIDIIN> | Specifies that the line
 *      described by this <t MIXERLINE> structure is strictly bound to
 *      the MIDI input device detailed in the remaining members of
 *      the <e MIXERLINE.Target> structure member of the <t MIXERLINE>
 *      structure.
 *
 *      @flag <c MIXERLINE_TARGETTYPE_AUX> | Specifies that the line
 *      described by this <t MIXERLINE> structure is strictly bound to
 *      the auxiliary device detailed in the remaining members of
 *      the <e MIXERLINE.Target> structure member of the <t MIXERLINE>
 *      structure.
 *
 *  @field2 DWORD | dwDeviceID | In the case of the
 *      <e MIXERLINE.dwType> member being a target type other than
 *      <c MIXERLINE_TARGETTYPE_UNDEFINED>, this member is the current device
 *      identifier of the target media device. This identifier is identical
 *      to the current media device index of the associated media device.
 *      Note that when calling the <f mixerGetLineInfo> function with
 *      the <c MIXER_GETLINEINFOF_TARGETTYPE> flag, this member is ignored on
 *      input and will be returned to the caller by the audio mixer manager.
 *
 *  @field2 WORD | wMid | In the case of the <e MIXERLINE.dwType>
 *      member being a target type other than <c MIXERLINE_TARGETTYPE_UNDEFINED>,
 *      this member is the manufacturer identifier of the target media device.
 *      This identifier is identical to the wMid member of the associated
 *      media device capabilities structure.
 *
 *  @field WORD | wPid | In the case of the <e MIXERLINE.dwType>
 *      member being a target type other than <c MIXERLINE_TARGETTYPE_UNDEFINED>,
 *      this member is the product identifier of the target media device.
 *      This identifier is identical to the wPid member of the associated
 *      media device capabilities structure.
 *
 *  @field2 MMVERSION | vDriverVersion | In the case of the
 *      <e MIXERLINE.dwType> member being a target type other than
 *      <c MIXERLINE_TARGETTYPE_UNDEFINED>, this member is the driver version
 *      of the target media device. This version is identical to the
 *      vDriverVersion member of the associated media device capabilities
 *      structure.
 *
 *  @field char | szPname[MAXPNAMELEN] | In the case of the
 *      <e MIXERLINE.dwType> member being a target type other than
 *      <c MIXERLINE_TARGETTYPE_UNDEFINED>, this member is the product
 *      name of the target media device. This name is identical to the
 *      szPname member of the associated media device capabilities structure.
 *
 *  @tagname tMIXERLINE
 *
 *  @othertype MIXERLINE FAR * | LPMIXERLINE | A pointer to a <t MIXERLINE>
 *      structure.
 *
 *  @othertype MIXERLINE * | PMIXERLINE | A pointer to a <t MIXERLINE>
 *      structure.
 *
 *  @xref <f mixerGetLineInfo>, <f mixerGetDevCaps>
 *
 **/

/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK API
 *
 *  @api MMRESULT | mixerGetLineInfo | The <f mixerGetLineInfo> function
 *      retrieves information about a specified audio mixer devices 'line'.
 *
 *  @parm <c HMIXEROBJ> | hmxobj | Specifies a handle to the audio mixer
 *      device object to get line information from.
 *
 *  @parm LPMIXERLINE | pmxl | Points to a <t MIXERLINE> structure. This
 *      structure is filled with information about the mixer line for the
 *      audio mixer device. See the comments for each query flag passed
 *      through <p fdwInfo> for details on what members of the <t MIXERLINE>
 *      structure must be initialized before calling <f mixerGetLineInfo>.
 *      Note that in all cases, <e MIXERLINE.cbStruct> must be initialized
 *      to be the size, in bytes, of the <t MIXERLINE> structure.
 *
 *  @parm DWORD | fdwInfo | Specifies flags for getting information on a
 *      mixer line.
 *
 *      @flag <c MIXER_GETLINEINFOF_DESTINATION> | If this flag is specified,
 *      <p pmxl> is to receive information on the destination line
 *      specified by the <e MIXERLINE.dwDestination> member of the
 *      <t MIXERLINE> structure. This index ranges from zero to one less
 *      than <e MIXERCAPS.cDestinations> of the <t MIXERCAPS> structure.
 *      All remaining structure members except <e MIXERLINE.cbStruct> require
 *      no further initialization.
 *
 *      @flag <c MIXER_GETLINEINFOF_SOURCE> | If this flag is specified,
 *      <p pmxl> is to receive information on the source line specified by
 *      the <e MIXERLINE.dwDestination> and <e MIXERLINE.dwSource> members
 *      of the <t MIXERLINE> structure. The index specified by
 *      <e MIXERLINE.dwDestination> ranges from zero to one less than
 *      <e MIXERCAPS.cDestinations> of the <t MIXERCAPS> structure. The
 *      index specified by for <e MIXERLINE.dwSource> ranges from
 *      zero to one less than the <e MIXERLINE.cConnections> member of the
 *      <t MIXERLINE> structure returned for the <e MIXERLINE.dwDestination>
 *      line. All remaining structure members except <e MIXERLINE.cbStruct>
 *      require no further initialization.
 *
 *      @flag <c MIXER_GETLINEINFOF_LINEID> | If this flag is specified,
 *      <p pmxl> is to receive information on the line specified by the
 *      <e MIXERLINE.dwLineID> member of the <t MIXERLINE> structure. This
 *      is usually used to retrieve updated information on a line's state.
 *      All remaining structure members except <e MIXERLINE.cbStruct> require
 *      no further initialization.
 *
 *      @flag <c MIXER_GETLINEINFOF_COMPONENTTYPE> | If this flag is
 *      specified, <p pmxl> is to receive information on the first line of
 *      the type specified in the <e MIXERLINE.dwComponentType> member of the
 *      <t MIXERLINE> structure. This is used to retrieve information
 *      on a line that is of a specific component type (for example, an
 *      application could specify <c MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE>
 *      to retrieve information on the first Microphone input associated
 *      with the specified <p hmxobj>). All remaining structure members
 *      except <e MIXERLINE.cbStruct> require no further initialization.
 *
 *      @flag <c MIXER_GETLINEINFOF_TARGETTYPE> | If this flag is specified,
 *      <p pmxl> is to receive information on the line that is for the
 *      <e MIXERLINE.dwType> of the <t MIXERLINE> structure. This is
 *      used to retrieve information on a line that handles the target
 *      type (<c MIXERLINE_TARGETTYPE_WAVEOUT> for example). An application
 *      must initialize <e MIXERLINE.dwType>, <e MIXERLINE.wMid>,
 *      <e MIXERLINE.wPid>, <e MIXERLINE.vDriverVersion> and
 *      <e MIXERLINE.szPname> of the <t MIXERLINE> structure before
 *      calling <f mixerGetLineInfo>. All of these values can be retrieved
 *      from the device capabilities structures for all media devices. All
 *      remaining structure members except <e MIXERLINE.cbStruct> require
 *      no further initialization.
 *
 *      @flag <c MIXER_OBJECTF_MIXER> | Specifies that <p hmxobj> is an audio
 *      mixer device identifier in the range of zero to one less than the
 *      number of devices returned by <f mixerGetNumDevs>. This flag is
 *      optional.
 *
 *      @flag <c MIXER_OBJECTF_HMIXER> | Specifies that <p hmxobj> is a mixer
 *      device handle returned by <f mixerOpen>. This flag is optional.
 *
 *      @flag <c MIXER_OBJECTF_WAVEOUT> | Specifies that <p hmxobj> is a
 *      waveform output device identifier in the range of zero to one less
 *      than the number of devices returned by <f waveOutGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HWAVEOUT> | Specifies that <p hmxobj> is a
 *      waveform output handle returned by <f waveOutOpen>.
 *
 *      @flag <c MIXER_OBJECTF_WAVEIN> | Specifies that <p hmxobj> is a
 *      waveform input device identifier in the range of zero to one less
 *      than the number of devices returned by <f waveInGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HWAVEIN> | Specifies that <p hmxobj> is a
 *      waveform input handle returned by <f midiInOpen>.
 *
 *      @flag <c MIXER_OBJECTF_MIDIOUT> | Specifies that <p hmxobj> is a MIDI
 *      output device identifier in the range of zero to one less than the
 *      number of devices returned by <f midiOutGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HMIDIOUT> | Specifies that <p hmxobj> is a
 *      MIDI output handle returned by <f midiOutOpen>.
 *
 *      @flag <c MIXER_OBJECTF_MIDIIN> | Specifies that <p hmxobj> is a MIDI
 *      input device identifier in the range of zero to one less than the
 *      number of devices returned by <f midiInGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HMIDIIN> | Specifies that <p hmxobj> is a MIDI
 *      input handle returned by <f midiInOpen>.
 *
 *      @flag <c MIXER_OBJECTF_AUX> | Specifies that <p hmxobj> is an
 *      auxiliary device identifier in the range of zero to one less than the
 *      number of devices returned by <f auxGetNumDevs>.
 *
 *  @rdesc The return value is zero if the function is successful. Otherwise,
 *      it returns a non-zero error number. Possible error returns include
 *      the following:
 *
 *      @flag <c MMSYSERR_BADDEVICEID> | The <p hmxobj> argument specifies an
 *      invalid device identifier.
 *
 *      @flag <c MMSYSERR_INVALHANDLE> | The <p hmxobj> argument specifies an
 *      invalid handle.
 *
 *      @flag <c MMSYSERR_INVALFLAG> | One or more flags are invalid.
 *
 *      @flag <c MMSYSERR_INVALPARAM> | One or more arguments passed is
 *      invalid.
 *
 *      @flag <c MMSYSERR_NODRIVER> | No audio mixer device is available for
 *      the object specified by <p hmxobj>.
 *
 *      @flag <c MIXERR_INVALLINE> | The audio mixer device line reference is
 *      invalid.
 *
 *  @xref <t MIXERLINE>, <f mixerOpen>, <f mixerGetDevCaps>, <t MIXERCAPS>,
 *      <f mixerGetLineControls>
 *
 **/

MMRESULT APIENTRY mixerGetLineInfoA(
    HMIXEROBJ               hmxobj,
    LPMIXERLINEA            pmxlA,
    DWORD                   fdwInfo
)
{
    MIXERLINEW              mxlW;
    MMRESULT                mmr;

    //
    //  Validate the mixer line info pointer
    //

    V_WPOINTER(pmxlA, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (pmxlA->cbStruct < sizeof(MIXERLINEA)) {
        return MMSYSERR_INVALPARAM;
    }
    V_WPOINTER(pmxlA, pmxlA->cbStruct, MMSYSERR_INVALPARAM);

    //
    //  Call the UNICODE version to get the full set of data
    //

    CopyMemory((PVOID)&mxlW, (PVOID)pmxlA, FIELD_OFFSET(MIXERLINE, cChannels));
    mxlW.cbStruct = sizeof(mxlW);

    //
    //  If target stuff wanted we must set the target data
    //

    if ((fdwInfo & MIXER_GETLINEINFOF_QUERYMASK) ==
        MIXER_GETLINEINFOF_TARGETTYPE) {
        CopyMemory((PVOID)&mxlW.Target.dwType, (PVOID)&pmxlA->Target.dwType,
                   FIELD_OFFSET(MIXERLINE, Target.szPname[0]) -
                   FIELD_OFFSET(MIXERLINE, Target.dwType));

        Imbstowcs(mxlW.Target.szPname, pmxlA->Target.szPname, MAXPNAMELEN);
    }

    //
    //  Set the relevant values
    //

    mmr = mixerGetLineInfo(hmxobj, &mxlW, fdwInfo);

    if (mmr != MMSYSERR_NOERROR) {
        return mmr;
    }

    //
    //  Massage the return data to ASCII
    //

    ConvertMIXERLINEWToMIXERLINEA(pmxlA, &mxlW);

    return mmr;
} // mixerGetLineInfoA()

MMRESULT APIENTRY mixerGetLineInfo(
    HMIXEROBJ               hmxobj,
    LPMIXERLINE             pmxl,
    DWORD                   fdwInfo
)
{
    DWORD               fdwMxObjType;
    MMRESULT            mmr;
    PMIXERDEV           pmxdev;
//  UINT                cb;
    UINT                uMxId;
    BOOL                fSourceLine, fResource;

    V_DFLAGS(fdwInfo, MIXER_GETLINEINFOF_VALID, mixerGetLineInfo, MMSYSERR_INVALFLAG);
    V_WPOINTER(pmxl, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(MIXERLINE) > pmxl->cbStruct)
    {
        DebugErr1(DBF_ERROR, "mixerGetLineInfo: structure size too small or cbStruct not initialized (%lu).", pmxl->cbStruct);
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pmxl, pmxl->cbStruct, MMSYSERR_INVALPARAM);


    ClientUpdatePnpInfo();

    //
    //
    //
    fSourceLine = FALSE;
    switch (fdwInfo & MIXER_GETLINEINFOF_QUERYMASK)
    {
        case MIXER_GETLINEINFOF_DESTINATION:
            pmxl->dwSource        = (DWORD)-1L;
            pmxl->dwLineID        = (DWORD)-1L;
            pmxl->dwComponentType = (DWORD)-1L;
            break;

        case MIXER_GETLINEINFOF_SOURCE:
            fSourceLine = TRUE;
            pmxl->dwLineID        = (DWORD)-1L;
            pmxl->dwComponentType = (DWORD)-1L;
            break;

        case MIXER_GETLINEINFOF_LINEID:
            pmxl->dwSource        = (DWORD)-1L;
            pmxl->dwDestination   = (DWORD)-1L;
            pmxl->dwComponentType = (DWORD)-1L;
            break;

        case MIXER_GETLINEINFOF_COMPONENTTYPE:
            pmxl->dwSource        = (DWORD)-1L;
            pmxl->dwDestination   = (DWORD)-1L;
            pmxl->dwLineID        = (DWORD)-1L;

            if (!IMixerIsValidComponentType(pmxl->dwComponentType, 0) &&
                !IMixerIsValidComponentType(pmxl->dwComponentType, MIXERLINE_LINEF_SOURCE))
            {
                DebugErr1(DBF_ERROR, "mixerGetLineInfo: invalid dwComponentType (%lu).", pmxl->dwComponentType);
                return (MMSYSERR_INVALPARAM);
            }
            break;

        case MIXER_GETLINEINFOF_TARGETTYPE:
            pmxl->dwSource        = (DWORD)-1L;
            pmxl->dwDestination   = (DWORD)-1L;
            pmxl->dwLineID        = (DWORD)-1L;
            pmxl->dwComponentType = (DWORD)-1L;

            if (MIXERLINE_TARGETTYPE_AUX < pmxl->Target.dwType)
            {
                DebugErr1(DBF_ERROR, "mixerGetLineInfo: invalid Target.dwType (%lu).", pmxl->Target.dwType);
                return (MMSYSERR_INVALPARAM);
            }
            break;

        default:
            DebugErr1(DBF_ERROR, "mixerGetLineInfo: invalid query flag (%.08lXh).",
                        fdwInfo & MIXER_GETLINEINFOF_QUERYMASK);
            return (MMSYSERR_INVALFLAG);
    }



    //
    //
    //
    fdwMxObjType = (MIXER_OBJECTF_TYPEMASK & fdwInfo);

    fResource = FALSE;

    AcquireHandleListResourceShared();
    
    //  Checking for the type of mixer object.  If it is a non-mixer type
    //  calling IMixerMesssageID (called by IMixerGetID) with the shared
    //  resource will deadlock.
    if ((MIXER_OBJECTF_MIXER  == fdwMxObjType) ||
        (MIXER_OBJECTF_HMIXER == fdwMxObjType))
    {
        if (BAD_HANDLE(hmxobj, TYPE_MIXER))
        {
            ReleaseHandleListResource();
        }
        else
        {
            fResource = TRUE;
        }
    }
    else
    {
        ReleaseHandleListResource();
    }
    
    mmr = IMixerGetID(hmxobj, &uMxId, pmxl, fdwMxObjType);
    if (MMSYSERR_NOERROR != mmr)
    {
        dprintf(( "!IMixerGetLineInfo: IMixerGetID() failed!" ));
        if (fResource)
            ReleaseHandleListResource();
        return (mmr);
    }

    if ((MIXER_OBJECTF_MIXER  == fdwMxObjType) ||
        (MIXER_OBJECTF_HMIXER == fdwMxObjType))
    {
        //
        //  if a mixer device id was passed, then null hmx so we use the
        //  correct message sender below
        //
        if ((UINT_PTR)hmxobj == uMxId)
            hmxobj = NULL;
    }
    else
    {
        return (MMSYSERR_NOERROR);
    }


    //
    //  clear all fields before calling driver
    //
    if (NULL != hmxobj)
    {
        //
        //
        //
        pmxdev = (PMIXERDEV)hmxobj;
#if 0
        if (pmxdev->cDestinations <= pmxl->dwDestination)
        {
            ReleaseHandleListResource();
            DebugErr1(DBF_ERROR, "mixerGetLineInfo: invalid destination index (%lu).", pmxl->dwDestination);
            return (MMSYSERR_INVALPARAM);
        }
#endif

        mmr = (MMRESULT)IMixerMessageHandle((HMIXER)hmxobj,
                                            MXDM_GETLINEINFO,
                                            (DWORD_PTR)(LPVOID)pmxl,
                                            fdwInfo);
    }
    else
    {
#pragma message("----IMixerGetLineInfo: dwDestination not validated for ID's!!")
        mmr = (MMRESULT)IMixerMessageId(uMxId,
                                        MXDM_GETLINEINFO,
                                        (DWORD_PTR)(LPVOID)pmxl,
                                        fdwInfo);
    }

    if (MMSYSERR_NOERROR != mmr)
        return (mmr);

#pragma message("----IMixerGetLineInfo: should validate mixer driver didn't hose us!")


    //
    //  validate the driver's returned stuff...
    //
    //
    if (sizeof(MIXERLINE) != pmxl->cbStruct)
    {
        DebugErr1(DBF_ERROR, "mixerGetLineInfo: buggy driver returned invalid cbStruct (%lu).", pmxl->cbStruct);
        pmxl->cbStruct = sizeof(MIXERLINE);
    }

    if ((DWORD)-1L == pmxl->dwDestination)
    {
        DebugErr(DBF_ERROR, "mixerGetLineInfo: buggy driver failed to init dwDestination member.");
    }
    if (fSourceLine)
    {
        if (0 == (MIXERLINE_LINEF_SOURCE & pmxl->fdwLine))
        {
            DebugErr(DBF_ERROR, "mixerGetLineInfo: buggy driver failed to set MIXERLINE_LINEF_SOURCE.");
            pmxl->fdwLine |= MIXERLINE_LINEF_SOURCE;
        }

        if ((DWORD)-1L == pmxl->dwSource)
        {
            DebugErr(DBF_ERROR, "mixerGetLineInfo: buggy driver failed to init dwSource member.");
        }
    }
    if ((DWORD)-1L == pmxl->dwLineID)
    {
        DebugErr(DBF_ERROR, "mixerGetLineInfo: buggy driver failed to init dwLineID member.");
    }
    if (pmxl->fdwLine & ~0x80008001L)
    {
        DebugErr1(DBF_ERROR, "mixerGetLineInfo: buggy driver set reserved line flags (%.08lXh)!", pmxl->fdwLine);
        pmxl->fdwLine &= 0x80008001L;
    }
    if (!IMixerIsValidComponentType(pmxl->dwComponentType, pmxl->fdwLine))
    {
        DebugErr1(DBF_ERROR, "mixerGetLineInfo: buggy driver returned invalid dwComponentType (%.08lXh).", pmxl->dwComponentType);
        pmxl->dwComponentType = MIXERLINE_TARGETTYPE_UNDEFINED;
    }
    if (0 == pmxl->cChannels)
    {
        DebugErr(DBF_ERROR, "mixerGetLineInfo: buggy driver returned zero channels?!?");
        pmxl->cChannels = 1;
    }
    if (fSourceLine)
    {
        if (0 != pmxl->cConnections)
        {
            DebugErr(DBF_ERROR, "mixerGetLineInfo: buggy driver returned non-zero connections on source?!?");
            pmxl->cConnections = 0;
        }
    }

    pmxl->szShortName[SIZEOF(pmxl->szShortName) - 1] = '\0';
    pmxl->szName[SIZEOF(pmxl->szName) - 1] = '\0';


    //
    // Does this really need to be done if TARGETTYPE was requested?
    //


    //
    //
    //
    if (MIXERLINE_TARGETTYPE_UNDEFINED != pmxl->Target.dwType)
    {
        UINT        u;

        pmxl->Target.dwDeviceID = (DWORD)-1L;


        //
        //  we have a wMid, wPid and szPname (supposedly) of type dwType
        //  so let's go find it...
        //
        switch (pmxl->Target.dwType)
        {
            case MIXERLINE_TARGETTYPE_WAVEOUT:
                u = waveOutGetNumDevs();
                while (u--)
                {
                    WAVEOUTCAPS     woc;

                    mmr = waveOutGetDevCaps(u, &woc, sizeof(woc));
                    if (MMSYSERR_NOERROR != mmr)
                        continue;

                    woc.szPname[SIZEOF(woc.szPname) - 1] = '\0';

                    if (woc.wMid != pmxl->Target.wMid)
                        continue;

                    if (woc.wPid != pmxl->Target.wPid)
                        continue;

                    if (woc.vDriverVersion != pmxl->Target.vDriverVersion)
                        continue;

                    if (lstrcmp(woc.szPname, pmxl->Target.szPname))
                        continue;

                    pmxl->Target.dwDeviceID = u;
                    break;
                }
                break;

            case MIXERLINE_TARGETTYPE_WAVEIN:
                u = waveInGetNumDevs();
                while (u--)
                {
                    WAVEINCAPS      wic;

                    mmr = waveInGetDevCaps(u, &wic, sizeof(wic));
                    if (MMSYSERR_NOERROR != mmr)
                        continue;

                    wic.szPname[SIZEOF(wic.szPname) - 1] = '\0';

                    if (wic.wMid != pmxl->Target.wMid)
                        continue;

                    if (wic.wPid != pmxl->Target.wPid)
                        continue;

                    if (wic.vDriverVersion != pmxl->Target.vDriverVersion)
                        continue;

                    if (lstrcmp(wic.szPname, pmxl->Target.szPname))
                        continue;

                    pmxl->Target.dwDeviceID = u;
                    break;
                }
                break;

            case MIXERLINE_TARGETTYPE_MIDIOUT:
                u = midiOutGetNumDevs();
                while (u--)
                {
                    MIDIOUTCAPS     moc;

                    mmr = midiOutGetDevCaps(u, &moc, sizeof(moc));
                    if (MMSYSERR_NOERROR != mmr)
                        continue;

                    moc.szPname[SIZEOF(moc.szPname) - 1] = '\0';

                    if (moc.wMid != pmxl->Target.wMid)
                        continue;

                    if (moc.wPid != pmxl->Target.wPid)
                        continue;

                    if (moc.vDriverVersion != pmxl->Target.vDriverVersion)
                        continue;

                    if (lstrcmp(moc.szPname, pmxl->Target.szPname))
                        continue;

                    pmxl->Target.dwDeviceID = u;
                    break;
                }
                break;

            case MIXERLINE_TARGETTYPE_MIDIIN:
                u = midiInGetNumDevs();
                while (u--)
                {
                    MIDIINCAPS      mic;

                    mmr = midiInGetDevCaps(u, &mic, sizeof(mic));
                    if (MMSYSERR_NOERROR != mmr)
                        continue;

                    mic.szPname[SIZEOF(mic.szPname) - 1] = '\0';

                    if (mic.wMid != pmxl->Target.wMid)
                        continue;

                    if (mic.wPid != pmxl->Target.wPid)
                        continue;

                    if (mic.vDriverVersion != pmxl->Target.vDriverVersion)
                        continue;

                    if (lstrcmp(mic.szPname, pmxl->Target.szPname))
                        continue;

                    pmxl->Target.dwDeviceID = u;
                    break;
                }
                break;

            case MIXERLINE_TARGETTYPE_AUX:
                u = auxGetNumDevs();
                while (u--)
                {
                    AUXCAPS     ac;

                    mmr = auxGetDevCaps(u, &ac, sizeof(ac));
                    if (MMSYSERR_NOERROR != mmr)
                        continue;

                    ac.szPname[SIZEOF(ac.szPname) - 1] = '\0';

                    if (ac.wMid != pmxl->Target.wMid)
                        continue;

                    if (ac.wPid != pmxl->Target.wPid)
                        continue;

                    if (ac.vDriverVersion != pmxl->Target.vDriverVersion)
                        continue;

                    if (lstrcmp(ac.szPname, pmxl->Target.szPname))
                        continue;

                    pmxl->Target.dwDeviceID = u;
                    break;
                }
                break;

            default:
                pmxl->Target.dwType = MIXERLINE_TARGETTYPE_UNDEFINED;
                break;
        }
    }


    return (mmr);

} // mixerGetLineInfo()


//
//  Abstract converting the complex mixerline structure
//
void ConvertMIXERLINEWToMIXERLINEA(
    PMIXERLINEA         pmxlA,
    PMIXERLINEW         pmxlW
)
{
    //
    //  Don't copy cbStruct
    //

    CopyMemory((PVOID)((PBYTE)pmxlA + sizeof(DWORD)),
               (PVOID)((PBYTE)pmxlW + sizeof(DWORD)),
               FIELD_OFFSET(MIXERLINEA, szShortName[0]) - sizeof(DWORD));

    Iwcstombs(pmxlA->szShortName, pmxlW->szShortName,
             sizeof(pmxlA->szShortName));
    Iwcstombs(pmxlA->szName, pmxlW->szName,
             sizeof(pmxlA->szName));

    CopyMemory((PVOID)&pmxlA->Target, (PVOID)&pmxlW->Target,
               FIELD_OFFSET(MIXERLINEA, Target.szPname[0]) -
               FIELD_OFFSET(MIXERLINEA, Target.dwType));

    Iwcstombs(pmxlA->Target.szPname, pmxlW->Target.szPname,
             sizeof(pmxlA->Target.szPname));
}


/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK STRUCTURE
 *
 *  @types MIXERCONTROL | The <t MIXERCONTROL> structure describes the state
 *      and metrics of a single control for an audio mixer line.
 *
 *  @syntaxex
 *      typedef struct tMIXERCONTROL
 *      {
 *          DWORD           cbStruct;
 *          DWORD           dwControlID;
 *          DWORD           dwControlType;
 *          DWORD           fdwControl;
 *          DWORD           cMultipleItems;
 *          char            szShortName[MIXER_SHORT_NAME_CHARS];
 *          char            szName[MIXER_LONG_NAME_CHARS];
 *          union
 *          {
 *              struct
 *              {
 *                  LONG    lMinimum;
 *                  LONG    lMaximum;
 *              };
 *              struct
 *              {
 *                  DWORD   dwMinimum;
 *                  DWORD   dwMaximum;
 *              };
 *              DWORD       dwReserved[6];
 *          } Bounds;
 *          union
 *          {
 *              DWORD       cSteps;
 *              DWORD       cbCustomData;
 *              DWORD       dwReserved[6];
 *          } Metrics;
 *      } MIXERCONTROL;
 *
 *  @field DWORD | cbStruct | Specifies the size, in bytes, of the
 *      <t MIXERCONTROL> structure. Since the <t MIXERCONTROL> structure
 *      is only passed as a receiving buffer referenced and described by
 *      the <t MIXERLINECONTROLS> structure passed to the
 *      <f mixerGetLineControls> function, it is not necessary for the
 *      calling application to initialize this member (or any other members
 *      of this structure). When the <f mixerGetLineControls> function
 *      returns, this member contains the actual size of the information
 *      returned by the mixer device. The returned information will never
 *      exceed the requested size and will never be smaller than the
 *      base <t MIXERCONTROL> structure.
 *
 *  @field DWORD | dwControlID | Specifies an audio mixer defined identifier
 *      that uniquely refers to the control described by the <t MIXERCONTROL>
 *      structure. This identifier is unique only to a single mixer device
 *      and may be of any format that the mixer device wishes. An application
 *      should only use this identifier as an abstract handle. No two
 *      controls for a single mixer device will have the same control
 *      identifier under any circumstances.
 *
 *  @field DWORD | dwControlType | Specifies the control type for this
 *      control. An application must use this information to display the
 *      appropriate control for input from the user. An application may
 *      also wish to display tailored graphics based on the control type or
 *      search for a particular control type on a specific line. If an
 *      application does not know about a control type, then this control
 *      must be ignored. There are currently seven different control type
 *      classifications.
 *
 *      The control type class <cl MIXERCONTROL_CT_CLASS_CUSTOM> consists of
 *      the following standard control types.
 *
 *      <c MIXERCONTROL_CONTROLTYPE_CUSTOM><nl>
 *
 *      The control type class <cl MIXERCONTROL_CT_CLASS_METER> consists of
 *      the following standard control types.
 *
 *      <c MIXERCONTROL_CONTROLTYPE_BOOLEANMETER><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_SIGNEDMETER><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_PEAKMETER><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_UNSIGNEDMETER><nl>
 *
 *      The control type class <cl MIXERCONTROL_CT_CLASS_SWITCH> consists of
 *      the following standard control types.
 *
 *      <c MIXERCONTROL_CONTROLTYPE_BUTTON><nl>
 *
 *      <c MIXERCONTROL_CONTROLTYPE_BOOLEAN><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_ONOFF><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MUTE><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MONO><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_LOUDNESS><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_STEREOENH><nl>
 *
 *      The control type class <cl MIXERCONTROL_CT_CLASS_NUMBER> consists of
 *      the following standard control types.
 *
 *      <c MIXERCONTROL_CONTROLTYPE_SIGNED><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_DECIBELS><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_UNSIGNED><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_PERCENT><nl>
 *
 *      The control type class <cl MIXERCONTROL_CT_CLASS_SLIDER> consists of
 *      the following standard control types.
 *
 *      <c MIXERCONTROL_CONTROLTYPE_SLIDER><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_PAN><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_QSOUNDPAN><nl>
 *
 *      The control type class <cl MIXERCONTROL_CT_CLASS_FADER> consists of
 *      the following standard control types.
 *
 *      <c MIXERCONTROL_CONTROLTYPE_FADER><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_VOLUME><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_BASS><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_TREBLE><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_EQUALIZER><nl>
 *
 *      The control type class <cl MIXERCONTROL_CT_CLASS_TIME> consists of
 *      the following standard control types.
 *
 *      <c MIXERCONTROL_CONTROLTYPE_MICROTIME><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MILLITIME><nl>
 *
 *      The control type class <cl MIXERCONTROL_CT_CLASS_LIST> consists of
 *      the following standard control types.
 *
 *      <c MIXERCONTROL_CONTROLTYPE_SINGLESELECT><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MUX><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MIXER><nl>
 *
 *  @field DWORD | fdwControl | Specifies status and support flags for the
 *      audio mixer line control.
 *
 *      @flag <c MIXERCONTROL_CONTROLF_UNIFORM> | Specifies that the control
 *      acts on all channels of a multi-channel line in a uniform fashion.
 *      For example, a Mute control that mutes both channels of a stereo
 *      line would set this flag. Most MUX and Mixer controls will also
 *      specify the <c MIXERCONTROL_CONTROLF_UNIFORM> flag.
 *
 *      @flag <c MIXERCONTROL_CONTROLF_MULTIPLE> | Specifies that the control
 *      has two or more settings per channel. An example of a control
 *      that requires the multiple flag is an equalizer--each frequency
 *      band can be set to different values. Note that an equalizer that
 *      affects both channels of a stereo line in a uniform fashion will
 *      also set the <c MIXERCONTROL_CONTROLF_UNIFORM> flag.
 *
 *      @flag <c MIXERCONTROL_CONTROLF_DISABLED> | Specifies that the control
 *      is disabled (perhaps due to other settings for the mixer hardware)
 *      and cannot be used. An application can read current settings from
 *      a disabled control, but cannot apply settings.
 *
 *  @field DWORD | cMultipleItems | Specifies the number of items per
 *      channel that a <c MIXERCONTROL_CONTROLF_MULTIPLE> control contains.
 *      This number will always be two or greater for multiple item
 *      controls. If the control is not a multiple item control, this
 *      member will be zero and should be ignored.
 *
 *  @field char | szShortName[<c MIXER_SHORT_NAME_CHARS>] | Specifies a short
 *      string that describes the <e MIXERCONTROL.dwControlID> audio mixer
 *      line control. This description is appropriate for using as a
 *      displayable label for the control that can fit in small spaces.
 *
 *  @field char | szName[<c MIXER_LONG_NAME_CHARS>] | Specifies a string
 *      that describes the <e MIXERCONTROL.dwControlID> audio mixer line
 *      control. This description is appropriate for using as a displayable
 *      description for the control that is not limited by screen space.
 *
 *  @field union | Bounds | Contains the union of boundary types.
 *
 *  @field2 DWORD | dwMinimum | Specifies the minimum unsigned value
 *      for a control that has an unsigned boundary nature. Refer to the
 *      description for each control type to determine if this member is
 *      appropriate for the control. This member overlaps with the
 *      <e MIXERCONTROL.lMinimum> member and cannot be used in
 *      conjunction with that member.
 *
 *  @field2 DWORD | dwMaximum | Specifies the maximum unsigned value
 *      for a control that has an unsigned boundary nature. Refer to the
 *      description for each control type to determine if this member is
 *      appropriate for the control. This member overlaps with the
 *      <e MIXERCONTROL.lMaximum> member and cannot be used in
 *      conjunction with that member.
 *
 *  @field2 DWORD | lMinimum | Specifies the minimum signed value
 *      for a control that has a signed boundary nature. Refer to the
 *      description for each control type to determine if this member is
 *      appropriate for the control. This member overlaps with the
 *      <e MIXERCONTROL.dwMinimum> member and cannot be used in
 *      conjunction with that member.
 *
 *  @field2 DWORD | lMaximum | Specifies the maximum signed value
 *      for a control that has a signed boundary nature. Refer to the
 *      description for each control type to determine if this member is
 *      appropriate for the control. This member overlaps with the
 *      <e MIXERCONTROL.dwMaximum> member and cannot be used in
 *      conjunction with that member.
 *
 *  @field union | Metrics | Contains the union of boundary metrics.
 *
 *  @field2 DWORD | cSteps | Specifies the number of discrete
 *      ranges within the specified <e MIXERCONTROL.Bounds> for a control.
 *      Refer to the description for each control type to determine if this
 *      member is appropriate for the control. This member overlaps with the
 *      other members of the <e MIXERCONTROL.Metrics> structure member and
 *      cannot be used in conjunction with those members.
 *
 *  @field2 DWORD | cbCustomData | Specifies the size, in bytes,
 *      required to hold the state of a custom control type. This member
 *      is only appropriate for the <c MIXERCONTROL_CONTROLTYPE_CUSTOM>
 *      control type. See the description for custom control types for more
 *      information on the use of this member.
 *
 *  @tagname tMIXERCONTROL
 *
 *  @othertype MIXERCONTROL FAR * | LPMIXERCONTROL | A pointer to a
 *      <t MIXERCONTROL> structure.
 *
 *  @othertype MIXERCONTROL * | PMIXERCONTROL | A pointer to a
 *      <t MIXERCONTROL> structure.
 *
 *  @xref <t MIXERLINECONTROLS>, <f mixerGetLineControls>, <f mixerGetLineInfo>,
 *      <f mixerGetControlDetails>, <f mixerSetControlDetails>,
 *      <t MIXERCONTROLDETAILS>
 *
 **/

/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK STRUCTURE
 *
 *  @types MIXERLINECONTROLS | The <t MIXERLINECONTROLS> structure references
 *      what controls to retrieve information on from an audio mixer line.
 *
 *  @field DWORD | cbStruct | Specifies the size, in bytes, of the
 *      <t MIXERLINECONTROLS> structure. This member must be initialized
 *      before calling the <f mixerGetLineControls> function. The size
 *      specified in this member must be large enough to contain the base
 *      <t MIXERLINECONTROLS> structure. When the <f mixerGetLineControls>
 *      function returns, this member contains the actual size of the
 *      information returned. The returned information will never exceed
 *      the requested size and will never be smaller than the base
 *      <t MIXERLINECONTROLS> structure.
 *
 *  @field DWORD | dwLineID | Specifies the line identifier to retrieve
 *      one or all controls for. This member is not used if the
 *      <c MIXER_GETLINECONTROLSF_ONEBYID> flag is specified for the
 *      <f mixerGetLineControls> function--but the mixer device will return
 *      this member in this case. The <e MIXERLINECONTROLS.dwControlID>
 *      and <e MIXERLINECONTROLS.dwControlType> members are not used when
 *      <c MIXER_GETLINECONTROLSF_ALL> is specified.
 *
 *  @field DWORD | dwControlID | Specifies the control identifier of the
 *      control desired. This member is used with the
 *      <c MIXER_GETLINECONTROLSF_ONEBYID> flag for <f mixerGetLineControls>
 *      to retrieve the control information of the specified control.
 *      Note that the <e MIXERLINECONTROLS.dwLineID> member of the
 *      <t MIXERLINECONTROLS> structure will be returned by the mixer device
 *      and is not required as an input parameter. This member overlaps with
 *      the <e MIXERLINECONTROLS.dwControlType> member and cannot be used in
 *      conjunction with the <c MIXER_GETLINECONTROLSF_ONEBYTYPE> query type.
 *
 *  @field DWORD | dwControlType | Specifies the control type of the
 *      control desired. This member is used with the
 *      <c MIXER_GETLINECONTROLSF_ONEBYTYPE> flag for <f mixerGetLineControls>
 *      to retrieve the first control of the specified type on the line
 *      specified by the <e MIXERLINECONTROLS.dwLineID> member of the
 *      <t MIXERLINECONTROLS> structure. This member overlaps with the
 *      <e MIXERLINECONTROLS.dwControlID> member and cannot be used in
 *      conjunction with the <c MIXER_GETLINECONTROLSF_ONEBYID> query type.
 *
 *  @field DWORD | cControls | Specifies the number of <t MIXERCONTROL>
 *      structure elements to retrieve. This member must be initialized by
 *      the application before calling the <f mixerGetLineControls> function.
 *      This member may only be one (if <c MIXER_GETLINECONTROLSF_ONEBYID> or
 *      <c MIXER_GETLINECONTROLSF_ONEBYTYPE> is specified) or the value
 *      returned in the <e MIXERLINE.cControls> member of the <t MIXERLINE>
 *      structure returned for a line. This member cannot be zero. If a
 *      line specifies that it has no controls, then <f mixerGetLineControls>
 *      should not be called.
 *
 *  @field DWORD | cbmxctrl | Specifies the size, in bytes, of a single
 *      <t MIXERCONTROL> structure. This must be at least large enough
 *      to hold the base <t MIXERCONTROL> structure. The total size, in
 *      bytes, required for the buffer pointed to by <e MIXERLINECONTROLS.pamxctrl>
 *      member is the product of the <e MIXERLINECONTROLS.cbmxctrl> and
 *      <e MIXERLINECONTROLS.cControls> members of the <t MIXERLINECONTROLS>
 *      structure.
 *
 *  @field LPMIXERCONTROL | pamxctrl | Points to one or more <t MIXERCONTROL>
 *      structures to receive the details on the requested audio mixer line
 *      controls. This member may never be NULL and must be initialized before
 *      calling the <f mixerGetLineControls> function. Each element of the
 *      array of controls must be at least large enough to hold a base
 *      <t MIXERCONTROL> structure. The <e MIXERLINECONTROLS.cbmxctrl> member
 *      must specify the size, in bytes, of each element in this array. No
 *      initialization of the buffer pointed to by this member needs to be
 *      initialized by the application. All members will be filled in by
 *      the mixer device (including the <e MIXERCONTROL.cbStruct> member
 *      of each <t MIXERCONTROL> structure) upon returning successfully to
 *      the application.
 *
 *  @tagname tMIXERLINECONTROLS
 *
 *  @othertype MIXERLINECONTROLS FAR * | LPMIXERLINECONTROLS | A pointer to a
 *      <t MIXERLINECONTROLS> structure.
 *
 *  @othertype MIXERLINECONTROLS * | PMIXERLINECONTROLS | A pointer to a
 *      <t MIXERLINECONTROLS> structure.
 *
 *  @xref <t MIXERCONTROL>, <f mixerGetLineControls>, <f mixerGetLineInfo>,
 *      <f mixerGetControlDetails>, <f mixerSetControlDetails>
 *
 **/

/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK API
 *
 *  @api MMRESULT | mixerGetLineControls | The <f mixerGetLineControls>
 *      function is used to retrieve one or more controls associated with
 *      an audio mixer device line.
 *
 *  @parm <c HMIXEROBJ> | hmxobj | Specifies a handle to the audio mixer
 *      device object to get line control information from.
 *
 *  @parm LPMIXERLINECONTROLS | pmxlc | Points to a <t MIXERLINECONTROLS>
 *      structure. This structure is used to reference one or more
 *      <t MIXERCONTROL> structures to be filled with information about the
 *      controls associated with a mixer line.
 *      See the comments for each query flag passed through <p fdwControls>
 *      for details on what members of the <t MIXERLINECONTROLS> structure
 *      that must be initialized. Note that in all cases, the
 *      <e MIXERLINECONTROLS.cbStruct> member of the <t MIXERLINECONTROLS>
 *      structure must be initialized to be the size, in bytes, of the
 *      <t MIXERLINECONTROLS> structure.
 *
 *  @parm DWORD | fdwControls | Specifies flags for getting information on
 *      one or more control associated with a mixer line.
 *
 *      @flag <c MIXER_GETLINECONTROLSF_ALL> | If this flag is specified,
 *      <p pmxlc> references a list of <t MIXERCONTROL> structures that
 *      will receive information on all controls associated with the
 *      line identified by the <e MIXERLINECONTROLS.dwLineID> member of
 *      the <t MIXERLINECONTROLS> structure. <e MIXERLINECONTROLS.cControls>
 *      must be initialized to the number of controls associated with the
 *      line. This number is retrieved from the <e MIXERLINE.cControls>
 *      member of the <t MIXERLINE> structure returned by the
 *      <f mixerGetLineInfo> function. <e MIXERLINECONTROLS.cbmxctrl> must
 *      be initialized to the size, in bytes, of a single <t MIXERCONTROL>
 *      structure. <e MIXERLINECONTROLS.pamxctrl> must point to
 *      the first <t MIXERCONTROL> structure to be filled in. Both the
 *      <e MIXERLINECONTROLS.dwControlID> and <e MIXERLINECONTROLS.dwControlType>
 *      members are ignored for this query.
 *
 *      @flag <c MIXER_GETLINECONTROLSF_ONEBYID> | If this flag is specified,
 *      <p pmxlc> references a single <t MIXERCONTROL> structure that
 *      will receive information on the control identified by the
 *      <e MIXERLINECONTROLS.dwControlID> member of the <t MIXERLINECONTROLS>
 *      structure. <e MIXERLINECONTROLS.cControls> must be initialized to one.
 *      <e MIXERLINECONTROLS.cbmxctrl> must be initialized to the size, in
 *      bytes, of a single <t MIXERCONTROL> structure.
 *      <e MIXERLINECONTROLS.pamxctrl> must point to a <t MIXERCONTROL>
 *      structure to be filled in. Both the <e MIXERLINECONTROLS.dwLineID>
 *      and <e MIXERLINECONTROLS.dwControlType> members are ignored for this
 *      query. This query is usually used to refresh a control after
 *      receiving a <m MM_MIXM_CONTROL_CHANGE> control change notification
 *      message by the user-specified callback (see <f mixerOpen>).
 *
 *      @flag <c MIXER_GETLINECONTROLSF_ONEBYTYPE> | If this flag is specified,
 *      <p pmxlc> references a single <t MIXERCONTROL> structure that
 *      will receive information on the fist control associated with the
 *      line identified by <e MIXERLINECONTROLS.dwLineID> of the type
 *      specified in the <e MIXERLINECONTROLS.dwControlType> member of the
 *      <t MIXERLINECONTROLS> structure.
 *       <e MIXERLINECONTROLS.cControls> must be
 *      initialized to one. <e MIXERLINECONTROLS.cbmxctrl> must be initialized
 *      to the size, in bytes, of a single <t MIXERCONTROL> structure.
 *      <e MIXERLINECONTROLS.pamxctrl> must point to a <t MIXERCONTROL>
 *      structure to be filled in. The <e MIXERLINECONTROLS.dwControlID>
 *      member is ignored for this query. This query can be used by an
 *      application to get information on single control associated with
 *      a line. For example, an application may only want to use a peak
 *      meter from a waveform output line.
 *
 *      @flag <c MIXER_OBJECTF_MIXER> | Specifies that <p hmxobj> is an audio
 *      mixer device identifier in the range of zero to one less than the
 *      number of devices returned by <f mixerGetNumDevs>. This flag is
 *      optional.
 *
 *      @flag <c MIXER_OBJECTF_HMIXER> | Specifies that <p hmxobj> is a mixer
 *      device handle returned by <f mixerOpen>. This flag is optional.
 *
 *      @flag <c MIXER_OBJECTF_WAVEOUT> | Specifies that <p hmxobj> is a
 *      waveform output device identifier in the range of zero to one less
 *      than the number of devices returned by <f waveOutGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HWAVEOUT> | Specifies that <p hmxobj> is a
 *      waveform output handle returned by <f waveOutOpen>.
 *
 *      @flag <c MIXER_OBJECTF_WAVEIN> | Specifies that <p hmxobj> is a
 *      waveform input device identifier in the range of zero to one less
 *      than the number of devices returned by <f waveInGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HWAVEIN> | Specifies that <p hmxobj> is a
 *      waveform input handle returned by <f midiInOpen>.
 *
 *      @flag <c MIXER_OBJECTF_MIDIOUT> | Specifies that <p hmxobj> is a MIDI
 *      output device identifier in the range of zero to one less than the
 *      number of devices returned by <f midiOutGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HMIDIOUT> | Specifies that <p hmxobj> is a
 *      MIDI output handle returned by <f midiOutOpen>.
 *
 *      @flag <c MIXER_OBJECTF_MIDIIN> | Specifies that <p hmxobj> is a MIDI
 *      input device identifier in the range of zero to one less than the
 *      number of devices returned by <f midiInGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HMIDIIN> | Specifies that <p hmxobj> is a MIDI
 *      input handle returned by <f midiInOpen>.
 *
 *      @flag <c MIXER_OBJECTF_AUX> | Specifies that <p hmxobj> is an
 *      auxiliary device identifier in the range of zero to one less than the
 *      number of devices returned by <f auxGetNumDevs>.
 *
 *  @rdesc The return value is zero if the function is successful. Otherwise,
 *      it returns a non-zero error number. Possible error returns include
 *      the following:
 *
 *      @flag <c MMSYSERR_BADDEVICEID> | The <p hmxobj> argument specifies an
 *      invalid device identifier.
 *
 *      @flag <c MMSYSERR_INVALHANDLE> | The <p hmxobj> argument specifies an
 *      invalid handle.
 *
 *      @flag <c MMSYSERR_INVALFLAG> | One or more flags are invalid.
 *
 *      @flag <c MMSYSERR_INVALPARAM> | One or more arguments passed is
 *      invalid.
 *
 *      @flag <c MMSYSERR_NODRIVER> | No audio mixer device is available for
 *      the object specified by <p hmxobj>.
 *
 *      @flag <c MIXERR_INVALLINE> | The audio mixer device line reference is
 *      invalid.
 *
 *      @flag <c MIXERR_INVALCONTROL> | The control reference is invalid.
 *
 *  @xref <t MIXERLINECONTROLS>, <t MIXERCONTROL>, <f mixerGetLineInfo>,
 *      <f mixerOpen>, <f mixerGetControlDetails>, <f mixerSetControlDetails>
 *
 **/

MMRESULT APIENTRY mixerGetLineControlsA(
    HMIXEROBJ               hmxobj,
    LPMIXERLINECONTROLSA    pmxlcA,
    DWORD                   fdwControls
)
{
    MIXERLINECONTROLSW      mxlcW;
    MMRESULT                mmr;
    DWORD                   cControls;

    V_WPOINTER(pmxlcA, sizeof(DWORD), MMSYSERR_INVALPARAM);
    V_WPOINTER(pmxlcA, (UINT)pmxlcA->cbStruct, MMSYSERR_INVALPARAM);
    if (sizeof(MIXERLINECONTROLSA) > pmxlcA->cbStruct) {
        DebugErr1(DBF_ERROR, "mixerGetLineControls: structure size too small or cbStruct not initialized (%lu).", pmxlcA->cbStruct);
        return (MMSYSERR_INVALPARAM);
    }

    //
    //  Set up a MIXERCONTROLW structure and allocate space for the
    //  returned data
    //

    CopyMemory((PVOID)&mxlcW, (PVOID)pmxlcA,
               FIELD_OFFSET(MIXERLINECONTROLSA, pamxctrl));
    mxlcW.cbmxctrl = mxlcW.cbmxctrl + sizeof(MIXERCONTROLW) -
                                          sizeof(MIXERCONTROLA);

    //
    //  Work out how many controls (what a mess - why isn't the count
    //  ALWAYS required)!
    //

    switch (MIXER_GETLINECONTROLSF_QUERYMASK & fdwControls)
    {
        case MIXER_GETLINECONTROLSF_ONEBYID:
        case MIXER_GETLINECONTROLSF_ONEBYTYPE:
            cControls = 1;
            break;

        default:
            cControls = mxlcW.cControls;
            break;
    }

    if (cControls != 0) {
        mxlcW.pamxctrl = (LPMIXERCONTROLW)
                             LocalAlloc(LPTR, cControls * mxlcW.cbmxctrl);

        if (mxlcW.pamxctrl == NULL) {
            return MMSYSERR_NOMEM;
        }

    } else {
        mxlcW.pamxctrl = NULL;
    }

    //
    //  Call the real function
    //

    mmr = mixerGetLineControls(hmxobj, &mxlcW, fdwControls);

    if (mmr != MMSYSERR_NOERROR) {
        if (mxlcW.pamxctrl != NULL) {
            LocalFree((HLOCAL)mxlcW.pamxctrl);
        }
        return mmr;
    }

    //
    //  The INPUT line id can be changed !!
    //

    pmxlcA->dwLineID = mxlcW.dwLineID;

    //
    //  The control id can be changed !!
    //

    pmxlcA->dwControlID = mxlcW.dwControlID;


    //
    //  Copy and massage the data back for the application
    //

    {
        UINT i;
        LPMIXERCONTROLA pamxctrlA;
        LPMIXERCONTROLW pamxctrlW;

        for (i = 0, pamxctrlA = pmxlcA->pamxctrl, pamxctrlW = mxlcW.pamxctrl;
             i < cControls;
             i++,
             *(LPBYTE *)&pamxctrlA += pmxlcA->cbmxctrl,
             *(LPBYTE *)&pamxctrlW += mxlcW.cbmxctrl
             ) {


             CopyMemory((PVOID)pamxctrlA,
                        (PVOID)pamxctrlW,
                        FIELD_OFFSET(MIXERCONTROLA, szShortName[0]));

             /*
             **  Set the size
             */

             pamxctrlA->cbStruct = sizeof(MIXERCONTROLA);

             Iwcstombs(pamxctrlA->szShortName,
                      pamxctrlW->szShortName,
                      sizeof(pamxctrlA->szShortName));
             Iwcstombs(pamxctrlA->szName,
                      pamxctrlW->szName,
                      sizeof(pamxctrlA->szName));

             CopyMemory((PVOID)((PBYTE)pamxctrlA +
                             FIELD_OFFSET(MIXERCONTROLA, Bounds.lMinimum)),
                        (PVOID)((PBYTE)pamxctrlW +
                             FIELD_OFFSET(MIXERCONTROLW, Bounds.lMinimum)),
                        sizeof(MIXERCONTROLW) -
                             FIELD_OFFSET(MIXERCONTROLW, Bounds.lMinimum));

        }
    }

    if (mxlcW.pamxctrl != NULL) {
        LocalFree((HLOCAL)mxlcW.pamxctrl);
    }
    return mmr;

} // mixerGetLineControlsA()

MMRESULT APIENTRY mixerGetLineControls(
    HMIXEROBJ               hmxobj,
    LPMIXERLINECONTROLS     pmxlc,
    DWORD                   fdwControls
)
{
    DWORD               fdwMxObjType;
    UINT                uMxId;
    BOOL                fResource;
    MMRESULT            mmr;

    V_DFLAGS(fdwControls, MIXER_GETLINECONTROLSF_VALID, mixerGetLineControls, MMSYSERR_INVALFLAG);
    V_WPOINTER(pmxlc, sizeof(DWORD), MMSYSERR_INVALPARAM);

    //
    //  the structure header for MIXERLINECONTROLS must be at least the
    //  minimum size
    //
    if (sizeof(MIXERLINECONTROLS) > pmxlc->cbStruct)
    {
        DebugErr1(DBF_ERROR, "mixerGetLineControls: structure size too small or cbStruct not initialized (%lu).", pmxlc->cbStruct);
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pmxlc, pmxlc->cbStruct, MMSYSERR_INVALPARAM);

    if (sizeof(MIXERCONTROL) > pmxlc->cbmxctrl)
    {
        DebugErr1(DBF_ERROR, "mixerGetLineControls: structure size too small or cbmxctrl not initialized (%lu).", pmxlc->cbmxctrl);
        return (MMSYSERR_INVALPARAM);
    }


    ClientUpdatePnpInfo();

    //
    //
    //
    switch (MIXER_GETLINECONTROLSF_QUERYMASK & fdwControls)
    {
        case MIXER_GETLINECONTROLSF_ALL:
            if (0 == pmxlc->cControls)
            {
                DebugErr(DBF_ERROR, "mixerGetLineControls: cControls cannot be zero.");
                return (MMSYSERR_INVALPARAM);
            }


            pmxlc->dwControlID  = (DWORD)-1L;
            break;

        case MIXER_GETLINECONTROLSF_ONEBYID:
            pmxlc->dwLineID     = (DWORD)-1L;

            // -- fall through --

        case MIXER_GETLINECONTROLSF_ONEBYTYPE:
            pmxlc->cControls    = (DWORD)1;
            break;

        default:
            DebugErr1(DBF_ERROR, "mixerGetLineControls: invalid query flags (%.08lXh).",
                        MIXER_GETLINECONTROLSF_QUERYMASK & fdwControls);
            return (MMSYSERR_INVALFLAG);
    }

    V_WPOINTER(pmxlc->pamxctrl, pmxlc->cControls * pmxlc->cbmxctrl, MMSYSERR_INVALPARAM);


    //
    //
    //
    fdwMxObjType = (MIXER_OBJECTF_TYPEMASK & fdwControls);

    fResource = FALSE;

    AcquireHandleListResourceShared();
    
    //  Checking for the type of mixer object.  If it is a non-mixer type
    //  calling IMixerMesssageID (called by IMixerGetID) with the shared
    //  resource will deadlock.
    if ((MIXER_OBJECTF_MIXER  == fdwMxObjType) ||
        (MIXER_OBJECTF_HMIXER == fdwMxObjType))
    {
        if (BAD_HANDLE(hmxobj, TYPE_MIXER))
        {
            ReleaseHandleListResource();
        }
        else
        {
            fResource = TRUE;
        }
    }
    else
    {
        ReleaseHandleListResource();
    }
    
    mmr = IMixerGetID(hmxobj, &uMxId, NULL, fdwMxObjType);
    if (MMSYSERR_NOERROR != mmr)
    {
        if (fResource)
            ReleaseHandleListResource();
        return (mmr);
    }

    if ((MIXER_OBJECTF_MIXER  == fdwMxObjType) ||
        (MIXER_OBJECTF_HMIXER == fdwMxObjType))
    {
        //
        //  if a mixer device id was passed, then null hmx so we use the
        //  correct message sender below
        //
        if ((UINT_PTR)hmxobj == uMxId)
            hmxobj = NULL;
    }
    else
    {
        hmxobj = NULL;
    }



    //
    //
    //
    //
    if (NULL != hmxobj)
    {
        mmr = (MMRESULT)IMixerMessageHandle((HMIXER)hmxobj,
                                            MXDM_GETLINECONTROLS,
                                            (DWORD_PTR)pmxlc,
                                            fdwControls);
    }
    else
    {
        mmr = (MMRESULT)IMixerMessageId(uMxId,
                                        MXDM_GETLINECONTROLS,
                                        (DWORD_PTR)pmxlc,
                                        fdwControls);
    }

    return (mmr);
} // mixerGetLineControls()


/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK STRUCTURE
 *
 *  @types MIXERCONTROLDETAILS_LISTTEXT | The <t MIXERCONTROLDETAILS_LISTTEXT>
 *      structure is used to get list text, label text, and/or band range
 *      information for multiple item controls. This structure is only used
 *      in conjunction with the <c MIXER_GETCONTROLDETAILSF_LISTTEXT> flag
 *      on the <f mixerGetControlDetails> function.
 *
 *  @field DWORD | dwParam1 | Specifies the first 32 bit control type
 *      specific value. Refer to the description of the multiple item control
 *      type for information on what this value represents for the given
 *      control.
 *
 *  @field DWORD | dwParam1 | Specifies the second 32 bit control type
 *      specific value. Refer to the description of the multiple item control
 *      type for information on what this value represents for the given
 *      control.
 *
 *  @field char | szName[<c MIXER_LONG_NAME_CHARS>] | Specifies a name that
 *      describes a single item in a multiple item control. This text can
 *      be used as a label or item text depending on the specific control
 *      type.
 *
 *  @comm The following standard control types use the
 *      <t MIXERCONTROLDETAILS_LISTTEXT> structure for getting the item text
 *      descriptions on multiple item controls:
 *
 *      <c MIXERCONTROL_CONTROLTYPE_EQUALIZER><nl>
 *
 *      <c MIXERCONTROL_CONTROLTYPE_SINGLESELECT><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MUX><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MIXER><nl>
 *
 *  @tagname tMIXERCONTROLDETAILS_LISTTEXT
 *
 *  @othertype MIXERCONTROLDETAILS_LISTTEXT FAR * | LPMIXERCONTROLDETAILS_LISTTEXT |
 *      A pointer to a <t MIXERCONTROLDETAILS_LISTTEXT> structure.
 *
 *  @othertype MIXERCONTROLDETAILS_LISTTEXT * | PMIXERCONTROLDETAILS_LISTTEXT |
 *      A pointer to a <t MIXERCONTROLDETAILS_LISTTEXT> structure.
 *
 *  @xref <t MIXERCONTROLDETAILS_UNSIGNED>, <t MIXERCONTROLDETAILS_SIGNED>,
 *      <t MIXERCONTROLDETAILS_BOOLEAN>, <f mixerGetControlDetails>,
 *      <f mixerSetControlDetails>, <t MIXERCONTROL>
 *
 **/

/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK STRUCTURE
 *
 *  @types MIXERCONTROLDETAILS_BOOLEAN | The <t MIXERCONTROLDETAILS_BOOLEAN>
 *      structure is used to get and set Boolean type control details for
 *      an audio mixer control. Refer to the control type description for
 *      the desired control to determine what details structure to use.
 *
 *  @field LONG | fValue | Specifies the Boolean value for a single item
 *      or channel. This value is assumed to zero for a 'FALSE' state (for
 *      example, off or disabled). This value is assumed to be non-zero
 *      for a 'TRUE' state (for example, on or enabled).
 *
 *  @comm The following standard control types use the
 *      <t MIXERCONTROLDETAILS_BOOLEAN> structure for getting and setting
 *      details:
 *
 *      <c MIXERCONTROL_CONTROLTYPE_BOOLEANMETER><nl>
 *
 *      <c MIXERCONTROL_CONTROLTYPE_BUTTON><nl>
 *
 *      <c MIXERCONTROL_CONTROLTYPE_BOOLEAN><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_ONOFF><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MUTE><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MONO><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_LOUDNESS><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_STEREOENH><nl>
 *
 *      <c MIXERCONTROL_CONTROLTYPE_SINGLESELECT><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MUX><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MIXER><nl>
 *
 *  @tagname tMIXERCONTROLDETAILS_BOOLEAN
 *
 *  @othertype MIXERCONTROLDETAILS_BOOLEAN FAR * | LPMIXERCONTROLDETAILS_BOOLEAN |
 *      A pointer to a <t MIXERCONTROLDETAILS_BOOLEAN> structure.
 *
 *  @othertype MIXERCONTROLDETAILS_BOOLEAN * | PMIXERCONTROLDETAILS_BOOLEAN |
 *      A pointer to a <t MIXERCONTROLDETAILS_BOOLEAN> structure.
 *
 *  @xref <t MIXERCONTROLDETAILS_UNSIGNED>, <t MIXERCONTROLDETAILS_SIGNED>,
 *      <t MIXERCONTROLDETAILS_LISTTEXT>, <f mixerGetControlDetails>,
 *      <f mixerSetControlDetails>, <t MIXERCONTROL>
 *
 **/

/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK STRUCTURE
 *
 *  @types MIXERCONTROLDETAILS_SIGNED | The <t MIXERCONTROLDETAILS_SIGNED>
 *      structure is used to get and set signed type control details for
 *      an audio mixer control. Refer to the control type description for
 *      the desired control to determine what details structure to use.
 *
 *  @field LONG | lValue | Specifies a signed integer value for a single
 *      item or channel. This value must be inclusively within the bounds
 *      given in the <e MIXERCONTROL.Bounds> structure member of the
 *      <t MIXERCONTROL> structure for signed integer controls.
 *
 *  @comm The following standard control types use the
 *      <t MIXERCONTROLDETAILS_SIGNED> structure for getting and setting
 *      details:
 *
 *      <c MIXERCONTROL_CONTROLTYPE_SIGNEDMETER><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_PEAKMETER><nl>
 *
 *      <c MIXERCONTROL_CONTROLTYPE_SIGNED><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_DECIBELS><nl>
 *
 *      <c MIXERCONTROL_CONTROLTYPE_SLIDER><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_PAN><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_QSOUNDPAN><nl>
 *
 *  @tagname tMIXERCONTROLDETAILS_SIGNED
 *
 *  @othertype MIXERCONTROLDETAILS_SIGNED FAR * | LPMIXERCONTROLDETAILS_SIGNED |
 *      A pointer to a <t MIXERCONTROLDETAILS_SIGNED> structure.
 *
 *  @othertype MIXERCONTROLDETAILS_SIGNED * | PMIXERCONTROLDETAILS_SIGNED |
 *      A pointer to a <t MIXERCONTROLDETAILS_SIGNED> structure.
 *
 *  @xref <t MIXERCONTROLDETAILS_UNSIGNED>, <t MIXERCONTROLDETAILS_BOOLEAN>,
 *      <t MIXERCONTROLDETAILS_LISTTEXT>, <f mixerGetControlDetails>,
 *      <f mixerSetControlDetails>, <t MIXERCONTROL>
 *
 **/

/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK STRUCTURE
 *
 *  @types MIXERCONTROLDETAILS_UNSIGNED | The <t MIXERCONTROLDETAILS_UNSIGNED>
 *      structure is used to get and set unsigned type control details for
 *      an audio mixer control. Refer to the control type description for
 *      the desired control to determine what details structure to use.
 *
 *  @field DWORD | dwValue | Specifies an unsigned integer value for a single
 *      item or channel. This value must be inclusively within the bounds
 *      given in the <e MIXERCONTROL.Bounds> structure member of the
 *      <t MIXERCONTROL> structure for unsigned integer controls.
 *
 *  @comm The following standard control types use the
 *      <t MIXERCONTROLDETAILS_UNSIGNED> structure for getting and setting
 *      details:
 *
 *      <c MIXERCONTROL_CONTROLTYPE_UNSIGNEDMETER><nl>
 *
 *      <c MIXERCONTROL_CONTROLTYPE_UNSIGNED><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_PERCENT><nl>
 *
 *      <c MIXERCONTROL_CONTROLTYPE_FADER><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_VOLUME><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_BASS><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_TREBLE><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_EQUALIZER><nl>
 *
 *      <c MIXERCONTROL_CONTROLTYPE_MICROTIME><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MILLITIME><nl>
 *
 *  @tagname tMIXERCONTROLDETAILS_UNSIGNED
 *
 *  @othertype MIXERCONTROLDETAILS_UNSIGNED FAR * | LPMIXERCONTROLDETAILS_UNSIGNED |
 *      A pointer to a <t MIXERCONTROLDETAILS_UNSIGNED> structure.
 *
 *  @othertype MIXERCONTROLDETAILS_UNSIGNED * | PMIXERCONTROLDETAILS_UNSIGNED |
 *      A pointer to a <t MIXERCONTROLDETAILS_UNSIGNED> structure.
 *
 *  @xref <t MIXERCONTROLDETAILS_SIGNED>, <t MIXERCONTROLDETAILS_BOOLEAN>,
 *      <t MIXERCONTROLDETAILS_LISTTEXT>, <f mixerGetControlDetails>,
 *      <f mixerSetControlDetails>, <t MIXERCONTROL>
 *
 **/


/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK STRUCTURE
 *
 *  @types MIXERCONTROLDETAILS | The <t MIXERCONTROLDETAILS> structure
 *      references control detail structures to retrieve or set state
 *      information of an audio mixer control. All members of this structure
 *      must be initialized before calling the <f mixerGetControlDetails>
 *      and <f mixerSetControlDetails> functions.
 *
 *  @field DWORD | cbStruct | Specifies the size, in bytes, of the
 *      <t MIXERCONTROLDETAILS> structure. This member must be initialized
 *      before calling the <f mixerGetControlDetails> and
 *      <f mixerSetControlDetails> functions. The size specified in this
 *      member must be large enough to contain the base
 *      <t MIXERCONTROLDETAILS> structure. When the <f mixerGetControlDetails>
 *      function returns, this member contains the actual size of the
 *      information returned. The returned information will never exceed
 *      the requested size and will never be smaller than the base
 *      <t MIXERCONTROLDETAILS> structure.
 *
 *  @field DWORD | dwControlID | Specifies the control identifier to get or
 *      set details on. This member must always be initialized before calling
 *      the <f mixerGetControlDetails> and <f mixerSetControlDetails>
 *      functions.
 *
 *  @field DWORD | cChannels | Specifies the number of channels to get or
 *      set details for. This member can be one of the following values for a
 *      control.
 *
 *      1. If the details for the control are expected on all channels for
 *      a line, then this member must be equal the <e MIXERLINE.cChannels>
 *      member of the <t MIXERLINE> structure.
 *
 *      2. If the control is a <c MIXERCONTROL_CONTROLF_UNIFORM> control, then
 *      this member must be set to one.
 *
 *      3. If the control is not uniform, but the application wishes to
 *      get and set all channels as if they were uniform, then this member
 *      should be set to one.
 *
 *      4. If the control is a <c MIXERCONTROL_CONTROLTYPE_CUSTOM> control,
 *      then this member must be zero.
 *
 *      An application is not allowed to specify any value that comes
 *      between one and the number of channels for the line. For example,
 *      specifying two or three for a four channel line is not valid.
 *      This member can never be zero for non-custom control types.
 *
 *  @field DWORD | cMultipleItems | Specifies the number of multiple items
 *      per channel to get or set details for. This member can be one of
 *      the following values for a control.
 *
 *      1. If the control is not a <c MIXERCONTROL_CONTROLF_MULTIPLE> control,
 *      then this member must be zero.
 *
 *      2. If the control is a <c MIXERCONTROL_CONTROLF_MULTIPLE> control,
 *      then this member must be equal to the <e MIXERCONTROL.cMultipleItems>
 *      member of the <t MIXERCONTROL> structure.
 *
 *      3. If the control is a <c MIXERCONTROL_CONTROLTYPE_CUSTOM> control,
 *      then this member must be zero unless the
 *      <c MIXER_SETCONTROLDETAILSF_CUSTOM> flag is specified for the
 *      <f mixerSetControlDetails> function. In this case, the
 *      <e MIXERCONTROLDETAILS.cMultipleItems> member overlaps with the
 *      <e MIXERCONTROLDETAILS.hwndOwner> member and is therefore the value
 *      of the window handle.
 *
 *      An application is not allowed to specify any value other than the
 *      value specified in the <e MIXERCONTROL.cMultipleItems> member of
 *      the <t MIXERCONTROL> structure for a <c MIXERCONTROL_CONTROLF_MULTIPLE>
 *      control.
 *
 *  @field DWORD | cbDetails | Specifies the size, in bytes, of a single
 *      details structure. This size must be the exact size of the correct
 *      details structure. There are currently four different details
 *      structures:
 *
 *          @flag <t MIXERCONTROLDETAILS_UNSIGNED> | Defines an unsigned
 *          value for a mixer line control.
 *
 *          @flag <t MIXERCONTROLDETAILS_SIGNED> | Defines an signed
 *          value for a mixer line control.
 *
 *          @flag <t MIXERCONTROLDETAILS_BOOLEAN> | Defines a Boolean
 *          value for a mixer line control.
 *
 *          @flag <t MIXERCONTROLDETAILS_LISTTEXT> | Defines a list text
 *          buffer for a mixer line control.
 *
 *      Refer to the description of the control type for information on what
 *      details structure is appropriate for a specific control.
 *
 *      If the control is a <c MIXERCONTROL_CONTROLTYPE_CUSTOM> control,
 *      then this member must be equal to the <e MIXERCONTROL.cbCustomData>
 *      member of the <t MIXERCONTROL> structure.
 *
 *  @field LPVOID | paDetails | Points to an array of one or more details
 *      structures to get or set details for the specified control in. The
 *      required size for this buffer is computed as follows:
 *
 *      1. For controls that are not <c MIXERCONTROL_CONTROLF_MULTIPLE> types,
 *      the size of this buffer is the product of the
 *      <e MIXERCONTROLDETAILS.cChannels> and <e MIXERCONTROLDETAILS.cbDetails>
 *      members of the <t MIXERCONTROLDETAILS> structure.
 *
 *      2. For controls that are <c MIXERCONTROL_CONTROLF_MULTIPLE> types,
 *      the size of this buffer is the product of the
 *      <e MIXERCONTROLDETAILS.cChannels>, <e MIXERCONTROLDETAILS.cMultipleItems>
 *      and <e MIXERCONTROLDETAILS.cbDetails> members of the
 *      <t MIXERCONTROLDETAILS> structure.
 *
 *      The layout of the details elements in this array are as follows:
 *
 *      1. For controls that are not <c MIXERCONTROL_CONTROLF_MULTIPLE> types,
 *      each element index is equivalent to the zero based channel that it
 *      affects. That is, <e MIXERCONTROLDETAILS.paDetails>[0] is for the
 *      left channel, <e MIXERCONTROLDETAILS.paDetails>[1] is for the
 *      right channel.
 *
 *      2. For controls that are <c MIXERCONTROL_CONTROLF_MULTIPLE> types,
 *      the array can be thought of as a two dimensional array that is
 *      'channel major'. That is, all multiple items for the left channel
 *      are given, then all multiple items for the right channel, etc.
 *
 *      If the control is a <c MIXERCONTROL_CONTROLTYPE_CUSTOM> control,
 *      then this member must point to a buffer that is at least large
 *      enough to hold the size, in bytes, specified by the
 *      <e MIXERCONTROL.cbCustomData> member of the <t MIXERCONTROL>
 *      structure.
 *
 *  @tagname tMIXERCONTROLDETAILS
 *
 *  @othertype MIXERCONTROLDETAILS FAR * | LPMIXERCONTROLDETAILS | A pointer
 *      to a <t MIXERCONTROLDETAILS> structure.
 *
 *  @othertype MIXERCONTROLDETAILS * | PMIXERCONTROLDETAILS | A pointer
 *      to a <t MIXERCONTROLDETAILS> structure.
 *
 *  @ex So the following example shows how to address a single item in a
 *      multiple item control for using the <t MIXERCONTROLDETAILS_SIGNED>
 *      details structure. |
 *      {
 *          MIXERCONTROLDETAILS         mxcd;
 *          PMIXERCONTROLDETAILS_SIGNED pamxcd_s;
 *          PMIXERCONTROLDETAILS_SIGNED pmxcd_s;
 *
 *          //
 *          //  'mxcd' is assumed to be a valid MIXERCONTROLDETAILS
 *          //  structure.
 *          //
 *          //  'channel' is assumed to be a valid channel ranging from zero
 *          //  to one less than the number of channels available for the
 *          //  signed control.
 *          //
 *          //  'item' is assumed to be a valid item index ranging from zero
 *          //  to one less than the number of 'multiple items' stored in
 *          //  the variable called 'cMultipleItems'.
 *          //
 *          pamxcd_s = (PMIXERCONTROLDETAILS_SIGNED)mxcd.paDetails;
 *          pmxcd_s  = &pamxcd_s[(channel * cMultipleItems) + item];
 *      }
 *
 *  @xref <f mixerGetLineControls>, <f mixerGetControlDetails>,
 *      <f mixerSetControlDetails>, <t MIXERCONTROL>
 *
 **/

/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK API
 *
 *  @api MMRESULT | mixerGetControlDetails | The <f mixerGetControlDetails>
 *      function is used to retrieve details on a single control associated
 *      with an audio mixer device line.
 *
 *  @parm <c HMIXEROBJ> | hmxobj | Specifies a handle to the audio mixer
 *      device object to get control details for.
 *
 *  @parm LPMIXERCONTROLDETAILS | pmxcd | Points to a <t MIXERCONTROLDETAILS>
 *      structure. This structure is used to reference control detail
 *      structures to be filled with state information about the control.
 *      See the comments for each query flag passed through <p fdwDetails>
 *      for details on what members of the <t MIXERCONTROLDETAILS> structure
 *      must be initialized before calling the <f mixerGetControlDetails>
 *      function. Note that in all cases, the <e MIXERCONTROLDETAILS.cbStruct>
 *      member of the <t MIXERCONTROLDETAILS> structure must be initialized
 *      to be the size, in bytes, of the <t MIXERCONTROLDETAILS> structure.
 *
 *  @parm DWORD | fdwDetails | Specifies flags for getting details on
 *      a control.
 *
 *      @flag <c MIXER_GETCONTROLDETAILSF_VALUE> | If this flag is specified,
 *      the application is interested in getting the current value(s) for a
 *      control. The <e MIXERCONTROLDETAILS.paDetails> member of the
 *      <t MIXERCONTROLDETAILS> points to one or more details structures of
 *      the correct type for the control type. Refer to the description of the
 *      <t MIXERCONTROLDETAILS> structure for information on what each member
 *      of this structure must be initialized before calling the
 *      <f mixerGetControlDetails> function.
 *
 *      @flag <c MIXER_GETCONTROLDETAILSF_LISTTEXT> | If this flag is specified,
 *      the <e MIXERCONTROLDETAILS.paDetails> member of the <t MIXERCONTROLDETAILS>
 *      structure points to one or more <t MIXERCONTROLDETAILS_LISTTEXT>
 *      structures to receive text labels for multiple item controls. Note
 *      that an application must get all list text items for a multiple item
 *      control at once. Refer to the description of the <t MIXERCONTROLDETAILS>
 *      structure for information on what each member of this structure must
 *      be initialized before calling the <f mixerGetControlDetails> function.
 *      This flag cannot be used with <c MIXERCONTROL_CONTROLTYPE_CUSTOM>
 *      controls.
 *
 *      @flag <c MIXER_OBJECTF_MIXER> | Specifies that <p hmxobj> is an audio
 *      mixer device identifier in the range of zero to one less than the
 *      number of devices returned by <f mixerGetNumDevs>. This flag is
 *      optional.
 *
 *      @flag <c MIXER_OBJECTF_HMIXER> | Specifies that <p hmxobj> is a mixer
 *      device handle returned by <f mixerOpen>. This flag is optional.
 *
 *      @flag <c MIXER_OBJECTF_WAVEOUT> | Specifies that <p hmxobj> is a
 *      waveform output device identifier in the range of zero to one less
 *      than the number of devices returned by <f waveOutGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HWAVEOUT> | Specifies that <p hmxobj> is a
 *      waveform output handle returned by <f waveOutOpen>.
 *
 *      @flag <c MIXER_OBJECTF_WAVEIN> | Specifies that <p hmxobj> is a
 *      waveform input device identifier in the range of zero to one less
 *      than the number of devices returned by <f waveInGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HWAVEIN> | Specifies that <p hmxobj> is a
 *      waveform input handle returned by <f midiInOpen>.
 *
 *      @flag <c MIXER_OBJECTF_MIDIOUT> | Specifies that <p hmxobj> is a MIDI
 *      output device identifier in the range of zero to one less than the
 *      number of devices returned by <f midiOutGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HMIDIOUT> | Specifies that <p hmxobj> is a
 *      MIDI output handle returned by <f midiOutOpen>.
 *
 *      @flag <c MIXER_OBJECTF_MIDIIN> | Specifies that <p hmxobj> is a MIDI
 *      input device identifier in the range of zero to one less than the
 *      number of devices returned by <f midiInGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HMIDIIN> | Specifies that <p hmxobj> is a MIDI
 *      input handle returned by <f midiInOpen>.
 *
 *      @flag <c MIXER_OBJECTF_AUX> | Specifies that <p hmxobj> is an
 *      auxiliary device identifier in the range of zero to one less than the
 *      number of devices returned by <f auxGetNumDevs>.
 *
 *  @rdesc The return value is zero if the function is successful. Otherwise,
 *      it returns a non-zero error number. Possible error returns include
 *      the following:
 *
 *      @flag <c MMSYSERR_BADDEVICEID> | The <p hmxobj> argument specifies an
 *      invalid device identifier.
 *
 *      @flag <c MMSYSERR_INVALHANDLE> | The <p hmxobj> argument specifies an
 *      invalid handle.
 *
 *      @flag <c MMSYSERR_INVALFLAG> | One or more flags are invalid.
 *
 *      @flag <c MMSYSERR_INVALPARAM> | One or more arguments passed is
 *      invalid.
 *
 *      @flag <c MMSYSERR_NODRIVER> | No audio mixer device is available for
 *      the object specified by <p hmxobj>.
 *
 *      @flag <c MIXERR_INVALCONTROL> | The control reference is invalid.
 *
 *  @xref <t MIXERCONTROLDETAILS>, <t MIXERCONTROL>, <f mixerGetLineControls>,
 *      <f mixerOpen>, <f mixerSetControlDetails>
 *
 **/

MMRESULT APIENTRY mixerGetControlDetailsA(
    HMIXEROBJ               hmxobj,
    LPMIXERCONTROLDETAILS   pmxcd,
    DWORD                   fdwDetails
)
{
    MIXERCONTROLDETAILS mxcd;
    MMRESULT mmr;
    int cDetails;

    //
    //  Everything is OK unless it's MIXER_GETCONTROLDETAILSF_LISTTEXT
    //

    if ((MIXER_GETCONTROLDETAILSF_QUERYMASK & fdwDetails) !=
        MIXER_GETCONTROLDETAILSF_LISTTEXT) {
        return mixerGetControlDetails(hmxobj, pmxcd, fdwDetails);
    }

    V_WPOINTER(pmxcd, sizeof(DWORD), MMSYSERR_INVALPARAM);

    //
    //  the structure header for MIXERCONTROLDETAILS must be at least the
    //  minimum size
    //
    if (sizeof(MIXERCONTROLDETAILS) > pmxcd->cbStruct)
    {
        DebugErr1(DBF_ERROR, "mixerGetControlDetails: structure size too small or cbStruct not initialized (%lu).", pmxcd->cbStruct);
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pmxcd, pmxcd->cbStruct, MMSYSERR_INVALPARAM);

    if (sizeof(MIXERCONTROLDETAILS_LISTTEXTA) < pmxcd->cbDetails) {
        DebugErr1(DBF_ERROR, "mixerGetControlDetails: structure size too small or cbDetails not initialized for _LISTTEXT (%lu).", pmxcd->cbDetails);
        return (MMSYSERR_INVALPARAM);
    }

    //
    //  Allocate space for the return structure.
    //

    mxcd = *pmxcd;
    cDetails = pmxcd->cChannels * pmxcd->cMultipleItems;

    mxcd.paDetails =
        (PVOID)LocalAlloc(LPTR, cDetails *
                                sizeof(MIXERCONTROLDETAILS_LISTTEXTW));

    mxcd.cbDetails = sizeof(MIXERCONTROLDETAILS_LISTTEXTW);

    if (mxcd.paDetails == NULL) {
        return MMSYSERR_NOMEM;
    }


    //
    //  Call the UNICODE version
    //

    mmr = mixerGetControlDetails(hmxobj, &mxcd, fdwDetails);

    if (mmr != MMSYSERR_NOERROR) {
        LocalFree((HLOCAL)(mxcd.paDetails));
        return mmr;
    }

    //
    //  Copy the return data back
    //

    {
        int i;
        PMIXERCONTROLDETAILS_LISTTEXTW pDetailsW;
        PMIXERCONTROLDETAILS_LISTTEXTA pDetailsA;

        for (i = 0,
             pDetailsW = (PMIXERCONTROLDETAILS_LISTTEXTW)mxcd.paDetails,
             pDetailsA = (PMIXERCONTROLDETAILS_LISTTEXTA)pmxcd->paDetails;

             i < cDetails;

             i++,
             pDetailsW++,
             *(LPBYTE *)&pDetailsA += pmxcd->cbDetails)
        {
            pDetailsA->dwParam1 = pDetailsW->dwParam1;
            pDetailsA->dwParam2 = pDetailsW->dwParam2;
            Iwcstombs(pDetailsA->szName, pDetailsW->szName,
                      sizeof(pDetailsA->szName));
        }
    }

    LocalFree((HLOCAL)mxcd.paDetails);

    return mmr;

} // mixerGetControlDetailsA()

MMRESULT APIENTRY mixerGetControlDetails(
    HMIXEROBJ               hmxobj,
    LPMIXERCONTROLDETAILS   pmxcd,
    DWORD                   fdwDetails
)
{
    DWORD               fdwMxObjType;
    MMRESULT            mmr;
    UINT                uMxId;
    UINT                cDetails;
    BOOL                fResource;

    V_DFLAGS(fdwDetails, MIXER_GETCONTROLDETAILSF_VALID, mixerGetControlDetails, MMSYSERR_INVALFLAG);
    V_WPOINTER(pmxcd, sizeof(DWORD), MMSYSERR_INVALPARAM);

    //
    //  the structure header for MIXERCONTROLDETAILS must be at least the
    //  minimum size
    //
    if (sizeof(MIXERCONTROLDETAILS) > pmxcd->cbStruct)
    {
        DebugErr1(DBF_ERROR, "mixerGetControlDetails: structure size too small or cbStruct not initialized (%lu).", pmxcd->cbStruct);
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pmxcd, pmxcd->cbStruct, MMSYSERR_INVALPARAM);


    switch (MIXER_GETCONTROLDETAILSF_QUERYMASK & fdwDetails)
    {
        case MIXER_GETCONTROLDETAILSF_VALUE:
            //
            //  if both cChannels and cMultipleItems are zero, it is a
            //  custom control
            //
            if ((0 == pmxcd->cChannels) && (0 == pmxcd->cMultipleItems))
            {
                if (0 == pmxcd->cbDetails)
                {
                    DebugErr(DBF_ERROR, "mixerGetControlDetails: cbDetails cannot be zero.");
                    return (MMSYSERR_INVALPARAM);
                }

                V_WPOINTER(pmxcd->paDetails, pmxcd->cbDetails, MMSYSERR_INVALPARAM);

            }
            else
            {
                if (0 == pmxcd->cChannels)
                {
                    DebugErr(DBF_ERROR, "mixerGetControlDetails: cChannels for _VALUE cannot be zero.");
                    return (MMSYSERR_INVALPARAM);
                }


                if (pmxcd->cbDetails < sizeof(MIXERCONTROLDETAILS_SIGNED))
                {
                    DebugErr1(DBF_ERROR, "mixerGetControlDetails: structure size too small or cbDetails not initialized (%lu).", pmxcd->cbDetails);
                    return (MMSYSERR_INVALPARAM);
                }

                //
                //
                //
                cDetails = (UINT)pmxcd->cChannels;
                if (0 != pmxcd->cMultipleItems)
                {
                    cDetails *= (UINT)pmxcd->cMultipleItems;
                }

                V_WPOINTER(pmxcd->paDetails, cDetails * pmxcd->cbDetails, MMSYSERR_INVALPARAM);
            }
            break;

        case MIXER_GETCONTROLDETAILSF_LISTTEXT:
            if (0 == pmxcd->cChannels)
            {
                DebugErr(DBF_ERROR, "mixerGetControlDetails: cChannels for _LISTTEXT cannot be zero.");
                return (MMSYSERR_INVALPARAM);
            }

            if (2 > pmxcd->cMultipleItems)
            {
                DebugErr(DBF_ERROR, "mixerGetControlDetails: cMultipleItems for _LISTTEXT must be 2 or greater.");
                return (MMSYSERR_INVALPARAM);
            }

            if (pmxcd->cbDetails < sizeof(MIXERCONTROLDETAILS_LISTTEXT))
            {
                DebugErr1(DBF_ERROR, "mixerGetControlDetails: structure size too small or cbDetails not initialized (%lu).", pmxcd->cbDetails);
                return (MMSYSERR_INVALPARAM);
            }

            cDetails = (UINT)pmxcd->cChannels * (UINT)pmxcd->cMultipleItems;
            V_WPOINTER(pmxcd->paDetails, cDetails * pmxcd->cbDetails, MMSYSERR_INVALPARAM);
            break;

        default:
            DebugErr1(DBF_ERROR, "mixerGetControlDetails: invalid query flags (%.08lXh).",
                        MIXER_GETCONTROLDETAILSF_QUERYMASK & fdwDetails);
            return (MMSYSERR_INVALFLAG);
    }



    ClientUpdatePnpInfo();

    //
    //
    //
    fdwMxObjType = (MIXER_OBJECTF_TYPEMASK & fdwDetails);

    fResource = FALSE;

    AcquireHandleListResourceShared();
    
    //  Checking for the type of mixer object.  If it is a non-mixer type
    //  calling IMixerMesssageID (called by IMixerGetID) with the shared
    //  resource will deadlock.
    if ((MIXER_OBJECTF_MIXER  == fdwMxObjType) ||
        (MIXER_OBJECTF_HMIXER == fdwMxObjType))
    {
        if (BAD_HANDLE(hmxobj, TYPE_MIXER))
        {
            ReleaseHandleListResource();
        }
        else
        {
            fResource = TRUE;
        }
    }
    else
    {
        ReleaseHandleListResource();
    }
    
    mmr = IMixerGetID(hmxobj, &uMxId, NULL, fdwMxObjType);
    if (MMSYSERR_NOERROR != mmr)
    {
        if (fResource)
            ReleaseHandleListResource();
        return (mmr);
    }

    if ((MIXER_OBJECTF_MIXER  == fdwMxObjType) ||
        (MIXER_OBJECTF_HMIXER == fdwMxObjType))
    {
        //
        //  if a mixer device id was passed, then null hmx so we use the
        //  correct message sender below
        //
        if ((UINT_PTR)hmxobj == uMxId)
            hmxobj = NULL;
    }
    else
    {
        hmxobj = NULL;
    }

    //
    //
    //
    //
    if (NULL != hmxobj)
    {
        mmr = (MMRESULT)IMixerMessageHandle((HMIXER)hmxobj,
                                            MXDM_GETCONTROLDETAILS,
                                            (DWORD_PTR)pmxcd,
                                            fdwDetails);
    }
    else
    {
        mmr = (MMRESULT)IMixerMessageId(uMxId,
                                        MXDM_GETCONTROLDETAILS,
                                        (DWORD_PTR)pmxcd,
                                        fdwDetails);
    }

    return (mmr);
} // mixerGetControlDetails()


/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK API
 *
 *  @api MMRESULT | mixerSetControlDetails | The <f mixerSetControlDetails>
 *      function is used to set details on a single control associated
 *      with an audio mixer device line.
 *
 *  @parm <c HMIXEROBJ> | hmxobj | Specifies a handle to the audio mixer
 *      device object to set control details for.
 *
 *  @parm LPMIXERCONTROLDETAILS | pmxcd | Points to a <t MIXERCONTROLDETAILS>
 *      structure. This structure is used to reference control detail
 *      structures to that contain the desired state for the control.
 *      See the description for the <t MIXERCONTROLDETAILS> structure
 *      to determine what members of this structure must be initialized
 *      before calling the <f mixerSetControlDetails> function. Note that
 *      in all cases, the <e MIXERCONTROLDETAILS.cbStruct> member of the
 *      <t MIXERCONTROLDETAILS> structure must be initialized
 *      to be the size, in bytes, of the <t MIXERCONTROLDETAILS> structure.
 *
 *  @parm DWORD | fdwDetails | Specifies flags for setting details for
 *      a control.
 *
 *      @flag <c MIXER_SETCONTROLDETAILSF_VALUE> | If this flag is specified,
 *      the application is interested in setting the current value(s) for a
 *      control. The <e MIXERCONTROLDETAILS.paDetails> member of the
 *      <t MIXERCONTROLDETAILS> points to one or more details structures of
 *      the correct type for the control type. Refer to the description of the
 *      <t MIXERCONTROLDETAILS> structure for information on what each member
 *      of this structure must be initialized before calling the
 *      <f mixerSetControlDetails> function.
 *
 *      @flag <c MIXER_SETCONTROLDETAILSF_CUSTOM> | If this flag is specified,
 *      the application is asking the mixer device to display a custom
 *      dialog for the specified custom mixer control. The handle for the
 *      owning window is specified in the <e MIXERCONTROLDETAILS.hwndOwner>
 *      member (this handle may, validly, be NULL). The mixer device will
 *      gather the required information from the user and return the data
 *      in the specified buffer. This data may then be saved by the
 *      application and later set back to the same state using the
 *      <c MIXER_SETCONTROLDETAILSF_VALUE> flag. If an application only
 *      needs to get the current state of a custom mixer control without
 *      displaying a dialog, then the <f mixerGetControlDetails> function
 *      can be used with the <c MIXER_GETCONTROLDETAILSF_VALUE> flag.
 *
 *      @flag <c MIXER_OBJECTF_MIXER> | Specifies that <p hmxobj> is an audio
 *      mixer device identifier in the range of zero to one less than the
 *      number of devices returned by <f mixerGetNumDevs>. This flag is
 *      optional.
 *
 *      @flag <c MIXER_OBJECTF_HMIXER> | Specifies that <p hmxobj> is a mixer
 *      device handle returned by <f mixerOpen>. This flag is optional.
 *
 *      @flag <c MIXER_OBJECTF_WAVEOUT> | Specifies that <p hmxobj> is a
 *      waveform output device identifier in the range of zero to one less
 *      than the number of devices returned by <f waveOutGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HWAVEOUT> | Specifies that <p hmxobj> is a
 *      waveform output handle returned by <f waveOutOpen>.
 *
 *      @flag <c MIXER_OBJECTF_WAVEIN> | Specifies that <p hmxobj> is a
 *      waveform input device identifier in the range of zero to one less
 *      than the number of devices returned by <f waveInGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HWAVEIN> | Specifies that <p hmxobj> is a
 *      waveform input handle returned by <f midiInOpen>.
 *
 *      @flag <c MIXER_OBJECTF_MIDIOUT> | Specifies that <p hmxobj> is a MIDI
 *      output device identifier in the range of zero to one less than the
 *      number of devices returned by <f midiOutGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HMIDIOUT> | Specifies that <p hmxobj> is a
 *      MIDI output handle returned by <f midiOutOpen>.
 *
 *      @flag <c MIXER_OBJECTF_MIDIIN> | Specifies that <p hmxobj> is a MIDI
 *      input device identifier in the range of zero to one less than the
 *      number of devices returned by <f midiInGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HMIDIIN> | Specifies that <p hmxobj> is a MIDI
 *      input handle returned by <f midiInOpen>.
 *
 *      @flag <c MIXER_OBJECTF_AUX> | Specifies that <p hmxobj> is an
 *      auxiliary device identifier in the range of zero to one less than the
 *      number of devices returned by <f auxGetNumDevs>.
 *
 *  @rdesc The return value is zero if the function is successful. Otherwise,
 *      it returns a non-zero error number. Possible error returns include
 *      the following:
 *
 *      @flag <c MMSYSERR_BADDEVICEID> | The <p hmxobj> argument specifies an
 *      invalid device identifier.
 *
 *      @flag <c MMSYSERR_INVALHANDLE> | The <p hmxobj> argument specifies an
 *      invalid handle.
 *
 *      @flag <c MMSYSERR_INVALFLAG> | One or more flags are invalid.
 *
 *      @flag <c MMSYSERR_INVALPARAM> | One or more arguments passed is
 *      invalid.
 *
 *      @flag <c MMSYSERR_NODRIVER> | No audio mixer device is available for
 *      the object specified by <p hmxobj>.
 *
 *      @flag <c MIXERR_INVALCONTROL> | The control reference is invalid.
 *
 *  @xref <t MIXERCONTROLDETAILS>, <t MIXERCONTROL>, <f mixerGetLineControls>,
 *      <f mixerOpen>, <f mixerGetControlDetails>
 *
 **/

MMRESULT APIENTRY mixerSetControlDetails(
    HMIXEROBJ               hmxobj,
    LPMIXERCONTROLDETAILS   pmxcd,
    DWORD                   fdwDetails
)
{
    DWORD               fdwMxObjType;
    MMRESULT            mmr;
    UINT                uMxId;
    UINT                cDetails;
    BOOL                fResource;

    V_DFLAGS(fdwDetails, MIXER_SETCONTROLDETAILSF_VALID, mixerSetControlDetails, MMSYSERR_INVALFLAG);
    V_WPOINTER(pmxcd, sizeof(DWORD), MMSYSERR_INVALPARAM);

    //
    //  the structure header for MIXERCONTROLDETAILS must be at least the
    //  minimum size
    //
    if (sizeof(MIXERCONTROLDETAILS) > pmxcd->cbStruct)
    {
        DebugErr1(DBF_ERROR, "mixerSetControlDetails: structure size too small or cbStruct not initialized (%lu).", pmxcd->cbStruct);
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pmxcd, pmxcd->cbStruct, MMSYSERR_INVALPARAM);



    switch (MIXER_SETCONTROLDETAILSF_QUERYMASK & fdwDetails)
    {
        case MIXER_SETCONTROLDETAILSF_VALUE:
            //
            //  cChannels is zero for custom controls
            //
            if (0 == pmxcd->cChannels)
            {
                if (0 == pmxcd->cbDetails)
                {
                    DebugErr(DBF_ERROR, "mixerSetControlDetails: cbDetails cannot be zero.");
                    return (MMSYSERR_INVALPARAM);
                }

                V_WPOINTER(pmxcd->paDetails, pmxcd->cbDetails, MMSYSERR_INVALPARAM);

                //
                //
                //
                if (0 != pmxcd->cMultipleItems)
                {
                    DebugErr(DBF_ERROR, "mixerSetControlDetails: cMultipleItems must be zero for custom controls.");
                    return (MMSYSERR_INVALPARAM);
                }
            }
            else
            {
                if (pmxcd->cbDetails < sizeof(MIXERCONTROLDETAILS_SIGNED))
                {
                    DebugErr1(DBF_ERROR, "mixerSetControlDetails: structure size too small or cbDetails not initialized (%lu).", pmxcd->cbDetails);
                    return (MMSYSERR_INVALPARAM);
                }

                cDetails = (UINT)pmxcd->cChannels;

                //
                //
                //
                if (0 != pmxcd->cMultipleItems)
                {
                    cDetails *= (UINT)(pmxcd->cMultipleItems);
                }

                V_WPOINTER(pmxcd->paDetails, cDetails * pmxcd->cbDetails, MMSYSERR_INVALPARAM);
            }
            break;

        case MIXER_SETCONTROLDETAILSF_CUSTOM:
            if (0 == pmxcd->cbDetails)
            {
                DebugErr(DBF_ERROR, "mixerSetControlDetails: cbDetails cannot be zero for custom controls.");
                return (MMSYSERR_INVALPARAM);
            }

            if (0 != pmxcd->cChannels)
            {
                DebugErr(DBF_ERROR, "mixerSetControlDetails: cChannels must be zero for custom controls.");
                return (MMSYSERR_INVALPARAM);
            }

            V_WPOINTER(pmxcd->paDetails, pmxcd->cbDetails, MMSYSERR_INVALPARAM);

            //
            //
            //
            if ((NULL != pmxcd->hwndOwner) && !IsWindow(pmxcd->hwndOwner))
            {
                DebugErr1(DBF_ERROR, "mixerSetControlDetails: hwndOwner must be a valid window handle (%.04Xh).", pmxcd->hwndOwner);
                return (MMSYSERR_INVALHANDLE);
            }
            break;

        default:
            DebugErr1(DBF_ERROR, "mixerSetControlDetails: invalid query flags (%.08lXh).",
                        MIXER_SETCONTROLDETAILSF_QUERYMASK & fdwDetails);
            return (MMSYSERR_INVALFLAG);
    }


    ClientUpdatePnpInfo();

    //
    //
    //
    fdwMxObjType = (MIXER_OBJECTF_TYPEMASK & fdwDetails);

    fResource = FALSE;

    AcquireHandleListResourceShared();
    
    //  Checking for the type of mixer object.  If it is a non-mixer type
    //  calling IMixerMesssageID (called by IMixerGetID) with the shared
    //  resource will deadlock.
    if ((MIXER_OBJECTF_MIXER  == fdwMxObjType) ||
        (MIXER_OBJECTF_HMIXER == fdwMxObjType))
    {
        if (BAD_HANDLE(hmxobj, TYPE_MIXER))
        {
            ReleaseHandleListResource();
        }
        else
        {
            fResource = TRUE;
        }
    }
    else
    {
        ReleaseHandleListResource();
    }
    
    mmr = IMixerGetID(hmxobj, &uMxId, NULL, fdwMxObjType);
    if (MMSYSERR_NOERROR != mmr)
    {
        if (fResource)
            ReleaseHandleListResource();
        return (mmr);
    }

    if ((MIXER_OBJECTF_MIXER  == fdwMxObjType) ||
        (MIXER_OBJECTF_HMIXER == fdwMxObjType))
    {
        //
        //  if a mixer device id was passed, then null hmx so we use the
        //  correct message sender below
        //
        if ((UINT_PTR)hmxobj == uMxId)
            hmxobj = NULL;
    }
    else
    {
        hmxobj = NULL;
    }

    //
    //
    //
    //
    if (NULL != hmxobj)
    {
        mmr = (MMRESULT)IMixerMessageHandle((HMIXER)hmxobj,
                                            MXDM_SETCONTROLDETAILS,
                                            (DWORD_PTR)pmxcd,
                                            fdwDetails);
    }
    else
    {
        mmr = (MMRESULT)IMixerMessageId(uMxId,
                                        MXDM_SETCONTROLDETAILS,
                                        (DWORD_PTR)pmxcd,
                                        fdwDetails);
    }

    return (mmr);
} // mixerSetControlDetails()


//--------------------------------------------------------------------------;
//
//  MMRESULT mixerDesertHandle
//
//  Description:
//      Cleans up the mixer handle and marks it as deserted.
//
//  Arguments:
//      HMIXER hmx:  Mixer handle.
//
//  Return (MMRESULT):  Error code.
//
//  History:
//      01/25/99    Fwong       Adding Pnp Support.
//
//--------------------------------------------------------------------------;

MMRESULT mixerDesertHandle
(
    HMIXER  hmx
)
{
    MMRESULT    mmr;
    PMIXERDEV   pmxdev;
    PMIXERDEV   pmxdevT;
    PMIXERDRV   pmxdrv;
    BOOL        fClose;

    V_HANDLE_ACQ(hmx, TYPE_MIXER, MMSYSERR_INVALHANDLE);

    ENTER_MM_HANDLE(hmx);
    ReleaseHandleListResource();

    if (IsHandleDeserted(hmx))
    {
        //  Handle has already been deserted...
        LEAVE_MM_HANDLE(hmx);
        return (MMSYSERR_NOERROR);
    }

    //  Marking handle as deserted
    SetHandleFlag(hmx, MMHANDLE_DESERTED);

    //
    //  remove the mixer handle from the linked list
    //

    MIXMGR_ENTER;

    pmxdev = (PMIXERDEV)hmx;
    pmxdrv = pmxdev->pmxdrv;

    if (pmxdev == gpMixerDevHeader)
    {
        gpMixerDevHeader = pmxdev->pmxdevNext;
    }
    else
    {
        for (pmxdevT = gpMixerDevHeader;
             pmxdevT && (pmxdevT->pmxdevNext != pmxdev);
             pmxdevT = pmxdevT->pmxdevNext)
            ;

        if (NULL == pmxdevT)
        {
            DebugErr1(DBF_ERROR,
                      "mixerDesertHandle: invalid mixer handle (%.04Xh).",
                      hmx);

            MIXMGR_LEAVE;
            LEAVE_MM_HANDLE(hmx);

            return (MMSYSERR_INVALHANDLE);
        }

        pmxdevT->pmxdevNext = pmxdev->pmxdevNext;
    }

    //
    // see if this is the last handle on this open instance
    //
    fClose = TRUE;
    if (gpMixerDevHeader)
    {
	    PMIXERDEV   pmxdevT2;
        for (pmxdevT2 = gpMixerDevHeader; pmxdevT2; pmxdevT2 = pmxdevT2->pmxdevNext)
        {
            if (pmxdevT2->pmxdrv != pmxdev->pmxdrv) continue;
            if (pmxdevT2->wDevice != pmxdev->wDevice) continue;
    	    fClose = FALSE;
    	    break;
        }
    }

    MIXMGR_LEAVE;

    if (fClose)
    {
        EnterCriticalSection(&pmxdev->pmxdrv->MixerCritSec);
        mmr = (*(pmxdrv->drvMessage))(pmxdev->wDevice, MXDM_CLOSE, pmxdev->dwDrvUser, 0L, 0L);
        LeaveCriticalSection(&pmxdev->pmxdrv->MixerCritSec);
        
        if (MMSYSERR_NOERROR != mmr)
        {
            //  Close message failed.
            //  Should we put the handle back in the list???
            LEAVE_MM_HANDLE(hmx);
            return mmr;
        }
    }

    LEAVE_MM_HANDLE(hmx);
    
    mregDecUsage(PTtoH(HMD, pmxdev->pmxdrv));

    return MMSYSERR_NOERROR;
} // mixerDesertHandle()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\mmiomisc.c ===
/* Copyright (c) 1991-1992 Microsoft Corporation */
/* mmiomisc.c
 *
 * Miscellaneous utility functions.
 *
 *      AsciiStrToUnicodeStr    Convert ASCII string Unicode
 *      CopyLPWSTRA             Convert Unicode string to ASCII
 *
 * See also WinCom, which defines:
 *
 *      lstrncpy        copy a string (up to n characters)
 *      lstrncat        concatenate strings (up to n characters)
 *      lstrncmp        compare strings (up to n characters)
 *      lmemcpy         copy a memory block
 *      hmemcpy         copy a huge memory block
 *      HPSTR           the type "char huge *"
 *      SEEK_SET/CUR/END constants used for seeking
 */


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "winmmi.h"
#include "mmioi.h"

/*--------------------------------------------------------------------*\
 * Function prototypes
\*--------------------------------------------------------------------*/
// extern int wcslen(LPCWSTR pwsz);

/**************************************************************************\
* AllocUnicodeStr
*
*
* Returns a UNICODE version of the given ASCII source string, or NULL if
* no storage is available.
* Users must call FreeUnicodeStr to free the allocated storage.
*
* 28-Apr-1992   StephenE    Created
\**************************************************************************/
LPWSTR AllocUnicodeStr( LPCSTR lpSourceStr )
{
    PBYTE   pByte;      // Ascii version of szFileName
    ULONG   cbDst;      // Length of lpSourceStr as a byte count

    cbDst = (strlen( lpSourceStr ) * sizeof(WCHAR)) + sizeof(WCHAR);

    pByte = HeapAlloc( hHeap, 0, cbDst );
    if ( pByte == (PBYTE)NULL ) {
        return (LPWSTR)NULL;
    }

    AsciiStrToUnicodeStr( pByte, pByte + cbDst, lpSourceStr );

    return (LPWSTR)pByte;
}
BOOL FreeUnicodeStr( LPWSTR lpStr )
{
    return HeapFree( hHeap, 0, (PBYTE)lpStr );
}

/**************************************************************************\
* AllocAsciiStr
*
*
* Returns a ASCII version of the given UNICODE source string, or NULL if
* no storage is available.
* Users must call FreeAsciiStr to free the allocated storage.
*
* 28-Apr-1992   StrphenE    Created
\**************************************************************************/
LPSTR AllocAsciiStr( LPCWSTR lpSourceStr )
{

    PBYTE   pByte;      // Ascii version of szFileName
    ULONG   cbDst;      // Length of lpSourceStr as a byte count

    cbDst = (wcslen( lpSourceStr ) * sizeof(WCHAR)) + sizeof(WCHAR);

    pByte = HeapAlloc( hHeap, 0, cbDst );
    if ( pByte == (PBYTE)NULL ) {
        return (LPSTR)NULL;
    }

    UnicodeStrToAsciiStr( pByte, pByte + cbDst, lpSourceStr );

    return (LPSTR)pByte;
}
BOOL FreeAsciiStr( LPSTR lpStr )
{
    return HeapFree( hHeap, 0, (PBYTE)lpStr );
}



/**************************************************************************\
* AsciiStrToUnicodeStr
*
* Translate ANSI 'psrc' to UNICODE 'pdst' without destination going beyond
* 'pmax'
*
* Return DWORD-aligned ptr beyond end of pdst, 0 if failed.
*
* 27-Aug-1991  IanJa     Created
\**************************************************************************/
PBYTE AsciiStrToUnicodeStr( PBYTE pdst, PBYTE pmax, LPCSTR psrc )
{
    int     cbSrc;
    ULONG   cbDst;

    cbSrc = strlen( psrc ) + sizeof(CHAR);

    /*
     * The destination UNICODE string will never be more than twice the
     * length of the ANSI source string.  (It may sometimes be less, but
     * it's not worth computing it exactly now).
     */
    if ((pdst + (cbSrc * sizeof(WCHAR))) <= pmax) {
        /*
         * RtlMultiByteToUnicodeN() returns the exact number of
         * destination bytes.
         */
        RtlMultiByteToUnicodeN( (LPWSTR)pdst,           // Unicode str
                                (ULONG)(pmax - pdst),   // max len of pdst
                                &cbDst,                 // bytes in unicode str
                                (PCHAR)psrc,            // Source string
                                cbSrc                   // bytes in source str
                              );

        return pdst + ((cbDst + 3) & ~3);
    }
    return 0;
}

/**************************************************************************\
* UnicodeStrToAsciiStr
*
* Translate UNICODE 'psrc' to ANSI 'pdst' without destination going beyond
* 'pmax'
*
* Return DWORD-aligned ptr beyond end of pdst, 0 if failed.
*
* 27-Aug-1991  IanJa     Created
\**************************************************************************/
PBYTE UnicodeStrToAsciiStr( PBYTE pdst, PBYTE pmax, LPCWSTR psrc)
{
    int     cbSrc;
    ULONG   cbDst;

    cbSrc = (wcslen(psrc) * sizeof(WCHAR)) + sizeof(WCHAR);

    /*
     * The destination ANSI string will never be longer than the UNICODE
     * source string (in bytes).  It is normally closer to half the length,
     * but due to the possibility of pre-composed characters, the upper
     * bound of the ANSI length is the UNICODE length (in bytes).
     */

    if ((pdst + cbSrc ) <= pmax) {
        /*
         * RtlUnicodeToMultiByteN() returns the exact number of
         * destination bytes.
         */
        RtlUnicodeToMultiByteN( (LPSTR)pdst,  // ansi string
                                (ULONG)(pmax - pdst),   // max len of pdst
                                &cbDst,       // bytes copied
                                (LPWSTR)psrc,
                                cbSrc);

        return pdst + ((cbDst + 3) & ~3);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\mmio.c ===
/* Copyright (c) 1991-1999 Microsoft Corporation */
/*-------------------------------------------------------------------*\
 *
 * mmio.c
 *
 * Basic MMIO functions.
 *
\*-------------------------------------------------------------------*/

/*--------------------------------------------------------------------*/
/* Revision history:
 * LaurieGr: Jan 92 Ported from win16.  Source tree fork, not common code.
 * StephenE: Apr 92 Enabled UNICODE.
 */
/*--------------------------------------------------------------------*/


/*--------------------------------------------------------------------*/
/* Implementation notes:
 *
 * An HMMIO is in fact a PMMIO i.e. a pointer to a MMIOINFO.
 * This causes the code to be littered with casts.
 * Whoever exported MMIOINFO should learn about encapsulation and
 * all that stuff.  sigh.
 *
 * The "current disk offset" is the disk offset (i.e. the location
 * in the disk file) that the next MMIOM_READ or MMIOM_WRITE will
 * read from or write to.  The I/O procedure maintains the
 * <lDiskOffset> field of the file's MMIO structure so that
 * <lDiskOffset> is equal to the current disk offset.
 *
 * The "current buffered offset" is the disk offset that the next
 * mmioRead() or mmioWrite() call would read from or write to.
 * The current buffered offset is defined as
 *
 *  <lBufOffset> + (<pchNext> - <pchBuffer>)
 *
 * since <lBufOffset> is the disk offset of the start of the buffer
 * and <pchNext> corresponds to the current buffered offset.
 *
 * If the file is unbuffered, then <pchBuffer>, <pchNext>,
 * <pchEndRead> and <pchEndWrite> will always be NULL, and
 * <lBufOffset> will always be considered the "current buffered
 * offset", i.e. mmioRead() and mmioWrite() will read/write
 * at this offset.
 *
 *
 * Except right at the beginning of mmioOpen(), the MMIO_ALLOCBUF
 * flag is set if and only if the pchBuffer field points to a block
 * of global memory that MMIO has allocated.
 */
/*--------------------------------------------------------------------*/

#include "winmmi.h"
#include "mmioi.h"


/*--------------------------------------------------------------------*\
 * Local function prototypes
\*--------------------------------------------------------------------*/
static void NEAR PASCAL SetIOProc( LPCWSTR szFileName, LPMMIOINFO lpmmio);
static LPMMIOPROC NEAR PASCAL RemoveIOProc(FOURCC fccIOProc, HANDLE htask);
static LONG NEAR PASCAL mmioDiskIO(PMMIO pmmio, UINT uMsg, LPSTR pch, LONG cch);
static UINT NEAR PASCAL mmioExpandMemFile(PMMIO pmmio, LONG lExpand);
static LPMMIOPROC mmioInternalInstallIOProc( FOURCC fccIOProc,
                                             LPMMIOPROC pIOProc,
                                             DWORD dwFlags);

/*--------------------------------------------------------------------*/
/* The I/O procedure map is a linked list of IOProcMapEntry structures.
 * The head of the list, <gIOProcMapHead> is a pointer node to the last
 * entry registered.  The first few elements of the list are the predefined
 * global IO procedures below -- these all have <hTask> equal to NULL so
 * that no task can unregister them.
 *
 */

typedef struct IOProcMapEntryTag
{
        FOURCC          fccIOProc;      // ID of installed I/O procedure
        LPMMIOPROC      pIOProc;        // I/O procedure address
        HANDLE          hTask;          // task that called mmioRegisterIOProc()
        struct IOProcMapEntryTag *pNext;  // pointer to next IOProc entry
} IOProcMapEntry, *pIOProcMapEntry;

// MMIOPROC is defined in the public MMSYSTEM.H
// typedef LONG (APIENTRY MMIOPROC)(LPSTR lpmmioinfo, UINT uMsg, LONG lParam1, LONG lParam2);

MMIOPROC mmioDOSIOProc, mmioMEMIOProc; // standard I/O procedures

static IOProcMapEntry gIOProcMaps[] = {
    { FOURCC_DOS, mmioDOSIOProc, NULL,  &gIOProcMaps[1] },
    { FOURCC_MEM, mmioMEMIOProc, NULL,  NULL }
};

//
// Global head of list
//

static pIOProcMapEntry gIOProcMapHead = gIOProcMaps;

#ifdef DUMPIOPROCLIST
/* debug dump of ioproclist */
static void DumpIOProcList(void)
{  pIOProcMapEntry pph;

   dprintf(("gIOProcMapHead= %8x\n",gIOProcMapHead ));
   for (pph = gIOProcMapHead;pph ;pph=pph->pNext)
   {  dprintf(( "fourcc=%c%c%c%c pioproc=%8x hTask=%8x\n"
             , pph->fccIOProc/16777216
             , (pph->fccIOProc/65536)%256
             , (pph->fccIOProc/256)%256
             , (pph->fccIOProc)%256
             , pph->pIOProc
             , pph->hTask
             ));
   }
} /* DumpIOProcList */
#endif


/* Call the IOProc in the info structure and return the result.
   Take due account of whether it is a 16 or 32 bit IOProc.
*/
static LRESULT IOProc(LPMMIOINFO lpmmioinfo, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
{
    /*  just pass the call on */
    return ((LPMMIOPROC)(lpmmioinfo->pIOProc)) ((LPSTR)lpmmioinfo, uMsg, lParam1, lParam2);
} /* IOProc */

/*--------------------------------------------------------------------*/
/* @doc INTERNAL

@func   LPMMIOPROC | FindIOProc | This function locates the IOProcMapEntry
    for a previously installed IO procedure .
*/
/*--------------------------------------------------------------------*/
static pIOProcMapEntry
                  FindIOProc(FOURCC fccIOProc, HANDLE htask)
{
    IOProcMapEntry *pEnt;       // an entry in linked list

    /* walk through the linked list, first looking for an entry with
     * identifier <fccIOProc> that was added by the current task, then
     * looking for global entries.
     */

    for (pEnt = gIOProcMapHead; pEnt; pEnt = pEnt->pNext)
        if ((pEnt->fccIOProc == fccIOProc) && (pEnt->hTask == htask))
            return pEnt;

    for (pEnt = gIOProcMapHead; pEnt; pEnt = pEnt->pNext)
        if ( (pEnt->fccIOProc == fccIOProc)
                                           // ?? && (pEnt->hTask ==NULL)  ??
           )
            return pEnt;

    return NULL;
}

/*--------------------------------------------------------------------*/
/* @doc INTERNAL

@func   LPMMIOPROC | RemoveIOProc | This function removes previously installed
    IO procedure.
*/
/*--------------------------------------------------------------------*/
static LPMMIOPROC PASCAL NEAR
                  RemoveIOProc(FOURCC fccIOProc, HANDLE htask)
{
    IOProcMapEntry *pEnt;       // an entry in linked list
    IOProcMapEntry *pEntPrev;   // the entry before <pEnt>

    /* walk through the linked list, looking for an entry with
     * identifier <fccIOProc> that was added by the current task
     */
    for ( pEntPrev = NULL, pEnt = gIOProcMapHead
        ; pEnt
        ; pEntPrev = pEnt, pEnt = pEnt->pNext
        )
        if ((pEnt->fccIOProc == fccIOProc) && (pEnt->hTask == htask)) {
            LPMMIOPROC  pIOProc;

            pIOProc = pEnt->pIOProc;
            if (pEntPrev)
                pEntPrev->pNext = pEnt->pNext;
            else
                gIOProcMapHead = pEnt->pNext;
            FreeHandle((HMMIO) pEnt);
            return pIOProc;
        }
    return NULL;
}

/*--------------------------------------------------------------------*/
/* @doc INTERNAL

@func   void | SetIOProc | This function sets the physical IO procedure
    based on either the file name or the parameters within the
    <p lpmmioinfo> structure passed.

@parm   LPCWSTR | szFilename | Specifies a pointer to a string
containing the filename of the file to open. If no I/O procedure is

@parm   LPMMIOINFO | lpmmioinfo | Specifies a pointer to an
    <t MMIOINFO> structure containing extra parameters used by
    <f SetIOProc> in determining the IO procedure to use.  The
    <e MMIOINFO.pIOProc> element is set to the procedure found.

@rdesc  Nothing.
*/
/*--------------------------------------------------------------------*/
static void NEAR PASCAL
            SetIOProc( LPCWSTR szFileName, LPMMIOINFO lpmmio)
{
    IOProcMapEntry *pEnt;       // the entry in linked list

    /* If the IOProc is not given, see if the file name implies that
     * <szFileName> is either a RIFF compound file or some kind of
     * other registered storage system -- look for the last CFSEPCHAR in
     * the name, e.g. '+' in "foo.bnd+bar.hlp+blorg.dib", and figure
     * that the IOProc ID is the extension of the compound file name,
     * e.g. the extension of "foo.bnd+bar.hlp", i.e. 'HLP '.
     *
     * Alternatively, if <szFileName> is NULL, then assume that
     * <lpmmio->adwInfo[0]> is a DOS file handle.
    */
    if (lpmmio->pIOProc == NULL)
    {
        if (lpmmio->fccIOProc == 0)
        {
            if (szFileName != NULL)
            {
                LPWSTR   pch;

                /* see if <szFileName> contains CFSEPCHAR */
                if ((pch = wcsrchr(szFileName, CFSEPCHAR)) != 0)
                {
                    /* find the extension that precedes CFSEPCHAR,
                     * e.g. "hlp" in "foo.bnd+bar.hlp+blorg.dib"
                    */
                    while (  (pch > szFileName)
                          && (*pch != '.')
                          && (*pch != ':')
                          && (*pch != '\\')
                          )
                        pch--;
                    if (*pch == '.')
                    {
                        WCHAR    aszFour[sizeof(FOURCC)+1];
                        int i;

                        for (i = 0, pch++; i < sizeof(FOURCC); i++)
                            if (*pch == CFSEPCHAR)
                                aszFour[i] = (WCHAR)0;
                            else
                                aszFour[i] = *pch++;
                        aszFour[sizeof(FOURCC)] = (WCHAR)0;
                        lpmmio->fccIOProc
                                 = mmioStringToFOURCCW(aszFour, MMIO_TOUPPER);
                    }
                }
            }
            /* if the caller didn't specify an IOProc, and the code above
             * didn't determine an IOProc ID, then the default is the DOS
             * IOProc.
            */
            if (lpmmio->fccIOProc == 0)
                lpmmio->fccIOProc = FOURCC_DOS;
        }

        /* unless an IOProc address is specified explicitly, look up the
         * IOProc in the global IOProc ID-to-address table -- the default
         * is 'DOS' since we'll assume that custom storage system I/O
         * procedures would have been installed
        */
        pEnt = FindIOProc( lpmmio->fccIOProc
                         ,   lpmmio->htask
                           ? lpmmio->htask
                           : GetCurrentTask()
                         );
        if (pEnt && pEnt->pIOProc) {
            lpmmio->pIOProc = pEnt -> pIOProc;
        }
        else {
            lpmmio->pIOProc = mmioDOSIOProc;
            lpmmio->dwReserved1 = 0;
        }
    }
}


/*--------------------------------------------------------------------*/
/* @doc INTERNAL

@func   void | mmioCleanupIOProcs | removes from the linked list entries
    installed with the given task handle

@parm   HANDLE | hTask | Specifies the task to clean up for

@rdesc  Nothing.

@comm  This will only be called to clean up a WOW task.
*/
/*--------------------------------------------------------------------*/
void mmioCleanupIOProcs(HANDLE hTask)
{
     IOProcMapEntry *pEnt;
     IOProcMapEntry *pEntPrev;

     for (pEntPrev = NULL, pEnt = gIOProcMapHead; pEnt;) {

        if (pEnt->hTask == hTask) {
            dprintf1(("MMIOPROC handle (%04X) not closed.", pEnt));
            if (pEntPrev) {
                pEntPrev->pNext = pEnt->pNext;
                FreeHandle((HMMIO)pEnt);
                pEnt = pEntPrev->pNext;
            } else {
                gIOProcMapHead = pEnt->pNext;
                FreeHandle((HMMIO)pEnt);
                pEnt = gIOProcMapHead;
            }
        } else {
            pEntPrev = pEnt;
            pEnt = pEnt->pNext;
        }
     }
}



/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    UINT | mmioRename | This function renames the specified file.

@parm   LPCTSTR | szFilename | Specifies a pointer to a string
containing the filename of the file to rename.

@parm   LPCTSTR | szNewFileName | Specifies a pointer to a string
containing the new filename.

@parm   LPMMIOINFO | lpmmioinfo | Specifies a pointer to an
    <t MMIOINFO> structure containing extra parameters used by
    <f mmioRename>.

    If <p lpmmioinfo> is not NULL, all unused fields of the
    <t MMIOINFO> structure it references must be set to zero, including the
    reserved fields.

@parm   DWORD | dwRenameFlags | Specifies option flags for the rename
    operation.  This should be set to zero.

@rdesc  The return value is zero if the file was renamed.  Otherwise, the
return value is an error code returned from <f mmioRename> or from the I/O
procedure.
*/
/*--------------------------------------------------------------------*/
UINT APIENTRY
     mmioRenameW( LPCWSTR        szFileName
                , LPCWSTR        szNewFileName
                , LPCMMIOINFO    lpmmioinfo
                , DWORD          fdwRename
                )
{
    MMIOINFO    mmioinfo;

    ZeroMemory( &mmioinfo, sizeof( MMIOINFO ) );

    V_RPOINTER0(lpmmioinfo, sizeof(MMIOINFO), MMSYSERR_INVALPARAM);
    if (lpmmioinfo) {
        V_CALLBACK0((FARPROC)lpmmioinfo->pIOProc, MMSYSERR_INVALPARAM);
        mmioinfo = *lpmmioinfo;
    }

    SetIOProc(szFileName, &mmioinfo);

    if ( (mmioinfo.dwFlags & MMIO_UNICODEPROC )
      || (mmioinfo.pIOProc == mmioDOSIOProc )     // or the DOS file IO Proc
      || (mmioinfo.pIOProc == mmioMEMIOProc ) ) { // or a memory file IO Proc

        /*------------------------------------------------------------*\
         * We have an unicode IO Proc so use the given file names
         * without any conversion.
        \*------------------------------------------------------------*/
        return (UINT)IOProc( &mmioinfo, MMIOM_RENAME,
                       (LPARAM)szFileName, (LPARAM)szNewFileName );
    } else {

        UINT    uiRc;
        LPSTR   pAsciiFileName;      // Ascii version of szFileName
        LPSTR   pAsciiNewFileName;   // Ascii version of szNewFileName

        /*------------------------------------------------------------*\
         * We have an ascii IO Proc so convert the given file names
         * into ascii.
        \*------------------------------------------------------------*/
        pAsciiFileName = AllocAsciiStr( szFileName );
        if ( pAsciiFileName == (LPSTR)NULL ) {
            return MMIOERR_OUTOFMEMORY;
        }

        pAsciiNewFileName = AllocAsciiStr( szNewFileName );
        if ( pAsciiNewFileName == (LPSTR)NULL ) {
            FreeAsciiStr( pAsciiFileName );
            return MMIOERR_OUTOFMEMORY;
        }

        uiRc = (UINT)IOProc( &mmioinfo,
                       MMIOM_RENAME,
                       (LPARAM)pAsciiFileName,
                       (LPARAM)pAsciiNewFileName );

        FreeAsciiStr( pAsciiFileName );
        FreeAsciiStr( pAsciiNewFileName );

        return uiRc;
    }

}

UINT APIENTRY
     mmioRenameA( LPCSTR        szFileName
                , LPCSTR        szNewFileName
                , LPCMMIOINFO   lpmmioinfo
                , DWORD         fdwRename
                )
{
    MMIOINFO    mmioinfo;
    LPWSTR      pUnicodeFileName;
    LPWSTR      pUnicodeNewFileName;
    UINT        uiRc;

    ZeroMemory( &mmioinfo, sizeof( MMIOINFO ) );

    V_RPOINTER0(lpmmioinfo, sizeof(MMIOINFO), MMSYSERR_INVALPARAM);
    if (lpmmioinfo) {
        V_CALLBACK0((FARPROC)lpmmioinfo->pIOProc, MMSYSERR_INVALPARAM);
        mmioinfo = *lpmmioinfo;
    }

    /*----------------------------------------------------------------*\
     * SetIOProc only works with unicode strings, therefore we always
     * have to convert szFileName to unicode, so:
     * Allocate some storage to hold the unicode version of szFileName.
     * Do the acsii to unicode conversion .
     * Call SetIOProc
    \*----------------------------------------------------------------*/
    pUnicodeFileName = AllocUnicodeStr( szFileName );
    if ( pUnicodeFileName == (LPWSTR)NULL ) {
        return MMIOERR_OUTOFMEMORY;
    }
    SetIOProc( pUnicodeFileName, &mmioinfo );

    if ( (mmioinfo.dwFlags & MMIO_UNICODEPROC )
      || (mmioinfo.pIOProc == mmioDOSIOProc )     // or the DOS file IO Proc
      || (mmioinfo.pIOProc == mmioMEMIOProc ) ) { // or a memory file IO Proc

        /*------------------------------------------------------------*\
         * We have a unicode IO Proc, this means that we have to
         * convert szNewFileName to unicode too.
        \*------------------------------------------------------------*/
        pUnicodeNewFileName = AllocUnicodeStr( szNewFileName );
        if ( pUnicodeNewFileName == (LPWSTR)NULL ) {
            FreeUnicodeStr( pUnicodeFileName );
            return MMIOERR_OUTOFMEMORY;
        }

        uiRc = (UINT)IOProc( &mmioinfo,
                       MMIOM_RENAME,
                       (LPARAM)pUnicodeFileName,
                       (LPARAM)pUnicodeNewFileName );

        FreeUnicodeStr( pUnicodeNewFileName );

    } else {

        /*------------------------------------------------------------*\
         * We have an ascii IO Proc so use the given file names
         * without any conversion.
        \*------------------------------------------------------------*/
        uiRc = (UINT)IOProc( &mmioinfo, MMIOM_RENAME,
                       (LPARAM)szFileName, (LPARAM)szNewFileName);
    }

    FreeUnicodeStr( pUnicodeFileName );
    return uiRc;
}

/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    HMMIO | mmioOpen | This function opens a file for unbuffered
    or buffered I/O. The file can be a DOS file, a memory file, or an
    element of a custom storage system.

@parm   LPTSTR | szFilename | Specifies a pointer to a string
containing the filename of the file to open. If no I/O procedure is
specified to open the file, then the filename determines how the file
is opened, as follows:

    -- If the filename does not contain "+", then it is assumed
    to be the name of a DOS file.

    -- If the filename is of the form "foo.ext+bar", then the
    extension "EXT " is assumed to identify an installed I/O procedure
    which is called to perform I/O on the file (see <f mmioInstallIOProc>).

    -- If the filename is NULL and no I/O procedure is given, then
    <e MMIOINFO.adwInfo[0]> is assumed to be the DOS file handle
    of a currently open file.

    The filename should not be longer than 128 bytes, including the
    terminating NULL.

    When opening a memory file, set <p szFilename> to NULL.

@parm   LPMMIOINFO | lpmmioinfo | Specifies a pointer to an
    <t MMIOINFO> structure containing extra parameters used by
    <f mmioOpen>. Unless you are opening a memory file, specifying the
    size of a buffer for buffered I/O, or specifying an uninstalled I/O
    procedure to open a file, this parameter should be NULL.

    If <p lpmmioinfo> is not NULL, all unused fields of the
    <t MMIOINFO> structure it references must be set to zero, including the
    reserved fields.

@parm   DWORD | dwOpenFlags | Specifies option flags for the open
    operation. The MMIO_READ, MMIO_WRITE, and MMIO_READWRITE flags are
    mutually exclusive--only one should be specified. The MMIO_COMPAT,
    MMIO_EXCLUSIVE, MMIO_DENYWRITE, MMIO_DENYREAD, and MMIO_DENYNONE flags
    are DOS file-sharing flags, and can only be used after the DOS
    command SHARE has been executed.

    @flag   MMIO_READ | Opens the file for reading only.  This is the
        default, if MMIO_WRITE and MMIO_READWRITE are not specified.

    @flag   MMIO_WRITE | Opens the file for writing.  You should not
        read from a file opened in this mode.

    @flag   MMIO_READWRITE | Opens the file for both reading and writing.

    @flag   MMIO_CREATE | Creates a new file.
        If the file already exists, it is truncated to zero length.
        For memory files, MMIO_CREATE indicates the end of the file
        is initially at the start of the buffer.

    @flag   MMIO_DELETE | Deletes a file. If this flag is specified,
        <p szFilename> should not be NULL. The return
        value will be TRUE (cast to HMMIO) if the file was deleted
        successfully, FALSE otherwise.  Do not call <f mmioClose>
        for a file that has been deleted.  If this flag is specified,
        all other file opening flags are ignored.

    @flag   MMIO_PARSE | Creates a fully qualified filename from the path
        specified in <p szFileName>. The fully qualified filename is
        placed back into <p szFileName>. The return value
        will be TRUE (cast to HMMIO) if the qualification was
        successful, FALSE otherwise. The file is not opened, and the function
        does not return a valid MMIO file handle, so do not attempt to
        close the file. If this flag is specified, all other file
        opening flags are ignored.

    @flag   MMIO_EXIST | Determines whether the specified file exists
        and creates a fully qualified filename from the path
        specified in <p szFileName>. The fully qualified filename is
        placed back into <p szFileName>. The return value
        will be TRUE (cast to HMMIO) if the qualification was
        successful and the file exists, FALSE otherwise. The file is
        not opened, and the function does not return a valid MMIO file
        handle, so do not attempt to close the file.

    @flag   MMIO_ALLOCBUF | Opens a file for buffered I/O.
        To allocate a buffer larger or smaller than the default
        buffer size (8K), set the <e MMIOINFO.cchBuffer> field of the
        <t MMIOINFO> structure to the desired buffer size. If
        <e MMIOINFO.cchBuffer> is zero, then the default buffer size
        is used. If you are providing your own I/O buffer, then the
        MMIO_ALLOCBUF flag should not be used.

    @flag   MMIO_COMPAT | Opens the file with compatibility mode,
        allowing any process on a given machine to open the file
        any number of times.  <f mmioOpen> fails if the file has
        been opened with any of the other sharing modes.

    @flag   MMIO_EXCLUSIVE | Opens the file with exclusive mode,
        denying other processes both read and write access to the file.
        <f mmioOpen> fails if the file has been opened in any other
        mode for read or write access, even by the current process.

    @flag   MMIO_DENYWRITE | Opens the file and denies other
        processes write access to the file.  <f mmioOpen> fails
        if the file has been opened in compatibility or for write
        access by any other process.

    @flag   MMIO_DENYREAD | Opens the file and denies other
        processes read access to the file.  <f mmioOpen> fails if the
        file has been opened in compatibility mode or for read access
        by any other process.

    @flag   MMIO_DENYNONE | Opens the file without denying other
        processes read or write access to the file.  <f mmioOpen>
        fails if the file has been opened in compatibility mode
        by any other process.

    @flag   MMIO_GETTEMP | Creates a temporary filename, optionally
        using the parameters passed in <p szFileName> to determine
        the temporary name. For example, you can specify "C:F" to
        create a temporary file residing on drive C, starting with
        letter "F". The resulting filename is placed in the buffer
        pointed to by <p szFileName>.  The return value will be TRUE
        (cast to HMMIO) if the temporary filename was created successfully,
        FALSE otherwise. The file is
        not opened, and the function does not return a valid MMIO file
        handle, so do not attempt to close the file.
        This flag overrides all other flags.

@rdesc  The return value is a handle to the opened file. This handle
    is not a DOS file handle--do not use it with any file I/O functions
    other than MMIO functions.

    If the file cannot be opened, the return value is NULL.  If
    <p lpmmioinfo> is not NULL, then its <e MMIOINFO.wErrorRet> field
    will contain extended error information returned by the I/O
    procedure.

@comm   If <p lpmmioinfo> references an <t MMIOINFO> structure, set
up the fields as described below. All unused fields must be set to
zero, including reserved fields.

-- To request that a file be opened with an installed I/O
procedure, set the <e MMIOINFO.fccIOProc> field
to the four-character code of the I/O procedure,
and set the <e MMIOINFO.pIOProc> field to NULL.

-- To request that a file be opened with an uninstalled I/O procedure,
set the <e MMIOINFO.pIOProc> field to
point to the I/O procedure, and set <e MMIOINFO.fccIOProc> to NULL.

-- To request that <f mmioOpen> determine which I/O procedure to use
to open the file based on the filename contained in <p szFilename>,
set both <e MMIOINFO.fccIOProc> and <e MMIOINFO.pIOProc> to NULL.
This is the default behavior if no <t MMIOINFO> structure is specified.

-- To open a memory file using an internally allocated and managed
buffer, set the <e MMIOINFO.pchBuffer> field to NULL,
<e MMIOINFO.fccIOProc> to FOURCC_MEM,
<e MMIOINFO.cchBuffer> to the initial size of the buffer, and
<e MMIOINFO.adwInfo[0]> to the incremental expansion size of the
buffer. This memory file will automatically be expanded in increments of
<e MMIOINFO.adwInfo[0]> bytes when necessary. Specify the MMIO_CREATE
flag for the <p dwOpenFlags> parameter to initially set the end of
the file to be the beginning of the buffer.

-- To open a memory file using a caller-supplied buffer, set
the <e MMIOINFO.pchBuffer> field to point to the memory buffer,
<e MMIOINFO.fccIOProc> to FOURCC_MEM,
<e MMIOINFO.cchBuffer> to the size of the buffer, and
<e MMIOINFO.adwInfo[0]> to the incremental expansion size of the
buffer. The expansion size in <e MMIOINFO.adwInfo[0]> should only
be non-zero if <e MMIOINFO.pchBuffer> is a pointer obtained by calling
<f GlobalAlloc> and <f GlobalLock>, since <f GlobalReAlloc> will be called to
expand the buffer.  In particular, if <e MMIOINFO.pchBuffer> points to a
local or global array, a block of memory in the local heap, or a block
of memory allocated by <f GlobalDosAlloc>, <e MMIOINFO.adwInfo[0]> must
be zero.
Specify the MMIO_CREATE flag for the <p dwOpenFlags> parameter to
initially set the end of the file to be the beginning of the buffer;
otherwise, the entire block of memory will be considered readable.

-- To use a currently open DOS file handle with MMIO, set the
<e MMIOINFO.fccIOProc> field to FOURCC_DOS,
<e MMIOINFO.pchBuffer> to NULL, and <e MMIOINFO.adwInfo[0]> to the
DOS file handle.  Note that offsets within the file will be relative to
the beginning of the file, and will not depend on the DOS file position
at the time <f mmioOpen> is called; the initial MMIO offset will be the same
as the DOS offset when <f mmioOpen> is called.
Later, to close the MMIO file handle without closing the DOS
file handle, pass the MMIO_FHOPEN flag to <f mmioClose>.

You must call <f mmioClose> to close a file opened with <f mmioOpen>.
Open files are not automatically closed when an application exits.

@xref   mmioClose
*/

/* these are the changes to mmioOpen() to support compound files... */

/* @doc CFDOC

@api    HMMIO | mmioOpen | ...The file can be a DOS file, a memory file,
    an element of a RIFF compound file...

@parm   LPTSTR | szFilename | ...

    -- If <p szFilename> is of the form "foo+bar", then <f mmioOpen>
    opens the compound file element named "bar" that is stored inside
    the RIFF compound file named "foo".

    -- If <p szFilename> is of the form "foo.ext+bar", then the
    extension "ext" is assumed to identify the installed I/O procedure
    (see <f mmioInstallIOProc>).  The extension "bnd", and any extensions
    that have not been installed, are assumed to refer to a RIFF compound
    file.

@parm   LPMMIOINFO | lpmmioinfo | ...

@parm   DWORD | dwOpenFlags | ...

@rdesc  ...

@comm   ...

    The following I/O procedure identifiers (type FOURCC) are predefined:

    ...

    FOURCC_BND: <p szFilename> is assumed to be the name of
    a RIFF compound file element, and <p adwInfo[0]> should
    contain the HMMCF of the compound file.  Alternatively,
    <p szFilename> can include the name of the compound file
    (e.g. "foo.bnd+bar.dib" as described above), and <p adwInfo[0]>
    should be NULL, to automatically open the compound file.

    ...

    The easy way to open an element of a RIFF compound file: just
    include the name of the compound file in <p szFilename> preceded
    by a "+" as described above.  For example, opening
    "c:\data\bar.bnd+blorg.dib" opens the compound file element
    named "blorg.dib" in the compound file "c:\data\bar.bnd".
    <p lpmmioinfo> can be null in this case -- set <p dwOpenFlags>
    as described above.  You can use this same method to open an
    element of a custom storage system, if the file extension of the
    compound file ("bnd" in the above example) corresponds to an
    installed I/O procedure -- see <f mmioInstallIOProc> for details.

    To open an element of a RIFF compound file that was opened using
    <f mmioCFAccess> or <f mmioCFOpen>: set <p szFilename>
    to be the name of the compound file element; set <p fccIOProc>
    to FOURCC_BND; set <p adwInfo[0]> to the HMMCF of the open compound
    file; set <p dwOpenFlags> and <p cchBuffer> as described above;
    set all other fields of <p lpmmioinfo> to zero.

    ...
*/
/*--------------------------------------------------------------------*/
HMMIO APIENTRY
      mmioOpenW( LPWSTR szFileName, LPMMIOINFO lpmmioinfo, DWORD dwOpenFlags )
{
    PMMIO       pmmio;      // MMIO status block
    LPSTR       hpBuffer;
    UINT        w;          // an MMRESULT or a LRESULT from an IOPROC

    V_FLAGS(dwOpenFlags, MMIO_OPEN_VALID, mmioOpen, NULL);
    V_WPOINTER0(lpmmioinfo, sizeof(MMIOINFO), NULL);

    if (lpmmioinfo) {
        lpmmioinfo->wErrorRet = 0;
        V_CALLBACK0((FARPROC)lpmmioinfo->pIOProc, NULL);
    }

    /* allocate MMIO status information block */
    if ( (pmmio = (PMMIO)(NewHandle(TYPE_MMIO, NULL, sizeof(MMIOINFO)))) == NULL)
    {
        if (lpmmioinfo) {
            lpmmioinfo->wErrorRet = MMIOERR_OUTOFMEMORY;
        }
        return NULL;
    }

    //  Implicitly acquired by NewHandle()
    ReleaseHandleListResource();

    /*----------------------------------------------------------------*\
     * NewHandle does not zero the allocated storage so we had better do
     * it now.
    \*----------------------------------------------------------------*/
    ZeroMemory( pmmio, sizeof(MMIOINFO) );

    /* if user supplied <lpmmioinfo>, copy it to <pmmio> */
    if (lpmmioinfo != NULL) {
        *pmmio = *lpmmioinfo;
    }

    /* <dwOpenFlags> always takes precedence over contents of <pmmio> */
    pmmio->dwFlags = dwOpenFlags;
    pmmio->hmmio = ((HMMIO)pmmio);

    /* MMIO_ALLOCBUF in the flags means that the user wants a buffer
     * allocated for buffered I/O, but after this point it means that
     * a buffer *was* allocated, so turn off the flag until the buffer
     * is actually allocated (which is done by mmioSetBuffer() below)
     */
    if (pmmio->dwFlags & MMIO_ALLOCBUF)
    {
        /* if a buffer size is not specified, use the default */
        if (pmmio->cchBuffer == 0) {
            pmmio->cchBuffer = MMIO_DEFAULTBUFFER;
        }
        pmmio->dwFlags &= ~MMIO_ALLOCBUF;
    }

    /* Set the pIOProc function as determined by the file name or the
     * parameters in the pmmio structure.
     */
    SetIOProc(szFileName, pmmio);

    /* The pmmio structure hasn't been set up for buffering, so we must
     * explicitly make sure that pchBuffer is NULL.
     */
    hpBuffer = pmmio->pchBuffer;
    pmmio->pchBuffer = NULL;

    /* set up buffered I/O however the user requested it */
    w = mmioSetBuffer(((HMMIO)pmmio), hpBuffer, pmmio->cchBuffer, 0);
    if (w)
    {
        if (lpmmioinfo) {
            lpmmioinfo->wErrorRet = w;
        }
        FreeHandle(((HMMIO)pmmio));
        return NULL;
    }

    if ( (pmmio->dwFlags & MMIO_UNICODEPROC)    // a Unicode IO Proc
      || (pmmio->pIOProc == mmioDOSIOProc )     // or the DOS file IO Proc
      || (pmmio->pIOProc == mmioMEMIOProc ) ) { // or a memory file IO Proc

        /* let the I/O procedure open/delete/qualify the file */
        w = (UINT)IOProc( pmmio, MMIOM_OPEN, (LPARAM)szFileName, 0L );

    } else {

        if (NULL == szFileName) {

            w = (UINT)IOProc( pmmio,
                        MMIOM_OPEN,
                        (LPARAM)NULL,
                        0L );

        } else {
            LPSTR   lpAsciiFileName;  // ascii version of szFileName

            /*------------------------------------------------------------*\
            * We have an ascii IO Proc so convert the given file name
            * into ascii.
            \*------------------------------------------------------------*/
            lpAsciiFileName = AllocAsciiStr( szFileName );
            if ( lpAsciiFileName == (LPSTR)NULL ) {
                if (lpmmioinfo) {
                    lpmmioinfo->wErrorRet = MMIOERR_OUTOFMEMORY;
                }
                FreeHandle( (HMMIO)pmmio );
                return NULL;
            }

            /*------------------------------------------------------------*\
            * Call the IO proc and then free the allocated unicode
            * filename storage.
            \*------------------------------------------------------------*/
            w = (UINT)IOProc( pmmio,
                        MMIOM_OPEN,
                        (LPARAM)lpAsciiFileName,
                        0L );

            FreeAsciiStr( lpAsciiFileName );
        }
    }

    /* If this is non-zero, return it to the user */
    if (w != 0)
    {
        if (lpmmioinfo != NULL) {
            lpmmioinfo->wErrorRet = w;
        }
        FreeHandle(((HMMIO)pmmio));
        return NULL;
    }

    if (pmmio->dwFlags & (MMIO_DELETE| MMIO_PARSE| MMIO_EXIST| MMIO_GETTEMP))
    {
        /* if the file is being deleted/parsed/name gotten, exit
         * QUICKLY because the file handle (or whatever) in <pmmio>
         * is not valid.
         */
        mmioSetBuffer(((HMMIO)pmmio), NULL, 0L, 0);
        FreeHandle(((HMMIO)pmmio));
        return (HMMIO) TRUE;
    }

    /* the initial "current buffered offset" will be equal to the initial
     * "current disk offset"
     */
    pmmio->lBufOffset = pmmio->lDiskOffset;

    return ((HMMIO)pmmio);
}

HMMIO APIENTRY
      mmioOpenA( LPSTR szFileName, LPMMIOINFO lpmmioinfo, DWORD dwOpenFlags )
{
    PMMIO       pmmio;          // MMIO status block
    LPSTR       hpBuffer;
    UINT        w;              // an MMRESULT or a LRESULT from an IOPROC
    LPWSTR      lpUnicodeName;  // Unicode version of szFileName
    WCHAR       UnicodeBuffer[ MAX_PATH ];


    V_FLAGS(dwOpenFlags, MMIO_OPEN_VALID, mmioOpen, NULL);
    V_WPOINTER0(lpmmioinfo, sizeof(MMIOINFO), NULL);

    if (lpmmioinfo) {
        lpmmioinfo->wErrorRet = 0;
        V_CALLBACK0((FARPROC)lpmmioinfo->pIOProc, NULL);
    }

    /*----------------------------------------------------------------*\
     * Don't convert szFilename if it does not point to anything
    \*----------------------------------------------------------------*/
    if ( szFileName != (LPSTR)NULL ) {

        /*----------------------------------------------------------------*\
         * Convert the Ascii szFileName to Unicode
        \*----------------------------------------------------------------*/
        AsciiStrToUnicodeStr( (PBYTE)UnicodeBuffer,
                              (PBYTE)UnicodeBuffer + (MAX_PATH * sizeof(WCHAR)),
                              szFileName );
        lpUnicodeName = UnicodeBuffer;

    } else {
        lpUnicodeName = (LPWSTR)NULL;
    }


    /* allocate MMIO status information block */
    if ( (pmmio = (PMMIO)(NewHandle(TYPE_MMIO, NULL, sizeof(MMIOINFO)))) == NULL)
    {
        if (lpmmioinfo) {
            lpmmioinfo->wErrorRet = MMIOERR_OUTOFMEMORY;
        }
        return NULL;
    }
    
    //  Implicitly acquired by NewHandle()
    ReleaseHandleListResource();

    /*----------------------------------------------------------------*\
     * NewHandle does not zero the allocated storage so we had better do
     * it now.
    \*----------------------------------------------------------------*/
    ZeroMemory( pmmio, sizeof(MMIOINFO) );

    /* if user supplied <lpmmioinfo>, copy it to <pmmio> */
    if (lpmmioinfo != NULL) {
        *pmmio = *lpmmioinfo;
    }

    /* <dwOpenFlags> always takes precedence over contents of <pmmio> */
    pmmio->dwFlags = dwOpenFlags;
    pmmio->hmmio = ((HMMIO)pmmio);

    /* MMIO_ALLOCBUF in the flags means that the user wants a buffer
     * allocated for buffered I/O, but after this point it means that
     * a buffer *was* allocated, so turn off the flag until the buffer
     * is actually allocated (which is done by mmioSetBuffer() below)
     */
    if (pmmio->dwFlags & MMIO_ALLOCBUF)
    {
        /* if a buffer size is not specified, use the default */
        if (pmmio->cchBuffer == 0) {
            pmmio->cchBuffer = MMIO_DEFAULTBUFFER;
        }
        pmmio->dwFlags &= ~MMIO_ALLOCBUF;
    }

    /* Set the pIOProc function as determined by the file name or the
     * parameters in the pmmio structure.
     */
    SetIOProc( lpUnicodeName, pmmio );

    /* The pmmio structure hasn't been set up for buffering, so we must
     * explicitly make sure that pchBuffer is NULL.
     */
    hpBuffer = pmmio->pchBuffer;
    pmmio->pchBuffer = NULL;

    /* set up buffered I/O however the user requested it */
    w = mmioSetBuffer(((HMMIO)pmmio), hpBuffer, pmmio->cchBuffer, 0);
    if (w)
    {
        if (lpmmioinfo) {
            lpmmioinfo->wErrorRet = w;
        }
        FreeHandle(((HMMIO)pmmio));
        return NULL;
    }

    if ( (pmmio->dwFlags & MMIO_UNICODEPROC)        // a Unicode IO Proc
        || (pmmio->pIOProc == mmioDOSIOProc)        // or the DOS file IO Proc
        || (pmmio->pIOProc == mmioMEMIOProc) ) {    // or a memory file IO Proc

        /* let the I/O procedure open/delete/qualify the file */
        w = (UINT)IOProc( pmmio, MMIOM_OPEN,
                    (LPARAM)lpUnicodeName, 0L );

        /*------------------------------------------------------------*\
         * If we have a DOS IO proc and the user specified the
         * parse option and we did not get any errors from the IO proc
         * call we convert the returned parsed path string from Unicode
         * back into Ansi and copy this value into szFileName.
        \*------------------------------------------------------------*/
        if ( w == 0
          && (pmmio->pIOProc == mmioDOSIOProc)
          && ((dwOpenFlags & MMIO_PARSE) || (dwOpenFlags & MMIO_GETTEMP)) ) {

              BYTE   ansiPath[ MAX_PATH ];

              UnicodeStrToAsciiStr( ansiPath,
                                    ansiPath + MAX_PATH,
                                    lpUnicodeName );
              strcpy( (LPSTR)szFileName, (LPCSTR)ansiPath );
        }

    } else {

        w = (UINT)IOProc( pmmio, MMIOM_OPEN, (LPARAM)szFileName, 0L );

    }

    /* If this is non-zero, return it to the user */
    if (w != 0)
    {
        if (lpmmioinfo != NULL) {
            lpmmioinfo->wErrorRet = w;
        }
        FreeHandle(((HMMIO)pmmio));
        return NULL;
    }

    if (pmmio->dwFlags & (MMIO_DELETE| MMIO_PARSE| MMIO_EXIST| MMIO_GETTEMP))
    {
        /* if the file is being deleted/parsed/name gotten, exit
         * QUICKLY because the file handle (or whatever) in <pmmio>
         * is not valid.
         */
        mmioSetBuffer(((HMMIO)pmmio), NULL, 0L, 0);
        FreeHandle(((HMMIO)pmmio));
        return (HMMIO) TRUE;
    }

    /* the initial "current buffered offset" will be equal to the initial
     * "current disk offset"
     */
    pmmio->lBufOffset = pmmio->lDiskOffset;

    return ((HMMIO)pmmio);
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    MMRESULT | mmioClose | This function closes a file opened with
    <f mmioOpen>.

@parm   HMMIO | hmmio | Specifies the file handle of the file to
    close.

@parm   UINT | uFlags | Specifies options for the close operation.

    @flag   MMIO_FHOPEN | If the file was opened by passing the DOS
        file handle of an already-opened file to <f mmioOpen>, then
        using this flag tells <f mmioClose> to close the MMIO file
        handle, but not the DOS file handle.  (This is done by the
        I/O Proc).

@rdesc  The return value is zero if the function is successful.
    Otherwise, the return value is an error code, either from
    <f mmioFlush> or from the I/O procedure. The error code can be
    one of the following codes:

    @flag MMIOERR_CANNOTWRITE | The contents of the buffer could
    not be written to disk.

    @flag MMIOERR_CANNOTCLOSE | There was a DOS file system error when
    the I/O Proc attempted to close the DOS file.

@xref   mmioOpen mmioFlush
*/
/*--------------------------------------------------------------------*/
MMRESULT APIENTRY
        mmioClose(HMMIO hmmio, UINT uFlags)
{
    UINT w;                /* either an LRESULT from an IOProc or an MMRESULT */

    V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);

    if ((w = mmioFlush(hmmio, 0)) != 0)
        return w;

    w = (UINT)IOProc( (PMMIO)hmmio, MMIOM_CLOSE, (LPARAM)(DWORD) uFlags, (LPARAM) 0);
    if (w != 0) return w;

    /* free the buffer if necessary */
    mmioSetBuffer(hmmio, NULL, 0L, 0);

        FreeHandle(hmmio);

    return 0;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    LRESULT | mmioRead | This function reads a specified number of
    bytes from a file opened with <f mmioOpen>.

@parm   HMMIO | hmmio | Specifies the file handle of the file to be
    read.

@parm   LPSTR | pch | Specifies a pointer to a buffer to contain
    the data read from the file.

@parm   LONG | cch | Specifies the number of bytes to read from the
    file.

@rdesc  The return value is the number of bytes actually read. If the
    end of the file has been reached and no more bytes can be read, the
    return value is zero. If there is an error reading from the file, the
    return value is -1.

@comm  On 16 bit windows pch is a huge pointer.  On 32 bit windows there is no
    distinction between huge pointers and long pointers.

@xref   mmioWrite
*/
/*--------------------------------------------------------------------*/
LONG APIENTRY
mmioRead(HMMIO hmmio, LPSTR pch, LONG cch)
{
    LONG        lTotalBytesRead = 0L;   // total no. bytes read
    LONG        lBytes;         // no. bytes that can be read
    PMMIO       pmmio=(PMMIO)hmmio; //local copy hmmio - avoid casting, simplify debug

    V_HANDLE(hmmio, TYPE_MMIO, -1);
    V_WPOINTER(pch, cch, -1);

    for(;;)
    {
        /* calculate the number of bytes that can be read */
        lBytes = (LONG)(pmmio->pchEndRead - pmmio->pchNext);

        /* can only read at most <cch> bytes from buffer */
        if (lBytes > cch)
            lBytes = cch;

        if (lBytes > 0)
        {
            /* this is where some performance improvements can
             * be made, especially for small reads...?
             */
            CopyMemory(pch, pmmio->pchNext, lBytes);
            pmmio->pchNext += lBytes;
            pch += lBytes;
            cch -= lBytes;
            lTotalBytesRead += lBytes;
        }

        /* cannot do MMIOM_READ from memory files */
        if (pmmio->fccIOProc == FOURCC_MEM)
            return lTotalBytesRead;

        if (cch == 0)           // no more to read?
            return lTotalBytesRead;

        /* we need to read beyond this buffer; if we have at least
         * another bufferful to read, just call the I/O procedure
         */
        if (cch > pmmio->cchBuffer)
            break;

        /* read the next bufferful and loop around */
        if (mmioAdvance(hmmio, NULL, MMIO_READ) != 0)
            return -1;

        /* if mmioAdvance() couldn't read any more data, we must be
         * at the end of the file
         */
        if (pmmio->pchNext == pmmio->pchEndRead)
            return lTotalBytesRead;
    }

    /* flush and empty the I/O buffer and manipulate <lBufOffset>
     * directly to change the current file position
     */
    if (mmioFlush(hmmio, MMIO_EMPTYBUF) != 0)
        return -1;

    /* call the I/O procedure to do the rest of the reading */
    lBytes = mmioDiskIO(pmmio, MMIOM_READ, pch, cch);
    pmmio->lBufOffset = pmmio->lDiskOffset;

    return (lBytes == -1L) ? -1L : lTotalBytesRead + lBytes;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    LRESULT | mmioWrite | This function writes a specified number of
    bytes to a file opened with <f mmioOpen>.

@parm   HMMIO | hmmio | Specifies the file handle of the file.

@parm   LPSTR | pch | Specifies a pointer to the buffer to be
    written to the file.

@parm   LONG | cch | Specifies the number of bytes to write to the
    file.

@rdesc  The return value is the number of bytes actually written. If
    there is an error writing to the file, the return value is -1.

@comm   The current file position is incremented by the number of
    bytes written.   On 16 bit windows pch is a huge pointer.
    On 32 bit windows there is no distinction between huge pointers
    and long pointers.

@xref   mmioRead
*/
/*--------------------------------------------------------------------*/
LONG APIENTRY
mmioWrite(HMMIO hmmio, LPCSTR pch, LONG cch)
{
    LONG        lTotalBytesWritten = 0L; // total no. bytes written
    LONG        lBytes;         // no. bytes that can be written
    // "pch" is LPCSTR which is correct, but
    // we pass it to a polymorphic routine
    // which needs LPSTR.

    V_HANDLE(hmmio, TYPE_MMIO, -1);
    V_RPOINTER(pch, cch, -1);

    for(;;)
    {
        /* calculate the number of bytes that can be written */
        lBytes = (LONG)(((PMMIO)hmmio)->pchEndWrite - ((PMMIO)hmmio)->pchNext);

        if ((cch > lBytes) && (((PMMIO)hmmio)->fccIOProc == FOURCC_MEM))
        {
            /* this is a memory file -- expand it */
            if (mmioExpandMemFile(((PMMIO)hmmio), cch - lBytes) != 0)
                return -1;  // cannot expand
            lBytes = (LONG)(((PMMIO)hmmio)->pchEndWrite - ((PMMIO)hmmio)->pchNext);
        }

        /* can only write at most <cch> bytes into the buffer */
        if (lBytes > cch)
            lBytes = cch;

        /* this is where some performance improvements can
         * be made, especially for small writes... should
         * special-case cases when segment boundaries are
         * not crossed (or maybe hmemcpy() should do that)
         */
        if (lBytes > 0)
        {
            CopyMemory(((PMMIO)hmmio)->pchNext, pch, lBytes);
            ((PMMIO)hmmio)->dwFlags |= MMIO_DIRTY;
            ((PMMIO)hmmio)->pchNext += lBytes;
            pch += lBytes;
            cch -= lBytes;
            lTotalBytesWritten += lBytes;
        }

        /* validate <pchEndRead>, i.e. re-enforce the invariant that
         * <pchEndRead> points past the last valid byte in the buffer
         */
        if (((PMMIO)hmmio)->pchEndRead < ((PMMIO)hmmio)->pchNext)
            ((PMMIO)hmmio)->pchEndRead = ((PMMIO)hmmio)->pchNext;

        if (cch == 0)           // no more to write?
            return lTotalBytesWritten;

        /* we need to read beyond this buffer; if we have at least
         * another bufferful to read, just call the I/O procedure
         */
        if (cch > ((PMMIO)hmmio)->cchBuffer)
            break;

        /* write this buffer (if needed) and read the next
         * bufferful (if needed)
         */
        if (mmioAdvance(hmmio, NULL, MMIO_WRITE) != 0)
            return -1;
    }

    /* we should never need to do MMIOM_WRITE with memory files */

    /* flush and empty the I/O buffer and manipulate <lBufOffset>
     * directly to change the current file position
     */
    if (mmioFlush(hmmio, MMIO_EMPTYBUF) != 0)
        return -1;

    /* call the I/O procedure to do the rest of the writing
     * mmioDiskIO is a polymorphic routine, hence we need to cast
     * our LPCSTR input pointer to LPSTR.
     */
    lBytes = mmioDiskIO(((PMMIO)hmmio), MMIOM_WRITE, (LPSTR)pch, cch);
    ((PMMIO)hmmio)->lBufOffset = ((PMMIO)hmmio)->lDiskOffset;

    return (lBytes == -1L) ? -1L : lTotalBytesWritten + lBytes;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    LRESULT | mmioSeek | This function changes the current file
    position in a file opened with <f mmioOpen>. The current file
    position is the location in the file where data is read or written.

@parm   HMMIO | hmmio | Specifies the file handle of the file to seek
    in.

@parm   LONG | lOffset | Specifies an offset to change the file position.

@parm   int | iOrigin | Specifies how the offset specified by
    <p lOffset> is interpreted. Contains one of the following flags:

    @flag   SEEK_SET | Seeks to <p lOffset> bytes from the beginning
        of the file.

    @flag   SEEK_CUR | Seeks to <p lOffset> bytes from the current
        file position.

    @flag   SEEK_END | Seeks to <p lOffset> bytes from the end
        of the file.

@rdesc  The return value is the new file position in bytes, relative
    to the beginning of the file. If there is an error, the return value
    is -1.

@comm   Seeking to an invalid location in the file, such as past the
    end of the file, may cause <f mmioSeek> to not return an error,
    but may cause subsequent I/O operations on the file to fail.

    To locate the end of a file, call <f mmioSeek> with <p lOffset>
    set to zero and <p iOrigin> set to SEEK_END.
*/
/*--------------------------------------------------------------------*/
LONG APIENTRY
mmioSeek(HMMIO hmmio, LONG lOffset, int iOrigin)
{
    LONG        lCurOffset; // disk offset of <pchNext>
    LONG        lEndBufOffset;  // disk offset of end of buffer
    LONG        lNewOffset; // new disk offset

    V_HANDLE(hmmio, TYPE_MMIO, -1);

    /* careful! all this buffer pointer manipulation is fine, but keep
     * in mind that buffering may be disabled (in which case <pchEndRead>
     * and <pchBuffer> will both be NULL, so the buffer will appear to
     * be zero bytes in size)
     */

    /* <((PMMIO)hmmio)->lBufOffset> is the disk offset of the start of the
     * start of the buffer; determine <lCurOffset>, the offset of <pchNext>,
     * and <lEndBufOffset>, the offset of the end of the valid part
     * of the buffer
     */
    lCurOffset = (LONG)(((PMMIO)hmmio)->lBufOffset +
        (((PMMIO)hmmio)->pchNext - ((PMMIO)hmmio)->pchBuffer));
    lEndBufOffset = (LONG)(((PMMIO)hmmio)->lBufOffset +
        (((PMMIO)hmmio)->pchEndRead - ((PMMIO)hmmio)->pchBuffer));

    /* determine <lNewOffset>, the offset to seek to */
    switch (iOrigin)
    {
    case SEEK_SET:      // seek relative to start of file

        lNewOffset = lOffset;
        break;

    case SEEK_CUR:      // seek relative to current location

        lNewOffset = lCurOffset + lOffset;
        break;

    case SEEK_END:      // seek relative to end of file

        if (((PMMIO)hmmio)->fccIOProc == FOURCC_MEM)
            lNewOffset = lEndBufOffset - lOffset;
        else
        {
            LONG    lEndFileOffset;

            /* find out where the end of the file is */
            lEndFileOffset
                 = (LONG)IOProc( (PMMIO)hmmio, MMIOM_SEEK, (LPARAM) 0, (LPARAM) SEEK_END);
            if (lEndFileOffset == -1)
                return -1;
            /* Check that we don't have buffered data not yet written */

            if (lEndBufOffset > lEndFileOffset) {
                lEndFileOffset = lEndBufOffset;
            }

            lNewOffset = lEndFileOffset - lOffset;
        }
        break;
    default: lNewOffset = 0;
        {
          dprintf(( "Invalid seek type %d\n",iOrigin));
          WinAssert(FALSE);
        }
    }

    if ( (lNewOffset >= ((PMMIO)hmmio)->lBufOffset)
       && (lNewOffset <= lEndBufOffset)
       )
    {
        /* seeking within the valid part of the buffer
         * (possibly including seeking to <lEndBufOffset>)
         */
        ((PMMIO)hmmio)->pchNext = ((PMMIO)hmmio)->pchBuffer +
            (lNewOffset - ((PMMIO)hmmio)->lBufOffset);
    }
    else
    {
        /* seeking outside the buffer */
        if (((PMMIO)hmmio)->fccIOProc == FOURCC_MEM)
            return -1;  // can't seek outside mem. file buffer
        if (mmioFlush(hmmio, 0) != 0)
            return -1;

        /* the current "buffered file position" (same as <lDiskOffset>
         * for unbuffered files) equals <lBufOffset> +
         * (<pchNext> - <pchBuffer>); we'll move the current buffered
         * file position (and empty the buffer, since it becomes
         * invalid when <lBufOffset> changes) as follows...
         */
        ((PMMIO)hmmio)->lBufOffset = lNewOffset;
        ((PMMIO)hmmio)->pchNext
            = ((PMMIO)hmmio)->pchEndRead
            = ((PMMIO)hmmio)->pchBuffer;

        /* don't need to actually seek right now, since the next
         * MMIOM_READ or MMIOM_WRITE will have to seek anyway
         */
    }

    return lNewOffset;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    MMRESULT | mmioGetInfo | This function retrieves information
    about a file opened with <f mmioOpen>. This information allows the
    caller to directly access the I/O buffer, if the file is opened
    for buffered I/O.

@parm   HMMIO | hmmio | Specifies the file handle of the file.

@parm   LPMMIOINFO | lpmmioinfo | Specifies a pointer to a
    caller-allocated <t MMIOINFO> structure that <f mmioGetInfo>
    fills with information about the file. See the <t MMIOINFO> structure
    and the <f mmioOpen> function for information about the fields in
    this structure.

@parm   UINT | uFlags | Is not used and should be set to zero.

@rdesc  The return value is zero if the function is successful.

@comm   To directly access the I/O buffer of a file opened for
    buffered I/O, use the following fields of the <t MMIOINFO> structure
    filled by <f mmioGetInfo>:

    -- The <e MMIOINFO.pchNext> field points to the next byte in the
    buffer that can be read or written. When you read or write, increment
    <e MMIOINFO.pchNext> by the number of bytes read or written.

    -- The <e MMIOINFO.pchEndRead> field points to one byte past the
    last valid byte in the buffer that can be read.

    -- The <e MMIOINFO.pchEndWrite> field points to one byte past the
    last location in the buffer that can be written.

    Once you read or write to the buffer and modify
    <e MMIOINFO.pchNext>, do not call any MMIO function except
    <f mmioAdvance> until you call <f mmioSetInfo>. Call <f mmioSetInfo>
    when you are finished directly accessing the buffer.

    When you reach the end of the buffer specified by
    <e MMIOINFO.pchEndRead> or <e MMIOINFO.pchEndWrite>, call
    <f mmioAdvance> to fill the buffer from the disk, or write
    the buffer to the disk. The <f mmioAdvance> function
    will update the <e MMIOINFO.pchNext>, <e MMIOINFO.pchEndRead>, and
    <e MMIOINFO.pchEndWrite> fields in the <t MMIOINFO> structure for the
    file.

    Before calling <f mmioAdvance> or <f mmioSetInfo> to flush a
    buffer to disk, set the MMIO_DIRTY flag in the <e MMIOINFO.dwFlags>
    field of the <t MMIOINFO> structure for the file. Otherwise, the
    buffer will not get written to disk.

    Do not decrement <e MMIOINFO.pchNext> or modify any fields in the
    <t MMIOINFO> structure other than <e MMIOINFO.pchNext> and
    <e MMIOINFO.dwFlags>. Do not set any flags in <e MMIOINFO.dwFlags>
    except MMIO_DIRTY.

@xref   mmioSetInfo MMIOINFO
*/
/*--------------------------------------------------------------------*/
MMRESULT APIENTRY
mmioGetInfo(HMMIO hmmio, LPMMIOINFO lpmmioinfo, UINT uFlags)
{
    V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);
    V_WPOINTER(lpmmioinfo, sizeof(MMIOINFO), MMSYSERR_INVALPARAM);

    *lpmmioinfo = *((PMMIO)hmmio);

    return 0;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    MMRESULT | mmioSetInfo | This function updates the information
    retrieved by <f mmioGetInfo> about a file opened with <f mmioOpen>.
    Use this function to terminate direct buffer access of a file opened
    for buffered I/O.

@parm   HMMIO | hmmio | Specifies the file handle of the file.

@parm   LPMMIOINFO | lpmmioinfo | Specifies a pointer to an
    <t MMIOINFO> structure filled with information with
    <f mmioGetInfo>.

@parm   UINT | uFlags | Is not used and should be set to zero.

@rdesc  The return value is zero if the function is successful.

@comm   If you have written to the file I/O buffer, set the
    MMIO_DIRTY flag in the <e MMIOINFO.dwFlags> field of the <t MMIOINFO>
    structure before calling <f mmioSetInfo> to terminate direct buffer
    access. Otherwise, the buffer will not get flushed to disk.

@xref   mmioGetInfo MMIOINFO
*/
/*--------------------------------------------------------------------*/
MMRESULT APIENTRY
mmioSetInfo(HMMIO hmmio, LPCMMIOINFO lpmmioinfo, UINT fuInfo)
{
    V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);
    V_RPOINTER(lpmmioinfo, sizeof(MMIOINFO), MMSYSERR_INVALPARAM);
    V_RPOINTER0( lpmmioinfo->pchBuffer
               , lpmmioinfo->cchBuffer
               , MMSYSERR_INVALPARAM
               );
    V_CALLBACK((FARPROC)lpmmioinfo->pIOProc, MMSYSERR_INVALPARAM);

    /* copy the relevant information from <lpmmioinfo> back into <hmmio> */
    *((PMMIO)hmmio) = *lpmmioinfo;

    /* validate <pchEndRead>, i.e. re-enforce the invariant that
     * <pchEndRead> points past the last valid byte in the buffer
     */
    if (((PMMIO)hmmio)->pchEndRead < ((PMMIO)hmmio)->pchNext)
        ((PMMIO)hmmio)->pchEndRead = ((PMMIO)hmmio)->pchNext;

    return 0;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    MMRESULT | mmioSetBuffer | This function enables or disables
    buffered I/O, or changes the buffer or buffer size for a file opened
    with <f mmioOpen>.

@parm   HMMIO | hmmio | Specifies the file handle of the file.

@parm   LPSTR | pchBuffer | Specifies a pointer to a
    caller-supplied buffer to use for buffered I/O. If NULL,
    <f mmioSetBuffer> allocates an internal buffer for buffered I/O.

@parm   LONG | cchBuffer | Specifies the size of the caller-supplied
    buffer, or the size of the buffer for <f mmioSetBuffer> to allocate.

@parm   UINT | fuInfo | Is not used and should be set to zero.

@rdesc  The return value is zero if the function is successful.
    Otherwise, the return value specifies an error code. If an error
    occurs, the file handle remains valid. The error code can be one
    of the following codes:

    @flag MMIOERR_CANNOTWRITE | The contents of the old buffer could
    not be written to disk, so the operation was aborted.

    @flag MMIOERR_OUTOFMEMORY | The new buffer could not be allocated,
    probably due to a lack of available memory.

@comm   To enable buffering using an internal buffer, set
    <p pchBuffer> to NULL and <p cchBuffer> to the desired buffer size.

    To supply your own buffer, set <p pchBuffer> to point to the buffer,
    and set <p cchBuffer> to the size of the buffer.

    To disable buffered I/O, set <p pchBuffer> to NULL and
    <p cchBuffer> to zero.

    If buffered I/O is already enabled using an internal buffer, you
    can reallocate the buffer to a different size by setting
    <p pchBuffer> to NULL and <p cchBuffer> to the new buffer size. The
    contents of the buffer may be changed after resizing.
 */
/*--------------------------------------------------------------------*/
MMRESULT APIENTRY
         mmioSetBuffer( HMMIO hmmio
                      , LPSTR pchBuffer
                      , LONG cchBuffer
                      , UINT uFlags
                      )
{
    MMRESULT mmr;
    HANDLE hMem;

    V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);
    // Validate the buffer - for READ/WRITE as appropriate
    if (((PMMIO)hmmio)->dwFlags & MMIO_WRITE) {
	V_WPOINTER0(pchBuffer, cchBuffer, MMSYSERR_INVALPARAM);
    } else {
	V_RPOINTER0(pchBuffer, cchBuffer, MMSYSERR_INVALPARAM);
    }

    if ((((PMMIO)hmmio)->dwFlags & MMIO_ALLOCBUF) &&
        (pchBuffer == NULL) && (cchBuffer > 0))
    {
        /* grow or shrink buffer in-place */
        LPSTR       pch;
        LONG        lDeltaNext;
        LONG        lDeltaEndRead;

        /* Since the ALLOCBUF flag is set, we must have a buffer */

        /* write the buffer to disk, but don't empty it */
        if ((mmr = mmioFlush(hmmio, 0)) != 0)
            return mmr;

        for(;;)
        {
            /* remember where <pchNext> and <pchEndRead> are
             * in the buffer
             */
            lDeltaNext = (LONG)(((PMMIO)hmmio)->pchNext - ((PMMIO)hmmio)->pchBuffer);
            lDeltaEndRead
                    = (LONG)(((PMMIO)hmmio)->pchEndRead - ((PMMIO)hmmio)->pchBuffer);

            if (cchBuffer >= lDeltaNext)
                break;

            /* caller wants to truncate the part of the buffer
             * that contains <pchNext> -- handle this by
             * emptying the buffer, recalculating <lDeltaNext>
             * and <lDeltaEndRead>, and continuing below
             */
            if ((mmr = mmioFlush(hmmio, MMIO_EMPTYBUF)) != 0)
                return mmr;
        }

        /* reallocate buffer */
	{
	HANDLE hTemp;

        hTemp =  GlobalHandle( ((PMMIO)hmmio)->pchBuffer );

        GlobalUnlock( hTemp );
        hMem = GlobalReAlloc( hTemp
                            , cchBuffer
                            , GMEM_MOVEABLE
                            );
        pch = GlobalLock(hMem);
	dprintf2(("mmioSetBuffer reallocated ptr %8x, handle %8x, to ptr %8x (handle %8x)\n",
		((PMMIO)hmmio)->pchBuffer, hTemp, pch, hMem));

	}

        /* If we cannot allocate the new buffer, exit with no
         *   harm done.
         */
        if (pch == NULL)
            return MMIOERR_OUTOFMEMORY; // out of memory

        /* transfer pointers to new buffer */
        ((PMMIO)hmmio)->cchBuffer = cchBuffer;
        ((PMMIO)hmmio)->pchBuffer = pch;
        ((PMMIO)hmmio)->pchNext = pch + lDeltaNext;
        ((PMMIO)hmmio)->pchEndRead = pch + lDeltaEndRead;

        /* <pchEndWrite> always points to the end of the buf. */
        ((PMMIO)hmmio)->pchEndWrite = ((PMMIO)hmmio)->pchBuffer + cchBuffer;

        /* check if the reallocation truncated valid data */
        if (lDeltaEndRead > cchBuffer)
            ((PMMIO)hmmio)->pchEndRead = ((PMMIO)hmmio)->pchEndWrite;

        return 0;
    }

    /* write the buffer to disk and stop using the buffer */
    if ((mmr = mmioFlush(hmmio, MMIO_EMPTYBUF)) != 0)
        return mmr;

    if (((PMMIO)hmmio)->dwFlags & MMIO_ALLOCBUF)
    {
        hMem = GlobalHandle( ((PMMIO)hmmio)->pchBuffer);
        GlobalUnlock( hMem );
        GlobalFree( hMem );
        ((PMMIO)hmmio)->dwFlags &= ~MMIO_ALLOCBUF;
    }

    /* Initially, no error. */
    mmr = 0;

    if ((pchBuffer == NULL) && (cchBuffer > 0))
    {
        hMem = GlobalAlloc(GMEM_MOVEABLE, cchBuffer);
        if (hMem)
            pchBuffer = GlobalLock(hMem);
        //else pchBuffer = NULL;

        /* If there is an error, change the file to be un-buffered
         * and return an error code.  The file is still valid.
         * (Just for a little extra security.)
         */
        if (pchBuffer == NULL)
        {   mmr = MMIOERR_OUTOFMEMORY;
            cchBuffer = 0L;
        }
        else
          ((PMMIO)hmmio)->dwFlags |= MMIO_ALLOCBUF;
    }

    /* invariant: <pchEndRead> points past the end of the "valid" portion
     * of the buffer, and <pchEndWrite> points past the last byte that
     * can be written into; <pchNext> points to the next byte to read
     * or write; <lBufOffset> is the current disk offset of the start
     * of the buffer, and it will not change
     */
    ((PMMIO)hmmio)->pchBuffer = pchBuffer;
    ((PMMIO)hmmio)->cchBuffer = cchBuffer;
    ((PMMIO)hmmio)->pchNext
                     = ((PMMIO)hmmio)->pchEndRead = ((PMMIO)hmmio)->pchBuffer;
    ((PMMIO)hmmio)->pchEndWrite = ((PMMIO)hmmio)->pchBuffer + cchBuffer;

    return mmr;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    MMRESULT | mmioFlush | This function writes the I/O buffer of a
    file to disk, if the I/O buffer has been written to.

@parm   HMMIO | hmmio | Specifies the file handle of a file opened
    with <f mmioOpen>.

@parm   UINT | uFlags | Is not used and should be set to zero.

@rdesc  The return value is zero if the function is successful.
    Otherwise, the return value specifies an error code. The error
    code can be one of the following codes:

    @flag MMIOERR_CANNOTWRITE | The contents of the buffer could
    not be written to disk.

@comm   Closing a file with <f mmioClose> will automatically flush
    its buffer.

    If there is insufficient disk space to write the
    buffer, <f mmioFlush> will fail, even if the preceding <f mmioWrite>
    calls were successful.
*/
/*--------------------------------------------------------------------*/
MMRESULT APIENTRY
    mmioFlush(HMMIO hmmio, UINT uFlags)
{
    LONG        lBytesAsk;      // no. bytes to write
    LONG        lBytesWritten;      // no. bytes actually written

    V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);

    if (  ( ((PMMIO)hmmio)->fccIOProc
          == FOURCC_MEM
          )
       || ( ((PMMIO)hmmio)->pchBuffer == NULL )
       )
        return 0;       // cannot flush memory files

    /* if the file is unbuffered then the dirty flag should not be set */
    if (((PMMIO)hmmio)->dwFlags & MMIO_DIRTY)
    {
        /* figure out how many bytes need to be flushed */
        lBytesAsk = (LONG)(((PMMIO)hmmio)->pchEndRead - ((PMMIO)hmmio)->pchBuffer);

        /* write the buffer to disk */
        lBytesWritten = mmioDiskIO(((PMMIO)hmmio), MMIOM_WRITEFLUSH,
            ((PMMIO)hmmio)->pchBuffer, lBytesAsk);
        if (lBytesWritten != lBytesAsk)
            return MMIOERR_CANNOTWRITE;
        ((PMMIO)hmmio)->dwFlags &= ~MMIO_DIRTY; // buffer is clean now
    }

    if (uFlags & MMIO_EMPTYBUF)
    {
        /* empty the I/O buffer, and update <lBufOffset> to reflect
         * what the current file position is
         */
        ((PMMIO)hmmio)->lBufOffset
                    += (LONG)((((PMMIO)hmmio)->pchNext - ((PMMIO)hmmio)->pchBuffer));
        ((PMMIO)hmmio)->pchNext
                    = ((PMMIO)hmmio)->pchEndRead = ((PMMIO)hmmio)->pchBuffer;
    }

    return 0;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    MMRESULT | mmioAdvance | This function advances the I/O buffer of
    a file set up for direct I/O buffer access with <f mmioGetInfo>. If
    the file is opened for reading, the I/O buffer is filled from the
    disk.  If the file is opened for writing and the MMIO_DIRTY flag is
    set in the <e MMIOINFO.dwFlags> field of the <t MMIOINFO> structure,
    the buffer is written to disk.  The <e MMIOINFO.pchNext>,
    <e MMIOINFO.pchEndRead>, and <e MMIOINFO.pchEndWrite> fields of the
    <t MMIOINFO> structure are updated to reflect the new state of
    the I/O buffer.

@parm   HMMIO | hmmio | Specifies the file handle for a file opened
    with <f mmioOpen>.

@parm   LPMMIOINFO | lpmmioinfo | Optionally specifies a pointer to the
    <t MMIOINFO> structure obtained with <f mmioGetInfo>, which is used to
    set the current file information, then updated after the buffer is
    advanced.

@parm   UINT | uFlags | Specifies options for the operation.
    Contains exactly one of the following two flags:

    @flag   MMIO_READ | The buffer is filled from the file.

    @flag   MMIO_WRITE | The buffer is written to the file.

@rdesc  The return value is zero if the operation is successful.
    Otherwise, the return value specifies an error code. The error
    code can be one of the following codes:

    @flag MMIOERR_CANNOTWRITE | The contents of the buffer could
    not be written to disk.

    @flag MMIOERR_CANNOTREAD | An error occurred while re-filling
    the buffer.

    @flag MMIOERR_UNBUFFERED | The specified file is not opened
    for buffered I/O.

    @flag MMIOERR_CANNOTEXPAND | The specified memory file cannot
    be expanded, probably because the <e MMIOINFO.adwInfo[0]> field
    was set to zero in the initial call to <f mmioOpen>.

    @flag MMIOERR_OUTOFMEMORY | There was not enough memory to expand
    a memory file for further writing.


@comm   If the specified file is opened for writing or for both
    reading and writing, the I/O buffer will be flushed to disk before
    the next buffer is read. If the I/O buffer cannot be written to disk
    because the disk is full, then <f mmioAdvance> will return
    MMIOERR_CANNOTWRITE.

    If the specified file is only open for writing, the MMIO_WRITE
    flag must be specified.

    If you have written to the I/O buffer, you must set the MMIO_DIRTY
    flag in the <e MMIOINFO.dwFlags> field of the <t MMIOINFO> structure
    before calling <f mmioAdvance>. Otherwise, the buffer will not be
    written to disk.

    If the end of file is reached, <f mmioAdvance> will still return
    success, even though no more data can be read.  Thus, to check for
    the end of the file, it is necessary to see if the
    <e MMIOINFO.pchNext> and <e MMIOINFO.pchEndRead> fields of the
    <t MMIOINFO> structure are equal after calling <f mmioAdvance>.

@xref   mmioGetInfo MMIOINFO
*/
/*--------------------------------------------------------------------*/
MMRESULT APIENTRY
         mmioAdvance(HMMIO hmmio, LPMMIOINFO lpmmioinfo, UINT uFlags)
{
    LONG        lBytesRead;     // bytes actually read
    UINT        w;

    V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);
    if (((PMMIO)hmmio)->pchBuffer == NULL)
        return MMIOERR_UNBUFFERED;
    if (lpmmioinfo != NULL) {
        V_WPOINTER(lpmmioinfo, sizeof(MMIOINFO), MMSYSERR_INVALPARAM);
        mmioSetInfo(hmmio, lpmmioinfo, 0);
    }

    if (((PMMIO)hmmio)->fccIOProc == FOURCC_MEM)
    {
        /* this is a memory file:
         *   -- if the caller is reading, cannot advance
         *   -- if the caller is writing, then advance by expanding
         *      the buffer (if possible) if the there is less than
         *  <adwInfo[0]> bytes left in the buffer
         */
        if (!(uFlags & MMIO_WRITE))
            return MMIOERR_CANNOTREAD;
        if ( (DWORD)(((PMMIO)hmmio)->pchEndWrite - ((PMMIO)hmmio)->pchNext)
           >= ((PMMIO)hmmio)->adwInfo[0]
           )
            return MMIOERR_CANNOTEXPAND;
        if ((w = mmioExpandMemFile(((PMMIO)hmmio), 1L)) != 0)
            return w;   // out of memory, or whatever
        goto GETINFO_AND_EXIT;
    }

    /* empty the I/O buffer, which will effectively advance the
     * buffer by (<pchNext> - <pchBuffer>) bytes
     */
    if ((w = mmioFlush(hmmio, MMIO_EMPTYBUF)) != 0)
        return w;

    /* if MMIO_WRITE bit is not set in uFlags, fill the buffer  */
    if (!(uFlags & MMIO_WRITE))
    {
        /* read the next bufferful from the file */
        lBytesRead = mmioDiskIO(((PMMIO)hmmio), MMIOM_READ,
            ((PMMIO)hmmio)->pchBuffer, ((PMMIO)hmmio)->cchBuffer);
        if (lBytesRead == -1)
            return MMIOERR_CANNOTREAD;

        /* reading zero bytes should not be treated as an error
         * condition -- e.g. open a new file R+W and call
         * mmioAdvance(), and MMIOM_READ will return zero bytes
         * because the file started off empty
         */
        ((PMMIO)hmmio)->pchEndRead += lBytesRead;
    }

GETINFO_AND_EXIT:

    /* copy <hmmio> back to <lpmmioinfo> if <lpmmioinfo> is provided */
    if (lpmmioinfo != NULL)
        mmioGetInfo(hmmio, lpmmioinfo, 0);

    return 0;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    FOURCC | mmioStringToFOURCC | This function converts a
    null-terminated string to a four-character code.

@parm   LPCTSTR | sz | Specifies a pointer to a null-terminated
    string to a four-character code.

@parm   UINT | uFlags | Specifies options for the conversion:

    @flag   MMIO_TOUPPER | Converts all characters to uppercase.

@rdesc  The return value is the four character code created from the
    given string.

@comm   This function does not check to see if the string referenced
    by <p sz> follows any conventions regarding which characters to
    include in a four-character code.  The string is
    simply copied to a four-character code and padded with blanks or
    truncated to four characters if required.

@xref   mmioFOURCC
*/
/*--------------------------------------------------------------------*/
FOURCC APIENTRY
       mmioStringToFOURCCW( LPCWSTR sz, UINT uFlags )
{

    FOURCC  fcc;
    PBYTE   pByte;  // ascii version of szFileName
    ULONG   cbDst;  // character count of szFileName

//    V_STRING(sz, -1, 0);

    /*------------------------------------------------------------*\
     * Convert the given unicode string into ascii and then call
     * the ascii version of mmioStringToFOURCCW
    \*------------------------------------------------------------*/
    cbDst = (wcslen( sz ) * sizeof(WCHAR)) + sizeof(WCHAR);
    pByte = HeapAlloc( hHeap, 0, cbDst );
    if ( pByte == (PBYTE)NULL ) {
        return (FOURCC)(DWORD_PTR)NULL;
    }
    UnicodeStrToAsciiStr( pByte, pByte + cbDst, sz );

    fcc = mmioStringToFOURCCA( (LPSTR)pByte, uFlags );

    HeapFree( hHeap, 0, pByte );
    return (FOURCC)fcc;
}

FOURCC APIENTRY
       mmioStringToFOURCCA( LPCSTR sz, UINT uFlags )
{
    FOURCC      fcc;
    LPSTR       pch = (LPSTR) &fcc;
    int         i;

    V_STRING(sz, (DWORD)-1, 0);

    for (i = sizeof(FOURCC) - 1; i >= 0; i--)
    {
        if (!*sz)
            *pch = ' ';   /* and don't increment sz beyond the terminating NULL! */
        else {
            *pch = *sz;
            if (uFlags & MMIO_TOUPPER)

//#ifdef DBCS // we don't allow DBCS string. This is enough for us.
                *pch = (char)(WORD)PtrToUlong(AnsiUpper((LPSTR)(DWORD_PTR)((ULONG)*pch & 0xff)));
//#else
//                *pch = (char)(WORD)(LONG)AnsiUpper((LPSTR)(LONG)*pch);
//#endif

            sz++;
        }
        pch++;
    }

    return fcc;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    LPMMIOPROC | mmioInstallIOProc | This function installs or
    removes a custom I/O procedure. It will also locate an installed I/O
    procedure, given its corresponding four-character code.

@parm   FOURCC | fccIOProc | Specifies a four-character code
    identifying the I/O procedure to install, remove, or locate. All
    characters in this four-character code should be uppercase characters.

@parm   LPMMIOPROC | pIOProc | Specifies the address of the I/O
    procedure to install. To remove or locate an I/O procedure, set this
    parameter to NULL.

@parm   DWORD | dwFlags | Specifies one of the following flags
    indicating whether the I/O procedure is being installed, removed, or
    located:

    @flag   MMIO_INSTALLPROC | Installs the specified I/O procedure.

    @flag   MMIO_GLOBALPROC | This flag is a modifier to the install flag,
        and indicates the I/O procedure should be installed for global
        use.  This flag is ignored on removal or find.

    @flag   MMIO_REMOVEPROC | Removes the specified I/O procedure.

    @flag   MMIO_FINDPROC | Searches for the specified I/O procedure.

@rdesc  The return value is the address of the I/O procedure
    installed, removed, or located. If there is an error, the return value
    is NULL.

@comm   If the I/O procedure resides in the application, use
    <f MakeProcInstance> for compatibility with 16 bit windows
    to get a procedure-instance address and specify
    this address for <p pIOProc>. You don't need to get a procedure-instance
    address if the I/O procedure resides in a DLL.

@cb LONG FAR PASCAL | IOProc | <f IOProc> is a placeholder for the
    application-supplied function name. The actual name must be exported
    by including it in a EXPORTS statement in the application's
    module-definitions file.

    @parm   LPSTR | lpmmioinfo | Specifies a pointer to an
        <t MMIOINFO> structure containing information about the open
        file.  The I/O procedure must maintain the <e MMIOINFO.lDiskOffset>
        field in this structure to indicate the file offset to the
        next read or write location. The I/O procedure can use the
        <e MMIOINFO.adwInfo[]> field to store state information. The
        I/O procedure should not modify any other fields of the
        <t MMIOINFO> structure.


    @parm   UINT | wMsg | Specifies a message indicating the
        requested I/O operation. Messages that can be received include
        <m MMIOM_OPEN>, <m MMIOM_CLOSE>, <m MMIOM_READ>, <m MMIOM_WRITE>,
        and <m MMIOM_SEEK>.

    @parm   LONG | lParam1 | Specifies a parameter for the message.

    @parm   LONG | lParam2 | Specifies a parameter for the message.

@rdesc  The return value depends on the message specified by
    <p wMsg>. If the I/O procedure does not recognize a message, it should
    return zero.

@comm   The four-character code specified by the
    <e MMIOINFO.fccIOProc> field in the <t MMIOINFO> structure
    associated with a file identifies a filename extension for a custom
    storage system. When an application calls <f mmioOpen> with a
    filename such as "foo.xyz!bar", the I/O procedure associated with the
    four-character code "XYZ " is called to open the "bar" element of the
    file "foo.xyz".

    The <f mmioInstallIOProc> function maintains a separate list of
    installed I/O procedures for each Windows application. Therefore,
    different applications can use the same I/O procedure identifier for
    different I/O procedures without conflict.  Installing an I/O procedure
    globally however enables any process to use the procedure.

    If an application calls <f mmioInstallIOProc> more than once to
    register the same I/O procedure, then it must call
    <f mmioInstallIOProc> to remove the procedure once for each time it
    installed the procedure.

    <f mmioInstallIOProc> will not prevent an application from
    installing two different I/O procedures with the same identifier, or
    installing an I/O procedure with one of the predefined identifiers
    ("DOS ", "MEM "). The most recently installed procedure
    takes precedence, and the most recently installed procedure is the
    first one to get removed.

    When searching for a specified I/O procedure, local procedures are
    searched first, then global procedures.

@xref   mmioOpen
 */

/*--------------------------------------------------------------------*/
LPMMIOPROC APIENTRY
mmioInstallIOProcW(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags)
{
    V_FLAGS(dwFlags, MMIO_VALIDPROC, mmioInstallIOProc, NULL);

    dwFlags |= MMIO_UNICODEPROC;
    return mmioInternalInstallIOProc( fccIOProc, pIOProc, dwFlags);
}

LPMMIOPROC APIENTRY
mmioInstallIOProcA(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags)
{

    V_FLAGS(dwFlags, MMIO_VALIDPROC, mmioInstallIOProc, NULL);

    dwFlags &= ~MMIO_UNICODEPROC;
    return mmioInternalInstallIOProc( fccIOProc, pIOProc, dwFlags);
}


static LPMMIOPROC mmioInternalInstallIOProc(
                     FOURCC      fccIOProc,   // I/O Proc 4 char id
                     LPMMIOPROC  pIOProc,     // pointer to any I/O proc to install
                     DWORD       dwFlags      // flags from caller
                     )
{
    IOProcMapEntry  *pEnt;          // an entry in linked list
    HANDLE          hTaskCurrent;   // current Windows task handle

#ifdef DUMPIOPROCLIST
// dprintf(("initial I/O proc list\n"));
// DumpIOProcList();
#endif

    if (fccIOProc == 0L)
        return NULL;

    hTaskCurrent = GetCurrentTask();

    if (dwFlags & MMIO_INSTALLPROC)
    {
        /* install I/O procedure -- always add at the beginning of
         * the list, so it overrides any other I/O procedures
         * with the same identifier installed by the same task
         */
        V_CALLBACK((FARPROC)pIOProc, NULL);
        if ((pEnt = (IOProcMapEntry NEAR *)
            NewHandle(TYPE_MMIO, NULL, sizeof(IOProcMapEntry))) == NULL)
                return NULL;        // out of memory
        //  Implicitly acquired by NewHandle()
        ReleaseHandleListResource();
        pEnt->fccIOProc = fccIOProc;
        pEnt->pIOProc = pIOProc;
        pEnt->hTask = hTaskCurrent;
        pEnt->pNext = gIOProcMapHead;
        gIOProcMapHead = pEnt;

#ifdef DUMPIOPROCLIST
// dprintf(("I/O proc list after addition"));
// DumpIOProcList();
#endif

        return pIOProc;
    }

    if (!pIOProc)
        if (dwFlags & MMIO_REMOVEPROC)
            return RemoveIOProc(fccIOProc, hTaskCurrent);
        else if (dwFlags & MMIO_FINDPROC)
        {   
            pEnt = FindIOProc(fccIOProc, hTaskCurrent);
            return ( pEnt==NULL
                   ? NULL
                   : pEnt->pIOProc
                   );
        }
    return NULL;        // couldn't find requested I/O procedure
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    LRESULT | mmioSendMessage | This function sends a message to the
    I/O procedure associated with the specified file.

@parm   HMMIO | hmmio | Specifies the file handle for a file opened
    with <f mmioOpen>.

@parm   UINT | wMsg | Specifies the message to send to the I/O procedure.

@parm   LONG | lParam1 | Specifies a parameter for the message.

@parm   LONG | lParam2 | Specifies a parameter for the message.

@rdesc  The return value depends on the message. If the I/O procedure
    does not recognize the message, the return value is zero.

@comm   Use this function to send custom user-defined messages. Do
    not use it to send the <m MMIOM_OPEN>, <m MMIOM_CLOSE>,
    <m MMIOM_READ>, <m MMIOM_WRITE>, <m MMIOM_WRITEFLUSH>, or
    <m MMIOM_SEEK> messages. Define
    custom messages to be greater than or equal to the MMIOM_USER constant.

@xref   mmioInstallIOProc
*/
/*--------------------------------------------------------------------*/
LRESULT APIENTRY
mmioSendMessage(HMMIO hmmio, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
{
    V_HANDLE(hmmio, TYPE_MMIO, (LRESULT)0);
    return IOProc( (PMMIO)hmmio, uMsg, lParam1, lParam2);
}


/*--------------------------------------------------------------------*/
/* @doc INTERNAL

@api    LONG | mmioDiskIO | Perform an unbuffered read or write.
    Do not assume where the current disk offset <p lDiskOffset> will be.

@parm   PMMIO | pmmio | The open file handle returned by <f mmioOpen>.

@parm   UINT | wMsg | MMIOM_READ if <f mmioDiskIO> should read from the disk,
    or MMIOM_WRITE if <f mmioDiskIO> should write to the disk,
    or MMIOM_WRITEFLUSH if <f mmioDiskIO> should flush all pending I/O.

@parm   LPSTR | pch | The buffer to read into or write from.

@parm   LONG | cch | The number of bytes to read or write.

    <f mmioDiskIO> changes the disk offset to be <p lBufOffset>
    and then performs an MMIOM_READ or MMIOM_WRITE operation as
    specified by <p wMsg>, <p pch>, and <p cch>.

    Note that if the I/O buffer is not empty at this point, this
    function may not do what you expect.

    Do not call this function for memory files.
*/
/*--------------------------------------------------------------------*/
static LONG NEAR PASCAL
mmioDiskIO(PMMIO pmmio, UINT uMsg, LPSTR pch, LONG cch)
{
    if (pmmio->lDiskOffset != pmmio->lBufOffset)
    {
        if (IOProc( pmmio
                  , MMIOM_SEEK
                  , (LONG) pmmio->lBufOffset
                  , (LONG) SEEK_SET
                  )
           == -1
           )
            return -1;
    }

    return (LONG)IOProc( pmmio, uMsg, (LPARAM) pch, (LPARAM) cch);
}


/*--------------------------------------------------------------------*/
/* @doc INTERNAL

@api    UINT | mmioExpandMemFile | Assuming that <p pmmio> is a memory file,
    expand it by <p lExpand> bytes or <p adwInfo[0]> bytes, whichever
    is larger.  Do not disturb the contents of the buffer or change
    the current file position.

@parm   PMMIO | pmmio | The open file handle returned by <f mmioOpen>.

@parm   LONG | lExpand | The minimum number of bytes to expand the buffer by.

@rdesc  If the function succeeds, zero is returned.  If the function fails,
    an error code is returned.  In particular, MMIOERR_OUTOFMEMORY is
    returned if memory reallocation failed.

@comm   Only call this function for memory files.
*/
/*--------------------------------------------------------------------*/
static UINT NEAR PASCAL
mmioExpandMemFile(PMMIO pmmio, LONG lExpand)
{
    MMIOMEMINFO *   pInfo = (MMIOMEMINFO *) pmmio->adwInfo;
    DWORD       dwFlagsTemp;
    UINT        w;

    /* make sure buffer can be expanded */
    /* Note: we used to check ALLOC_BUF here, we don't now. */
    if (pInfo->lExpand == 0)
        return MMIOERR_CANNOTEXPAND;    // cannot grow file

    /* how much should the buffer be expanded by? */
    if (lExpand < pInfo->lExpand)
        lExpand = pInfo->lExpand;

    dwFlagsTemp = pmmio->dwFlags;
    pmmio->dwFlags |= MMIO_ALLOCBUF;
    w = mmioSetBuffer(((HMMIO)pmmio), NULL,
                     pmmio->cchBuffer + lExpand, 0);
    pmmio->dwFlags = dwFlagsTemp;
    return w;
}


/*--------------------------------------------------------------------*/
/* @doc INTERNAL

@api    LRESULT | mmioDOSIOProc | The 'DOS' I/O procedure, which handles I/O
    on ordinary DOS files.

@parm   LPSTR | lpmmioinfo | A pointer to an MMIOINFO block that
    contains information about the open file.

@parm   UINT | uMsg | The message that the I/O procedure is being
    asked to execute.

@parm   LONG | lParam1 | Specifies additional message information.

@parm   LONG | lParam2 | Specifies additional message information.

@rdesc  Return value depends on <p wMsg>.
*/
/*--------------------------------------------------------------------*/
LRESULT
     mmioDOSIOProc(LPSTR lpmmioStr, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
{
    PMMIO       pmmio  = (PMMIO)lpmmioStr;              // only in DLL!
    MMIODOSINFO *pInfo = (MMIODOSINFO *)pmmio->adwInfo;
    LONG        lResult;
    LPWSTR      szFilePart;
    WCHAR       szPath[ MAX_PATH ];

    switch (uMsg) {

    case MMIOM_OPEN:
        /*
         * The extra info parameter optionally contains a
         * sequence number to pass.
         */
        if ( pmmio->dwFlags & MMIO_GETTEMP )
        {
            V_RPOINTER((LPSTR)lParam1, 4, (LRESULT) MMSYSERR_INVALPARAM);

            if ( GetTempPathW( MAX_PATH, szPath ) == 0 ) {
                wcscpy( szPath, (LPCWSTR)L"." );
            }

            return GetTempFileNameW( szPath, (LPCWSTR)L"sje",
                                    (WORD)pmmio->adwInfo[0], (LPWSTR)lParam1 )
                   ? (LRESULT)0
                   : (LRESULT)MMIOERR_FILENOTFOUND;
        }


        /*------------------------------------------------------------*\
         * <lParam1> is either a file name or NULL; if it is
         * NULL, then <adwInfo[0]>, which is actually <pInfo->fh>,
         * should already contain an open DOS file handle.
         *
         * Does lParam1 point to a file name ?
         *
         * if so then either:
         *
         *  delete the file,
         *  check the existance of the file,
         *  parse the file name, or
         *  open the file name
         *
        \*------------------------------------------------------------*/
        if ( lParam1 != 0 ) {

            if ( pmmio->dwFlags & MMIO_DELETE ) {

                return DeleteFileW( (LPWSTR)lParam1 )
                       ? (LRESULT)0
                       : (LRESULT)MMIOERR_FILENOTFOUND;
            }

            if ( pmmio->dwFlags & MMIO_EXIST ) {
                if ( !(pmmio->dwFlags & MMIO_CREATE) ) {
#ifdef LATER
      I think this should be using SearchPath (with lpszPath==lParam1)
      as the definition of MMIO_EXIST states that a fully qualified
      filename is returned.  OR tweak the flags to turn MMIO_PARSE ON
      and execute the next section.
#endif
                    if ( GetFileAttributesW( (LPWSTR)lParam1 ) == -1 ) {
                        return (LRESULT)MMIOERR_FILENOTFOUND;
                    }
                    return (LRESULT)0;
                }
            }

            if ( pmmio->dwFlags & MMIO_PARSE ) {

                if ( GetFullPathNameW((LPWSTR)lParam1,
                                  MAX_PATH,
                                  szPath,
                                  &szFilePart ) == 0 ) {

                    return (LRESULT)MMIOERR_FILENOTFOUND;
                }
                wcscpy( (LPWSTR)lParam1, szPath );
                return (LRESULT) 0;
            }

            {
                DWORD   dwAccess        = 0;
                DWORD   dwSharedMode    = 0;
                DWORD   dwCreate        = 0;
                DWORD   dwFlags         = FILE_ATTRIBUTE_NORMAL;

                /*----------------------------------------------------*\
                 * Look at the access flags
                \*----------------------------------------------------*/
                if ( pmmio->dwFlags & MMIO_WRITE ) {
                    dwAccess = GENERIC_WRITE;
                } else {
                    dwAccess = GENERIC_READ;
                }

                if ( pmmio->dwFlags & MMIO_READWRITE ) {
                    dwAccess |= (GENERIC_WRITE | GENERIC_READ);
                }

                /*----------------------------------------------------*\
                 * Set dwSharedMode from the share flags
                \*----------------------------------------------------*/

                {   /* owing to some crappy design in WIN3.1, the share flags are
                    *  exclusive  = 10
                    *  deny write = 20
                    *  deny read  = 30
                    *  deny none  = 40
                    *  so deny read looks like exclusive + deny write.  Sigh.
                    *  00 is taken as being DENYNONE (probably correct)
                    *  So is 50, 60 and 70 (which is probably bogus).
                    *  As we need to support the DOS flags for WOW, we need this
                    *  code somewhere, so might as well leave the flag definitions
                    *  as they are.  First pull out all the share mode bits.
                    */
                    DWORD dwShare = MMIO_DENYWRITE | MMIO_DENYREAD
                                  | MMIO_DENYNONE | MMIO_EXCLUSIVE;
                    dwShare &= pmmio->dwFlags;

                    switch (dwShare)
                    {   case MMIO_DENYWRITE:
                           dwSharedMode = FILE_SHARE_READ;
                        break;
                        case MMIO_DENYREAD:
                           dwSharedMode = FILE_SHARE_WRITE;
                        break;
                        case MMIO_EXCLUSIVE:
                           dwSharedMode = 0;
                        break;
                        case MMIO_DENYNONE:
                        default:
                           dwSharedMode = FILE_SHARE_WRITE | FILE_SHARE_READ;
                        break;
#ifdef later
   Generate an error for invalid flags?
#endif
                    }
                }

                /*----------------------------------------------------*\
                 * Look at the create flags
                \*----------------------------------------------------*/
                if ( (pmmio->dwFlags) & MMIO_CREATE) {
                    dwCreate = CREATE_ALWAYS;
                    wcscpy( szPath, (LPWSTR)lParam1 );

                } else {
                    dwCreate = OPEN_EXISTING;
                    if ( SearchPathW( NULL, (LPWSTR)lParam1,
                                      NULL,
                                      (MAX_PATH - 1),
                                      szPath, &szFilePart ) == 0 ) {

                        return (LRESULT)MMIOERR_FILENOTFOUND;
                    }
                }

                pInfo->fh = (int)(DWORD_PTR)CreateFileW( szPath,
                                              dwAccess,
                                              dwSharedMode,
                                              NULL,
                                              dwCreate,
                                              dwFlags | FILE_FLAG_SEQUENTIAL_SCAN,
                                              NULL );

                if ( pInfo->fh == (int)-1 ) {
                    return (LRESULT)MMIOERR_FILENOTFOUND;
                }

                if ( pmmio->dwFlags & MMIO_EXIST ) {
                    CloseHandle( (HANDLE)(UINT_PTR)pInfo->fh );
                    return (LRESULT)0;
                }

            }

        }
        /* check the current file offset */
        pmmio->lDiskOffset = _llseek(pInfo->fh, 0L, SEEK_CUR);
        return (LRESULT)0;

    case MMIOM_CLOSE:
        /* MMIO_FHOPEN flag means keep the DOS file handle open */
        if (  !((DWORD)lParam1 & MMIO_FHOPEN)
           && (_lclose(pInfo->fh) == HFILE_ERROR) ) {

            return (LRESULT) MMIOERR_CANNOTCLOSE;
        }
        return (LRESULT) 0;

    case MMIOM_READ:
        lResult = _lread(pInfo->fh, (LPVOID)lParam1, (LONG)lParam2);
        if (lResult != -1L) {
            pmmio->lDiskOffset += lResult;
        }
        return (LRESULT) lResult;

    case MMIOM_WRITE:
    case MMIOM_WRITEFLUSH:

        lResult = _lwrite(pInfo->fh, (LPVOID)lParam1, (LONG)lParam2);
        if (lResult != -1L) {
            pmmio->lDiskOffset += lResult;
        }

#ifdef DOSCANFLUSH
        if (uMsg == MMIOM_WRITEFLUSH)
        {
            /* Issue hardware flush command */
        }
#endif
        return (LRESULT) lResult;

    case MMIOM_SEEK:
        lResult = _llseek(pInfo->fh, (LONG)lParam1, (int)(LONG)lParam2);
        if (lResult != -1L) {
            pmmio->lDiskOffset = lResult;
        }
        return (LRESULT) lResult;

    case MMIOM_RENAME:
        if (!MoveFileW((LPWSTR)lParam1, (LPWSTR)lParam2)) {
            return (LRESULT) MMIOERR_FILENOTFOUND;
            /* ??? There are other errors too? e.g. target exists? */
        }
        break;

    }

    return (LRESULT) 0;
}


/*--------------------------------------------------------------------*/
/* @doc INTERNAL

@api    LRESULT | mmioMEMIOProc | The 'MEM' I/O procedure, which handles I/O
    on memory files.

@parm   LPSTR | lpmmioinfo | A pointer to an MMIOINFO block that
    contains information about the open file.

@parm   UINT | uMsg | The message that the I/O procedure is being
    asked to execute.

@parm   LONG | lParam1 | Specifies additional message information.

@parm   LONG | lParam2 | Specifies additional message information.

@rdesc  Return value depends on <p uMsg>.
*/
/*--------------------------------------------------------------------*/
LRESULT
      mmioMEMIOProc(LPSTR lpmmioStr, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
{
    PMMIO       pmmio = (PMMIO) lpmmioStr; // only in DLL!

    switch (uMsg)
    {

        case MMIOM_OPEN:

        if ( pmmio->dwFlags
           & ~(MMIO_CREATE
              | MMIO_READWRITE
              | MMIO_WRITE
              | MMIO_EXCLUSIVE
              | MMIO_DENYWRITE
              | MMIO_DENYREAD
              | MMIO_DENYNONE
              | MMIO_ALLOCBUF
              )
           )
            return (LRESULT) MMSYSERR_INVALFLAG;

        /* all the data in the buffer is valid */
        if (!(pmmio->dwFlags & MMIO_CREATE))
            pmmio->pchEndRead = pmmio->pchEndWrite;
        return (LRESULT) 0;

    case MMIOM_CLOSE:

        /* nothing special to do on close */
        return (LRESULT) 0;

    case MMIOM_READ:
    case MMIOM_WRITE:
    case MMIOM_WRITEFLUSH:
    case MMIOM_SEEK:
                return (LRESULT) -1;
    }

    return (LRESULT) 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\mmiocf.h ===
// Copyright (c) 1992 Microsoft Corporation
/* mmiocf.h
 *
 * Multimedia File I/O Library.
 *
 * This include file contains declarations required for compound file support.
 *
 */

/* Revision history:
   LaurieGr: Jan 92 Ported from win16.  Source tree fork, not common code.
*/

#ifndef MMIOCF_H
#define MMIOCF_H

typedef HANDLE HMMCF;           // a handle to an open RIFF compound file

typedef struct _MMCFINFO        // structure for representing CTOC header info.
{
        DWORD           dwHeaderSize;   // size of CTOC header (w/o entries)
        DWORD           dwEntriesTotal; // no. of entries in table of contents
        DWORD           dwEntriesDeleted; // no. of entries ref. to. del. ent.
        DWORD           dwEntriesUnused; // no. of entries that are not used
        DWORD           dwBytesTotal;   // total bytes of CGRP contents
        DWORD           dwBytesDeleted; // total bytes of deleted CGRP elements
        DWORD           dwHeaderFlags;  // flags
        WORD            wEntrySize;     // size of each <CTOC-table-entry>
        WORD            wNameSize;      // size of each <achName> field
        WORD            wExHdrFields;   // number of "extra header fields"
        WORD            wExEntFields;   // number of "extra entry fields"
} MMCFINFO, FAR *LPMMCFINFO;

typedef struct _MMCTOCENTRY     // structure for representing CTOC entry info.
{
        DWORD           dwOffset;       // offset of element inside CGRP chunk
        DWORD           dwSize;         // size of element inside CGRP chunk
        DWORD           dwMedType;      // media element type of CF element
        DWORD           dwMedUsage;     // media element usage information
        DWORD           dwCompressTech; // media element compression technique
        DWORD           dwUncompressBytes; // size after decompression
        DWORD           adwExEntField[1]; // extra CTOC table entry fields
} MMCTOCENTRY, FAR *LPMMCTOCENTRY;

/* <dwFlags> field of MMIOINFO structure -- many same as OpenFile() flags */
#define MMIO_CTOCFIRST  0x00020000      // mmioCFOpen(): put CTOC before CGRP

/* flags for other functions */
#define MMIO_FINDFIRST          0x0010  // mmioCFFindEntry(): find first entry
#define MMIO_FINDNEXT           0x0020  // mmioCFFindEntry(): find next entry
#define MMIO_FINDUNUSED         0x0040  // mmioCFFindEntry(): find unused entry
#define MMIO_FINDDELETED        0x0080  // mmioCFFindEntry(): find deleted entry

/* message numbers for MMIOPROC */
#define MMIOM_GETCF             10      // get HMMCF of CF element
#define MMIOM_GETCFENTRY        11      // get ptr. to CTOC table entry

/* four character codes used to identify standard built-in I/O procedures */
#define FOURCC_BND      mmioFOURCC('B', 'N', 'D', ' ')

/* <dwHeaderFlags> field of MMCFINFO structure */
#define CTOC_HF_SEQUENTIAL      0x00000001 // CF elements in same order as CTOC
#define CTOC_HF_MEDSUBTYPE      0x00000002 // <dwMedUsage> is a med. el. subtype

/* CTOC table entry flags */
#define CTOC_EF_DELETED         0x01    // CF element is deleted
#define CTOC_EF_UNUSED          0x02    // CTOC entry is unused

/* CF I/O prototypes */
HMMCF FAR PASCAL mmioCFOpen(LPWSTR szFileName, DWORD dwFlags);
HMMCF FAR PASCAL mmioCFAccess(HMMIO hmmio, LPMMCFINFO lpmmcfinfo,
        DWORD dwFlags);
MMRESULT FAR PASCAL mmioCFClose(HMMCF hmmcf, UINT uFlags);
DWORD FAR PASCAL mmioCFGetInfo(HMMCF hmmcf, LPMMCFINFO lpmmcfinfo, DWORD cb);
DWORD FAR PASCAL mmioCFSetInfo(HMMCF hmmcf, LPMMCFINFO lpmmcfinfo, DWORD cb);
LPMMCTOCENTRY FAR PASCAL mmioCFFindEntry(HMMCF hmmcf, LPWSTR szName,
        UINT uFlags, LONG lParam);

#endif // MMIOCF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\mixer.h ===
/******************************Module*Header*******************************\
* Module Name: mixer.h
*
* Internal header file for mixer.c
*
*
* Created: 27-10-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993-2001 Microsoft Corporation
\**************************************************************************/
#define UNICODE
#ifndef WIN32
#define WIN32
#endif

#include <stdlib.h>
#include <windows.h>
#include "mmsystem.h"            // pick up the internal one
#include "mmsysp.h"            // pick up the internal one
#include "mmddk.h"
#define NONEWWAVE
#include <mmreg.h>
#undef NONEWWAVE

//
//  Avoid including msacm.h - in any case this define should be in mmreg.h
//
#ifndef DRVM_MAPPER_STATUS
#define DRVM_MAPPER_STATUS              (0x2000)
#endif

#ifndef WIDM_MAPPER_STATUS
#define WIDM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEIN_MAPPER_STATUS_DEVICE     0
#define WAVEIN_MAPPER_STATUS_MAPPED     1
#endif

#ifndef WODM_MAPPER_STATUS
#define WODM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEOUT_MAPPER_STATUS_DEVICE    0
#define WAVEOUT_MAPPER_STATUS_MAPPED    1
#endif

#define MMDDKINC
#include "winmmi.h"

#define MIXMGR_ENTER EnterCriticalSection(&HandleListCritSec)
#define MIXMGR_LEAVE LeaveCriticalSection(&HandleListCritSec)

//typedef struct
//{
//    HDRVR               hdrvr;      // handle to the module
//    DRIVERMSGPROC       drvMessage; // pointer to entry point
//    BYTE                bNumDevs;   // number of devices supported
//    BYTE                bUsage;     // usage count (number of handles open)
//    DWORD               cookie;     // cookie used for WDM devices.
//    CRITICAL_SECTION    MixerCritSec; // Serialize use of mixer
//    WCHAR               wszDrvEntry[64]; // driver filename
//} MIXERDRV, *PMIXERDRV;

typedef struct tMIXERDEV
{
    UINT                uHandleType;    // for parameter validation

    struct tMIXERDEV   *pmxdevNext;     /* How quaint, a linked list... */
    PMIXERDRV           pmxdrv;
    UINT                wDevice;
    DWORD_PTR           dwDrvUser;
    UINT                uDeviceID;

    DWORD               fdwSupport;     // from the driver's mixercaps
    DWORD               cDestinations;  // from the driver's mixercaps

    DWORD_PTR           dwCallback;     // client's callback and inst data
    DWORD_PTR           dwInstance;

    DWORD               fdwOpen;        /* The open flags the caller used */
    DWORD               fdwHandle;
} MIXERDEV, *PMIXERDEV;

/* -------------------------------------------------------------------------
** internal function prototypes
** -------------------------------------------------------------------------
*/
BOOL CALLBACK MixerCallbackFunc(
    HMIXER hmx,
    UINT uMsg,
    DWORD_PTR dwInstance,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2
);


MMRESULT mixerReferenceDriverById(
    IN UINT uId,
    OUT PMIXERDRV *ppdrv OPTIONAL,
    OUT UINT *pport OPTIONAL
);

DWORD NEAR PASCAL IMixerMessageHandle(
    HMIXER hmx,
    UINT uMsg,
    DWORD_PTR dwP1,
    DWORD_PTR dwP2
);

DWORD NEAR PASCAL IMixerMessageId(
    UINT uDeviceID,
    UINT uMsg,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2
);

void
ConvertMIXERLINEWToMIXERLINEA(
    PMIXERLINEA pmxlA,
    PMIXERLINEW pmxlW
);

MMRESULT IMixerGetID(
    HMIXEROBJ hmxobj,
    PUINT puMxId,
    LPMIXERLINE pmxl,
    DWORD fdwId
);


/* -------------------------------------------------------------------------
** Loading and initialization functions
** -------------------------------------------------------------------------
*/
BOOL mmDrvInstallMixer(
    HDRVR           hdrvr,
    DRIVERMSGPROC   drvMessage,
    UINT            wFlags,
    LPCTSTR         tszDrvEntry
);

BOOL IMixerUnloadDrivers(
    HDRVR hdrvrSelf
);

HDRVR mmDrvOpenMixer(
    LPTSTR szAlias
);

BOOL IMixerLoadDrivers(
    void
);

/* -------------------------------------------------------------------------
** Make sizeof return the number of chars when applied to a character array
** which may be unicoded.
** -------------------------------------------------------------------------
*/
#ifdef UNICODE
    #define SIZEOF(x)   (sizeof(x)/sizeof(WCHAR))
#else
    #define SIZEOF(x)   sizeof(x)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\mmioi.h ===
// Copyright (c) 1991-1992 Microsoft Corporation
/* mmioi.h
 *
 * Definitions that are internal to the MMIO library, i.e. shared by MMIO*.C
 */


/* Revision history:
 * LaurieGr: Jan 92 Ported from win16.  Source tree fork, not common code.
 * StephenE: Apr 92 added unicode to ascii conversion function prototypes.
 */

#include "mmiocf.h"

#include "mmiocf.h"
typedef MMIOINFO *PMMIO;                // (Win32)

typedef struct _MMIODOSINFO             // How DOS IOProc uses MMIO.adwInfo[]
{
        int             fh;             // DOS file handle
} MMIODOSINFO;

typedef struct _MMIOMEMINFO             // How MEM IOProc uses MMIO.adwInfo[]
{
        LONG            lExpand;        // increment to expand mem. files by
} MMIOMEMINFO;

typedef struct _MMIOBNDINFO             // How BND IOProc uses MMIO.adwInfo[]
{
        HMMCF           hmmcf;          // which compound file owns this element
        WORD            wPad;           // make adwInfo[0] equals <hmmcf>
        LPMMCTOCENTRY   pEntry;         // pointer to CTOC table entry
} MMIOBNDINFO;

typedef struct _MMCF
{
        HMMIO           hmmio;          // open file that contains CTOC and CGRP
        LPMMCFINFO      pHeader;        // ptr. to beginning of CTOC
        WORD            cbHeader;       // size of CTOC header
        HPSTR           pEntries;       // ptr. to first CTOC table entry
        HANDLE          hmmcfNext;      // next CF in list
        HANDLE          hmmcfPrev;      // previous CF in list
        HANDLE          hTask;          // handle to task that owns this
        LONG            lUsage;         // usage count
        WORD            wFlags;         // random flags
        LONG            lTotalExpand;   // how much CF expanded (to fix RIFF())

        /* information about each entry */
        WORD            wEntrySize;     // size of each <CTOC-table-entry>
        WORD            wEntFlagsOffset; // offset of <bEntryFlags> in an entry
        WORD            wEntNameOffset; // offset of <achName> in an entry

        /* offsets of parts of compound file (relative to start of file) */
        LONG            lStartCTOC;     // offset of start of CTOC chunk (or -1)
        LONG            lEndCTOC;       // offset of end of CTOC chunk (or -1)
        LONG            lStartCGRP;     // offset of start of CGRP chunk (or -1)
        DWORD           lStartCGRPData; // offset of data part of CGRP chunk
        LONG            lEndCGRP;       // offset of end of CGRP chunk (or -1)
        LONG            lEndFile;       // offset of end of CGRP chunk (or -1)
} MMCF, NEAR *PMMCF;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\mmioriff.c ===
/* Copyright (c) 1991-1995 Microsoft Corporation */
/* mmioriff.c
 *
 * MMIO RIFF functions.
 */

/* Revision history:
   LaurieGr: Jan 92 Ported from win16.  Source tree fork, not common code.
*/

#define VALIDATE_PARMS
#include "winmmi.h"
#include "mmioi.h"

static  BYTE bPad;

/* @doc EXTERNAL

@api    MMRESULT | mmioDescend | This function descends into a chunk of a
    RIFF file opened with <f mmioOpen>. It can also search for a given
    chunk.

@parm   HMMIO | hmmio | Specifies the file handle of an open RIFF file.

@parm   LPMMCKINFO | lpck | Specifies a pointer to a
    caller-supplied  <t MMCKINFO> structure that <f mmioDescend> fills
    with the following information:

    -- The <e MMCKINFO.ckid> field is the chunk ID of the chunk.

    -- The <e MMCKINFO.cksize> field is the size of the data portion
    of the chunk. The data size includes the form type or list type (if
    any), but does not include the 8-byte chunk header or the pad byte at
    the end of the data (if any).

    -- The <e MMCKINFO.fccType> field is the form type if
    <e MMCKINFO.ckid> is "RIFF", or the list type if
    <e MMCKINFO.ckid> is "LIST". Otherwise, it is NULL.

    -- The <e MMCKINFO.dwDataOffset> field is the file offset of the
    beginning of the data portion of the chunk. If the chunk is a
    "RIFF" chunk or a "LIST" chunk, then <e MMCKINFO.dwDataOffset>
    is the offset of the form type or list type.

    -- The <e MMCKINFO.dwFlags> contains other information about the chunk.
    Currently, this information is not used and is set to zero.

    If the MMIO_FINDCHUNK, MMIO_FINDRIFF, or MMIO_FINDLIST flag is
    specified for <p uFlags>, then the <t MMCKINFO> structure is also
    used to pass parameters to <f mmioDescend>:

    -- The <e MMCKINFO.ckid> field specifies the four-character code
    of the chunk ID, form type, or list type to search for.

@parm   LPMMCKINFO | lpckParent | Specifies a pointer to an
    optional caller-supplied <t MMCKINFO> structure identifying
    the parent of the chunk being searched for.
    A parent of a chunk is the enclosing chunk--only "RIFF" and "LIST"
    chunks can be parents.  If <p lpckParent> is not NULL, then
    <f mmioDescend> assumes the <t MMCKINFO> structure it refers to
    was filled when <f mmioDescend> was called to descend into the parent
    chunk, and <f mmioDescend> will only search for a chunk within the
    parent chunk. Set <p lpckParent> to NULL if no parent chunk is
    being specified.

@parm   UINT | uFlags | Specifies search options. Contains up to one
    of the following flags. If no flags are specified,
    <f mmioDescend> descends into the chunk beginning at the current file
    position.

    @flag   MMIO_FINDCHUNK | Searches for a chunk with the specified chunk ID.

    @flag   MMIO_FINDRIFF | Searches for a chunk with chunk ID "RIFF"
        and with the specified form type.

    @flag   MMIO_FINDLIST | Searches for a chunk with chunk ID "LIST"
        and with the specified form type.

@rdesc  The return value is zero if the function is successful.
    Otherwise, the return value specifies an error code. If the end of
    the file (or the end of the parent chunk, if given) is reached before
    the desired chunk is found, the return value is
    MMIOERR_CHUNKNOTFOUND.
    Other error return values are possible, for instance MMIOERR_CANNOTSEEK.

@comm   A RIFF chunk consists of a four-byte chunk ID (type FOURCC),
    followed by a four-byte chunk size (type DWORD), followed
    by the data portion of the chunk, followed by a null pad byte if
    the size of the data portion is odd. If the chunk ID is "RIFF" or
    "LIST", the first four bytes of the data portion of the chunk are
    a form type or list type (type FOURCC).

    If <f mmioDescend> is used to search for a chunk, the file
    position should be at the beginning of a
    chunk before calling <f mmioDescend>. The search begins at the
    current file position and continues to the end of the file. If a
    parent chunk is specified, the file position should be somewhere
    within the parent chunk before calling <f mmioDescend>. In this case,
    the search begins at the current file position and continues to the
    end of the parent chunk.

    If <f mmioDescend> is unsuccessful in searching for a chunk, the
    current file position is undefined. If <f mmioDescend> is
    successful, the current file position is changed. If the chunk
    is a "RIFF" or "LIST" chunk, the new file position
    will be just after the form type or list type (12 bytes from the
    beginning of the chunk). For other chunks, the new file position will be
    the start of the data portion of the chunk (8 bytes from the
    beginning of the chunk).

    For efficient RIFF file I/O, use buffered I/O.

    @xref   mmioAscend MMCKINFO
*/
MMRESULT APIENTRY
   mmioDescend(HMMIO hmmio, LPMMCKINFO lpck, LPCMMCKINFO lpckParent, UINT uFlags)
{
    FOURCC      ckidFind;   // chunk ID to find (or NULL)
    FOURCC      fccTypeFind;    // form/list type to find (or NULL)

#ifdef VALIDATE_PARMS
    V_FLAGS(uFlags, MMIO_DESCEND_VALID, mmioDescend, MMSYSERR_INVALFLAG);
    V_WPOINTER(lpck, sizeof(MMCKINFO), MMSYSERR_INVALPARAM);
    V_RPOINTER0(lpckParent, sizeof(MMCKINFO), MMSYSERR_INVALPARAM);
#endif
    /* figure out what chunk id and form/list type to search for */
    if (uFlags & MMIO_FINDCHUNK)
        ckidFind = lpck->ckid, fccTypeFind = 0;
    else
    if (uFlags & MMIO_FINDRIFF)
        ckidFind = FOURCC_RIFF, fccTypeFind = lpck->fccType;
    else
    if (uFlags & MMIO_FINDLIST)
        ckidFind = FOURCC_LIST, fccTypeFind = lpck->fccType;
    else
        ckidFind = fccTypeFind = 0;

    lpck->dwFlags = 0L;

    if (hmmio == NULL) return MMIOERR_OUTOFMEMORY;

    for(;;)
    {
        MMRESULT  mmr;

        /* read the chunk header */
        if (mmioRead(hmmio, (LPSTR) lpck, 2 * sizeof(DWORD)) !=
            2 * sizeof(DWORD))
            return MMIOERR_CHUNKNOTFOUND;

        /* store the offset of the data part of the chunk */
        if ((lpck->dwDataOffset = mmioSeek(hmmio, 0L, SEEK_CUR)) == -1)
            return MMIOERR_CANNOTSEEK;

        /* see if the chunk is within the parent chunk (if given) */
        if ((lpckParent != NULL) &&
            (lpck->dwDataOffset - 8L >=
             lpckParent->dwDataOffset + lpckParent->cksize))
            return MMIOERR_CHUNKNOTFOUND;

        /* if the chunk if a 'RIFF' or 'LIST' chunk, read the
         * form type or list type
         */
        if ((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
        {
            if (!hmmio)
                return MMIOERR_CHUNKNOTFOUND;

            if (mmioRead(hmmio, (LPSTR) &lpck->fccType,
                     sizeof(DWORD)) != sizeof(DWORD))
                return MMIOERR_CHUNKNOTFOUND;
        }
        else
            lpck->fccType = 0;

        /* if this is the chunk we're looking for, stop looking */
        if ( ((ckidFind == 0) || (ckidFind == lpck->ckid)) &&
             ((fccTypeFind == 0) || (fccTypeFind == lpck->fccType)) )
            break;

        /* ascend out of the chunk and try again */
        if ((mmr = mmioAscend(hmmio, lpck, 0)) != 0)
            return mmr;
    }

    return 0;
}


/* @doc EXTERNAL MMIO_RIFF

@api    MMRESULT | mmioAscend | This function ascends out of a chunk in a
    RIFF file descended into with <f mmioDescend> or created with
    <f mmioCreateChunk>.

@parm   HMMIO | hmmio | Specifies the file handle of an open RIFF file.

@parm   LPMMCKINFO | lpck | Specifies a pointer to a
    caller-supplied <t MMCKINFO> structure previously filled by
    <f mmioDescend> or <f mmioCreateChunk>.

@parm   UINT | uFlags | Is not used and should be set to zero.

@rdesc  The return value is zero if the function is successful.
    Otherwise, the return value specifies an error code. The error
    code can be one of the following codes:

    @flag MMIOERR_CANNOTWRITE | The contents of the buffer could
    not be written to disk.

    @flag MMIOERR_CANNOTSEEK | There was an error while seeking to
    the end of the chunk.

@comm   If the chunk was descended into using <f mmioDescend>, then
    <f mmioAscend> seeks to the location following the end of the
    chunk (past the extra pad byte, if any).

    If the chunk was created and descended into using
    <f mmioCreateChunk>, or if the MMIO_DIRTY flag is set in the
    <e MMCKINFO.dwFlags> field of the <t MMCKINFO> structure
    referenced by <p lpck>, then the current file position
    is assumed to be the end of the data portion of the chunk.
    If the chunk size is not the same as the value stored
    in the <e MMCKINFO.cksize> field when <f mmioCreateChunk>
    was called, then <f mmioAscend> corrects the chunk
    size in the file before ascending from the chunk. If the chunk
    size is odd, <f mmioAscend> writes a null pad byte at the end of the
    chunk. After ascending from the chunk, the current file position is
    the location following the end of the chunk (past the extra pad byte,
    if any).

@xref   mmioDescend mmioCreateChunk MMCKINFO
*/
MMRESULT APIENTRY
mmioAscend(HMMIO hmmio, LPMMCKINFO lpck, UINT uFlags)
{
    LONG lSeekPos;
#ifdef VALIDATE_PARMS
    V_FLAGS(uFlags, 0, mmioAscend, MMSYSERR_INVALFLAG);
    V_WPOINTER(lpck, sizeof(MMCKINFO), MMSYSERR_INVALPARAM);
#endif

    if (lpck->dwFlags & MMIO_DIRTY)
    {
        /* <lpck> refers to a chunk created by mmioCreateChunk();
         * check that the chunk size that was written when
         * mmioCreateChunk() was called is the real chunk size;
         * if not, fix it
         */
        LONG        lOffset;    // current offset in file
        LONG        lActualSize;    // actual size of chunk data

        if (hmmio == NULL) return MMIOERR_OUTOFMEMORY;

        if ((lOffset = mmioSeek(hmmio, 0L, SEEK_CUR)) == -1)
            return MMIOERR_CANNOTSEEK;
        if ((lActualSize = lOffset - lpck->dwDataOffset) < 0)
            return MMIOERR_CANNOTWRITE;

        if (LOWORD(lActualSize) & 1)
        {    
            if (hmmio == NULL) 
                return MMIOERR_CANNOTWRITE;

            /* chunk size is odd -- write a null pad byte */
            if (mmioWrite(hmmio, (LPSTR) &bPad, sizeof(bPad))
                    != sizeof(bPad))
                return MMIOERR_CANNOTWRITE;

        }

        if (lpck->cksize == (DWORD)lActualSize)
            return 0;

        /* fix the chunk header */
        lpck->cksize = lActualSize;
        if (mmioSeek(hmmio, lpck->dwDataOffset
                - sizeof(DWORD), SEEK_SET) == -1)
            return MMIOERR_CANNOTSEEK;
        if (mmioWrite(hmmio, (LPSTR) &lpck->cksize,
                sizeof(DWORD)) != sizeof(DWORD))
            return MMIOERR_CANNOTWRITE;
    }

    // make sure that when we seek, we will be ADVANCING.  otherwise
    // we could get stuck in a loop trying to descend/ascend and never
    // going forward through the file
    //
    lSeekPos = lpck->dwDataOffset + lpck->cksize + (lpck->cksize & 1);
    if ((LONG)lpck->dwDataOffset < 0 || lSeekPos < (LONG)lpck->dwDataOffset)
        return MMIOERR_INVALIDFILE;

    /* seek to the end of the chunk, past the null pad byte
     * (which is only there if chunk size is odd)
     */
    if (mmioSeek(hmmio, lSeekPos, SEEK_SET) == -1)
        return MMIOERR_CANNOTSEEK;

    return 0;
}


/* @doc EXTERNAL MMIO_RIFF

@api    MMRESULT | mmioCreateChunk | This function creates a chunk in a
    RIFF file opened with <f mmioOpen>. The new chunk is created at the
    current file position. After the new chunk is created, the current
    file position is the beginning of the data portion of the new chunk.

@parm   HMMIO | hmmio | Specifies the file handle of an open RIFF
    file.

@parm   LPMMCKINFO | lpck | Specifies a pointer to a caller-supplied
    <t MMCKINFO> structure containing information about the chunk to be
    created. The <t MMCKINFO> structure should be set up as follows:

    -- The <e MMCKINFO.ckid> field specifies the chunk ID of the
    chunk. If <p uFlags> includes MMIO_CREATERIFF or MMIO_CREATELIST,
    this field will be filled by <f mmioCreateChunk>.

    -- The <e MMCKINFO.cksize> field specifies the size of the data
    portion of the chunk, including the form type or list type (if any).
    If this value is not correct when <f mmioAscend> is called to mark
    the end of the chunk, them <f mmioAscend> will correct the chunk
    size.

    -- The <e MMCKINFO.fccType> field specifies the form type or list
    type if the chunk is a "RIFF" or "LIST" chunk. If the chunk is not a
    "RIFF" or "LIST" chunk, this field need not be filled in.

    -- The <e MMCKINFO.dwDataOffset> field need not be filled in. The
    <f mmioCreateChunk> function will fill this field with the file
    offset of the data portion of the chunk.

    -- The <e MMCKINFO.dwFlags> field need not be filled in. The
    <f mmioCreateChunk> function will set the MMIO_DIRTY flag in
    <e MMCKINFO.dwFlags>.

@parm   UINT | uFlags | Specifies flags to optionally create either a
    "RIFF" chunk or a "LIST" chunk. Can contain one of the following
    flags:

    @flag   MMIO_CREATERIFF | Creates a "RIFF" chunk.

    @flag   MMIO_CREATELIST | Creates a "LIST" chunk.

@rdesc  The return value is zero if the function is successful.
    Otherwise, the return value specifies an error code. The error
    code can be one of the following codes:

    @flag MMIOERR_CANNOTWRITE | Unable to write the chunk header.

    @flag MMIOERR_CANNOTSEEK | Uanble to determine offset of data
    portion of the chunk.

@comm   This function cannot insert a chunk into the middle of a
    file. If a chunk is created anywhere but the end of a file,
    <f mmioCreateChunk> will overwrite existing information in the file.
*/
MMRESULT APIENTRY
mmioCreateChunk(HMMIO hmmio, LPMMCKINFO lpck, UINT uFlags)
{
    int     iBytes;         // bytes to write
    LONG        lOffset;    // current offset in file

#ifdef VALIDATE_PARMS
    V_FLAGS(uFlags, MMIO_CREATE_VALID, mmioCreateChunk, MMSYSERR_INVALFLAG);
    V_WPOINTER(lpck, sizeof(MMCKINFO), MMSYSERR_INVALPARAM);
#endif

    /* store the offset of the data part of the chunk */
    if ((lOffset = mmioSeek(hmmio, 0L, SEEK_CUR)) == -1)
        return MMIOERR_CANNOTSEEK;
    lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

    /* figure out if a form/list type needs to be written */
    if (uFlags & MMIO_CREATERIFF)
        lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
    else
    if (uFlags & MMIO_CREATELIST)
        lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
    else
        iBytes = 2 * sizeof(DWORD);

    if (hmmio == NULL) return MMIOERR_CANNOTWRITE;

    /* write the chunk header */
    if (mmioWrite(hmmio, (LPSTR) lpck, (LONG) iBytes) != (LONG) iBytes)
        return MMIOERR_CANNOTWRITE;

    lpck->dwFlags = MMIO_DIRTY;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\mmwnd.c ===
/******************************************************************************

   Copyright (c) 1985-1998 Microsoft Corporation

   Title:   mmwnd.c - contains the window procedure for the WINMM 'global'
                      window

                      the global window is used by sndPlaySound and MCI for
                      reciving notification messages.

   Version: 1.00

   Date:    04-Sep-1990

   Author:  ToddLa

   Changes: SteveDav Jan 92   Ported to NT

*****************************************************************************/

#include "winmmi.h"
#include "mci.h"

// WINMMI.H includes WINDOWS.H which will eventually include WINMM.H

//#ifdef DBG
//    #include "netname.h"
//#endif // DBG

#define CLASS_NAME MAKEINTATOM(43)   // 42 clashes with 16-bit mmsystem

DWORD mciWindowThreadId;

STATICFN LRESULT mmWndProc(HWND hwnd, MMMESSAGE msg, WPARAM wParam, LPARAM lParam);
STATICFN BOOL	WaitForWaitMsg(void);


typedef struct SentMsg {
    LRESULT Result;
    MMMESSAGE msg;
    WPARAM  wParam;
    LPARAM  lParam;
    UINT    SendingThread;
} SENTMSG, * PSENTMSG;

/*
**  Client notification stuff
*/

HWND             hwndNotify = NULL;

/*
**  Server notification stuff
*/

PGLOBALMCI       base;
CRITICAL_SECTION mciGlobalCritSec;
HANDLE           hEvent;

/***************************************************************************/

STATICDT BOOL classcreated = FALSE;

STATICFN BOOL PASCAL FAR CreateMMClass(
    void)
{
    WNDCLASS cls;

    if (classcreated) {
        return(TRUE);
    }

    ZeroMemory(&cls, sizeof(WNDCLASS));

    cls.hCursor        = NULL;
    cls.hIcon          = LoadIcon(ghInst, MAKEINTRESOURCE(IDI_MCIHWND));
    cls.lpszMenuName   = NULL;
    cls.lpszClassName  = CLASS_NAME;
    cls.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
    cls.hInstance      = ghInst;
    cls.style          = CS_GLOBALCLASS;
    cls.lpfnWndProc    = (WNDPROC)mmWndProc;
    cls.cbWndExtra     = 0;
    cls.cbClsExtra     = 0;

    classcreated = RegisterClass(&cls);
    return classcreated;
}


STATICDT CHAR mciWndName[] = "MCI command handling window";

//
//
//
BOOL mciGlobalInit(
    void)
{
    return TRUE;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif
//
//
//
STATICFN DWORD mciwnd2(LPVOID lpParams)
{
    UINT    msg;
    LPCWSTR lszSound;
    DWORD   wFlags;
    DWORD   n;
    WCHAR   soundname[MAX_PATH];

    while (TRUE) {

        LockMCIGlobal;
        if (!base->msg) {

#ifdef LATER
    This still needs to be tidied up.  The intention is to have a
    list of sounds that should be played.  This will also make it
    easier to STOP all sound playing by clearing out the list.
#endif
            // We have no work to do; reset the event and wait for
            // more work to be posted.  By setting the event within
            // the lock we are safe from timing windows.

            ResetMCIEvent(hEvent);
            UnlockMCIGlobal;
            dprintf2(("MCIWND2 thread waiting for next event..."));
            n = WaitForSingleObject(hEvent, WAIT_FOREVER);

#if DBG
            if ((DWORD)-1 == n) {
                n = GetLastError();
                dprintf2(("Error %d waiting on event in worker thread", n));
            }
#endif
            LockMCIGlobal;
    	}

        msg = base->msg;
        wFlags = base->dwFlags;
        lszSound = base->lszSound;

        base->msg=0;
        if (wFlags & SND_FILENAME) {
            // Have to copy the file name
            wcscpy(soundname, base->szSound);
            lszSound = soundname;
            dprintf3(("Copying the soundfile name to a local variable: %ls", lszSound));
        } else {
            dprintf3(("Playing a system sound"));
        }

        UnlockMCIGlobal;

        PlaySoundW(lszSound, NULL, (wFlags & ~SND_ASYNC)); // Play sync
    }

#if DBG
    dprintf(("MCIWND2 thread ending...!!"));
#endif
    return(0);
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

/***************************************************************************
 *
 * @doc     INTERNAL    WINMM
 *
 * @api     void | WndTerminate | called when WINMM is terminating
 *
 ***************************************************************************/

STATICFN void NEAR PASCAL WndTerminate(
    void)
{
    dprintf1(("hwndNotify terminating"));
    if (hwndNotify)
    {
        dprintf1(("sending Close\n"));
        SendMessage(hwndNotify, WM_CLOSE, 0, 0L);
        UnregisterClass(CLASS_NAME, ghInst);
    }
}

/***************************************************************************
 *
 * @doc     INTERNAL    WINMM
 *
 * @api     LRESULT | mmWndProc | The Window procedure for the WINMM window
 *
 * @comm    mmWndProc calls DefWindowProc for all messages except:
 *
 *          MM_MCINOTIFY:       calls MciNotify()        in MCI.C
 *          MM_WOM_DONE:        calls WaveOutNotify()    in PLAYWAV.C
 *
 * @xref    sndPlaySound
 *
 ***************************************************************************/

STATICFN LRESULT mmWndProc(
    HWND    hwnd,
    MMMESSAGE msg,
    WPARAM  wParam,
    LPARAM  lParam)
{

#if DBG
    dprintf4(("MMWNDPROC: Msg %5x  Hwnd=%8x\r\n     wParam=%8x  lParam=%8x", msg, hwnd, wParam, lParam));
#endif
    switch (msg)
    {
        case WM_CREATE:
            hwndNotify = hwnd;
            break;

        case MM_MCINOTIFY:
            MciNotify((DWORD)wParam, (LONG)lParam);
            break;

#define NODELAY
#ifdef NODELAY
        case MM_WOM_DONE:

            /*
                The sound started with sndPlaySound has completed
                so we should call the cleanup routine. On NT we do NOT
                delay as the wave really has finished playing.
            */

            dprintf2(("Received MM_WOM_DONE, calling WaveOutNotify"));
            WaveOutNotify(0,0);

            break;
#else
/*
   SOUND_DELAY is the number of ms to delay before closing the wave device
   after the buffer is done.
*/

#define SOUND_DELAY 300
        case WM_TIMER:
            KillTimer(hwnd, (UINT)wParam);
            WaveOutNotify(0,0);
            break;

        case MM_WOM_DONE:

            /*
                The sound started with sndPlaySound has completed
                so we should call the cleanup routine. We delay
                this call for several hundred milliseconds because
                some sound drivers have a nasty characteristic - they
                will notify before the final DMA transfer is complete
                because the app. supplied buffer is no longer required.
                This means that they may have to spin inside a close
                request until the dma transfer completes. This hangs
                the system for hundreds of milliseconds.

            */

            dprintf2(("Received MM_WOM_DONE, setting timer delay"));

            SetTimer(hwndNotify, 1, SOUND_DELAY, NULL);
            break;
#endif

    	case MM_SND_ABORT:  /* Do not need to do anything */
    		break;

        case MM_SND_PLAY:
	{
	    // There is a critical section problem as we have one global, and
	    // sounds being played on separate threads.
	    MSG abortmsg;
	    if (SND_ALIAS_ID == (wParam & SND_ALIAS_ID)) {
	    return((LRESULT)PlaySound((LPCSTR)lParam, NULL, (DWORD)wParam & ~SND_ASYNC));
	    }
	    if (!PeekMessage(&abortmsg, hwnd, MM_SND_ABORT, MM_SND_ABORT, PM_NOREMOVE)) {
	        // There is no pending synchronous sound
	        return (LRESULT)(LONG)sndMessage((LPWSTR)lParam, (UINT)wParam);
	    }
	    // We must free the sound definition.  Note that this does not close
	    // the critical section as we may be past this check point when the
	    // synchronous sound causes the abort message to be posted.  But it
	    // will prevent spurious code being run.  It is perfectly valid for
	    // an asynchronous sound to be after the abort message, which is
	    // why the message is not removed at this point.
	    dprintf3(("Aborting sound..."));
	    if (!(wParam & SND_MEMORY)) {
		LocalFree((HANDLE)lParam);
	    }
	    break;
	}

	case MM_SND_SEND:
            ((PSENTMSG)wParam)->Result =
		mmWndProc(NULL, ((PSENTMSG)wParam)->msg,
		                  ((PSENTMSG)wParam)->wParam,
		                  ((PSENTMSG)wParam)->lParam);
	    PostThreadMessage(((PSENTMSG)wParam)->SendingThread, MCIWAITMSG, 0, 0);
	    break;

	case MM_POLYMSGBUFRDONE:
		--(((PMIDIEMU)wParam)->cPostedBuffers);
		midiOutNukePMBuffer((PMIDIEMU)wParam, (LPMIDIHDR)lParam);
		return (0L);

        case MM_MCISYSTEM_STRING:
            // In MCI.C
            return (LRESULT)mciRelaySystemString ((LPMCI_SYSTEM_MESSAGE)lParam);

        default:
            return DefWindowProc(hwnd, msg, wParam,lParam);
    }

    return (LRESULT)0L;
}

void mciwindow(HANDLE hEvent);


/*
**  Initialize all the bits for creating sound.  For non-server apps this
**  means initializing our hwnd.  For the server we set up a thread et
*/
BOOL InitAsyncSound(VOID)
{
    if (!WinmmRunningInServer) {
        return CreatehwndNotify();
    } else {

        LockMCIGlobal;

        if (base == NULL) {
            HANDLE hThread;
            PGLOBALMCI pBase;

            /*
            **  We need a thread, an event (we already have the crit sec) and
            **  some memory
            */


            pBase = mciAlloc(sizeof(GLOBALMCI));

            if (pBase == NULL) {
                UnlockMCIGlobal;
                return FALSE;
            }

            hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
            if (hEvent == NULL) {
                mciFree((PVOID)pBase);
                UnlockMCIGlobal;
                return FALSE;
            }

            /*
            **  We have to create a thread by a special method inside the
            **  server and register it with CSR
            */

            if (!CreateServerPlayingThread((PVOID)mciwnd2)) {
                mciFree((PVOID)pBase);
                CloseHandle(hEvent);
                hEvent = NULL;
                UnlockMCIGlobal;
                return FALSE;
            }

            base = pBase;

        }

        UnlockMCIGlobal;

        return base != NULL;
    }
}

BOOL CreatehwndNotify(VOID)
{
    HANDLE hWindowThread;
    BOOL   ReturnCode;
    HANDLE hEventForCreate;

    mciEnter("CreatehwndNotify");

    if (hwndNotify != NULL) {
        mciLeave("CreatehwndNotify");
        return TRUE;
    }

    if (!CreateMMClass()) {
        dprintf1(("Failed to create the MCI global window class, rc=%d", GetLastError()));
        mciLeave("CreatehwndNotify");
        return FALSE;
    } else {
        dprintf4(("Created global window class"));
    }

    // We create our new thread then suspend ourselves until the new
    // thread has called CreateWindow.  We are then triggered to run
    // and passed the results of the CreateWindow call.  NOTE:  Any
    // messages that arrive for this thread that are not destined for
    // a specific window will be DISCARDED until the one message we
    // are waiting for arrives.  We could create an event and wait
    // for that event to be triggered.  This was slightly quicker to
    // code and involves less creation/destruction of resources.

    hEventForCreate = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (hEventForCreate != NULL) {
        hWindowThread = CreateThread(NULL,  // attributes
                               0,           // same stack size as thread 1
                               (LPTHREAD_START_ROUTINE)mciwindow,
                               (LPVOID) hEventForCreate,
                               0,  // Thread runs immediately
                               &mciWindowThreadId
                               );
        CloseHandle(hWindowThread);

        if (!hWindowThread) {
            dprintf1(("Failed to create window thread. Error: %XH", GetLastError()));

        } else {
            dprintf3(("Window thread is %x", mciWindowThreadId));

        	WaitForSingleObject(hEventForCreate, INFINITE);

        	dprintf3(("hwndNotify now %x", hwndNotify));
        }
        CloseHandle(hEventForCreate);
    }
    ReturnCode = hwndNotify != NULL;
    mciLeave("CreatehwndNotify");

    return ReturnCode;
}

void mciwindow(
    HANDLE hEvent)

{
    BOOL fResult = TRUE;

    //
    //  Higher priority so we hear the sound at once!
    //  This seems to work better than calling SetThreadPriority
    //  on the handle just after creation (?).

    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);

    if (!(hwndNotify = CreateWindowEx(0, CLASS_NAME, mciWndName, WS_OVERLAPPED,
           0, 0, 0, 0, NULL, NULL, ghInst, NULL))) {
        dprintf1(("Failed to create the MCI global window, rc=%d", GetLastError()));
        UnregisterClass(CLASS_NAME, ghInst);
        fResult = FALSE;
    }

    //
    // Let our creator thread know we are up and running
    //
    SetEvent(hEvent);

    if (fResult) {
        MSG msg;
        HWND hwndTemp;

        while (GetMessage(&msg, NULL, 0, 0)) {


            /*
             *   If the message is for a window dispatch it
             */
            dprintf3(("mciwindow - Msg %5x hwnd %8x (%8x %8x)", msg.message, msg.hwnd, msg.wParam, msg.lParam));
            if (msg.hwnd != NULL) {
                DispatchMessage(&msg);
            }
    	}

        hwndTemp = hwndNotify;
        hwndNotify = NULL;    // Clear the global before destroying the window
        DestroyWindow(hwndTemp);
    }

    ExitThread(0);
}

#if 0   //LATER - not currently used

//
// Routine to SEND (synchronous) a message to another thread.  Currently
// the standard API allows you to send a message to a window, or post to
// a thread.  There are circumstances when it would be helpful to send
// to a thread.
//

STATICFN LRESULT SendThreadMessage(
    UINT    tid,
    MMMESSAGE msg,
    WPARAM  wParam,
    LPARAM  lParam)
{

    SENTMSG smsg;
    smsg.msg = msg;
    smsg.wParam = wParam;
    smsg.lParam = lParam;
    smsg.SendingThread = GetCurrentThreadId();
    PostThreadMessage(tid, MM_SND_SEND, (WPARAM)&smsg, 0);
    WaitForWaitMsg();
    return(smsg.Result);
}
#endif

/*********************************************************************\
* WaitForWaitMsg:                                                     *
*                                                                     *
* This routine waits until a specific message is returned to this     *
* thread.  While waiting NO posted messages are processed, but sent   *
* messages will be handled within GetMessage.  The routine is used    *
* to synchronise two threads of execution, and to implement a         *
* synchronous PostMessage operation between threads.                  *
*                                                                     *
\*********************************************************************/

STATICFN BOOL	WaitForWaitMsg() {
    for (;;) {
    	MSG msg;
        /*
         *   Retrieve our particular message
    	 */
    	GetMessage(&msg, NULL, MCIWAITMSG, MCIWAITMSG);

        /*
    	 *   If the message is for a window dispatch it
    	 */
        WinAssert(msg.hwnd == NULL);
#if 0
    	if (msg.hwnd != NULL) {      // This should not be executed.
    		DispatchMessage(&msg);   // MCIWAITMSG is not sent to a window
    	} else
#endif
    	    /*
    	     *   MCIWAITMSG is the signal message
    	     */
    		if (msg.message == MCIWAITMSG) {
    			break;
    		}
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\mmwow32.c ===
/******************************Module*Header*******************************\
* Module Name: mmwow32.c
*
* This file thunks for the Multi-Media functions.
*
* Created:  1-Jul-1993
* Author: Stephen Estrop [StephenE]
*
* Copyright (c) 1993-1999 Microsoft Corporation
\**************************************************************************/

#define NO_GDI

#ifndef WIN32
#define WIN32
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "winmmi.h"

#define _INC_ALL_WOWSTUFF
#include "mmwow32.h"
#include "mmwowcb.h"

// #define TELL_THE_TRUTH
#define MIN_TIME_PERIOD_WE_RETURN   1

#if DBG
/*
** ----------------------------------------------------------------
** Debugging, Profiling and Tracing variables.
** ----------------------------------------------------------------
*/

int TraceAux     = 0;
int TraceJoy     = 0;
int TraceTime    = 0;
int TraceMix     = 0;
int TraceWaveOut = 0;
int TraceWaveIn  = 0;
int TraceMidiOut = 0;
int TraceMidiIn  = 0;
int DebugLevel   = 0;
int AllocWaveCount;
int AllocMidiCount;

#endif

#ifndef _WIN64

PCALLBACK_DATA      pCallBackData;  // A 32 bit ptr to the 16 bit callback data
CRITICAL_SECTION    mmCriticalSection;
TIMECAPS            g_TimeCaps32;

LPCALL_ICA_HW_INTERRUPT GenerateInterrupt;
LPGETVDMPOINTER         GetVDMPointer;
LPWOWHANDLE32           lpWOWHandle32;
LPWOWHANDLE16           lpWOWHandle16;

DWORD
NotifyCallbackData(
    UINT uDevID,
    UINT uMsg,
    DWORD dwInstance,
    DWORD dwParam1,
    VPCALLBACK_DATA parg16
    );

BOOL APIENTRY
WOW32ResolveMultiMediaHandle(
    UINT uHandleType,
    UINT uMappingDirection,
    WORD wHandle16_In,
    LPWORD lpwHandle16_Out,
    DWORD dwHandle32_In,
    LPDWORD lpdwHandle32_Out
    );

/*
** Constants for use with WOW32ResolveMultiMediaHandle
*/

#define WOW32_DIR_16IN_32OUT        0x0001
#define WOW32_DIR_32IN_16OUT        0x0002


#define WOW32_WAVEIN_HANDLE         0x0003
#define WOW32_WAVEOUT_HANDLE        0x0004
#define WOW32_MIDIOUT_HANDLE        0x0005
#define WOW32_MIDIIN_HANDLE         0x0006

/*
** Constans for auxOutMessage, waveInMessage, waveOutMessage, midiInMessage
** and midiOutMessage.
*/
#define DRV_BUFFER_LOW      (DRV_USER - 0x1000)     // 0x3000
#define DRV_BUFFER_USER     (DRV_USER - 0x0800)     // 0x3800
#define DRV_BUFFER_HIGH     (DRV_USER - 0x0001)     // 0x3FFF


/******************************Public*Routine******************************\
* NotifyCallbackData
*
* This function is called by the 16 bit mmsystem.dll to notify us of the
* address of the callback data structure.  The callback data structure
* has been paged locked so that it can be accessed at interrupt time, this
* also means that we can safely keep a 32 bit pointer to the data.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
NotifyCallbackData(
    UINT uDevID,
    UINT uMsg,
    DWORD dwInstance,
    DWORD dwParam1,
    VPCALLBACK_DATA parg16
    )
{
    HMODULE     hModNTVDM;


    if ( parg16 ) {

        InitializeCriticalSection( &mmCriticalSection );

        hModNTVDM = GetModuleHandleW( (LPCWSTR)L"NTVDM.EXE" );
        if ( hModNTVDM ) {

            *(FARPROC *)&GenerateInterrupt =
                        GetProcAddress( hModNTVDM, "call_ica_hw_interrupt" );
        }

        timeGetDevCaps( &g_TimeCaps32, sizeof(g_TimeCaps32) );

#if !defined(i386)

        /*
        ** Although the Risc PC's support a uPeriodMin of 1ms, WOW does not
        ** seem capable of delivering interrupts at that rate on non
        ** intel platforms.
        */

        g_TimeCaps32.wPeriodMin = 10;
#endif

    }
    else {
        DeleteCriticalSection( &mmCriticalSection );
    }


    dprintf1(( "Notified of callback address %X", parg16 ));
    pCallBackData = GETVDMPTR( parg16 );

    return 0L;
}


/******************************Public*Routine******************************\
* wod32Message
*
* Thunks WODM_Xxxx messages
*
* The dwInstance field is used to save the 32 bit version of the decives
* handle.  So for example a WODM_PAUSE message can be thunked thus.
*      case WODM_PAUSE:
*          return waveOutPause( (HWAVEOUT)dwInstance );
*
*
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD WINAPI
wod32Message(
    UINT uDeviceID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    )
{

#if DBG
    static MSG_NAME name_map[] = {
        WODM_GETNUMDEVS,        "WODM_GETNUMDEVS",
        WODM_GETDEVCAPS,        "WODM_GETDEVCAPS",
        WODM_OPEN,              "WODM_OPEN",
        WODM_CLOSE,             "WODM_CLOSE",
        WODM_PREPARE,           "WODM_PREPARE",
        WODM_UNPREPARE,         "WODM_UNPREPARE",
        WODM_WRITE,             "WODM_WRITE",
        WODM_PAUSE,             "WODM_PAUSE",
        WODM_RESTART,           "WODM_RESTART",
        WODM_RESET,             "WODM_RESET",
        WODM_GETPOS,            "WODM_GETPOS",
        WODM_GETPITCH,          "WODM_GETPITCH",
        WODM_SETPITCH,          "WODM_SETPITCH",
        WODM_GETVOLUME,         "WODM_GETVOLUME",
        WODM_SETVOLUME,         "WODM_SETVOLUME",
        WODM_GETPLAYBACKRATE,   "WODM_GETPLAYBACKRATE",
        WODM_SETPLAYBACKRATE,   "WODM_SETPLAYBACKRATE",
        WODM_BREAKLOOP,         "WODM_BREAKLOOP",
        WODM_BUSY,              "WODM_BUSY",
        WODM_MAPPER_STATUS,     "WODM_MAPPER_STATUS"
    };
    int      i;
    int      n;
#endif

    static  DWORD               dwNumWaveOutDevs;
            DWORD               dwRet = MMSYSERR_NOTSUPPORTED;
            DWORD               dwTmp;
            DWORD UNALIGNED     *lpdwTmp;
            WAVEOUTCAPSA        woCaps;
            MMTIME              mmTime32;

#if DBG
    for( i = 0, n = sizeof(name_map) / sizeof(name_map[0]); i < n; i++ ) {
        if ( name_map[i].uMsg == uMessage ) {
            break;
        }
    }
    if ( i != n ) {
        trace_waveout(( "wod32Message( 0x%X, %s, 0x%X, 0x%X, 0x%X)",
                        uDeviceID, name_map[i].lpstrName, dwInstance,
                        dwParam1, dwParam2 ));
    }
    else {
        trace_waveout(( "wod32Message( 0x%X, 0x%X, 0x%X, 0x%X, 0x%X)",
                        uDeviceID, uMessage, dwInstance,
                        dwParam1, dwParam2 ));
    }
#endif

    /*
    ** Make sure that we are consistent with the WAVE_MAPPER
    */
    if ( LOWORD(uDeviceID) == 0xFFFF ) {
        uDeviceID = (UINT)-1;
    }

    switch ( uMessage ) {

    case WODM_GETNUMDEVS:
        dwRet = waveOutGetNumDevs();
        break;


    case WODM_OPEN:
        dwRet = ThunkCommonWaveOpen( WAVE_OUT_DEVICE, uDeviceID, dwParam1,
                                     dwParam2, dwInstance );
        break;


    case WODM_CLOSE:
        dwRet = waveOutClose( (HWAVEOUT)dwInstance );
        break;


    case WODM_BREAKLOOP:
    case WODM_PAUSE:
    case WODM_RESET:
    case WODM_RESTART:
        dwRet = waveOutMessage( (HWAVEOUT)dwInstance, uMessage, 0L, 0L );
        break;


    case WODM_GETDEVCAPS:
       // Handle
       // Vadimb

        if ( 0 == dwInstance ) {
           dwRet = waveOutGetDevCapsA(uDeviceID, &woCaps, sizeof(woCaps));
        }
        else {
           dwRet = waveOutMessage((HWAVEOUT)dwInstance,
                                  uMessage,
                                  (DWORD)&woCaps,
                                  sizeof(woCaps));
        }

        if ( dwRet == MMSYSERR_NOERROR ) {
            CopyWaveOutCaps( (LPWAVEOUTCAPS16)GETVDMPTR( dwParam1 ),
                             &woCaps, dwParam2 );
        }
        break;


    case WODM_GETVOLUME:
        /*
        ** An application might try to get the volume using either
        ** the device ID (waveOutGetVolume) or a handle to the device
        ** waveOutMessage( WODM_GETVOLUME...), if the later is the case
        ** we must also call waveOutMessage as the device ID will not
        ** necessarily be valid.  Same applies for waveOutSetVolume below.
        */
        if ( dwInstance == 0 ) {
            dwRet = waveOutGetVolume( (HWAVEOUT)uDeviceID, &dwTmp );
        }
        else {
            dwRet = waveOutMessage( (HWAVEOUT)dwInstance, uMessage,
                                    (DWORD)&dwTmp, 0L );
        }
        lpdwTmp = GETVDMPTR( dwParam1 );
        *lpdwTmp = dwTmp;
        break;



    case WODM_GETPITCH:
    case WODM_GETPLAYBACKRATE:
        dwRet = waveOutMessage( (HWAVEOUT)dwInstance, uMessage,
                                (DWORD)&dwTmp, 0L );
        lpdwTmp = GETVDMPTR( dwParam1 );
        *lpdwTmp = dwTmp;
        break;


    case WODM_GETPOS:
        GetMMTime( (LPMMTIME16)GETVDMPTR( dwParam1 ), &mmTime32 );
        dwRet = waveOutGetPosition( (HWAVEOUT)dwInstance, &mmTime32,
                                    sizeof(mmTime32) );
        if ( dwRet == MMSYSERR_NOERROR ) {
            PutMMTime( (LPMMTIME16)GETVDMPTR( dwParam1 ), &mmTime32 );
        }
        break;


    case WODM_UNPREPARE:
        dwRet =  ThunkCommonWaveUnprepareHeader( (HWAVE)dwInstance, dwParam1,
                                                 WAVE_OUT_DEVICE );
        break;


    case WODM_PREPARE:
        dwRet =  ThunkCommonWavePrepareHeader( (HWAVE)dwInstance, dwParam1,
                                               WAVE_OUT_DEVICE );
        break;


    case WODM_SETVOLUME:
        /*
        ** An application might try to set the volume using either
        ** the device ID (waveOutSetVolume) or a handle to the device
        ** waveOutMessage( WODM_SETVOLUME...), if the later is the case
        ** we must also call waveOutMessage as the device ID will not
        ** necessarily be valid.  Same applies for waveOutGetVolume above.
        */
        if ( dwInstance == 0 ) {
            dwRet = waveOutSetVolume( (HWAVEOUT)uDeviceID, dwParam1 );
        }
        else {
            dwRet = waveOutMessage( (HWAVEOUT)dwInstance, uMessage,
                                    dwParam1, dwParam2 );
        }
        break;


    case WODM_SETPITCH:
    case WODM_SETPLAYBACKRATE:
        dwRet = waveOutMessage( (HWAVEOUT)dwInstance, uMessage, dwParam1, 0L );
        break;


    case WODM_WRITE:
        dwRet =  ThunkCommonWaveReadWrite( WAVE_OUT_DEVICE, dwParam1,
                                           dwParam2, dwInstance );
        break;


    case WODM_MAPPER_STATUS:
        {
            WAVEFORMATEX    waveFmtEx;

            switch ( dwParam1 ) {

            case WAVEOUT_MAPPER_STATUS_DEVICE:
            case WAVEOUT_MAPPER_STATUS_MAPPED:
                dwRet = waveOutMessage( (HWAVEOUT)dwInstance, uMessage,
                                        dwParam1, (DWORD)&dwTmp );
                lpdwTmp = GETVDMPTR( dwParam2 );
                *lpdwTmp = dwTmp;
                break;

            case WAVEOUT_MAPPER_STATUS_FORMAT:
                dwRet = waveOutMessage( (HWAVEOUT)dwInstance, uMessage,
                                        dwParam1, (DWORD)&waveFmtEx );

                CopyMemory( (LPVOID)GETVDMPTR( dwParam2 ),
                            (LPVOID)&waveFmtEx, sizeof(WAVEFORMATEX) );
                break;

            default:
                dwRet = MMSYSERR_NOTSUPPORTED;
            }
        }
        break;


    default:
        if ( uMessage >= DRV_BUFFER_LOW && uMessage <= DRV_BUFFER_HIGH ) {
            lpdwTmp = GETVDMPTR( dwParam1 );
        }
        else {
            lpdwTmp = (LPDWORD)dwParam1;
        }
        dwRet = waveOutMessage( (HWAVEOUT)dwInstance, uMessage,
                                (DWORD)lpdwTmp, dwParam2 );
        break;

    }

    trace_waveout(( "-> 0x%X", dwRet ));
    return dwRet;
}




/******************************Public*Routine******************************\
* wid32Message
*
* Thunks WIDM_Xxxx messages
*
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD WINAPI
wid32Message(
    UINT uDeviceID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    )
{
#if DBG
    static MSG_NAME name_map[] = {
        WIDM_GETNUMDEVS,    "WIDM_GETNUMDEVS",
        WIDM_GETDEVCAPS,    "WIDM_GETDEVCAPS",
        WIDM_OPEN,          "WIDM_OPEN",
        WIDM_CLOSE,         "WIDM_CLOSE",
        WIDM_PREPARE,       "WIDM_PREPARE",
        WIDM_UNPREPARE,     "WIDM_UNPREPARE",
        WIDM_ADDBUFFER,     "WIDM_ADDBUFFER",
        WIDM_START,         "WIDM_START",
        WIDM_STOP,          "WIDM_STOP",
        WIDM_RESET,         "WIDM_RESET",
        WIDM_GETPOS,        "WIDM_GETPOS",
        WIDM_MAPPER_STATUS, "WIDM_MAPPER_STATUS"
    };
    int      i;
    int      n;
#endif

    static  DWORD               dwNumWaveInDevs;
            DWORD               dwRet = MMSYSERR_NOTSUPPORTED;
            WAVEINCAPSA         wiCaps;
            MMTIME              mmTime32;
            DWORD               dwTmp;
            DWORD UNALIGNED     *lpdwTmp;

#if DBG
    for( i = 0, n = sizeof(name_map) / sizeof(name_map[0]); i < n; i++ ) {
        if ( name_map[i].uMsg == uMessage ) {
            break;
        }
    }
    if ( i != n ) {
        trace_wavein(( "wid32Message( 0x%X, %s, 0x%X, 0x%X, 0x%X)",
                       uDeviceID, name_map[i].lpstrName, dwInstance,
                       dwParam1, dwParam2 ));
    }
    else {
        trace_wavein(( "wid32Message( 0x%X, 0x%X, 0x%X, 0x%X, 0x%X)",
                       uDeviceID, uMessage, dwInstance,
                       dwParam1, dwParam2 ));
    }
#endif

    /*
    ** Make sure that we are consistent with the WAVE_MAPPER
    */
    if ( LOWORD(uDeviceID) == 0xFFFF ) {
        uDeviceID = (UINT)-1;
    }

    switch ( uMessage ) {

    case WIDM_GETNUMDEVS:
        dwRet =  waveInGetNumDevs();
        break;


    case WIDM_GETDEVCAPS:
       // Handle
       // VadimB

        if (0 == dwInstance) {
           dwRet = waveInGetDevCapsA(uDeviceID, &wiCaps, sizeof(wiCaps));
        }
        else {
           dwRet = waveInMessage((HWAVEIN)dwInstance,
                                  uMessage,
                                  (DWORD)&wiCaps,
                                  sizeof(wiCaps));
        }

        if ( dwRet == MMSYSERR_NOERROR ) {
            CopyWaveInCaps( (LPWAVEINCAPS16)GETVDMPTR( dwParam1 ),
                            &wiCaps, dwParam2 );
        }
        break;


    case WIDM_OPEN:
        dwRet =  ThunkCommonWaveOpen( WAVE_IN_DEVICE, uDeviceID, dwParam1,
                                      dwParam2, dwInstance );
        break;


    case WIDM_UNPREPARE:
        dwRet =  ThunkCommonWaveUnprepareHeader( (HWAVE)dwInstance, dwParam1,
                                                 WAVE_IN_DEVICE );
        break;


    case WIDM_PREPARE:
        dwRet =  ThunkCommonWavePrepareHeader( (HWAVE)dwInstance, dwParam1,
                                               WAVE_IN_DEVICE );
        break;


    case WIDM_ADDBUFFER:
        dwRet =  ThunkCommonWaveReadWrite( WAVE_IN_DEVICE, dwParam1,
                                           dwParam2, dwInstance );
        break;


    case WIDM_CLOSE:
        dwRet = waveInClose( (HWAVEIN)dwInstance );
        break;


    case WIDM_START:
    case WIDM_STOP:
    case WIDM_RESET:
        dwRet = waveInMessage( (HWAVEIN)dwInstance, uMessage, 0L, 0L );
        break;


    case WIDM_GETPOS:
        GetMMTime( (LPMMTIME16)GETVDMPTR( dwParam1 ), &mmTime32 );
        dwRet = waveInGetPosition( (HWAVEIN)dwInstance, &mmTime32,
                                   sizeof(mmTime32) );
        if ( dwRet == MMSYSERR_NOERROR ) {
            PutMMTime( (LPMMTIME16)GETVDMPTR( dwParam1 ), &mmTime32 );
        }
        break;


    case WIDM_MAPPER_STATUS:
        {
            WAVEFORMATEX    waveFmtEx;

            switch ( dwParam1 ) {

            case WAVEIN_MAPPER_STATUS_DEVICE:
            case WAVEIN_MAPPER_STATUS_MAPPED:
                dwRet = waveInMessage( (HWAVEIN)dwInstance, uMessage,
                                        dwParam1, (DWORD)&dwTmp );
                lpdwTmp = GETVDMPTR( dwParam2 );
                *lpdwTmp = dwTmp;
                break;

            case WAVEIN_MAPPER_STATUS_FORMAT:
                dwRet = waveInMessage( (HWAVEIN)dwInstance, uMessage,
                                       dwParam1, (DWORD)&waveFmtEx );

                CopyMemory( (LPVOID)GETVDMPTR( dwParam2 ),
                            (LPVOID)&waveFmtEx, sizeof(WAVEFORMATEX) );
                break;

            default:
                dwRet = MMSYSERR_NOTSUPPORTED;
            }
        }
        break;


    default:
        if ( uMessage >= DRV_BUFFER_LOW && uMessage <= DRV_BUFFER_HIGH ) {
            lpdwTmp = GETVDMPTR( dwParam1 );
        }
        else {
            lpdwTmp = (LPDWORD)dwParam1;
        }
        dwRet = waveInMessage( (HWAVEIN)dwInstance, uMessage,
                               (DWORD)lpdwTmp, dwParam2 );

    }

    trace_wavein(( "-> 0x%X", dwRet ));
    return dwRet;
}


/*****************************Private*Routine******************************\
* ThunkCommonWaveOpen
*
* Thunks all wave device opens
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
ThunkCommonWaveOpen(
    int iWhich,
    UINT uDeviceID,
    DWORD dwParam1,
    DWORD dwParam2,
    DWORD dwInstance
    )
{

    /*
    ** dwParam1 is a 16:16 pointer to a WAVEOPENDESC16 structure.
    ** dwParam2 specifies any option flags used when opening the device.
    */

    LPWAVEOPENDESC16        lpOpenDesc16;
    WAVEFORMATEX UNALIGNED  *lpFormat16;
    DWORD                   dwRet;
    WAVEFORMAT              wf[4];
    WAVEFORMATEX            *lpFormat32;

    lpOpenDesc16 = GETVDMPTR( dwParam1 );
    lpFormat16 = GETVDMPTR( lpOpenDesc16->lpFormat );

    /*
    ** Thunk the wave format structure.  If the wave format tag is PCM
    ** we just copy the structure as is.  If the wave format size
    ** is less than or equal to sizeof(wf) again just copy the
    ** structure as is, otherwise we allocate a new structure and then
    ** copy 16 bit wave format into it.
    */
    switch ( lpFormat16->wFormatTag ) {

    case WAVE_FORMAT_PCM:
        CopyMemory( (LPVOID)&wf[0], (LPVOID)lpFormat16, sizeof(PCMWAVEFORMAT) );
        lpFormat32 = (WAVEFORMATEX *)&wf[0];
        break;

    default:
        if ( sizeof(WAVEFORMATEX) + lpFormat16->cbSize > sizeof(wf) ) {

            lpFormat32 = winmmAlloc( sizeof(WAVEFORMATEX) + lpFormat16->cbSize );

            if (lpFormat32 == NULL) {
                return MMSYSERR_NOMEM;
            }
        }
        else {

            lpFormat32 = (WAVEFORMATEX *)&wf[0];
        }

        CopyMemory( (LPVOID)lpFormat32, (LPVOID)lpFormat16,
                    sizeof(WAVEFORMATEX) + lpFormat16->cbSize );
        break;

    }


    /*
    ** If the app is only querying the device we don't have to do very
    ** much, just pass the mapped format to waveOutOpen.
    */
    if ( dwParam2 & WAVE_FORMAT_QUERY ) {

        if ( iWhich == WAVE_OUT_DEVICE ) {
            dwRet = waveOutOpen( NULL, uDeviceID, lpFormat32,
                                 lpOpenDesc16->dwCallback,
                                 lpOpenDesc16->dwInstance, dwParam2 );
        }
        else {
            dwRet = waveInOpen( NULL, uDeviceID, lpFormat32,
                                lpOpenDesc16->dwCallback,
                                lpOpenDesc16->dwInstance, dwParam2 );
        }
    }
    else {

        HWAVE           Hand32;
        PINSTANCEDATA   pInstanceData;

        /*
        ** Create InstanceData block to be used by our callback routine.
        **
        ** NOTE: Although we malloc it here we don't free it.
        ** This is not a mistake - it must not be freed before the
        ** callback routine has used it - so it does the freeing.
        **
        ** If the malloc fails we bomb down to the bottom,
        ** set dwRet to MMSYSERR_NOMEM and exit gracefully.
        **
        ** We always have a callback functions.  This is to ensure that
        ** the WAVEHDR structure keeps getting copied back from
        ** 32 bit space to 16 bit, as it contains flags which
        ** applications are liable to keep checking.
        */
        pInstanceData = winmmAlloc(sizeof(INSTANCEDATA) );
        if ( pInstanceData != NULL ) {

            DWORD dwNewFlags = CALLBACK_FUNCTION;

            dprintf2(( "WaveCommonOpen: Allocated instance buffer at 0x%8X",
                       pInstanceData ));
            dprintf2(( "16 bit callback = 0x%X", lpOpenDesc16->dwCallback ));

            pInstanceData->Hand16 = lpOpenDesc16->hWave;
            pInstanceData->dwCallback = lpOpenDesc16->dwCallback;
            pInstanceData->dwCallbackInstance = lpOpenDesc16->dwInstance;
            pInstanceData->dwFlags = dwParam2;

            dwNewFlags |= (dwParam2 & WAVE_ALLOWSYNC);

            if ( iWhich == WAVE_OUT_DEVICE ) {
                dwRet = waveOutOpen( (LPHWAVEOUT)&Hand32, uDeviceID, lpFormat32,
                                     (DWORD)W32CommonDeviceCB,
                                     (DWORD)pInstanceData, dwNewFlags );
            }
            else {
                dwRet = waveInOpen( (LPHWAVEIN)&Hand32, uDeviceID, lpFormat32,
                                    (DWORD)W32CommonDeviceCB,
                                    (DWORD)pInstanceData, dwNewFlags );
            }
            /*
            ** If the call returns success save a copy of the 32 bit handle
            ** otherwise free the memory we malloc'd earlier, as the
            ** callback that would have freed it will never get callled.
            */
            if ( dwRet == MMSYSERR_NOERROR ) {

                DWORD UNALIGNED *lpDw;

                lpDw = GETVDMPTR( dwInstance );
                *lpDw = (DWORD)Hand32;
                SetWOWHandle( Hand32, lpOpenDesc16->hWave );

                trace_waveout(( "Handle -> %x", Hand32 ));
            }
            else {

                dprintf2(( "WaveCommonOpen: Freeing instance buffer at %8X "
                           "because open failed", pInstanceData ));
                winmmFree( pInstanceData );
            }
        }
        else {

            dwRet = MMSYSERR_NOMEM;
        }
    }

    /*
    ** Free the wave format structure if one was allocated.
    */
    if (lpFormat32 != (WAVEFORMATEX *)&wf[0] ) {
        winmmFree( lpFormat32 );
    }

    return dwRet;
}

/*****************************Private*Routine******************************\
* ThunkCommonWaveReadWrite
*
* Thunks all wave reads and writes.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
ThunkCommonWaveReadWrite(
    int iWhich,
    DWORD dwParam1,
    DWORD dwParam2,
    DWORD dwInstance
    )
{
    UINT                ul;
    PWAVEHDR32          p32WaveHdr;
    WAVEHDR16 UNALIGNED   *lp16;


    /*
    ** Get a pointer to the shadow WAVEHDR buffer.
    */
    lp16 = GETVDMPTR( dwParam1 );
    p32WaveHdr = (PWAVEHDR32)lp16->reserved;

    /*
    ** Make sure that the wave headers are consistent.
    */
    p32WaveHdr->Wavehdr.lpData = GETVDMPTR( (PWAVEHDR32)lp16->lpData );
    p32WaveHdr->pWavehdr32 = lp16;

    CopyMemory( (LPVOID)&p32WaveHdr->Wavehdr.dwBufferLength,
                (LPVOID)&lp16->dwBufferLength,
                (sizeof(WAVEHDR) - sizeof(LPSTR) - sizeof(DWORD)) );

    /*
    ** Call either waveInAddBuffer or waveOutWrite as determined by
    ** iWhich.
    */
    if ( iWhich == WAVE_OUT_DEVICE ) {

        ul = waveOutWrite( (HWAVEOUT)dwInstance,
                           &p32WaveHdr->Wavehdr, sizeof(WAVEHDR) );
    }
    else {

        ul = waveInAddBuffer( (HWAVEIN)dwInstance,
                              &p32WaveHdr->Wavehdr, sizeof(WAVEHDR) );
    }

    /*
    ** If the call worked reflect any change in the wave header back into
    ** the header that the application gave use.
    */
    if ( ul == MMSYSERR_NOERROR ) {
        PutWaveHdr16( lp16, &p32WaveHdr->Wavehdr );
    }

    return ul;
}

/*****************************Private*Routine******************************\
* ThunkCommonWavePrepareHeader
*
* This function sets up the following structure...
*
*
*       +-------------+       +-------------+
*  0:32 | pWavehdr32  |------>| Original    |
*       +-------------+       | header      |
* 16:16 | pWavehdr16  |------>| passed by   |
*       +-------------+<--+   | the 16 bit  |
*       | New 32 bit  |   |   |             |
*       | header thats|   |   |             |
*       | used instead|   |   |             |
*       | of the one  |   |   +-------------+
*       | passed to by|   +---| reserved    |
*       | application.|       +-------------+
*       |             |
*       +-------------+
*
*  ... and then calls waveXxxPrepareHeader as determioned by iWhich.
*
* Used by:
*          waveOutPrepareHdr
*          waveInPrepareHdr
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
DWORD
ThunkCommonWavePrepareHeader(
    HWAVE hWave,
    DWORD dwParam1,
    int iWhich
    )
{

    PWAVEHDR32          p32WaveHdr;
    DWORD               ul;
    WAVEHDR16 UNALIGNED   *lp16;


    lp16 = GETVDMPTR( dwParam1 );

    /*
    ** Allocate some storage for the new wave header structure.
    ** On debug builds we keep track of the number of wave headers allocated
    ** and freed.
    */
    p32WaveHdr = (PWAVEHDR32)winmmAlloc( sizeof(WAVEHDR32) );
    if ( p32WaveHdr != NULL ) {

#if DBG
        AllocWaveCount++;
        dprintf2(( "WH>> 0x%X (%d)", p32WaveHdr, AllocWaveCount ));
#endif

        /*
        ** Copy the header given to us by the application into the newly
        ** allocated header.  Note that GetWaveHdr returns a 0:32 pointer
        ** to the applications 16 bit header, which we save for later use.
        */
        p32WaveHdr->pWavehdr16 = (PWAVEHDR16)dwParam1;
        p32WaveHdr->pWavehdr32 = GetWaveHdr16( dwParam1,
                                               &p32WaveHdr->Wavehdr );

        /*
        ** Prepare the real header
        */
        if ( iWhich == WAVE_OUT_DEVICE ) {
            ul = waveOutPrepareHeader( (HWAVEOUT)hWave,
                                       &p32WaveHdr->Wavehdr,
                                       sizeof(WAVEHDR) );
        }
        else {
            ul = waveInPrepareHeader( (HWAVEIN)hWave,
                                      &p32WaveHdr->Wavehdr,
                                      sizeof(WAVEHDR) );
        }

        if ( ul == MMSYSERR_NOERROR ) {

            /*
            ** Copy back the prepared header so that any changed fields are
            ** updated.
            */
            PutWaveHdr16( lp16, &p32WaveHdr->Wavehdr );

            /*
            ** Save a back pointer to the newly allocated header in the
            ** reserved field.
            */
            lp16->reserved = (DWORD)p32WaveHdr;
        }
        else {

            /*
            ** Some error happened, anyway the wave header is now trash so
            ** free the allocated storage etc.
            */
            winmmFree( p32WaveHdr );
#if DBG
            AllocWaveCount--;
            dprintf2(( "WH<< 0x%X (%d)", p32WaveHdr, AllocWaveCount ));
#endif
        }
    }
    else {
        dprintf2(( "Could not allocate shadow wave header!!" ));
        ul = MMSYSERR_NOMEM;
    }
    return ul;
}


/*****************************Private*Routine******************************\
* ThunkCommonWaveUnprepareHeader
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
DWORD
ThunkCommonWaveUnprepareHeader(
    HWAVE hWave,
    DWORD dwParam1,
    int iWhich
    )
{
    DWORD               ul;
    PWAVEHDR32          p32WaveHdr;
    WAVEHDR16 UNALIGNED   *lp16;
    BOOL                fDoneBitSet;

    lp16 = (WAVEHDR16 UNALIGNED *)GETVDMPTR( dwParam1 );
    p32WaveHdr = (PWAVEHDR32)lp16->reserved;

    /*
    ** The DK Stowaway app clears the done bit before calling
    ** waveOutUnprepareHeader and depends on the done bit being cleared when
    ** this api returns.
    **
    ** So when we copy the 32 bit flags back we make sure that the done
    ** is left in the same state that we found it
    */
    fDoneBitSet = (lp16->dwFlags & WHDR_DONE);

    /*
    ** Now call waveXxxUnprepare header with the shadow buffer as determined
    ** by iWhich.
    */
    if ( iWhich == WAVE_OUT_DEVICE ) {
        ul = waveOutUnprepareHeader( (HWAVEOUT)hWave,
                                     &p32WaveHdr->Wavehdr, sizeof(WAVEHDR) );
    }
    else {
        ul = waveInUnprepareHeader( (HWAVEIN)hWave,
                                    &p32WaveHdr->Wavehdr, sizeof(WAVEHDR) );
    }


    /*
    ** Reflect any changes made by waveOutUnprepareHeader back into the
    ** the buffer that the application gave us.
    */
    if ( ul == MMSYSERR_NOERROR ) {

        PutWaveHdr16( lp16, &p32WaveHdr->Wavehdr );

        /*
        ** Make sure that we leave the done bit in the same state that we
        ** found it.
        */
        if (fDoneBitSet) {
            lp16->dwFlags |= WHDR_DONE;
        }
        else {
            lp16->dwFlags &= ~WHDR_DONE;
        }

        /*
        ** If everything worked OK we should free the shadow wave header
        ** here.
        */
#if DBG
        AllocWaveCount--;
        dprintf2(( "WH<< 0x%X (%d)", p32WaveHdr, AllocWaveCount ));
#endif
        winmmFree( p32WaveHdr );
    }

    return ul;

}


/*****************************Private*Routine******************************\
* CopyWaveOutCaps
*
* Copies 32 bit wave out caps info into the passed 16bit storage.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
void
CopyWaveOutCaps(
    LPWAVEOUTCAPS16 lpCaps16,
    LPWAVEOUTCAPSA lpCaps32,
    DWORD dwSize
    )
{
    WAVEOUTCAPS16 Caps16;

    Caps16.wMid = lpCaps32->wMid;
    Caps16.wPid = lpCaps32->wPid;

    Caps16.vDriverVersion = LOWORD( lpCaps32->vDriverVersion );
    CopyMemory( Caps16.szPname, lpCaps32->szPname, MAXPNAMELEN );
    Caps16.dwFormats = lpCaps32->dwFormats;
    Caps16.wChannels = lpCaps32->wChannels;
    Caps16.dwSupport = lpCaps32->dwSupport;

    CopyMemory( (LPVOID)lpCaps16, (LPVOID)&Caps16, (UINT)dwSize );
}



/*****************************Private*Routine******************************\
* CopyWaveInCaps
*
* Copies 32 bit wave in caps info into the passed 16bit storage.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
void
CopyWaveInCaps(
    LPWAVEINCAPS16 lpCaps16,
    LPWAVEINCAPSA lpCaps32,
    DWORD dwSize
    )
{
    WAVEINCAPS16 Caps16;

    Caps16.wMid = lpCaps32->wMid;
    Caps16.wPid = lpCaps32->wPid;

    Caps16.vDriverVersion = LOWORD( lpCaps32->vDriverVersion );
    CopyMemory( Caps16.szPname, lpCaps32->szPname, MAXPNAMELEN );
    Caps16.dwFormats = lpCaps32->dwFormats;
    Caps16.wChannels = lpCaps32->wChannels;

    CopyMemory( (LPVOID)lpCaps16, (LPVOID)&Caps16, (UINT)dwSize );
}


/******************************Public*Routine******************************\
* GetWaveHdr16
*
* Thunks a WAVEHDR structure from 16 bit to 32 bit space.
*
* Used by:
*          waveOutWrite
*          waveInAddBuffer
*
* Returns a 32 bit pointer to the 16 bit wave header.  This wave header
* should have been locked down by wave(In|Out)PrepareHeader.  Therefore,
* it is to store this pointer for use during the WOM_DONE callback message.
*
* With the WAVEHDR and MIDIHDR structs I am assured by Robin that the ->lpNext
* field is only used by the driver, and is therefore in 32 bit space. It
* therefore doesn't matter what gets passed back and forth (I hope !).
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
PWAVEHDR16
GetWaveHdr16(
    DWORD vpwhdr,
    LPWAVEHDR lpwhdr
    )
{
    register PWAVEHDR16 pwhdr16;

    pwhdr16 = GETVDMPTR(vpwhdr);
    if ( pwhdr16 == NULL ) {
        dprintf1(( "getwavehdr16 GETVDMPTR returned an invalid pointer" ));
        return NULL;
    }

    CopyMemory( (LPVOID)lpwhdr, (LPVOID)pwhdr16, sizeof(*lpwhdr) );
    lpwhdr->lpData = GETVDMPTR( pwhdr16->lpData );

    return pwhdr16;
}

/******************************Public*Routine******************************\
* PutWaveHdr16
*
* Thunks a WAVEHDR structure from 32 bit back to 16 bit space.
*
* Used by:
*          waveOutPrepareHeader
*          waveOutUnprepareHeader
*          waveOutWrite
*          waveInPrepareHeader
*          waveInUnprepareHeader
*          waveInAddBuffer
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
void
PutWaveHdr16(
    WAVEHDR16 UNALIGNED *pwhdr16,
    LPWAVEHDR lpwhdr
    )
{
    LPSTR   lpDataSave     = pwhdr16->lpData;
    DWORD   dwReservedSave = pwhdr16->reserved;

    CopyMemory( (LPVOID)pwhdr16, (LPVOID)lpwhdr, sizeof(WAVEHDR) );

    pwhdr16->lpData   = lpDataSave;
    pwhdr16->reserved = dwReservedSave;

}


/******************************Public*Routine******************************\
* mod32Message
*
* Thunks all midi out apis.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD WINAPI
mod32Message(
    UINT uDeviceID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    )
{
#if DBG
    static MSG_NAME name_map[] = {
        MODM_GETNUMDEVS,        "MODM_GETNUMDEVS",
        MODM_GETDEVCAPS,        "MODM_GETDEVCAPS",
        MODM_OPEN,              "MODM_OPEN",
        MODM_CLOSE,             "MODM_CLOSE",
        MODM_PREPARE,           "MODM_PREPARE",
        MODM_UNPREPARE,         "MODM_UNPREPARE",
        MODM_DATA,              "MODM_DATA",
        MODM_RESET,             "MODM_RESET",
        MODM_LONGDATA,          "MODM_LONGDATA",
        MODM_GETVOLUME,         "MODM_GETVOLUME",
        MODM_SETVOLUME,         "MODM_SETVOLUME" ,
        MODM_CACHEDRUMPATCHES,  "MODM_CACHEDRUMPATCHES",
        MODM_CACHEPATCHES,      "MODM_CACHEPATCHES"
    };
    int      i;
    int      n;
#endif

    static  DWORD               dwNumMidiOutDevs;
            DWORD               dwRet = MMSYSERR_NOTSUPPORTED;
            DWORD               dwTmp = 0;
            DWORD UNALIGNED     *lpdwTmp;
            MIDIOUTCAPSA        moCaps;

#if DBG
    for( i = 0, n = sizeof(name_map) / sizeof(name_map[0]); i < n; i++ ) {
        if ( name_map[i].uMsg == uMessage ) {
            break;
        }
    }
    if ( i != n ) {
        trace_midiout(( "mod32Message( 0x%X, %s, 0x%X, 0x%X, 0x%X)",
                        uDeviceID, name_map[i].lpstrName, dwInstance,
                        dwParam1, dwParam2 ));
    }
    else {
        trace_midiout(( "mod32Message( 0x%X, 0x%X, 0x%X, 0x%X, 0x%X)",
                        uDeviceID, uMessage, dwInstance,
                        dwParam1, dwParam2 ));
    }
#endif

    if ( LOWORD(uDeviceID) == 0xFFFF ) {
        uDeviceID = (UINT)-1;
    }

    switch ( uMessage ) {

    case MODM_GETNUMDEVS:
        dwRet = midiOutGetNumDevs();
        break;

    case MODM_GETDEVCAPS:
       //
       // this api also might take a valid handle in uDeviceID
       // per Win95 behavior
       // VadimB
        if (0 == dwInstance) {
           dwRet = midiOutGetDevCapsA( uDeviceID, &moCaps, sizeof(moCaps));
        }
        else {
           dwRet = midiOutMessage((HMIDIOUT)dwInstance,
                                  uMessage,
                                  (DWORD)&moCaps,
                                  sizeof(moCaps));
        }

        if ( dwRet == MMSYSERR_NOERROR ) {
            CopyMidiOutCaps( (LPMIDIOUTCAPS16)GETVDMPTR( dwParam1 ),
                              &moCaps, dwParam2 );
        }
        break;

    case MODM_OPEN:
        dwRet =  ThunkCommonMidiOpen( MIDI_OUT_DEVICE, uDeviceID, dwParam1,
                                      dwParam2, dwInstance );
        break;

    case MODM_LONGDATA:
        dwRet =  ThunkCommonMidiReadWrite( MIDI_OUT_DEVICE, dwParam1,
                                           dwParam2, dwInstance );
        break;

    case MODM_PREPARE:
        dwRet =  ThunkCommonMidiPrepareHeader( (HMIDI)dwInstance, dwParam1,
                                               MIDI_OUT_DEVICE );
        break;

    case MODM_UNPREPARE:
        dwRet =  ThunkCommonMidiUnprepareHeader( (HMIDI)dwInstance, dwParam1,
                                                 MIDI_OUT_DEVICE );
        break;

    case MODM_DATA:
        dwRet = midiOutShortMsg( (HMIDIOUT)dwInstance, dwParam1 );
        break;

    case MODM_CLOSE:
        dwRet = midiOutClose( (HMIDIOUT)dwInstance );
        break;

    case MODM_RESET:
        dwRet = midiOutMessage( (HMIDIOUT)dwInstance, uMessage,
                                dwParam1, dwParam2 );
        break;

    case MODM_SETVOLUME:
        /*
        ** An application might try to set the volume using either
        ** the device ID (midiOutSetVolume) or a handle to the device
        ** midiOutMessage( MODM_SETVOLUME...), if the later is the case
        ** we must also call midiOutMessage as the device ID will not
        ** necessarily be valid.  Same applies for midiOutGetVolume below.
        */
        if ( dwInstance == 0 ) {
            dwRet = midiOutSetVolume( (HMIDIOUT)uDeviceID, dwParam1 );
        }
        else {
            dwRet = midiOutMessage( (HMIDIOUT)dwInstance, uMessage,
                                    dwParam1, dwParam2 );
        }
        break;

    case MODM_GETVOLUME:
        if ( dwInstance == 0 ) {
            dwRet = midiOutGetVolume( (HMIDIOUT)uDeviceID, &dwTmp );
        }
        else {
            dwRet = midiOutMessage( (HMIDIOUT)dwInstance, uMessage,
                                    (DWORD)&dwTmp, dwParam2 );
        }
        lpdwTmp = GETVDMPTR( dwParam1 );
        *lpdwTmp = dwTmp;
        break;

    case MODM_CACHEPATCHES:
    case MODM_CACHEDRUMPATCHES:
        {
            LPWORD    lpCache;

            lpCache = winmmAlloc( MIDIPATCHSIZE * sizeof(WORD) );
            if ( lpCache != NULL ) {

                lpdwTmp = GETVDMPTR( dwParam1 );
                CopyMemory( (LPVOID)lpCache, (LPVOID)lpdwTmp,
                            MIDIPATCHSIZE * sizeof(WORD) );

                dwRet = midiOutMessage( (HMIDIOUT)dwInstance, uMessage,
                                        (DWORD)lpCache, dwParam2 );
                winmmFree( lpCache );
            }
            else {
                dwRet = MMSYSERR_NOMEM;
            }
        }
        break;

    default:
        if ( uMessage >= DRV_BUFFER_LOW && uMessage <= DRV_BUFFER_HIGH ) {
            lpdwTmp = GETVDMPTR( dwParam1 );
        }
        else {
            lpdwTmp = (LPDWORD)dwParam1;
        }
        dwRet = midiOutMessage( (HMIDIOUT)dwInstance, uMessage,
                               (DWORD)lpdwTmp, dwParam2 );
    }

    trace_midiout(( "-> 0x%X", dwRet ));
    return dwRet;
}


/******************************Public*Routine******************************\
* mid32Message
*
* Thunks all midi in apis.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD WINAPI
mid32Message(
    UINT uDeviceID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    )
{
#if DBG
    static MSG_NAME name_map[] = {
        MIDM_GETNUMDEVS,        "MIDM_GETNUMDEVS",
        MIDM_GETDEVCAPS,        "MIDM_GETDEVCAPS",
        MIDM_OPEN,              "MIDM_OPEN",
        MIDM_ADDBUFFER,         "MIDM_ADDBUFFER",
        MIDM_CLOSE,             "MIDM_CLOSE",
        MIDM_PREPARE,           "MIDM_PREPARE",
        MIDM_UNPREPARE,         "MIDM_UNPREPARE",
        MIDM_RESET,             "MIDM_RESET",
        MIDM_START,             "MIDM_START",
        MIDM_STOP,              "MIDM_STOP",
    };
    int      i;
    int      n;
#endif

    static  DWORD               dwNumMidiInDevs;
            DWORD               dwRet = MMSYSERR_NOTSUPPORTED;
            MIDIINCAPSA         miCaps;
            DWORD UNALIGNED     *lpdwTmp;

#if DBG
    for( i = 0, n = sizeof(name_map) / sizeof(name_map[0]); i < n; i++ ) {
        if ( name_map[i].uMsg == uMessage ) {
            break;
        }
    }
    if ( i != n ) {
        trace_midiin(( "mid32Message( 0x%X, %s, 0x%X, 0x%X, 0x%X)",
                        uDeviceID, name_map[i].lpstrName, dwInstance,
                        dwParam1, dwParam2 ));
    }
    else {
        trace_midiin(( "mid32Message( 0x%X, 0x%X, 0x%X, 0x%X, 0x%X)",
                        uDeviceID, uMessage, dwInstance,
                        dwParam1, dwParam2 ));
    }
#endif

    if ( LOWORD(uDeviceID) == 0xFFFF ) {
        uDeviceID = (UINT)-1;
    }

    switch ( uMessage ) {

    case MIDM_GETNUMDEVS:
        dwRet = midiInGetNumDevs();
        break;

    case MIDM_GETDEVCAPS:
       // Handle
       // VadimB
        if (0 == dwInstance) {
           dwRet = midiInGetDevCapsA( uDeviceID, &miCaps, sizeof(miCaps));
        }
        else {
           dwRet = midiInMessage((HMIDIIN)dwInstance,
                                 uMessage,
                                 (DWORD)&miCaps,
                                 sizeof(miCaps));
        }

        if ( dwRet == MMSYSERR_NOERROR ) {
            CopyMidiInCaps( (LPMIDIINCAPS16)GETVDMPTR( dwParam1 ),
                            &miCaps, dwParam2 );
        }
        break;

    case MIDM_OPEN:
        dwRet =  ThunkCommonMidiOpen( MIDI_IN_DEVICE, uDeviceID, dwParam1,
                                      dwParam2, dwInstance );
        break;

    case MIDM_ADDBUFFER:
        dwRet =  ThunkCommonMidiReadWrite( MIDI_IN_DEVICE, dwParam1,
                                           dwParam2, dwInstance );
        break;

    case MIDM_PREPARE:
        dwRet =  ThunkCommonMidiPrepareHeader( (HMIDI)dwInstance, dwParam1,
                                               MIDI_IN_DEVICE );
        break;

    case MIDM_UNPREPARE:
        dwRet =  ThunkCommonMidiUnprepareHeader( (HMIDI)dwInstance, dwParam1,
                                                 MIDI_IN_DEVICE );
        break;

    case MIDM_CLOSE:
        dwRet = midiInClose( (HMIDIIN)dwInstance );
        break;

    case MIDM_START:
    case MIDM_STOP:
    case MIDM_RESET:
        dwRet = midiInMessage( (HMIDIIN)dwInstance, uMessage,
                               dwParam1, dwParam2 );
        break;

    default:
        if ( uMessage >= DRV_BUFFER_LOW && uMessage <= DRV_BUFFER_HIGH ) {
            lpdwTmp = GETVDMPTR( dwParam1 );
        }
        else {
            lpdwTmp = (LPDWORD)dwParam1;
        }
        dwRet = midiInMessage( (HMIDIIN)dwInstance, uMessage,
                               (DWORD)lpdwTmp, dwParam2 );
    }

    trace_midiin(( "-> 0x%X", dwRet ));
    return dwRet;
}

/*****************************Private*Routine******************************\
* ThunkCommonMidiOpen
*
* Thunks all midi open requests.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
ThunkCommonMidiOpen(
    int iWhich,
    UINT uDeviceID,
    DWORD dwParam1,
    DWORD dwParam2,
    DWORD dwInstance
    )
{

    /*
    ** dwParam1 is a 16:16 pointer to a MIDIOPENDESC16 structure.
    ** dwParam2 specifies any option flags used when opening the device.
    */

    LPMIDIOPENDESC16    lpOpenDesc16;
    DWORD               dwRet;
    HMIDI               Hand32;
    PINSTANCEDATA       pInstanceData;


    lpOpenDesc16 = GETVDMPTR( dwParam1 );

    /*
    ** Create InstanceData block to be used by our callback routine.
    **
    ** NOTE: Although we malloc it here we don't free it.
    ** This is not a mistake - it must not be freed before the
    ** callback routine has used it - so it does the freeing.
    **
    ** If the malloc fails we bomb down to the bottom,
    ** set dwRet to MMSYSERR_NOMEM and exit gracefully.
    **
    ** We always have a callback functions.  This is to ensure that
    ** the MIDIHDR structure keeps getting copied back from
    ** 32 bit space to 16 bit, as it contains flags which
    ** applications are liable to keep checking.
    */
    pInstanceData = winmmAlloc(sizeof(INSTANCEDATA) );
    if ( pInstanceData != NULL ) {

        DWORD dwNewFlags = CALLBACK_FUNCTION;

        dprintf2(( "MidiCommonOpen: Allocated instance buffer at 0x%8X",
                   pInstanceData ));
        dprintf2(( "16 bit callback = 0x%X", lpOpenDesc16->dwCallback ));

        pInstanceData->Hand16 = lpOpenDesc16->hMidi;
        pInstanceData->dwCallback = lpOpenDesc16->dwCallback;
        pInstanceData->dwCallbackInstance = lpOpenDesc16->dwInstance;
        pInstanceData->dwFlags = dwParam2;


        if ( iWhich == MIDI_OUT_DEVICE ) {
            dwRet = midiOutOpen( (LPHMIDIOUT)&Hand32, uDeviceID,
                                 (DWORD)W32CommonDeviceCB,
                                 (DWORD)pInstanceData, dwNewFlags );
        }
        else {
            dwRet = midiInOpen( (LPHMIDIIN)&Hand32, uDeviceID,
                                (DWORD)W32CommonDeviceCB,
                                (DWORD)pInstanceData, dwNewFlags );
        }
        /*
        ** If the call returns success save a copy of the 32 bit handle
        ** otherwise free the memory we malloc'd earlier, as the
        ** callback that would have freed it will never get callled.
        */
        if ( dwRet == MMSYSERR_NOERROR ) {

            DWORD UNALIGNED *lpDw;

            lpDw = GETVDMPTR( dwInstance );
            *lpDw = (DWORD)Hand32;
            SetWOWHandle( Hand32, lpOpenDesc16->hMidi );

#if DBG
            if ( iWhich == MIDI_OUT_DEVICE ) {
                trace_midiout(( "Handle -> %x", Hand32 ));
            }
            else {
                trace_midiout(( "Handle -> %x", Hand32 ));
            }
#endif

        }
        else {

            dprintf2(( "MidiCommonOpen: Freeing instance buffer at %8X "
                       "because open failed", pInstanceData ));
            winmmFree( pInstanceData );
        }
    }
    else {

        dwRet = MMSYSERR_NOMEM;
    }

    return dwRet;
}


/*****************************Private*Routine******************************\
* ThunkCommonMidiReadWrite
*
* Thunks all midi read/write requests.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
ThunkCommonMidiReadWrite(
    int iWhich,
    DWORD dwParam1,
    DWORD dwParam2,
    DWORD dwInstance
    )
{
    UINT                ul;
    PMIDIHDR32          p32MidiHdr;
    MIDIHDR UNALIGNED   *lp16;


    /*
    ** Get a pointer to the shadow MIDIHDR buffer.
    */
    lp16 = GETVDMPTR( dwParam1 );
    p32MidiHdr = (PMIDIHDR32)lp16->reserved;

    /*
    ** Make sure that the midi headers are consistent.
    */
    CopyMemory( (LPVOID)&p32MidiHdr->Midihdr.dwBufferLength,
                (LPVOID)&lp16->dwBufferLength,
                (sizeof(MIDIHDR) - sizeof(LPSTR) - sizeof(DWORD)) );
    p32MidiHdr->Midihdr.reserved = p32MidiHdr->reserved;

    /*
    ** Call either midiInAddBuffer or midiOutWrite as determined by
    ** iWhich.
    */
    if ( iWhich == MIDI_OUT_DEVICE ) {

        ul = midiOutLongMsg( (HMIDIOUT)dwInstance,
                             &p32MidiHdr->Midihdr, sizeof(MIDIHDR) );
    }
    else {

        ul = midiInAddBuffer( (HMIDIIN)dwInstance,
                              &p32MidiHdr->Midihdr, sizeof(MIDIHDR) );
    }

    /*
    ** If the call worked reflect any change in the midi header back into
    ** the header that the application gave use.
    */
    if ( ul == MMSYSERR_NOERROR ) {
        PutMidiHdr16( lp16, &p32MidiHdr->Midihdr );
    }

    return ul;
}

/*****************************Private*Routine******************************\
* ThunkCommonMidiPrepareHeader
*
* This function sets up the following structure...
*
*
*       +-------------+       +-------------+
*  0:32 | pMidihdr32  |------>| Original    |
*       +-------------+       | header      |
* 16:16 | pMidihdr16  |------>| passed by   |
*       +-------------+<--+   | the 16 bit  |
*       | New 32 bit  |   |   |             |
*       | header thats|   |   |             |
*       | used instead|   |   |             |
*       | of the one  |   |   +-------------+
*       | passed to by|   +---| reserved    |
*       | application.|       +-------------+
*       |             |
*       +-------------+
*
*  ... and then calls midiXxxPrepareHeader as determioned by iWhich.
*
* Used by:
*          midiOutPrepareHdr
*          midiInPrepareHdr
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
DWORD
ThunkCommonMidiPrepareHeader(
    HMIDI hMidi,
    DWORD dwParam1,
    int iWhich
    )
{

    PMIDIHDR32          p32MidiHdr;
    DWORD               ul;
    MIDIHDR UNALIGNED   *lp16;


    lp16 = GETVDMPTR( dwParam1 );

    /*
    ** Allocate some storage for the new midi header structure.
    ** On debug builds we keep track of the number of midi headers allocated
    ** and freed.
    */
    p32MidiHdr = (PMIDIHDR32)winmmAlloc( sizeof(MIDIHDR32) );
    if ( p32MidiHdr != NULL ) {

#if DBG
        AllocMidiCount++;
        dprintf2(( "MH>> 0x%X (%d)", p32MidiHdr, AllocMidiCount ));
#endif

        /*
        ** Copy the header given to us by the application into the newly
        ** allocated header.  Note that GetMidiHdr returns a 0:32 pointer
        ** to the applications 16 bit header, which we save for later use.
        */
        p32MidiHdr->pMidihdr16 = (PMIDIHDR16)dwParam1;
        p32MidiHdr->pMidihdr32 = GetMidiHdr16( dwParam1,
                                               &p32MidiHdr->Midihdr );

        /*
        ** Prepare the real header
        */
        if ( iWhich == MIDI_OUT_DEVICE ) {
            ul = midiOutPrepareHeader( (HMIDIOUT)hMidi,
                                       &p32MidiHdr->Midihdr,
                                       sizeof(MIDIHDR) );
        }
        else {
            ul = midiInPrepareHeader( (HMIDIIN)hMidi,
                                      &p32MidiHdr->Midihdr,
                                      sizeof(MIDIHDR) );
        }

        if ( ul == MMSYSERR_NOERROR ) {

            /*
            ** Save a copy of the reserved field, MidiMap uses it.
            */
            p32MidiHdr->reserved = p32MidiHdr->Midihdr.reserved;

            /*
            ** Copy back the prepared header so that any changed fields are
            ** updated.
            */
            PutMidiHdr16( lp16, &p32MidiHdr->Midihdr );

            /*
            ** Save a back pointer to the newly allocated header in the
            ** reserved field.
            */
            lp16->reserved = (DWORD)p32MidiHdr;
        }
        else {

            /*
            ** Some error happened, anyway the midi header is now trash so
            ** free the allocated storage etc.
            */
            winmmFree( p32MidiHdr );
#if DBG
            AllocMidiCount--;
            dprintf2(( "MH<< 0x%X (%d)", p32MidiHdr, AllocMidiCount ));
#endif
        }
    }
    else {
        dprintf2(( "Could not allocate shadow midi header!!" ));
        ul = MMSYSERR_NOMEM;
    }
    return ul;
}


/*****************************Private*Routine******************************\
* ThunkCommonMidiUnprepareHeader
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
DWORD
ThunkCommonMidiUnprepareHeader(
    HMIDI hMidi,
    DWORD dwParam1,
    int iWhich
    )
{
    DWORD               ul;
    PMIDIHDR32          p32MidiHdr;
    MIDIHDR UNALIGNED   *lp16;

    lp16 = (MIDIHDR UNALIGNED *)GETVDMPTR( dwParam1 );
    p32MidiHdr = (PMIDIHDR32)lp16->reserved;
    p32MidiHdr->Midihdr.reserved = p32MidiHdr->reserved;

    /*
    ** Now call midiXxxUnprepare header with the shadow buffer as determined
    ** by iWhich.
    */
    if ( iWhich == MIDI_OUT_DEVICE ) {
        ul = midiOutUnprepareHeader( (HMIDIOUT)hMidi,
                                     &p32MidiHdr->Midihdr, sizeof(MIDIHDR) );
    }
    else {
        ul = midiInUnprepareHeader( (HMIDIIN)hMidi,
                                    &p32MidiHdr->Midihdr, sizeof(MIDIHDR) );
    }


    /*
    ** Reflect any changes made by midiOutUnprepareHeader back into the
    ** the buffer that the application gave us.
    */
    if ( ul == MMSYSERR_NOERROR ) {

        PutMidiHdr16( lp16, &p32MidiHdr->Midihdr );

        /*
        ** If everything worked OK we should free the shadow midi header
        ** here.
        */
#if DBG
        AllocMidiCount--;
        dprintf2(( "MH<< 0x%X (%d)", p32MidiHdr, AllocMidiCount ));
#endif
        winmmFree( p32MidiHdr );
    }

    return ul;

}


/*****************************Private*Routine******************************\
* CopyMidiOutCaps
*
* Copies 32 bit midi out caps info into the passed 16bit storage.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
void
CopyMidiOutCaps(
    LPMIDIOUTCAPS16 lpCaps16,
    LPMIDIOUTCAPSA lpCaps32,
    DWORD dwSize
    )
{
    MIDIOUTCAPS16  Caps16;

    Caps16.wMid = lpCaps32->wMid;
    Caps16.wPid = lpCaps32->wPid;

    CopyMemory( Caps16.szPname, lpCaps32->szPname, MAXPNAMELEN );

    Caps16.vDriverVersion    = LOWORD( lpCaps32->vDriverVersion );
    Caps16.wTechnology       = lpCaps32->wTechnology;
    Caps16.wVoices           = lpCaps32->wVoices;
    Caps16.wNotes            = lpCaps32->wNotes;
    Caps16.wChannelMask      = lpCaps32->wChannelMask;
    Caps16.dwSupport         = lpCaps32->dwSupport;

    CopyMemory( (LPVOID)lpCaps16, (LPVOID)&Caps16, (UINT)dwSize );
}



/*****************************Private*Routine******************************\
* CopyMidiInCaps
*
* Copies 32 bit midi in caps info into the passed 16bit storage.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
void
CopyMidiInCaps(
    LPMIDIINCAPS16 lpCaps16,
    LPMIDIINCAPSA lpCaps32,
    DWORD dwSize
    )
{
    MIDIINCAPS16 Caps16;

    Caps16.wMid = lpCaps32->wMid;
    Caps16.wPid = lpCaps32->wPid;
    Caps16.vDriverVersion = LOWORD( lpCaps32->vDriverVersion );
    CopyMemory( Caps16.szPname, lpCaps32->szPname, MAXPNAMELEN );

    CopyMemory( (LPVOID)lpCaps16, (LPVOID)&Caps16, (UINT)dwSize );
}


/******************************Public*Routine******************************\
* GetMidiHdr16
*
* Thunks a MIDIHDR structure from 16 bit to 32 bit space.
*
* Used by:
*          midiOutLongMsg
*          midiInAddBuffer
*
* Returns a 32 bit pointer to the 16 bit midi header.  This midi header
* should have been locked down by midi(In|Out)PrepareHeader.  Therefore,
* it is to store this pointer for use during the WOM_DONE callback message.
*
* With the MIDIHDR and MIDIHDR structs I am assured by Robin that the ->lpNext
* field is only used by the driver, and is therefore in 32 bit space. It
* therefore doesn't matter what gets passed back and forth (I hope !).
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
PMIDIHDR16
GetMidiHdr16(
    DWORD vpmhdr,
    LPMIDIHDR lpmhdr
    )
{
    register PMIDIHDR16 pmhdr16;

    pmhdr16 = GETVDMPTR(vpmhdr);
    if ( pmhdr16 == NULL ) {
        dprintf1(( "getmidihdr16 GETVDMPTR returned an invalid pointer" ));
        return NULL;
    }

    CopyMemory( (LPVOID)lpmhdr, (LPVOID)pmhdr16, sizeof(*lpmhdr) );
    lpmhdr->lpData = GETVDMPTR( pmhdr16->lpData );

    return pmhdr16;
}


/******************************Public*Routine******************************\
* PutMidiHdr16
*
* Thunks a MIDIHDR structure from 32 bit back to 16 bit space.
*
* Used by:
*          midiOutPrepareHeader
*          midiOutUnprepareHeader
*          midiOutLongMsg
*          midiInPrepareHeader
*          midiInUnprepareHeader
*          midiInAddBuffer
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
void
PutMidiHdr16(
    MIDIHDR UNALIGNED *pmhdr16,
    LPMIDIHDR lpmhdr
    )
{
    LPSTR   lpDataSave     = pmhdr16->lpData;
    DWORD   dwReservedSave = pmhdr16->reserved;

    CopyMemory( (LPVOID)pmhdr16, (LPVOID)lpmhdr, sizeof(MIDIHDR) );

    pmhdr16->lpData   = lpDataSave;
    pmhdr16->reserved = dwReservedSave;
}


/*****************************Private*Routine******************************\
* PutMMTime
*
* Puts an MMTIME structure from 32 bit storage into 16 bit storage
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
void
PutMMTime(
    LPMMTIME16 lpTime16,
    LPMMTIME lpTime32
    )
{
    lpTime16->wType = LOWORD(lpTime32->wType);

    switch ( lpTime32->wType ) {
    case TIME_MS:
        lpTime16->u.ms = lpTime32->u.ms;
        break;

    case TIME_SAMPLES:
        lpTime16->u.sample = lpTime32->u.sample;
        break;

    case TIME_BYTES:
        lpTime16->u.cb = lpTime32->u.cb;
        break;

    case TIME_SMPTE:
        lpTime16->u.smpte.hour  = lpTime32->u.smpte.hour;
        lpTime16->u.smpte.min   = lpTime32->u.smpte.min;
        lpTime16->u.smpte.sec   = lpTime32->u.smpte.sec;
        lpTime16->u.smpte.frame = lpTime32->u.smpte.frame;
        lpTime16->u.smpte.fps   = lpTime32->u.smpte.fps;
        lpTime16->u.smpte.dummy = lpTime32->u.smpte.dummy;
        break;

    case TIME_MIDI:
        lpTime16->u.midi.songptrpos = lpTime32->u.midi.songptrpos;
        break;
    }
}


/*****************************Private*Routine******************************\
* GetMMTime
*
* Gets an MMTIME structure from 16 bit storage into 32 bit storage
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
void
GetMMTime(
    LPMMTIME16 lpTime16,
    LPMMTIME lpTime32
    )
{

    lpTime32->wType = lpTime16->wType;

    switch ( lpTime32->wType ) {
    case TIME_MS:
        lpTime32->u.ms = lpTime16->u.ms;
        break;

    case TIME_SAMPLES:
        lpTime32->u.sample = lpTime16->u.sample;
        break;

    case TIME_BYTES:
        lpTime32->u.cb = lpTime16->u.cb;
        break;

    case TIME_SMPTE:
        lpTime32->u.smpte.hour  = lpTime16->u.smpte.hour;
        lpTime32->u.smpte.min   = lpTime16->u.smpte.min;
        lpTime32->u.smpte.sec   = lpTime16->u.smpte.sec;
        lpTime32->u.smpte.frame = lpTime16->u.smpte.frame;
        lpTime32->u.smpte.fps   = lpTime16->u.smpte.fps;
        lpTime32->u.smpte.dummy = lpTime16->u.smpte.dummy;
        break;

    case TIME_MIDI:
        lpTime32->u.midi.songptrpos = lpTime16->u.midi.songptrpos;
        break;
    }
}


/******************************Public*Routine******************************\
* W32CommonDeviceCB
*
* This routine is the callback which is ALWAYS called by wave and midi
* functions.  This is done to ensure that the XXXXHDR structure keeps
* getting copied back from 32 bit space to 16 bit, as it contains flags
* which the application is liable to keep checking.
*
* The way this whole business works is that the wave/midi data stays in 16
* bit space, but the XXXXHDR is copied to the 32 bit side, with the
* address of the data thunked accordingly so that Robin's device driver
* can still get at the data but we don't have the performance penalty of
* copying it back and forth all the time, not least because it is liable
* to be rather large...
*
* It also handles the tidying up of memory which is reserved to store
* the XXXXHDR, and the instance data (HWND/Callback address; instance
* data; flags) which the xxxxOpen calls pass to this routine, enabling
* it to forward messages or call callback as required.
*
* This routine handles all the messages that get sent from Robin's
* driver, and in fact thunks them back to the correct 16 bit form.  In
* theory there should be no MM_ format messages from the 16 bit side, so
* I can zap 'em out of WMSG16.  However the 32 bit side should thunk the
* mesages correctly and forward them to the 16 bit side and thence to
* the app.
*
* For the MM_WIM_DATA and MM_WOM_DONE message dwParam1 points to the
* following data struture.
*
*    P32HDR  is a 32 bit pointer to the original 16 bit header
*    P16HDR  is a 16 bit far pointer to the original 16 bit header
*
*    If we need to refernece the original header we must do via the
*    P32HDR pointer.
*
*                   +---------+
*                   | P32HDR  +----->+---------+
*                   +---------+      | 16 bit  |
*                   | P16HDR  +----->|         |    This is the original
*    dwParam1 ----->+---------+      |  Wave   |    wave header passed to
*                   | 32 bit  |      | Header  |    us by the Win 16 app.
*    This is the 32 |         |      |         |
*    bit wave       |  Wave   |      +---------+
*    header that we | Header  |
*    thunked at     |         |
*    earlier.       +---------+
*
*
* We must ensure that the 32 bit structure is completely hidden from the
* 16 bit application, ie. the 16 bit app only see's the wave header that it
* passed to us earlier.
*
*
* NOTE: dwParam2 is junk
*
*
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
VOID
W32CommonDeviceCB(
    HANDLE handle,
    UINT uMsg,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    )
{
    PWAVEHDR32      pWavehdr32;
    PMIDIHDR32      pMidiThunkHdr;
    PINSTANCEDATA   pInstanceData;
    HANDLE16        Hand16;

    pInstanceData = (PINSTANCEDATA)dwInstance;
    WinAssert( pInstanceData );

    switch (uMsg) {

        /* ------------------------------------------------------------
        ** MIDI INPUT MESSAGES
        ** ------------------------------------------------------------
        */

    case MM_MIM_LONGDATA:
        /*
        ** This message is sent to a window when an input buffer has been
        ** filled with MIDI system-exclusive data and is being returned to
        ** the application.
        */

    case MM_MIM_LONGERROR:
        /*
        ** This message is sent to a window when an invalid MIDI
        ** system-exclusive message is received.
        */
        pMidiThunkHdr = CONTAINING_RECORD(dwParam1, MIDIHDR32, Midihdr);
        WinAssert( pMidiThunkHdr );
        COPY_MIDIINHDR16_FLAGS( pMidiThunkHdr->pMidihdr32, pMidiThunkHdr->Midihdr );
        dwParam1 = (DWORD)pMidiThunkHdr->pMidihdr16;


    case MM_MIM_DATA:
        /*
        ** This message is sent to a window when a MIDI message is
        ** received by a MIDI input device.
        */

    case MM_MIM_ERROR:
        /*
        ** This message is sent to a window when an invalid MIDI message
        ** is received.
        */

    case MM_MIM_OPEN:
        /*
        ** This message is sent to a window when a MIDI input device is opened.
        ** We process this message the same way as MM_MIM_CLOSE (see below)
        */

    case MM_MIM_CLOSE:
        /*
        ** This message is sent to a window when a MIDI input device is
        ** closed. The device handle is no longer valid once this message
        ** has been sent.
        */
        Hand16 = pInstanceData->Hand16;
        break;



        /* ------------------------------------------------------------
        ** MIDI OUTPUT MESSAGES
        ** ------------------------------------------------------------
        */

    case MM_MOM_DONE:
        /*
        ** This message is sent to a window when the specified
        ** system-exclusive buffer has been played and is being returned to
        ** the application.
        */
        pMidiThunkHdr = CONTAINING_RECORD(dwParam1, MIDIHDR32, Midihdr);
        WinAssert( pMidiThunkHdr );
        COPY_MIDIOUTHDR16_FLAGS( pMidiThunkHdr->pMidihdr32, pMidiThunkHdr->Midihdr );
        dwParam1 = (DWORD)pMidiThunkHdr->pMidihdr16;

    case MM_MOM_OPEN:
        /*
        ** This message is sent to a window when a MIDI output device is opened.
        ** We process this message the same way as MM_MOM_CLOSE (see below)
        */

    case MM_MOM_CLOSE:
        /*
        ** This message is sent to a window when a MIDI output device is
        ** closed. The device handle is no longer valid once this message
        ** has been sent.
        */
        Hand16 = pInstanceData->Hand16;
        break;



        /* ------------------------------------------------------------
        ** WAVE INPUT MESSAGES
        ** ------------------------------------------------------------
        */

    case MM_WIM_DATA:
        /*
        ** This message is sent to a window when waveform data is present
        ** in the input buffer and the buffer is being returned to the
        ** application.  The message can be sent either when the buffer
        ** is full, or after the waveInReset function is called.
        */
        pWavehdr32 = (PWAVEHDR32)( (PBYTE)dwParam1 - (sizeof(PWAVEHDR16) * 2));
        WinAssert( pWavehdr32 );
        COPY_WAVEINHDR16_FLAGS( pWavehdr32->pWavehdr32, pWavehdr32->Wavehdr );
        dwParam1 = (DWORD)pWavehdr32->pWavehdr16;

    case MM_WIM_OPEN:
        /*
        ** This message is sent to a window when a waveform input
        ** device is opened.
        **
        ** We process this message the same way as MM_WIM_CLOSE (see below)
        */

    case MM_WIM_CLOSE:
        /*
        ** This message is sent to a window when a waveform input device is
        ** closed.  The device handle is no longer valid once the message has
        ** been sent.
        */
        Hand16 = pInstanceData->Hand16;
        break;



        /* ------------------------------------------------------------
        ** WAVE OUTPUT MESSAGES
        ** ------------------------------------------------------------
        */

    case MM_WOM_DONE:
        /*
        ** This message is sent to a window when the specified output
        ** buffer is being returned to the application. Buffers are returned
        ** to the application when they have been played, or as the result of
        ** a call to waveOutReset.
        */
        pWavehdr32 = (PWAVEHDR32)( (PBYTE)dwParam1 - (sizeof(PWAVEHDR16) * 2));
        WinAssert( pWavehdr32 );
        COPY_WAVEOUTHDR16_FLAGS( pWavehdr32->pWavehdr32, pWavehdr32->Wavehdr );
        dwParam1 = (DWORD)pWavehdr32->pWavehdr16;

    case MM_WOM_OPEN:
        /*
        ** This message is sent to a window when a waveform output device
        ** is opened.
        **
        ** We process this message the same way as MM_WOM_CLOSE (see below)
        */

    case MM_WOM_CLOSE:
        /*
        ** This message is sent to a window when a waveform output device
        ** is closed.  The device handle is no longer valid once the
        ** message has been sent.
        */
        Hand16 = pInstanceData->Hand16;
        break;

#if DBG
    default:
        dprintf(( "Unknown message received in CallBack function " ));
        return;
#endif

    }


    /*
    ** Now make the CallBack, or PostMessage call depending
    ** on the flags passed to original (wave|midi)(In|Out)Open call.
    */
    pInstanceData = (PINSTANCEDATA)dwInstance;
    WinAssert( pInstanceData );

    switch (pInstanceData->dwFlags & CALLBACK_TYPEMASK)  {

    case CALLBACK_WINDOW:
        dprintf3(( "WINDOW callback identified" ));
        PostMessage( HWND32( LOWORD(pInstanceData->dwCallback) ),
                     uMsg, Hand16, dwParam1 );
        break;


    case CALLBACK_TASK:
    case CALLBACK_FUNCTION: {

        DWORD   dwFlags;

        if ( (pInstanceData->dwFlags & CALLBACK_TYPEMASK) == CALLBACK_TASK ) {
            dprintf3(( "TASK callback identified" ));
            dwFlags = DCB_TASK;
        }
        else {
            dprintf3(( "FUNCTION callback identified" ));
            dwFlags = DCB_FUNCTION;
        }

        WOW32DriverCallback( pInstanceData->dwCallback,
                             dwFlags,
                             Hand16,
                             LOWORD( uMsg ),
                             pInstanceData->dwCallbackInstance,
                             dwParam1,
                             dwParam2 );

        }
        break;
    }

    /*
    ** Now, free up any storage that was allocated during the waveOutOpen
    ** and waveInOpen.  This should only be freed during the MM_WOM_CLOSE or
    ** MM_WIM_CLOSE message.
    */
    switch (uMsg) {

    case MM_MIM_CLOSE:
    case MM_MOM_CLOSE:
    case MM_WIM_CLOSE:
    case MM_WOM_CLOSE:
        dprintf2(( "W32CommonDeviceOpen: Freeing device open buffer at %X",
                    pInstanceData ));
        dprintf2(( "Alloc Midi count = %d", AllocMidiCount ));
        dprintf2(( "Alloc Wave count = %d", AllocWaveCount ));
        winmmFree( pInstanceData );
        break;
    }
}


/******************************Public*Routine******************************\
* WOW32DriverCallback
*
* Callback stub, which invokes the "real" 16 bit callback.
* The parameters to this function must be in the format that the 16 bit
* code expects,  i.e. all handles must be 16 bit handles, all addresses must
* be 16:16 ones.
*
*
* It is possible that this function will have been called with the
* DCB_WINDOW set in which case the 16 bit interrupt handler will call
* PostMessage.  Howver, it is much more efficient if PostMessage is called
* from the 32 bit side.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL WOW32DriverCallback( DWORD dwCallback, DWORD dwFlags, WORD wID, WORD wMsg,
                          DWORD dwUser, DWORD dw1, DWORD dw2 )
{

    PCALLBACK_ARGS      pArgs;
    WORD                tempSendCount;


    /*
    ** If this is window callback post the message here and let WOW
    ** take care of it.
    */
    if ( (dwFlags & DCB_TYPEMASK) == DCB_WINDOW ) {
        return PostMessage( HWND32( LOWORD(dwCallback) ), wMsg, wID, dw1 );
    }

    /*
    ** Now we put the parameters into the global callback data array
    ** and increment the wSendCount field.  Then we simulate
    ** an interrupt to the 16 bit code.
    **
    ** If tempSendCount == wRecvCount then we have filled the callback buffer.
    ** We throw this interrupt away, but still simulate an interrupt to the
    ** 16 bit side in an attempt to get it procesing the interrupt still in
    ** the buffer.
    */
    EnterCriticalSection( &mmCriticalSection );

    tempSendCount = ((pCallBackData->wSendCount + 1) % CALLBACK_ARGS_SIZE);

    if (tempSendCount != pCallBackData->wRecvCount) {

        pArgs = &pCallBackData->args[ pCallBackData->wSendCount ];

        pArgs->dwFlags        = dwFlags;
        pArgs->dwFunctionAddr = dwCallback;
        pArgs->wHandle        = wID;
        pArgs->wMessage       = wMsg;
        pArgs->dwInstance     = dwUser;
        pArgs->dwParam1       = dw1;
        pArgs->dwParam2       = dw2;

        /*
        ** Increment the send count.  Use of the % operator above makes
        ** sure that we wrap around to the begining of the array correctly.
        */
        pCallBackData->wSendCount = tempSendCount;

    }

    dprintf4(( "Send count = %d, Receive count = %d",
               pCallBackData->wSendCount, pCallBackData->wRecvCount ));
    LeaveCriticalSection( &mmCriticalSection );


    /*
    ** Dispatch the interrupt to the 16 bit code.
    */
    dprintf4(( "Dispatching HW interrupt callback" ));

    if (!IsNEC_98) {
        GenerateInterrupt( MULTIMEDIA_ICA, MULTIMEDIA_LINE, 1 );
    } else {
        GenerateInterrupt( MULTIMEDIA_ICA, MULTIMEDIA_LINE_98, 1 );
    }

    /*
    ** Dummy return code, used to keep api consistent with Win31 and Win NT.
    */
    return TRUE;
}


/******************************Public*Routine******************************\
* aux32Message
*
* Thunk the aux apis.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD WINAPI
aux32Message(
    UINT uDeviceID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    )
{
#if DBG
    static MSG_NAME name_map[] = {
        AUXDM_GETNUMDEVS,        "AUXDM_GETNUMDEVS",
        AUXDM_GETDEVCAPS,        "AUXDM_GETDEVCAPS",
        AUXDM_GETVOLUME,         "AUXDM_GETVOLUME",
        AUXDM_SETVOLUME,         "AUXDM_SETVOLUME",
    };
    int      i;
    int      n;
#endif

    static  DWORD               dwNumAuxDevs;
            DWORD               dwRet = MMSYSERR_NOTSUPPORTED;
            DWORD               dwTmp;
            DWORD UNALIGNED     *lpdwTmp;
            AUXCAPSA            aoCaps;

#if DBG
    for( i = 0, n = sizeof(name_map) / sizeof(name_map[0]); i < n; i++ ) {
        if ( name_map[i].uMsg == uMessage ) {
            break;
        }
    }
    if ( i != n ) {
        trace_aux(( "aux32Message( 0x%X, %s, 0x%X, 0x%X, 0x%X)",
                    uDeviceID, name_map[i].lpstrName, dwInstance,
                    dwParam1, dwParam2 ));
    }
    else {
        trace_aux(( "aux32Message( 0x%X, 0x%X, 0x%X, 0x%X, 0x%X)",
                     uDeviceID, uMessage, dwInstance,
                     dwParam1, dwParam2 ));
    }
#endif

    if ( LOWORD(uDeviceID) == 0xFFFF ) {
        uDeviceID = (UINT)-1;
    }

    dprintf2(( "aux32Message (0x%x)", uMessage ));
    switch ( uMessage ) {

    case AUXDM_GETNUMDEVS:
        dwRet = auxGetNumDevs();
        break;

    case AUXDM_GETDEVCAPS:
        dwRet = auxGetDevCapsA( uDeviceID, &aoCaps, sizeof(aoCaps) );
        if ( dwRet == MMSYSERR_NOERROR ) {
            CopyAuxCaps( (LPAUXCAPS16)GETVDMPTR( dwParam1 ),
                         &aoCaps, dwParam2 );
        }
        break;

    case AUXDM_GETVOLUME:
        dwRet = auxGetVolume( uDeviceID, &dwTmp );
        lpdwTmp = GETVDMPTR( dwParam1 );
        *lpdwTmp = dwTmp;
        break;

    case AUXDM_SETVOLUME:
        dwRet = auxSetVolume( uDeviceID, dwParam1 );
        break;

    default:
        if ( uMessage >= DRV_BUFFER_LOW && uMessage <= DRV_BUFFER_HIGH ) {
            lpdwTmp = GETVDMPTR( dwParam1 );
        }
        else {
            lpdwTmp = (LPDWORD)dwParam1;
        }
        dwRet = auxOutMessage( uDeviceID, uMessage,
                               (DWORD)lpdwTmp, dwParam2 );
    }

    trace_aux(( "-> 0x%X", dwRet ));

    return dwRet;
}


/*****************************Private*Routine******************************\
* CopyAuxCaps
*
* Copies 32 bit aux out caps info into the passed 16bit storage.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
void
CopyAuxCaps(
    LPAUXCAPS16 lpCaps16,
    LPAUXCAPSA lpCaps32,
    DWORD dwSize
    )
{
    AUXCAPS16 Caps16;

    Caps16.wMid = lpCaps32->wMid;
    Caps16.wPid = lpCaps32->wPid;

    Caps16.vDriverVersion = LOWORD( lpCaps32->vDriverVersion );
    CopyMemory( Caps16.szPname, lpCaps32->szPname, MAXPNAMELEN );
    Caps16.wTechnology = lpCaps32->wTechnology;
    Caps16.dwSupport = lpCaps32->dwSupport;

    CopyMemory( (LPVOID)lpCaps16, (LPVOID)&Caps16, (UINT)dwSize );
}

/******************************Public*Routine******************************\
* tid32Message
*
* Thunk the timer apis
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD WINAPI
tid32Message(
    UINT uDevId,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    )
{
#if DBG
    static MSG_NAME name_map[] = {
        TDD_SETTIMEREVENT,  "timeSetEvent",
        TDD_KILLTIMEREVENT, "timeKillEvent",
        TDD_GETSYSTEMTIME,  "timeGetTime",
        TDD_GETDEVCAPS,     "timeGetDevCaps",
        TDD_BEGINMINPERIOD, "timeBeginPeriod",
        TDD_ENDMINPERIOD,   "timeEndPeriod",
    };
    int      i;
    int      n;
#endif

    DWORD               dwRet = TIMERR_NOCANDO;
    LPTIMECAPS16        lp16TimeCaps;
    LPTIMEREVENT16      lp16TimeEvent;

#if DBG
    for( i = 0, n = sizeof(name_map) / sizeof(name_map[0]); i < n; i++ ) {
        if ( name_map[i].uMsg == uMessage ) {
            break;
        }
    }
    if ( i != n ) {
        trace_time(( "tid32Message( %s, 0x%X, 0x%X)",
                     name_map[i].lpstrName, dwParam1, dwParam2 ));
    }
    else {
        trace_time(( "tid32Message( 0x%X, 0x%X, 0x%X)",
                     uMessage,  dwParam1, dwParam2 ));
    }
#endif


    switch (uMessage) {

    case TDD_SETTIMEREVENT:

        lp16TimeEvent = (LPTIMEREVENT16)GETVDMPTR( dwParam1);

        trace_time(( "tid32Message: timeSetEvent(%#X, %#X, %#X, %#X)",
                     lp16TimeEvent->wDelay, lp16TimeEvent->wResolution,
                     lp16TimeEvent->lpFunction, lp16TimeEvent->wFlags ));

        /*
        **  The only difference for WOW is that WOW32DriverCallback is
        **  called for the callback rather than DriverCallback.  The
        **  last parameter to timeSetEventInternal makes this happen.
        */

        dwRet = timeSetEventInternal( max( lp16TimeEvent->wDelay,
                                           g_TimeCaps32.wPeriodMin ),
                                      lp16TimeEvent->wResolution,
                                      (LPTIMECALLBACK)lp16TimeEvent->lpFunction,
                                      (DWORD)lp16TimeEvent->dwUser,
                                      lp16TimeEvent->wFlags & TIME_PERIODIC,
                                      TRUE);

        dprintf4(( "timeSetEvent: 32 bit time ID %8X", dwRet ));
        break;

    case TDD_KILLTIMEREVENT:
        dwRet = timeKillEvent( dwParam1 );
        {
            /*
            ** Purge the callback queue of any messages were
            ** generated with this timer id.
            */

            int nIndex;

            EnterCriticalSection( &mmCriticalSection );

            for ( nIndex = 0; nIndex < CALLBACK_ARGS_SIZE; nIndex++ ) {

                if ( pCallBackData->args[ nIndex ].wHandle == LOWORD(dwParam1) &&
                     pCallBackData->args[ nIndex ].wMessage == 0 ) {

                    pCallBackData->args[ nIndex ].dwFunctionAddr = 0L;
                }
            }

            LeaveCriticalSection( &mmCriticalSection );
        }
        break;

    case TDD_GETSYSTEMTIME:
        dwRet = timeGetTime();
        break;

    case TDD_GETDEVCAPS:
        dwRet = 0;

        lp16TimeCaps = GETVDMPTR( dwParam1 );

        /*
        ** Under NT, the minimum time period is about 15ms.
        ** But Win3.1 on a 386 always returns 1ms.  Encarta doesn't even
        ** bother testing the CD-ROM's speed if the minimum period
        ** is > 2ms, it just assumes it is too slow.  So here we lie
        ** to WOW apps and always tell them 1ms just like Win3.1.
        **      John Vert (jvert) 17-Jun-1993
        */
#ifdef TELL_THE_TRUTH
        lp16TimeCaps->wPeriodMin = g_TimeCaps32.wPeriodMin;
#else
        lp16TimeCaps->wPeriodMin = MIN_TIME_PERIOD_WE_RETURN;
#endif

        /*
        ** In windows 3.1 the wPeriodMax value is 0xFFFF which is the
        ** max value you can store in a word.  In windows NT the
        ** wPeriodMax is 0xF4240 (1000 seconds).
        **
        ** If we just cast the 32 bit value down to a 16bit value we
        ** end up with 0x4240 which very small compared to real 32 bit
        ** value.
        **
        ** Therefore I will take the minimum of wPeriodMax and 0xFFFF
        ** that way will should remain consistent with Win 3.1 if
        ** wPeriodMax is greater than 0xFFFF.
        */
        lp16TimeCaps->wPeriodMax = (WORD)min(0xFFFF, g_TimeCaps32.wPeriodMax);
        break;

    case TDD_ENDMINPERIOD:
        dwParam1 = max(dwParam1, g_TimeCaps32.wPeriodMin);
        dwRet = timeEndPeriod( dwParam1 );
        break;

    case TDD_BEGINMINPERIOD:
        dwParam1 = max(dwParam1, g_TimeCaps32.wPeriodMin);
        dwRet = timeBeginPeriod( dwParam1 );
        break;

    }

    trace_time(( "-> 0x%X", dwRet ));

    return dwRet;
}


/******************************Public*Routine******************************\
* joy32Message
*
* Thunk the joystick apis
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD WINAPI
joy32Message(
    UINT uID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    )
{
#if DBG
    static MSG_NAME name_map[] = {
        JDD_GETDEVCAPS,     "joyGetDevCaps",
        JDD_GETPOS,         "joyGetPos",
//        JDD_SETCALIBRATION, "joySetCalibration",
        JDD_GETNUMDEVS,     "joyGetNumDevs"
    };
    int      i;
    int      n;
#endif

    UINT                wXbase;
    UINT                wXdelta;
    UINT                wYbase;
    UINT                wYdelta;
    UINT                wZbase;
    UINT                wZdelta;

    WORD UNALIGNED      *lpw;

    DWORD               dwRet = TIMERR_NOCANDO;
    JOYCAPSA            JoyCaps32;
    JOYINFO             JoyInfo32;
    LPJOYCAPS16         lp16JoyCaps;
    LPJOYINFO16         lp16JoyInfo;

#if DBG
    for( i = 0, n = sizeof(name_map) / sizeof(name_map[0]); i < n; i++ ) {
        if ( name_map[i].uMsg == uMessage ) {
            break;
        }
    }
    if ( i != n ) {
        trace_joy(( "joy32Message( %s, 0x%X, 0x%X)",
                    name_map[i].lpstrName, dwParam1, dwParam2 ));
    }
    else {
        trace_joy(( "joy32Message( 0x%X, 0x%X, 0x%X)",
                    uMessage,  dwParam1, dwParam2 ));
    }
#endif


    switch (uMessage) {


    case JDD_GETDEVCAPS:
        dwRet = joyGetDevCapsA( uID, &JoyCaps32, sizeof(JoyCaps32) );

        if ( dwRet == 0 ) {

            JOYCAPS16   JoyCaps16;

            lp16JoyCaps = GETVDMPTR( dwParam1 );

            JoyCaps16.wMid = JoyCaps32.wMid;
            JoyCaps16.wPid = JoyCaps32.wPid;

            CopyMemory( JoyCaps16.szPname, JoyCaps32.szPname, MAXPNAMELEN );

            JoyCaps16.wXmin = LOWORD( JoyCaps32.wXmin );
            JoyCaps16.wXmax = LOWORD( JoyCaps32.wXmax );

            JoyCaps16.wYmin = LOWORD( JoyCaps32.wYmin );
            JoyCaps16.wYmax = LOWORD( JoyCaps32.wYmax );

            JoyCaps16.wZmin = LOWORD( JoyCaps32.wZmin );
            JoyCaps16.wZmax = LOWORD( JoyCaps32.wZmax );

            JoyCaps16.wNumButtons = LOWORD( JoyCaps32.wNumButtons );

            JoyCaps16.wPeriodMin = LOWORD( JoyCaps32.wPeriodMin );
            JoyCaps16.wPeriodMax = LOWORD( JoyCaps32.wPeriodMax );

            CopyMemory( (LPVOID)lp16JoyCaps, (LPVOID)&JoyCaps16, (UINT)dwParam2 );
        }
        break;

    case JDD_GETNUMDEVS:
        dwRet = joyGetNumDevs();
        break;

    case JDD_GETPOS:
        dwRet = joyGetPos( uID, &JoyInfo32 );
        if ( dwRet == MMSYSERR_NOERROR ) {

            lp16JoyInfo = GETVDMPTR( dwParam1 );

            lp16JoyInfo->wXpos = LOWORD( JoyInfo32.wXpos );
            lp16JoyInfo->wYpos = LOWORD( JoyInfo32.wYpos );
            lp16JoyInfo->wZpos = LOWORD( JoyInfo32.wZpos );
            lp16JoyInfo->wButtons = LOWORD( JoyInfo32.wButtons );

        }
        break;
    }

    trace_joy(( "-> 0x%X", dwRet ));

    return dwRet;
}


/******************************Public*Routine******************************\
* mxd32Message
*
* 32 bit thunk function.  On NT all the 16 bit mixer apis get routed to
* here.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD CALLBACK
mxd32Message(
    UINT uId,
    UINT uMsg,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    )
{

#if DBG
    static MSG_NAME name_map[] = {
        MXDM_INIT,              "mixerInit",
        MXDM_GETNUMDEVS,        "mixerGetNumDevs",
        MXDM_GETDEVCAPS,        "mixerGetDevCaps",
        MXDM_OPEN,              "mixerOpen",
        MXDM_GETLINEINFO,       "mixerGetLineInfo",
        MXDM_GETLINECONTROLS,   "mixerGetLineControls",
        MXDM_GETCONTROLDETAILS, "mixerGetControlsDetails",
        MXDM_SETCONTROLDETAILS, "mixerSetControlsDetails"
    };
    int      i;
    int      n;
#endif


    DWORD                   dwRet = MMSYSERR_NOTSUPPORTED;
    DWORD                   fdwOpen;
    LPVOID                  lpOldAddress;
    LPMIXERCONTROLDETAILS   pmxcd;
    LPMIXERLINECONTROLSA    pmxlc;
    MIXERCONTROLDETAILS     mxcdA;
    HMIXEROBJ               hmixobj;
    MIXERCAPSA              caps32;
    MIXERCAPS16             caps16;
    LPMIXERCAPS16           lpcaps16;
    MIXERLINEA              line32;
    LPMIXERLINE16           lpline16;
    LPMIXEROPENDESC16       lpmxod16;
    HMIXER UNALIGNED        *phmx;
    HMIXER                  hmx;


#if DBG
    for( i = 0, n = sizeof(name_map) / sizeof(name_map[0]); i < n; i++ ) {
        if ( name_map[i].uMsg == uMsg ) {
            break;
        }
    }
    if ( i != n ) {
        trace_mix(( "mxd32Message( %s, 0x%X, 0x%X, 0x%X)",
                    name_map[i].lpstrName, dwInstance, dwParam1, dwParam2 ));
    }
    else {
        trace_mix(( "mxd32Message( 0x%X, 0x%X, 0x%X, 0x%X)",
                    uMsg, dwInstance, dwParam1, dwParam2 ));
    }
#endif


    if ( dwInstance == 0L ) {
        hmixobj = (HMIXEROBJ)uId;
    }
    else {
        hmixobj = (HMIXEROBJ)dwInstance;
    }

    switch ( uMsg ) {

    case MXDM_INIT:
        dwRet = 0;
        break;

    case MXDM_GETNUMDEVS:
        dwRet = mixerGetNumDevs();
        break;

    case MXDM_CLOSE:
        dwRet = mixerClose( (HMIXER)dwInstance );
        break;

    case MXDM_GETDEVCAPS:
        dwRet = mixerGetDevCapsA( uId, &caps32, sizeof(caps32) );
        if ( dwRet == MMSYSERR_NOERROR ) {

            lpcaps16 = GETVDMPTR( dwParam1 );

            caps16.wMid = caps32.wMid;
            caps16.wPid = caps32.wPid;

            caps16.vDriverVersion = LOWORD( caps32.vDriverVersion );
            CopyMemory( caps16.szPname, caps32.szPname, MAXPNAMELEN );
            caps16.fdwSupport = caps32.fdwSupport;
            caps16.cDestinations = caps32.cDestinations;

            CopyMemory( (LPVOID)lpcaps16, (LPVOID)&caps16, (UINT)dwParam2 );

        }
        break;

    case MXDM_OPEN:
        lpmxod16 = GETVDMPTR( dwParam1 );

        /*
        ** fdwOpen has already mapped all device handles into device ID's on
        ** the 16 bit side.  Therefore mangle the flags to reflect this.
        */
        fdwOpen = (DWORD)lpmxod16->pReserved0;

        if ( ( fdwOpen & CALLBACK_TYPEMASK ) == CALLBACK_WINDOW ) {

            lpmxod16->dwCallback = (DWORD)HWND32(LOWORD(lpmxod16->dwCallback));

        }
        else if ( ( fdwOpen & CALLBACK_TYPEMASK ) == CALLBACK_TASK ) {

            lpmxod16->dwCallback = GetCurrentThreadId();
        }

        dwRet = mixerOpen( &hmx, dwParam2, lpmxod16->dwCallback,
                           lpmxod16->dwInstance, fdwOpen );

        if ( dwRet == MMSYSERR_NOERROR ) {
            SetWOWHandle( hmx, lpmxod16->hmx );

            phmx = GETVDMPTR( dwInstance );
            *phmx = hmx;
        }
        break;

    case MXDM_GETLINEINFO:
        lpline16 = GETVDMPTR( dwParam1 );

        GetLineInfo( lpline16, &line32 );

        dwRet = mixerGetLineInfoA( hmixobj, &line32, dwParam2 );
        if ( dwRet == MMSYSERR_NOERROR ) {

            PutLineInfo( lpline16, &line32 );
        }
        break;

    case MXDM_GETLINECONTROLS:
        pmxlc = (LPMIXERLINECONTROLSA)GETVDMPTR( dwParam1 );
        lpOldAddress = pmxlc->pamxctrl;
        pmxlc->pamxctrl = GETVDMPTR( lpOldAddress );

        dwRet = mixerGetLineControlsA(hmixobj, pmxlc, dwParam2);

        pmxlc->pamxctrl = lpOldAddress;
        break;

    /*
    **  CAREFUL !!!
    **
    **  The ONLY reason we don't copy the details themselves is because
    **  somewhere down the line (usually in the IO subsystem) they're
    **  copied anyway
    */

    case MXDM_GETCONTROLDETAILS:
        pmxcd = (LPMIXERCONTROLDETAILS)GETVDMPTR( dwParam1 );
        CopyMemory(&mxcdA, pmxcd, sizeof(mxcdA));
        mxcdA.paDetails = GETVDMPTR( pmxcd->paDetails );

        dwRet = mixerGetControlDetailsA(hmixobj, &mxcdA, dwParam2);

        break;

    case MXDM_SETCONTROLDETAILS:
        pmxcd = (LPMIXERCONTROLDETAILS)GETVDMPTR( dwParam1 );
        CopyMemory(&mxcdA, pmxcd, sizeof(mxcdA));
        mxcdA.paDetails = GETVDMPTR( pmxcd->paDetails );

        dwRet = mixerSetControlDetails( hmixobj, &mxcdA, dwParam2 );
        break;

    default:
        dprintf3(( "Unkown mixer message 0x%X", uMsg ));
        dwRet = mixerMessage( (HMIXER)hmixobj, uMsg, dwParam1, dwParam2 );
        break;

    }

    dprintf3(( "-> 0x%X", dwRet ));
    return dwRet;
}

/*****************************Private*Routine******************************\
* GetLineInfo
*
* Copies fields from the 16 bit line info structure to the 32 bit line info
* structure.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
void
GetLineInfo(
    LPMIXERLINE16 lpline16,
    LPMIXERLINEA lpline32
    )
{
    CopyMemory( lpline32, (LPVOID)lpline16, FIELD_OFFSET(MIXERLINEA, Target.vDriverVersion ) );
    lpline32->Target.vDriverVersion = (DWORD)lpline16->Target.vDriverVersion;
    CopyMemory( lpline32->Target.szPname, lpline16->Target.szPname, MAXPNAMELEN );
    lpline32->cbStruct += sizeof(UINT) - sizeof(WORD);
}


/*****************************Private*Routine******************************\
* PutLineInfo
*
* Copies fields from the 32 bit line info structure to the 16 bit line info
* structure.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
void
PutLineInfo(
    LPMIXERLINE16 lpline16,
    LPMIXERLINEA lpline32
    )
{
    CopyMemory( (LPVOID)lpline16, lpline32, FIELD_OFFSET(MIXERLINEA, Target.vDriverVersion ) );
    lpline16->Target.vDriverVersion = (WORD)lpline32->Target.vDriverVersion;
    CopyMemory( lpline16->Target.szPname, lpline32->Target.szPname, MAXPNAMELEN );
    lpline16->cbStruct -= sizeof(UINT) - sizeof(WORD);
}



/******************************Public*Routine******************************\
* WOW32ResolveMultiMediaHandle
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
BOOL APIENTRY
WOW32ResolveMultiMediaHandle(
    UINT uHandleType,
    UINT uMappingDirection,
    WORD wHandle16_In,
    LPWORD lpwHandle16_Out,
    DWORD dwHandle32_In,
    LPDWORD lpdwHandle32_Out
    )
{
    BOOL    fReturn = FALSE;
    DWORD   dwHandle32;
    WORD    wHandle16;
    HANDLE  h;

    /*
    ** Protect ourself from being given a duff pointer.
    */
    try {
        if ( uMappingDirection == WOW32_DIR_16IN_32OUT ) {

            dwHandle32 = 0L;

            if ( wHandle16_In != 0 ) {

                switch ( uHandleType ) {

                case WOW32_WAVEIN_HANDLE:
                case WOW32_WAVEOUT_HANDLE:
                case WOW32_MIDIOUT_HANDLE:
                case WOW32_MIDIIN_HANDLE:
                    EnterCriticalSection(&HandleListCritSec);
                    h = GetHandleFirst();

                    while ( h )  {

                        if ( GetWOWHandle(h) == wHandle16_In ) {
                            dwHandle32 = (DWORD)h;
                            break;
                        }
                        h = GetHandleNext(h);
                    }
                    LeaveCriticalSection(&HandleListCritSec);

                    break;
                }

                *lpdwHandle32_Out = dwHandle32;
                if ( dwHandle32 ) {
                    fReturn = TRUE;
                }
            }

        }
        else if ( uMappingDirection == WOW32_DIR_32IN_16OUT ) {

            switch ( uHandleType ) {

            case WOW32_WAVEIN_HANDLE:
            case WOW32_WAVEOUT_HANDLE:
            case WOW32_MIDIOUT_HANDLE:
            case WOW32_MIDIIN_HANDLE:
                wHandle16 = (WORD)GetWOWHandle(dwHandle32_In);
                break;
            }

            *lpwHandle16_Out = wHandle16;
            if ( wHandle16 ) {
                fReturn = TRUE;
            }
        }
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {

        fReturn = FALSE;
    }

    return fReturn;
}

#endif // _WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\muldiv32.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1996 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  muldiv32.h
//
//  Description:
//      math routines for 32 bit signed and unsiged numbers.
//
//      MulDiv32(a,b,c) = (a * b) / c         (round down, signed)
//
//      MulDivRD(a,b,c) = (a * b) / c         (round down, unsigned)
//      MulDivRN(a,b,c) = (a * b + c/2) / c   (round nearest, unsigned)
//      MulDivRU(a,b,c) = (a * b + c-1) / c   (round up, unsigned)
//
//==========================================================================;

#ifndef _INC_MULDIV32
#define _INC_MULDIV32


#ifndef INLINE
#define INLINE __inline
#endif


#ifdef WIN32

    //----------------------------------------------------------------------;
    //
    //  Win 32
    //
    //----------------------------------------------------------------------;

    #ifdef _X86_
    
        //
        //  Use 32-bit x86 assembly.
        //

        #pragma warning(disable:4035 4704)

        INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     imul    ebx              //  imul ebx
            _asm     idiv    ecx              //  idiv ecx
            _asm	 shld	 edx, eax, 16     //  shld edx, eax, 16

        } // MulDiv32()

        INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     mov     ebx,ecx          //  mov  ebx,ecx
            _asm     shr     ebx,1            //  sar  ebx,1
            _asm     add     eax,ebx          //  add  eax,ebx
            _asm     adc     edx,0            //  adc  edx,0
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDiv32()

        INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     mov     ebx,ecx          //  mov  ebx,ecx
            _asm     dec     ebx              //  dec  ebx
            _asm     add     eax,ebx          //  add  eax,ebx
            _asm     adc     edx,0            //  adc  edx,0
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDivRU32()

        INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDivRD32()

        #pragma warning(default:4035 4704)


    #else

        //
        //  Use C9 __int64 support for Daytona RISC platforms.
        //

        INLINE LONG MulDiv32( LONG a, LONG b, LONG c )
        {
            return (LONG)( Int32x32To64(a,b) / c );
        }


        INLINE DWORD MulDivRD( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( UInt32x32To64(a,b) / c );
        }


        INLINE DWORD MulDivRN( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( (UInt32x32To64(a,b)+c/2) / c );
        }


        INLINE DWORD MulDivRU( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( (UInt32x32To64(a,b)+c-1) / c );
        }

    #endif


#else

    //----------------------------------------------------------------------;
    //
    //  Win 16
    //
    //----------------------------------------------------------------------;

    #pragma warning(disable:4035 4704)

    //
    //  Compile for 16-bit - we can use x86 with proper opcode prefixes
    //	    to get 32-bit instructions.
    //

    INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    imul    bx              //  imul ebx
        _asm _emit 0x66 _asm    idiv    cx              //  idiv ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    shr     bx,1            //  sar  ebx,1
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    dec     bx              //  dec  ebx
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRU32()


    INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRD32()

    #pragma warning(default:4035 4704)

#endif


//
//  some code references these by other names.
//
#define muldiv32    MulDiv32
#define muldivrn32  MulDivRN
#define muldivrd32  MulDivRD
#define muldivru32  MulDivRU

#endif  // _INC_MULDIV32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\mmwow32.h ===
/******************************Module*Header*******************************\
* Module Name: mmwow32.h
*
* This file types, function declarations and macro for the 32 bit MM thunks
*
* Created:  1-Jul-1993
* Author: Stephen Estrop [StephenE]
*
* Copyright (c) 1993-1996 Microsoft Corporation
\**************************************************************************/
#include <wownt32.h>

#ifdef _INC_ALL_WOWSTUFF

/****************************************************************************\
**
** 16 bit structures
**
\****************************************************************************/
#pragma pack(1)
typedef WORD    HANDLE16;
typedef WORD    MMVER16;      // major (high byte), minor (low byte)

// waveform input and output device open information structure
typedef struct waveopendesc16_tag {
    HANDLE16       hWave;             // handle (16 bit)
    LPWAVEFORMAT   lpFormat;          // format of wave data (16:16 ptr)
    DWORD          dwCallback;        // callback
    DWORD          dwInstance;        // app's private instance information
} WAVEOPENDESC16;
typedef WAVEOPENDESC16 UNALIGNED *LPWAVEOPENDESC16;


typedef struct _WAVEHDR16 {           /* whd16 */
    LPSTR   lpData;
    DWORD   dwBufferLength;
    DWORD   dwBytesRecorded;
    DWORD   dwUser;
    DWORD   dwFlags;
    DWORD   dwLoops;
    struct _WAVEHDR16 far *lpNext;
    DWORD   reserved;
} WAVEHDR16;
typedef WAVEHDR16 UNALIGNED *PWAVEHDR16;

typedef struct _WAVEOCUTCAPS16 {
    WORD    wMid;
    WORD    wPid;
    MMVER16 vDriverVersion;
    char    szPname[MAXPNAMELEN];
    DWORD   dwFormats;
    WORD    wChannels;
    DWORD   dwSupport;
} WAVEOUTCAPS16;
typedef WAVEOUTCAPS16 UNALIGNED *LPWAVEOUTCAPS16;

typedef struct _WAVEINCAPS16 {            /* wic16 */
    WORD    wMid;
    WORD    wPid;
    MMVER16 vDriverVersion;
    char    szPname[MAXPNAMELEN];
    DWORD   dwFormats;
    WORD    wChannels;
} WAVEINCAPS16;
typedef WAVEINCAPS16 UNALIGNED *LPWAVEINCAPS16;


typedef struct midiopendesc16_tag {
    HANDLE16       hMidi;             /* handle */
    DWORD          dwCallback;        /* callback */
    DWORD          dwInstance;        /* app's private instance information */
} MIDIOPENDESC16;
typedef MIDIOPENDESC16 UNALIGNED *LPMIDIOPENDESC16;

typedef struct _MIDIHDR16 {               /* mhdr16 */
    LPSTR   lpData;
    DWORD   dwBufferLength;
    DWORD   dwBytesRecorded;
    DWORD   dwUser;
    DWORD   dwFlags;
    struct  _MIDIHDR16 far *lpNext;
    DWORD   reserved;
} MIDIHDR16;
typedef MIDIHDR16 UNALIGNED *PMIDIHDR16;

typedef struct _MIDIOUTCAPS16 {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    MMVER16 vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    WORD    wTechnology;           /* type of device */
    WORD    wVoices;               /* # of voices (internal synth only) */
    WORD    wNotes;                /* max # of notes (internal synth only) */
    WORD    wChannelMask;          /* channels used (internal synth only) */
    DWORD   dwSupport;             /* functionality supported by driver */
} MIDIOUTCAPS16;
typedef MIDIOUTCAPS16 UNALIGNED *LPMIDIOUTCAPS16;

typedef struct _MIDINCAPS16 {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    MMVER16 vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
} MIDIINCAPS16;
typedef MIDIINCAPS16 UNALIGNED *LPMIDIINCAPS16;


typedef struct _MMTIME16 {                /* mmt16 */
    WORD    wType;
    union {
        DWORD   ms;
        DWORD   sample;
        DWORD   cb;
        struct {
            BYTE    hour;
            BYTE    min;
            BYTE    sec;
            BYTE    frame;
            BYTE    fps;
            BYTE    dummy;
        } smpte;
        struct {
            DWORD   songptrpos;
        } midi;
    } u;
} MMTIME16;
typedef MMTIME16 UNALIGNED *LPMMTIME16;

typedef struct timerevent16_tag {
    WORD                wDelay;         /* delay required */
    WORD                wResolution;    /* resolution required */
    LPTIMECALLBACK      lpFunction;     /* ptr to callback function */
    DWORD               dwUser;         /* user DWORD */
    WORD                wFlags;         /* defines how to program event */
} TIMEREVENT16;
typedef TIMEREVENT16 UNALIGNED *LPTIMEREVENT16;

typedef struct timecaps16_tag {
    WORD    wPeriodMin;     /* minimum period supported  */
    WORD    wPeriodMax;     /* maximum period supported  */
} TIMECAPS16;
typedef TIMECAPS16 UNALIGNED *LPTIMECAPS16;


typedef struct _AUXCAPS16 {
    WORD    wMid;
    WORD    wPid;
    MMVER16 vDriverVersion;
    char    szPname[MAXPNAMELEN];
    WORD    wTechnology;
    DWORD   dwSupport;
} AUXCAPS16;
typedef AUXCAPS16 UNALIGNED *LPAUXCAPS16;

typedef struct _JOYCAPS16 {
    WORD    wMid;
    WORD    wPid;
    MMVER16 vDriverVersion;
    char    szPname[MAXPNAMELEN];
    WORD    wXmin;
    WORD    wXmax;
    WORD    wYmin;
    WORD    wYmax;
    WORD    wZmin;
    WORD    wZmax;
    WORD    wNumButtons;
    WORD    wPeriodMin;
    WORD    wPeriodMax;
} JOYCAPS16;
typedef JOYCAPS16 UNALIGNED *LPJOYCAPS16;


typedef struct _JOYINFO16 {
    WORD    wXpos;
    WORD    wYpos;
    WORD    wZpos;
    WORD    wButtons;
} JOYINFO16;
typedef JOYINFO16 UNALIGNED *LPJOYINFO16;

#pragma pack()



/****************************************************************************\
**
** 32 bit structures
**
\****************************************************************************/
typedef struct _INSTANCEDATA {
    DWORD     dwCallback;          //Callback function or window handle
    DWORD     dwCallbackInstance;  //Instance data for callback function (only)
    DWORD     dwFlags;             //Flags
    HANDLE16  Hand16;
} INSTANCEDATA, *PINSTANCEDATA;

typedef struct _WAVEHDR32 {
    PWAVEHDR16 pWavehdr32;         //32 bit address to 16 bit WAVEHDR
    PWAVEHDR16 pWavehdr16;         //16 bit address to 16 bit WAVEHDR
    WAVEHDR    Wavehdr;            //32 bit address to 32 bit WAVEHDR
} WAVEHDR32, *PWAVEHDR32;


typedef struct _MIDIHDR32 {
    DWORD      reserved;           //Saved value of reserved.
    PMIDIHDR16 pMidihdr32;         //32 bit address to 16 bit MIDIHDR
    PMIDIHDR16 pMidihdr16;         //16 bit address to 16 bit MIDIHDR
    MIDIHDR    Midihdr;            //32 bit address to 32 bit MIDIHDR
} MIDIHDR32, *PMIDIHDR32;



/****************************************************************************\
** Function prototypes
**
**
\****************************************************************************/

BOOL
WINAPI LibMain(
    HINSTANCE hInst,
    DWORD dwReason,
    LPVOID lpReserved
    );

DWORD
WINAPI wod32Message(
    UINT uDeviceID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    );

DWORD
WINAPI wid32Message(
    UINT uDeviceID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    );

DWORD
WINAPI mod32Message(
    UINT uDeviceID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    );

DWORD
WINAPI mid32Message(
    UINT uDeviceID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    );

DWORD
WINAPI aux32Message(
    UINT uDeviceID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    );

void
CopyAuxCaps(
    LPAUXCAPS16 lpCaps16,
    LPAUXCAPS lpCaps32,
    DWORD dwSize
    );

DWORD WINAPI
tid32Message(
    UINT uDevId,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    );

VOID
W32CommonDeviceCB(
    HANDLE handle,
    UINT uMsg,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    );

PWAVEHDR16
GetWaveHdr16(
    DWORD vpwhdr,
    LPWAVEHDR lpwhdr
    );

void
PutWaveHdr16(
    WAVEHDR16 UNALIGNED *pwhdr16,
    LPWAVEHDR lpwhdr
    );

BOOL
WOW32DriverCallback(
    DWORD dwCallback,
    DWORD dwFlags,
    WORD wID,
    WORD wMsg,
    DWORD dwUser,
    DWORD dw1,
    DWORD dw2
    );

void
CopyWaveOutCaps(
    LPWAVEOUTCAPS16 lpCaps16,
    LPWAVEOUTCAPS   lpCaps32,
    DWORD dwSize
    );

void
CopyWaveInCaps(
    LPWAVEINCAPS16 lpCaps16,
    LPWAVEINCAPS lpCaps32,
    DWORD dwSize
    );

void
CopyMidiOutCaps(
    LPMIDIOUTCAPS16 lpCaps16,
    LPMIDIOUTCAPS lpCaps32,
    DWORD dwSize
    );

void
CopyMidiInCaps(
    LPMIDIINCAPS16 lpCaps16,
    LPMIDIINCAPS lpCaps32,
    DWORD dwSize
    );

void
GetMMTime(
    LPMMTIME16 lpTime16,
    LPMMTIME lpTime32
    );

void
PutMMTime(
    LPMMTIME16 lpTime16,
    LPMMTIME lpTime32
    );


#define WAVE_OUT_DEVICE 1
#define WAVE_IN_DEVICE  0
DWORD
ThunkCommonWaveOpen(
    int iWhich,
    UINT uDeviceID,
    DWORD dwParam1,
    DWORD dwParam2,
    DWORD dwUSer
    );

DWORD
ThunkCommonWaveReadWrite(
    int iWhich,
    DWORD dwParam1,
    DWORD dwParam2,
    DWORD dwInstance
    );

DWORD
ThunkCommonWavePrepareHeader(
    HWAVE hWave,
    DWORD dwParam1,
    int iWhich
    );

DWORD
ThunkCommonWaveUnprepareHeader(
    HWAVE hWave,
    DWORD dwParam1,
    int iWhich
    );

#define MIDI_OUT_DEVICE 1
#define MIDI_IN_DEVICE  0
DWORD
ThunkCommonMidiOpen(
    int iWhich,
    UINT uDeviceID,
    DWORD dwParam1,
    DWORD dwParam2,
    DWORD dwInstance
    );

DWORD
ThunkCommonMidiReadWrite(
    int iWhich,
    DWORD dwParam1,
    DWORD dwParam2,
    DWORD dwInstance
    );

DWORD
ThunkCommonMidiPrepareHeader(
    HMIDI hWave,
    DWORD dwParam1,
    int iWhich
    );

DWORD
ThunkCommonMidiUnprepareHeader(
    HMIDI hWave,
    DWORD dwParam1,
    int iWhich
    );

PMIDIHDR16
GetMidiHdr16(
    DWORD vpmhdr,
    LPMIDIHDR lpmhdr
    );

void
PutMidiHdr16(
    MIDIHDR UNALIGNED *pmhdr16,
    LPMIDIHDR lpmhdr
    );

DWORD WINAPI
joy32Message(
    UINT uID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    );


/* -------------------------------------------------------------------------
** MCI Stuff
** -------------------------------------------------------------------------
*/
#define THUNK_MCI_SENDCOMMAND                0x0001
#define THUNK_MCI_SENDSTRING                 0x0002
#define THUNK_MCI_GETDEVICEID                0x0003
#define THUNK_MCI_GETDEVIDFROMELEMID         0x0004
#define THUNK_MCI_GETERRORSTRING             0x0005
#define THUNK_MCI_EXECUTE                    0x0006
#define THUNK_MCI_SETYIELDPROC               0x0007
#define THUNK_MCI_GETYIELDPROC               0x0008
#define THUNK_MCI_GETCREATORTASK             0x0009
#define THUNK_TIMEGETTIME                    0x000A
#define THUNK_APP_EXIT                       0x000B
#define THUNK_MCI_ALLOCATE_NODE              0x000C
#define THUNK_MCI_FREE_NODE                  0x000D

DWORD WINAPI
mci32Message(
    DWORD dwApi,
    DWORD dwF1,
    DWORD dwF2,
    DWORD dwF3,
    DWORD dwF4
    );

DWORD
WMM32mciSendCommand(
    DWORD dwF1,
    DWORD dwF2,
    DWORD dwF3,
    DWORD dwF4
    );

DWORD
WMM32mciSendString(
    DWORD dwF1,
    DWORD dwF2,
    DWORD dwF3,
    DWORD dwF4
    );

DWORD
WMM32mciGetDeviceID(
    DWORD dwF1
    );

DWORD
WMM32mciGetErrorString(
    DWORD dwF1,
    DWORD dwF2,
    DWORD dwF3
    );

DWORD
WMM32mciExecute(
    DWORD dwF1
    );

DWORD
WMM32mciGetDeviceIDFromElementID(
    DWORD dwF1,
    DWORD dwF2
    );

DWORD
WMM32mciGetCreatorTask(
    DWORD dwF1
    );

DWORD
WMM32mciSetYieldProc(
    DWORD dwF1,
    DWORD dwF2,
    DWORD dwF3
    );

UINT
WMM32mciYieldProc(
    MCIDEVICEID wDeviceID,
    DWORD dwYieldData
    );

DWORD
WMM32mciGetYieldProc(
    DWORD dwF1,
    DWORD dwF2
    );

DWORD
WMM32mciAllocateNode(
    DWORD dwF1,            // dwOpenFlags
    DWORD dwF2             // lpszDeviceName
    );

DWORD
WMM32mciFreeNode(
    DWORD dwF2
    );

#endif


#if defined (_INC_WOW_CONVERSIONS) || defined (_INC_ALL_WOWSTUFF)
/****************************************************************************\
** Other stuff
**
**
\****************************************************************************/
typedef VOID    (APIENTRY *LPCALL_ICA_HW_INTERRUPT)( int, BYTE line, int count );
typedef LPVOID  (APIENTRY *LPGETVDMPOINTER)( DWORD Address, DWORD dwBytes, BOOL fProtectMode );
typedef HANDLE  (APIENTRY *LPWOWHANDLE32)(WORD, WOW_HANDLE_TYPE);
typedef WORD    (APIENTRY *LPWOWHANDLE16)(HANDLE, WOW_HANDLE_TYPE);

#define GETVDMPTR( p ) (LPVOID)((*GetVDMPointer)( (DWORD)(p), 0L, TRUE ))

extern LPCALL_ICA_HW_INTERRUPT GenerateInterrupt;
extern LPGETVDMPOINTER         GetVDMPointer;
extern LPWOWHANDLE32           lpWOWHandle32;
extern LPWOWHANDLE16           lpWOWHandle16;

/* -------------------------------------------------------------------------
** Conversions
** -------------------------------------------------------------------------
*/
typedef HANDLE  HAND32;
typedef WORD    HAND16;
typedef WORD    HWND16;
typedef WORD    HDC16;
typedef WORD    HTASK16;
typedef short   INT16;
typedef WORD    HPAL16;

#define GETHTASK16(h32)            ((HAND16)(INT)(h32))

#define HWND32(h16)                ((HWND)(*lpWOWHandle32)( h16, WOW_TYPE_HWND ))
#define GETHWND16(h32)             ((*lpWOWHandle16)( h32, WOW_TYPE_HWND ))

#define HDC32(hdc16)               ((HDC)(*lpWOWHandle32)( hdc16, WOW_TYPE_HDC ))
#define GETHDC16(hdc32)            ((*lpWOWHandle16)( hdc32, WOW_TYPE_HDC ))

#define HPALETTE32(hobj16)         ((HPALETTE)(*lpWOWHandle32)( hobj16, WOW_TYPE_HPALETTE ))
#define GETHPALETTE16(hobj32)      ((*lpWOWHandle16)( hobj32, WOW_TYPE_HPALETTE ))
#endif



#ifdef _INC_ALL_WOWSTUFF
/* -------------------------------------------------------------------------
** Messages
** -------------------------------------------------------------------------
*/
#ifndef DRVM_INIT
#define DRVM_INIT             100
#define WODM_INIT             DRVM_INIT
#define WIDM_INIT             DRVM_INIT
#define MODM_INIT             DRVM_INIT
#define MIDM_INIT             DRVM_INIT
#define AUXDM_INIT            DRVM_INIT
#endif

#ifndef MAX_TIMER_EVENTS
#define MAX_TIMER_EVENTS 16
#endif

#ifndef TDD_APPEXIT
#define TDD_APPEXIT    DRV_RESERVED+24
#endif

/**********************************************************************\
*
*   The following macros are used to set or clear the done bit in a
*   16 bit wave|midi header structure.
*
\**********************************************************************/
#define COPY_WAVEOUTHDR16_FLAGS( x, y )             \
{                                                   \
    PWAVEHDR16  pWavHdr;                            \
    DWORD       dw;                                 \
                                                    \
    pWavHdr = (x);                                  \
    dw      = (y).dwFlags;                          \
    pWavHdr->dwFlags = dw;                          \
}


#define COPY_MIDIOUTHDR16_FLAGS( x, y )             \
{                                                   \
    PMIDIHDR16  pMidHdr;                            \
    DWORD       dw;                                 \
                                                    \
    pMidHdr = (x);                                  \
    dw      = (y).dwFlags;                          \
    pMidHdr->dwFlags = dw;                          \
}

#define COPY_WAVEINHDR16_FLAGS( x, y )              \
{                                                   \
    PWAVEHDR16  pWavHdr;                            \
    DWORD       dw;                                 \
                                                    \
    pWavHdr = (x);                                  \
    dw      = (y).dwFlags;                          \
    pWavHdr->dwFlags = dw;                          \
    dw   = (y).dwBytesRecorded;                     \
    pWavHdr->dwBytesRecorded = dw;                  \
}


#define COPY_MIDIINHDR16_FLAGS( x, y )              \
{                                                   \
    PMIDIHDR16  pMidHdr;                            \
    DWORD       dw;                                 \
                                                    \
    pMidHdr = (x);                                  \
    dw      = (y).dwFlags;                          \
    pMidHdr->dwFlags = dw;                          \
    dw   = (y).dwBytesRecorded;                     \
    pMidHdr->dwBytesRecorded = dw;                  \
}



/* -------------------------------------------------------------------------
** Define 16-bit mixer stuff
** -------------------------------------------------------------------------
*/

#pragma pack(1)
typedef struct tMIXERCAPS16
{
    WORD            wMid;                   // manufacturer id
    WORD            wPid;                   // product id
    WORD            vDriverVersion;         // version of the driver
    char            szPname[MAXPNAMELEN];   // product name
    DWORD           fdwSupport;             // misc. support bits
    DWORD           cDestinations;          // count of destinations
} MIXERCAPS16;
typedef MIXERCAPS16  UNALIGNED *LPMIXERCAPS16;

typedef struct tMIXERLINE16
{
    DWORD       cbStruct;               // size of MIXERLINE structure
    DWORD       dwDestination;          // zero based destination index
    DWORD       dwSource;               // zero based source index (if source)
    DWORD       dwLineID;               // unique line id for mixer device
    DWORD       fdwLine;                // state/information about line
    DWORD       dwUser;                 // driver specific information
    DWORD       dwComponentType;        // component type line connects to
    DWORD       cChannels;              // number of channels line supports
    DWORD       cConnections;           // number of connections [possible]
    DWORD       cControls;              // number of controls at this line
    char        szShortName[MIXER_SHORT_NAME_CHARS];
    char        szName[MIXER_LONG_NAME_CHARS];
    struct
    {
        DWORD       dwType;                 // MIXERLINE_TARGETTYPE_xxxx
        DWORD       dwDeviceID;             // target device ID of device type
        WORD        wMid;                   // of target device
        WORD        wPid;                   //      "
        WORD        vDriverVersion;         //      "
        char        szPname[MAXPNAMELEN];   //      "
    } Target;
} MIXERLINE16;
typedef MIXERLINE16  UNALIGNED *LPMIXERLINE16;

typedef struct tMIXEROPENDESC16
{
    WORD            hmx;            // handle that will be used
    LPVOID          pReserved0;     // reserved--driver should ignore
    DWORD           dwCallback;     // callback
    DWORD           dwInstance;     // app's private instance information

} MIXEROPENDESC16;
typedef MIXEROPENDESC16 UNALIGNED *LPMIXEROPENDESC16;
#pragma pack()


DWORD CALLBACK
mxd32Message(
    UINT uId,
    UINT uMsg,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    );

void
GetLineInfo(
    LPMIXERLINE16 lpline16,
    LPMIXERLINEA lpline32
    );

void
PutLineInfo(
    LPMIXERLINE16 lpline16,
    LPMIXERLINEA lpline32
    );


/*
** ----------------------------------------------------------------
** General Debugging code
** ----------------------------------------------------------------
*/

#undef dprintf
#undef dprintf1
#undef dprintf2
#undef dprintf3
#undef dprintf4
#undef dprintf5

#if DBG

typedef struct tagMSG_NAME {
    UINT    uMsg;
    LPSTR   lpstrName;
} MSG_NAME;

extern int TraceAux;
extern int TraceJoy;
extern int TraceMidiIn;
extern int TraceMidiOut;
extern int TraceTime;
extern int TraceMix;
extern int TraceWaveOut;
extern int TraceWaveIn;
extern int DebugLevel;


VOID FAR DbgOutput( LPSTR lpstrFormatStr, ... );

#define dprintf( _x_ )                        winmmDbgOut _x_
#define dprintf1( _x_ ) if (DebugLevel >= 1) {winmmDbgOut _x_ ;} else
#define dprintf2( _x_ ) if (DebugLevel >= 2) {winmmDbgOut _x_ ;} else
#define dprintf3( _x_ ) if (DebugLevel >= 3) {winmmDbgOut _x_ ;} else
#define dprintf4( _x_ ) if (DebugLevel >= 4) {winmmDbgOut _x_ ;} else
#define dprintf5( _x_ ) if (DebugLevel >= 5) {winmmDbgOut _x_ ;} else

#define trace_waveout( _x_ ) if (TraceWaveOut)  {winmmDbgOut _x_ ;} else
#define trace_wavein( _x_ )  if (TraceWaveIn)   {winmmDbgOut _x_ ;} else
#define trace_mix( _x_ )     if (TraceMix)      {winmmDbgOut _x_ ;} else
#define trace_midiout( _x_ ) if (TraceMidiOut)  {winmmDbgOut _x_ ;} else
#define trace_midiin( _x_ )  if (TraceMidiIn)   {winmmDbgOut _x_ ;} else
#define trace_aux( _x_ )     if (TraceAux)      {winmmDbgOut _x_ ;} else
#define trace_joy( _x_ )     if (TraceJoy)      {winmmDbgOut _x_ ;} else
#define trace_time( _x_ )    if (TraceTime)     {winmmDbgOut _x_ ;} else

#else

#define dprintf( _x_ )
#define dprintf1( _x_ )
#define dprintf2( _x_ )
#define dprintf3( _x_ )
#define dprintf4( _x_ )
#define dprintf5( _x_ )

#define trace_waveout( _x_ )
#define trace_wavein( _x_ )
#define trace_mix( _x_ )
#define trace_midiout( _x_ )
#define trace_midiin( _x_ )
#define trace_time( _x_ )
#define trace_aux( _x_ )
#define trace_joy( _x_ )

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\mmwowmci.c ===
/******************************Module*Header*******************************\
* Module Name:  mmwowmci.c
*
*  Thunks for the mci api's.
*
*
* Created: 28-09-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993-1998 Microsoft Corporation
\**************************************************************************/
#include "winmmi.h"
#include "mci.h"
#include <digitalv.h>
#include <stdlib.h>

#include "mixer.h"

#define _INC_ALL_WOWSTUFF
#include "mmwow32.h"
#include "mmwowmci.h"
#include "mmwowcb.h"

extern void
WOWAppExit(
    HANDLE hTask
    );

STATICFN void mciFreeDevice(LPMCI_DEVICE_NODE nodeWorking);
STATICFN MCIDEVICEID NEAR mciAllocateNode (
    DWORD dwFlags,
    LPCWSTR lpDeviceName,
    LPMCI_DEVICE_NODE FAR *lpnodeNew);

#ifndef _WIN64

/******************************Public*Routine******************************\
* mci32Message
*
* Entry point for all the mci thunks.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD WINAPI
mci32Message(
    DWORD dwApi,
    DWORD dwF1,
    DWORD dwF2,
    DWORD dwF3,
    DWORD dwF4
    )
{

    DWORD   dwRet;

    switch ( dwApi ) {

    case THUNK_MCI_SENDCOMMAND:
        dwRet = WMM32mciSendCommand( dwF1, dwF2, dwF3, dwF4 );
        break;

    case THUNK_MCI_SENDSTRING:
        dwRet = WMM32mciSendString( dwF1, dwF2, dwF3, dwF4 );
        break;

    case THUNK_MCI_GETDEVICEID:
        dwRet = WMM32mciGetDeviceID( dwF1 );
        break;

    case THUNK_MCI_GETDEVIDFROMELEMID:
        dwRet = WMM32mciGetDeviceIDFromElementID( dwF1, dwF2 );
        break;

    case THUNK_MCI_GETERRORSTRING:
        dwRet = WMM32mciGetErrorString( dwF1, dwF2, dwF3 );
        break;

    case THUNK_MCI_SETYIELDPROC:
        dwRet = WMM32mciSetYieldProc( dwF1, dwF2, dwF3 );
        break;

    case THUNK_MCI_GETYIELDPROC:
        dwRet = WMM32mciGetYieldProc( dwF1, dwF2 );
        break;

    case THUNK_MCI_GETCREATORTASK:
        dwRet = WMM32mciGetCreatorTask( dwF1 );
        break;

    case THUNK_APP_EXIT:
        /*
        ** Now tidy up the other stuff.
        */
        dwRet = 0; //Keep the compiler happy
        WOWAppExit( (HANDLE)GetCurrentThreadId() );
        break;

    case THUNK_MCI_ALLOCATE_NODE:
        dwRet = WMM32mciAllocateNode( dwF1, dwF2 );
        break;

    case THUNK_MCI_FREE_NODE:
        dwRet = WMM32mciFreeNode( dwF1 );
        break;

    }

    return dwRet;
}


/**********************************************************************\
* WMM32mciSendCommand
*
*
* This function sends a command message to the specified MCI device.
*
\**********************************************************************/
DWORD
WMM32mciSendCommand(
    DWORD dwF1,
    DWORD dwF2,
    DWORD dwF3,
    DWORD dwF4
    )
{
    PMCI_GENERIC_PARMS16 lp16OrigParms;
    DWORD       ul;
    DWORD       NewParms[MCI_MAX_PARAM_SLOTS];
    LPWSTR      lpCommand;
    UINT        uTable;


    if ( dwF2 == DRV_CONFIGURE ) {

        typedef struct {
            DWORD   dwDCISize;
            LPCSTR  lpszDCISectionName;
            LPCSTR  lpszDCIAliasName;
        } DRVCONFIGINFO16;
        typedef DRVCONFIGINFO16 UNALIGNED *LPDRVCONFIGINFO16;

        LPDRVCONFIGINFO16   lpdrvConf;

        lpdrvConf = GETVDMPTR(dwF4);

        if (lpdrvConf && (lpdrvConf->dwDCISize == sizeof(DRVCONFIGINFO16))) {

            DRVCONFIGINFO drvConf;
            LPCSTR lpStr1 = lpdrvConf->lpszDCISectionName;
            LPCSTR lpStr2 = lpdrvConf->lpszDCIAliasName;

            drvConf.dwDCISize = sizeof(drvConf);
            drvConf.lpszDCISectionName = AllocUnicodeStr( GETVDMPTR(lpStr1) );

            if (NULL == drvConf.lpszDCISectionName) {
                return MCIERR_OUT_OF_MEMORY;
            }

            drvConf.lpszDCIAliasName = AllocUnicodeStr( GETVDMPTR(lpStr2) );

            if (NULL == lpdrvConf->lpszDCIAliasName) {

                FreeUnicodeStr((LPWSTR)drvConf.lpszDCISectionName);
                return MCIERR_OUT_OF_MEMORY;
            }

            ul = mciSendCommandW( dwF1, dwF2, (DWORD)HWND32(LOWORD(dwF3)),
                                  (DWORD)(LPVOID)&drvConf );

            FreeUnicodeStr( (LPWSTR)drvConf.lpszDCIAliasName );
            FreeUnicodeStr( (LPWSTR)drvConf.lpszDCISectionName );

            return ul;

        }

        return DRVCNF_CANCEL;
    }


    /*
    ** lparam (dwF4) is a 16:16 pointer.  This Requires parameter
    ** translation and probably memory copying, similar to the WM message
    ** thunks.  A whole thunk/unthunk table should be created.
    **
    ** Shouldn't these be FETCHDWORD, FETCHWORD macros?
    ** else MIPS problems ensue
    */
    lpCommand = NULL;
    uTable    = 0;
    lp16OrigParms = GETVDMPTR( dwF4 );

    try {

        ul = ThunkMciCommand16( (MCIDEVICEID)INT32( dwF1 ), (UINT)dwF2,
                                dwF3, lp16OrigParms, NewParms,
                                &lpCommand, &uTable );

        /*
        ** OK so far ?  If not don't bother calling into winmm.
        */
        if ( ul == 0 ) {

            dprintf3(( "About to call mciSendCommand." ));
            ul = (DWORD)mciSendCommandA( (MCIDEVICEID)INT32( dwF1 ),
                                         (UINT)dwF2, dwF3, (DWORD)NewParms );
            dprintf3(( "return code-> %ld", ul ));

            /*
            ** We have to special case the MCI_CLOSE command.  MCI_CLOSE usually
            ** causes the device to become unloaded.  This means that lpCommand
            ** now points to invalid memory.  We can fix this by setting
            ** lpCommand to NULL.
            */
            if ( dwF2 == MCI_CLOSE ) {
                lpCommand = NULL;
            }

            UnThunkMciCommand16( (MCIDEVICEID)INT32( dwF1 ), UINT32( dwF2 ),
                                 DWORD32( dwF3 ), lp16OrigParms,
                                 NewParms, lpCommand, uTable );
            /*
            ** Print a blank line so that I can distinguish the commands on the
            ** debugger.  This is only necessary if the debug level is >= 3.
            */
            dprintf3(( " " ));
#if DBG
            if ( DebugLevel >= 6 ) DebugBreak();
#endif

        }

    } except( GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION
                                        ? EXCEPTION_EXECUTE_HANDLER
                                        : EXCEPTION_CONTINUE_SEARCH ) {

        dprintf(( "UNKOWN access violation processing 0x%X command",
                  UINT32(dwF2) ));

    }

    return ul;
}

/**********************************************************************\
*
* WMM32mciSendString
*
* This function sends a command string to an MCI device. The device that the
* command is sent to is specified in the command string.
*
\**********************************************************************/
DWORD
WMM32mciSendString(
    DWORD dwF1,
    DWORD dwF2,
    DWORD dwF3,
    DWORD dwF4
    )
{

    //
    // The use of volatile here is to bypass a bug with the intel
    // compiler.
    //
#   define   MAX_MCI_CMD_LEN  256

    volatile ULONG              ul = MMSYSERR_INVALPARAM;
             PSZ                pszCommand;
             PSZ                pszReturnString = NULL;
             UINT               uSize;
             CHAR               szCopyCmd[MAX_MCI_CMD_LEN];


    /*
    ** Test against a NULL pointer for the command name.
    */
    pszCommand = GETVDMPTR(dwF1);
    if ( pszCommand ) {

#       define MAP_INTEGER     0
#       define MAP_HWND        1
#       define MAP_HPALETTE    2

        int     MapReturn = MAP_INTEGER;
        WORD    wMappedHandle;
        char    *psz;

        /*
        ** make a copy of the command string and then force it to
        ** all lower case.  Then scan the string looking for the word
        ** "status".  If we find it scan the string again looking for the
        ** word "handle", if we find it scan the the string again looking
        ** for palette or window.  Then set a flag to remind us to convert
        ** the handle back from 32 to 16 bits.
        */
        strncpy( szCopyCmd, pszCommand, MAX_MCI_CMD_LEN );
        szCopyCmd[ MAX_MCI_CMD_LEN - 1 ] = '\0';
        CharLowerBuff( szCopyCmd, MAX_MCI_CMD_LEN );

        /*
        ** Skip past any white space ie. " \t\r\n"
        ** If the next 6 characters after any white space are not
        ** "status" don't bother with any other tests.
        */
        psz = szCopyCmd + strspn( szCopyCmd, " \t\r\n" );
        if ( strncmp( psz, "status", 6 ) == 0 ) {

            if ( strstr( psz, "handle" ) ) {

                if ( strstr( psz, "window" ) ) {
                    MapReturn = MAP_HWND;
                }
                else if ( strstr( psz, "palette" ) ) {
                    MapReturn = MAP_HPALETTE;
                }
            }
        }

        /*
        ** Test against a zero length string and a NULL pointer
        */
        uSize = (UINT)dwF3;
        if( uSize != 0 ) {

            MMGETOPTPTR(dwF2, uSize, pszReturnString);

            if ( pszReturnString == NULL ) {
                uSize = 0;
            }
        }

        dprintf3(( "wow32: mciSendString -> %s", pszCommand ));

        ul = (DWORD)mciSendStringA( pszCommand, pszReturnString, uSize,
                                    HWND32(LOWORD(dwF4)) );

#if DBG
        if ( pszReturnString && *pszReturnString ) {
            dprintf3(( "wow32: mciSendString return -> %s", pszReturnString ));
        }
#endif

        if ( pszReturnString && *pszReturnString ) {

            switch ( MapReturn ) {

            case MAP_HWND:
                MapReturn = atoi( pszReturnString );
                wMappedHandle = (WORD)GETHWND16( (HWND)MapReturn );
                wsprintf( pszReturnString, "%d", wMappedHandle );
                dprintf2(( "Mapped 32 bit Window %s to 16 bit  %u",
                            pszReturnString,
                            wMappedHandle ));
                break;

            case MAP_HPALETTE:
                MapReturn = atoi( pszReturnString );
                dprintf2(( "Mapped 32 bit palette %s", pszReturnString ));
                wMappedHandle = (WORD)GETHPALETTE16( (HPALETTE)MapReturn );
                wsprintf( pszReturnString, "%d", wMappedHandle );
                dprintf2(( "Mapped 32 bit Palette %s to 16 bit  %u",
                            pszReturnString,
                            wMappedHandle ));
                break;
            }
        }

    }

    return ul;

#   undef MAP_INTEGER
#   undef MAP_HWND
#   undef MAP_HPALETTE
#   undef MAX_MCI_CMD_LEN
}

/**********************************************************************\
*
* WMM32mciGetDeviceID
*
* This assumes that the string is incoming, and the ID is returned in the WORD.
*
* This function retrieves the device ID corresponding to the name of an
* open MCI device.
*
\**********************************************************************/
DWORD
WMM32mciGetDeviceID(
    DWORD dwF1
    )
{
    DWORD ul = 0L;
    PSZ pszName;


    /*
    ** Test against a NULL pointer for the device name.
    */
    pszName = GETVDMPTR(dwF1);
    if ( pszName ) {

        ul = mciGetDeviceIDA( pszName );
    }

    return ul;
}

/**********************************************************************\
*
* WMM32mciGetErrorString
*
* This function returns a textual description of the specified MCI error.
*
\**********************************************************************/
DWORD
WMM32mciGetErrorString(
    DWORD dwF1,
    DWORD dwF2,
    DWORD dwF3
    )
{
    PSZ pszBuffer;
    DWORD ul = 0;


    /*
    ** Test against a zero length string and a NULL pointer
    */
    MMGETOPTPTR( dwF2, dwF3, pszBuffer);
    if ( pszBuffer ) {

        ul = (DWORD)mciGetErrorStringA( dwF1, pszBuffer, (UINT)dwF3 );
    }

    return ul;
}

#if 0
/**********************************************************************\
*
* WMM32mciExecute
*
* This function is a simplified version of the mciSendString function. It does
* not take a buffer for return information, and it displays a message box when
* errors occur.
*
* THIS FUNCTION SHOULD NOT BE USED - IT IS RETAINED ONLY FOR BACKWARD
* COMPATABILITY WITH WIN 3.0 APPS - USE mciSendString INSTEAD...
*
\**********************************************************************/
DWORD
WMM32mciExecute(
    DWORD dwF1
    )
{
    DWORD ul = 0;
    PSZ pszCommand;


    /*
    ** Test against a NULL pointer for the command string.
    */
    pszCommand = GETVDMPTR(dwF1);
    if ( pszCommand ) {

        ul = (DWORD)mciExecute( pszCommand );
    }

    return ul;
}
#endif

/**********************************************************************\
*
* WMM32mciGetDeviceIDFromElementID
*
* This function - um, yes, well...
*
* It appears in the headers but not in the book...
*
\**********************************************************************/
DWORD
WMM32mciGetDeviceIDFromElementID(
    DWORD dwF1,
    DWORD dwF2
    )
{
    ULONG ul = 0;
    PSZ pszDeviceID;


    /*
    ** Test against a NULL pointer for the device name.
    */
    pszDeviceID = GETVDMPTR(dwF2);
    if ( pszDeviceID ) {

        ul = (DWORD)mciGetDeviceIDFromElementIDA( dwF1, pszDeviceID );

    }
    return ul;
}

/**********************************************************************\
*
* WMM32mciGetCreatorTask
*
* This function - um again. Ditto for book and headers also.
*
\**********************************************************************/
DWORD
WMM32mciGetCreatorTask(
    DWORD dwF1
    )
{
    ULONG ul;

    ul = GETHTASK16( mciGetCreatorTask( (MCIDEVICEID)INT32(dwF1) ));

    return ul;
}


/**********************************************************************\
*
* WMM32mciSetYieldProc
*
*
\**********************************************************************/
DWORD
WMM32mciSetYieldProc(
    DWORD dwF1,
    DWORD dwF2,
    DWORD dwF3
    )
{
    ULONG              ul;
    YIELDPROC          YieldProc32;
    INSTANCEDATA      *lpYieldProcInfo;
    DWORD              dwYieldData = 0;

    /*
    ** We may have already set a YieldProc for this device ID.  If so we
    ** have to free the INSTANCEDATA structure here.  mciGetYieldProc
    ** returns NULL is no YieldProc was specified.
    */
    YieldProc32 = (YIELDPROC)mciGetYieldProc( (MCIDEVICEID)INT32(dwF1),
                                               &dwYieldData );

    if ( (YieldProc32 == WMM32mciYieldProc) && (dwYieldData != 0) ) {
        winmmFree( (INSTANCEDATA *)dwYieldData );
    }

    if ( dwF2 == 0 ) {
        YieldProc32 = NULL;
        dwYieldData = 0;
    }
    else {
        /*
        ** Allocate some storage for a INSTANCEDATA structure and save
        ** the passed 16 bit parameters.  This storage get freed when the
        ** application calls mciSetYieldProc with a NULL YieldProc.
        */
        lpYieldProcInfo = winmmAlloc( sizeof(INSTANCEDATA) );
        if ( lpYieldProcInfo == NULL ) {
            ul = (ULONG)MMSYSERR_NOMEM;
            goto exit_app;
        }

        dwYieldData = (DWORD)lpYieldProcInfo;
        YieldProc32 = WMM32mciYieldProc;

        lpYieldProcInfo->dwCallback         = dwF2;
        lpYieldProcInfo->dwCallbackInstance = dwF3;
    }

    ul = (DWORD)mciSetYieldProc( (MCIDEVICEID)INT32(dwF1),
                                 YieldProc32, dwYieldData );
    /*
    ** If the call failed free the storage here.
    */
    if ( ul == FALSE ) {
        winmmFree( (INSTANCEDATA *)dwYieldData );
    }

exit_app:
    return ul;
}


/**********************************************************************\
*
* WMM32mciYieldProc
*
* Here we call the real 16 bit YieldProc.  This function assumes that
* we yield on the wow thread.  If this is not the case we get instant
* death inside CallBack16.
*
* 12th Jan 1993 - The bad news is that the mci yield proc is NOT always
* called back on the thread that set it.  This means that we cannot callback
* into the 16bit code because the calling thread does not have a 16bit
* stack.
*
\**********************************************************************/
UINT
WMM32mciYieldProc(
    MCIDEVICEID wDeviceID,
    DWORD dwYieldData
    )
{
    wDeviceID   = (MCIDEVICEID)0;
    dwYieldData = 0;
    return 0;
}


/**********************************************************************\
*
* WMM32mciGetYieldProc
*
*
\**********************************************************************/
DWORD
WMM32mciGetYieldProc(
    DWORD dwF1,
    DWORD dwF2
    )
{
    ULONG ul = 0;
    YIELDPROC YieldProc32;
    DWORD dwYieldData = 0;
    DWORD UNALIGNED *pdw1;

    /*
    ** Get the address of the 32 bit yield proc.
    */
    YieldProc32 = (YIELDPROC)mciGetYieldProc( (MCIDEVICEID)INT32(dwF1),
                                              &dwYieldData );

    /*
    ** Did we set it ?  If so it must point to WMM32mciYieldProc.
    */
    if ( ((YieldProc32 == WMM32mciYieldProc) && (dwYieldData != 0)) ) {

        ul = ((INSTANCEDATA *)dwYieldData)->dwCallback;

        pdw1 = GETVDMPTR( dwF2 );
        *pdw1 = ((INSTANCEDATA *)dwYieldData)->dwCallbackInstance;
    }

    return ul;
}



/**********************************************************************\
*
* WMM32mciAllocateNode
*
*
\**********************************************************************/
DWORD
WMM32mciAllocateNode(
    DWORD dwF1,            // dwOpenFlags
    DWORD dwF2             // lpszDeviceName
    )
{
    LPMCI_DEVICE_NODE lpNode32;
    LPWSTR lpDeviceName32;
    ULONG ul = 0;

    // Thunk 16-bit params and allocate a 32-bit device node 
    if ((lpDeviceName32 = AllocUnicodeStr(GETVDMPTR(dwF2))) != NULL) {
        if ((ul = mciAllocateNode(dwF1, lpDeviceName32, &lpNode32)) != 0) {
            // Mark this device as 16-bit
            lpNode32->dwMCIFlags |= MCINODE_16BIT_DRIVER;
        }
        FreeUnicodeStr(lpDeviceName32);
    }
    return ul;
}

/**********************************************************************\
*
* WMM32mciFreeNode
*
*
\**********************************************************************/
DWORD
WMM32mciFreeNode(
    DWORD dwF2
    )
{
    LPMCI_DEVICE_NODE lpNode32;

    if ((lpNode32 = MCI_lpDeviceList[dwF2]) != NULL) {
        mciFreeDevice(lpNode32);
    }

    return 0;
}

#if DBG

MCI_MESSAGE_NAMES  mciMessageNames[32] = {
    { MCI_OPEN,         "MCI_OPEN" },
    { MCI_CLOSE,        "MCI_CLOSE" },
    { MCI_ESCAPE,       "MCI_ESCAPE" },
    { MCI_PLAY,         "MCI_PLAY" },
    { MCI_SEEK,         "MCI_SEEK" },
    { MCI_STOP,         "MCI_STOP" },
    { MCI_PAUSE,        "MCI_PAUSE" },
    { MCI_INFO,         "MCI_INFO" },
    { MCI_GETDEVCAPS,   "MCI_GETDEVCAPS" },
    { MCI_SPIN,         "MCI_SPIN" },
    { MCI_SET,          "MCI_SET" },
    { MCI_STEP,         "MCI_STEP" },
    { MCI_RECORD,       "MCI_RECORD" },
    { MCI_SYSINFO,      "MCI_SYSINFO" },
    { MCI_BREAK,        "MCI_BREAK" },
    { MCI_SOUND,        "MCI_SOUND" },
    { MCI_SAVE,         "MCI_SAVE" },
    { MCI_STATUS,       "MCI_STATUS" },
    { MCI_CUE,          "MCI_CUE" },
    { MCI_REALIZE,      "MCI_REALIZE" },
    { MCI_WINDOW,       "MCI_WINDOW" },
    { MCI_PUT,          "MCI_PUT" },
    { MCI_WHERE,        "MCI_WHERE" },
    { MCI_FREEZE,       "MCI_FREEZE" },
    { MCI_UNFREEZE,     "MCI_UNFREEZE" },
    { MCI_LOAD,         "MCI_LOAD" },
    { MCI_CUT,          "MCI_CUT" },
    { MCI_COPY,         "MCI_COPY" },
    { MCI_PASTE,        "MCI_PASTE" },
    { MCI_UPDATE,       "MCI_UPDATE" },
    { MCI_RESUME,       "MCI_RESUME" },
    { MCI_DELETE,       "MCI_DELETE" }
};
#endif

/**********************************************************************\
*
* ThunkMciCommand16
*
* This function converts a 16 bit mci command request into an
* equiverlant 32 bit request.
*
* The ideas behind this function were stolen from ThunkWMMsg16,
* see wmsg16.c and mciDebugOut see mci.c
*
* We return 0 if the thunk was OK, any other value should be used as
* an error code.  If the thunk failed all allocated resources will
* be freed by this function.  If the thunk was sucessful (ie. returned 0)
* UnThunkMciCommand16 MUST be called to free allocated resources.
*
* Here are the assumptions that I have used to perform the thunking:
*
* 1. MCI_OPEN is a special case.
*
* 2. If the message is NOT defined in mmsystem.h then it is treated as a
*    "user" command.  If a user command table is associated with the given
*    device ID we use this command table as an aid to perform the thunking.
*    If a user command table is NOT associated with the device ID the
*    command does NOT GET THUNKED, we return straight away, calling
*    mciSendCommand only to get a relevant error code.
*
* 3. If the command IS defined in mmsystem.h we perfrom a "manual" thunk
*    of the command IF the associated PARMS structure contains ReservedX
*    fields.  We mask out the associated flags as each field is thunked.
*
* 4. If there are any flags left then we use the command table
*    as an aid to perform the thunking.
*
\**********************************************************************/
DWORD
ThunkMciCommand16(
    MCIDEVICEID DeviceID,
    UINT OrigCommand,
    DWORD OrigFlags,
    PMCI_GENERIC_PARMS16 lp16OrigParms,
    PDWORD pNewParms,
    LPWSTR *lplpCommand,
    PUINT puTable
    )
{
#if DBG
    register    int             i;
                int             n;

    dprintf3(( "ThunkMciCommand16 :" ));
    dprintf5(( " OrigDevice -> %lX", DeviceID ));

    n = sizeof(mciMessageNames) / sizeof(MCI_MESSAGE_NAMES);
    for ( i = 0; i < n; i++ ) {
        if ( mciMessageNames[i].uMsg == OrigCommand ) {
            break;
        }
    }
    dprintf3(( "OrigCommand  -> 0x%lX", (DWORD)OrigCommand ));

    //
    // Special case MCI_STATUS.  I get loads of these from mplayer.
    // I only want to display MCI_STATUS messages if the debug level is
    // set to level 3, that way I won't get swamped with them.
    //
    if ( mciMessageNames[i].uMsg != MCI_STATUS ) {
        if ( i != n ) {
            dprintf2(( "Command Name -> %s", mciMessageNames[i].lpstMsgName ));
        }
        else {
            dprintf2(( "Command Name -> UNKNOWN COMMAND (%x)", OrigCommand ));
        }
    }
    else {
        dprintf3(( "Command Name -> MCI_STATUS" ));
    }

    dprintf5(( "OrigFlags    -> 0x%lX", OrigFlags ));
    dprintf5(( "OrigParms    -> 0x%lX", lp16OrigParms ));
#endif

    //
    // Thunk the generic params.  These are common to all mci devices.
    //
    ThunkGenericParms( &OrigFlags, lp16OrigParms,
                       (PMCI_GENERIC_PARMS)pNewParms );

    //
    // We thunk the MCI_OPEN command and all other commands that contain a
    // "ReservedX" field in their PARMS structure here.  We mask out each
    // flag as it is processed, if any flags are left we use the command
    // table to complete the thunk.
    //
    // The following commands have ReservedX fields:
    //      MCI_WINDOW
    //      MCI_SET
    //
    // This means that MOST COMMANDS GET THUNKED VIA THE COMMAND TABLE.
    //
    switch ( OrigCommand ) {

        case MCI_OPEN:
            //
            // MCI_OPEN is a special case message that I don't
            // how to deal with yet.
            //
            ThunkOpenCmd( &OrigFlags, (PMCI_OPEN_PARMS16)lp16OrigParms,
                          (PMCI_OPEN_PARMS)pNewParms );
            return 0;

            //
            // The next four commands have Reserved padding fields
            // these have to thunked manually.
            //

        case MCI_SET:
            ThunkSetCmd( DeviceID, &OrigFlags,
                         (PMCI_SET_PARMS16)lp16OrigParms,
                         (PMCI_SET_PARMS)pNewParms );
            break;

        case MCI_WINDOW:
            ThunkWindowCmd( DeviceID, &OrigFlags,
                            (PMCI_ANIM_WINDOW_PARMS16)lp16OrigParms,
                            (PMCI_ANIM_WINDOW_PARMS)pNewParms );
            break;

            //
            // Have to special case this command because the command table
            // is not correct.
            //
        case MCI_SETVIDEO:
            ThunkSetVideoCmd( &OrigFlags,
                              (PMCI_DGV_SETVIDEO_PARMS16)lp16OrigParms,
                              (LPMCI_DGV_SETVIDEO_PARMS)pNewParms );
            break;

            //
            // These two commands don't have any command extensions
            // so we return immediately.
            //
        case MCI_SYSINFO:
            ThunkSysInfoCmd( (PMCI_SYSINFO_PARMS16)lp16OrigParms,
                             (PMCI_SYSINFO_PARMS)pNewParms );
            return 0;

        case MCI_BREAK:
            ThunkBreakCmd( &OrigFlags,
                           (PMCI_BREAK_PARMS16)lp16OrigParms,
                           (PMCI_BREAK_PARMS)pNewParms );
            return 0;
    }

    //
    // Find the command table for the given command ID.
    // We always load the command table this is because the command table is
    // needed for UnThunking.
    //
    *lplpCommand = FindCommandItem( DeviceID, NULL, (LPWSTR)OrigCommand,
                                    NULL, puTable );
    //
    // If the command table is not found we return straight away.
    // Note that storage has been allocated for pNewParms and that the
    // MCI_WAIT and MCI_NOTIFY flags have been thunked.
    // We do not return an error here, but call mciSendCommand to
    // let it determine a suitable error code, we must also call
    // UnthunkMciCommand to free the allocated storage.
    //
    if ( *lplpCommand == NULL ) {
        dprintf(( "Command table not found !!" ));
        return 0;
    }
    dprintf4(( "Command table has been loaded -> 0x%lX", *lplpCommand ));

    //
    // If OrigFlags is not equal to 0 we still have work to do !
    // Note that this will be true for the majority of cases.
    //
    if ( OrigFlags ) {

        dprintf3(( "Thunking via command table" ));

        //
        // Now we thunk the command
        //
        return ThunkCommandViaTable( *lplpCommand, OrigFlags,
                                     (DWORD UNALIGNED *)lp16OrigParms,
                                     (LPBYTE)pNewParms );
    }

    return 0;

}

/*****************************Private*Routine******************************\
* ThunkGenericParms
*
* As we know that the first dword field is a Window handle
* this field is taken care of here.  Also the MCI_WAIT flag is
* masked out if it is set.
*
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
VOID
ThunkGenericParms(
    PDWORD pOrigFlags,
    PMCI_GENERIC_PARMS16 lp16GenParms,
    PMCI_GENERIC_PARMS lp32GenParms
    )
{

    // Look for the notify flag and thunk accordingly
    //
    if ( *pOrigFlags & MCI_NOTIFY ) {

        dprintf4(( "AllocMciParmBlock: Got MCI_NOTIFY flag." ));

        lp32GenParms->dwCallback =
            (DWORD)HWND32( FETCHWORD( lp16GenParms->dwCallback ) );

    }

    *pOrigFlags &= ~(MCI_WAIT | MCI_NOTIFY);
}

/**********************************************************************\
* ThunkOpenCmd
*
* Thunk the Open mci command parms.
\**********************************************************************/
DWORD
ThunkOpenCmd(
    PDWORD pOrigFlags,
    PMCI_OPEN_PARMS16 lp16OpenParms,
    PMCI_OPEN_PARMS p32OpenParms
    )
{
    PMCI_ANIM_OPEN_PARMS    p32OpenAnimParms;
    PMCI_WAVE_OPEN_PARMS    p32OpenWaveParms;

    PMCI_ANIM_OPEN_PARMS16  lpOpenAnimParms16;
    PMCI_WAVE_OPEN_PARMS16  lp16OpenWaveParms;

    //
    // Now scan our way thru all the known MCI_OPEN flags, thunking as
    // necessary.
    //
    // Start at the Device Type field
    //
    if ( *pOrigFlags & MCI_OPEN_TYPE ) {
        if ( *pOrigFlags & MCI_OPEN_TYPE_ID ) {

            dprintf4(( "ThunkOpenCmd: Got MCI_OPEN_TYPE_ID flag." ));

            p32OpenParms->lpstrDeviceType =
                                (LPSTR)lp16OpenParms->lpstrDeviceType;

            dprintf5(( "lpstrDeviceType -> %ld", p32OpenParms->lpstrDeviceType ));

        }
        else {

            dprintf4(( "ThunkOpenCmd: Got MCI_OPEN_TYPE flag" ));

            p32OpenParms->lpstrDeviceType =
                GETVDMPTR( lp16OpenParms->lpstrDeviceType );

            dprintf5(( "lpstrDeviceType -> %s", p32OpenParms->lpstrDeviceType ));
            dprintf5(( "lpstrDeviceType -> 0x%lX", p32OpenParms->lpstrDeviceType ));
        }
    }

    //
    // Now do the Element Name field
    //
    if ( *pOrigFlags & MCI_OPEN_ELEMENT ) {
        if ( *pOrigFlags & MCI_OPEN_ELEMENT_ID ) {

            dprintf4(( "ThunkOpenCmd: Got MCI_OPEN_ELEMENT_ID flag" ));
            p32OpenParms->lpstrElementName =
                (LPSTR)( FETCHDWORD( lp16OpenParms->lpstrElementName ) );
            dprintf5(( "lpstrElementName -> %ld", p32OpenParms->lpstrElementName ));

        }
        else {

            dprintf4(( "ThunkOpenCmd: Got MCI_OPEN_ELEMENT flag" ));
            p32OpenParms->lpstrElementName =
                GETVDMPTR( lp16OpenParms->lpstrElementName );
            dprintf5(( "lpstrElementName -> %s", p32OpenParms->lpstrElementName ));
            dprintf5(( "lpstrElementName -> 0x%lX", p32OpenParms->lpstrElementName ));
        }
    }

    //
    // Now do the Alias Name field
    //
    if ( *pOrigFlags & MCI_OPEN_ALIAS  ) {

        dprintf4(( "ThunkOpenCmd: Got MCI_OPEN_ALIAS flag" ));
        p32OpenParms->lpstrAlias = GETVDMPTR( lp16OpenParms->lpstrAlias );
        dprintf5(( "lpstrAlias -> %s", p32OpenParms->lpstrAlias ));
        dprintf5(( "lpstrAlias -> 0x%lX", p32OpenParms->lpstrAlias ));
    }

    //
    // Clear the MCI_OPEN_SHAREABLE flag if it is set
    //
#if DBG
    if ( *pOrigFlags & MCI_OPEN_SHAREABLE ) {
        dprintf4(( "ThunkOpenCmd: Got MCI_OPEN_SHAREABLE flag." ));
    }
#endif

    *pOrigFlags &= ~(MCI_OPEN_SHAREABLE | MCI_OPEN_ALIAS |
                     MCI_OPEN_ELEMENT | MCI_OPEN_ELEMENT_ID |
                     MCI_OPEN_TYPE | MCI_OPEN_TYPE_ID);

    //
    // If we don't have any extended flags I can return now
    //
    if ( *pOrigFlags == 0 ) {
        return (DWORD)p32OpenParms;
    }

    //
    // If there are any flags left then these are intended for an extended
    // form of MCI open.  Three different forms are known, these being:
    //      MCI_ANIM_OPEN_PARMS
    //      MCI_OVLY_OPEN_PARMS
    //      MCI_WAVE_OPEN_PARMS
    //
    // If I could tell what sort of device I had I could thunk the
    // extensions with no problems, but we don't have a device ID yet
    // so I can't figure out what sort of device I have without parsing
    // the parameters that I already know about.
    //
    // But, I am in luck; MCI_WAVE_OPEN_PARMS has one extended parameter
    // dwBufferSeconds which has a MCI_WAVE_OPEN_BUFFER flag associated with
    // it.  This field is also a DWORD in the other two parms structures.
    //

    if ( *pOrigFlags & MCI_WAVE_OPEN_BUFFER ) {
        //
        // Set up the VDM ptr for lpOpenWaveParms16 to point to OrigParms
        //
        lp16OpenWaveParms = (PMCI_WAVE_OPEN_PARMS16)lp16OpenParms;
        p32OpenWaveParms  = (PMCI_WAVE_OPEN_PARMS)p32OpenParms;

        dprintf4(( "ThunkOpenCmd: Got MCI_WAVE_OPEN_BUFFER flag." ));
        p32OpenWaveParms->dwBufferSeconds =
                FETCHDWORD( lp16OpenWaveParms->dwBufferSeconds );
        dprintf5(( "dwBufferSeconds -> %ld", p32OpenWaveParms->dwBufferSeconds ));
    }


    //
    // Now look for MCI_ANIM_OPEN_PARM and MCI_OVLY_OPEN_PARMS extensions.
    // Set up the VDM ptr for lpOpenAnimParms16 to point to OrigParms
    //
    lpOpenAnimParms16 = (PMCI_ANIM_OPEN_PARMS16)lp16OpenParms;
    p32OpenAnimParms  = (PMCI_ANIM_OPEN_PARMS)p32OpenParms;

    //
    // Check MCI_ANIN_OPEN_PARENT flag, this also checks
    // the MCI_OVLY_OPEN_PARENT flag too.
    //
    if ( *pOrigFlags & MCI_ANIM_OPEN_PARENT ) {

        dprintf4(( "ThunkOpenCmd: Got MCI_Xxxx_OPEN_PARENT flag." ));

        p32OpenAnimParms->hWndParent =
            HWND32(FETCHWORD(lpOpenAnimParms16->hWndParent) );
    }

    //
    // Check MCI_ANIN_OPEN_WS flag, this also checks
    // the MCI_OVLY_OPEN_WS flag too.
    //
    if ( *pOrigFlags & MCI_ANIM_OPEN_WS ) {

        dprintf4(( "ThunkOpenCmd: Got MCI_Xxxx_OPEN_WS flag." ));

        p32OpenAnimParms->dwStyle =
            FETCHDWORD( lpOpenAnimParms16->dwStyle );

        dprintf5(( "dwStyle -> %ld", p32OpenAnimParms->dwStyle ));
    }

#if DBG
    //
    // Check the MCI_ANIN_OPEN_NOSTATIC flag
    //
    if ( *pOrigFlags & MCI_ANIM_OPEN_NOSTATIC ) {
        dprintf4(( "ThunkOpenCmd: Got MCI_ANIM_OPEN_NOSTATIC flag." ));
    }
#endif

    *pOrigFlags &= ~(MCI_ANIM_OPEN_NOSTATIC | MCI_ANIM_OPEN_WS |
                     MCI_ANIM_OPEN_PARENT | MCI_WAVE_OPEN_BUFFER);

    return (DWORD)p32OpenParms;
}

/**********************************************************************\
* ThunkSetCmd
*
* Thunk the ThunkSetCmd mci command parms.
*
* The following are "basic" flags that all devices must support.
*   MCI_SET_AUDIO
*   MCI_SET_DOOR_CLOSED
*   MCI_SET_DOOR_OPEN
*   MCI_SET_TIME_FORMAT
*   MCI_SET_VIDEO
*   MCI_SET_ON
*   MCI_SET_OFF
*
* The following are "extended" flags that "sequencer" devices support.
*   MCI_SEQ_SET_MASTER
*   MCI_SEQ_SET_OFFSET
*   MCI_SEQ_SET_PORT
*   MCI_SEQ_SET_SLAVE
*   MCI_SEQ_SET_TEMPO
*
* The following are "extended" flags that "waveaudio" devices support.
*   MCI_WAVE_INPUT
*   MCI_WAVE_OUTPUT
*   MCI_WAVE_SET_ANYINPUT
*   MCI_WAVE_SET_ANYOUTPUT
*   MCI_WAVE_SET_AVGBYTESPERSEC
*   MCI_WAVE_SET_BITSPERSAMPLES
*   MCI_WAVE_SET_BLOCKALIGN
*   MCI_WAVE_SET_CHANNELS
*   MCI_WAVE_SET_FORMAT_TAG
*   MCI_WAVE_SET_SAMPLESPERSEC
*
\**********************************************************************/
DWORD
ThunkSetCmd(
    MCIDEVICEID DeviceID,
    PDWORD pOrigFlags,
    PMCI_SET_PARMS16 lpSetParms16,
    PMCI_SET_PARMS lpSetParms32
    )
{

    //
    // The following pointers will be used to point to the original
    // 16-bit Parms structure.
    //
    PMCI_WAVE_SET_PARMS16       lpSetWaveParms16;
    PMCI_SEQ_SET_PARMS16        lpSetSeqParms16;

    //
    // The following pointers will be used to point to the new
    // 32-bit Parms structure.
    //
    PMCI_WAVE_SET_PARMS         lpSetWaveParms32;
    PMCI_SEQ_SET_PARMS          lpSetSeqParms32;


    //
    // GetDevCaps is used to determine what sort of device are dealing
    // with.  We need this information to determine if we should use
    // standard, wave or sequencer MCI_SET structure.
    //
    MCI_GETDEVCAPS_PARMS        GetDevCaps;
    DWORD                       dwRetVal;

    //
    // First do the fields that are common to all devices.  Thunk the
    // dwAudio field.
    //
    if ( *pOrigFlags & MCI_SET_AUDIO ) {

        dprintf4(( "ThunkSetCmd: Got MCI_SET_AUDIO flag." ));
        lpSetParms32->dwAudio = FETCHDWORD( lpSetParms16->dwAudio );
        dprintf5(( "dwAudio -> %ld", lpSetParms32->dwAudio ));
    }

    //
    // Thunk the dwTimeFormat field.
    //
    if ( *pOrigFlags & MCI_SET_TIME_FORMAT ) {

        dprintf4(( "ThunkSetCmd: Got MCI_SET_TIME_FORMAT flag." ));
        lpSetParms32->dwTimeFormat = FETCHDWORD( lpSetParms16->dwTimeFormat );
        dprintf5(( "dwTimeFormat -> %ld", lpSetParms32->dwTimeFormat ));
    }

#if DBG
    //
    // Mask out the MCI_SET_DOOR_CLOSED
    //
    if ( *pOrigFlags & MCI_SET_DOOR_CLOSED ) {
        dprintf4(( "ThunkSetCmd: Got MCI_SET_DOOR_CLOSED flag." ));
    }

    //
    // Mask out the MCI_SET_DOOR_OPEN
    //
    if ( *pOrigFlags & MCI_SET_DOOR_OPEN ) {
        dprintf4(( "ThunkSetCmd: Got MCI_SET_DOOR_OPEN flag." ));
    }

    //
    // Mask out the MCI_SET_VIDEO
    //
    if ( *pOrigFlags & MCI_SET_VIDEO ) {
        dprintf4(( "ThunkSetCmd: Got MCI_SET_VIDEO flag." ));
    }

    //
    // Mask out the MCI_SET_ON
    //
    if ( *pOrigFlags & MCI_SET_ON ) {
        dprintf4(( "ThunkSetCmd: Got MCI_SET_ON flag." ));
    }

    //
    // Mask out the MCI_SET_OFF
    //
    if ( *pOrigFlags & MCI_SET_OFF ) {
        dprintf4(( "ThunkSetCmd: Got MCI_SET_OFF flag." ));
    }
#endif

    *pOrigFlags &= ~(MCI_SET_AUDIO | MCI_SET_TIME_FORMAT |
                     MCI_SET_OFF | MCI_SET_ON | MCI_SET_VIDEO |
                     MCI_SET_DOOR_OPEN | MCI_SET_DOOR_CLOSED |
                     MCI_SET_AUDIO | MCI_SET_TIME_FORMAT );

    //
    // We have done all the standard flags.  If there are any flags
    // still set we must have an extended command.
    //
    if ( *pOrigFlags == 0 ) {
        return (DWORD)lpSetParms32;
    }

    //
    // Now we need to determine what type of device we are
    // dealing with.  We can do this by send an MCI_GETDEVCAPS
    // command to the device. (We might as well use the Unicode
    // version of mciSendCommand and avoid another thunk).
    //
    ZeroMemory( &GetDevCaps, sizeof(MCI_GETDEVCAPS_PARMS) );
    GetDevCaps.dwItem = MCI_GETDEVCAPS_DEVICE_TYPE;
    dwRetVal = mciSendCommandW( DeviceID, MCI_GETDEVCAPS, MCI_GETDEVCAPS_ITEM,
                                 (DWORD)&GetDevCaps );

    //
    // What do we do if dwRetCode is not equal to 0 ?  If this is the
    // case it probably means that we have been given a duff device ID,
    // anyway it is pointless to carry on with the thunk so I will clear
    // the *pOrigFlags variable and return.  This means that the 32 bit version
    // of mciSendCommand will get called with only half the message thunked,
    // but as there is probably already a problem with the device or
    // the device ID is duff, mciSendCommand should be able to work out a
    // suitable error code to return to the application.
    //
    if ( dwRetVal ) {
        *pOrigFlags = 0;
        return (DWORD)lpSetParms32;
    }

    switch ( GetDevCaps.dwReturn ) {

    case MCI_DEVTYPE_WAVEFORM_AUDIO:

        //
        // Set up the VDM ptr for lpSetWaveParms16 to point to OrigParms
        //
        dprintf3(( "ThunkSetCmd: Got a WaveAudio device." ));
        lpSetWaveParms16 = (PMCI_WAVE_SET_PARMS16)lpSetParms16;
        lpSetWaveParms32 = (PMCI_WAVE_SET_PARMS)lpSetParms32;

        //
        // Thunk the wInput field.
        //
        if ( *pOrigFlags & MCI_WAVE_INPUT ) {

            dprintf4(( "ThunkSetCmd: Got MCI_WAVE_INPUT flag." ));
            lpSetWaveParms32->wInput = FETCHWORD( lpSetWaveParms16->wInput );
            dprintf5(( "wInput -> %u", lpSetWaveParms32->wInput ));
        }

        //
        // Thunk the wOutput field.
        //
        if ( *pOrigFlags & MCI_WAVE_OUTPUT ) {

            dprintf4(( "ThunkSetCmd: Got MCI_WAVE_OUTPUT flag." ));
            lpSetWaveParms32->wOutput = FETCHWORD( lpSetWaveParms16->wOutput );
            dprintf5(( "wOutput -> %u", lpSetWaveParms32->wOutput ));
        }

        //
        // Thunk the wFormatTag field.
        //
        if ( *pOrigFlags & MCI_WAVE_SET_FORMATTAG ) {

            dprintf4(( "ThunkSetCmd: Got MCI_WAVE_SET_FORMATTAG flag." ));
            lpSetWaveParms32->wFormatTag =
                FETCHWORD( lpSetWaveParms16->wFormatTag );
            dprintf5(( "wFormatTag -> %u", lpSetWaveParms32->wFormatTag ));
        }

        //
        // Thunk the nChannels field.
        //
        if ( *pOrigFlags & MCI_WAVE_SET_CHANNELS ) {

            dprintf4(( "ThunkSetCmd: Got MCI_WAVE_SET_CHANNELS flag." ));
            lpSetWaveParms32->nChannels =
                FETCHWORD( lpSetWaveParms16->nChannels );
            dprintf5(( "nChannels -> %u", lpSetWaveParms32->nChannels ));
        }

        //
        // Thunk the nSamplesPerSec field.
        //
        if ( *pOrigFlags & MCI_WAVE_SET_SAMPLESPERSEC ) {

            dprintf4(( "ThunkSetCmd: Got MCI_WAVE_SET_SAMPLESPERSEC flag." ));
            lpSetWaveParms32->nSamplesPerSec =
                FETCHDWORD( lpSetWaveParms16->nSamplesPerSecond );
            dprintf5(( "nSamplesPerSec -> %u", lpSetWaveParms32->nSamplesPerSec ));
        }

        //
        // Thunk the nAvgBytesPerSec field.
        //
        if ( *pOrigFlags & MCI_WAVE_SET_AVGBYTESPERSEC ) {

            dprintf4(( "ThunkSetCmd: Got MCI_WAVE_SET_AVGBYTESPERSEC flag." ));
            lpSetWaveParms32->nAvgBytesPerSec =
                FETCHDWORD( lpSetWaveParms16->nAvgBytesPerSec );
            dprintf5(( "nAvgBytesPerSec -> %u", lpSetWaveParms32->nAvgBytesPerSec ));
        }

        //
        // Thunk the nBlockAlign field.
        //
        if ( *pOrigFlags & MCI_WAVE_SET_BLOCKALIGN ) {

            dprintf4(( "ThunkSetCmd: Got MCI_WAVE_SET_BLOCKALIGN flag." ));
            lpSetWaveParms32->nBlockAlign =
                FETCHWORD( lpSetWaveParms16->nBlockAlign );
            dprintf5(( "nBlockAlign -> %u", lpSetWaveParms32->nBlockAlign ));
        }

        //
        // Thunk the nBitsPerSample field.
        //
        if ( *pOrigFlags & MCI_WAVE_SET_BITSPERSAMPLE ) {
            dprintf4(( "ThunkSetCmd: Got MCI_WAVE_SET_BITSPERSAMPLE flag." ));
            lpSetWaveParms32->wBitsPerSample =
                FETCHWORD( lpSetWaveParms16->wBitsPerSample );
            dprintf5(( "wBitsPerSamples -> %u", lpSetWaveParms32->wBitsPerSample ));
        }

        //
        // Turn off all the flags in one go.
        //
        *pOrigFlags &= ~(MCI_WAVE_INPUT | MCI_WAVE_SET_BITSPERSAMPLE |
                         MCI_WAVE_SET_BLOCKALIGN | MCI_WAVE_SET_AVGBYTESPERSEC |
                         MCI_WAVE_SET_SAMPLESPERSEC | MCI_WAVE_SET_CHANNELS |
                         MCI_WAVE_SET_FORMATTAG | MCI_WAVE_OUTPUT);



        break;

    case MCI_DEVTYPE_SEQUENCER:
        //
        // Set up the VDM ptr for lpSetSeqParms16 to point to OrigParms
        //
        dprintf3(( "ThunkSetCmd: Got a Sequencer device." ));
        lpSetSeqParms16 = (PMCI_SEQ_SET_PARMS16)lpSetParms16;
        lpSetSeqParms32 = (PMCI_SEQ_SET_PARMS)lpSetParms32;

        //
        // Thunk the dwMaster field.
        //
        if ( *pOrigFlags & MCI_SEQ_SET_MASTER ) {

            dprintf4(( "ThunkSetCmd: Got MCI_SEQ_SET_MASTER flag." ));
            lpSetSeqParms32->dwMaster = FETCHDWORD( lpSetSeqParms16->dwMaster );
            dprintf5(( "dwMaster -> %ld", lpSetSeqParms32->dwMaster ));
        }

        //
        // Thunk the dwPort field.
        //
        if ( *pOrigFlags & MCI_SEQ_SET_PORT ) {

            dprintf4(( "ThunkSetCmd: Got MCI_SEQ_SET_PORT flag." ));
            lpSetSeqParms32->dwPort = FETCHDWORD( lpSetSeqParms16->dwPort );
            dprintf5(( "dwPort -> %ld", lpSetSeqParms32->dwPort ));
        }

        //
        // Thunk the dwOffset field.
        //
        if ( *pOrigFlags & MCI_SEQ_SET_OFFSET ) {

            dprintf4(( "ThunkSetCmd: Got MCI_SEQ_SET_OFFSET flag." ));
            lpSetSeqParms32->dwOffset= FETCHDWORD( lpSetSeqParms16->dwOffset );
            dprintf5(( "dwOffset -> %ld", lpSetSeqParms32->dwOffset ));
        }

        //
        // Thunk the dwSlave field.
        //
        if ( *pOrigFlags & MCI_SEQ_SET_SLAVE ) {

            dprintf4(( "ThunkSetCmd: Got MCI_SEQ_SET_SLAVE flag." ));
            lpSetSeqParms32->dwSlave = FETCHDWORD( lpSetSeqParms16->dwSlave );
            dprintf5(( "dwSlave -> %ld", lpSetSeqParms32->dwSlave ));
        }

        //
        // Thunk the dwTempo field.
        //
        if ( *pOrigFlags & MCI_SEQ_SET_TEMPO ) {

            dprintf4(( "ThunkSetCmd: Got MCI_SEQ_SET_TEMPO flag." ));
            lpSetSeqParms32->dwTempo = FETCHDWORD( lpSetSeqParms16->dwTempo );
            dprintf5(( "dwTempo -> %ld", lpSetSeqParms32->dwTempo ));
        }

        //
        // Turn off all the flags in one go.
        //
        *pOrigFlags &= ~(MCI_SEQ_SET_MASTER | MCI_SEQ_SET_PORT |
                         MCI_SEQ_SET_OFFSET | MCI_SEQ_SET_SLAVE |
                         MCI_SEQ_SET_TEMPO);
        break;

    }

    return (DWORD)lpSetParms32;
}

/**********************************************************************\
* ThunkSetVideoCmd
*
* Thunk the SetVideo mci command parms.
*
\**********************************************************************/
DWORD
ThunkSetVideoCmd(
    PDWORD pOrigFlags,
    PMCI_DGV_SETVIDEO_PARMS16 lpSetParms16,
    LPMCI_DGV_SETVIDEO_PARMS lpSetParms32
    )
{

    if ( *pOrigFlags & MCI_DGV_SETVIDEO_ITEM ) {

        dprintf4(( "ThunkSetVideoCmd: Got MCI_DGV_SETVIDEO_ITEM flag." ));
        lpSetParms32->dwItem = FETCHDWORD( lpSetParms16->dwItem );
        dprintf5(( "dwItem -> %ld", lpSetParms32->dwItem ));
    }

    if ( *pOrigFlags & MCI_DGV_SETVIDEO_VALUE ) {

        if ( lpSetParms32->dwItem == MCI_DGV_SETVIDEO_PALHANDLE ) {

            HPAL16  hpal16;

            dprintf4(( "ThunkSetVideoCmd: Got MCI_DGV_SETVIDEO_PALHANDLE." ));

            hpal16 = (HPAL16)LOWORD( FETCHDWORD( lpSetParms16->dwValue ) );
            lpSetParms32->dwValue = (DWORD)HPALETTE32( hpal16 );
            dprintf5(( "\t-> 0x%X", hpal16 ));

        }
        else {

            dprintf4(( "ThunkSetVideoCmd: Got an MCI_INTEGER." ));
            lpSetParms32->dwValue = FETCHDWORD( lpSetParms16->dwValue );
            dprintf5(( "dwValue -> %ld", lpSetParms32->dwValue ));
        }
    }

#if DBG
    //
    // Turn off the MCI_SET_ON FLAG.
    //
    if ( *pOrigFlags & MCI_SET_ON ) {
        dprintf4(( "ThunkSetVideoCmd: Got MCI_SET_ON flag." ));
    }

    //
    // Turn off the MCI_SET_OFF FLAG.
    //
    if ( *pOrigFlags & MCI_SET_OFF ) {
        dprintf4(( "ThunkSetVideoCmd: Got MCI_SET_OFF flag." ));
    }
#endif

    *pOrigFlags &= ~(MCI_DGV_SETVIDEO_ITEM | MCI_DGV_SETVIDEO_VALUE |
                     MCI_SET_ON | MCI_SET_OFF);


    return (DWORD)lpSetParms32;

}


/**********************************************************************\
* ThunkSysInfoCmd
*
* Thunk the SysInfo mci command parms.
\**********************************************************************/
DWORD
ThunkSysInfoCmd(
    PMCI_SYSINFO_PARMS16 lpSysInfo16,
    PMCI_SYSINFO_PARMS lpSysInfo32
    )
{

    //
    // Thunk the dwRetSize, dwNumber and wDeviceType parameters.
    //
    lpSysInfo32->dwRetSize = FETCHDWORD( lpSysInfo16->dwRetSize );
    dprintf5(( "dwRetSize -> %ld", lpSysInfo32->dwRetSize ));

    lpSysInfo32->dwNumber = FETCHDWORD( lpSysInfo16->dwNumber );
    dprintf5(( "dwNumber -> %ld", lpSysInfo32->dwNumber ));

    lpSysInfo32->wDeviceType = (UINT)FETCHWORD( lpSysInfo16->wDeviceType );
    dprintf5(( "wDeviceType -> %ld", lpSysInfo32->wDeviceType ));

    //
    // Thunk lpstrReturn
    //
    if ( lpSysInfo32->dwRetSize > 0 ) {

        lpSysInfo32->lpstrReturn = GETVDMPTR( lpSysInfo16->lpstrReturn );
        dprintf5(( "lpstrReturn -> 0x%lX", lpSysInfo16->lpstrReturn ));
    }
    else {
        dprintf1(( "ThunkSysInfoCmd: lpstrReturn is 0 bytes long !!!" ));

        /* lpstrReturn has been set to NULL by ZeroMemory above */
    }

    return (DWORD)lpSysInfo32;

}

/**********************************************************************\
* ThunkBreakCmd
*
* Thunk the Break mci command parms.
\**********************************************************************/
DWORD
ThunkBreakCmd(
    PDWORD pOrigFlags,
    PMCI_BREAK_PARMS16 lpBreak16,
    PMCI_BREAK_PARMS lpBreak32
    )
{
    //
    // Check for the MCI_BREAK_KEY flag
    //
    if ( *pOrigFlags & MCI_BREAK_KEY ) {
        dprintf4(( "ThunkBreakCmd: Got MCI_BREAK_KEY flag." ));
        lpBreak32->nVirtKey = (int)FETCHWORD( lpBreak16->nVirtKey );
        dprintf5(( "nVirtKey -> %d", lpBreak32->nVirtKey ));
    }

    //
    // Check for the MCI_BREAK_HWND flag
    //
    if ( *pOrigFlags & MCI_BREAK_HWND ) {
        dprintf4(( "ThunkBreakCmd: Got MCI_BREAK_HWND flag." ));
        lpBreak32->hwndBreak = HWND32(FETCHWORD(lpBreak16->hwndBreak));
    }
    return (DWORD)lpBreak32;

}

/**********************************************************************\
* ThunkWindowCmd
*
* Thunk the mci Window command parms.
\**********************************************************************/
DWORD
ThunkWindowCmd(
    MCIDEVICEID DeviceID,
    PDWORD pOrigFlags,
    PMCI_ANIM_WINDOW_PARMS16 lpAniParms16,
    PMCI_ANIM_WINDOW_PARMS lpAniParms32
    )
{
    //
    // GetDevCaps is used to determine what sort of device are dealing
    // with.  We need this information to determine if we should use
    // overlay or animation MCI_WINDOW structure.
    //
    MCI_GETDEVCAPS_PARMS        GetDevCaps;
    DWORD                       dwRetVal;

    //
    // Now we need to determine what type of device we are
    // dealing with.  We can do this by send an MCI_GETDEVCAPS
    // command to the device. (We might as well use the Unicode
    // version of mciSendCommand and avoid another thunk).
    //
    ZeroMemory( &GetDevCaps, sizeof(MCI_GETDEVCAPS_PARMS) );
    GetDevCaps.dwItem = MCI_GETDEVCAPS_DEVICE_TYPE;
    dwRetVal = mciSendCommandW( DeviceID, MCI_GETDEVCAPS, MCI_GETDEVCAPS_ITEM,
                                (DWORD)&GetDevCaps );
    //
    // What do we do if dwRetCode is not equal to 0 ?  If this is the
    // case it probably means that we have been given a duff device ID,
    // anyway it is pointless to carry on with the thunk so I will clear
    // the *pOrigFlags variable and return.  This means that the 32 bit version
    // of mciSendCommand will get called with only half the message thunked,
    // but as there is probably already a problem with the device or
    // the device ID is duff, mciSendCommand should be able to work out a
    // suitable error code to return to the application.
    //
    if ( dwRetVal ) {
        *pOrigFlags = 0;
        return (DWORD)lpAniParms32;
    }

    //
    // Do we have an Animation or Overlay device type ?
    // Because Animation and Overlay have identical flags and
    // parms structures they can share the same code.
    //
    if ( GetDevCaps.dwReturn == MCI_DEVTYPE_ANIMATION
      || GetDevCaps.dwReturn == MCI_DEVTYPE_OVERLAY
      || GetDevCaps.dwReturn == MCI_DEVTYPE_DIGITAL_VIDEO ) {

        //
        // Check for the MCI_ANIM_WINDOW_TEXT
        //
        if ( *pOrigFlags & MCI_ANIM_WINDOW_TEXT ) {

            dprintf4(( "ThunkWindowCmd: Got MCI_Xxxx_WINDOW_TEXT flag." ));

            lpAniParms32->lpstrText = GETVDMPTR( lpAniParms16->lpstrText );

            dprintf5(( "lpstrText -> %s", lpAniParms32->lpstrText ));
            dprintf5(( "lpstrText -> 0x%lX", lpAniParms32->lpstrText ));

        }

        //
        // Check for the MCI_ANIM_WINDOW_HWND flag
        //
        if ( *pOrigFlags & MCI_ANIM_WINDOW_HWND ) {

            dprintf4(( "ThunkWindowCmd: Got MCI_Xxxx_WINDOW_HWND flag." ));
            lpAniParms32->hWnd = HWND32( FETCHWORD( lpAniParms16->hWnd ) );
            dprintf5(( "hWnd -> 0x%lX", lpAniParms32->hWnd ));
        }

        //
        // Check for the MCI_ANIM_WINDOW_STATE flag
        //
        if ( *pOrigFlags & MCI_ANIM_WINDOW_STATE ) {

            dprintf4(( "ThunkWindowCmd: Got MCI_Xxxx_WINDOW_STATE flag." ));
            lpAniParms32->nCmdShow = FETCHWORD( lpAniParms16->nCmdShow );
            dprintf5(( "nCmdShow -> 0x%lX", lpAniParms32->nCmdShow ));
        }

#if DBG
        //
        // Check for the MCI_ANIM_WINDOW_DISABLE_STRETCH flag
        //
        if ( *pOrigFlags & MCI_ANIM_WINDOW_DISABLE_STRETCH ) {
            dprintf4(( "ThunkWindowCmd: Got MCI_Xxxx_WINDOW_DISABLE_STRETCH flag." ));
        }

        //
        // Check for the MCI_ANIM_WINDOW_ENABLE_STRETCH flag
        //
        if ( *pOrigFlags & MCI_ANIM_WINDOW_ENABLE_STRETCH ) {
            dprintf4(( "ThunkWindowCmd: Got MCI_Xxxx_WINDOW_ENABLE_STRETCH flag." ));
        }
#endif

        *pOrigFlags &= ~(MCI_ANIM_WINDOW_TEXT | MCI_ANIM_WINDOW_HWND |
                         MCI_ANIM_WINDOW_STATE |
                         MCI_ANIM_WINDOW_DISABLE_STRETCH |
                         MCI_ANIM_WINDOW_ENABLE_STRETCH );
    }

    return (DWORD)lpAniParms32;
}


/**********************************************************************\
*  ThunkCommandViaTable
*
\**********************************************************************/
int
ThunkCommandViaTable(
    LPWSTR lpCommand,
    DWORD dwFlags,
    DWORD UNALIGNED *pdwOrig16,
    LPBYTE pNewParms
    )
{

#if DBG
    static  LPSTR   f_name = "ThunkCommandViaTable: ";
#endif

    LPWSTR  lpFirstParameter;

    UINT    wID;
    DWORD   dwValue;

    UINT    wOffset16, wOffset1stParm16;
    UINT    wOffset32, wOffset1stParm32;

    UINT    wParamSize;

    DWORD   dwParm16;
    PDWORD  pdwParm32;

    DWORD   dwMask = 1;

    //
    // Calculate the size of this command parameter block in terms
    // of bytes, then get a VDM pointer to the OrigParms.
    //
    dprintf3(( "%s16 bit Parms -> %lX", f_name, pdwOrig16 ));

    //
    // Skip past command entry
    //
    lpCommand = (LPWSTR)((LPBYTE)lpCommand +
                    mciEatCommandEntry( lpCommand, NULL, NULL ));
    //
    // Get the next entry
    //
    lpFirstParameter = lpCommand;

    //
    // Skip past the DWORD return value
    //
    wOffset1stParm32 = wOffset1stParm16 = 4;

    lpCommand = (LPWSTR)((LPBYTE)lpCommand +
                    mciEatCommandEntry( lpCommand, &dwValue, &wID ));
    //
    // If it is a return value, skip it
    //
    if ( wID == MCI_RETURN ) {

        //
        // Look for a string return type, these are a special case.
        //
        if ( dwValue == MCI_STRING ) {

            DWORD   dwStrlen;
            LPSTR   *lplpStr;

            //
            // Get string pointer and length
            //
            dwParm16 = FETCHDWORD(*(LPDWORD)((LPBYTE)pdwOrig16 + 4));
            dwStrlen = FETCHDWORD(*(LPDWORD)((LPBYTE)pdwOrig16 + 8));

            //
            // Copy string pointer
            //
            lplpStr = (LPSTR *)(pNewParms + 4);
            if ( dwStrlen > 0 ) {
                *lplpStr = GETVDMPTR( dwParm16 );
                dprintf5(( "%sReturn string -> 0x%lX", f_name, *lplpStr ));
                dprintf5(( "%sReturn length -> 0x%lX", f_name, dwStrlen ));
            }

            //
            // Copy string length
            //
            pdwParm32 = (LPDWORD)(pNewParms + 8);
            *pdwParm32 = dwStrlen;
        }

        //
        // Adjust the offset of the first parameter.  Remember that RECTS
        // are a different size in 16-bit world.
        //
        wParamSize = mciGetParamSize( dwValue, wID );
        wOffset1stParm16 += (dwValue == MCI_RECT ? sizeof(RECT16) : wParamSize);
        wOffset1stParm32 += wParamSize;

        //
        // Save the new first parameter
        //
        lpFirstParameter = lpCommand;
    }

    //
    // Walk through each flag
    //
    while ( dwMask != 0 ) {

        //
        // Is this bit set?
        //
        if ( (dwFlags & dwMask) != 0 ) {

            wOffset16 = wOffset1stParm16;
            wOffset32 = wOffset1stParm32;
            lpCommand = (LPWSTR)((LPBYTE)lpFirstParameter +
                                         mciEatCommandEntry( lpFirstParameter,
                                                             &dwValue, &wID ));

            //
            // What parameter uses this bit?
            //
            while ( wID != MCI_END_COMMAND && dwValue != dwMask ) {

                wParamSize = mciGetParamSize( dwValue, wID );
                wOffset16 += (wID == MCI_RECT ? sizeof( RECT16 ) : wParamSize);
                wOffset32 += wParamSize;

                if ( wID == MCI_CONSTANT ) {

                    while ( wID != MCI_END_CONSTANT ) {

                        lpCommand = (LPWSTR)((LPBYTE)lpCommand +
                                mciEatCommandEntry( lpCommand, NULL, &wID ));
                    }
                }
                lpCommand = (LPWSTR)((LPBYTE)lpCommand +
                             mciEatCommandEntry( lpCommand, &dwValue, &wID ));
            }

            if ( wID != MCI_END_COMMAND ) {

                //
                // Thunk the argument if there is one.  The argument is at
                // wOffset16 from the start of OrigParms.
                // This offset is in bytes.
                //
                dprintf5(( "%sOffset 16 -> 0x%lX", f_name, wOffset16 ));
                dprintf5(( "%sOffset 32 -> 0x%lX", f_name, wOffset32 ));

                if ( wID != MCI_FLAG ) {
                    dwParm16 = FETCHDWORD(*(LPDWORD)((LPBYTE)pdwOrig16 + wOffset16));
                    pdwParm32 = (LPDWORD)(pNewParms + wOffset32);
                }

                switch ( wID ) {

                    case MCI_STRING:
                        {
                            LPSTR   str16 = (LPSTR)dwParm16;
                            dprintf4(( "%sGot STRING flag -> 0x%lX", f_name, dwMask ));
                            *pdwParm32 = (DWORD)GETVDMPTR( str16 );
                            dprintf5(( "%s\t-> 0x%lX", f_name, *pdwParm32 ));
                            dprintf5(( "%s\t-> %s", f_name, *pdwParm32 ));
                        }
                        break;

                    case MCI_HWND:
                        {
                            HWND16  hwnd16;
                            dprintf4(( "%sGot HWND flag -> 0x%lX", f_name, dwMask ));
                            hwnd16 = (HWND16)LOWORD( dwParm16 );
                            *pdwParm32 = (DWORD)HWND32( hwnd16 );
                            dprintf5(( "\t-> 0x%X", hwnd16 ));
                        }
                        break;

                    case MCI_HPAL:
                        {
                            HPAL16  hpal16;
                            dprintf4(( "%sGot HPAL flag -> 0x%lX", f_name, dwMask ));
                            hpal16 = (HPAL16)LOWORD( dwParm16 );
                            *pdwParm32 = (DWORD)HPALETTE32( hpal16 );
                            dprintf5(( "\t-> 0x%X", hpal16 ));
                        }
                        break;

                    case MCI_HDC:
                        {
                            HDC16   hdc16;
                            dprintf4(( "%sGot HDC flag -> 0x%lX", f_name, dwMask ));
                            hdc16 = (HDC16)LOWORD( dwParm16 );
                            *pdwParm32 = (DWORD)HDC32( hdc16 );
                            dprintf5(( "\t-> 0x%X", hdc16 ));
                        }
                        break;

                    case MCI_RECT:
                        {
                            PRECT16 pRect16 = (PRECT16)((LPBYTE)pdwOrig16 + wOffset16);
                            PRECT   pRect32 = (PRECT)pdwParm32;

                            dprintf4(( "%sGot RECT flag -> 0x%lX", f_name, dwMask ));
                            pRect32->top    = (LONG)pRect16->top;
                            pRect32->bottom = (LONG)pRect16->bottom;
                            pRect32->left   = (LONG)pRect16->left;
                            pRect32->right  = (LONG)pRect16->right;
                        }
                        break;

                    case MCI_CONSTANT:
                    case MCI_INTEGER:
                        dprintf4(( "%sGot INTEGER flag -> 0x%lX", f_name, dwMask ));
                        *pdwParm32 = dwParm16;
                        dprintf5(( "\t-> 0x%lX", dwParm16 ));
                        break;
                }
            }
        }

        //
        // Go to the next flag
        //
        dwMask <<= 1;
    }
    return 0;
}


/**********************************************************************\
*
* UnThunkMciCommand16
*
* This function "unthunks" a 32 bit mci send command request.
*
* The ideas behind this function were stolen from UnThunkWMMsg16,
* see wmsg16.c
*
\**********************************************************************/
int
UnThunkMciCommand16(
    MCIDEVICEID devID,
    UINT OrigCommand,
    DWORD OrigFlags,
    PMCI_GENERIC_PARMS16 lp16GenericParms,
    PDWORD NewParms,
    LPWSTR lpCommand,
    UINT uTable
    )
{
    BOOL        fReturnValNotThunked = FALSE;

#if DBG
    static      LPSTR   f_name = "UnThunkMciCommand16: ";
    register    int     i;
                int     n;

    dprintf3(( "UnThunkMciCommand :" ));
    n = sizeof(mciMessageNames) / sizeof(MCI_MESSAGE_NAMES);
    for ( i = 0; i < n; i++ ) {
        if ( mciMessageNames[i].uMsg == OrigCommand ) {
            break;
        }
    }
    dprintf3(( "OrigCommand -> %lX", (DWORD)OrigCommand ));
    dprintf3(( "       Name -> %s", i != n ? mciMessageNames[i].lpstMsgName : "Unkown Name" ));

    dprintf5(( "  OrigFlags -> %lX", OrigFlags ));
    dprintf5(( "  OrigParms -> %lX", lp16GenericParms ));
    dprintf5(( "   NewParms -> %lX", NewParms ));

    //
    // If NewParms is 0 we shouldn't be here, I haven't got an assert
    // macro, but the following we do the same thing.
    //
    if ( NewParms == 0 ) {
        dprintf(( "%scalled with NewParms == NULL !!", f_name ));
        dprintf(( "Call StephenE NOW !!" ));
        DebugBreak();
    }
#endif

    //
    // We have to do a manual unthunk of MCI_SYSINFO because the
    // command table is not consistent.  As a command table should be
    // available now we can load it and then use it to unthunk MCI_OPEN.
    //
    switch ( OrigCommand ) {

    case MCI_OPEN:
        UnThunkOpenCmd( (PMCI_OPEN_PARMS16)lp16GenericParms,
                        (PMCI_OPEN_PARMS)NewParms );
        break;

    case MCI_SYSINFO:
#if DBG
        UnThunkSysInfoCmd( OrigFlags,
                           (PMCI_SYSINFO_PARMS)NewParms );
#endif
        break;

    case MCI_STATUS:
        UnThunkStatusCmd( devID, OrigFlags,
                          (DWORD UNALIGNED *)lp16GenericParms,
                          (DWORD)NewParms );
        break;

    default:
        fReturnValNotThunked = TRUE;
        break;
    }

    //
    // Do we have a command table ?  It is possible that we have
    // a custom command but we did not find a custom command table, in which
    // case we should just free the pNewParms storage.
    //
    if ( lpCommand != NULL ) {

        //
        // We now parse the custom command table to see if there is a
        // return field in the parms structure.
        //
        dprintf3(( "%sUnthunking via command table", f_name ));
        UnThunkCommandViaTable( lpCommand,
                                (DWORD UNALIGNED *)lp16GenericParms,
                                (DWORD)NewParms, fReturnValNotThunked );

        //
        // Now we have finished with the command table we should unlock it.
        //
        dprintf4(( "%sUnlocking custom command table", f_name ));
        mciUnlockCommandTable( uTable );
    }

    return 0;
}


/**********************************************************************\
* UnThunkOpenCmd
*
* UnThunk the Open mci command parms.
\**********************************************************************/
VOID
UnThunkOpenCmd(
    PMCI_OPEN_PARMS16 lpOpenParms16,
    PMCI_OPEN_PARMS lpOpenParms32
    )
{
    WORD                 wDevice;

    dprintf4(( "Copying Device ID." ));

    wDevice = LOWORD( lpOpenParms32->wDeviceID );
    STOREWORD( lpOpenParms16->wDeviceID, wDevice );

    dprintf5(( "wDeviceID -> %u", wDevice ));

}


#if DBG
/**********************************************************************\
* UnThunkSysInfoCmd
*
* UnThunk the SysInfo mci command parms.
\**********************************************************************/
VOID
UnThunkSysInfoCmd(
    DWORD OrigFlags,
    PMCI_SYSINFO_PARMS lpSysParms
    )
{
    //
    // Had better check that we did actually allocate
    // a pointer.
    //
    if ( lpSysParms->lpstrReturn && lpSysParms->dwRetSize ) {

        if ( !(OrigFlags & MCI_SYSINFO_QUANTITY) ) {
            dprintf5(( "lpstrReturn -> %s", lpSysParms->lpstrReturn ));
        }
        else {
            dprintf5(( "lpstrReturn -> %d", *(LPDWORD)lpSysParms->lpstrReturn ));
        }
    }
}
#endif


/**********************************************************************\
* UnThunkMciStatus
*
* UnThunk the Status mci command parms.
\**********************************************************************/
VOID
UnThunkStatusCmd(
    MCIDEVICEID devID,
    DWORD OrigFlags,
    DWORD UNALIGNED *pdwOrig16,
    DWORD NewParms
    )
{
#if DBG
    static  LPSTR   f_name = "UnThunkStatusCmd: ";
#endif

    MCI_GETDEVCAPS_PARMS        GetDevCaps;
    DWORD                       dwRetVal;
    DWORD                       dwParm16;
    PDWORD                      pdwParm32;
    int                         iReturnType = MCI_INTEGER;

    /*
    ** If the MCI_STATUS_ITEM flag is not specified don't bother
    ** doing any unthunking.
    */
    if ( !(OrigFlags & MCI_STATUS_ITEM) ) {
        return;
    }

    /*
    ** We need to determine what type of device we are
    ** dealing with.  We can do this by send an MCI_GETDEVCAPS
    ** command to the device. (We might as well use the Unicode
    ** version of mciSendCommand and avoid another thunk).
    */
    ZeroMemory( &GetDevCaps, sizeof(MCI_GETDEVCAPS_PARMS) );
    GetDevCaps.dwItem = MCI_GETDEVCAPS_DEVICE_TYPE;
    dwRetVal = mciSendCommandW( devID, MCI_GETDEVCAPS, MCI_GETDEVCAPS_ITEM,
                                (DWORD)&GetDevCaps );
    /*
    ** If we can't get the DevCaps then we are doomed.
    */
    if ( dwRetVal ) {
        dprintf(("%sFailure to get devcaps", f_name));
        return;
    }

    /*
    ** Determine the dwReturn type.
    */
    switch ( GetDevCaps.dwReturn ) {

    case MCI_DEVTYPE_ANIMATION:
        switch ( ((LPDWORD)NewParms)[2] ) {

        case MCI_ANIM_STATUS_HWND:
            iReturnType = MCI_HWND;
            break;

        case MCI_ANIM_STATUS_HPAL:
            iReturnType = MCI_HPAL;
            break;
        }
        break;

    case MCI_DEVTYPE_OVERLAY:
        if ( ((LPDWORD)NewParms)[2] == MCI_OVLY_STATUS_HWND ) {
            iReturnType = MCI_HWND;
        }
        break;

    case MCI_DEVTYPE_DIGITAL_VIDEO:
        switch ( ((LPDWORD)NewParms)[2] ) {

        case MCI_DGV_STATUS_HWND:
            iReturnType = MCI_HWND;
            break;

        case MCI_DGV_STATUS_HPAL:
            iReturnType = MCI_HPAL;
            break;
        }
        break;
    }


    /*
    ** Thunk the dwReturn value according to the required type
    */
    pdwParm32 = (LPDWORD)((LPBYTE)NewParms + 4);

    switch ( iReturnType ) {
    case MCI_HPAL:
        dprintf4(( "%sFound an HPAL return field", f_name ));
        dwParm16 = MAKELONG( GETHPALETTE16( (HPALETTE)*pdwParm32 ), 0 );
        STOREDWORD( *(LPDWORD)((LPBYTE)pdwOrig16 + 4), dwParm16 );
        dprintf5(( "HDC32 -> 0x%lX", *pdwParm32 ));
        dprintf5(( "HDC16 -> 0x%lX", dwParm16 ));
        break;

    case MCI_HWND:
        dprintf4(( "%sFound an HWND return field", f_name ));
        dwParm16 = MAKELONG( GETHWND16( (HWND)*pdwParm32 ), 0 );
        STOREDWORD( *(LPDWORD)((LPBYTE)pdwOrig16 + 4), dwParm16 );
        dprintf5(( "HWND32 -> 0x%lX", *pdwParm32 ));
        dprintf5(( "HWND16 -> 0x%lX", dwParm16 ));
        break;

    case MCI_INTEGER:
        dprintf4(( "%sFound an INTEGER return field", f_name ));
        STOREDWORD( *(LPDWORD)((LPBYTE)pdwOrig16 + 4), *pdwParm32 );
        dprintf5(( "INTEGER -> %ld", *pdwParm32 ));
        break;

    // no default: all possible cases accounted for
    }
}



/**********************************************************************\
*  UnThunkCommandViaTable
*
* Thunks the return field if there is one and then frees and pointers
* that were got via GETVDMPTR or GETVDMPTR.
\**********************************************************************/
int
UnThunkCommandViaTable(
    LPWSTR lpCommand,
    DWORD UNALIGNED *pdwOrig16,
    DWORD pNewParms,
    BOOL fReturnValNotThunked
    )
{

#if DBG
    static  LPSTR   f_name = "UnThunkCommandViaTable: ";
#endif

    LPWSTR          lpFirstParameter;

    UINT            wID;
    DWORD           dwValue;

    UINT            wOffset1stParm32;

    DWORD           dwParm16;
    DWORD           Size;
    PDWORD          pdwParm32;

    DWORD           dwMask = 1;


    //
    // Skip past command entry
    //
    lpCommand = (LPWSTR)((LPBYTE)lpCommand +
                    mciEatCommandEntry( lpCommand, NULL, NULL ));
    //
    // Get the next entry
    //
    lpFirstParameter = lpCommand;

    //
    // Skip past the DWORD return value
    //
    wOffset1stParm32 = 4;

    lpCommand = (LPWSTR)((LPBYTE)lpCommand +
                    mciEatCommandEntry( lpCommand, &dwValue, &wID ));
    //
    // If it is a return value, skip it
    //
    if ( (wID == MCI_RETURN) && (fReturnValNotThunked) ) {

        pdwParm32 = (LPDWORD)((LPBYTE)pNewParms + 4);

        //
        // Look for a string return type, these are a special case.
        //
        switch ( dwValue ) {

#if DBG
        case MCI_STRING:
            dprintf4(( "Found a STRING return field" ));
            //
            // Get string pointer and length
            //
            Size = *(LPDWORD)((LPBYTE)pNewParms + 8);

            //
            // Get the 32 bit string pointer
            //
            if ( Size > 0 ) {

                dprintf4(( "%sFreeing a return STRING pointer", f_name ));
                dprintf5(( "STRING -> %s", (LPSTR)*pdwParm32 ));
            }
            break;
#endif

        case MCI_RECT:
            {
                PRECT   pRect32 = (PRECT)((LPBYTE)pNewParms + 4);
                PRECT16 pRect16 = (PRECT16)((LPBYTE)pdwOrig16 + 4);

                dprintf4(( "%sFound a RECT return field", f_name ));
                pRect16->top    = (SHORT)LOWORD(pRect32->top);
                pRect16->bottom = (SHORT)LOWORD(pRect32->bottom);
                pRect16->left   = (SHORT)LOWORD(pRect32->left);
                pRect16->right  = (SHORT)LOWORD(pRect32->right);
            }
            break;

        case MCI_INTEGER:
            //
            // Get the 32 bit return integer and store it in the
            // 16 bit parameter structure.
            //
            dprintf4(( "%sFound an INTEGER return field", f_name ));
            STOREDWORD( *(LPDWORD)((LPBYTE)pdwOrig16 + 4), *pdwParm32 );
            dprintf5(( "INTEGER -> %ld", *pdwParm32 ));
            break;

        case MCI_HWND:
            dprintf4(( "%sFound an HWND return field", f_name ));
            dwParm16 = MAKELONG( GETHWND16( (HWND)*pdwParm32 ), 0 );
            STOREDWORD( *(LPDWORD)((LPBYTE)pdwOrig16 + 4), dwParm16 );
            dprintf5(( "HWND32 -> 0x%lX", *pdwParm32 ));
            dprintf5(( "HWND16 -> 0x%lX", dwParm16 ));
            break;

        case MCI_HPAL:
            dprintf4(( "%sFound an HPAL return field", f_name ));
            dwParm16 = MAKELONG( GETHPALETTE16( (HPALETTE)*pdwParm32 ), 0 );
            STOREDWORD( *(LPDWORD)((LPBYTE)pdwOrig16 + 4), dwParm16 );
            dprintf5(( "HDC32 -> 0x%lX", *pdwParm32 ));
            dprintf5(( "HDC16 -> 0x%lX", dwParm16 ));
            break;

        case MCI_HDC:
            dprintf4(( "%sFound an HDC return field", f_name ));
            dwParm16 = MAKELONG( GETHDC16( (HDC)*pdwParm32 ), 0 );
            STOREDWORD( *(LPDWORD)((LPBYTE)pdwOrig16 + 4), dwParm16 );
            dprintf5(( "HDC32 -> 0x%lX", *pdwParm32 ));
            dprintf5(( "HDC16 -> 0x%lX", dwParm16 ));
            break;
        }

    }

    return 0;
}

#endif // _WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\mmwowcb.h ===
// Copyright (c) 1993-1997 Microsoft Corporation
/* --------------------------------------------------------------------
** Module       : wowmmcb.h
**
** Description  : Interrupt callback stuff for Multi-Media.
**
** History:     : Created 09-Nov-1992 by StephenE
**
** --------------------------------------------------------------------
*/
#ifndef WOWMMCB_H
#define WOWMMCB_H

/*
** This header file will go through both 16 bit and 32 bit compilers.
** In 16 bit land UNALIGNED is not required, on 32 bit land UNALIGNED
** would have been #defined by the time this file was #included because
** this file is always included after wow32.h.  This means the following
** #define is always a no-op with 16 bit compilers and ignored with
** 32 bit compilers.
*/
#ifndef UNALIGNED
#define UNALIGNED
#endif


/* --------------------------------------------------------------------
**  Hardware Interrupts:
**
**  IRQ:     Interrupt: ICA: Line: Description:
**  -------------------------------------------------------------------
**  IRQ0     0x08       0    0     Timer Tick every 18.2 times per second.
**  IRQ1     0x09       0    1     Keyboard service required.
**  IRQ2     0x0A       0    2     INT from slave 8259A.
**  IRQ8     0x70       1    0         Real time clock service.
**  IRQ9     0x71       1    1         Software redirected to IRQ2.
**  IRQ10    0x72       1    2         Reserved.
**  IRQ11    0x73       1    3         Reserved.
**  IRQ12    0x74       1    4         Reserved.
**  IRQ13    0x75       1    5         Numeric co-processor
**  IRQ14    0x76       1    6         Fixed disk controller
**  IRQ15    0x77       1    7         Reserved.
**  IRQ3     0x0B       0    3     Com2 service request.
**  IRQ4     0x0C       0    4     Com1 service request.
**  IRQ5     0x0D       0    5     Data request from LPT2:
**  IRQ6     0x0E       0    6     Floppy disk service required.
**  IRQ7     0x0F       0    7     Data request from LPT1:
**
** --------------------------------------------------------------------
*/

#define MULTIMEDIA_LINE         2
#define MULTIMEDIA_LINE_98      4
#define MULTIMEDIA_ICA          1
#define MULTIMEDIA_INTERRUPT    0x72
#define MULTIMEDIA_INTERRUPT_98 0x14

#define CALLBACK_ARGS_SIZE      16

typedef struct _CALLBACK_ARGS {   /* cbargs */
    DWORD       dwFlags;        // Flags to identify the type of callback.
    DWORD       dwFunctionAddr; // 16:16 address of the function to be called
    WORD        wHandle;        // The handle or ID of the device
    WORD        wMessage;       // The message to be passed to function
    DWORD       dwInstance;     // User data
    DWORD       dwParam1;       // Device data 1
    DWORD       dwParam2;       // Device data 2
} CALLBACK_ARGS;

typedef struct _CALLBACK_DATA {   /* cbdata */
    WORD            wRecvCount;    // The number of interrupts received
    WORD            wSendCount;    // The number of interrupts sent
    CALLBACK_ARGS   args[CALLBACK_ARGS_SIZE];  // Interrupt arguments
    WORD            wIntsCount;    // The number of interrupts received
} CALLBACK_DATA;

typedef CALLBACK_DATA FAR *VPCALLBACK_DATA;         // 16:16 pointer type
typedef CALLBACK_ARGS FAR *VPCALLBACK_ARGS;         // 16:16 pointer type

typedef CALLBACK_DATA UNALIGNED *PCALLBACK_DATA;    //  0:32 pointer type
typedef CALLBACK_ARGS UNALIGNED *PCALLBACK_ARGS;    //  0:32 pointer type

VOID FAR PASCAL Notify_Callback_Data( VPCALLBACK_DATA vpCallbackData );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\mmwowmci.h ===
/******************************Module*Header*******************************\
* Module Name:
*
*
*
*
* Created: dd-mm-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/


typedef struct _RECT16 {        /* rc16 */
    SHORT   left;
    SHORT   top;
    SHORT   right;
    SHORT   bottom;
} RECT16;
typedef RECT16 UNALIGNED *PRECT16;

typedef struct _MCI_ANIM_OPEN_PARMS16 {
    DWORD   dwCallback;
    WORD    wDeviceID;
    WORD    wReserved0;
    LPCSTR  lpstrDeviceType;
    LPCSTR  lpstrElementName;
    LPCSTR  lpstrAlias;
    DWORD   dwStyle;
    HWND16  hWndParent;    // Keeps consistent, and is equivalent anyway
    WORD    wReserved1;
} MCI_ANIM_OPEN_PARMS16;
typedef MCI_ANIM_OPEN_PARMS16 UNALIGNED *PMCI_ANIM_OPEN_PARMS16;
typedef LPVOID  LPMCI_ANIM_OPEN_PARMS16;

typedef struct _MCI_ANIM_PLAY_PARMS16 {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_ANIM_PLAY_PARMS16;
typedef MCI_ANIM_PLAY_PARMS16 UNALIGNED *PMCI_ANIM_PLAY_PARMS16;
typedef LPVOID  LPMCA_ANIM_PLAY_PARMS16;

typedef struct _MCI_ANIM_RECT_PARMS16 {
    DWORD   dwCallback;
    RECT16  rc;
} MCI_ANIM_RECT_PARMS16;
typedef MCI_ANIM_RECT_PARMS16 UNALIGNED *PMCI_ANIM_RECT_PARMS16;
typedef LPVOID  LPMCI_ANIM_RECT_PARMS16;

typedef struct _MCI_ANIM_STEP_PARMS16 {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_ANIM_STEP_PARMS16;
typedef MCI_ANIM_STEP_PARMS16 UNALIGNED *PMCI_ANIM_STEP_PARMS16;
typedef LPVOID  LPMCI_ANIM_STEP_PARMS16;

typedef struct _MCI_ANIM_UPDATE_PARMS16 {
    DWORD   dwCalback;
    RECT16  rc;
    HDC16   hDC;
} MCI_ANIM_UPDATE_PARMS16;
typedef MCI_ANIM_UPDATE_PARMS16 UNALIGNED *PMCI_ANIM_UPDATE_PARMS16;
typedef LPVOID  LPMCI_ANIM_UPDATE_PARMS16;

typedef struct _MCI_ANIM_WINDOW_PARMS16 {
    DWORD   dwCallabck;
    HWND16  hWnd;
    WORD    wReserved1;
    WORD    nCmdShow;
    WORD    wReserved2;
    LPCSTR  lpstrText;
} MCI_ANIM_WINDOW_PARMS16;
typedef MCI_ANIM_WINDOW_PARMS16 UNALIGNED *PMCI_ANIM_WINDOW_PARMS16;
typedef LPVOID  LPMCI_ANIM_WINDOW_PARMS16;

typedef struct _MCI_BREAK_PARMS16 {
    DWORD  dwCallback;
    INT16  nVirtKey;
    WORD   wReserved0;
    HWND16 hwndBreak;
    WORD   wReserved1;
} MCI_BREAK_PARMS16;
typedef MCI_BREAK_PARMS16 UNALIGNED *PMCI_BREAK_PARMS16;
typedef LPVOID  LPMCI_BREAK_PARMS16;

typedef struct _MCI_GENERIC_PARMS16 {
    DWORD   dwCallback;
} MCI_GENERIC_PARMS16;
typedef MCI_GENERIC_PARMS16 UNALIGNED *PMCI_GENERIC_PARMS16;
typedef LPVOID  LPMCI_GENERIC_PARMS16;

typedef struct _MCI_GETDEVCAPS_PARMS16 {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
} MCI_GETDEVCAPS_PARMS16;
typedef MCI_GETDEVCAPS_PARMS16 UNALIGNED *PMCI_GETDEVCAPS_PARMS16;
typedef LPVOID  LPMCI_GETDEVCAPS_PARMS16;

typedef struct _MCI_INFO_PARMS16 {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMS16;
typedef MCI_INFO_PARMS16 UNALIGNED *PMCI_INFO_PARMS16;
typedef LPVOID  LPMCI_INFO_PARMS16;

typedef struct _MCI_LOAD_PARMS16 {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
} MCI_LOAD_PARMS16;
typedef MCI_LOAD_PARMS16 UNALIGNED *PMCI_LOAD_PARMS16;
typedef LPVOID  LPMCI_LOAD_PARMS16;

typedef struct _MCI_OPEN_PARMS16 {
    DWORD   dwCallback;
    WORD    wDeviceID;
    WORD    wReserved0;
    LPCSTR  lpstrDeviceType;
    LPCSTR  lpstrElementName;
    LPCSTR  lpstrAlias;
} MCI_OPEN_PARMS16;
typedef MCI_OPEN_PARMS16 UNALIGNED *PMCI_OPEN_PARMS16;
typedef LPVOID  LPMCI_OPEN_PARMS16;

typedef struct _MCI_OVLY_LOAD_PARMS16 {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
    RECT16  rc;
} MCI_OVLY_LOAD_PARMS16;
typedef MCI_OVLY_LOAD_PARMS16 UNALIGNED *PMCI_OVLY_LOAD_PARMS16;
typedef LPVOID  LPMCI_OVLY_LOAD_PARMS16;

typedef struct _MCI_OVLY_OPEN_PARMS16 {
    DWORD   dwCallabck;
    WORD    wDeviceID;
    WORD    wReserved0;
    LPCSTR  lpstrDeviceType;
    LPCSTR  lpstrElementName;
    LPCSTR  lpstrAlias;
    DWORD   dwStyle;
    HWND16  hWndParent;  // The book is wrong
    WORD    wReserved1;
} MCI_OVLY_OPEN_PARMS16;
typedef MCI_OVLY_OPEN_PARMS16 UNALIGNED *PMCI_OVLY_OPEN_PARMS16;
typedef LPVOID  LPMCI_OVLY_OPEN_PARMS16;

typedef struct _MCI_OVLY_RECT_PARMS16 {
    DWORD   dwCallback;
    RECT16  rc;
} MCI_OVLY_RECT_PARMS16;
typedef MCI_OVLY_RECT_PARMS16 UNALIGNED *PMCI_OVLY_RECT_PARMS16;
typedef LPVOID  LPMCI_OVLY_RECT_PARMS16;

typedef struct _MCI_OVLY_SAVE_PARMS16 {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
    RECT16  rc;
} MCI_OVLY_SAVE_PARMS16;
typedef MCI_OVLY_SAVE_PARMS16 UNALIGNED *PMCI_OVLY_SAVE_PARMS16;
typedef LPVOID  LPMCI_OVLY_SAVE_PARMS16;

typedef struct _MCI_OVLY_WINDOW_PARMS16 {
    DWORD   dwCallabck;
    HWND16  hWnd;
    WORD    wReserved1;
    WORD    nCmdShow;
    WORD    wReserved2;
    LPCSTR  lpstrText;
} MCI_OVLY_WINDOW_PARMS16;
typedef MCI_OVLY_WINDOW_PARMS16 UNALIGNED *PMCI_OVLY_WINDOW_PARMS16;
typedef LPVOID  LPMCI_OVLY_WINDOW_PARMS16;

typedef struct _MCI_PLAY_PARMS16 {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_PLAY_PARMS16;
typedef MCI_PLAY_PARMS16 UNALIGNED *PMCI_PLAY_PARMS16;
typedef LPVOID  LPMCI_PLAY_PARMS16;

typedef struct _MCI_RECORD_PARMS16 {
    DWORD   dwCallabck;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_RECORD_PARMS16;
typedef MCI_RECORD_PARMS16 UNALIGNED *PMCI_RECORD_PARMS16;
typedef LPVOID  LPMCI_RECORD_PARMS16;

typedef struct _MCI_SAVE_PARMS16 {
    DWORD   dwCallback;
    LPCSTR  lpfilename;   // MMSYSTEM.H differs from the book
} MCI_SAVE_PARMS16;
typedef MCI_SAVE_PARMS16 UNALIGNED *PMCI_SAVE_PARMS16;
typedef LPVOID  LPMCI_SAVE_PARMS16;

typedef struct _MCI_SEEK_PARMS16 {
    DWORD   dwCallback;
    DWORD   dwTo;
} MCI_SEEK_PARMS16;
typedef MCI_SEEK_PARMS16 UNALIGNED *PMCI_SEEK_PARMS16;
typedef LPVOID  LPMCI_SEEK_PARMS16;

typedef struct _MCI_SEQ_SET_PARMS16 {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    DWORD   dwTempo;
    DWORD   dwPort;
    DWORD   dwSlave;
    DWORD   dwMaster;
    DWORD   dwOffset;
} MCI_SEQ_SET_PARMS16;
typedef MCI_SEQ_SET_PARMS16 UNALIGNED *PMCI_SEQ_SET_PARMS16;
typedef LPVOID  LPMCI_SEQ_SET_PARMS16;

typedef struct _MCI_SET_PARMS16 {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
} MCI_SET_PARMS16;
typedef MCI_SET_PARMS16 UNALIGNED *PMCI_SET_PARMS16;
typedef LPVOID  LPMCI_SET_PARMS16;

typedef struct _MCI_SOUND_PARMS16 {
    DWORD   dwCallback;
    LPCSTR  lpstrSoundName;
} MCI_SOUND_PARMS16;
typedef MCI_SOUND_PARMS16 UNALIGNED *PMCI_SOUND_PARMS16;
typedef LPVOID  LPMCI_SOUND_PARMS16;

typedef struct _MCI_STATUS_PARMS16 {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
} MCI_STATUS_PARMS16;
typedef MCI_STATUS_PARMS16 UNALIGNED *PMCI_STATUS_PARMS16;
typedef LPVOID  LPMCI_STATUS_PARMS16;

typedef struct _MCI_SYSINFO_PARMS16 {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    WORD    wDeviceType;
    WORD    wReserved0;
} MCI_SYSINFO_PARMS16;
typedef MCI_SYSINFO_PARMS16 UNALIGNED *PMCI_SYSINFO_PARMS16;
typedef LPVOID  LPMCI_SYSINFO_PARMS16;

typedef struct _MCI_VD_ESCAPE_PARMS16 {
    DWORD   dwCallback;
    LPCSTR  lpstrCommand;
} MCI_VD_ESCAPE_PARMS16;
typedef MCI_VD_ESCAPE_PARMS16 UNALIGNED *PMCI_VD_ESCAPE_PARMS16;
typedef LPVOID  LPMCI_VD_ESCAPE_PARMS16;

typedef struct _MCI_VD_PLAY_PARMS16 {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_VD_PLAY_PARMS16;
typedef MCI_VD_PLAY_PARMS16 UNALIGNED *PMCI_VD_PLAY_PARMS16;
typedef LPVOID  LPMCI_VD_PLAY_PARMS16;

typedef struct _MCI_VD_STEP_PARMS16 {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_VD_STEP_PARMS16;
typedef MCI_VD_STEP_PARMS16 UNALIGNED *PMCI_VD_STEP_PARMS16;
typedef LPVOID  LPMCI_VD_STEP_PARMS16;

typedef struct _MCI_VD_DELETE_PARMS16 {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_VD_DELETE_PARMS16;
typedef MCI_VD_DELETE_PARMS16 UNALIGNED *PMCI_VD_DELETE_PARMS16;
typedef LPVOID  LPMCI_VD_DELETE_PARMS16;

typedef struct _MCI_WAVE_OPEN_PARMS16 {
    DWORD   dwCallback;
    WORD    wDeviceID;
    WORD    wReserved0;
    LPCSTR  lpstrDeviceType;
    LPCSTR  lpstrElementName;
    LPCSTR  lpstrAlias;
    DWORD   dwBufferSeconds;
} MCI_WAVE_OPEN_PARMS16;
typedef MCI_WAVE_OPEN_PARMS16 UNALIGNED *PMCI_WAVE_OPEN_PARMS16;
typedef LPVOID  LPMCI_WAVE_OPEN_PARMS16;

typedef struct _MCI_WAVE_SET_PARMS16 {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    WORD    wInput;
    WORD    wReserved0;
    WORD    wOutput;
    WORD    wReserved1;
    WORD    wFormatTag;
    WORD    wReserved2;
    WORD    nChannels;
    WORD    wReserved3;
    DWORD   nSamplesPerSecond;
    DWORD   nAvgBytesPerSec;
    WORD    nBlockAlign;
    WORD    wReserved4;
    WORD    wBitsPerSample;
    WORD    wReserved5;
} MCI_WAVE_SET_PARMS16;
typedef MCI_WAVE_SET_PARMS16 UNALIGNED *PMCI_WAVE_SET_PARMS16;
typedef LPVOID  LPMCI_WAVE_SET_PARMS16;

typedef struct {
    DWORD   dwCallback;
    DWORD   dwItem;
    DWORD   dwValue;
    DWORD   dwOver;
    LPSTR   lpstrAlgorithm;
    LPSTR   lpstrQuality;
    DWORD   dwSourceNumber;
} MCI_DGV_SETVIDEO_PARMS16;
typedef MCI_DGV_SETVIDEO_PARMS16 UNALIGNED *PMCI_DGV_SETVIDEO_PARMS16;

#ifdef i386
#define GETWORD(pb)     (*((PWORD)pb)++)
#define GETDWORD(pb)    (*((PDWORD)pb)++)
#define FETCHWORD(s)    ((WORD)(s))
#define FETCHDWORD(s)   ((DWORD)(s))
#define STOREWORD(d,s)  (WORD)d=(WORD)s
#define STOREDWORD(d,s) (DWORD)d=(DWORD)s
#else
#define GETWORD(pb)   (*((UNALIGNED WORD *)pb)++)
#define GETDWORD(pb)  (*((UNALIGNED DWORD *)pb)++)
#define FETCHWORD(s)  (*(UNALIGNED WORD *)&(s))
#define FETCHDWORD(s) (*(UNALIGNED DWORD *)&(s))
#define STOREWORD(d,s)  *(UNALIGNED WORD *)&(d)=(WORD)s
#define STOREDWORD(d,s) *(UNALIGNED DWORD *)&(d)=(DWORD)s
#endif

#define FETCHSHORT(s)   ((SHORT)(FETCHWORD(s)))
#define FETCHLONG(s)    ((LONG)(FETCHDWORD(s)))
#define STORESHORT(d,s) STOREWORD(d,s)
#define STORELONG(d,s)  STOREDWORD(d,s)

#define CHAR32(b)       ((CHAR)(b))
#define BYTE32(b)       ((BYTE)(b))
#define INT32(i)        ((INT)(INT16)(i))
#define UINT32(i)       ((unsigned int)(i))
#define BOOL32(f)       ((BOOL)(f))
#define WORD32(w)       ((WORD)(w))
#define LONG32(l)       FETCHLONG(l)
#define DWORD32(dw)     FETCHDWORD(dw)

#define MMGETOPTPTR(vp,cb,p)  {p=NULL; if (HIWORD(FETCHDWORD(vp))) p = GETVDMPTR(vp);}


DWORD
ThunkMciCommand16(
    MCIDEVICEID DeviceID,
    UINT OrigCommand,
    DWORD OrigFlags,
    PMCI_GENERIC_PARMS16 lp16OrigParms,
    PDWORD pNewParms,
    LPWSTR *lplpCommand,
    PUINT puTable
    );

VOID
ThunkGenericParms(
    PDWORD pOrigFlags,
    PMCI_GENERIC_PARMS16 lp16GenParmsOrig,
    PMCI_GENERIC_PARMS lp32GenParmsOrig
    );

DWORD
ThunkOpenCmd(
    PDWORD pOrigFlags,
    PMCI_OPEN_PARMS16 lp16OpenParms,
    PMCI_OPEN_PARMS p32OpenParms
    );

DWORD
ThunkSetCmd(
    MCIDEVICEID DeviceID,
    PDWORD pOrigFlags,
    PMCI_SET_PARMS16 lpSetParms16,
    PMCI_SET_PARMS lpSetParms32
    );

DWORD
ThunkSetVideoCmd(
    PDWORD pOrigFlags,
    PMCI_DGV_SETVIDEO_PARMS16 lpSetParms16,
    LPMCI_DGV_SETVIDEO_PARMS lpSetParms32
    );

DWORD
ThunkSysInfoCmd(
    PMCI_SYSINFO_PARMS16 lpSysInfo16,
    PMCI_SYSINFO_PARMS lpSysInfo32
    );

DWORD
ThunkBreakCmd(
    PDWORD pOrigFlags,
    PMCI_BREAK_PARMS16 lpBreak16,
    PMCI_BREAK_PARMS lpBreak32
    );

DWORD
ThunkWindowCmd(
    MCIDEVICEID DeviceID,
    PDWORD pOrigFlags,
    PMCI_ANIM_WINDOW_PARMS16 lpAniParms16,
    PMCI_ANIM_WINDOW_PARMS lpAniParms32
    );

int
ThunkCommandViaTable(
    LPWSTR lpCommand,
    DWORD dwFlags,
    DWORD UNALIGNED *pdwOrig16,
    LPBYTE pNewParms
    );

int
UnThunkMciCommand16(
    MCIDEVICEID devID,
    UINT OrigCommand,
    DWORD OrigFlags,
    PMCI_GENERIC_PARMS16 lp16GenericParms,
    PDWORD NewParms,
    LPWSTR lpCommand,
    UINT uTable
    );

VOID
UnThunkOpenCmd(
    PMCI_OPEN_PARMS16 lpOpeParms16,
    PMCI_OPEN_PARMS lpOpenParms32
    );

#if DBG
VOID
UnThunkSysInfoCmd(
    DWORD OrigFlags,
    PMCI_SYSINFO_PARMS NewParms
    );
#endif

VOID
UnThunkStatusCmd(
    MCIDEVICEID devID,
    DWORD OrigFlags,
    DWORD UNALIGNED *pdwOrig16,
    DWORD NewParms
    );

int
UnThunkCommandViaTable(
    LPWSTR lpCommand,
    DWORD UNALIGNED *pdwOrig16,
    DWORD pNewParms,
    BOOL fReturnValNotThunked
    );


/* -------------------------------------------------------------------------
** Compatability functions.
** -------------------------------------------------------------------------
*/
BOOL APIENTRY mciExecute(
    LPCSTR lpstrCommand
    );

/* -----------------------------------------------------------------------
 *
 * MCI Command Thunks Debugging Functions and Macros
 *
 * ----------------------------------------------------------------------- */
typedef struct {
    UINT    uMsg;
    LPSTR   lpstMsgName;
} MCI_MESSAGE_NAMES;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\playsnd.c ===
/********************************************************************\
*   playsnd.c
*
*   Level 1 kitchen sink DLL sound driver functions
*
*   Copyright (c) 1991-1999 Microsoft Corporation
*
*********************************************************************/
#define UNICODE

#include "winmmi.h"
#include "playwav.h"
#include "mci.h"


WSZCODE szSoundSection[]  = L"sounds"; // WIN.INI section for sounds

WSZCODE szSystemDefaultSound[] = SOUND_DEFAULT; // Name of the default sound

#define SOUNDNAMELEN 256
STATICDT HANDLE hCurrentSound;              // handle to current sound.

extern LPWAVEHDR lpWavHdr;                  // current playing sound PLAYWAV.C

STATICFN BOOL sndPlaySoundI(LPCWSTR lszSoundName, HMODULE hMod, UINT wFlags);
STATICFN void GetDefaultSound(LPWSTR lszSoundName);
CRITICAL_SECTION SoundCritSec;
#define EnterSound()   EnterCriticalSection(&SoundCritSec);
#define LeaveSound()   LeaveCriticalSection(&SoundCritSec);

void lsplitpath (LPCTSTR pszSource,
                 LPTSTR pszDr, LPTSTR pszPath, LPTSTR pszName, LPTSTR pszExt);
void lstrncpy (LPTSTR pszTarget, LPCTSTR pszSource, size_t cch);
void lstrncpyW (LPWSTR pszTarget, LPCWSTR pszSource, size_t cch);

/****************************************************************************/

#ifndef cchLENGTH
#define cchLENGTH(_sz)  (sizeof(_sz)/sizeof(_sz[0]))
#endif

#ifndef _MAX_DRIVE
#define _MAX_DRIVE    3
#define _MAX_DIR    260
#define _MAX_EXT      5
#define _MAX_FNAME  260
#endif


/**************************************************************************\
*  Sounds are played by the variants of PlaySound (i.e. sndPlaySoundA etc)
*  either synchronously or asynchronously.  The semantics in each case is
*  that there can only be one sound playing at a time, and that we kill any
*  sound which is already playing and then start the new one.  If the new
*  one is sync then we do all the work on the current thread by calling
*  sndMessage directly.  This includes waiting for the sound to complete.
*  If the sound is async then we post a message to mmWndProc and return
*  immediately.
*
*  The message queue of mmWndProc is the queue of async messages
*  still waiting to be played.  It contains the following messages
*  which are of interest:
*     MM_WOM_DONE:  call WaveOutNotify
*     MM_SND_PLAY:  Play an async sound
*     MM_SND_ABORT: Put on the queue when a sync wave request comes in.
*
*  The calling tree is
*
*
*
*
*
*             <---------------------------------------------------
*            |  called to play sound alias synchronously          |
*            v                                                    |
*    (Snd)PlaySound--->PostMessage--->mmWndProc------------------>
*            |                (MM_SND_PLAY)| |
*            |                             | |(MM_WOM_DONE)
*             -----------------------------  |
*                     |                      |
*                     v                      |
*                 sndMessage                 v
*                     |                  WaveOutNotify
*                     v                      |
*              SetCurrentSound               |
*                 |   |                      |
*         --------    |                      |
*        |            v                      |
*        v         soundPlay             ----
*    soundFree       | | |              |
*            --------  |  -----------   |
*           |          |             |  |
*           v          v             v  v
*        soundOpen   soundWait    soundClose
*
*  hwndNotify exists for each process and is a global pseudo-constant.
*  It is set when the window is created (typically 1st async sound or
*  mci command) and is never altered thereafter.  It points in effect to
*  mmWndProc.  There is no real need for the window to exist.  It is a
*  convenience to allow messages to be posted and SENT.  If there was no
*  need to send a message (meaning wait for a reply) we could simply create
*  a thread.
*
*  When an asynch sound comes in it is just added to the queue.  mmWndProc
*  will normally find it and call sndMessage.  Before calling sndMessage
*  mmWndProc peeks at the queue to see if there is any abort message
*  pending.  If there is it doesn't bother to try to play the sound.  It
*  means that a SYNC sound has come in since and has pre-empted it.  The
*  async sound will never play.
*
*  SoundMessage critical section:
*  This mechanism in itself is not quite enough.  It is still possible
*  for an async sound to be already heading into sndMessage at the point
*  when a sync sound comes in.  The two then have a race.  To ensure that
*  there is a clear winner, all the real work in sndMessage is done
*  inside a critical section.  We guarantee that we eventually leave
*  the section by a try/finally in sndMessage.  It is entered and left by
*  the EnterSound and LeaveSound macros.
*
*  WavHdrCritSec critical section
*  The notification uses a global variable lpWavHdr.  This is set by
*  soundOpen and cleared by soundClose.  soundClose may be called
*  asynchronously by WaveOutNotify, so all attempts to dereference it
*  must be protected by a check that it is non-null and a critical section
*  to ensure that it is not nullified between the check and the dereference.
*  It is entered and left by the EnterWavHdr and LeaveWavHdr macros.
\**************************************************************************/

STATICFN UINT TransAlias(UINT alias) {
    switch (alias) {
        case SND_ALIAS_SYSTEMASTERISK:     return STR_ALIAS_SYSTEMASTERISK    ;
        case SND_ALIAS_SYSTEMQUESTION:     return STR_ALIAS_SYSTEMQUESTION    ;
        case SND_ALIAS_SYSTEMHAND:         return STR_ALIAS_SYSTEMHAND        ;
        case SND_ALIAS_SYSTEMEXIT:         return STR_ALIAS_SYSTEMEXIT        ;
        case SND_ALIAS_SYSTEMSTART:        return STR_ALIAS_SYSTEMSTART       ;
        case SND_ALIAS_SYSTEMWELCOME:      return STR_ALIAS_SYSTEMWELCOME     ;
        case SND_ALIAS_SYSTEMEXCLAMATION:  return STR_ALIAS_SYSTEMEXCLAMATION ;
        case SND_ALIAS_SYSTEMDEFAULT:      return STR_ALIAS_SYSTEMDEFAULT     ;
        default: return alias;
    }
}


extern BOOL  WinmmRunningInServer;  // Are we running in the user/base server?
extern BOOL  WaveMapperInitialized; // Wave mapper safely loaded

extern TCHAR gszSchemesRootKey[];
extern TCHAR gszSchemeAppsKey[];
extern TCHAR aszDefault[];
extern TCHAR aszCurrent[];
extern TCHAR asz4Format[];
extern TCHAR asz5Format[];
extern TCHAR asz6Format[];
extern TCHAR aszActiveKey[];
extern TCHAR aszBoolOne[];
extern TCHAR aszSetup[];	// REGSTR_PATH_SETUP
extern TCHAR aszValMedia[];	// REGSTR_VAL_MEDIA

extern TCHAR gszDefaultBeepOldAlias[];	// "SystemDefault"

BOOL UseRegistry= FALSE;
TCHAR Keyname[] = TEXT("Control Panel\\Sounds\\");


//--------------------------------------------------------------------------;
BOOL PASCAL sndQueryRegistry (LPCWSTR szScheme,
                              LPCWSTR szApp,
                              LPCWSTR szSound,
                              LPWSTR  szBuffer)
{
    TCHAR   szKey[196];
    LONG    cbValue;

    wsprintfW (szKey, asz5Format, // ("AppEvents\Apps\(app)\(sound)\(scheme)")
               gszSchemesRootKey,
               gszSchemeAppsKey,
               szApp,
               szSound,
               szScheme);

    if (mmRegQueryUserValue (szKey, NULL, MAX_SOUND_ATOM_CHARS, szBuffer))
    {
                // There's an entry--but make sure it's enabled!
                //
        wsprintfW (szKey, asz6Format,  // "AppEvents\Apps\app\snd\scheme\Active"
                   (LPCSTR)gszSchemesRootKey,
                   (LPCSTR)gszSchemeAppsKey,
                   (LPCSTR)szApp,
                   szSound,
                   szScheme,
                   aszActiveKey);

        if (!mmRegQueryUserValue (szKey, NULL, cchLENGTH(szKey), szKey))
        {
            return TRUE;	// Not disabled?  Okay.
        }

        if (!lstrcmpW (szKey, aszBoolOne))
        {
            return TRUE;	// Says it's enabled?  Okay.
        }
    }

    return FALSE;
}


/****************************************************************************/
STATICFN BOOL GetSoundAlias(
    LPCWSTR  lszSoundName,
    LPWSTR   lszBuffer,
    DWORD    dwFlags)
/****************************************************************************/
{
    BOOL   fFound;
    LPWSTR lpwstrFilePart;
    TCHAR  szApp[APP_TYPE_MAX_LENGTH];
    TCHAR  szScheme[SCH_TYPE_MAX_LENGTH];
    LONG   cbValue;
    TCHAR  szTemp[ _MAX_FNAME ];

    if ((lszSoundName == NULL) || (lszBuffer == NULL))
        return FALSE;

            //
            // Try to translate the alias (from lszSoundName--it'll be
            // ".Default", "MailBeep", etc) into a fully-qualified
            // filename.  Note that lszSoundName and lszBuffer may point
            // to the same address space.
            //
            // If it's "SystemDefault", play ".Default" instead.
            //

    fFound = FALSE;

    if (!lstrcmp (lszSoundName, gszDefaultBeepOldAlias))
    {
        lszSoundName = szSystemDefaultSound;
    }

    if (lstrlen(lszSoundName) < EVT_TYPE_MAX_LENGTH)
    {

                //
                // first determine what application is calling us;
                // we'll use ".default" if nothing is apparent, but
                // in theory we should be able to differentiate sounds
                // on an app by app basis.
                //

        szApp[0] = TEXT('\0');

        if (dwFlags & SND_APPLICATION)
        {
            if (GetModuleFileName (GetModuleHandle(NULL),
                                   szTemp, sizeof(szTemp)/sizeof(szTemp[0])))
            {
                lsplitpath (szTemp, NULL, NULL, szApp, NULL);
            }
        }

        if (szApp[0] == TEXT('\0'))
        {
            lstrcpy(szApp, aszDefault);
        }

                //
                // determine what the current scheme is, and find the
                // appropriate sound.  Try both the app we queried above,
                // and ".Default" if necessary.
                //

        szScheme[0] = TEXT('\0');

        if (sndQueryRegistry(aszCurrent, szApp,      lszSoundName, szTemp) ||
            sndQueryRegistry(aszCurrent, aszDefault, lszSoundName, szTemp))
        {
            lstrcpy (lszBuffer, szTemp);
            fFound = TRUE;
        }
    }

            //
            // Were we able to translate the alias into a valid filename?
            //

    if (!fFound)
    {
        // never found a matching alias!
        //
        return FALSE;
    }

    lstrcpy (szTemp, lszBuffer);
    return TRUE;
}


/****************************************************************************/
STATICFN BOOL PASCAL NEAR GetSoundName(
    LPCWSTR  lszSoundName,
    LPWSTR   lszBuffer,
    DWORD    flags)
/****************************************************************************/
{
    int     i;
    WCHAR   szTmpFileName[SOUNDNAMELEN];
    LPWSTR  lpwstrFilePart;

    //
    //  if the sound is defined in the [sounds] section of WIN.INI
    //  get it and remove the description, otherwise assume it is a
    //  file and qualify it.
    //
    // If we KNOW it is a filename do not look in the INI file
    if ((flags & SND_ALIAS) || !(flags & SND_FILENAME)) {

        if (!GetSoundAlias ( lszSoundName, lszBuffer, flags)) {
            lstrcpy( lszBuffer, lszSoundName );
        }

    } else  {
        lstrcpy( lszBuffer, lszSoundName );
    }

//  UNICODE:  Can't use OpenFile with Unicode string name.  As we are
//  checking to see if the file exists and then copying its fully
//  qualified name to lszBuffer, (ie. not opening the file) I will
//  use SearchPathW instead.
//
//  if (OpenFile(lszBuffer, &of, OF_EXIST | OF_READ | OF_SHARE_DENY_NONE) != HFILE_ERROR) {
//      OemToAnsi(of.szPathName, lszBuffer);
//  }


    lstrcpy( szTmpFileName, lszBuffer );
    if (!SearchPathW( NULL, szTmpFileName, L".WAV", SOUNDNAMELEN,
                      lszBuffer, &lpwstrFilePart )) {
       WCHAR szMediaPath[MAX_PATH];

       if (mmRegQueryMachineValue (aszSetup, aszValMedia,
                                   cchLENGTH(szMediaPath), szMediaPath)) {
          if (!SearchPathW( szMediaPath, szTmpFileName, L".WAV", SOUNDNAMELEN,
                            lszBuffer, &lpwstrFilePart )) {
             return FALSE;  // couldn't find the sound file anywhere!
          }
       }
    }

    //  Clearing warning.

    return TRUE;
}


/*****************************************************************************
 * @doc EXTERNAL
 *
 * @api BOOL | sndPlaySound | This function plays a waveform
 *      sound specified by a filename or by an entry in the [sounds] section
 *      of WIN.INI.  If the sound can't be found, it plays the
 *      default sound specified by the .Default entry in the
 *      [sounds] section of WIN.INI. If there is no .Default
 *      entry or if the default sound can't be found, the function
 *      makes no sound and returns FALSE.
 *
 * @parm LPCSTR | lpszSoundName | Specifies the name of the sound to play.
 *      The function searches the [sounds] section of WIN.INI for an entry
 *      with this name and plays the associated waveform file.
 *      If no entry by this name exists, then it assumes the name is
 *      the name of a waveform file. If this parameter is NULL, any
 *      currently playing sound is stopped.
 *
 * @parm UINT | wFlags | Specifies options for playing the sound using one
 *      or more of the following flags:
 *              
 * @flag  SND_SYNC            | The sound is played synchronously and the
 *      function does not return until the sound ends.
 * @flag  SND_ASYNC           | The sound is played asynchronously and the
 *      function returns immediately after beginning the sound. To terminate
 *      an asynchronously-played sound, call <f sndPlaySound> with
 *      <p lpszSoundName> set to NULL.
 * @flag  SND_NODEFAULT       | If the sound can't be found, the function
 *      returns silently without playing the default sound.
 * @flag  SND_MEMORY          | The parameter specified by <p lpszSoundName>
 *      points to an in-memory image of a waveform sound.
 * @flag  SND_LOOP            | The sound will continue to play repeatedly
 *      until <f sndPlaySound> is called again with the
 *      <p lpszSoundName> parameter set to NULL.  You must also specify the
 *      SND_ASYNC flag to loop sounds.
 * @flag  SND_NOSTOP          | If a sound is currently playing, the
 *      function will immediately return FALSE without playing the requested
 *      sound.
 *
 * @rdesc Returns TRUE if the sound is played, otherwise
 *      returns FALSE.
 *
 * @comm The sound must fit in available physical memory and be playable
 *      by an installed waveform audio device driver. The directories
 *      searched for sound files are, in order: the current directory;
 *      the Windows directory; the Windows system directory; the directories
 *      listed in the PATH environment variable; the list of directories
 *      mapped in a network. See the Windows <f OpenFile> function for
 *      more information about the directory search order.
 *
 *      If you specify the SND_MEMORY flag, <p lpszSoundName> must point
 *      to an in-memory image of a waveform sound. If the sound is stored
 *      as a resource, use <f LoadResource> and <f LockResource> to load
 *      and lock the resource and get a pointer to it. If the sound is not
 *      a resource, you must use <f GlobalAlloc> with the GMEM_MOVEABLE and
 *      GMEM_SHARE flags set and then <f GlobalLock> to allocate and lock
 *      memory for the sound.
 *
 * @xref MessageBeep
 ****************************************************************************/
BOOL APIENTRY sndPlaySoundW( LPCWSTR szSoundName, UINT wFlags)
{
    UINT    cDevs;

    //
    //  !!! quick exit for no wave devices !!!
    //

    ClientUpdatePnpInfo();

    EnterNumDevs("sndPlaySoundW");
    cDevs = wTotalWaveOutDevs;
    LeaveNumDevs("sndPlaySoundW");

    if (cDevs) {
        return sndPlaySoundI(szSoundName, NULL, wFlags);
    } else {
        return FALSE;
    }
}

BOOL APIENTRY sndPlaySoundA( LPCSTR szSoundName, UINT wFlags)
{
    return PlaySoundA(szSoundName, NULL, wFlags);
}

BOOL APIENTRY PlaySoundW(LPCWSTR szSoundName, HMODULE hModule, DWORD wFlags)
{
    UINT    cDevs;

    //
    //  !!! quick exit for no wave devices !!!
    //

    ClientUpdatePnpInfo();

    EnterNumDevs("sndPlaySoundW");
    cDevs = wTotalWaveOutDevs;
    LeaveNumDevs("sndPlaySoundW");

    if (cDevs) {
        return sndPlaySoundI(szSoundName, hModule, (UINT)wFlags);
    }
    return FALSE;
}

BOOL APIENTRY PlaySoundA(LPCSTR szSoundName, HMODULE hModule, DWORD wFlags)
{
    UINT  cDevs;
    WCHAR UnicodeStr[256]; // Unicode version of szSoundName

    //
    //  !!! quick exit for no wave devices !!!
    //

    ClientUpdatePnpInfo();

    EnterNumDevs("sndPlaySoundW");
    cDevs = wTotalWaveOutDevs;
    LeaveNumDevs("sndPlaySoundW");

    if (cDevs) {

        // We do not want to translate szSoundName unless it is a pointer
        // to an ascii string.  It may be a pointer to an in-memory copy
        // of a wave file, or it may identify a resource.  If a resource
        // then we do want to translate the name.  Note that there is an
        // overlap between SND_MEMORY and SND_RESOURCE.  This is deliberate
        // as later on the resource will be loaded - then played from memory.

        if ( HIWORD(szSoundName)         // Potential to point to an ascii name
             // Translate if NOT memory, or a resource
             // If the resource is identified by ID - the ID better be <= 0xFFFF
             // which applies to lots of other code as well!
          && (!(wFlags & SND_MEMORY) || ((wFlags & SND_RESOURCE) == SND_RESOURCE))
          ) {
            //
            // Convert the Unicode sound name into Ascii
            //

            if (Imbstowcs(UnicodeStr, szSoundName,
                          sizeof(UnicodeStr) / sizeof(WCHAR)) >=
                sizeof(UnicodeStr) / sizeof(WCHAR)) {
                return 0;
            }

            return sndPlaySoundI( UnicodeStr, hModule, (UINT)wFlags );
        }
        else {
            return sndPlaySoundI( (LPWSTR)szSoundName, hModule, (UINT)wFlags );
        }
    }
    return FALSE;
}


/****************************************************************************/
/*
@doc    INTERNAL

@func   BOOL | sndPlaySoundI | Internal version of <f>sndPlaySound<d> which
    resides in the WAVE segment instead.

    If the SND_NOSTOP flag is specifed and a wave file is currently
    playing, or if for some reason no WINMM window is present, the
    function returns failure immediately.  The first condition ensures
    that a current sound is not interrupted if the flag is set.  The
    second condition is only in case of some start up error in which
    the notification window was not created, or WINMM was not
    specified in the [drivers] line, and therefore never loaded.

    Next, if the <p>lszSoundName<d> parameter does not represent a memory
    file, and it is non-NULL, then it must represent a string.  Therefore
    the string must be parsed before sending the sound message to the
    WINMM window.  This is because the WINMM window may reside in a
    a different task than the task which is calling the function, and
    would most likely have a different current directory.

    In this case, the parameter is first checked to determine if it
    actually contains anything.  For some reason a zero length string
    was determined to be able to return TRUE from this function, so that
    is checked.

    Next the string is checked against INI entries, then parsed.

    After parsing the sound name, ensure that a task switch only occurs if
    the sound is asynchronous (SND_ASYNC), and a previous sound does not
    need to be discarded.

    If a task switch is needed, first ensure that intertask messages can
    be sent by checking to see that this task is not locked, or that the
    notification window is in the current task.

@parm   LPCSTR | lszSoundName | Specifies the name of the sound to play.

@parm   UINT | wFlags | Specifies options for playing the sound.

@rdesc  Returns TRUE if the function was successful, else FALSE if an error
    occurred.
*/
STATICFN BOOL sndPlaySoundI(
    LPCWSTR  lszSoundName,
    HMODULE  hMod,
    UINT    wFlags)
{
    BOOL        fPlayReturn;
    LPWSTR      szSoundName = NULL;
    UINT        nLength = 0;
    
    //  Note: Although the max size of a system event sound is 80 chars,
    //        the limitation of the registry key is 256 chars.
    
    WCHAR       temp[256];  // Maximum size of a system event sound

    V_FLAGS(wFlags, SND_VALIDFLAGS, sndPlaySoundW, FALSE);

    if (!(wFlags & SND_MEMORY) && HIWORD(lszSoundName)) {
        V_STRING_W(lszSoundName, 256, FALSE);
    }

    WinAssert(!SND_SYNC); // Because the code relies on SND_ASYNC being non-0

#if DBG
    if (wFlags & SND_MEMORY) {
        STATICFN SZCODE szFormat[] = "sndPlaySound(%lx) Flags %8x";
        dprintf2((szFormat, lszSoundName, wFlags));

    } else if (HIWORD(lszSoundName)) {

        STATICFN SZCODE szFormat[] = "sndPlaySound(%ls) Flags %8x";
        dprintf2((szFormat, lszSoundName, wFlags));

    } else if (lszSoundName) {

        STATICFN SZCODE szFormat[] = "sndPlaySound(0x%x)  Flags %8x";
        dprintf2((szFormat, lszSoundName, wFlags));
    }

#endif  //if DBG

    if (((wFlags & SND_NOSTOP) && lpWavHdr) /*** || (NoNotify)  ***/) {
        dprintf1(("Sound playing, or no notify window"));
        return FALSE;
    }

    //
    //  Bad things happen in functions like LoadIcon which the ACM CODECs
    //  call during their initialization if we're on a CSRSS thread so always
    //  make async calls until we're sure it's initialized.
    //  The last test makes sure we don't 'or' in the SND_ASYNC flag again
    //  on the server thread!
    //
    if ( WinmmRunningInServer && !WaveMapperInitialized &&
         SND_ALIAS_ID == (wFlags & SND_ALIAS_ID)) {
        wFlags |= SND_ASYNC;
    }

    // comments here should have been there from day 1 and explain
    // the test
    //
    //  if (!hwndNotify && !(!(wFlags & SND_ASYNC) && !lpWavHdr))
    // IF   no window
    // AND     NOT  (Synchronous, and no sound present)
    //         ==    Async OR sound present
    // Which meant that if a sound is playing we will attempt to create
    // a second thread even if this is a synchronous request.  This
    // causes havoc when we are called on the server side.


    // If this is an asynchronous call we need to create the asynchronous
    // thread on which the sound will be played.  We should NEVER create
    // the thread if this is a synchronous request, irrespective of the
    // current state (i.e. sound playing, or no sound playing).

    if (wFlags & SND_ASYNC) {
        if (!InitAsyncSound()) {
            dprintf2(("Having to play synchronously - cannot create notify window"));
            wFlags &= ~SND_ASYNC;
            if (WinmmRunningInServer) {
                return FALSE;
            }
        }
    }

    if ( WinmmRunningInServer && (wFlags & SND_ASYNC) ) {

        UINT alias;   // To check if the incoming alias is SYSTEMDEFAULT
        // lszSoundName is NOT a pointer to a filename.  It
        // is a resource id.  Resolve the name from the INI file
        // now.

        if (SND_ALIAS_ID == (wFlags & SND_ALIAS_ID)) {
            nLength = LoadStringW( ghInst,
                                   (alias = TransAlias((UINT)(UINT_PTR)lszSoundName)),
                                   temp, sizeof(temp)/sizeof(WCHAR) );
            if (0 == nLength) {
                dprintf3(("Could not translate Alias ID"));
                return(FALSE);
            } else {
                dprintf3(("Translated alias %x to sound %ls", lszSoundName, temp));
            }

            // We cannot switch control immediately to the async thread as that
            // thread does not have the correct user impersonation.  So rather
            // than passing an alias we resolve it here to a filename.
            // Later: we should get the async thread to set the correct user
            // token and inifilemapping  - then we could revert to passing aliases.

            // Turn off the ID bit, leave ALIAS on)
            wFlags &= ~(SND_ALIAS_ID);
            wFlags |= SND_ALIAS;
        } else {
            //
            // Note: I (RichJ) just stuck this ELSE in here for 3.51, but a
            // lack of it should've been causing faults or failed lookups any
            // time an async sound was requested from the server, without
            // using an ALIAS_ID as the request.  Did that just never happen?
            //
            lstrcpy (temp, lszSoundName);
        }

        // Translate the alias to a file name
        dprintf4(("Calling GetSoundName"));
        if (!GetSoundName(temp, base->szSound, SND_ALIAS)) {
            //
            // Couldn't find the sound file; if there's no default sound,
            // then don't play anything (and don't cancel what's
            // playing now--for example, what if the MenuPopup event
            // has a sound, but the MenuCommand event doesn't?)
            //
	    if (wFlags & SND_NODEFAULT) {
                return(FALSE);
	    }
	}
        dprintf4(("Set %ls as the sound name", base->szSound));

        if (lpWavHdr) {  // Sound is playing
            dprintf4(("Killing pending sound on server"));
            soundFree(NULL);  // Kill any pending sound
        }

        LockMCIGlobal;

        dprintf2(("Signalling play of %x",lszSoundName));
        base->msg = MM_SND_PLAY;
        base->dwFlags = wFlags | SND_FILENAME;
        base->dwFlags &= ~(SND_ALIAS_ID | SND_ALIAS);
        base->lszSound = lszSoundName;

        if (wFlags & SND_NODEFAULT) {
        } else {
            if (STR_ALIAS_SYSTEMDEFAULT == alias) {
                wFlags |= SND_NODEFAULT;
                // We will play the default sound, hence there is
                // no point in having the NODEFAULT flag off.
                dprintf4(("Playing the default sound"));
            } else {

                // If we cannot find or play the file passed in
                // we have to play a default sound.  By the time
                // we get around to playing a default sound we will
                // have lost the ini file mapping.  Resolve the name
                // now.
                dprintf4(("Resolving default sound"));
                GetSoundName(szSystemDefaultSound,
                             base->szDefaultSound,
                             SND_ALIAS);
            }
        }

        dprintf2(("Setting event"));
        SetMCIEvent( hEvent );

        dprintf2(("Event set"));
        UnlockMCIGlobal;

        return(TRUE);
    }

    if (!(wFlags & SND_MEMORY) && lszSoundName) {

        if (!(szSoundName = (LPWSTR)LocalAlloc(LMEM_FIXED, SOUNDNAMELEN * sizeof(WCHAR)))) {
            return FALSE;
        }
        dprintf4(("Allocated szSoundName at %8x", szSoundName));

        if (SND_ALIAS_ID == (wFlags & SND_ALIAS_ID)) {
            // lszSoundName is NOT a pointer to a filename.  It
            // is a resource id.  Resolve the name from the INI file
            // now.

            nLength = LoadStringW( ghInst,
                                   (UINT)TransAlias(PtrToUlong(lszSoundName)),
                                   szSoundName, SOUNDNAMELEN );
            if (0 == nLength) {
                dprintf3(("Could not translate Alias ID"));
                return(FALSE);
            }

            lszSoundName = szSoundName;
            // Turn off the ID bit, leave ALIAS on)
            wFlags &= (~SND_ALIAS_ID | SND_ALIAS);
        }

        if (!*lszSoundName) {
            // LATER: STOP any sound that is already playing
            LocalFree ((HLOCAL)szSoundName);
            return TRUE;
        }

        if (!GetSoundName(lszSoundName, szSoundName, wFlags)) {
            //
            // Couldn't find the sound file; if there's no default sound,
            // then don't play anything (and don't cancel what's
            // playing now--for example, what if the MenuPopup event
            // has a sound, but the MenuCommand event doesn't?)
            //
            if (wFlags & SND_NODEFAULT) {
                LocalFree ((HLOCAL)szSoundName);
                return TRUE;
            }
        }

        lszSoundName = (LPCWSTR)szSoundName;
        nLength = lstrlenW(szSoundName);

    } else {

        // lszSoundName points to a memory image (if SND_MEMORY)
        // or lszSoundName is null.  Either way we do not want to
        // load a file.  OR we may have a resource to load.

        HANDLE hResInfo;
        HANDLE hResource;

        szSoundName = NULL;

        if (SND_RESOURCE == (wFlags & SND_RESOURCE)) {
	    
	    hResInfo = FindResourceW( hMod, lszSoundName, SOUND_RESOURCE_TYPE_SOUND );
	    if (NULL == hResInfo) {
		hResInfo = FindResourceW( hMod, lszSoundName, SOUND_RESOURCE_TYPE_WAVE );
	    }

            if (hResInfo) {
                hResource = LoadResource( hMod, hResInfo);
                if (hResource) {
                    lszSoundName = LockResource(hResource);
                } else {
                    dprintf1(("failed to load resource"));
                    return(FALSE);
                }
            } else {
                dprintf1(("failed to find resource"));
                return(FALSE);
            }
            // Turn off the resource bit
            wFlags &= ~(SND_RESOURCE-SND_MEMORY);
        }
    }

    // This was the old test - replaced with the one below.  The
    if (szSoundName) {
        wFlags |= SND_FREE;
        // LocalFree((HANDLE)szSoundName);  // Freed by SNDMESSAGE
    }

    // For a synchronous sound it is valid for a prior async sound to be
    // still playing.  Before we finally play this new sound we will kill
    // the old sound.  The code commented out below caused a SYNC sound to
    // play asynchronously if a previous sound was still active
    if (!(wFlags & SND_ASYNC) /* && !lpWavHdr SOUND IS STILL PLAYING */) {

        if (hwndNotify) {  // Clear any pending asynchronous sounds
            PostMessage(hwndNotify, MM_SND_ABORT, 0, 0);
        }
        fPlayReturn = sndMessage( (LPWSTR)lszSoundName, wFlags);

    } else {

        WinAssert(hwndNotify);   // At this point we need the window
        // Note: in this leg we must free lszSoundName later
        dprintf3(("Sending MM_SND_PLAY to hwndNotify"));

        fPlayReturn = PostMessage(hwndNotify, MM_SND_PLAY, wFlags, (LPARAM)lszSoundName);
    }

    return fPlayReturn;
}

/****************************************************************************\
* INTERNAL MatchFile                                                                                                             *
*                                                                                                                                                        *
* Checks that the file stored on disk matches the cached sound file for          *
* date, time and size.  If not, then we return FALSE and the cached sound        *
* file is not used.  If the details do match we return TRUE.  Note that the  *
* last_write file time is used in case the user has updated the file.        *
\****************************************************************************/

STATICFN BOOL MatchFile(PSOUNDFILE pf, LPCWSTR lsz)
{
    HANDLE fh;
    BOOL result = FALSE;
    fh = CreateFileW( lsz,
                      GENERIC_READ,
                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL );

    if ((HANDLE)(UINT_PTR)HFILE_ERROR != fh) {
        if (pf->Size == GetFileSize(fh, NULL)) {
            FILETIME ft;
            if (GetFileTime(fh, NULL, NULL, &ft)) {
                if (CompareFileTime(&ft, &(pf->ft)) == 0) {
                    result = TRUE;
                }
            } else {
               dprintf2(("Error %d getting last write time", GetLastError()));
            }
        }
        CloseHandle(fh);
    }
    return result;
}

/*********************************************************************\
* INTERNAL SetCurrentSound
*
* Called to set the cached sound on this process to <lszSoundName>.
* Before discarding the current sound we check to see if it is the
* same as the one about to be loaded.  If so, then it need not be
* read off the disk.  To be considered the same not only the filename
* has to match, but the file date, time and size.  Note: Windows 3.1
* only matches on the name.
\*********************************************************************/
STATICFN BOOL PASCAL NEAR SetCurrentSound(
    LPCWSTR  lszSoundName)
{
    HANDLE  hSound;
    BOOL    f;
    LPWSTR  lp;

    if (hCurrentSound && (NULL != (lp = GlobalLock(hCurrentSound)))) {

        f = lstrcmpiW( ((PSOUNDFILE)lp)->Filename, (LPWSTR)lszSoundName);

        if (f == 0 && MatchFile( ((PSOUNDFILE)lp), lszSoundName)) {
            GlobalUnlock(hCurrentSound);
            dprintf2(("SetCurrentSound - sound already loaded %ls",(LPWSTR)lszSoundName));
            return TRUE;
        }
        GlobalUnlock(hCurrentSound);
    }

    dprintf2(("SetCurrentSound(%ls)\r\n",lszSoundName));

    if (NULL != (hSound = soundLoadFile(lszSoundName))) {
        soundFree(hCurrentSound);
        hCurrentSound = hSound;
        dprintf3(("SetCurrentSound returning TRUE"));
        return TRUE;
    }
    dprintf3(("SetCurrentSound returning FALSE"));
    return FALSE;
}

/****************************************************************************/
/*
@doc    INTERNAL

@func   BOOL | SoundBeep | Called to sound the speaker when the .Default
        sound either does not exist or is set to NULL

@rdesc  Returns TRUE if the function was successful, else FALSE if an error
    occurred.
*/

STATICFN BOOL SoundBeep(VOID)
{
    BOOL fBeep;
    if (WinmmRunningInServer) {
        // being played on the server thread.  We would not have
        // got here unless the user wants beeps to sound
        fBeep = TRUE;
    } else {
        if (!SystemParametersInfo(SPI_GETBEEP, 0, &fBeep, FALSE)) {
            // Failed to get hold of beep setting.  Should we be
            // noisy or quiet?  We have to choose one value...
            fBeep = TRUE;
        }
    }

    if (fBeep) {
        dprintf5(("Sounding the speaker"));
        // LATER: Symbolic constant... read from which header file?
        return Beep(440, 125);
    } else {
        dprintf5(("NO speaker sound"));
        return(TRUE);
    }
}

/****************************************************************************/
/*
@doc    INTERNAL

@func   BOOL | sndMessage | This function is called in response to an
    MM_SND_PLAY message sent to the WINMM window, and attempts to
    play the specified file, or dump current sound caching.

    If <p>lszSoundName<d> is NULL, any currently cached sound is
    discarded, and the function returns success.

    If the SND_MEMORY flag is set, then <p>lszSoundName<d> actually
    points to a buffer containing a RIFF format WAVE memory file, and
    the function attempts to play it.  The load function performs
    validation on this memory file.  Unlike playing sound names,
    memory files are not cached for future use.

    Otherwise the <p>lszSoundName<d> parameter is actually an INI entry
    or file name.  The function initially attempts to load that sound,
    and if it fails, attempts to load the system default sound.  Note of
    course that the SND_NODEFAULT flag is first checked to determine if
    the default sound is to be played when the original name cannot be
    located.  If no default is wanted, or the default cannot be located,
    the function returns failure.  Note that in calling <f>GetSoundName<d>,
    the <p>lszSoundName<d> parameter is modified.  This function assumes
    that the parameter passed has been previously allocated if a string is
    passed to this function, and is not the actual user's parameter passed
    to <f>sndPlaySound<d>.

@parm   LPSTR | lszSoundName | Specifies the name of the sound to play.

@parm   UINT | wFlags | Specifies options for playing the sound.

@rdesc  Returns TRUE if the function was successful, else FALSE if an error
    occurred.
*/
#if DBG
UINT CritCount = 0;
UINT CritOwner = 0;
#endif

BOOL FAR PASCAL sndMessage(LPWSTR lszSoundName, UINT wFlags)
{
    BOOL fResult;
#if DBG
    if (!lszSoundName) {
        dprintf3(("sndMessage - sound NULL, Flags %8x", wFlags));
    } else {
        dprintf3(("sndMessage - sound %ls, Flags %8x", lszSoundName, wFlags));
    }
#endif

  try {

#if DBG
    if (CritCount) {
        dprintf2(("Sound critical section owned by %x, thread %x waiting", CritOwner, GetCurrentThreadId()));
    }
#endif

    EnterSound();

#if DBG
    if (!CritCount++) {
        CritOwner = GetCurrentThreadId();
        dprintf2(("Thread %x entered Sound critical section", CritOwner));
    } else {
        dprintf2(("Thread %x re-entered Sound critical section, count is %d", CritOwner, CritCount));
    }
#endif

    if (!lszSoundName) {
        // Note that soundFree will stop playing the current sound if
        // it is still playing
        dprintf4(("Freeing current sound, nothing else to play"));
        soundFree(hCurrentSound);
        hCurrentSound = NULL;

        fResult = TRUE;
        goto exit;
    }

    if (wFlags & SND_MEMORY) {

        soundFree(hCurrentSound);
        hCurrentSound = soundLoadMemory( (PBYTE)lszSoundName );

    } else if (!SetCurrentSound(lszSoundName)) {

        if (wFlags & SND_NODEFAULT) {
            if (wFlags & SND_FREE) {
                dprintf3(("Freeing (1) memory block at %8x",lszSoundName));
                LocalFree(lszSoundName);
            }
            fResult = FALSE;
            goto exit;
        }

        GetDefaultSound(lszSoundName);

        // If there is no default sound (.Default == NONE in CPL applet)
        // then sound the old beep.
        if (!*lszSoundName || !SetCurrentSound(lszSoundName)) {
            fResult = SoundBeep();
            if (wFlags & SND_FREE) {
                dprintf3(("Freeing (2) memory block at %8x",lszSoundName));
                LocalFree(lszSoundName);
            }
            goto exit;
        }
    }

    if (wFlags & SND_FREE) {
        dprintf3(("Freeing (3) memory block at %8x",lszSoundName));
        LocalFree(lszSoundName);
    }

    dprintf3(("Calling soundPlay, flags are %8x", wFlags));
    fResult = soundPlay(hCurrentSound, wFlags);
    dprintf3(("returning from sndMessage"));
    exit:;

  } finally {

#if DBG
    if (!--CritCount) {
        dprintf2(("Thread %x relinquishing Sound critical section", CritOwner));
        CritOwner = 0;
    } else {
        dprintf2(("Thread %x leaving Sound critical section, Count is %d", CritOwner, CritCount));
    }
#endif

    LeaveSound();
  } // try
    return(fResult);
}


STATICFN void GetDefaultSound(LPWSTR lszSoundName)
{
    // It's a shame the default sound cannot be cached.  Unfortunately
    // the user can change the mapping (alias->different_file) or even
    // change the file while keeping the same file name.  The only time
    // we do not resolve the name from the INI file is when we are
    // executing in the server.  There may be no ini file mapping in
    // existence (but arbitrarily opening a mapping fails if already
    // open) so we rely on the default sound filename being preset.
    if (!WinmmRunningInServer) {
        GetSoundName(szSystemDefaultSound, lszSoundName, SND_ALIAS);
    } else {
        LockMCIGlobal;
        wcscpy(lszSoundName, base->szDefaultSound);
        UnlockMCIGlobal;
    }
}


void lsplitpath (LPCTSTR pszSource,
                 LPTSTR pszDrive, LPTSTR pszPath, LPTSTR pszName, LPTSTR pszExt)
{
   LPCTSTR  pszLastSlash = NULL;
   LPCTSTR  pszLastDot = NULL;
   LPCTSTR  pch;
   size_t   cchCopy;

        /*
         * NOTE: This routine was snitched out of USERPRI.LIB 'cause the
         * one in there doesn't split the extension off the name properly.
         *
         * We assume that the path argument has the following form, where any
         * or all of the components may be missing.
         *
         *      <drive><dir><fname><ext>
         *
         * and each of the components has the following expected form(s)
         *
         *  drive:
         *      0 to _MAX_DRIVE-1 characters, the last of which, if any, is a
         *      ':'
         *  dir:
         *      0 to _MAX_DIR-1 characters in the form of an absolute path
         *      (leading '/' or '\') or relative path, the last of which, if
         *      any, must be a '/' or '\'.  E.g -
         *      absolute path:
         *          \top\next\last\     ; or
         *          /top/next/last/
         *      relative path:
         *          top\next\last\      ; or
         *          top/next/last/
         *      Mixed use of '/' and '\' within a path is also tolerated
         *  fname:
         *      0 to _MAX_FNAME-1 characters not including the '.' character
         *  ext:
         *      0 to _MAX_EXT-1 characters where, if any, the first must be a
         *      '.'
         *
         */

             // extract drive letter and :, if any
             //
   if (*(pszSource + _MAX_DRIVE - 2) == TEXT(':'))
      {
      if (pszDrive)
         {
         lstrncpy (pszDrive, pszSource, _MAX_DRIVE-1);
         pszDrive[ _MAX_DRIVE-1 ] = TEXT('\0');
         }
      pszSource += _MAX_DRIVE-1;
      }
    else if (pszDrive)
      {
      *pszDrive = TEXT('\0');
      }

          // extract path string, if any.  pszSource now points to the first
          // character of the path, if any, or the filename or extension, if
          // no path was specified.  Scan ahead for the last occurence, if
          // any, of a '/' or '\' path separator character.  If none is found,
          // there is no path.  We will also note the last '.' character found,
          // if any, to aid in handling the extension.
          //
   for (pch = pszSource; *pch != TEXT('\0'); pch++)
      {
      if (*pch == TEXT('/') || *pch == TEXT('\\'))
         pszLastSlash = pch;
      else if (*pch == TEXT('.'))
         pszLastDot = pch;
      }

          // if we found a '\\' or '/', fill in pszPath
          //
   if (pszLastSlash)
      {
      if (pszPath)
         {
         cchCopy = min( (size_t)(_MAX_DIR -1), (size_t)(pszLastSlash -pszSource +1) );
         lstrncpy (pszPath, pszSource, cchCopy);
         pszPath[ cchCopy ] = 0;
         }
      pszSource = pszLastSlash +1;
      }
   else if (pszPath)
      {
      *pszPath = TEXT('\0');
      }

             // extract file name and extension, if any.  Path now points to
             // the first character of the file name, if any, or the extension
             // if no file name was given.  Dot points to the '.' beginning the
             // extension, if any.
             //

   if (pszLastDot && (pszLastDot >= pszSource))
      {
               // found the marker for an extension -
               // copy the file name up to the '.'.
               //
      if (pszName)
         {
         cchCopy = min( (size_t)(_MAX_DIR-1), (size_t)(pszLastDot -pszSource) );
         lstrncpy (pszName, pszSource, cchCopy);
         pszName[ cchCopy ] = 0;
         }

               // now we can get the extension
               //
      if (pszExt)
         {
         lstrncpy (pszExt, pszLastDot, _MAX_EXT -1);
         pszExt[ _MAX_EXT-1 ] = TEXT('\0');
         }
      }
   else
      {
               // found no extension, give empty extension and copy rest of
               // string into fname.
               //
      if (pszName)
         {
         lstrncpy (pszName, pszSource, _MAX_FNAME -1);
         pszName[ _MAX_FNAME -1 ] = TEXT('\0');
         }

      if (pszExt)
         {
         *pszExt = TEXT('\0');
         }
      }

}

void lstrncpy (LPTSTR pszTarget, LPCTSTR pszSource, size_t cch)
{
   size_t ich;
   for (ich = 0; ich < cch; ich++)
      {
      if ((pszTarget[ich] = pszSource[ich]) == TEXT('\0'))
         break;
      }
}

void lstrncpyW (LPWSTR pszTarget, LPCWSTR pszSource, size_t cch)
{
   size_t ich;
   for (ich = 0; ich < cch; ich++)
      {
      if ((pszTarget[ich] = pszSource[ich]) == L'\0')
         break;
      }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\pref.c ===
/* Copyright (c) 1998-2001 Microsoft Corporation */
#define UNICODE
#define _UNICODE
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "winmmi.h"
#include <mmreg.h>
#include <regstr.h>
#include <stdlib.h>
#include <tchar.h>
#include "audiosrvc.h"

extern PCWSTR waveReferenceDevInterfaceById(IN PWAVEDRV pdrvZ, IN UINT_PTR id);
extern PCWSTR midiReferenceDevInterfaceById(IN PMIDIDRV pdrvZ, IN UINT_PTR id);

#define REGSTR_PATH_MULTIMEDIA_SOUNDMAPPER TEXT("Software\\Microsoft\\Multimedia\\Sound Mapper")
#define REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_PLAYBACK TEXT("Playback")
#define REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_RECORD TEXT("Record")
#define REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_CONSOLEVOICECOM_PLAYBACK TEXT("ConsoleVoiceComPlayback")
#define REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_CONSOLEVOICECOM_RECORD   TEXT("ConsoleVoiceComRecord")
#define REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_PREFERREDONLY TEXT("PreferredOnly")

#define REGSTR_PATH_MEDIARESOURCES_MIDI REGSTR_PATH_MEDIARESOURCES TEXT("\\MIDI")
#define REGSTR_VAL_MEDIARESOURCES_MIDI_SUBKEY_ACTIVE          TEXT("Active")
#define REGSTR_VAL_MEDIARESOURCES_MIDI_SUBKEY_DESCRIPTION     TEXT("Description")
#define REGSTR_VAL_MEDIARESOURCES_MIDI_SUBKEY_DEVICEINTERFACE TEXT("DeviceInterface")
#define REGSTR_VAL_MEDIARESOURCES_MIDI_SUBKEY_PHYSDEVID       TEXT("PhysDevID")
#define REGSTR_VAL_MEDIARESOURCES_MIDI_SUBKEY_PORT            TEXT("Port")

#define REGSTR_PATH_MULTIMEDIA_MIDIMAP REGSTR_PATH_MULTIMEDIA TEXT("\\MIDIMap")
#define REGSTR_VAL_MULTIMEDIA_MIDIMAP_CONFIGURECOUNT    TEXT("ConfigureCount")
#define REGSTR_VAL_MULTIMEDIA_MIDIMAP_USESCHEME         TEXT("UseScheme")
#define REGSTR_VAL_MULTIMEDIA_MIDIMAP_DRIVERLIST        TEXT("DriverList")
#define REGSTR_VAL_MULTIMEDIA_MIDIMAP_AUTOSCHEME        TEXT("AutoScheme")
#define REGSTR_VAL_MULTIMEDIA_MIDIMAP_CURRENTINSTRUMENT TEXT("CurrentInstrument")
#define REGSTR_VAL_MULTIMEDIA_MIDIMAP_DEVICEINTERFACE   TEXT("DeviceInterface")
#define REGSTR_VAL_MULTIMEDIA_MIDIMAP_RELATIVEINDEX     TEXT("RelativeIndex")
#define REGSTR_VAL_MULTIMEDIA_MIDIMAP_SZPNAME           TEXT("szPname")

#define REGSTR_VAL_SETUPPREFERREDAUDIODEVICES TEXT("SetupPreferredAudioDevices")
#define REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT TEXT("SetupPreferredAudioDevicesCount")

extern BOOL WaveMapperInitialized;	// in winmm.c
extern BOOL MidiMapperInitialized;	// in winmm.c

// Preferred Ids.  Setting these to *_MAPPER indicates no setting.
PWSTR gpstrWoDefaultStringId         = NULL;
PWSTR gpstrWiDefaultStringId         = NULL;
PWSTR gpstrWoConsoleVoiceComStringId = NULL;
PWSTR gpstrWiConsoleVoiceComStringId = NULL;
BOOL  gfUsePreferredWaveOnly         = TRUE;
PWSTR gpstrMoDefaultStringId         = NULL;

// These will be TRUE if we sent the preferred device change
// to sysaudio.
BOOL gfWaveOutPreferredMessageSent = FALSE;
BOOL gfWaveInPreferredMessageSent  = FALSE;
BOOL gfMidiOutPreferredMessageSent = FALSE;

//------------------------------------------------------------------------------
//
//
//	Registry helpers
//
//
//------------------------------------------------------------------------------

LONG RegQuerySzValue(HKEY hkey, PCTSTR pValueName, PTSTR *ppstrValue)
{
    LONG result;
    DWORD typeValue;
    DWORD cbstrValue = 0;
    BOOL f;
    
    result = RegQueryValueEx(hkey, pValueName, 0, &typeValue, NULL, &cbstrValue);
    if (ERROR_SUCCESS == result)
    {
	if (REG_SZ == typeValue)
	{
	    PTSTR pstrValue;
	    pstrValue = HeapAlloc(hHeap, 0, cbstrValue);
	    if (pstrValue)
	    {
		result = RegQueryValueEx(hkey, pValueName, 0, &typeValue, (PBYTE)pstrValue, &cbstrValue);
		if (ERROR_SUCCESS == result)
		{
                    if (REG_SZ == typeValue)
                    {
                        *ppstrValue = pstrValue;
                    } else {
                        result = ERROR_FILE_NOT_FOUND;
                        f = HeapFree(hHeap, 0, pstrValue);
                        WinAssert(f);
                    }
		} else {
		    f = HeapFree(hHeap, 0, pstrValue);
		    WinAssert(f);
		}
	    } else {
		result = ERROR_OUTOFMEMORY;
	    }
	} else {
	    result = ERROR_FILE_NOT_FOUND;
	}
    }
    return result;
}

LONG RegQueryDwordValue(HKEY hkey, PCTSTR pValueName, PDWORD pdwValue)
{
    DWORD cbdwValue;
    LONG result;

    cbdwValue = sizeof(*pdwValue);
    result = RegQueryValueEx(hkey, pValueName, 0, NULL, (PBYTE)pdwValue, &cbdwValue);
    return result;
}

LONG RegSetSzValue(HKEY hkey, PCTSTR pValueName, PCTSTR pstrValue)
{
    DWORD cbstrValue = (lstrlen(pstrValue) + 1) * sizeof(pstrValue[0]);
    return RegSetValueEx(hkey, pValueName, 0, REG_SZ, (PBYTE)pstrValue, cbstrValue);
}

LONG RegSetDwordValue(HKEY hkey, PCTSTR pValueName, DWORD dwValue)
{
    return RegSetValueEx(hkey, pValueName, 0, REG_DWORD, (PBYTE)&dwValue, sizeof(dwValue));
}


//------------------------------------------------------------------------------
//
//
//	AutoSetupPreferredAudio functions
//
//
//------------------------------------------------------------------------------

//--------------------------------------------------------------------------;
//
// DWORD GetCurrentSetupPreferredAudioCount
//
// Arguments:
//
// Return value:
//
// History:
//	1/19/99		FrankYe		Created
//
//--------------------------------------------------------------------------;
DWORD GetCurrentSetupPreferredAudioCount(void)
{
    HKEY hkeySetupPreferredAudioDevices;
    DWORD SetupCount = 0;
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_MEDIARESOURCES TEXT("\\") REGSTR_VAL_SETUPPREFERREDAUDIODEVICES, 0, KEY_QUERY_VALUE, &hkeySetupPreferredAudioDevices))
    {
	if (ERROR_SUCCESS != RegQueryDwordValue(hkeySetupPreferredAudioDevices, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, &SetupCount)) {
	    Squirt("GCSPATS: Couldn't read hklm\\...\\SetupPreferredAudioDevicesCount");
	}
	if (ERROR_SUCCESS != RegCloseKey(hkeySetupPreferredAudioDevices)) {
	    WinAssert(!"GCSPATS: unexpected failure of RegCloseKey");
	}
    } else {
	Squirt("GCSPATS: Couldn't open hklm\\...\\SetupPreferredAudioDevices");
    }

    return SetupCount;
}

//--------------------------------------------------------------------------;
//
// DWORD GetDeviceInterfaceSetupPreferredAudioCount
//
// Arguments:
//
// Return value:
//
// History:
//	1/19/99		FrankYe		Created
//
//--------------------------------------------------------------------------;
DWORD GetDeviceInterfaceSetupPreferredAudioCount(PCWSTR DeviceInterface)
{
    PMMDEVICEINTERFACEINFO pdii;
    PMMPNPINFO pPnpInfo;
    LONG cbPnpInfo;
    DWORD count;
    int ii;

    // Handle empty DeviceInterface names in case of legacy drivers
    if (0 == lstrlen(DeviceInterface)) return 0;

    if (ERROR_SUCCESS != winmmGetPnpInfo(&cbPnpInfo, &pPnpInfo)) return 0;
    
    pdii = (PMMDEVICEINTERFACEINFO)&(pPnpInfo[1]);
    pdii = PAD_POINTER(pdii);

    for (ii = pPnpInfo->cDevInterfaces; ii; ii--)
    {
	//  Searching for the device interface...
        if (0 == lstrcmpi(pdii->szName, DeviceInterface)) break;

        pdii = (PMMDEVICEINTERFACEINFO)(pdii->szName + lstrlenW(pdii->szName) + 1);
	pdii = PAD_POINTER(pdii);
    }

    WinAssert(ii);
    
    count = pdii->SetupPreferredAudioCount;
    
    HeapFree(hHeap, 0, pPnpInfo);

    return count;
}

//------------------------------------------------------------------------------
//
//
//	NotifyServerPreferredDeviceChange
//
//
//------------------------------------------------------------------------------
void NotifyServerPreferredDeviceChange(void)
{
    winmmAdvisePreferredDeviceChange();
}

//------------------------------------------------------------------------------
//
//
//	Wave
//
//
//------------------------------------------------------------------------------

MMRESULT waveWritePersistentConsoleVoiceCom(BOOL fOut, PTSTR pstrPref, BOOL fPrefOnly)
{
    HKEY hkcu;
    HKEY hkSoundMapper;
    LONG result;
    BOOL fSuccess;

    if (!NT_SUCCESS(RtlOpenCurrentUser(GENERIC_WRITE, &hkcu))) return MMSYSERR_WRITEERROR;

    result = RegCreateKeyEx(hkcu, REGSTR_PATH_MULTIMEDIA_SOUNDMAPPER, 0, TEXT("\0"), REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hkSoundMapper, NULL);
    if (ERROR_SUCCESS == result)
    {
	DWORD cbstrPref;

	cbstrPref = (lstrlen(pstrPref) + 1) * sizeof(pstrPref[0]);

    if (fOut)
    {
    	result = RegSetSzValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_CONSOLEVOICECOM_PLAYBACK, pstrPref);
    }
    else
    {
    	result = RegSetSzValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_CONSOLEVOICECOM_RECORD, pstrPref);
    }

	if (ERROR_SUCCESS == result)
	{
	    fSuccess = TRUE;
	    result = RegSetDwordValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_PREFERREDONLY, (DWORD)fPrefOnly);
	    if (ERROR_SUCCESS != result) {
		Squirt("wWPCVC: Could not write hkcu\\...\\Sound Mapper\\PreferredOnly");
	    }
	    result = RegSetDwordValue(hkSoundMapper, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, GetCurrentSetupPreferredAudioCount());
	    if (ERROR_SUCCESS != result) {
		Squirt("wWPCVC: Could not write hkcu\\...\\Sound Mapper\\SetupPreferredAudioCount");
	    }
	}
	result = RegCloseKey(hkSoundMapper);
	WinAssert(ERROR_SUCCESS == result);
    }

    NtClose(hkcu);

    return MMSYSERR_NOERROR;
}

BOOL waveReadPersistentConsoleVoiceCom(BOOL fOut, PTSTR *ppstrPref, PBOOL pfPrefOnly, PDWORD pSetupCount)
{
    HKEY hkcu;
    HKEY hkSoundMapper;
    LONG result;
    BOOL fSuccess;

    fSuccess = FALSE;

    *ppstrPref = NULL;
    *pfPrefOnly = FALSE;
    *pSetupCount = 0;

    if (!NT_SUCCESS(RtlOpenCurrentUser(GENERIC_READ, &hkcu))) return FALSE;

    result = RegOpenKeyEx(hkcu, REGSTR_PATH_MULTIMEDIA_SOUNDMAPPER, 0, KEY_QUERY_VALUE, &hkSoundMapper);
    if (ERROR_SUCCESS == result)
    {
	DWORD SetupCount;

	result = RegQueryDwordValue(hkSoundMapper, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, &SetupCount);
	SetupCount = (ERROR_SUCCESS == result) ? SetupCount : 0;
	if (ERROR_SUCCESS == result)
	{
	    PTSTR pstrPref;
	    BOOL fPrefOnly;
	    DWORD dwPrefOnly;

	    result = RegQueryDwordValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_PREFERREDONLY, &dwPrefOnly);
	    fPrefOnly = (ERROR_SUCCESS == result) ? (0 != dwPrefOnly) : FALSE;

            if (fOut)
            {
                result = RegQuerySzValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_CONSOLEVOICECOM_PLAYBACK, &pstrPref);
            }
            else
            {
                result = RegQuerySzValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_CONSOLEVOICECOM_RECORD, &pstrPref);
            }
    
	    if (ERROR_SUCCESS != result) pstrPref = NULL;

	    *ppstrPref = pstrPref;
	    *pfPrefOnly = fPrefOnly;
	    *pSetupCount = SetupCount;
	    fSuccess = TRUE;
	}
	result = RegCloseKey(hkSoundMapper);
	WinAssert(ERROR_SUCCESS == result);
    }

    NtClose(hkcu);

    return fSuccess;
}

MMRESULT wavePickBestConsoleVoiceComId(BOOL fOut, PUINT pPrefId, PDWORD pdwFlags)
{
    PTSTR pstrPref;
    UINT cWaveId;
    UINT WaveId;
    UINT UserSelectedId;
    UINT NonConsoleId;
    UINT PreferredId;
    DWORD UserSelectedIdSetupCount;
    BOOL fPrefOnly;
    BOOL f;

    UserSelectedId = WAVE_MAPPER;

    if (fOut)
    {
    	waveOutGetCurrentPreferredId(&NonConsoleId, NULL);
    	
        cWaveId = waveOutGetNumDevs();

        waveReadPersistentConsoleVoiceCom(fOut, &pstrPref, &fPrefOnly, &UserSelectedIdSetupCount);

        *pdwFlags = fPrefOnly ? DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY : 0;

        for (WaveId = cWaveId-1; ((int)WaveId) >= 0; WaveId--)
        {
	    WAVEOUTCAPS wc;
	    MMRESULT mmr;

	    mmr = waveOutGetDevCaps(WaveId, &wc, sizeof(wc));
	    if (mmr) continue;

	    wc.szPname[MAXPNAMELEN-1] = TEXT('\0');

	    if (pstrPref && !lstrcmp(wc.szPname, pstrPref))
            {
                UserSelectedId = WaveId;
                break;
            }
        }
    }
    else
    {
    	waveInGetCurrentPreferredId(&NonConsoleId, NULL);
    	
        cWaveId = waveInGetNumDevs();

        waveReadPersistentConsoleVoiceCom(fOut, &pstrPref, &fPrefOnly, &UserSelectedIdSetupCount);

        *pdwFlags = fPrefOnly ? DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY : 0;

        for (WaveId = cWaveId-1; ((int)WaveId) >= 0; WaveId--)
        {
            WAVEINCAPS wc;
            MMRESULT mmr;

            mmr = waveInGetDevCaps(WaveId, &wc, sizeof(wc));
            if (mmr) continue;

            wc.szPname[MAXPNAMELEN-1] = TEXT('\0');

            if (pstrPref && !lstrcmp(wc.szPname, pstrPref))
            {
                UserSelectedId = WaveId;
                break;
            }
        }
    }

    if (pstrPref) {
	f = HeapFree(hHeap, 0, pstrPref);
	WinAssert(f);
	pstrPref = NULL;
    }

    PreferredId = ((WAVE_MAPPER == UserSelectedId)?NonConsoleId:UserSelectedId);

    *pPrefId = PreferredId;
    return MMSYSERR_NOERROR;
}

//------------------------------------------------------------------------------
//
//
//	WaveOut
//
//
//------------------------------------------------------------------------------

DWORD waveOutGetSetupPreferredAudioCount(UINT WaveId)
{
    PCWSTR DeviceInterface;
    DWORD dwCount;

    DeviceInterface = waveReferenceDevInterfaceById(&waveoutdrvZ, WaveId);

    if(DeviceInterface == NULL) {
        return 0;
    }

    dwCount = GetDeviceInterfaceSetupPreferredAudioCount(DeviceInterface);
    wdmDevInterfaceDec(DeviceInterface);
    return dwCount;
}

MMRESULT waveOutSendPreferredMessage(BOOL fClear)
{
    PCWSTR DeviceInterface;
    UINT WaveId, Flags;
    MMRESULT mmr;

    if(!gfLogon) {
        return MMSYSERR_NOERROR;
    }

    waveOutGetCurrentPreferredId(&WaveId, &Flags);

    //Squirt("waveOutSendPreferredMessage: id %d f %d", WaveId, fClear);

    if(WaveId == WAVE_MAPPER) {
        return MMSYSERR_NOERROR;
    }

    DeviceInterface = waveReferenceDevInterfaceById(&waveoutdrvZ, WaveId);

    if(DeviceInterface == NULL) {
        return MMSYSERR_NOERROR;
    }

    gfWaveOutPreferredMessageSent = TRUE;

    mmr = waveOutMessage((HWAVEOUT)(UINT_PTR)WaveId, WODM_PREFERRED, (DWORD_PTR)fClear, (DWORD_PTR)DeviceInterface);
    wdmDevInterfaceDec(DeviceInterface);
    return mmr;
}

BOOL waveOutReadPersistentPref(PTSTR *ppstrPref, PBOOL pfPrefOnly, PDWORD pSetupCount)
{
    HKEY hkcu;
    HKEY hkSoundMapper;
    LONG result;
    BOOL fSuccess;

    fSuccess = FALSE;

    *ppstrPref = NULL;
    *pfPrefOnly = FALSE;
    *pSetupCount = 0;

    if (!NT_SUCCESS(RtlOpenCurrentUser(GENERIC_READ, &hkcu))) return FALSE;

    result = RegOpenKeyEx(hkcu, REGSTR_PATH_MULTIMEDIA_SOUNDMAPPER, 0, KEY_QUERY_VALUE, &hkSoundMapper);
    if (ERROR_SUCCESS == result)
    {
	DWORD SetupCount;

	result = RegQueryDwordValue(hkSoundMapper, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, &SetupCount);
	SetupCount = (ERROR_SUCCESS == result) ? SetupCount : 0;
	if (ERROR_SUCCESS == result)
	{
	    PTSTR pstrPref;
	    BOOL fPrefOnly;
	    DWORD dwPrefOnly;

	    result = RegQueryDwordValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_PREFERREDONLY, &dwPrefOnly);
	    fPrefOnly = (ERROR_SUCCESS == result) ? (0 != dwPrefOnly) : FALSE;

	    result = RegQuerySzValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_PLAYBACK, &pstrPref);
	    if (ERROR_SUCCESS != result) pstrPref = NULL;

	    *ppstrPref = pstrPref;
	    *pfPrefOnly = fPrefOnly;
	    *pSetupCount = SetupCount;
	    fSuccess = TRUE;
	}
	result = RegCloseKey(hkSoundMapper);
	WinAssert(ERROR_SUCCESS == result);
    }

    NtClose(hkcu);

    return fSuccess;
}

MMRESULT waveOutPickBestId(PUINT pPrefId, PDWORD pdwFlags)
{
    PTSTR pstrPref;
    UINT cWaveId;
    UINT WaveId;
    UINT MappableId;
    UINT MixableId;
    UINT UserSelectedId;
    UINT PreferredId;
    DWORD WaveIdSetupCount;
    DWORD MappableIdSetupCount;
    DWORD MixableIdSetupCount;
    DWORD UserSelectedIdSetupCount;
    DWORD PreferredIdSetupCount;
    BOOL fPrefOnly;
    BOOL f;


    MappableId = WAVE_MAPPER;
    MixableId = WAVE_MAPPER;
    UserSelectedId = WAVE_MAPPER;
    PreferredId = WAVE_MAPPER;

    MappableIdSetupCount = 0;
    MixableIdSetupCount = 0;
    UserSelectedIdSetupCount = 0;
    PreferredIdSetupCount = 0;

    cWaveId = waveOutGetNumDevs();

    waveOutReadPersistentPref(&pstrPref, &fPrefOnly, &UserSelectedIdSetupCount);

    *pdwFlags = fPrefOnly ? DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY : 0;

    for (WaveId = cWaveId-1; ((int)WaveId) >= 0; WaveId--)
    {
    	WAVEOUTCAPS wc;
    	UINT uMixerId;
    	MMRESULT mmr;
        PWAVEDRV pdrv;
        BOOL fThisSession;

        //
        // check the protocol name
        //  mask all inappropriate TS/non-TS drivers
        //
        if (waveReferenceDriverById(&waveoutdrvZ, WaveId, &pdrv, NULL)) continue;
        fThisSession = !lstrcmpW(pdrv->wszSessProtocol, SessionProtocolName);
        mregDecUsagePtr(pdrv);
        if (!fThisSession) continue;

    	mmr = waveOutGetDevCaps(WaveId, &wc, sizeof(wc));
    	if (mmr) continue;

    	wc.szPname[MAXPNAMELEN-1] = TEXT('\0');

    	if (pstrPref && !lstrcmp(wc.szPname, pstrPref)) UserSelectedId = WaveId;

    	WaveIdSetupCount = waveOutGetSetupPreferredAudioCount(WaveId);

    	mmr = waveOutMessage((HWAVEOUT)(UINT_PTR)WaveId, DRV_QUERYMAPPABLE, 0L, 0L);
    	if (mmr) continue;

    	if (WaveIdSetupCount >= MappableIdSetupCount) {
    	    MappableId = WaveId;
    	    MappableIdSetupCount = WaveIdSetupCount;
    	}

    	mmr = mixerGetID((HMIXEROBJ)(UINT_PTR)WaveId, &uMixerId, MIXER_OBJECTF_WAVEOUT);
    	if (mmr) continue;

    	if (WaveIdSetupCount >= MixableIdSetupCount) {
    	    MixableId = WaveId;
    	    MixableIdSetupCount = WaveIdSetupCount;
    	}
    }

    if (pstrPref) {
    	f = HeapFree(hHeap, 0, pstrPref);
    	WinAssert(f);
    	pstrPref = NULL;
    }

    PreferredId = MappableId;
    PreferredIdSetupCount = MappableIdSetupCount;
    if ((MixableIdSetupCount >= PreferredIdSetupCount) && (WAVE_MAPPER != MixableId))
    {
    	PreferredId = MixableId;
    	PreferredIdSetupCount = MixableIdSetupCount;
    }
    if ((UserSelectedIdSetupCount >= PreferredIdSetupCount) && (WAVE_MAPPER != UserSelectedId))
    {
    	PreferredId = UserSelectedId;
    	PreferredIdSetupCount = UserSelectedIdSetupCount;
    }

    *pPrefId = PreferredId;
    return MMSYSERR_NOERROR;
}

void waveOutGetCurrentPreferredId(PUINT pPrefId, PDWORD pdwFlags)
{
    *pPrefId = WAVE_MAPPER;
    if (pdwFlags) *pdwFlags = gfUsePreferredWaveOnly ? DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY : 0;
    if (gpstrWoDefaultStringId) mregGetIdFromStringId(&waveoutdrvZ, gpstrWoDefaultStringId, pPrefId);
    return;
}

BOOL waveOutWritePersistentPref(PTSTR pstrPref, BOOL fPrefOnly)
{
    HKEY hkcu;
    HKEY hkSoundMapper;
    LONG result;
    BOOL fSuccess;

    if (!NT_SUCCESS(RtlOpenCurrentUser(GENERIC_WRITE, &hkcu))) return MMSYSERR_WRITEERROR;

    result = RegCreateKeyEx(hkcu, REGSTR_PATH_MULTIMEDIA_SOUNDMAPPER, 0, TEXT("\0"), REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hkSoundMapper, NULL);
    if (ERROR_SUCCESS == result)
    {
	DWORD cbstrPref;

	cbstrPref = (lstrlen(pstrPref) + 1) * sizeof(pstrPref[0]);
	result = RegSetSzValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_PLAYBACK, pstrPref);
	if (ERROR_SUCCESS == result)
	{
	    fSuccess = TRUE;
	    result = RegSetDwordValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_PREFERREDONLY, (DWORD)fPrefOnly);
	    if (ERROR_SUCCESS != result) {
		Squirt("wOWPP: Could not write hkcu\\...\\Sound Mapper\\PreferredOnly");
	    }
	    result = RegSetDwordValue(hkSoundMapper, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, GetCurrentSetupPreferredAudioCount());
	    if (ERROR_SUCCESS != result) {
		Squirt("wOWPP: Could not write hkcu\\...\\Sound Mapper\\SetupPreferredAudioCount");
	    }
	}
	result = RegCloseKey(hkSoundMapper);
	WinAssert(ERROR_SUCCESS == result);
    }

    NtClose(hkcu);

    return MMSYSERR_NOERROR;
}

MMRESULT waveOutSetCurrentPreferredId(UINT PrefId, DWORD dwFlags)
{
    MMRESULT mmr;
    WinAssert(PrefId < wTotalWaveOutDevs || PrefId == WAVE_MAPPER);

    mmr = MMSYSERR_NOERROR;

    if (gpstrWoDefaultStringId) HeapFree(hHeap, 0, gpstrWoDefaultStringId);
    gpstrWoDefaultStringId = NULL;
    
    if (wTotalWaveOutDevs)
    {
    	UINT mixerId;
        PWAVEDRV pwavedrv;
        UINT port;
            
        mmr = waveReferenceDriverById(&waveoutdrvZ, PrefId, &pwavedrv, &port);
    	if (!mmr)
    	{
    	    mmr = mregCreateStringIdFromDriverPort(pwavedrv, port, &gpstrWoDefaultStringId, NULL);
    	    if (!mmr)
    	    {
    	    	if (!gfDisablePreferredDeviceReordering)
    	    	{
                    // Rearrange some of the driver list so that the preferred waveOut
       	            // device and its associated mixer device have a good chance of
        	    // having device ID 0
        	    mmr = mixerGetID((HMIXEROBJ)(UINT_PTR)PrefId, &mixerId, MIXER_OBJECTF_WAVEOUT);
        	    if (mmr) mixerId = 0;
        	 
        	    if (0 != PrefId)
        	    {
                        // Move the wave driver to the head of this list.  This usually
                        // makes the preferred device have ID 0.
        	            EnterNumDevs("waveOutSetCurrentPreferredId");
                        pwavedrv->Prev->Next = pwavedrv->Next;
                        pwavedrv->Next->Prev = pwavedrv->Prev;
                        pwavedrv->Next = waveoutdrvZ.Next;
                        pwavedrv->Prev = &waveoutdrvZ;
                        waveoutdrvZ.Next->Prev = pwavedrv;
                        waveoutdrvZ.Next = pwavedrv;
                        LeaveNumDevs("waveOutSetCurrentPreferredId");
    
                        mregDecUsagePtr(pwavedrv);
        	    }
        	        
                    if (0 != mixerId)
                    {
                        PMIXERDRV pmixerdrv;
                
                        mmr = mixerReferenceDriverById(mixerId, &pmixerdrv, NULL);
                        if (!mmr)
                        {
			    EnterNumDevs("waveOutSetCurrentPreferredId");
			    pmixerdrv->Prev->Next = pmixerdrv->Next;
                	    pmixerdrv->Next->Prev = pmixerdrv->Prev;
                	    pmixerdrv->Next = mixerdrvZ.Next;
                	    pmixerdrv->Prev = &mixerdrvZ;
                	    mixerdrvZ.Next->Prev = pmixerdrv;
                	    mixerdrvZ.Next = pmixerdrv;
                            LeaveNumDevs("waveOutSetCurrentPreferredId");
    
                	    mregDecUsagePtr(pmixerdrv);
                        }
                    }
    	    	}

                // Errors in this body are not critical
                mmr = MMSYSERR_NOERROR;
    	    }
    	}    	    
    }

    if (!mmr)
    {
        gfUsePreferredWaveOnly = (0 != (dwFlags & DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY));

        // Reconfigure the mapper only if it was already loaded.  Don't cause it to
        // load simply so that we can reconfigure it!
        if (WaveMapperInitialized) waveOutMessage((HWAVEOUT)(UINT_PTR)WAVE_MAPPER, DRVM_MAPPER_RECONFIGURE, 0, 0);
    }

    return mmr;
}

MMRESULT waveOutSetPersistentPreferredId(UINT PrefId, DWORD dwFlags)
{
    MMRESULT mmr;
    WAVEOUTCAPS woc;

    if (0 != (dwFlags & ~DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY)) return MMSYSERR_INVALPARAM;
    
    mmr = waveOutGetDevCaps(PrefId, &woc, sizeof(woc));
    if (!mmr)
    {
	woc.szPname[MAXPNAMELEN-1] = TEXT('\0');
	mmr = waveOutWritePersistentPref(woc.szPname, 0 != (dwFlags & 0x00000001));
	if (!mmr) {
	    NotifyServerPreferredDeviceChange();
	} else {
	    Squirt("waveOutSetPersistentPreferredId: waveOutWritePersistenPref failed, mmr=%08Xh", mmr);
	}	    
    }

    return mmr;
}

void waveOutGetCurrentConsoleVoiceComId(PUINT pPrefId, PDWORD pdwFlags)
{
    *pPrefId = WAVE_MAPPER;
    *pdwFlags = gfUsePreferredWaveOnly ? DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY : 0;
    if (gpstrWoConsoleVoiceComStringId) mregGetIdFromStringId(&waveoutdrvZ, gpstrWoConsoleVoiceComStringId, pPrefId);
    return;
}

MMRESULT waveOutSetPersistentConsoleVoiceComId(UINT PrefId, DWORD dwFlags)
{
    MMRESULT mmr;
    WAVEOUTCAPS woc;

    if (0 != (dwFlags & ~DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY)) return MMSYSERR_INVALPARAM;
    
    mmr = waveOutGetDevCaps(PrefId, &woc, sizeof(woc));
    if (!mmr)
    {
	woc.szPname[MAXPNAMELEN-1] = TEXT('\0');
	mmr = waveWritePersistentConsoleVoiceCom(TRUE, woc.szPname, 0 != (dwFlags & 0x00000001));
	if (!mmr) {
	    NotifyServerPreferredDeviceChange();
	} else {
	    Squirt("waveOutSetPersistentConsoleVoiceComId: waveWritePersistentConsoleVoiceCom failed, mmr=%08Xh", mmr);
	}	    
    }

    return mmr;
}

MMRESULT waveOutSetCurrentConsoleVoiceComId(UINT PrefId, DWORD dwFlags)
{
    MMRESULT mmr;

    WinAssert(PrefId < wTotalWaveOutDevs || PrefId == WAVE_MAPPER);

    mmr = MMSYSERR_NOERROR;

    if (gpstrWoConsoleVoiceComStringId) HeapFree(hHeap, 0, gpstrWoConsoleVoiceComStringId);
    gpstrWoConsoleVoiceComStringId = NULL;
    
    if (wTotalWaveOutDevs)
    {
        PWAVEDRV pwavedrv;
        UINT port;
            
        mmr = waveReferenceDriverById(&waveoutdrvZ, PrefId, &pwavedrv, &port);
    	if (!mmr)
    	{
    	    mregCreateStringIdFromDriverPort(pwavedrv, port, &gpstrWoConsoleVoiceComStringId, NULL);
            gfUsePreferredWaveOnly = (0 != (dwFlags & DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY));
    	}    	    
    }

    return mmr;
}

//------------------------------------------------------------------------------
//
//
//	WaveIn
//
//
//------------------------------------------------------------------------------

DWORD waveInGetSetupPreferredAudioCount(UINT WaveId)
{
    PCWSTR DeviceInterface;
    DWORD dwCount;

    DeviceInterface = waveReferenceDevInterfaceById(&waveindrvZ, WaveId);

    if(DeviceInterface == NULL) {
        return 0;
    }

    dwCount = GetDeviceInterfaceSetupPreferredAudioCount(DeviceInterface);
    wdmDevInterfaceDec(DeviceInterface);
    return dwCount;
}

MMRESULT waveInSendPreferredMessage(BOOL fClear)
{
    PCWSTR DeviceInterface;
    UINT WaveId, Flags;
    MMRESULT mmr;

    if(!gfLogon) {
        return MMSYSERR_NOERROR;
    }

    waveInGetCurrentPreferredId(&WaveId, &Flags);

    //Squirt("waveInSendPreferredMessage: id %d f %d", WaveId, fClear);

    if(WaveId == WAVE_MAPPER) {
        return MMSYSERR_NOERROR;
    }

    DeviceInterface = waveReferenceDevInterfaceById(&waveindrvZ, WaveId);

    if(DeviceInterface == NULL) {
        return MMSYSERR_NOERROR;
    }

    gfWaveInPreferredMessageSent = TRUE;

    mmr = waveInMessage((HWAVEIN)(UINT_PTR)WaveId, WIDM_PREFERRED, (DWORD_PTR)fClear, (DWORD_PTR)DeviceInterface);
    wdmDevInterfaceDec(DeviceInterface);
    return mmr;
}

BOOL waveInReadPersistentPref(PTSTR *ppstrPref, PBOOL pfPrefOnly, PDWORD pSetupCount)
{
    HKEY hkcu;
    HKEY hkSoundMapper;
    LONG result;
    BOOL fSuccess;

    fSuccess = FALSE;
    
    *ppstrPref = NULL;
    *pfPrefOnly = FALSE;
    *pSetupCount = 0;

    if (!NT_SUCCESS(RtlOpenCurrentUser(GENERIC_READ, &hkcu))) return FALSE;

    result = RegOpenKeyEx(hkcu, REGSTR_PATH_MULTIMEDIA_SOUNDMAPPER, 0, KEY_QUERY_VALUE, &hkSoundMapper);
    if (ERROR_SUCCESS == result)
    {
	DWORD SetupCount;

	result = RegQueryDwordValue(hkSoundMapper, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, &SetupCount);
	SetupCount = (ERROR_SUCCESS == result) ? SetupCount : 0;
	if (ERROR_SUCCESS == result)
	{
	    PTSTR pstrPref;
	    BOOL fPrefOnly;
	    DWORD dwPrefOnly;

	    result = RegQueryDwordValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_PREFERREDONLY, &dwPrefOnly);
	    fPrefOnly = (ERROR_SUCCESS == result) ? (0 != dwPrefOnly) : FALSE;

	    result = RegQuerySzValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_RECORD, &pstrPref);
	    if (ERROR_SUCCESS != result) pstrPref = NULL;

	    *ppstrPref = pstrPref;
	    *pfPrefOnly = fPrefOnly;
	    *pSetupCount = SetupCount;
	    fSuccess = TRUE;
	}
	result = RegCloseKey(hkSoundMapper);
	WinAssert(ERROR_SUCCESS == result);
    }

    NtClose(hkcu);

    return fSuccess;
}

MMRESULT waveInPickBestId(PUINT pPrefId, PDWORD pdwFlags)
{
    PTSTR pstrPref;
    UINT cWaveId;
    UINT WaveId;
    UINT MappableId;
    UINT MixableId;
    UINT UserSelectedId;
    UINT PreferredId;
    DWORD WaveIdSetupCount;
    DWORD MappableIdSetupCount;
    DWORD MixableIdSetupCount;
    DWORD UserSelectedIdSetupCount;
    DWORD PreferredIdSetupCount;
    BOOL fPrefOnly;
    BOOL f;

    
    MappableId = WAVE_MAPPER;
    MixableId = WAVE_MAPPER;
    UserSelectedId = WAVE_MAPPER;
    PreferredId = WAVE_MAPPER;
    
    MappableIdSetupCount = 0;
    MixableIdSetupCount = 0;
    UserSelectedIdSetupCount = 0;
    PreferredIdSetupCount = 0;
    
    cWaveId = waveInGetNumDevs();

    waveInReadPersistentPref(&pstrPref, &fPrefOnly, &UserSelectedIdSetupCount);

    *pdwFlags = fPrefOnly ? DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY : 0;

    for (WaveId = cWaveId-1; ((int)WaveId) >= 0; WaveId--)
    {
	WAVEINCAPS wic;
	UINT uMixerId;
	MMRESULT mmr;

	mmr = waveInGetDevCaps(WaveId, &wic, sizeof(wic));
	if (MMSYSERR_NOERROR != mmr) continue;

	wic.szPname[MAXPNAMELEN-1] = TEXT('\0');

	if (pstrPref && !lstrcmp(wic.szPname, pstrPref)) UserSelectedId = WaveId;

	WaveIdSetupCount = waveInGetSetupPreferredAudioCount(WaveId);

	mmr = waveInMessage((HWAVEIN)(UINT_PTR)WaveId, DRV_QUERYMAPPABLE, 0L, 0L);
	if (MMSYSERR_NOERROR != mmr) continue;

	if (WaveIdSetupCount >= MappableIdSetupCount) {
	    MappableId = WaveId;
	    MappableIdSetupCount = WaveIdSetupCount;
	}

	mmr = mixerGetID((HMIXEROBJ)(UINT_PTR)WaveId, &uMixerId, MIXER_OBJECTF_WAVEIN);
	if (MMSYSERR_NOERROR != mmr) continue;

	if (WaveIdSetupCount >= MixableIdSetupCount) {
	    MixableId = WaveId;
	    MixableIdSetupCount = WaveIdSetupCount;
	}
    }

    if (pstrPref) {
	f = HeapFree(hHeap, 0, pstrPref);
	WinAssert(f);
	pstrPref = NULL;
    }

    PreferredId = MappableId;
    PreferredIdSetupCount = MappableIdSetupCount;
    if ((MixableIdSetupCount >= PreferredIdSetupCount) && (WAVE_MAPPER != MixableId)) {
	PreferredId = MixableId;
	PreferredIdSetupCount = MixableIdSetupCount;
    }
    if ((UserSelectedIdSetupCount >= PreferredIdSetupCount) && (WAVE_MAPPER != UserSelectedId))
    {
	PreferredId = UserSelectedId;
	PreferredIdSetupCount = UserSelectedIdSetupCount;
    }

    *pPrefId = PreferredId;
    
    return MMSYSERR_NOERROR;
}

void waveInGetCurrentPreferredId(PUINT pPrefId, PDWORD pdwFlags)
{
    *pPrefId = WAVE_MAPPER;
    if (pdwFlags) *pdwFlags = gfUsePreferredWaveOnly ? DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY : 0;
    if (gpstrWiDefaultStringId) mregGetIdFromStringId(&waveindrvZ, gpstrWiDefaultStringId, pPrefId);
    return;
}

BOOL waveInWritePersistentPref(PTSTR pstrPref, BOOL fPrefOnly)
{
    HKEY hkcu;
    HKEY hkSoundMapper;
    LONG result;
    BOOL fSuccess;

    if (!NT_SUCCESS(RtlOpenCurrentUser(GENERIC_WRITE, &hkcu))) return MMSYSERR_WRITEERROR;

    result = RegCreateKeyEx(hkcu, REGSTR_PATH_MULTIMEDIA_SOUNDMAPPER, 0, TEXT("\0"), REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hkSoundMapper, NULL);
    if (ERROR_SUCCESS == result)
    {
	DWORD cbstrPref;

	cbstrPref = (lstrlen(pstrPref) + 1) * sizeof(pstrPref[0]);
	result = RegSetSzValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_RECORD, pstrPref);
	if (ERROR_SUCCESS == result)
	{
	    fSuccess = TRUE;
	    result = RegSetDwordValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_PREFERREDONLY, (DWORD)fPrefOnly);
	    if (ERROR_SUCCESS != result) {
		Squirt("wiWPP: Could not write hkcu\\...\\Sound Mapper\\PreferredOnly");
	    }
	    result = RegSetDwordValue(hkSoundMapper, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, GetCurrentSetupPreferredAudioCount());
	    if (ERROR_SUCCESS != result) {
		Squirt("wiWPP: Could not write hkcu\\...\\Sound Mapper\\SetupPreferredAudioCount");
	    }
	}
	result = RegCloseKey(hkSoundMapper);
	WinAssert(ERROR_SUCCESS == result);
    }

    NtClose(hkcu);

    return MMSYSERR_NOERROR;
}

MMRESULT waveInSetCurrentPreferredId(UINT PrefId, DWORD dwFlags)
{
    MMRESULT mmr;
    WinAssert(PrefId < wTotalWaveInDevs || PrefId == WAVE_MAPPER);

    mmr = MMSYSERR_NOERROR;

    if (gpstrWiDefaultStringId) HeapFree(hHeap, 0, gpstrWiDefaultStringId);
    gpstrWiDefaultStringId = NULL;
    
    if (wTotalWaveInDevs)
    {
        PWAVEDRV pwavedrv;
        UINT port;
            
        mmr = waveReferenceDriverById(&waveindrvZ, PrefId, &pwavedrv, &port);
    	if (!mmr)
    	{
    	    mmr = mregCreateStringIdFromDriverPort(pwavedrv, port, &gpstrWiDefaultStringId, NULL);
    	    if (!mmr)
    	    {
    	    	if (!gfDisablePreferredDeviceReordering)
    	    	{
                    // Rearrange some of the driver list so that the preferred waveIn
        	    // device has a good chance of having device ID 0
        	    if (0 != PrefId)
        	    {
                        // Move the wave driver to the head of this list.  This usually
                        // makes the preferred device have ID 0.
        	            EnterNumDevs("waveInSetCurrentPreferredId");
                        pwavedrv->Prev->Next = pwavedrv->Next;
                        pwavedrv->Next->Prev = pwavedrv->Prev;
                        pwavedrv->Next = waveindrvZ.Next;
                        pwavedrv->Prev = &waveindrvZ;
                        waveindrvZ.Next->Prev = pwavedrv;
                        waveindrvZ.Next = pwavedrv;
                        LeaveNumDevs("waveInSetCurrentPreferredId");
    
                        mregDecUsagePtr(pwavedrv);
        	    }
    	    	}
    	    }
    	}    	    
    }

    if (!mmr)
    {
        gfUsePreferredWaveOnly = (0 != (dwFlags & DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY));

        // Reconfigure the mapper only if it was already loaded.  Don't cause it to
        // load simply so that we can reconfigure it!
        if (WaveMapperInitialized) waveInMessage((HWAVEIN)(UINT_PTR)WAVE_MAPPER, DRVM_MAPPER_RECONFIGURE, 0, 0);
    }

    return mmr;
}

MMRESULT waveInSetPersistentPreferredId(UINT PrefId, DWORD dwFlags)
{
    MMRESULT mmr;
    WAVEINCAPS wc;

    if (0 != (dwFlags & ~DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY)) return MMSYSERR_INVALPARAM;

    mmr = waveInGetDevCaps(PrefId, &wc, sizeof(wc));
    if (!mmr)
    {
	wc.szPname[MAXPNAMELEN-1] = TEXT('\0');
	mmr = waveInWritePersistentPref(wc.szPname, 0 != (dwFlags & DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY));
	if (!mmr) {
	    NotifyServerPreferredDeviceChange();
	} else {
	    Squirt("waveInSetPersistentPreferredId: waveInWritePersistenPref failed, mmr=%08Xh", mmr);
	}	    
    }

    return mmr;
}

void waveInGetCurrentConsoleVoiceComId(PUINT pPrefId, PDWORD pdwFlags)
{
    *pPrefId = WAVE_MAPPER;
    *pdwFlags = gfUsePreferredWaveOnly ? DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY : 0;
    if (gpstrWiConsoleVoiceComStringId) mregGetIdFromStringId(&waveindrvZ, gpstrWiConsoleVoiceComStringId, pPrefId);
    return;
}

MMRESULT waveInSetPersistentConsoleVoiceComId(UINT PrefId, DWORD dwFlags)
{
    MMRESULT mmr;
    WAVEINCAPS wic;

    if (0 != (dwFlags & ~DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY)) return MMSYSERR_INVALPARAM;
    
    mmr = waveInGetDevCaps(PrefId, &wic, sizeof(wic));
    if (!mmr)
    {
	wic.szPname[MAXPNAMELEN-1] = TEXT('\0');
	mmr = waveWritePersistentConsoleVoiceCom(FALSE, wic.szPname, 0 != (dwFlags & 0x00000001));
	if (!mmr) {
	    NotifyServerPreferredDeviceChange();
	} else {
	    Squirt("waveInSetPersistentConsoleVoiceComId: waveWritePersistentConsoleVoiceCom failed, mmr=%08Xh", mmr);
	}	    
    }

    return mmr;
}

MMRESULT waveInSetCurrentConsoleVoiceComId(UINT PrefId, DWORD dwFlags)
{
    MMRESULT mmr;

    WinAssert(PrefId < wTotalWaveInDevs || PrefId == WAVE_MAPPER);

    mmr = MMSYSERR_NOERROR;

    if (gpstrWiConsoleVoiceComStringId) HeapFree(hHeap, 0, gpstrWiConsoleVoiceComStringId);
    gpstrWiConsoleVoiceComStringId = NULL;
    
    if (wTotalWaveInDevs)
    {
        PWAVEDRV pwavedrv;
        UINT port;
            
        mmr = waveReferenceDriverById(&waveindrvZ, PrefId, &pwavedrv, &port);
    	if (!mmr)
    	{
    	    mregCreateStringIdFromDriverPort(pwavedrv, port, &gpstrWiConsoleVoiceComStringId, NULL);
            gfUsePreferredWaveOnly = (0 != (dwFlags & DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY));
    	}    	    
    }

    return mmr;
}


//------------------------------------------------------------------------------
//
//
//	MidiOut
//
//
//------------------------------------------------------------------------------

DWORD midiOutGetSetupPreferredAudioCount(UINT MidiId)
{
    PCWSTR DeviceInterface;
    DWORD dwCount;

    DeviceInterface = midiReferenceDevInterfaceById(&midioutdrvZ, MidiId);

    if(DeviceInterface == NULL) {
        return 0;
    }

    dwCount = GetDeviceInterfaceSetupPreferredAudioCount(DeviceInterface);
    wdmDevInterfaceDec(DeviceInterface);
    return dwCount;
}

MMRESULT midiOutSendPreferredMessage(BOOL fClear)
{
    PCWSTR DeviceInterface;
    UINT MidiId;
    MMRESULT mmr;

    if(!gfLogon) {
        return MMSYSERR_NOERROR;
    }

    midiOutGetCurrentPreferredId(&MidiId, NULL);

    if(MidiId == WAVE_MAPPER) {
        return MMSYSERR_NOERROR;
    }

    DeviceInterface = midiReferenceDevInterfaceById(&midioutdrvZ, MidiId);

    if(DeviceInterface == NULL) {
        return MMSYSERR_NOERROR;
    }

    gfMidiOutPreferredMessageSent = TRUE;

    mmr = midiOutMessage((HMIDIOUT)(UINT_PTR)MidiId, MODM_PREFERRED, (DWORD_PTR)fClear, (DWORD_PTR)DeviceInterface);
    wdmDevInterfaceDec(DeviceInterface);
    return mmr;
}

MMRESULT midiOutWritePersistentPref(IN UINT MidiOutId, IN ULONG SetupCount)
{
    HKEY hkMidiMapper;
    HKEY hkcu;
    MIDIOUTCAPS moc;
    DWORD dwDisposition;
    LONG result;
    MMRESULT mmr;

    mmr = midiOutGetDevCaps(MidiOutId, &moc, sizeof(moc));
    if (MMSYSERR_NOERROR != mmr) return mmr;

    if (!NT_SUCCESS(RtlOpenCurrentUser(GENERIC_ALL, &hkcu))) return MMSYSERR_WRITEERROR;

    result = RegCreateKeyEx(hkcu, REGSTR_PATH_MULTIMEDIA_MIDIMAP, 0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_QUERY_VALUE, NULL, &hkMidiMapper, &dwDisposition);
    if (ERROR_SUCCESS == result)
    {
        PCWSTR pstrDeviceInterface;
        UINT RelativeIndex;

        pstrDeviceInterface = midiReferenceDevInterfaceById(&midioutdrvZ, MidiOutId);
        if (pstrDeviceInterface) {
            UINT i;
            RelativeIndex = 0;
            for (i = 0; i < MidiOutId; i++) {
                PCWSTR pstr = midiReferenceDevInterfaceById(&midioutdrvZ, i);
                if (pstr && !lstrcmpi(pstrDeviceInterface, pstr)) RelativeIndex++;
                if (pstr) wdmDevInterfaceDec(pstr);
            }
        } else {
            RelativeIndex = 0;
        }

        result = RegSetSzValue(hkMidiMapper, REGSTR_VAL_MULTIMEDIA_MIDIMAP_SZPNAME, moc.szPname);
        if (ERROR_SUCCESS == result) result = RegSetDwordValue(hkMidiMapper, REGSTR_VAL_MULTIMEDIA_MIDIMAP_RELATIVEINDEX, RelativeIndex);
        if (ERROR_SUCCESS == result) result = RegSetSzValue(hkMidiMapper, REGSTR_VAL_MULTIMEDIA_MIDIMAP_DEVICEINTERFACE, pstrDeviceInterface ? pstrDeviceInterface : TEXT(""));
        if (ERROR_SUCCESS == result) result = RegSetDwordValue(hkMidiMapper, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, SetupCount);
        if (ERROR_SUCCESS == result) RegDeleteValue(hkMidiMapper, REGSTR_VAL_MULTIMEDIA_MIDIMAP_CURRENTINSTRUMENT);

        if (pstrDeviceInterface) wdmDevInterfaceDec(pstrDeviceInterface);
        RegCloseKey(hkMidiMapper);
    }

    if (ERROR_SUCCESS != result) mmr = MMSYSERR_WRITEERROR;

    NtClose(hkcu);
    return mmr;
}

MMRESULT midiOutGetIdFromName(IN PTSTR pstrName, OUT UINT *pMidiOutId)
{
    UINT MidiOutId;
    UINT cMidiOutId;
    MMRESULT mmr;

    cMidiOutId = midiOutGetNumDevs();
    for (MidiOutId = 0; MidiOutId < cMidiOutId; MidiOutId++)
    {
        MIDIOUTCAPS moc;
        mmr = midiOutGetDevCaps(MidiOutId, &moc, sizeof(moc));
        if (MMSYSERR_NOERROR == mmr)
        {
            if (!lstrcmp(pstrName, moc.szPname))
            {
                mmr = MMSYSERR_NOERROR;
                break;
            }
        }
    }
    
    if (MidiOutId == cMidiOutId)
    {
        mmr = MMSYSERR_NODRIVER;
    }

    if (MMSYSERR_NOERROR == mmr) *pMidiOutId = MidiOutId;
    return mmr;
}

MMRESULT midiOutGetIdFromDiAndIndex(IN PTSTR pstrDeviceInterface, IN INT RelativeIndex, OUT UINT *pMidiOutId)
{
    UINT cMidiOut;
    UINT MidiOutId;
    MMRESULT mmr;

    mmr = MMSYSERR_NODRIVER;

    cMidiOut = midiOutGetNumDevs();
    if (0 == cMidiOut) return MMSYSERR_NODRIVER;

    for (MidiOutId = 0; MidiOutId < cMidiOut; MidiOutId++) {
        PCWSTR pstr = midiReferenceDevInterfaceById(&midioutdrvZ, MidiOutId);
        if (pstr && !lstrcmpi(pstr, pstrDeviceInterface) && (0 == RelativeIndex--)) {
            *pMidiOutId = MidiOutId;
            wdmDevInterfaceDec(pstr);
            mmr = MMSYSERR_NOERROR;
            break;
        }
        if (pstr) wdmDevInterfaceDec(pstr);
    }

    return mmr;
}

MMRESULT midiOutGetInstrumentDriverData(IN PCTSTR pstrMidiSubkeyName, OUT PTSTR *ppstrDeviceInterface, OUT UINT *pDriverNum, OUT UINT *pPortNum, OUT PTSTR *ppstrPname)
{
    HKEY hkMidi;
    HKEY hkMidiSubkey;
    LONG result;
    MMRESULT mmr;
    BOOL f;

    mmr = MMSYSERR_ERROR;
    
    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_MEDIARESOURCES_MIDI, 0, KEY_QUERY_VALUE, &hkMidi);
    if (ERROR_SUCCESS != result) return MMSYSERR_ERROR;

    result = RegOpenKeyEx(hkMidi, pstrMidiSubkeyName, 0, KEY_QUERY_VALUE, &hkMidiSubkey);
    if (ERROR_SUCCESS == result)
    {
	PTSTR pstrActive;

	result = RegQuerySzValue(hkMidiSubkey, REGSTR_VAL_MEDIARESOURCES_MIDI_SUBKEY_ACTIVE, &pstrActive);
	if (ERROR_SUCCESS == result)
	{
	    PTCHAR pchEnd;
	    
	    BOOL fActive = _tcstol(pstrActive, &pchEnd, 10);
	    
	    f = HeapFree(hHeap, 0, pstrActive);
	    WinAssert(f);
	    
	    if (fActive)
	    {
                PTSTR pstrDeviceInterface = NULL;
                PTSTR pstrPname = NULL;
                DWORD dwDriverNum;
                DWORD dwPortNum;

		result = RegQueryDwordValue(hkMidiSubkey, REGSTR_VAL_MEDIARESOURCES_MIDI_SUBKEY_PHYSDEVID, &dwDriverNum);
		if (ERROR_SUCCESS == result) result = RegQueryDwordValue(hkMidiSubkey, REGSTR_VAL_MEDIARESOURCES_MIDI_SUBKEY_PORT, &dwPortNum);
                if (ERROR_SUCCESS == result) RegQuerySzValue(hkMidiSubkey, REGSTR_VAL_MEDIARESOURCES_MIDI_SUBKEY_DEVICEINTERFACE, &pstrDeviceInterface);
                if (ERROR_SUCCESS == result) RegQuerySzValue(hkMidiSubkey, REGSTR_VAL_MEDIARESOURCES_MIDI_SUBKEY_DESCRIPTION, &pstrPname);

		if (ERROR_SUCCESS == result)
		{
                    *ppstrDeviceInterface = NULL;
                    *ppstrPname = NULL;

                    if (pstrDeviceInterface) {
                        if (lstrlen(pstrDeviceInterface)> 0) {
                            *ppstrDeviceInterface = pstrDeviceInterface;
                        } else {
                            HeapFree(hHeap, 0, pstrDeviceInterface);
                        }
                    }

                    if (pstrPname) {
                        if (lstrlen(pstrPname)> 0) {
                            *ppstrPname = pstrPname;
                        } else {
                            HeapFree(hHeap, 0, pstrPname);
                        }
                    }

		    *pDriverNum = dwDriverNum;
		    *pPortNum = dwPortNum;

		    mmr = MMSYSERR_NOERROR;
		}
	    }
	}
	
	result = RegCloseKey(hkMidiSubkey);
	WinAssert(ERROR_SUCCESS == result);
    }

    result = RegCloseKey(hkMidi);
    WinAssert(ERROR_SUCCESS == result);
    
    return mmr;
}

MMRESULT midiOutGetIdFromInstrument(IN PTSTR pstrMidiKeyName, OUT UINT *outMidiOutId)
{
    PTSTR pstrDeviceInterface, pstrPname;
    UINT DriverNum, PortNum;
    UINT MidiOutId;
    MMRESULT mmr;

    mmr = midiOutGetInstrumentDriverData(pstrMidiKeyName, &pstrDeviceInterface, &DriverNum, &PortNum, &pstrPname);
    if (MMSYSERR_NOERROR == mmr) {
        if (pstrDeviceInterface) {
            mmr = midiOutGetIdFromDiAndIndex(pstrDeviceInterface, PortNum, &MidiOutId);
        } else if (pstrPname) {
            mmr = midiOutGetIdFromName(pstrPname, &MidiOutId);
        } else {
            PMIDIDRV pmidioutdrv = midioutdrvZ.Next;
            UINT DriverNum1 = DriverNum + 1;

            MidiOutId = 0;

            while ((pmidioutdrv != &midioutdrvZ) && (0 < DriverNum1))
            {
            	MidiOutId += pmidioutdrv->NumDevs;
            	DriverNum1--;
            	pmidioutdrv = pmidioutdrv->Next;
            }

            if ((pmidioutdrv != &midioutdrvZ) && (PortNum < pmidioutdrv->NumDevs))
            {
                MidiOutId += PortNum;
            } else {
                MidiOutId = MIDI_MAPPER;
                mmr = MMSYSERR_ERROR;
            }
        }
        if (pstrDeviceInterface) HeapFree(hHeap, 0, pstrDeviceInterface);
        if (pstrPname) HeapFree(hHeap, 0, pstrPname);
    }

    if (MMSYSERR_NOERROR == mmr) {
        MIDIOUTCAPS moc;
	WinAssert(MIDI_MAPPER != MidiOutId);
	mmr = midiOutGetDevCaps(MidiOutId, &moc, sizeof(moc));
    }

    if (MMSYSERR_NOERROR == mmr) *outMidiOutId = MidiOutId;
    return mmr;
}

MMRESULT midiOutReadCurrentInstrument(OUT PTSTR *ppstrCurrentInstrument, OUT DWORD *pSetupCount)
{
    HKEY hkcu;
    HKEY hkMidiMapper;
    LONG result;
    MMRESULT mmr;

    mmr = MMSYSERR_ERROR;
    
    if (!NT_SUCCESS(RtlOpenCurrentUser(GENERIC_READ, &hkcu))) return MMSYSERR_READERROR;

    result = RegOpenKeyEx(hkcu, REGSTR_PATH_MULTIMEDIA_MIDIMAP, 0, KEY_QUERY_VALUE, &hkMidiMapper);
    if (ERROR_SUCCESS == result)
    {
	result = RegQuerySzValue(hkMidiMapper, REGSTR_VAL_MULTIMEDIA_MIDIMAP_CURRENTINSTRUMENT, ppstrCurrentInstrument);
	if (ERROR_SUCCESS == result)
	{
	    DWORD SetupCount;

	    result = RegQueryDwordValue(hkMidiMapper, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, &SetupCount);
	    SetupCount = (ERROR_SUCCESS == result) ? SetupCount : 0;

	    *pSetupCount = SetupCount;
	    mmr = MMSYSERR_NOERROR;
	} else {
	    mmr = MMSYSERR_ERROR;
	}
	result = RegCloseKey(hkMidiMapper);
	WinAssert(ERROR_SUCCESS == result);
    }

    NtClose(hkcu);

    return mmr;
}

MMRESULT midiOutReadPreferredDeviceData(OUT PTSTR *ppstrDeviceInterface, OUT UINT *pRelativeIndex, OUT PTSTR *ppstrPname, OUT ULONG *pSetupCount)
{
    HKEY hkcu;
    HKEY hkMidiMapper;
    LONG result;
    MMRESULT mmr;

    if (!NT_SUCCESS(RtlOpenCurrentUser(GENERIC_READ, &hkcu))) return MMSYSERR_READERROR;

    result = RegOpenKeyEx(hkcu, REGSTR_PATH_MULTIMEDIA_MIDIMAP, 0, KEY_QUERY_VALUE, &hkMidiMapper);
    if (ERROR_SUCCESS == result)
    {
        PTSTR pstrDeviceInterface = NULL;
        PTSTR pstrPname = NULL;
        DWORD dwIndex;
        DWORD dwSetupCount;
        
        // See if we have a Pname.  It is okay not to.
        result = RegQuerySzValue(hkMidiMapper, REGSTR_VAL_MULTIMEDIA_MIDIMAP_SZPNAME, &pstrPname);
        if (ERROR_FILE_NOT_FOUND == result) result = ERROR_SUCCESS;

        // See if we have a device interface + relative index.  It is okay not to.
        if (ERROR_SUCCESS == result) result = RegQueryDwordValue(hkMidiMapper, REGSTR_VAL_MULTIMEDIA_MIDIMAP_RELATIVEINDEX, &dwIndex);
        if (ERROR_SUCCESS == result) result = RegQuerySzValue(hkMidiMapper, REGSTR_VAL_MULTIMEDIA_MIDIMAP_DEVICEINTERFACE, &pstrDeviceInterface);
        if (ERROR_FILE_NOT_FOUND == result) result = ERROR_SUCCESS;

        // The device interface value might be zero length.  Act as thought it
        // doesn't exist in this case.
        if ((ERROR_SUCCESS == result) && (pstrDeviceInterface) && (0 == lstrlen(pstrDeviceInterface)))
        {
            HeapFree(hHeap, 0, pstrDeviceInterface);
            pstrDeviceInterface = NULL;
            dwIndex = 0;
        }

        if (ERROR_SUCCESS != RegQueryDwordValue(hkMidiMapper, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, &dwSetupCount)) {
            dwSetupCount = 0;
        }

        if (ERROR_SUCCESS == result) {
            if (pstrPname || pstrDeviceInterface) {
                *ppstrDeviceInterface = pstrDeviceInterface;
                *ppstrPname = pstrPname;
                *pRelativeIndex = dwIndex;
                *pSetupCount = dwSetupCount;
                mmr = MMSYSERR_NOERROR;
            } else {
                mmr = MMSYSERR_VALNOTFOUND;
            }
        } else {
            mmr = MMSYSERR_READERROR;
        }

        if (MMSYSERR_NOERROR != mmr) {
            if (pstrDeviceInterface) HeapFree(hHeap, 0, pstrDeviceInterface);
            if (pstrPname) HeapFree(hHeap, 0, pstrPname);
        }
            
        RegCloseKey(hkMidiMapper);
    } else {
        if (ERROR_FILE_NOT_FOUND == result) mmr = MMSYSERR_KEYNOTFOUND;
        else mmr = MMSYSERR_READERROR;
    }

    NtClose(hkcu);

    return mmr;
}

MMRESULT midiOutReadPersistentPreferredId(OUT UINT *pMidiPrefId, OUT ULONG *pSetupCount)
{
    PTSTR pstrDeviceInterface;
    PTSTR pstrPname;
    UINT RelativeIndex;
    UINT MidiOutId;
    ULONG SetupCount;
    MMRESULT mmr;

    mmr = midiOutReadPreferredDeviceData(&pstrDeviceInterface, &RelativeIndex, &pstrPname, &SetupCount);
    if (MMSYSERR_NOERROR == mmr) {
        WinAssert(pstrDeviceInterface || pstrPname);
        if (pstrDeviceInterface) {
            mmr = midiOutGetIdFromDiAndIndex(pstrDeviceInterface, RelativeIndex, &MidiOutId);
        } else {
            WinAssert(pstrPname);
            mmr = midiOutGetIdFromName(pstrPname, &MidiOutId);
        }
        if (pstrDeviceInterface) HeapFree(hHeap, 0, pstrDeviceInterface);
        if (pstrPname) HeapFree(hHeap, 0, pstrPname);
    } else if (MMSYSERR_VALNOTFOUND == mmr || MMSYSERR_KEYNOTFOUND == mmr) {
        PTSTR pstrMidiKeyName;
        mmr = midiOutReadCurrentInstrument(&pstrMidiKeyName, &SetupCount);
        if (MMSYSERR_NOERROR == mmr) {
            mmr = midiOutGetIdFromInstrument(pstrMidiKeyName, &MidiOutId);
            // Since this is older format for storing preference, let's
            //   rewrite it in newer format.
            if (MMSYSERR_NOERROR == mmr)
            {
                midiOutWritePersistentPref(MidiOutId, SetupCount);
            }
            HeapFree(hHeap, 0, pstrMidiKeyName);
         }
    }

    if (MMSYSERR_NOERROR == mmr) {
        *pMidiPrefId = MidiOutId;
        *pSetupCount = SetupCount;
    }

    return mmr;
}

MMRESULT midiOutPickBestId(PUINT pMidiPrefId, UINT WaveOutPrefId)
{
    MIDIOUTCAPS moc;
    UINT cMidiOutId;
    UINT MidiOutId;
    UINT UserSelectedMidiOutId;
    UINT WavetableMidiOutId;
    UINT SoftwareMidiOutId;
    UINT OtherMidiOutId;
    UINT FmMidiOutId;
    UINT ExternalMidiOutId;
    DWORD MidiOutIdCount;
    DWORD UserSelectedMidiOutIdCount;
    DWORD WavetableMidiOutIdCount;
    DWORD SoftwareMidiOutIdCount;
    DWORD OtherMidiOutIdCount;
    DWORD FmMidiOutIdCount;
    DWORD ExternalMidiOutIdCount;
    MMRESULT mmrLastError;
    MMRESULT mmr;
    BOOL f;

    UserSelectedMidiOutId = MIDI_MAPPER;
    WavetableMidiOutId = MIDI_MAPPER;
    SoftwareMidiOutId = MIDI_MAPPER;
    OtherMidiOutId = MIDI_MAPPER;
    FmMidiOutId = MIDI_MAPPER;
    ExternalMidiOutId = MIDI_MAPPER;
    MidiOutId = MIDI_MAPPER;

    UserSelectedMidiOutIdCount = 0;
    WavetableMidiOutIdCount = 0;
    SoftwareMidiOutIdCount = 0;
    OtherMidiOutIdCount = 0;
    FmMidiOutIdCount = 0;
    ExternalMidiOutIdCount = 0;
    MidiOutIdCount = 0;

    mmr = midiOutReadPersistentPreferredId(&UserSelectedMidiOutId, &UserSelectedMidiOutIdCount);

    mmrLastError = MMSYSERR_NODRIVER;

    cMidiOutId = midiOutGetNumDevs();
    for (MidiOutId = 0; MidiOutId < cMidiOutId; MidiOutId++)
    {
	mmr = midiOutGetDevCaps(MidiOutId, &moc, sizeof(moc));
	if (MMSYSERR_NOERROR == mmr)
	{
	    MidiOutIdCount = midiOutGetSetupPreferredAudioCount(MidiOutId);

	    if (MOD_SWSYNTH == moc.wTechnology &&
		MM_MSFT_WDMAUDIO_MIDIOUT == moc.wPid &&
		MM_MICROSOFT == moc.wMid)
	    {
		// We need to special case this synth, and get the count from
		//  the preferred audio device.
		SoftwareMidiOutId = MidiOutId;
		if ((-1) != WaveOutPrefId) {
		    SoftwareMidiOutIdCount = waveOutGetSetupPreferredAudioCount(WaveOutPrefId);
		} else {
		    SoftwareMidiOutIdCount = 0;
		}
	    } else if (MOD_FMSYNTH == moc.wTechnology) {
		FmMidiOutId = MidiOutId;
		FmMidiOutIdCount = MidiOutIdCount;
	    } else if (MOD_MIDIPORT == moc.wTechnology) {
		ExternalMidiOutId = MidiOutId;
		ExternalMidiOutIdCount = MidiOutIdCount;
	    } else if (MOD_WAVETABLE == moc.wTechnology) {
		WavetableMidiOutId = MidiOutId;
		WavetableMidiOutIdCount = MidiOutIdCount;
	    } else {
		OtherMidiOutId = MidiOutId;
		OtherMidiOutIdCount = MidiOutIdCount;
	    }
	} else {
	    mmrLastError = mmr;
	}
    }

    MidiOutId = ExternalMidiOutId;
    MidiOutIdCount = ExternalMidiOutIdCount;
    if ((FmMidiOutIdCount >= MidiOutIdCount) && (MIDI_MAPPER != FmMidiOutId))
    {
	MidiOutId = FmMidiOutId;
	MidiOutIdCount = FmMidiOutIdCount;
    }
    if ((OtherMidiOutIdCount >= MidiOutIdCount) && (MIDI_MAPPER != OtherMidiOutId))
    {
	MidiOutId = OtherMidiOutId;
	MidiOutIdCount = OtherMidiOutIdCount;
    }
    if ((SoftwareMidiOutIdCount >= MidiOutIdCount) && (MIDI_MAPPER != SoftwareMidiOutId))
    {
	MidiOutId = SoftwareMidiOutId;
	MidiOutIdCount = SoftwareMidiOutIdCount;
    }
    if ((WavetableMidiOutIdCount >= MidiOutIdCount) && (MIDI_MAPPER != WavetableMidiOutId))
    {
	MidiOutId = WavetableMidiOutId;
	MidiOutIdCount = WavetableMidiOutIdCount;
    }
    if ((UserSelectedMidiOutIdCount >= MidiOutIdCount) && (MIDI_MAPPER != UserSelectedMidiOutId))
    {
	MidiOutId = UserSelectedMidiOutId;
	MidiOutIdCount = UserSelectedMidiOutIdCount;
    }
		    
    if ((-1) != MidiOutId) {
	mmr = MMSYSERR_NOERROR;
    } else {
	mmr = mmrLastError;
    }

    if (MMSYSERR_NOERROR == mmr) *pMidiPrefId = MidiOutId;
    return mmr;
}

void midiOutGetCurrentPreferredId(PUINT pPrefId, PDWORD pdwFlags)
{
    *pPrefId = WAVE_MAPPER;
    if (pdwFlags) *pdwFlags = 0;;
    if (gpstrMoDefaultStringId) mregGetIdFromStringId(&midioutdrvZ, gpstrMoDefaultStringId, pPrefId);
    return;
}

MMRESULT midiOutSetCurrentPreferredId(UINT PrefId)
{
    MMRESULT mmr;
    
    WinAssert(PrefId < wTotalMidiOutDevs || PrefId == MIDI_MAPPER);

    mmr = MMSYSERR_NOERROR;

    if (gpstrMoDefaultStringId) HeapFree(hHeap, 0, gpstrMoDefaultStringId);
    gpstrMoDefaultStringId = NULL;
    
    if (wTotalMidiOutDevs)
    {
        PMIDIDRV pmididrv;
        UINT port;
            
        mmr = midiReferenceDriverById(&midioutdrvZ, PrefId, &pmididrv, &port);
    	if (!mmr)
    	{
    	    mmr = mregCreateStringIdFromDriverPort(pmididrv, port, &gpstrMoDefaultStringId, NULL);
    	    if (!mmr)
    	    {
    	    	if (!gfDisablePreferredDeviceReordering)
    	    	{
                    // Rearrange some of the driver list so that the preferred midiOut
        	    // device has a good chance of having device ID 0
        	    if (0 != PrefId)
        	    {
                        // Move the midi driver to the head of this list.  This usually
                        // makes the preferred device have ID 0.
        	            EnterNumDevs("midiOutSetCurrentPreferredId");
                        pmididrv->Prev->Next = pmididrv->Next;
                        pmididrv->Next->Prev = pmididrv->Prev;
                        pmididrv->Next = midioutdrvZ.Next;
                        pmididrv->Prev = &midioutdrvZ;
                        midioutdrvZ.Next->Prev = pmididrv;
                        midioutdrvZ.Next = pmididrv;
                        LeaveNumDevs("midiOutSetCurrentPreferredId");
    
                        mregDecUsagePtr(pmididrv);
        	    }
    	    	}
    	    }
    	}    	    
    }

    if (!mmr)
    {
        // Reconfigure the mapper only if it was already loaded.  Don't cause it to
        // load simply so that we can reconfigure it!
        if (MidiMapperInitialized) midiOutMessage((HMIDIOUT)(UINT_PTR)MIDI_MAPPER, DRVM_MAPPER_RECONFIGURE, 0, 0);
    }

    return mmr;
}

MMRESULT midiOutSetPersistentPreferredId(UINT PrefId, DWORD dwFlags)
{
    MMRESULT mmr;
    mmr = midiOutWritePersistentPref(PrefId, GetCurrentSetupPreferredAudioCount());
    if (!mmr) NotifyServerPreferredDeviceChange();
    return mmr;
}

//------------------------------------------------------------------------------
//
//
//	RefreshPreferredDevices
//
//
//------------------------------------------------------------------------------
void RefreshPreferredDevices(void)
{
    UINT WaveOutPreferredId;
    DWORD WaveOutPreferredFlags;
    UINT WaveInPreferredId;
    DWORD WaveInPreferredFlags;
    UINT WaveOutConsoleVoiceComId;
    DWORD WaveOutConsoleVoiceComFlags;
    UINT WaveInConsoleVoiceComId;
    DWORD WaveInConsoleVoiceComFlags;
    UINT MidiOutPreferredId;

    UINT OldWaveOutPreferredId;
    DWORD OldWaveOutPreferredFlags;
    UINT OldWaveInPreferredId;
    DWORD OldWaveInPreferredFlags;
    UINT OldWaveOutConsoleVoiceComId;
    DWORD OldWaveOutConsoleVoiceComFlags;
    UINT OldWaveInConsoleVoiceComId;
    DWORD OldWaveInConsoleVoiceComFlags;
    UINT OldMidiOutPreferredId;

    // Squirt("RefreshPreferredDevices");
    
    BOOL fImpersonate = FALSE;
    
    waveOutGetCurrentPreferredId(&OldWaveOutPreferredId, &OldWaveOutPreferredFlags);
    if (!waveOutPickBestId(&WaveOutPreferredId, &WaveOutPreferredFlags)) {
        if ((WaveOutPreferredId != OldWaveOutPreferredId) ||
            (WaveOutPreferredFlags != OldWaveOutPreferredFlags) ||
            !gfWaveOutPreferredMessageSent)
        {
            // Squirt("RefreshPreferredDevices: different waveOut preference %d -> %d", OldWaveOutPreferredId, WaveOutPreferredId);

            waveOutSendPreferredMessage(TRUE);
            
            waveOutSetCurrentPreferredId(WaveOutPreferredId, WaveOutPreferredFlags);
            
            waveOutSendPreferredMessage(FALSE);
            
        }

    }

    waveOutGetCurrentConsoleVoiceComId(&OldWaveOutConsoleVoiceComId, &OldWaveOutConsoleVoiceComFlags);
    if (!wavePickBestConsoleVoiceComId(TRUE, &WaveOutConsoleVoiceComId, &WaveOutConsoleVoiceComFlags)) {
        if ((WaveOutConsoleVoiceComId != OldWaveOutConsoleVoiceComId) ||
            (WaveOutConsoleVoiceComFlags != OldWaveOutConsoleVoiceComFlags))
        {
            // Squirt("RefreshPreferredDevices: different waveOut preference %d -> %d", OldWaveOutConsoleVoiceComId, WaveOutConsoleVoiceComId);
            waveOutSetCurrentConsoleVoiceComId(WaveOutConsoleVoiceComId, WaveOutConsoleVoiceComFlags);
        }

    }

    waveInGetCurrentPreferredId(&OldWaveInPreferredId, &OldWaveInPreferredFlags);
    if (!waveInPickBestId(&WaveInPreferredId, &WaveInPreferredFlags)) {
        if ((WaveInPreferredId != OldWaveInPreferredId) ||
            (WaveInPreferredFlags != OldWaveInPreferredFlags) ||
            !gfWaveInPreferredMessageSent)
        {
            // Squirt("RefreshPreferredDevices: different waveIn preference %d -> %d", OldWaveInPreferredId, WaveInPreferredId);

            waveInSendPreferredMessage(TRUE);

            waveInSetCurrentPreferredId(WaveInPreferredId, WaveInPreferredFlags);

            waveInSendPreferredMessage(FALSE);

        }
    }

    waveInGetCurrentConsoleVoiceComId(&OldWaveInConsoleVoiceComId, &OldWaveInConsoleVoiceComFlags);
    if (!wavePickBestConsoleVoiceComId(FALSE, &WaveInConsoleVoiceComId, &WaveInConsoleVoiceComFlags)) {
        if ((WaveInConsoleVoiceComId != OldWaveInConsoleVoiceComId) ||
            (WaveInConsoleVoiceComFlags != OldWaveInConsoleVoiceComFlags))
        {
            // Squirt("RefreshPreferredDevices: different waveIn preference %d -> %d", OldWaveInConsoleVoiceComId, WaveInConsoleVoiceComId);
            waveInSetCurrentConsoleVoiceComId(WaveInConsoleVoiceComId, WaveInConsoleVoiceComFlags);
        }
    }

    midiOutGetCurrentPreferredId(&OldMidiOutPreferredId, NULL);
    if (!midiOutPickBestId(&MidiOutPreferredId, WaveOutPreferredId)) {
        if (MidiOutPreferredId != OldMidiOutPreferredId ||
            !gfMidiOutPreferredMessageSent)
        {
            // Squirt("RefreshPreferredDevices: different midiOut preference %d -> %d", OldMidiOutPreferredId, MidiOutPreferredId);

            midiOutSendPreferredMessage(TRUE);

            midiOutSetCurrentPreferredId(MidiOutPreferredId);

            midiOutSendPreferredMessage(FALSE);

        }
    }

    // Squirt("RefreshPreferredDevices: return");
    return;
}

void InvalidatePreferredDevices(void)
{
    if (gpstrWoDefaultStringId) HeapFree(hHeap, 0, gpstrWoDefaultStringId);
    if (gpstrWiDefaultStringId) HeapFree(hHeap, 0, gpstrWiDefaultStringId);
    gpstrWoDefaultStringId = NULL;
    gpstrWiDefaultStringId = NULL;
    
    if (gpstrWoConsoleVoiceComStringId) HeapFree(hHeap, 0, gpstrWoConsoleVoiceComStringId);
    if (gpstrWiConsoleVoiceComStringId) HeapFree(hHeap, 0, gpstrWiConsoleVoiceComStringId);
    gpstrWoConsoleVoiceComStringId = NULL;
    gpstrWiConsoleVoiceComStringId = NULL;
    
    if (gpstrMoDefaultStringId) HeapFree(hHeap, 0, gpstrMoDefaultStringId);
    gpstrMoDefaultStringId = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\playwav.h ===
// Copyright (c) 1992 Microsoft Corporation
/*****************************************************************************

    playwav.h

 ****************************************************************************/

extern BOOL    NEAR PASCAL soundPlay(HANDLE hSound, UINT wFlags);
extern VOID    NEAR PASCAL soundFree(HANDLE hSound);
extern HANDLE  NEAR PASCAL soundLoadFile(LPCWSTR szFileName);
extern HANDLE  NEAR PASCAL soundLoadMemory(LPBYTE lpMem);

/*****************************************************************************

      STUFF TO SUPPORT MS-WAVE FORMAT FILES

 ****************************************************************************/

typedef struct _FileHeader {
        DWORD   dwRiff;
        DWORD   dwSize;
        DWORD   dwWave;
} FileHeader;
typedef FileHeader FAR *FPFileHeader;

typedef struct _ChunkHeader {
        DWORD   dwCKID;
        DWORD   dwSize;
} ChunkHeader;
typedef ChunkHeader UNALIGNED *FPChunkHeader;

/*  Chunk Types  */
//#define RIFF_FILE       FOURCC('R','I','F','F')
//#define RIFF_WAVE       FOURCC('W','A','V','E')
//#define RIFF_FORMAT     FOURCC('f','m','t',' ')
//#define RIFF_CHANNEL    FOURCC('d','a','t','a')

#define RIFF_FILE       FOURCC_RIFF    // in Winmm.H
#define RIFF_WAVE       FOURCC_WAVE        // in WinmmI.h
#define RIFF_FORMAT     FOURCC_FMT     // in WinmmI.h
#define RIFF_CHANNEL    FOURCC_DATA    // in WinmmI.h

/* When memory for a PlaySound file is allocated we insert a WAVEHDR, then
 * the size, date and time as well as the filename of the wave file.
 * Then if the user changes the file underneath us, but keeping the same
 * name, we have a chance to detect the difference and not to play the
 * cached sound file.  Note: the filetime stored is the lastwritten time.
 */
typedef struct _SoundFile {
	WAVEHDR     wh;
	ULONG		Size;
	FILETIME	ft;
	WCHAR		Filename[];   // allows field to be addressed
} SOUNDFILE;
typedef SOUNDFILE * PSOUNDFILE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\playwav.c ===
/*******************************Module*Header*********************************\
* Module Name: playwav.c
*
* Sound support routines for NT - ported from Windows 3.1 Sonic
*
* Created:
* Author:
* Jan  92: Ported to Win32 - SteveDav
*
* History:
*
* Copyright (c) 1992-1998 Microsoft Corporation
*
\******************************************************************************/
#define UNICODE

#define MMNOSEQ
#define MMNOJOY
#define MMNOMIDI
#define MMNOMCI

#include "winmmi.h"
#include "playwav.h"

//
// These globals are used to keep track of the currently playing sound, and
// the handle to the wave device.  only 1 sound can be playing at a time.
//

STATICDT HWAVEOUT    hWaveOut;         // handle to open wave device
LPWAVEHDR   lpWavHdr;                  // current wave file playing
ULONG timeAbort;                       // time at which we should give up waiting
                                       //  for a playing sound to finish
CRITICAL_SECTION WavHdrCritSec;
#define EnterWavHdr()   EnterCriticalSection(&WavHdrCritSec);
#define LeaveWavHdr()   LeaveCriticalSection(&WavHdrCritSec);

/* flags for _lseek */
#define  SEEK_CUR 1
#define  SEEK_END 2
#define  SEEK_SET 0

#define FMEM                (GMEM_MOVEABLE)

STATICFN BOOL  NEAR PASCAL soundInitWavHdr(LPWAVEHDR lpwh, LPBYTE lpMem, DWORD dwLen);
STATICFN BOOL  NEAR PASCAL soundOpen(HANDLE  hSound, UINT wFlags);
STATICFN BOOL  NEAR PASCAL soundClose(void);
STATICFN void  NEAR PASCAL soundWait(void);

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api void | WaveOutNotify  | called by mmWndProc when it receives a
 *                              MM_WOM_DONE message
 * @rdesc None.
 *
 ****************************************************************************/

void FAR PASCAL WaveOutNotify(
    DWORD wParam,
    LONG lParam)
{

    EnterWavHdr();
    
#if DBG
    WinAssert(!hWaveOut || lpWavHdr);  // if hWaveOut, then MUST have lpWavHdr
#endif

    if (hWaveOut && !(lpWavHdr->dwFlags & WHDR_DONE)) {
        LeaveWavHdr();
        return;         // wave is not done! get out
    }

    LeaveWavHdr();
        
    //
    // wave file is done! release the device
    //

    dprintf2(("ASYNC sound done, closing wave device"));

    soundClose();
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api BOOL | soundPlay   | Pretty much speaks for itself!
 *
 * @parm HANDLE  | hSound | The sound resource to play.
 *
 * @parm wFlags | UINT | flags controlling sync/async etc.
 *
 *  @flag  SND_SYNC            | play synchronously (default)
 *  @flag  SND_ASYNC           | play asynchronously
 *
 * @rdesc Returns TRUE if successful and FALSE on failure.
 ****************************************************************************/
BOOL NEAR PASCAL soundPlay(
    HANDLE  hSound,
    UINT wFlags)
{
    //
    // Before playing a sound release it
    //
    soundClose();
    
    //
    // If the current session is disconnected
    // then don't bother playing
    //
    if (WTSCurrentSessionIsDisconnected()) return TRUE;

    //
    // open the sound device and write the sound to it.
    //
    if (!soundOpen(hSound, wFlags)) {
        dprintf1(("Returning false after calling SoundOpen"));
        return FALSE;
    }
    dprintf2(("SoundOpen OK"));

    if (!(wFlags & SND_ASYNC))
    {
        dprintf4(("Calling SoundWait"));
        soundWait();
        dprintf4(("Calling SoundClose"));
        soundClose();
    }
    return TRUE;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api BOOL | soundOpen  | Open the wave device and write a sound to it.
 *
 * @parm HANDLE  | hSound | The sound resource to play.
 *
 * @rdesc Returns TRUE if successful and FALSE on failure.
 ****************************************************************************/
STATICFN BOOL NEAR PASCAL soundOpen(
    HANDLE  hSound,
    UINT    wFlags)
{
    UINT        wErr;
    DWORD       flags = WAVE_ALLOWSYNC;
    BOOL        fResult = FALSE;

    if (!hSound) {
        return FALSE;
    }

    if (hWaveOut)
    {
        dprintf1(("WINMM: soundOpen() wave device is currently open."));
        return FALSE;
    }

    try {
        EnterWavHdr();
        lpWavHdr = (LPWAVEHDR)GlobalLock(hSound);

        if (!lpWavHdr)
        {
#if DBG
            if ((GlobalFlags(hSound) & GMEM_DISCARDED)) {
                dprintf1(("WINMM: sound was discarded before play could begin."));
            }
#endif
            goto exit;
        }

        //
        // open the wave device, open any wave device that supports the
        // format
        //
        if (hwndNotify) {
            flags |= CALLBACK_WINDOW;
        }

        wErr = waveOutOpen(&hWaveOut,           // returns handle to device
                (UINT)WAVE_MAPPER,              // device id (any device)
                (LPWAVEFORMATEX)lpWavHdr->dwUser, // wave format
                (DWORD_PTR)hwndNotify,          // callback function
                0L,                             // callback instance data
                flags);                         // flags

        if (wErr != 0)
        {
            dprintf1(("WINMM: soundOpen() unable to open wave device"));
            GlobalUnlock(hSound);
            hWaveOut = NULL;
            lpWavHdr = NULL;
            goto exit;
        }

        wErr = waveOutPrepareHeader(hWaveOut, lpWavHdr, sizeof(WAVEHDR));

        if (wErr != 0)
        {
            dprintf1(("WINMM: soundOpen() waveOutPrepare failed"));
            soundClose();
            goto exit;
        }

        //
        // Only allow sound looping if playing ASYNC sounds
        //
        if ((wFlags & SND_ASYNC) && (wFlags & SND_LOOP))
        {
            lpWavHdr->dwLoops  = 0xFFFFFFFF;     // infinite loop
            lpWavHdr->dwFlags |= WHDR_BEGINLOOP|WHDR_ENDLOOP;
        }
        else
        {
            lpWavHdr->dwLoops  = 0;
            lpWavHdr->dwFlags &=~(WHDR_BEGINLOOP|WHDR_ENDLOOP);
        }

        lpWavHdr->dwFlags &= ~WHDR_DONE;        // mark as not done!
        wErr = waveOutWrite(hWaveOut, lpWavHdr, sizeof(WAVEHDR));

        timeAbort = lpWavHdr->dwBufferLength * 1000 / ((LPWAVEFORMATEX)lpWavHdr->dwUser)->nAvgBytesPerSec;
        timeAbort = timeAbort * 2;	// 100% room for slew between audio and system clocks
        timeAbort = timeAbort + timeGetTime();

        if (wErr != 0)
        {
            dprintf1(("WINMM: soundOpen() waveOutWrite failed"));
            soundClose();
            goto exit;
        }
        fResult = TRUE;
        exit: ;

    } finally {
        LeaveWavHdr();
    }
    return fResult;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | soundClose | This function closes the sound device
 *
 * @rdesc Returns TRUE if successful and FALSE on failure.
 ****************************************************************************/
STATICFN BOOL NEAR PASCAL soundClose(
    void)
{
    UINT        wErr;

    //
    // Do we have the sound device open?
    //
try {
    EnterWavHdr();

    if (!lpWavHdr || !hWaveOut) {
        // return TRUE;
    } else {

        //
        // if the block is still playing, stop it!
        //
        if (!(lpWavHdr->dwFlags & WHDR_DONE)) {
            waveOutReset(hWaveOut);
        }

#if DBG
        if (!(lpWavHdr->dwFlags & WHDR_DONE))
        {
            dprintf1(("WINMM: soundClose() data is not DONE!???"));
            lpWavHdr->dwFlags |= WHDR_DONE;
        }

        if (!(lpWavHdr->dwFlags & WHDR_PREPARED))
        {
            dprintf1(("WINMM: soundClose() data not prepared???"));
        }
#endif

        //
        // unprepare the data anyway!
        //
        wErr = waveOutUnprepareHeader(hWaveOut, lpWavHdr, sizeof(WAVEHDR));

        if (wErr != 0)
        {
            dprintf1(("WINMM: soundClose() waveOutUnprepare failed!"));
        }

        //
        // finally, actually close the device, and unlock the data
        //
        waveOutClose(hWaveOut);
        GlobalUnlock(GlobalHandle(lpWavHdr));

        //
        // update globals, claiming the device is closed.
        //
        hWaveOut = NULL;
        lpWavHdr = NULL;
    }
} finally {
    LeaveWavHdr();
}
    return TRUE;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api void | soundWait | wait for the sound device to complete
 *
 * @rdesc none
 ****************************************************************************/
STATICFN void NEAR PASCAL soundWait(
    void)
{

    try {                         // This should ensure that even WOW
                                  // threads that die on us depart the
                                  // critical section
        EnterWavHdr();
        if (lpWavHdr) {
            LPWAVEHDR   lpExisting;       // current playing wave file
            lpExisting = lpWavHdr;
            while (lpExisting == lpWavHdr &&
		   !(lpWavHdr->dwFlags & WHDR_DONE) &&
		   (timeGetTime() < timeAbort)
		  )
	    {
                dprintf4(("Waiting for buffer to complete"));
                LeaveWavHdr();
                Sleep(75);
                EnterWavHdr();
                // LATER !! We should have an event (on another thread... sigh...)
                // which will be triggered when the buffer is played.  Waiting
                // on the WHDR_DONE bit is ported directly from Win 3.1 and is
                // certainly not the best way of doing this.  The disadvantage of
                // using the thread notification is signalling this thread to
                // continue.
            }
        }
    } finally {
        LeaveWavHdr();
    }
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api void | soundFree | This function frees a sound resource created
 *      with soundLoadFile or soundLoadMemory
 *
 * @rdesc Returns TRUE if successful and FALSE on failure.
 ****************************************************************************/
void NEAR PASCAL soundFree(
    HANDLE  hSound)
{
    // Allow a null handle to stop any pending sounds, without discarding
    // the current cached sound
    //
    // !!! we should only close the sound device iff this hSound is playing!
    //
    soundClose();

    if (hSound) {
        GlobalFree(hSound);
    }
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api HANDLE  | soundLoadFile | Loads a specified sound resource from a
 *  file into a global, discardable object.
 *
 * @parm LPCSTR | lpszFile | The file from which to load the sound resource.
 *
 * @rdesc Returns NULL on failure, GLOBAL HANDLE to a WAVEHDR iff success
 ****************************************************************************/
HANDLE  NEAR PASCAL soundLoadFile(
    LPCWSTR szFileName)
{
    HANDLE      fh;
    DWORD       dwSize;
    LPBYTE      lpData;
    HANDLE      h;
    UINT        wNameLen;

    // open the file
    fh = CreateFile( szFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );

    if (fh == (HANDLE)(UINT_PTR)HFILE_ERROR) {
        dprintf3(("soundLoadFile: Failed to open %ls  Error is %d",szFileName, GetLastError()));
        return NULL;
    } else {
        dprintf3(("soundLoadFile: opened %ls",szFileName));
    }

    /* Get wNameLen rounded up to next WORD boundary.
     * We do not need to round up to a DWORD boundary as this value is
     * about to be multiplied by sizeof(WCHAR) which will do the additional
     * boundary alignment for us.  If we ever contemplate moving back to
     * non-UNICODE then this statement will have to be changed.  The
     * alignment is needed so that the actual wave data starts on a
     * DWORD boundary.
     */
    wNameLen = ((lstrlen(szFileName) + 1 + sizeof(WORD) - 1) /
            sizeof(WORD)) * sizeof(WORD);

#define BLOCKBYTES (sizeof(SOUNDFILE) + (wNameLen * sizeof(WCHAR)))
//   The amount of space we need to allocate - the WAVEHDR, file size, date
//   time plus the file name and a terminating null.

    dwSize = GetFileSize(fh, NULL);
    // note: could also use the C function FILELENGTH
    if (HFILE_ERROR == dwSize) {
        dprintf2(("Failed to find file size: %ls", szFileName));
        goto error1;
    }

    // allocate some discardable memory for a wave hdr, name and the file data.
    h = GlobalAlloc( FMEM + GMEM_DISCARDABLE,
                    BLOCKBYTES + dwSize );
    if (!h) {
        dprintf3(("soundLoadFile: Failed to allocate memory"));
        goto error1;
    }

    // lock it down
    if (NULL == (lpData = GlobalLock(h))) goto error2;

    // read the file into the memory block

    // NOTE:  We could, and probably should, use the file mapping functions.
    // Do this LATER
    if ( _lread( (HFILE)(DWORD_PTR)fh,
                 lpData + BLOCKBYTES,
                 (UINT)dwSize)
        != dwSize ) {
        goto error3;
    }

    // Save the last written time, and the file size
    ((PSOUNDFILE)lpData)->Size = dwSize;
    GetFileTime(fh, NULL, NULL, &(((PSOUNDFILE)lpData)->ft));

    // do the rest of it from the memory image
    //
    // MIPS WARNING !! Unaligned data - wNameLen is arbitrary
    //

    if (!soundInitWavHdr( (LPWAVEHDR)lpData,
                          lpData + BLOCKBYTES,
                          dwSize) )
    {
        dprintf3(("soundLoadFile: Failed to InitWaveHdr"));
        goto error3;
    }

    CloseHandle(fh);

    lstrcpyW( ((PSOUNDFILE)lpData)->Filename, szFileName);
    GlobalUnlock(h);
    return h;

error3:
    GlobalUnlock(h);
error2:
    GlobalFree(h);
error1:
    CloseHandle(fh);
    return NULL;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api HANDLE  | soundLoadMemory | Loads a user specified sound resource from a
 *  a memory block supplied by the caller.
 *
 * @parm LPCSTR | lpMem | Pointer to a memory image of the file
 *
 * @rdesc Returns NULL on failure, GLOBAL HANDLE to a WAVEHDR iff success
 ****************************************************************************/
HANDLE  NEAR PASCAL soundLoadMemory(
    LPBYTE  lpMem)
{
    HANDLE  h;
    LPBYTE  lp;

    // allocate some memory, for a wave hdr
    h = GlobalAlloc(FMEM, (LONG)(sizeof(SOUNDFILE) + sizeof(WCHAR)) );
    if (!h) {
        goto error1;
    }

    // lock it down
    if (NULL == (lp = GlobalLock(h))) goto error2;

    //
    // we must assume the memory pointer is correct! (hence the -1l)
    //
    if (!soundInitWavHdr( (LPWAVEHDR)lp, lpMem, (DWORD)-1l)) {
        goto error3;
    }

    //*(LPWSTR)(lp + sizeof(WAVEHDR)+sizeof(SOUNDFILE)) = '\0';   // No file name for memory file
    ((PSOUNDFILE)lp)->Filename[0] = '\0';   // No file name for memory file
    ((PSOUNDFILE)lp)->Size = 0;
    GlobalUnlock(h);
    return h;

error3:
    GlobalUnlock(h);
error2:
    GlobalFree(h);
error1:
    return NULL;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api BOOL | soundInitWavHdr | Initializes a WAVEHDR data structure from a
 *                         pointer to a memory image of a RIFF WAV file.
 *
 * @parm LPWAVEHDR | lpwh | Pointer to a WAVEHDR
 *
 * @parm LPCSTR | lpMem | Pointer to a memory image of a RIFF WAV file
 *
 * @rdesc Returns FALSE on failure, TRUE on success.
 *
 * @comm the dwUser field of the WAVEHDR structure is initialized to point
 * to the WAVEFORMAT structure that is inside the RIFF data
 *
 ****************************************************************************/
STATICFN BOOL NEAR PASCAL soundInitWavHdr(
    LPWAVEHDR lpwh,
    LPBYTE lpMem,
    DWORD dwLen)
{
    FPFileHeader    fpHead;
    LPWAVEFORMAT    lpFmt;
    LPBYTE          lpData;
    DWORD           dwFileSize,dwCurPos;
    DWORD           dwSize;
    DWORD           AlignError;
    DWORD           FmtSize;

    if (dwLen < sizeof(FileHeader)) {
        dprintf3(("Not a RIFF file, or not a WAVE file"));
        return FALSE;
    }

    // assume the first few bytes are the file header
    fpHead = (FPFileHeader) lpMem;

    // check that it's a valid RIFF file and a valid WAVE form.
    if (fpHead->dwRiff != RIFF_FILE || fpHead->dwWave != RIFF_WAVE ) {
        return FALSE;
    }

    dwFileSize = fpHead->dwSize;
    dwCurPos = sizeof(FileHeader);
    lpData = lpMem + sizeof(FileHeader);

    if (dwLen < dwFileSize) {     // RIFF header
        return FALSE;
    }

    // scan until we find the 'fmt' chunk
    while( 1 ) {
        if( ((FPChunkHeader)lpData)->dwCKID == RIFF_FORMAT ) {
            break; // from the while loop that's looking for it
        }
        dwCurPos += ((FPChunkHeader)lpData)->dwSize + sizeof(ChunkHeader);
        if( dwCurPos >= dwFileSize ) {
            return FALSE;
        }
        lpData += ((FPChunkHeader)lpData)->dwSize + sizeof(ChunkHeader);
    }

    // now we're at the beginning of the 'fmt' chunk data
    lpFmt = (LPWAVEFORMAT) (lpData + sizeof(ChunkHeader));

    // Save the size of the format data and check it.
    FmtSize = ((FPChunkHeader)lpData)->dwSize;
    if (FmtSize < sizeof(WAVEFORMAT)) {
        return FALSE;
    }


    // scan until we find the 'data' chunk
    lpData = lpData + ((FPChunkHeader)lpData)->dwSize + sizeof(ChunkHeader);
    while( 1 ) {
        if ( ((FPChunkHeader)lpData)->dwCKID == RIFF_CHANNEL) {
            break; // from the while loop that's looking for it
        }
        dwCurPos += ((FPChunkHeader)lpData)->dwSize + sizeof(ChunkHeader);
        if( dwCurPos >= dwFileSize ) {
            return 0;
        }
        lpData += ((FPChunkHeader)lpData)->dwSize + sizeof(ChunkHeader);
    }

    //
    // The format chunk must be aligned so move things if necessary
    // Warning - this is a hack to get round alignment problems
    //
    AlignError = ((DWORD)((LPBYTE)lpFmt - lpMem)) % sizeof(DWORD);

    if (AlignError != 0) {
        lpFmt = (LPWAVEFORMAT)((LPBYTE)lpFmt - AlignError);
        MoveMemory(lpFmt, (LPBYTE)lpFmt + AlignError, FmtSize);
    }

    // now we're at the beginning of the 'data' chunk data
    dwSize = ((FPChunkHeader)lpData)->dwSize;
    lpData = lpData + sizeof(ChunkHeader);

    // initialize the WAVEHDR

    lpwh->lpData    = (LPSTR)lpData;    // pointer to locked data buffer
    lpwh->dwBufferLength  = dwSize;     // length of data buffer
    lpwh->dwUser    = (DWORD_PTR)lpFmt;     // for client's use
    lpwh->dwFlags   = WHDR_DONE;        // assorted flags (see defines)
    lpwh->dwLoops   = 0;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\regapi.c ===
/****************************************************************************\
*
*  Module Name : regapi.c
*
*  Multimedia support library
*
*  This module contains the code for accessing the registry
*
*  Copyright (c) 1993-1998 Microsoft Corporation
*
\****************************************************************************/

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <regapi.h>
#include "winmmi.h"

HANDLE Drivers32Handle;
static WCHAR gszMsacmDriver[] = L"msacm.";

/*
**  Free everything cached
*/

VOID mmRegFree(VOID)
{
    if (Drivers32Handle != NULL) {
        NtClose(Drivers32Handle);
        Drivers32Handle = NULL;
    }
}

/*
**  Open a subkey
*/
HANDLE mmRegOpenSubkey(HANDLE BaseKeyHandle, LPCWSTR lpszSubkeyName)
{
    UNICODE_STRING    unicodeSectionName;
    HANDLE            KeyHandle;
    OBJECT_ATTRIBUTES oa;

    RtlInitUnicodeString(&unicodeSectionName, lpszSubkeyName);
    InitializeObjectAttributes(&oa,
                               &unicodeSectionName,
                               OBJ_CASE_INSENSITIVE,
                               BaseKeyHandle,
                               (PSECURITY_DESCRIPTOR)NULL);

    /*
    **  Open the sub section
    */

    if (!NT_SUCCESS(NtOpenKey(&KeyHandle, GENERIC_READ, &oa))) {
        return NULL;
    } else {
        return KeyHandle;
    }
}


/*
**  Open a subkey
*/
HANDLE mmRegOpenSubkeyForWrite(HANDLE BaseKeyHandle, LPCWSTR lpszSubkeyName)
{
    UNICODE_STRING    unicodeSectionName;
    HANDLE            KeyHandle;
    OBJECT_ATTRIBUTES oa;

    RtlInitUnicodeString(&unicodeSectionName, lpszSubkeyName);
    InitializeObjectAttributes(&oa,
                               &unicodeSectionName,
                               OBJ_CASE_INSENSITIVE,
                               BaseKeyHandle,
                               (PSECURITY_DESCRIPTOR)NULL);

    /*
    **  Open the sub section
    */

    if (!NT_SUCCESS(NtOpenKey(&KeyHandle, MAXIMUM_ALLOWED, &oa))) {
        return NULL;
    } else {
        return KeyHandle;
    }
}

/*
**  Read (small) registry data entries
*/

BOOL mmRegQueryValue(HANDLE  BaseKeyHandle,
                     LPCWSTR lpszSubkeyName,
                     LPCWSTR lpszValueName,
                     ULONG   dwLen,
                     LPWSTR  lpszValue)
{
    BOOL              ReturnCode;
    HANDLE            KeyHandle;
    UNICODE_STRING    unicodeSectionName;
    UNICODE_STRING    unicodeValueName;
    ULONG             ResultLength;

    struct   {
        KEY_VALUE_PARTIAL_INFORMATION KeyInfo;
        UCHAR                         Data[MAX_PATH * sizeof(WCHAR)];
             }        OurKeyValueInformation;


    if (lpszSubkeyName) {
        KeyHandle = mmRegOpenSubkey(BaseKeyHandle, lpszSubkeyName);
    } else {
        KeyHandle = NULL;
    }

    /*
    **  Read the data
    */


    if (lpszValueName == NULL) {
       RtlInitUnicodeString(&unicodeValueName, TEXT(""));
    } else {
       RtlInitUnicodeString(&unicodeValueName, lpszValueName);
    }

    ReturnCode = NT_SUCCESS(NtQueryValueKey(KeyHandle == NULL ?
               BaseKeyHandle : KeyHandle,
            &unicodeValueName,
            KeyValuePartialInformation,
            (PVOID)&OurKeyValueInformation,
            sizeof(OurKeyValueInformation),
            &ResultLength));

    if (ReturnCode) {
        /*
        **  Check we got the right type of data and not too much
        */

        if (OurKeyValueInformation.KeyInfo.DataLength > dwLen * sizeof(WCHAR) ||
            (OurKeyValueInformation.KeyInfo.Type != REG_SZ &&
             OurKeyValueInformation.KeyInfo.Type != REG_EXPAND_SZ)) {

            ReturnCode = FALSE;
        } else {
            /*
            **  Copy back the data
            */

            if (OurKeyValueInformation.KeyInfo.Type == REG_EXPAND_SZ) {
                lpszValue[0] = TEXT('\0');
                ExpandEnvironmentStringsW
                          ((LPCWSTR)OurKeyValueInformation.KeyInfo.Data,
                           (LPWSTR)lpszValue,
                           dwLen);
            } else {
                CopyMemory((PVOID)lpszValue,
                           (PVOID)OurKeyValueInformation.KeyInfo.Data,
                           dwLen * sizeof(WCHAR));
                lpszValue[ min(OurKeyValueInformation.KeyInfo.DataLength,
                               dwLen-1) ] = TEXT('\0');
            }
        }
    }

    if (KeyHandle) {
        NtClose(KeyHandle);
    }

    return ReturnCode;
}

/*
**  Read a mapped 'user' value in a known section
*/

BOOL mmRegQueryUserValue(LPCWSTR lpszSectionName,
                         LPCWSTR lpszValueName,
                         ULONG   dwLen,
                         LPWSTR  lpszValue)
{
    HANDLE UserHandle;
    BOOL   ReturnCode;

    /*
    **  Open the user's key.  It's important to do this EACH time because
    **  on the server it's different for different threads.
    */

    if (!NT_SUCCESS(RtlOpenCurrentUser(GENERIC_READ, &UserHandle))) {
        return FALSE;
    }


    ReturnCode = mmRegQueryValue(UserHandle,
                                 lpszSectionName,
                                 lpszValueName,
                                 dwLen,
                                 lpszValue);

    NtClose(UserHandle);

    return ReturnCode;
}


/*
**  Set a mapped 'user' value in a known section
*/

BOOL mmRegSetUserValue(LPCWSTR lpszSectionName,
                       LPCWSTR lpszValueName,
                       LPCWSTR lpszValue)
{
    HANDLE UserHandle;
    BOOL   ReturnCode = FALSE;

    /*
    **  Open the user's key.  It's important to do this EACH time because
    **  on the server it's different for different threads.
    */

    if (NT_SUCCESS(RtlOpenCurrentUser(MAXIMUM_ALLOWED, &UserHandle)))
    {
        HANDLE  KeyHandle;

        KeyHandle = mmRegOpenSubkeyForWrite (UserHandle, lpszSectionName);
        if (KeyHandle != NULL)
        {
            UNICODE_STRING ValueName;
            if (lpszValueName == NULL) {
                RtlInitUnicodeString (&ValueName, TEXT(""));
            } else {
                RtlInitUnicodeString (&ValueName, lpszValueName);
            }

            ReturnCode = NT_SUCCESS( NtSetValueKey (KeyHandle,
                                                    &ValueName,
                                                    0,
                                                    REG_SZ,
                                                    (PVOID)lpszValue,
                                                    (lstrlenW(lpszValue)+1)* sizeof(lpszValue[0])
                                                    ) );
            NtClose(KeyHandle);
        }

        NtClose(UserHandle);
    }

    return ReturnCode;
}


BOOL mmRegCreateUserKey (LPCWSTR lpszPath, LPCWSTR lpszNewKey)
{
    HANDLE UserHandle;
    BOOL   ReturnValue = FALSE;

    /*
    **  Open the user's key.  It's important to do this EACH time because
    **  on the server it's different for different threads.
    */

    if (NT_SUCCESS(RtlOpenCurrentUser(MAXIMUM_ALLOWED, &UserHandle)))
    {
        HANDLE            PathHandle;
        HANDLE            KeyHandle;
        UNICODE_STRING    unicodeSectionName;
        OBJECT_ATTRIBUTES oa;

        if (lpszPath == NULL)
        {
            PathHandle = NULL;
        }
        else
        {
            PathHandle = mmRegOpenSubkeyForWrite (UserHandle, lpszPath);
            if (PathHandle == NULL)
            {
                NtClose(UserHandle);
                return FALSE;
            }
        }


        RtlInitUnicodeString(&unicodeSectionName, lpszNewKey);
        InitializeObjectAttributes(&oa,
                                   &unicodeSectionName,
                                   OBJ_CASE_INSENSITIVE,
                                   (PathHandle == NULL)
                                      ? UserHandle : PathHandle,
                                   (PSECURITY_DESCRIPTOR)NULL);

        /*
        **  Create the sub section
        */

        if (NT_SUCCESS( NtCreateKey(&KeyHandle,
                                     KEY_READ | KEY_WRITE,
                                     &oa,
                                     0,
                                     NULL,
                                     0,
                                     NULL
                                     ) ))
        {
            if (KeyHandle)
            {
                ReturnValue = TRUE;
                NtClose (KeyHandle);
            }
        }

        if (PathHandle != NULL)
        {
            NtClose(PathHandle);
        }

        NtClose(UserHandle);
    }

    return ReturnValue;
}


/*
**  Test whether a mapped 'user' key exists
*/

BOOL mmRegQueryUserKey (LPCWSTR lpszKeyName)
{
    HANDLE UserHandle;
    BOOL   ReturnValue = FALSE;

    if (lpszKeyName == NULL)
    {
        return FALSE;
    }

    if (NT_SUCCESS(RtlOpenCurrentUser(MAXIMUM_ALLOWED, &UserHandle)))
    {
        HANDLE  KeyHandle;

        KeyHandle = mmRegOpenSubkeyForWrite (UserHandle, lpszKeyName);
        if (KeyHandle != NULL)
        {
            ReturnValue = TRUE;
            NtClose(KeyHandle);
        }

        NtClose(UserHandle);
    }

    return ReturnValue;
}


/*
**  Delete a mapped 'user' key.  Careful--this function deletes recursively!
*/

#define nMaxLevelsToRecurseInDELETEKEY 3   // don't runaway or stack fault

BOOL mmRegDeleteUserKeyRecurse (HANDLE UserHandle, LPCWSTR lpszName, int level)
{
    HANDLE KeyHandle;

    if (lpszName == NULL)
    {
        return FALSE;
    }
    if (level > nMaxLevelsToRecurseInDELETEKEY)
    {
        return FALSE;
    }

    if ((KeyHandle = mmRegOpenSubkeyForWrite (UserHandle, lpszName)) != NULL)
    {
        struct {
            KEY_BASIC_INFORMATION kbi;
            WCHAR NameBuffer [MAX_PATH];
        } kbi;

        /*
        ** Before NtDeleteKey() will work on this key, we have to ensure
        ** there are no subkeys.
        */

        while (TRUE)
        {
            ULONG  cbReturned = 0L;
            WCHAR  szSubKeyName[ MAX_PATH ];

            ZeroMemory (&kbi, sizeof(kbi));

            if (!NT_SUCCESS(NtEnumerateKey(KeyHandle,
                                           0,
           KeyBasicInformation,
           (PVOID)&kbi,
           sizeof(kbi),
           &cbReturned)))
            {
                break;
            }

            wsprintf (szSubKeyName, L"%ls\\%ls", lpszName, kbi.kbi.Name);

            if (!mmRegDeleteUserKeyRecurse (UserHandle, szSubKeyName, 1+level))
            {
                NtClose (KeyHandle);
                return FALSE;
            }
        }

        /*
        ** Once there are no subkeys, we should be able to delete this key.
        */

        if (NT_SUCCESS(NtDeleteKey(KeyHandle)))
        {
            NtClose(KeyHandle);
            return TRUE;
        }

        NtClose(KeyHandle);
    }

    return FALSE;
}


BOOL mmRegDeleteUserKey (LPCWSTR lpszKeyName)
{
    HANDLE UserHandle;
    BOOL   ReturnValue = FALSE;

    if (lpszKeyName == NULL)
    {
        return FALSE;
    }

    if (NT_SUCCESS(RtlOpenCurrentUser(MAXIMUM_ALLOWED, &UserHandle)))
    {
        ReturnValue = mmRegDeleteUserKeyRecurse (UserHandle, lpszKeyName, 1);

        NtClose(UserHandle);
    }

    return ReturnValue;
}


/*
**  Read a mapped 'HKLM' value in a known section
*/

BOOL mmRegQueryMachineValue(LPCWSTR lpszSectionName,
                            LPCWSTR lpszValueName,
                            ULONG   dwLen,
                            LPWSTR  lpszValue)
{
    WCHAR  FullKeyName[MAX_PATH];
    HANDLE HostHandle;
    BOOL   ReturnCode = FALSE;

    lstrcpyW (FullKeyName, L"\\Registry\\Machine\\");
    wcsncat (FullKeyName, lpszSectionName, (MAX_PATH - wcslen(FullKeyName) - 1));

    if ((HostHandle = mmRegOpenSubkey (NULL, FullKeyName)) != NULL)
    {
        ReturnCode = mmRegQueryValue (HostHandle,
                                      lpszSectionName,
                                      lpszValueName,
                                      dwLen,
                                      lpszValue);

        NtClose (HostHandle);
    }

    return ReturnCode;
}


/*
**  Write a mapped 'HKLM' value in a known section
*/

BOOL mmRegSetMachineValue(LPCWSTR lpszSectionName,
                          LPCWSTR lpszValueName,
                          LPCWSTR lpszValue)
{
    WCHAR  FullKeyName[MAX_PATH];
    HANDLE HostHandle;
    BOOL   ReturnCode = FALSE;

    lstrcpyW (FullKeyName, L"\\Registry\\Machine\\");
    wcsncat (FullKeyName, lpszSectionName, (MAX_PATH - wcslen(FullKeyName) - 1));

    if ((HostHandle = mmRegOpenSubkeyForWrite (NULL, FullKeyName)) != NULL)
    {
        UNICODE_STRING ValueName;
        if (lpszValueName == NULL) {
            RtlInitUnicodeString (&ValueName, TEXT(""));
        } else {
            RtlInitUnicodeString (&ValueName, lpszValueName);
        }

        ReturnCode = NT_SUCCESS( NtSetValueKey (HostHandle,
                                                &ValueName,
                                                0,
                                                REG_SZ,
                                                (PVOID)lpszValue,
                                                (lstrlenW(lpszValue)+1)* sizeof(lpszValue[0])
                                                ) );

        NtClose(HostHandle);
    }

    return ReturnCode;
}


BOOL mmRegCreateMachineKey (LPCWSTR lpszPath, LPCWSTR lpszNewKey)
{
    WCHAR  FullKeyName[MAX_PATH];
    HANDLE HostHandle;
    BOOL   ReturnValue = FALSE;

    lstrcpyW (FullKeyName, L"\\Registry\\Machine\\");
    wcsncat (FullKeyName, lpszPath, (MAX_PATH - wcslen(FullKeyName) - 1));

    if ((HostHandle = mmRegOpenSubkeyForWrite (NULL, FullKeyName)) != NULL)
    {
        HANDLE            KeyHandle;
        UNICODE_STRING    unicodeSectionName;
        OBJECT_ATTRIBUTES oa;

        RtlInitUnicodeString(&unicodeSectionName, lpszNewKey);
        InitializeObjectAttributes(&oa,
                                   &unicodeSectionName,
                                   OBJ_CASE_INSENSITIVE,
                                   HostHandle,
                                   (PSECURITY_DESCRIPTOR)NULL);

        /*
        **  Create the sub section
        */

        if (NT_SUCCESS( NtCreateKey(&KeyHandle,
                                     KEY_READ | KEY_WRITE,
                                     &oa,
                                     0,
                                     NULL,
                                     0,
                                     NULL
                                     ) ))
        {
            if (KeyHandle)
            {
                ReturnValue = TRUE;
                NtClose (KeyHandle);
            }
        }

        NtClose(HostHandle);
    }

    return ReturnValue;
}




/*
**  Read stuff from system.ini
*/

BOOL mmRegQuerySystemIni(LPCWSTR lpszSectionName,
                         LPCWSTR lpszValueName,
                         ULONG   dwLen,
                         LPWSTR  lpszValue)
{
    WCHAR KeyPathBuffer[MAX_PATH];
    WCHAR ExKeyPathBuffer[MAX_PATH];

    /*
    **  Create the full path
    */

    lstrcpy(KeyPathBuffer,
     (LPCTSTR) L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\");

    wcsncat(KeyPathBuffer, lpszSectionName, (MAX_PATH - wcslen(KeyPathBuffer) - 1));

    if (lstrcmpiW(lpszSectionName, wszDrivers) == 0) {

     //
     //  for remote session, look ..\terminal Server\RDP (or other protocols) for drivers32
     //  name
     //
     //
        if (WinmmRunningInSession) {
            lstrcat(KeyPathBuffer,L"\\");
            lstrcat(KeyPathBuffer, REG_TSERVER);
            lstrcat(KeyPathBuffer,L"\\");
            lstrcat(KeyPathBuffer, SessionProtocolName);
        }

        if (Drivers32Handle == NULL) {
            Drivers32Handle = mmRegOpenSubkey(NULL, KeyPathBuffer);
        }

        if (Drivers32Handle != NULL) {
            BOOL rc;

            rc = mmRegQueryValue(Drivers32Handle,
                                   NULL,
                                   lpszValueName,
                                   dwLen,
                                   lpszValue);

            //
            //  If we can't find the codec in the TermSrv protocol path
            //  we will look under Driver32 next
            //
            if (rc == FALSE && WinmmRunningInSession &&
                    _wcsnicmp(lpszValueName, gszMsacmDriver, lstrlen(gszMsacmDriver)) == 0) {                   
                HANDLE hKey;

                /*
                **  Create the full path
                */
            
                lstrcpy(KeyPathBuffer,
                 (LPCTSTR) L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\");
            
                lstrcat(KeyPathBuffer, lpszSectionName);

                hKey = mmRegOpenSubkey(NULL, KeyPathBuffer);

                if (hKey != NULL) {
                    rc = mmRegQueryValue(hKey,
                                   NULL,
                                   lpszValueName,
                                   dwLen,
                                   lpszValue);                    

                    RegCloseKey(hKey);
                    return rc;

                }
                else {
                    return FALSE;
                }
            }
            else {
                return rc;
            }
        } else {
            return FALSE;
        }
    }

    if (WinmmRunningInSession) {
        if (lstrcmpiW(lpszSectionName, MCI_SECTION) == 0) {

            memset(ExKeyPathBuffer, 0 , sizeof(ExKeyPathBuffer));
            lstrcpy(ExKeyPathBuffer, KeyPathBuffer);
            lstrcat(ExKeyPathBuffer,L"\\");
            lstrcat(ExKeyPathBuffer, REG_TSERVER);
            lstrcat(ExKeyPathBuffer,L"\\");
            lstrcat(ExKeyPathBuffer, SessionProtocolName);

            /*  look through terminal server section for drivers information first */
            if (mmRegQueryValue(NULL, ExKeyPathBuffer, lpszValueName, dwLen, lpszValue))
                return TRUE;
            else {
            /* pick the system default drivers information */
                return mmRegQueryValue(NULL, KeyPathBuffer, lpszValueName, dwLen, lpszValue);
            }
        }
    }

    return mmRegQueryValue(NULL, KeyPathBuffer, lpszValueName, dwLen, lpszValue);
}

/*
**  Translate name through sounds section
*/

BOOL mmRegQuerySound(LPCWSTR lpszSoundName,
                     ULONG   dwLen,
                     LPWSTR  lpszValue)
{
    WCHAR KeyPathBuffer[MAX_PATH];

    lstrcpy(KeyPathBuffer, (LPCWSTR)L"Control Panel\\");
    lstrcat(KeyPathBuffer, szSoundSection);

    return mmRegQueryUserValue(KeyPathBuffer,
                               lpszSoundName,
                               dwLen,
                               lpszValue);
}

BOOL IsAliasName(LPCWSTR lpSection, LPCWSTR lpKeyName)
{

    if ((!wcsncmp(lpKeyName, L"wave", 4)) ||
        (!wcsncmp(lpKeyName, L"midi", 4)) ||
        (!wcsncmp(lpKeyName, L"aux", 3 )) ||	
        (!wcsncmp(lpKeyName, L"mixer",5)) ||
        (!wcsncmp(lpKeyName, L"msacm",5)) ||
        (!wcsncmp(lpKeyName, L"vidc",4)) ||
        (!wcsncmp(lpKeyName, L"midimapper", 10)) ||
        (!wcsncmp(lpKeyName, L"wavemapper", 10)) ||
        (!wcsncmp(lpKeyName, L"auxmapper", 9 ))  ||	
        (!wcsncmp(lpKeyName, L"mixermapper", 11)))
    {
        return TRUE;
    }
    else
    {
        if (lstrcmpiW( lpSection, (LPCWSTR)MCI_HANDLERS) == 0L)
        {
            UINT    n = lstrlen(lpKeyName);
            
            for (; n > 0; n--)
            {
                //  Found a '.' which implies and extension, which implies a
                //  file.
            
                if ('.' == lpKeyName[n-1])
                {
                    return FALSE;
                }
            }
            
            //  Searched the string for '.'.
            //  None so it is an alias (that is -- not filename)
            return TRUE;
        }
    
        if (lstrcmpiW( lpSection, (LPCWSTR)wszDrivers) == 0L)
        {
            WCHAR   szFileName[MAX_PATH];
            //  It could be something REALLY off the wall, like "ReelDrv"
            
            return (mmRegQuerySystemIni(lpSection, lpKeyName, MAX_PATH, szFileName));
        }
    
        return FALSE;
    }
}

/*****************************Private*Routine******************************\
* MyGetPrivateProfileString
*
* Attempt to bypass stevewo's private profile stuff.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
DWORD
winmmGetPrivateProfileString(
    LPCWSTR lpSection,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR  lpReturnedString,
    DWORD   nSize,
    LPCWSTR lpFileName
)
{
    WCHAR       szFileName[MAX_PATH];

    /*                                  
    ** for now just look for to the [Drivers32] section of system.ini
    */

    if ( (lstrcmpiW( lpFileName, wszSystemIni ) == 0L)
      && ( ( lstrcmpiW( lpSection, wszDrivers ) == 0L ) ||
           ( lstrcmpiW( lpSection, (LPCWSTR)MCI_HANDLERS) == 0L ) ) ) {

		if (IsAliasName(lpSection, lpKeyName))
		{
			if (mmRegQuerySystemIni(lpSection, lpKeyName, nSize, lpReturnedString)) 
			{
				return lstrlen(lpReturnedString);
			} 
			else
			{
				return 0;
			}
		}
		else 
		{
            UINT    ii;
            HANDLE  hFile;

            lstrcpyW(szFileName, lpKeyName);

            for (ii = 0; 0 != szFileName[ii]; ii++)
            {
                if(' ' == szFileName[ii])
                {
                    //  Truncate parameters...

                    szFileName[ii] = 0;
                    break;
                }
            }

            hFile = CreateFile(
                        szFileName,
                        0,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

            if(INVALID_HANDLE_VALUE != hFile)
            {
                CloseHandle(hFile);
                wcsncpy(lpReturnedString, lpKeyName, nSize);
                return (lstrlenW(lpKeyName));
            }
            else
            {
                //  Okay was it a full file path?

                for(ii = 0; 0 != szFileName[ii]; ii++)
                {
                    if ('\\' == szFileName[ii])
                    {
                        //  Probably...

                        break;
                    }
                }

                if ('\\' != szFileName[ii])
                {
                    WCHAR       szStub[MAX_PATH];
                    LPWSTR      pszFilePart;
                    
                    lstrcpyW(szStub, lpKeyName);
                    for(ii = 0; 0 != szStub[ii]; ii++)
                    {
                        if(' ' == szStub[ii])
                        {
                            //  Truncate parameters...

                            szStub[ii] = 0;
                            break;
                        }
                    }
                    
                    if (!SearchPathW(NULL,
                                    szStub,
                                    NULL,
                                    MAX_PATH,
                                    szFileName,
                                    &pszFilePart))
                    {
                        return (0);
                    }

                    hFile = CreateFile(
                                szFileName,
                                0,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

                    if(INVALID_HANDLE_VALUE != hFile)
                    {
                        CloseHandle(hFile);
                        wcsncpy(lpReturnedString, lpKeyName, nSize);
                        return (lstrlenW(lpKeyName));
                    }
                }
            }

            if (lpDefault != NULL) {
                wcsncpy(lpReturnedString, lpDefault, nSize);
            }
            return 0;
        }
    }
    else {

        return GetPrivateProfileStringW( lpSection, lpKeyName, lpDefault,
                                         lpReturnedString, nSize, lpFileName );

    }
}

DWORD
winmmGetProfileString(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR  lpReturnedString,
    DWORD nSize
)
{

    /*
    **  See if it's one we know about
    */

    if (lstrcmpiW(lpAppName, szSoundSection) == 0) {

        if (mmRegQuerySound(lpKeyName, nSize, lpReturnedString)) {
            return lstrlen(lpReturnedString);
        } else {
            if (lpDefault != NULL) {
                wcsncpy(lpReturnedString, lpDefault, nSize);
            }
            return FALSE;
        }
    } else {
        return GetProfileString(lpAppName,
                                lpKeyName,
                                lpDefault,
                                lpReturnedString,
                                nSize);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\task.c ===
/******************************************************************************

   Copyright (c) 1985-1998 Microsoft Corporation

   Title:   task.c - support for task creation and blocking

   Version: 1.00

   Date:    05-Mar-1990

   Author:  ROBWI

------------------------------------------------------------------------------

   Change log:

      DATE        REV            DESCRIPTION
   -----------   ----- -----------------------------------------------------------
   05-MAR-1990   ROBWI First Version - APIs and structures
   18-APR-1990   ROBWI Ported from Resman to mmsystem
   25-JUN-1990   ROBWI Added mmTaskYield
   07-JUL-1991   CJP   Modified to work with new stack switcher code

                 SD    Ported to NT

                 RCBS  Added NT function - Modelled on threads and
                       PostThreadMessage :

                       HTASK is thread id (DWORD)
*****************************************************************************/

#define MMNOTIMER
#define MMNOSEQ
#define MMNOWAVE
#define MMNOMIDI
#define MMNOJOY
#define MMNOSOUND
#define MMNOMCI

#define NOMIDIDEV
#define NOWAVEDEV
#define NOTIMERDEV
#define NOJOYDEV
#define NOMCIDEV
#define NOSEQDEV

#include <winmmi.h>

#define MM_TASK_STACK_SIZE 0x200

/*
 *  Private structure type passed from mmTaskCreate to mmStartTask
 */

 typedef struct {
     HANDLE TerminationEvent;
     DWORD_PTR  dwInst;
     LPTHREAD_START_ROUTINE lpfn;
 } MM_THREAD_START_DATA;

/*
 * Task start stub
 */

STATICFN DWORD mmStartTask(LPVOID lpThreadParameter);

/*************************************************************************
 *
 * @doc     DDK    MMSYSTEM    TASK
 *
 * @api     VOID | mmTaskBlock |  This function blocks the current
 *          task context if its event count is 0.
 *
 * @parm    HANDLE | hTask | Task handle of the current task. For predictable
 *          results, get the task handle from <f mmGetCurrentTask>.
 *
 * @xref    mmTaskSignal mmTaskCreate
 *
 * @comm    WARNING : For predictable results, must only be called from a
 *          task created with <f mmTaskCreate>.
 *
 *************************************************************************/
VOID    APIENTRY mmTaskBlock(DWORD h)
{
    MSG msg;

   /*
    *   Loop until we get the message we want
    */
    for (;;) {
       /*
        *   Retrieve any message for task
        */
        GetMessage(&msg, NULL, 0, 0);

       /*
        *   If the message is for a window dispatch it
        */
        if (msg.hwnd != NULL) {
            DispatchMessage(&msg);
        } else {
           /*
            *   WM_USER is the signal message
            */
            if (msg.message == WM_USER) {
                break;
            }
        }
    }
    return;
}

/*************************************************************************
 *
 * @doc     DDK    MMSYSTEM    TASK
 *
 * @api     BOOL | mmTaskSignal |  This function signals the specified
 *          task, incrementing its event count and unblocking
 *          it.
 *
 * @parm    HTASK | hTask | Task handle. For predictable results, get the
 *          task handle from <f mmGetCurrentTask>.
 *
 * @rdesc   Returns TRUE if the signal was sent, else FALSE if the message
 *          queue was full.
 *
 * @xref    mmTaskBlock  mmTaskCreate
 *
 * @comm    Must be callable at interrupt time! WARNING : For
 *          predictable results, must only be called from a task
 *          created with <f mmTaskCreate>.
 *
 *************************************************************************/
BOOL    APIENTRY mmTaskSignal(DWORD h)
{
#ifdef DBG
    BOOL fErr;
    dprintf2(("Signalling Thread %x", (ULONG)h));
    fErr = PostThreadMessage((DWORD)h, WM_USER, 0, 0);
        if (!fErr) {
                dprintf1(("Error %d signalling Thread %x", GetLastError(), (ULONG)h));
        }
        return(fErr);
#else
    return PostThreadMessage((DWORD)h, WM_USER, 0, 0);
#endif
}

/*************************************************************************
 *
 * @doc     DDK    MMSYSTEM    TASK
 *
 * @api     VOID | mmTaskYield | This function causes the current task
 *          to yield.
 *
 * @comm    For predictable results and future compatibility, use this
 *          function rather than <f Yield> or the undocumented Kernel yield
 *          function to yield within a task created with <f mmTaskCreate>.
 *
 *************************************************************************/
VOID    APIENTRY mmTaskYield(VOID) {
   Yield();
}

/*************************************************************************
 *
 * @doc     DDK    MMSYSTEM    TASK
 *
 * @api     HTASK | mmGetCurrentTask |  This function returns the
 *          handle of the currently executing task created with
 *          <f mmTaskCreate>.
 *
 * @rdesc   Returns a task handle. For predictable results and future
 *          compatibility, use this function rather than <f GetCurrentTask>
 *          to get the task handle of a task created with <f mmTaskCreate>.
 *
 * @xref    mmTaskCreate
 *
 *************************************************************************/
DWORD   APIENTRY mmGetCurrentTask(VOID) {
   return (DWORD)GetCurrentThreadId();
}

/***************************************************************************
 *
 * @doc     DDK    MMSYSTEM    TASK
 *
 * @api     UINT | mmTaskCreate | This function creates a new task.
 *
 * @parm    LPTASKCALLBACK | lpfn |  Points to a program supplied
 *            function and represents the starting address of the new
 *            task.
 *
 * @parm    HANDLE * | lph | Points to the variable that receives the
 *            task handle (NOT the task identifier).  This is used by
 *            systems that wish to use the handle to wait for task
 *            termination.  If lph is 0 the thread handle is closed here
 *
 * @parm    DWORD | dwStack | Specifies the size of the stack to be
 *            provided to the task.
 *
 * @parm    DWORD | dwInst | DWORD of instance data to pass to the task
 *            routine.
 *
 * @rdesc   Returns zero if the function is successful. Otherwise it
 *            returns an error value which may be one of the following:
 *
 *     @flag    TASKERR_NOTASKSUPPORT | Task support is not available.
 *     @flag    TASKERR_OUTOFMEMORY | Not enough memory to create task.
 *
 * @comm    When a mmsystem task is created, the system will make a far
 *          call to the program-supplied function whose address is
 *          specified by the lpfn parameter. This function may include
 *          local variables and may call other functions as long as
 *          the stack has sufficient space.
 *
 *          The task terminates when it returns.
 *
 * @xref    mmTaskSignal mmTaskBlock
 *
 ***************************************************************************/


UINT APIENTRY mmTaskCreate(LPTASKCALLBACK lpfn, HANDLE * lph, DWORD_PTR dwInst)
{
    DWORD            ThreadId;
    HANDLE           ThreadHandle;
    HANDLE           TerminationEvent;

    MM_THREAD_START_DATA *ThreadData;

   /*
    *  Create a block to pass stuff to our new thread
    */

    ThreadData = (MM_THREAD_START_DATA *)LocalAlloc(LPTR, sizeof(*ThreadData));

    if (ThreadData == NULL) {
        return TASKERR_OUTOFMEMORY;
    }

    ThreadData->dwInst = dwInst;
    ThreadData->lpfn = (LPTHREAD_START_ROUTINE)lpfn;

   /*
    *  We create an event which will be set when the thread terminates
    *  The initial state is NOT signalled.  This means that the handle
    *  can be waited on immediately.
    */

    if (lph) {
        ThreadData->TerminationEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (ThreadData->TerminationEvent == NULL) {
            LocalFree(ThreadData);
            return TASKERR_OUTOFMEMORY;
        }
    }

   /*
    *  The new thread will free ThreadData - copy of Termination Event handle
    */

    TerminationEvent = ThreadData->TerminationEvent;

   /*
    *  create another thread so that we can run the stream outside of
    *  the context of the app.
    */

    ThreadHandle = CreateThread(NULL,
                                MM_TASK_STACK_SIZE,
                                mmStartTask,
                                (LPVOID)ThreadData,
                                0,
                                &ThreadId);
    if (ThreadHandle) {
        if (lph) {
            *lph = TerminationEvent;
        }

        CloseHandle(ThreadHandle);
        dprintf2(("Created task with thread id %x", ThreadId));
        return 0;

    } else {
        if (lph) {
            CloseHandle(ThreadData->TerminationEvent);
        }
        LocalFree(ThreadData);
        return TASKERR_OUTOFMEMORY;
    }
}


/***************************************************************************
 *
 * @doc     DDK    MMSYSTEM    TASK
 *
 * @api     DWORD | mmStartTask | This function is a stub for a new task.
 *
 * @parm    LPVOID | lpThreadParameter |  Points to the data for the
 *            thread.  In our case this is an MM_THREAD_START_DATA
 *            packet.
 *
 * @rdesc   Returns the return code of the thread routine passed.
 *
 * @comm    When a mmsystem task is created, this routine will always be
 *          the entry point for it.  It calls the routine the application
 *          wanted then sets an event for termination.  The reason for this
 *          is that we often want to wait for the thread to terminate inside
 *          winmm's DLL init routine which deadlock if you wait for threads to
 *          really terminate.  On the other hand we don't want the thread to
 *          be executing other DLL's code at the point when we say we're
 *          finished because that DLL may be unloading.
 *
 *          The task terminates when it returns.
 *
 * @xref    mmTaskSignal mmTaskBlock
 *
 ***************************************************************************/
STATICFN DWORD mmStartTask(LPVOID lpThreadParameter)
{
    MM_THREAD_START_DATA ThreadData;
    DWORD ThreadReturn;


   /*
    *  Take a copy of the input data and free the allocated memory
    */

    ThreadData = *(MM_THREAD_START_DATA *)lpThreadParameter;
    LocalFree(lpThreadParameter);


   /*
    *  Call the real thread
    */

    ThreadReturn = (*ThreadData.lpfn)((PVOID)ThreadData.dwInst);

   /*
    *  The real thread is now finshed so set its event
    */

    if (ThreadData.TerminationEvent) {
        SetEvent(ThreadData.TerminationEvent);
    }


   /*
    *  Return the return code the thread wanted to return
    */

    return ThreadReturn;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\sources.inc ===
#
#   Create WINMM.DLL
#

MAJORCOMP=windows
MINORCOMP=winmm

TARGETNAME=winmm
TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows

DLLDEF=$(O)\winmm.def

# Define libs we need and where to find them

TARGETLIBS=$(WINDOWS_LIB_PATH)\user32p.lib     \
           $(LIBRARY_PATH)\gdi32.lib      \
           $(LIBRARY_PATH)\kernel32.lib   \
           $(LIBRARY_PATH)\advapi32.lib   \
           $(SDK_LIB_PATH)\setupapi.lib   \
           $(SDK_LIB_PATH)\ole32.lib      \
           $(DDK_LIB_PATH)\ksguid.lib     \
           $(LIBRARY_PATH)\rpcrt4.lib     \
           $(LIBRARY_PATH)\dinput.lib     \

INCLUDES=..\;..\..\inc;$(TERMSRV_INC_PATH);$(WINDOWS_INC_PATH);$(O);

MSC_WARNING_LEVEL=/W3 /WX

#
# Retail
#
C_DEFINES=$(C_DEFINES) -D_WINMM_ -DAGFX_EXPORTS

#DLLORDER=..\$(TARGETNAME).prf

#NTPROFILEINPUT=yes

#
# Debug (normally commented out but leave in file)
#
#C_DEFINES=$(C_DEFINES) -D_WINMM_ -DDEBUG -DWINVER=0x0400
#MSC_OPTIMIZATION=-Od -Zi
#NTDEBUG=ntsd
#NTDEBUGTYPE=both
#386_OPTIMIZATION=-Fc

USE_NTDLL=1

PASS1_PUBLISH={$(O)\$(TARGETNAME).lib=$(SDK_LIB_PATH)\$(TARGETNAME).lib}


SOURCES=..\audiosrv.idl   \
        ..\audiosrv_c.cpp \
        ..\audiosrvc.c     \
        ..\agfxc.c      \
        ..\regapi.c     \
        ..\csrthrd.c    \
        ..\auxout.c     \
        ..\drvr.c       \
        ..\drvrrare.c   \
        ..\debug.c      \
        ..\joy.c        \
        ..\mixer.c      \
        ..\mmwow32.c    \
        ..\mmwowmci.c   \
        ..\mci.c        \
        ..\mciparse.c   \
        ..\mcisys.c     \
        ..\mmwnd.c      \
        ..\mmio.c       \
        ..\mmioriff.c   \
        ..\mmiomisc.c   \
        ..\midi.c       \
        ..\midistrm.c   \
        ..\playsnd.c    \
        ..\playwav.c    \
        ..\time.c       \
        ..\task.c       \
        ..\util.c       \
        ..\winmm.c      \
        ..\wave.c       \
        ..\clock.c      \
        ..\midiemu.c    \
        ..\pref.c       \
        ..\winmm.rc

# Set up the entry point
DLLENTRY=DllInstanceInit

NTTARGETFILE0=audiosrv.idl audiosrv.acf
IDL_TYPE=RPC
PASS0_CLIENTDIR=$(O)
PASS0_HEADERDIR=$(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\time.c ===
/******************************************************************************

   Copyright (c) 1985-1999 Microsoft Corporation

   Title:   TIME.C : WINMM TIMER API

   Version: 1.00

   History:

       21 Feb 1992 - Robin Speed (RobinSp) converted to Windows NT

*****************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "winmmi.h"
#define _INC_ALL_WOWSTUFF
#include "mmwow32.h"

/****************************************************************************

    Structure shared between timer APIs and timer thread

****************************************************************************/

#define TDD_MINRESOLUTION 55        // in milliseconds
UINT TDD_MAXRESOLUTION;             // Should be 2 ... But ...

#define TDD_MAXPERIOD 1000000       // 1000 seconds
#define TDD_MINPERIOD TDD_MAXRESOLUTION   // Some apps assume this.

#define TIMER_STACK_SIZE 300

HANDLE hTimerThread;       // we need this to be global

#define ROUND_MIN_TIME_TO_MS(x)  (((x) + 9900) / 10000) // Special sloppy round
DWORD  MinimumTime;        // Kernel's version of the max res in 100ns units

typedef volatile struct {
    UINT             Delay;           // App requested delay (ms)
    UINT             Resolution;      // App requested resolution (ms)
    LPTIMECALLBACK   Callback;        // Whom to call when timer fires
    DWORD_PTR        User;            // Data to pass back when timer fires
    UINT             Id;              // Id allocated (bottom 4 bits = slot
                                      // id.
    UINT             Flags;           // App's option flags
    HANDLE           TimerHandle;     // Handle given to APP
    DWORD            ThreadId;        // Id of requestor thread (WOW cleanup)
    LARGE_INTEGER    FireTime;        // Time it should fire
    BOOL             IsWOW;           // For WOW events
} TIMER_EVENT;

//
// Data integrity
//

// Held while handling resolution.  ResolutionCritSec should always be 
// held when using TimerData.PeriodSlots, TimerData.CurrentPeriod and
// TimerData.CurrentActualPeriod.
CRITICAL_SECTION ResolutionCritSec;

// This critical section should be held when using Events, 
// TimerData.TimerNotCallingCallbackEvent, TimerData.CallbackTimerID 
// and TimerData.EventCount.  The critical section should also be held 
// while creating the timer thread.  This ensures that only one timer 
// thread is created.  This critical section should not be acquired if
// a thread already owns the ResolutionCritSec.  A deadlock will occur
// if this critical section is acquired after the ResolutionCritSec
// is acquired.
CRITICAL_SECTION TimerThreadCritSec;

DWORD TimerThreadId;

//
// Data used to communicate with timer thread and within timer thread
//

struct {
    //
    // Thread control (timerThread)
    //
    HANDLE           Event1;          // Synch event - schedules thread
    BOOL             Started;         // So WOW Cleanup doesn't deadlock

    UINT CallbackTimerID;             // The ID of the timer which is currently calling its' callback function.
                                      // This value is only valid if TimerCallingCallback is TRUE.
    BOOL TimerCallingCallback;        // TRUE if a timer is calling its' callback function on the timer thread. 
                                      // Otherwise FALSE.
    HANDLE TimerNotCallingCallbackEvent;  // This event is set if no timer is calling its' callback function on
                                          // the timer thread.  Otherwise it is not set.

    //
    // timeGetTime stuff
    //
    BOOL             UseTickCount;
    LARGE_INTEGER    InitialInterruptTick;
    DWORD            StartTick;
    DWORD            MinResolution;

    //
    // Internal to thread
    //
    UINT             CurrentPeriod;   // Current min res in ms
    DWORD            CurrentActualPeriod;
                                      // What the kernel gave us in ms
                                      // units
    DWORD            ThreadToKill;    // For WOW cleanup
    WORD             EventCount;      // For returning (fairly) unique handles
                                      // Make this WORD for WOW compatiblity
    WORD             PeriodSlots[TDD_MINRESOLUTION];

                                     // Count of what periods are set
} TimerData;

#define MAX_TIMER_EVENTS 16

TIMER_EVENT Events[MAX_TIMER_EVENTS];


/****************************************************************************

    Internal functions

****************************************************************************/
BOOL TimeInitThread(void);
void TimerCompletion(UINT TimerId);
BOOL timeSetTimerEvent(TIMER_EVENT *pEvent);
DWORD timeThread(LPVOID lpParameter);
LRESULT timeThreadSetEvent(TIMER_EVENT *pEvent);
void InitializeWaitEventArrays
    (
    UINT* pcObjects,
    HANDLE aTimers[MAX_TIMER_EVENTS + 1],
    UINT aEventIndexToTimerIDTable[MAX_TIMER_EVENTS+1]
    );

/*
**  Read the interrupt time from the kernel
*/

static LONGLONG __inline ReadInterruptTick(VOID) {
    LARGE_INTEGER InterruptTime;

    // Copy the interrupt time, verifying that the 64 bit quantity (copied
    // in two 32 bit operations) remains valid.
    // This may mean we need to iterate around the loop.
    do {
        InterruptTime.HighPart = USER_SHARED_DATA->InterruptTime.High1Time;
        InterruptTime.LowPart = USER_SHARED_DATA->InterruptTime.LowPart;
    } while (InterruptTime.HighPart != USER_SHARED_DATA->InterruptTime.High2Time);

    return InterruptTime.QuadPart;
}

/*
**  Calibrate our timer
*/
VOID CalibrateTimer(VOID)
{
    //
    // Find out the current time(s)
    //
    UINT n = 100;

    // We calibrate the timer by making sure that the tick count and
    // interrupt tick count are in step with each other.  Just in case
    // the hardware goes funny we put a limit on the number of times we
    // execute the loop.
    while (n) {
        DWORD EndTick;

        --n;
        TimerData.StartTick = GetCurrentTime();

        TimerData.InitialInterruptTick.QuadPart = ReadInterruptTick();

        EndTick = GetCurrentTime();

        if (EndTick == TimerData.StartTick) {
            dprintf2(("Timer calibrated, looped %d times", 100-n));
            break;
        }
    }
}


//  Calling this effectively leaks WINMM and makes sure we never
//  go through the DLL exit routine
//  This is used so we don't deadlock with shutting down our global threads
BOOL LoadWINMM()
{
    TCHAR sz[1000];
    BOOL bOK = 0 != GetModuleFileName(ghInst, sz, sizeof(sz) / sizeof(sz[0]));
    if (bOK) {
        HINSTANCE hInst = LoadLibrary(sz);
        if (hInst != NULL) {
            // ASSERT(hInst == ghInst);
        } else {
            bOK = FALSE;
        }
    }
    return bOK;
}

/****************************************************************************

    @doc INTERNAL

    @api BOOL | TimeInit | This function initialises the timer services.

    @rdesc The return value is TRUE if the services are initialised, FALSE
        if an error occurs.

    @comm it is not a FATAL error if a timer driver is not installed, this
          routine will allways return TRUE

****************************************************************************/

BOOL NEAR PASCAL TimeInit(void)
{
    //
    // Find out the maximum timer resolution we can support
    //
    {
        DWORD MaximumTime;
        DWORD CurrentTime;

        TimerData.MinResolution = TDD_MINRESOLUTION;

        if (!NT_SUCCESS(NtQueryTimerResolution(
                            &MaximumTime,
                            &MinimumTime,
                            &CurrentTime))) {


            TDD_MAXRESOLUTION = 10;     // was 16 for NT 3.1, 10 for NT 3.5
            dprintf2(("Kernel timer : using default maximum resolution"));
        } else {
            dprintf2(("               MaximumTime = %d", MaximumTime));
            dprintf2(("               CurrentTime = %d", CurrentTime));

            if ((MaximumTime + 9999) / 10000 < TDD_MINRESOLUTION) {
                TimerData.MinResolution = (MaximumTime + 9999) / 10000;
            }
            //
            //  On the x86 it's just over 1ms minimum to we allow a little
            //  leeway
            //
            TDD_MAXRESOLUTION = max(1, ROUND_MIN_TIME_TO_MS(MinimumTime));
        }
    }

    //
    //  Compute the relationship between our timer and the performance
    //  counter
    //
    CalibrateTimer();

    //
    //  Start out slowly !
    //
    TimerData.CurrentPeriod = TimerData.MinResolution;
    TimerData.CurrentActualPeriod = TimerData.CurrentPeriod;

    return TRUE;
}

/****************************************************************************

    @doc INTERNAL

    @api BOOL | TimeInitThread | This function initialises the timer thread.

    @rdesc The return value is TRUE if the services are initialised, FALSE
        if an error occurs.

    @comm it is not a FATAL error if a timer driver is not installed, this
          routine will allways return TRUE

****************************************************************************/

BOOL TimeInitThread(void)
{
    //  Make sure winmm never gets unloaded
    if (!LoadWINMM()) {
        return FALSE;
    }

    //
    // Set up events and create our thread
    //
    if (!NT_SUCCESS(NtCreateEvent(&TimerData.Event1,
                                  EVENT_ALL_ACCESS,
                                  NULL,
                                  SynchronizationEvent,
                                  FALSE))) {   // Not signalled
        return FALSE;
    }

    // Create an unnamed signaled manual reset event.  
    TimerData.TimerNotCallingCallbackEvent = CreateEvent(NULL, TRUE, TRUE, NULL);

    // CreateEvent() returns NULL if an error occurs.
    if (!TimerData.TimerNotCallingCallbackEvent) {
        NtClose(TimerData.Event1);
        TimerData.Event1 = NULL;
        return FALSE;
    }

    //
    // The thread will start up and wait on Event1 (alertably)
    //
    hTimerThread = CreateThread(NULL,
                           TIMER_STACK_SIZE,
                           timeThread,
                           NULL,
                           THREAD_SET_INFORMATION,
                           &TimerThreadId);
    if (!hTimerThread) {
        CloseHandle(TimerData.TimerNotCallingCallbackEvent);
        NtClose(TimerData.Event1);
        TimerData.TimerNotCallingCallbackEvent = NULL;
        TimerData.Event1 = NULL;
        return FALSE;
    }


    SetThreadPriority(hTimerThread, THREAD_PRIORITY_TIME_CRITICAL);


    return TRUE;
}

/****************************************************************************

    @doc EXTERNAL

    @api MMRESULT | timeGetSystemTime | This function retrieves the system time
    in milliseconds.  The system time is the time elapsed since
    Windows was started.

    @parm LPMMTIME | lpTime | Specifies a far pointer to an <t MMTIME> data
    structure.

    @parm UINT | wSize | Specifies the size of the <t MMTIME> structure.

    @rdesc Returns zero.
    The system time is returned in the <e MMTIME.ms> field of the <t MMTIME>
    structure.

    @comm The time is always returned in milliseconds.

    @xref timeGetTime
****************************************************************************/

MMRESULT APIENTRY timeGetSystemTime(LPMMTIME lpTime, UINT wSize)
{
    //
    // !!!WARNING DS is not setup right!!! see above
    //
    if (wSize < sizeof(MMTIME))
        return TIMERR_STRUCT;

    if (!ValidateWritePointer(lpTime,wSize)) {
        return TIMERR_STRUCT;
    }

    lpTime->u.ms  = timeGetTime();
    lpTime->wType = TIME_MS;

    return TIMERR_NOERROR;
}

/****************************************************************************

    @doc EXTERNAL

    @api UINT | timeSetEvent | This function sets up a timed callback event.
    The event can be a one-time event or a periodic event.  Once activated,
    the event calls the specified callback function.

    @parm UINT | wDelay | Specifies the event period in milliseconds.
    If the delay is less than the minimum period supported by the timer,
    or greater than the maximum period supported by the timer, the
    function returns an error.

    @parm UINT | wResolution | Specifies the accuracy of the delay in
    milliseconds. The resolution of the timer event increases with
    smaller <p wResolution> values. To reduce system overhead, use
    the maximum <p wResolution> value appropriate for your application.

    @parm LPTIMECALLBACK | lpFunction | Specifies the procedure address of
    a callback function that is called once upon expiration of a one-shot
    event or periodically upon expiration of periodic events.

    @parm DWORD | dwUser | Contains user-supplied callback data.

    @parm UINT | wFlags | Specifies the type of timer event, using one of
    the following flags:

    @flag TIME_ONESHOT | Event occurs once, after <p wPeriod> milliseconds.

    @flag TIME_PERIODIC | Event occurs every <p wPeriod> milliseconds.

    @rdesc Returns an ID code that identifies the timer event. Returns
    NULL if the timer event was not created. The ID code is also passed to
        the callback function.

    @comm Using this function to generate a high-frequency periodic-delay
    event (with a period less than 10 milliseconds) can consume a
        significant portion of the system CPU bandwidth.  Any call to
    <f timeSetEvent> for a periodic-delay timer
    must be paired with a call to <f timeKillEvent>.

    The callback function must reside in a DLL.  You don't have to use
    <f MakeProcInstance> to get a procedure-instance address for the callback
    function.

    @cb void CALLBACK | TimeFunc | <f TimeFunc> is a placeholder for the
    application-supplied function name.  The actual name must be exported by
    including it in the EXPORTS statement of the module-definition file for
    the DLL.

    @parm UINT | wID | The ID of the timer event.  This is the ID returned
       by <f timeSetEvent>.

    @parm UINT | wMsg | Not used.

    @parm DWORD | dwUser | User instance data supplied to the <p dwUser>
    parameter of <f timeSetEvent>.

    @parm DWORD | dw1 | Not used.

    @parm DWORD | dw2 | Not used.

    @comm Because the callback is accessed at interrupt time, it must
    reside in a DLL, and its code segment must be specified as FIXED
    in the module-definition file for the DLL.  Any data that the
    callback accesses must be in a FIXED data segment as well.
    The callback may not make any system calls except for <f PostMessage>,
    <f timeGetSystemTime>, <f timeGetTime>, <f timeSetEvent>,
    <f timeKillEvent>, <f midiOutShortMsg>,
    <f midiOutLongMsg>, and <f OutputDebugStr>.

    @xref timeKillEvent timeBeginPeriod timeEndPeriod

****************************************************************************/

UINT APIENTRY timeSetEvent(UINT wDelay, UINT wResolution,
    LPTIMECALLBACK lpFunction, DWORD_PTR dwUser, UINT wFlags)
{

    // verify the input flags
    // first remove the callback type, then check that only
    // time_periodic or time_oneshot are specified
    if (wFlags & ~(TIME_CALLBACK_TYPEMASK | TIME_ONESHOT | TIME_PERIODIC | TIME_KILL_SYNCHRONOUS)) {
        return(0);
    }

    return timeSetEventInternal(wDelay, wResolution, lpFunction,
                                dwUser, wFlags, FALSE);
}

UINT timeSetEventInternal(UINT wDelay, UINT wResolution,
    LPTIMECALLBACK lpFunction, DWORD_PTR dwUser, UINT wFlags, BOOL IsWOW)
{
    UINT TimerId;       // Our return value
    TIMER_EVENT Event;  // Event data for thread

    // V_TCALLBACK(lpFunction, MMSYSERR_INVALPARAM);

    //
    // First check our parameters
    //

    if (wDelay > TDD_MAXPERIOD || wDelay < TDD_MINPERIOD) {
        return 0;
    }

    //
    // if resolution is 0 set default resolution, otherwise
    // make sure the resolution is in range
    //

    if (wResolution > TimerData.MinResolution) {
        wResolution = TimerData.MinResolution;
    } else {
        if (wResolution < TDD_MAXRESOLUTION) {
            wResolution = TDD_MAXRESOLUTION;
        }
    }

    if (wResolution > wDelay) {
        wResolution = TimerData.MinResolution;
    }

    //
    // Remember time if it's periodic so we get accurate long term
    // timing.  Otherwise we'll just use the delay.
    //

    if ((wFlags & TIME_PERIODIC) || IsWOW) {
        Event.FireTime.QuadPart = ReadInterruptTick();
    }
    Event.Delay      = wDelay;
    Event.Resolution = wResolution;
    Event.Callback   = lpFunction;
    Event.User       = dwUser;
    Event.Flags      = wFlags;
    Event.ThreadId   = GetCurrentThreadId();  // For WOW cleanup
    Event.IsWOW      = IsWOW;

    //
    // Now set up the period to be used
    //
    if (timeBeginPeriod(wResolution) == MMSYSERR_NOERROR) {

        EnterCriticalSection(&TimerThreadCritSec);
        
        if (NULL == TimerData.Event1)
        {
            if (!TimeInitThread())
            {
                LeaveCriticalSection(&TimerThreadCritSec);            
                return(0);
            }
        }

        TimerId = (UINT)timeThreadSetEvent(&Event);

        LeaveCriticalSection(&TimerThreadCritSec);

        //
        // If we didn't get a good id give up
        //
        if (TimerId == 0) {
            timeEndPeriod(wResolution);
        }
    } else {
        TimerId = 0;
    }

    return TimerId;
}

/****************************************************************************

    @doc EXTERNAL

    @api MMRESULT | timeGetDevCaps | This function queries the timer device to
    determine its capabilities.

    @parm LPTIMECAPS | lpTimeCaps | Specifies a far pointer to a
        <t TIMECAPS> structure.  This structure is filled with information
        about the capabilities of the timer device.

    @parm UINT | wSize | Specifies the size of the <t TIMECAPS> structure.

    @rdesc Returns zero if successful. Returns TIMERR_NOCANDO if it fails
    to return the timer device capabilities.

****************************************************************************/

MMRESULT APIENTRY timeGetDevCaps(LPTIMECAPS lpTimeCaps, UINT wSize)
{
    if (wSize < sizeof(TIMECAPS)) {
        return TIMERR_NOCANDO;
    }

    if (!ValidateWritePointer(lpTimeCaps, wSize)) {
        return TIMERR_NOCANDO;
    }

    lpTimeCaps->wPeriodMin = TDD_MINPERIOD;
    lpTimeCaps->wPeriodMax = TDD_MAXPERIOD;
    return MMSYSERR_NOERROR;
}

/****************************************************************************

    @doc EXTERNAL

    @api MMRESULT | timeBeginPeriod | This function sets the minimum (lowest
    number of milliseconds) timer resolution that an application or
    driver is going to use. Call this function immediately before starting
    to use timer-event services, and call <f timeEndPeriod> immediately
    after finishing with the timer-event services.

    @parm UINT | wPeriod | Specifies the minimum timer-event resolution
    that the application or driver will use.

    @rdesc Returns zero if successful. Returns TIMERR_NOCANDO if the specified
    <p wPeriod> resolution value is out of range.

    @xref timeEndPeriod timeSetEvent

    @comm For each call to <f timeBeginPeriod>, you must call
    <f timeEndPeriod> with a matching <p wPeriod> value.
    An application or driver can make multiple calls to <f timeBeginPeriod>,
    as long as each <f timeBeginPeriod> call is matched with a
    <f timeEndPeriod> call.

****************************************************************************/
MMRESULT APIENTRY timeBeginPeriod(UINT uPeriod)
{

    dprintf3(("timeBeginPeriod %d", uPeriod));
    dprintf4(("     CurrentPeriod = %d, CurrentActualPeriod = %d",
              TimerData.CurrentPeriod, TimerData.CurrentActualPeriod));

    //
    // See if period is in our range
    //
    if (uPeriod < TDD_MAXRESOLUTION) {
        return TIMERR_NOCANDO;
    }

    if (uPeriod >= TimerData.MinResolution) {
        return MMSYSERR_NOERROR;
    }

    EnterCriticalSection(&ResolutionCritSec);

    //
    // See what's happening in our slot
    //
    if (TimerData.PeriodSlots[uPeriod - TDD_MAXRESOLUTION] ==
        0xFFFF) {
        //
        // Overflowed
        //
        LeaveCriticalSection(&ResolutionCritSec);
        return TIMERR_NOCANDO;
    }

    TimerData.PeriodSlots[uPeriod - TDD_MAXRESOLUTION]++;

    if (TimerData.PeriodSlots[uPeriod - TDD_MAXRESOLUTION] == 1 &&
        uPeriod < TimerData.CurrentActualPeriod) {

        DWORD NewPeriod100ns;

        //
        // Set the new period in our kernel driver handle
        // If it's just out then use the actual minimum
        //

        dprintf4(("timeBeginPeriod: setting resolution %d", uPeriod));

        NewPeriod100ns = uPeriod * 10000;
        if (NewPeriod100ns < MinimumTime) {
            NewPeriod100ns = MinimumTime;
        }

        if (!NT_SUCCESS(NtSetTimerResolution(
                            NewPeriod100ns,
                            TRUE,
                            &NewPeriod100ns))) {
            dprintf1(("timeBeginPeriod: Failed to set period %d", uPeriod));
            TimerData.PeriodSlots[uPeriod - TDD_MAXRESOLUTION]--;
            LeaveCriticalSection(&ResolutionCritSec);
            return TIMERR_NOCANDO;
        } else {
            //
            // This slot is just started to be used and is higher
            // resolution that currently set
            //

            TimerData.CurrentPeriod = uPeriod;
            TimerData.CurrentActualPeriod =
                                       ROUND_MIN_TIME_TO_MS(NewPeriod100ns);
            LeaveCriticalSection(&ResolutionCritSec);
            return MMSYSERR_NOERROR;
        }
    } else {
        //
        // No need to set period as it's already set
        //
        LeaveCriticalSection(&ResolutionCritSec);
        return MMSYSERR_NOERROR;
    }
}

/****************************************************************************

    @doc EXTERNAL

    @api MMRESULT | timeEndPeriod | This function clears a previously set
    minimum (lowest number of milliseconds) timer resolution that an
    application or driver is going to use. Call this function
    immediately after using timer event services.

    @parm UINT | wPeriod | Specifies the minimum timer-event resolution
    value specified in the previous call to <f timeBeginPeriod>.

    @rdesc Returns zero if successful. Returns TIMERR_NOCANDO if the specified
    <p wPeriod> resolution value is out of range.

    @xref timeBeginPeriod timeSetEvent

    @comm For each call to <f timeBeginPeriod>, you must call
    <f timeEndPeriod> with a matching <p wPeriod> value.
    An application or driver can make multiple calls to <f timeBeginPeriod>,
    as long as each <f timeBeginPeriod> call is matched with a
    <f timeEndPeriod> call.

****************************************************************************/
MMRESULT APIENTRY timeEndPeriod(UINT uPeriod)
{

    dprintf3(("timeEndPeriod %d", uPeriod));
    dprintf4(("     CurrentPeriod = %d, CurrentActualPeriod = %d",
              TimerData.CurrentPeriod, TimerData.CurrentActualPeriod));

    //
    // Round the period to our range
    //
    if (uPeriod < TDD_MAXRESOLUTION) {
        return TIMERR_NOCANDO;
    }

    if (uPeriod >= TimerData.MinResolution) {
        return MMSYSERR_NOERROR;
    }

    EnterCriticalSection(&ResolutionCritSec);

    //
    // See what's happening in our slot
    //
    if (TimerData.PeriodSlots[uPeriod - TDD_MAXRESOLUTION] == 0) {
        //
        // Oops ! Overflowed
        //
        LeaveCriticalSection(&ResolutionCritSec);
        return TIMERR_NOCANDO;
    }

    TimerData.PeriodSlots[uPeriod - TDD_MAXRESOLUTION]--;

    if (TimerData.PeriodSlots[uPeriod - TDD_MAXRESOLUTION] == 0 &&
        uPeriod == TimerData.CurrentPeriod) {

        DWORD CurrentTime;

        //
        // This slot is just finished and was the fastest
        // so find the next fastest
        //

        for (;uPeriod < TimerData.MinResolution; uPeriod++) {
            if (TimerData.PeriodSlots[uPeriod - TDD_MAXRESOLUTION] != 0) {
                break;
            }
        }


        //
        //  Reset the current setting
        //

        NtSetTimerResolution(TimerData.CurrentActualPeriod * 10000,
                             FALSE,
                             &CurrentTime);

        TimerData.CurrentActualPeriod = TimerData.MinResolution;
        TimerData.CurrentPeriod       = uPeriod;

        if (uPeriod >= TimerData.MinResolution) {
            //
            // Nobody's interested in timing any more
            //

        } else {

            //
            // Set the new period in the kernel
            //

            DWORD NewPeriod100ns;

            //
            // Set the new period in our kernel driver handle
            //

            dprintf4(("timeEndPeriod: setting resolution %d", uPeriod));

            if (!NT_SUCCESS(NtSetTimerResolution(
                                uPeriod * 10000,
                                TRUE,
                                &NewPeriod100ns))) {
                //
                //  This guy's OK but everyone else is hosed
                //

                dprintf1(("timeEndPeriod: Failed to set period %d", uPeriod));
            } else {
                TimerData.CurrentActualPeriod = (NewPeriod100ns + 9999) / 10000;
            }
        }
    }

    LeaveCriticalSection(&ResolutionCritSec);
    return MMSYSERR_NOERROR;
}

/****************************************************************************

    @doc EXTERNAL

    @api MMRESULT | timeKillEvent | This functions destroys a specified timer
    callback event.

    @parm UINT | wID | Identifies the event to be destroyed.

    @rdesc Returns zero if successful. Returns TIMERR_NOCANDO if the
    specified timer event does not exist.

    @comm The timer event ID specified by <p wID> must be an ID
        returned by <f timeSetEvent>.

    @xref  timeSetEvent

****************************************************************************/
MMRESULT APIENTRY timeKillEvent(UINT uId)
{
    MMRESULT mmr;
    TIMER_EVENT *pEvent;
    BOOL fWaitForCallbackToEnd;

    EnterCriticalSection(&TimerThreadCritSec);

    // This event will be initialized if timeSetEvent() was successfully called.
    if (NULL == TimerData.TimerNotCallingCallbackEvent) {
        LeaveCriticalSection(&TimerThreadCritSec);
        return TIMERR_NOCANDO;
    }

    pEvent = &Events[uId % MAX_TIMER_EVENTS];

    //
    // Find our event in the table and check it's there
    // This also catches already completed events
    //
    if (pEvent->Id != uId) {
        LeaveCriticalSection(&TimerThreadCritSec);
        return TIMERR_NOCANDO;
    }

    //
    // Release our event
    //
    timeEndPeriod(pEvent->Resolution);
    pEvent->Id = 0;

    if (!NT_SUCCESS(NtCancelTimer(pEvent->TimerHandle, NULL))) {
        mmr = TIMERR_NOCANDO;
    } else {
        mmr = MMSYSERR_NOERROR;
    }

    NtSetEvent(TimerData.Event1, NULL);

    fWaitForCallbackToEnd = ( TimerData.TimerCallingCallback &&
                              (uId == TimerData.CallbackTimerID) &&
                              (TimerThreadId != GetCurrentThreadId()) &&
                              (pEvent->Flags & TIME_KILL_SYNCHRONOUS) );

    LeaveCriticalSection(&TimerThreadCritSec);

    if ((MMSYSERR_NOERROR == mmr) && fWaitForCallbackToEnd) {
        WaitForSingleObject(TimerData.TimerNotCallingCallbackEvent, INFINITE);
    }

    return mmr;
}

/****************************************************************************

    @doc EXTERNAL

    @api DWORD | timeGetTime | This function retrieves the system time
    in milliseconds.  The system time is the time elapsed since
    Windows was started.

    @rdesc The return value is the system time in milliseconds.

    @comm The only difference between this function and
        the <f timeGetSystemTime> function is <f timeGetSystemTime>
        uses the standard multimedia time structure <t MMTIME> to return
        the system time.  The <f timeGetTime> function has less overhead than
        <f timeGetSystemTime>.

    @xref timeGetSystemTime

****************************************************************************/
DWORD APIENTRY timeGetTime(VOID)
{
    if (TimerData.UseTickCount) {
        //
        // Use the system service
        //
        return GetCurrentTime();
    } else {
        LARGE_INTEGER Difference;

        Difference.QuadPart = ReadInterruptTick() - TimerData.InitialInterruptTick.QuadPart;

        return (DWORD)(Difference.QuadPart / 10000) + TimerData.StartTick;
    }
}

/****************************************************************************

    @doc INTERNAL

    @api LRESULT | timeThread | The timer thread

    @parm LPVOID | lpParameter | the thread parameter (NULL here)

    @rdesc Never returns

    @comm Note that this thread serializes access to the events list

****************************************************************************/
#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)                   // Not all control paths return (due to infinite loop)
#endif

DWORD timeThread(LPVOID lpParameter)
{
    NTSTATUS    nts;
    UINT        cObjects;
    UINT        uiEventIDIndex;
    HANDLE      aTimers[MAX_TIMER_EVENTS + 1];
    UINT        aEventIndexToTimerIDTable[MAX_TIMER_EVENTS + 1];

    //
    // Tell people it's OK to call us from DLL init sections now
    //

    TimerData.Started = TRUE;
    InitializeWaitEventArrays( &cObjects, aTimers, aEventIndexToTimerIDTable );

    //
    // Sit in a loop waiting for something to do
    //
    for (;;) {
        nts = NtWaitForMultipleObjects(
                cObjects,   //  Number of objects (event + timers)
                aTimers,    //  Array of handles
                WaitAny,    //  Wait for any to signal
                TRUE,       //  Wait Alertably (???)
                NULL);      //  Wait forever

        if (STATUS_WAIT_0 == nts)
        {
            //  There's been some timer change (timeSetEvent, timeKillEvent),
            //  rebuild the array...

            InitializeWaitEventArrays( &cObjects, aTimers, aEventIndexToTimerIDTable );
        }
        else
        {
            if ((nts >= STATUS_WAIT_1) && (nts <= STATUS_WAIT_0 + MAX_TIMER_EVENTS))
            {
                uiEventIDIndex = nts - STATUS_WAIT_0;
                TimerCompletion(aEventIndexToTimerIDTable[uiEventIDIndex]);
            }
            else
            {
                WinAssert(FALSE);
            }
        }
    }

    return 1; // CreateThread() requires all threads to return a DWORD value.  The
              // value this thread returns has no meaning.
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

void InitializeWaitEventArrays
    (
    UINT* pcObjects,
    HANDLE aTimers[MAX_TIMER_EVENTS + 1],
    UINT aEventIndexToTimerIDTable[MAX_TIMER_EVENTS+1]
    )
{
    UINT cObjects;
    DWORD dwEventIndex;

    cObjects = 0;
    aTimers[cObjects++] = TimerData.Event1;

    EnterCriticalSection(&TimerThreadCritSec);
    for (dwEventIndex = 0; dwEventIndex < MAX_TIMER_EVENTS; dwEventIndex++)
    {
        if (0 != Events[dwEventIndex].Id)
        {
            aTimers[cObjects] = Events[dwEventIndex].TimerHandle;
            aEventIndexToTimerIDTable[cObjects] = Events[dwEventIndex].Id;
            cObjects++;
        }
    }

    *pcObjects = cObjects;

    LeaveCriticalSection(&TimerThreadCritSec);
}

/****************************************************************************

    @doc INTERNAL

    @api LRESULT | timeThread | The timer thread

    @parm PVOID | ApcContext | Our context - the wave buffer header

    @parm PIO_STATUS_BLOCK | The Io status block we used

    @rdesc None

****************************************************************************/

BOOL timeSetTimerEvent(TIMER_EVENT *pEvent)
{

    //
    // Work out time to fire (and store in case timer is periodic)
    //

    LONGLONG Delay;
    LARGE_INTEGER lDelay;

    //
    // Work out time to fire (and store in case timer is periodic)
    //

    pEvent->FireTime.QuadPart += pEvent->Delay*10000;

    if (pEvent->Flags & TIME_PERIODIC) {

        //
        //  Note that this arithmetic must allow for the case where
        //  timeGetTime() wraps.  We do this by computing delay as
        //  a signed quantity and testing the sign
        //
        Delay = ReadInterruptTick() - pEvent->FireTime.QuadPart;

    } else {

        Delay = -((LONGLONG)pEvent->Delay*10000);
    }

    //
    // If it's already fired then make the timer fire immediately
    // (or at least whichever is the latest - AD 1600 or now).
    // but DON'T call the callback now as we're in the TimerThreadCritSec!
    //

    if (Delay > 0) {
        // Delay = 0;   we no longer use Delay after this point
        lDelay.QuadPart = 0;
    } else {
        lDelay.QuadPart = Delay;
    }

    //
    // Create a timer if we haven't got one
    //
    if (pEvent->TimerHandle == NULL) {
        HANDLE TimerHandle;
        if (!NT_SUCCESS(NtCreateTimer(
                            &TimerHandle,
                            TIMER_ALL_ACCESS,
                            NULL,
                            NotificationTimer))) {
            return FALSE;
        }

        pEvent->TimerHandle = TimerHandle;
    }

    //
    //  Possibly valid since the timer API's are not synchronized anymore
    //

    //  WinAssert(pEvent->Id != 0);

    //
    // Set up a system timer
    //
    return
        NT_SUCCESS(
            NtSetTimer(pEvent->TimerHandle,
                       &lDelay,
                       NULL,
                       (PVOID)(DWORD_PTR)pEvent->Id,
                       FALSE,
                       0,
                       NULL));
}

/****************************************************************************

    @doc INTERNAL

    @api LRESULT | timeThreadSetEvent | Set a new event from the timer thread

    @parm TIMER_EVENT * | pEvent | Our Event

    @rdesc The new event id

****************************************************************************/
LRESULT timeThreadSetEvent(TIMER_EVENT *pEvent)
{
    UINT    i;
    LRESULT lr = 0;

    EnterCriticalSection(&TimerThreadCritSec);

    //
    // Find a free slot and fill it
    //

    for (i = 0; i < MAX_TIMER_EVENTS; i++) {
        //
        // Is the slot free ?
        //
        if (Events[i].Id == 0) {
            pEvent->TimerHandle = Events[i].TimerHandle;
            Events[i] = *pEvent;
            do {
                TimerData.EventCount += MAX_TIMER_EVENTS;
            } while (TimerData.EventCount == 0);
            Events[i].Id = i + TimerData.EventCount;
            break;   // Got our event
        }
    }

    if (i == MAX_TIMER_EVENTS) {
        lr = 0;
    } else {

        //
        // Set the new event in the driver
        //

        if (!timeSetTimerEvent(&Events[i])) {
            Events[i].Id = 0;   // Failed so free our slot
            lr = 0;
        } else {
            lr = Events[i].Id;
        }
    }

    LeaveCriticalSection(&TimerThreadCritSec);

    //  Notifying timer thread of changes..

    NtSetEvent(TimerData.Event1, NULL);
    return lr;
}

/****************************************************************************

    @doc INTERNAL

    @api void | TimerCompletion | Complete a timeout event

    @parm UINT | TimerId | Our timer handle

    @rdesc None

****************************************************************************/

void TimerCompletion(UINT TimerId)
{
    DWORD_PTR dpUser;
    TIMER_EVENT *pEvent;
    LPTIMECALLBACK pCallbackFunction;


    EnterCriticalSection(&TimerThreadCritSec);

    //
    // Find out where we are
    //

    pEvent = &Events[TimerId % MAX_TIMER_EVENTS];

    //
    // Synch up with timeKillEvent
    //

    if (pEvent->Id != TimerId) {
        LeaveCriticalSection(&TimerThreadCritSec);
        return;
    }

    if (pEvent->IsWOW) {

        //
        //  Adobe Premiere has to be sure the time has reached the time
        //  it expected.  But because the timer we use for timeGetTime is
        //  not the same (or at least not rounded the same) as the one used
        //  to set the events) this need not be the case here.
        //
        while(pEvent->FireTime.QuadPart - ReadInterruptTick() > 0) {
            Sleep(1);
        }
    }

    switch (pEvent->Flags & TIME_CALLBACK_TYPEMASK) {
        case TIME_CALLBACK_FUNCTION:

            TimerData.TimerCallingCallback = TRUE;
            TimerData.CallbackTimerID = pEvent->Id;
            ResetEvent(TimerData.TimerNotCallingCallbackEvent);

            dpUser = pEvent->User;
            pCallbackFunction = pEvent->Callback;

            LeaveCriticalSection(&TimerThreadCritSec);

            //
            // Call the callback
            //

#ifdef  _WIN64

            DriverCallback(
                *(PDWORD_PTR)&pCallbackFunction, // Function
                DCB_FUNCTION,                    // Type of callback
                (HDRVR)(DWORD_PTR)TimerId,       // Handle
                0,                               // msg = 0
                dpUser,                          // User data
                0,                               // dw1 = 0
                0);                              // dw2 = 0

#else   //  !WIN64

            if (pEvent->IsWOW) {
                WOW32DriverCallback(
                    *(DWORD *)&pCallbackFunction,    // Function
                    DCB_FUNCTION,                    // Type of callback
                    LOWORD(TimerId),                 // Handle
                    0,                               // msg = 0
                    (DWORD)dpUser,                   // User data
                    0,                               // dw1 = 0
                    0);                              // dw2 = 0
            } else {

                DriverCallback(
                    *(PDWORD_PTR)&pCallbackFunction, // Function
                    DCB_FUNCTION,                    // Type of callback
                    (HDRVR)TimerId,                  // Handle
                    0,                               // msg = 0
                    dpUser,                          // User data
                    0,                               // dw1 = 0
                    0);                              // dw2 = 0

            }

#endif  //  !WIN64

            EnterCriticalSection(&TimerThreadCritSec);

            TimerData.TimerCallingCallback = FALSE;
            SetEvent(TimerData.TimerNotCallingCallbackEvent);

            break;

        case TIME_CALLBACK_EVENT_SET:
            SetEvent((HANDLE)pEvent->Callback);
            break;

        case TIME_CALLBACK_EVENT_PULSE:
            PulseEvent((HANDLE)pEvent->Callback);
            break;

    }

    //
    //  The callback may have kill it, created new timers etc!
    //

    if (TimerId == pEvent->Id) {

        if (!(pEvent->Flags & TIME_PERIODIC)) {
            UINT uResolution;

            //
            // One-shot - so destroy the event
            //

            uResolution = pEvent->Resolution;  // Before we release the slot!
            pEvent->Id = 0;
            timeEndPeriod(uResolution);

            //  Not renewing the timer should remove it from the list...
            NtSetEvent(TimerData.Event1, NULL);

        } else {

            //
            // Try repeating the event
            //

            if (!timeSetTimerEvent(pEvent)) {
                UINT uResolution;

                //
                // Failed - so don't keep event hanging around
                //
                uResolution = pEvent->Resolution; // Before we release the slot!
                pEvent->Id = 0;
                timeEndPeriod(pEvent->Resolution);
            }
        } // Periodic processing
    }

    LeaveCriticalSection(&TimerThreadCritSec);
}

/****************************************************************************

    @doc INTERNAL

    @api void | TimerCleanup | Cleanup on thread termination or DLL unload

    @parm PVOID | ThreadId | Thread to clean up (WOW) or 0 for DLL unload

    @rdesc None

****************************************************************************/

void TimeCleanup(DWORD ThreadId)
{
    //
    // Always called from DLL init routine which is protected by process
    // semaphore so TimerData.ThreadToKill needs no extra protection
    // This variable is an input to the timer thread which either terminates
    // all timers or just those associated with the current thread (for WOW).
    //

    TimerData.ThreadToKill = ThreadId;

    //
    // Thread id of 0 means DLL cleanup
    //

    if (ThreadId == 0) {
        if (hTimerThread) {
#ifdef WRONG

            //
            // we also can not synchronize with the thread at ALL ! It may not
            // have gone through DLL initialization ! This means that during
            // our dll routines we can not do anything with the thread unless
            // we know for a fact the status of the thread !
            //
            // This could be fixed by setting a flag when the timer thread
            // goes through initialization (process mutex held) and testing
            // that flag here - but we don't exepect people to set timer
            // events and unload winmm.dll
            //

            if (TimerData.Started) {
                //
                // Kill any events (only for current thread if WOW).
                //
                {
                    int i;
                    for (i = 0; i < MAX_TIMER_EVENTS; i++) {
                        if (Events[i].Id &&
                            (TimerData.ThreadToKill == 0 ||
                             TimerData.ThreadToKill == Events[i].ThreadId)) {
                            timeKillEvent(Events[i].Id);
                        }
                    }
                }
            }

            //  WaitForSingleObject(hTimerThread, -1);
            //  We cannot wait for the thread to terminate as it will
            //  not go through DLL exit processing while we are doing
            //  our DLL exit processing
#endif
        }

        if (TimerData.Event1) {
            NtClose(TimerData.Event1);
        }

    } else {
        //
        // Per-thread Cleanup for WOW.  We don't touch anything if it
        // looks like nothing has run yet (so we might be caught out
        // if the thread is stopped in the middle of a timeSetEvent).
        //

        if (TimerData.Started) {
            //
            // Kill any events (only for current thread if WOW).
            //
            {
                int i;
                for (i = 0; i < MAX_TIMER_EVENTS; i++) {
                    if (Events[i].Id &&
                        (TimerData.ThreadToKill == 0 ||
                         TimerData.ThreadToKill == Events[i].ThreadId)) {
                        timeKillEvent(Events[i].Id);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\daytona\makefile.inc ===
audiosrv.idl : ..\..\audiosrv\audiosrv.idl
        copy ..\..\audiosrv\audiosrv.idl ..

audiosrv.acf : ..\..\audiosrv\audiosrv.acf
        copy ..\..\audiosrv\audiosrv.acf ..
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\winmm.c ===
/****************************************************************************\
*
*  Module Name : winmm.c
*
*  Multimedia support library
*
*  This module contains the entry point, startup and termination code
*
*  Copyright (c) 1991-2001 Microsoft Corporation
*
\****************************************************************************/

#define UNICODE
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "winmmi.h"
#include "mmioi.h"
#include "mci.h"
#include <regstr.h>
#include <winuser.h>
#include <wtsapi32.h>
#include <dbt.h>
#include <ks.h>
#include <ksmedia.h>
#include <winsta.h>
#include <stdlib.h>
#include "winuserp.h"

#include "audiosrvc.h"
#include "agfxp.h"
#define _INC_WOW_CONVERSIONS
#include "mmwow32.h"

BOOL WaveInit(void);
BOOL MidiInit(void);
BOOL AuxInit(void);
BOOL MixerInit(void);
void InitDevices(void);
HANDLE mmDrvOpen(LPWSTR szAlias);
void WOWAppExit(HANDLE hTask);
void MigrateSoundEvents(void);
UINT APIENTRY mmDrvInstall(HANDLE hDriver, WCHAR * wszDrvEntry, DRIVERMSGPROC drvMessage, UINT wFlags);
STATIC void NEAR PASCAL mregAddIniScheme(LPTSTR  lszSection,
                                         LPTSTR  lszSchemeID,
                                         LPTSTR  lszSchemeName,
                                         LPTSTR  lszINI);
STATIC void NEAR PASCAL mregCreateSchemeID(LPTSTR szSchemeName, LPTSTR szSchemeID);
int lstrncmpi (LPTSTR pszA, LPTSTR pszB, size_t cch);
void RemoveMediaPath (LPTSTR pszTarget, LPTSTR pszSource);

MMRESULT waveOutDesertHandle(HWAVEOUT hWaveOut);
MMRESULT waveInDesertHandle(HWAVEIN hWaveIn);
MMRESULT midiOutDesertHandle(HMIDIOUT hMidiOut);
MMRESULT midiInDesertHandle(HMIDIIN hMidiIn);
MMRESULT mixerDesertHandle(HMIXER hmx);

#ifndef cchLENGTH
#define cchLENGTH(_sz) (sizeof(_sz) / sizeof(_sz[0]))
#endif

/****************************************************************************

    global data

****************************************************************************/

HANDLE  ghInst;                         // Module handle
BOOL    gfDisablePreferredDeviceReordering = FALSE;
BOOL    WinmmRunningInServer;           // Are we running in the user/base server?
BOOL    WinmmRunningInWOW;              // Are we running in WOW
BOOL    WinmmRunningInSession;          // Are we running in remote session
WCHAR   SessionProtocolName[WPROTOCOLNAME_LENGTH];

//                                                                            |
// The tls is used simply as an indication that the thread has entered
// waveOutOpen or waveOutGetDevCaps for a non-mapper device.  Then, we detect
// re-entrancy into either of these APIs.  In the case of re-entrancy we
// might have a driver that is enumerating and caching device IDs.  To improve
// the chances of such a driver working, we disable preferred device
// reordering in this case.  Note we rely on the OS to initialize the tls to 0.
//
DWORD   gTlsIndex = TLS_OUT_OF_INDEXES; // Thread local storage index;

CRITICAL_SECTION DriverListCritSec;       // Protect driver interface globals
CRITICAL_SECTION DriverLoadFreeCritSec; // Protect driver load/unload
CRITICAL_SECTION NumDevsCritSec;      // Protect Numdevs/Device ID's
CRITICAL_SECTION MapperInitCritSec;   // Protect test of mapper initialized

HANDLE           hClientPnpInfo        = NULL;
PMMPNPINFO       pClientPnpInfo        = NULL;
CRITICAL_SECTION PnpCritSec;

RTL_RESOURCE     gHandleListResource;       //  Serializes access to handles.

BOOL gfLogon         = FALSE;

HANDLE  hEventApiInit = NULL;

WAVEDRV waveoutdrvZ;                  // wave output device driver list head
WAVEDRV waveindrvZ;                   // wave input device driver list head
MIDIDRV midioutdrvZ;                  // midi output device driver list
MIDIDRV midiindrvZ;                   // midi input device driver list
AUXDRV  auxdrvZ;                      // aux device driver list
UINT    wTotalMidiOutDevs;            // total midi output devices
UINT    wTotalMidiInDevs;             // total midi input devices
UINT    wTotalWaveOutDevs;            // total wave output devices
UINT    wTotalWaveInDevs;             // total wave input devices
UINT    wTotalAuxDevs;                // total auxiliary output devices
LONG    cPnpEvents;                   // number of processed pnp events
LONG    cPreferredDeviceChanges = 0;  // number of processed preferred device changes

typedef struct tag_wdmdeviceinterface *PWDMDEVICEINTERFACE;
typedef struct tag_wdmdeviceinterface
{
    PWDMDEVICEINTERFACE Next;
    DWORD               cUsage;
    LONG                cPnpEvents;
    WCHAR               szDeviceInterface[0];
    
} WDMDEVICEINTERFACE, *PWDMDEVICEINTERFACE;

WDMDEVICEINTERFACE wdmDevZ;

LPCRITICAL_SECTION acs[] = {
    &HandleListCritSec,
    &DriverListCritSec,
    &DriverLoadFreeCritSec,
    &MapperInitCritSec,
    &NumDevsCritSec,
    &PnpCritSec,
    &WavHdrCritSec,
    &SoundCritSec,
    &midiStrmHdrCritSec,
    &joyCritSec,
    &mciGlobalCritSec,
    &mciCritSec,
    &TimerThreadCritSec,
    &ResolutionCritSec
};

//  HACK!!!

SERVICE_STATUS_HANDLE   hss;
SERVICE_STATUS          gss;

#ifdef DEBUG_RETAIL
BYTE    fIdReverse;                   // reverse wave/midi id's
#endif

// For sounds:

STATIC TCHAR gszControlIniTime[] = TEXT("ControlIniTimeStamp");
TCHAR gszControlPanel[] = TEXT("Control Panel");
TCHAR gszSchemesRootKey[] = TEXT("AppEvents\\Schemes");
TCHAR gszJustSchemesKey[] = TEXT("Schemes");
TCHAR aszExplorer[] = TEXT("Explorer");
TCHAR aszDefault[] = TEXT(".Default");
TCHAR aszCurrent[] = TEXT(".Current");
TCHAR gszAppEventsKey[] = TEXT("AppEvents");
TCHAR gszSchemeAppsKey[] = TEXT("Apps");
TCHAR aszSoundsSection[] = TEXT("Sounds");
TCHAR aszSoundSection[] = TEXT("Sound");
TCHAR aszActiveKey[] = TEXT("Active");
TCHAR aszBoolOne[] = TEXT("1");

TCHAR asz2Format[] = TEXT("%s\\%s");
TCHAR asz3Format[] = TEXT("%s\\%s\\%s");
TCHAR asz4Format[] = TEXT("%s\\%s\\%s\\%s");
TCHAR asz5Format[] = TEXT("%s\\%s\\%s\\%s\\%s");
TCHAR asz6Format[] = TEXT("%s\\%s\\%s\\%s\\%s\\%s");

STATIC TCHAR aszSchemeLabelsKey[] = TEXT("EventLabels");
STATIC TCHAR aszSchemeNamesKey[] = TEXT("Names");
STATIC TCHAR aszControlINI[] = TEXT("control.ini");
STATIC TCHAR aszWinINI[] = TEXT("win.ini");
STATIC TCHAR aszSchemesSection[] = TEXT("SoundSchemes");
STATIC TCHAR gszSoundScheme[] = TEXT("SoundScheme.%s");
STATIC TCHAR aszCurrentSection[] = TEXT("Current");
STATIC TCHAR aszYourOldScheme[] = TEXT("Your Old Scheme");
STATIC TCHAR aszNone[] = TEXT("<none>");
STATIC TCHAR aszDummyDrv[] = TEXT("mmsystem.dll");
STATIC TCHAR aszDummySnd[] = TEXT("SystemDefault");
STATIC TCHAR aszDummySndValue[] = TEXT(",");
STATIC TCHAR aszExtendedSounds[] = TEXT("ExtendedSounds");
STATIC TCHAR aszExtendedSoundsYes[] = TEXT("yes");

STATIC TCHAR gszApp[] = TEXT("App");
STATIC TCHAR gszSystem[] = TEXT("System");

STATIC TCHAR gszAsterisk[] = TEXT("Asterisk");
STATIC TCHAR gszDefault[] = TEXT("Default");
STATIC TCHAR gszExclamation[] = TEXT("Exclamation");
STATIC TCHAR gszExit[] = TEXT("Exit");
STATIC TCHAR gszQuestion[] = TEXT("Question");
STATIC TCHAR gszStart[] = TEXT("Start");
STATIC TCHAR gszHand[] = TEXT("Hand");

STATIC TCHAR gszClose[] = TEXT("Close");
STATIC TCHAR gszMaximize[] = TEXT("Maximize");
STATIC TCHAR gszMinimize[] = TEXT("Minimize");
STATIC TCHAR gszOpen[] = TEXT("Open");
STATIC TCHAR gszRestoreDown[] = TEXT("RestoreDown");
STATIC TCHAR gszRestoreUp[] = TEXT("RestoreUp");

STATIC TCHAR aszOptionalClips[] = REGSTR_PATH_SETUP REGSTR_KEY_SETUP TEXT("\\OptionalComponents\\Clips");
STATIC TCHAR aszInstalled[] = TEXT("Installed");

STATIC TCHAR * gpszSounds[] = {
      gszClose,
      gszMaximize,
      gszMinimize,
      gszOpen,
      gszRestoreDown,
      gszRestoreUp,
      gszAsterisk,
      gszDefault,
      gszExclamation,
      gszExit,
      gszQuestion,
      gszStart,
      gszHand
   };

STATIC TCHAR aszMigration[] = TEXT("Migrated Schemes");
#define wCurrentSchemeMigrationLEVEL 1

static struct {
   LPCTSTR pszEvent;
   int idDescription;
   LPCTSTR pszApp;
} gaEventLabels[] = {
   { TEXT("AppGPFault"),         STR_LABEL_APPGPFAULT,         aszDefault   },
   { TEXT("Close"),              STR_LABEL_CLOSE,              aszDefault   },
   { TEXT("EmptyRecycleBin"),    STR_LABEL_EMPTYRECYCLEBIN,    aszExplorer  },
   { TEXT("Maximize"),           STR_LABEL_MAXIMIZE,           aszDefault   },
   { TEXT("MenuCommand"),        STR_LABEL_MENUCOMMAND,        aszDefault   },
   { TEXT("MenuPopup"),          STR_LABEL_MENUPOPUP,          aszDefault   },
   { TEXT("Minimize"),           STR_LABEL_MINIMIZE,           aszDefault   },
   { TEXT("Open"),               STR_LABEL_OPEN,               aszDefault   },
   { TEXT("RestoreDown"),        STR_LABEL_RESTOREDOWN,        aszDefault   },
   { TEXT("RestoreUp"),          STR_LABEL_RESTOREUP,          aszDefault   },
   { TEXT("RingIn"),             STR_LABEL_RINGIN,             aszDefault   },
   { TEXT("RingOut"),            STR_LABEL_RINGOUT,            aszDefault   },
   { TEXT("SystemAsterisk"),     STR_LABEL_SYSTEMASTERISK,     aszDefault   },
   { TEXT(".Default"),           STR_LABEL_SYSTEMDEFAULT,      aszDefault   },
   { TEXT("SystemExclamation"),  STR_LABEL_SYSTEMEXCLAMATION,  aszDefault   },
   { TEXT("SystemExit"),         STR_LABEL_SYSTEMEXIT,         aszDefault   },
   { TEXT("SystemHand"),         STR_LABEL_SYSTEMHAND,         aszDefault   },
   { TEXT("SystemQuestion"),     STR_LABEL_SYSTEMQUESTION,     aszDefault   },
   { TEXT("SystemStart"),        STR_LABEL_SYSTEMSTART,        aszDefault   },
};

TCHAR gszDefaultBeepOldAlias[] = TEXT("SystemDefault");

#define nEVENTLABELS  (sizeof(gaEventLabels)/sizeof(gaEventLabels[0]))

STATIC TCHAR gszChimes[] = TEXT("chimes.wav");
STATIC TCHAR gszDing[] = TEXT("ding.wav");
STATIC TCHAR gszTada[] = TEXT("tada.wav");
STATIC TCHAR gszChord[] = TEXT("chord.wav");

STATIC TCHAR * gpszKnownWAVFiles[] = {
      gszChord,
      gszTada,
      gszChimes,
      gszDing,
   };

#define INISECTION      768
#define BIGINISECTION   2048
TCHAR szNull[] = TEXT("");
TCHAR aszSetup[] = REGSTR_PATH_SETUP;
TCHAR aszValMedia[] = REGSTR_VAL_MEDIA;
TCHAR aszValMediaUnexpanded[] = TEXT("MediaPathUnexpanded");

extern HANDLE  hInstalledDriverList;  // List of installed driver instances
extern int     cInstalledDrivers;     // High water count of installed driver instances

HANDLE ghSessionNotification = NULL;
HANDLE ghSessionNotificationEvent = NULL;
BOOL   gfSessionDisconnected = FALSE;

#define g_szWinmmConsoleAudioEvent L"Global\\WinMMConsoleAudioEvent"


//=============================================================================
//===   Reg helpers   ===
//=============================================================================
LONG RegPrepareEnum(HKEY hkey, PDWORD pcSubkeys, PTSTR *ppstrSubkeyNameBuffer, PDWORD pcchSubkeyNameBuffer)
{
    DWORD cSubkeys;
    DWORD cchMaxSubkeyName;
    LONG lresult;

    lresult = RegQueryInfoKey(hkey, NULL, NULL, NULL, &cSubkeys, &cchMaxSubkeyName, NULL, NULL, NULL, NULL, NULL, NULL);
    if (ERROR_SUCCESS == lresult) {
        PTSTR SubkeyName;
        SubkeyName = (PTSTR)HeapAlloc(hHeap, 0, (cchMaxSubkeyName+1) * sizeof(TCHAR));
        if (SubkeyName) {
		*pcSubkeys = cSubkeys;
		*ppstrSubkeyNameBuffer = SubkeyName;
		*pcchSubkeyNameBuffer = cchMaxSubkeyName+1;
	} else {
	    lresult = ERROR_OUTOFMEMORY;
	}
    }
    return lresult;
}

LONG RegEnumOpenKey(HKEY hkey, DWORD dwIndex, PTSTR SubkeyName, DWORD cchSubkeyName, REGSAM samDesired, PHKEY phkeyResult)
{
    LONG lresult;

    lresult = RegEnumKeyEx(hkey, dwIndex, SubkeyName, &cchSubkeyName, NULL, NULL, NULL, NULL);
    if (ERROR_SUCCESS == lresult) {
	HKEY hkeyResult;
	lresult = RegOpenKeyEx(hkey, SubkeyName, 0, samDesired, &hkeyResult);
	if (ERROR_SUCCESS == lresult) *phkeyResult = hkeyResult;
    }
    return lresult;
}

/**************************************************************************

          Terminal server helper functions

 **************************************************************************/
BOOL
IsPersonalTerminalServicesEnabled(
    VOID
    )
{
    static BOOL fRet;
    static BOOL fVerified = FALSE;

    DWORDLONG dwlConditionMask;
    OSVERSIONINFOEX osVersionInfo;

    if ( fVerified )
        goto exitpt;

    RtlZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wProductType = VER_NT_WORKSTATION;
    osVersionInfo.wSuiteMask = VER_SUITE_SINGLEUSERTS;

    dwlConditionMask = 0;
    VER_SET_CONDITION(dwlConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);
    VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

    fRet = VerifyVersionInfo(
            &osVersionInfo,
            VER_PRODUCT_TYPE | VER_SUITENAME,
            dwlConditionMask
            );

    fVerified = TRUE;

exitpt:

    return(fRet);
}

//
//  Check if console audio is enabled in remote session
//
BOOL
IsTsConsoleAudio(
    VOID
    )
{
    BOOL    RemoteConsoleAudio = FALSE;            // Allow audio play at the console
    static  HANDLE hConsoleAudioEvent = NULL;


    if (NtCurrentPeb()->SessionId == 0 ||
        IsPersonalTerminalServicesEnabled()) {

        if (hConsoleAudioEvent == NULL) {
            hConsoleAudioEvent = OpenEvent(SYNCHRONIZE, FALSE, g_szWinmmConsoleAudioEvent);
        }

        if (hConsoleAudioEvent != NULL) {
            DWORD status;

            status = WaitForSingleObject(hConsoleAudioEvent, 0);

            if (status == WAIT_OBJECT_0) {
                RemoteConsoleAudio = TRUE;
            }
        }
        else {
            dprintf(("Remote session: console audio event NULL with error: %d\n", GetLastError()));
        }
    }

    return RemoteConsoleAudio;
}

//
//  returns TRUE if we are on the console
//
BOOL IsActiveConsoleSession( VOID )
{
    return (USER_SHARED_DATA->ActiveConsoleId == NtCurrentPeb()->SessionId);
}

void InitSession(void);
BOOL WaveReInit(void);

//
//  Check if the session is changed and load additional audio drivers
//  this is a case only for reconnecting the console from Terminal Server
//
BOOL
CheckSessionChanged(VOID)
{
    static BOOL bCalled = FALSE;
    static BOOL bWasntRedirecting;
    BOOL   bOld;
    BOOL   bDontRedirect;
    BOOL   bRefreshPreferredDevices;

    bRefreshPreferredDevices = FALSE;

    bDontRedirect = IsActiveConsoleSession() || IsTsConsoleAudio();

    if ( !InterlockedExchange( &bCalled, TRUE ))
    {
        bWasntRedirecting = !bDontRedirect;
    }

    bOld = InterlockedExchange( &bWasntRedirecting, bDontRedirect);
    if ( bOld ^ bWasntRedirecting )
    {
        //
        //  session conditions changed
        //

        dprintf(( "Session state changed: %s",
            (bWasntRedirecting)?"CONSOLE":"SESSION" ));
        //
        //  close the old registry handle
        //
        mmRegFree();

        //
        //  add new devices
        //
        InitSession();
        WaveReInit();

        bRefreshPreferredDevices = TRUE;
    }

    return bRefreshPreferredDevices;
}

/*****************************************************************************
 *
 * WTSCurrentSessionIsDisonnected
 *
 * Determines whether current session is disconnected.
 *
 ****************************************************************************/
BOOL WTSCurrentSessionIsDisconnected(void)
{
    if (NULL == ghSessionNotification)
    {
        // We create the event signalled so that we'll get the connect state
        // from audiosrv on first successful pass through this function.
        WinAssert(NULL == ghSessionNotificationEvent);
        ghSessionNotificationEvent = CreateEvent(NULL, FALSE, TRUE, NULL);
        if (ghSessionNotificationEvent) {
            LONG lresult;
            lresult = winmmRegisterSessionNotificationEvent(ghSessionNotificationEvent, &ghSessionNotification);
            if (lresult) {
                CloseHandle(ghSessionNotificationEvent);
                ghSessionNotificationEvent = NULL;
                ghSessionNotification = NULL;
            }
        }
    }

    if (ghSessionNotification) {
    	WinAssert(ghSessionNotificationEvent);
        if (WAIT_OBJECT_0 == WaitForSingleObjectEx(ghSessionNotificationEvent, 0, TRUE)) {
            INT ConnectState;
            LONG lresult;

            // Get new state from audiosrv
            lresult = winmmSessionConnectState(&ConnectState);
            if (!lresult) {
                gfSessionDisconnected = (WTSDisconnected == ConnectState);
            }
        }
    }

    return gfSessionDisconnected;
}

/**************************************************************************

    @doc EXTERNAL

    @api BOOL | mmDeleteMultipleCriticalSections | This procedure
        deletes multiple critical sections.

    @parm LPCRITICAL_SECTION* | ppCritcalSections | Pointer to an array of
        pointers to critical sections

    @parm LONG | nCount | Number of critical sections pointers in the array.

    @rdesc VOID

**************************************************************************/
void mmDeleteMultipleCriticalSections(LPCRITICAL_SECTION *ppCriticalSections, LONG nCount)
{
    int i;
    for (i = 0; i < nCount; i++) DeleteCriticalSection(ppCriticalSections[i]);
    return;
}

/**************************************************************************

    @doc EXTERNAL

    @api BOOL | mmInitializeMultipleCriticalSections | This procedure
        initializes multiple critical sections.

    @parm LPCRITICAL_SECTION* | ppCritcalSections | Pointer to an array of
        pointers to critical sections

    @parm LONG | nCount | Number of critical sections pointers in the array.

    @rdesc The return value is TRUE if the initialization completed ok,
        FALSE if not.

**************************************************************************/
BOOL mmInitializeMultipleCriticalSections(LPCRITICAL_SECTION *ppCriticalSections, LONG nCount)
{
    int i;      // Must be signed for loops to work properly

    for (i = 0; i < nCount; i++)
    {
        if (!mmInitializeCriticalSection(ppCriticalSections[i])) break;
    }

    if (i == nCount) return TRUE;

    // Back up index to the last successful initialization
    i--;

    // There must have been a failure.  Clean up the ones that succeeded.
    for ( ; i >= 0; i--)
    {
        DeleteCriticalSection(ppCriticalSections[i]);
    }
    return FALSE;
}

/*
 *    Initialization for terminal server
 */
void InitSession(void) {
   WSINFO SessionInfo;

   BOOL bCons = (BOOL)IsActiveConsoleSession();
   if ( bCons || IsTsConsoleAudio() )
        WinmmRunningInSession = FALSE;
   else
        WinmmRunningInSession = TRUE;

   if (WinmmRunningInSession) {

      memset( &SessionInfo, 0, sizeof(SessionInfo));
      GetWinStationInfo(&SessionInfo);
      lstrcpyW(SessionProtocolName, SessionInfo.ProtocolName);
      dprintf(("Remote session protocol %ls", SessionProtocolName));
      dprintf(("Remote audio driver name %ls", SessionInfo.AudioDriverName));

   } else {
      SessionProtocolName[0] = 0;
   }

}

/**************************************************************************

    @doc INTERNAL

    @api VOID | DeletePnpInfo | Frees the pClientPnpInfo file mapping
    
    @rdesc There is no return value

**************************************************************************/
void DeletePnpInfo(void)
{
    if (pClientPnpInfo) {
	BOOL f;

	WinAssert(hClientPnpInfo);

	f = UnmapViewOfFile(pClientPnpInfo);
	WinAssert(f);
	pClientPnpInfo = NULL;
	f = CloseHandle(hClientPnpInfo);
	WinAssert(f);
	hClientPnpInfo = NULL;
    }
    return;
}

/**************************************************************************

    @doc EXTERNAL

    @api BOOL | DllProcessAttach | This procedure is called whenever a
        process attaches to the DLL.

    @parm PVOID | hModule | Handle of the DLL.

    @rdesc The return value is TRUE if the initialisation completed ok,
        FALSE if not.

**************************************************************************/
BOOL DllProcessAttach(PVOID hModule)
{
    HANDLE hModWow32;
    PIMAGE_NT_HEADERS NtHeaders;    // For checking if we're in the server.
    BOOL fSuccess;

#if DBG
    CHAR strname[MAX_PATH];
    GetModuleFileNameA(NULL, strname, sizeof(strname));
    dprintf2(("Process attaching, exe=%hs (Pid %x  Tid %x)", strname, GetCurrentProcessId(), GetCurrentThreadId()));
#endif

    // We don't need to know when threads start
    DisableThreadLibraryCalls(hModule);

    // Get access to the process heap.  This is cheaper in terms of
    // overall resource being chewed up than creating our own heap.
    hHeap = RtlProcessHeap();
    if (hHeap == NULL) {
        return FALSE;
    }

    // Allocate our tls
    gTlsIndex = TlsAlloc();
    if (TLS_OUT_OF_INDEXES == gTlsIndex) return FALSE;

    //
    // Find out if we're in WOW
    //
#ifdef _WIN64
    WinmmRunningInWOW = FALSE;
#else
    if ( (hModWow32 = GetModuleHandleW( L"WOW32.DLL" )) != NULL ) {
        WinmmRunningInWOW = TRUE;
        GetVDMPointer = (LPGETVDMPOINTER)GetProcAddress( hModWow32, "WOWGetVDMPointer");
        lpWOWHandle32 = (LPWOWHANDLE32)GetProcAddress( hModWow32, "WOWHandle32" );
        lpWOWHandle16 = (LPWOWHANDLE16)GetProcAddress( hModWow32, "WOWHandle16" );
    } else {
        WinmmRunningInWOW = FALSE;
    }
#endif

    //
    // Find out if we're in the server
    //
    NtHeaders = RtlImageNtHeader(NtCurrentPeb()->ImageBaseAddress);

    WinmmRunningInServer = (NtHeaders->OptionalHeader.Subsystem != IMAGE_SUBSYSTEM_WINDOWS_CUI) &&
                           (NtHeaders->OptionalHeader.Subsystem != IMAGE_SUBSYSTEM_WINDOWS_GUI);

    if (mmInitializeMultipleCriticalSections(acs, sizeof(acs)/sizeof(acs[0])))
    {
        NTSTATUS    nts;
    
        hEventApiInit = CreateEvent(NULL, TRUE, FALSE, NULL);

        __try {
            RtlInitializeResource(&gHandleListResource);
            nts = STATUS_SUCCESS;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            nts = GetExceptionCode();
        }
        
        if ((hEventApiInit) && (NT_SUCCESS(nts))) {
            InitDebugLevel();
            InitSession();
            InitDevices();

            // it is important that the MCI window initialisation is done AFTER
            // we have initialised Wave, Midi, etc. devices.  Note the server
            // uses Wave devices, but nothing else (e.g. MCI, midi...)
            if (!WinmmRunningInServer) {
                mciGlobalInit();
            }
        } else {
            // EventApiInit Create failed
            if (hEventApiInit) CloseHandle(hEventApiInit);
            hEventApiInit = NULL;
            mmDeleteMultipleCriticalSections(acs, sizeof(acs)/sizeof(acs[0]));
            TlsFree(gTlsIndex);
            return (FALSE);
        }
    }
    else
    {
        //  Failed to initialize critical sections.
        TlsFree(gTlsIndex);
        return (FALSE);
    }

    // Added to remove warning.
    return TRUE;
}

/**************************************************************************

    @doc EXTERNAL

    @api BOOL | DllInstanceInit | This procedure is called whenever a
        process attaches or detaches from the DLL.

    @parm PVOID | hModule | Handle of the DLL.

    @parm ULONG | Reason | What the reason for the call is.

    @parm PCONTEXT | pContext | Some random other information.

    @rdesc The return value is TRUE if the initialisation completed ok,
        FALSE if not.

**************************************************************************/

BOOL DllInstanceInit(PVOID hModule, ULONG Reason, PCONTEXT pContext)
{
    PIMAGE_NT_HEADERS NtHeaders;    // For checking if we're in the server.
    HANDLE            hModWow32;
    DWORD             dwThread;
    BOOL              f;

    ghInst = (HANDLE) hModule;

    DBG_UNREFERENCED_PARAMETER(pContext);

    if (Reason == DLL_PROCESS_ATTACH) {

        return DllProcessAttach(hModule);

    } else if (Reason == DLL_PROCESS_DETACH) {

        dprintf2(("Process ending (Pid %x  Tid %x)", GetCurrentProcessId(), GetCurrentThreadId()));

        // Squirt("Entering process detach");

        // Can't really use RPC during DllMain, so let's just close first
        AudioSrvBindingFree();

        if (ghSessionNotification) 
        {
            WinAssert(ghSessionNotificationEvent);
            winmmUnregisterSessionNotification(ghSessionNotification);
            CloseHandle(ghSessionNotificationEvent);
            ghSessionNotification = NULL;
            ghSessionNotificationEvent = NULL;
        }
        else
        {
            WinAssert(!ghSessionNotificationEvent);
        }

        if (!WinmmRunningInServer) {
            TimeCleanup(0); // DLL cleanup
        }

        mmRegFree();
        JoyCleanup();                                           //qzheng

        DeletePnpInfo();

        if (hInstalledDriverList)
        {
            GlobalFree ((HGLOBAL)hInstalledDriverList);
            hInstalledDriverList = NULL;
            cInstalledDrivers = 0;      // Count of installed drivers
        }

        InvalidatePreferredDevices();

        if (hEventApiInit) CloseHandle(hEventApiInit);

        mmDeleteMultipleCriticalSections(acs, sizeof(acs)/sizeof(acs[0]));

        RtlDeleteResource(&gHandleListResource);

        TlsFree(gTlsIndex);
        
    } else if (Reason == 999) {
        // This is a dummy call to an entry point in ADVAPI32.DLL.  By
        // statically linking to the library we avoid the following:
        // An application links to winmm.dll and advapi32.dll
        // When the application loads the list of dependent dlls is built,
        // and a list of the dll init routines is created.  It happens
        // that the winmm init routine is called first.
        // IF there is a sound card in the system, winmm's dll init routine
        // call LoadLibrary on the sound driver DLL.  This DLL WILL
        // reference advapi32.dll - and call entry points in advapi32.
        // Unfortunately the init routine of advapi32.dll is marked as
        // having RUN - although that is not yet the case as we are still
        // within the load routine for winmm.
        // When the advapi32 entry point runs, it relies on its init
        // routine having completed; specifically a CriticalSection should
        // have been initialised.  This is not the case, and BOOM!
        // The workaround is to ensure that advapi32.dll runs its init
        // routine first.  This is done by making sure that WINMM has a
        // static link to the dll.
        ImpersonateSelf(999);   // This routine will never be called.
        // If it is called, it will fail.
    }

    return TRUE;
}


/*****************************************************************************
 * @doc EXTERNAL MMSYSTEM
 *
 * @api void | WOWAppExit | This function cleans up when a (WOW) application
 * terminates.
 *
 * @parm HANDLE | hTask | Thread id of application (equivalent to windows task
 * handle).
 *
 * @rdesc Nothing
 *
 * @comm  Note that NOT ALL threads are WOW threads.  We rely here on the
 *     fact that ONLY MCI creates threads other than WOW threads which
 *     use our low level device resources.
 *
 *     Note also that once a thread is inside here no other threads can
 *     go through here so, since we clean up MCI devices first, their
 *     low level devices will be freed before we get to their threads.
 *
 ****************************************************************************/

void WOWAppExit(HANDLE hTask)
{
    MCIDEVICEID DeviceID;
    HANDLE h, hNext;

    dprintf3(("WOW Multi-media - thread %x exiting", hTask));

    //
    // Free MCI devices allocated by this task (thread).
    //

    EnterCriticalSection(&mciCritSec);
    for (DeviceID=1; DeviceID < MCI_wNextDeviceID; DeviceID++)
    {

        if (MCI_VALID_DEVICE_ID(DeviceID) &&
            MCI_lpDeviceList[DeviceID]->hCreatorTask == hTask)
        {
            //
            //  Note that the loop control variables are globals so will be
            //  reloaded on each iteration.
            //
            //  Also no new devices will be opened by APPs because this is WOW
            //
            //  Hence it's safe (and essential!) to leave the critical
            //  section which we send the close command
            //

            dprintf2(("MCI device %ls (%d) not released.", MCI_lpDeviceList[DeviceID]->lpstrInstallName, DeviceID));
            LeaveCriticalSection(&mciCritSec);
            mciSendCommandW(DeviceID, MCI_CLOSE, 0, 0);
            EnterCriticalSection(&mciCritSec);
        }
    }
    LeaveCriticalSection(&mciCritSec);

    //
    // Free any timers
    //

    TimeCleanup((DWORD)(DWORD_PTR)hTask);

    //
    // free all WAVE/MIDI/MMIO handles
    //

    // ISSUE-2001/01/16-FrankYe This violates the order in which locks should
    //   be acquired.  The HandleListCritSec should be the last lock taken,
    //   but here it is held while calling winmm APIs
    EnterCriticalSection(&HandleListCritSec);
    h = GetHandleFirst();

    while (h)
    {
        hNext = GetHandleNext(h);

        if (GetHandleOwner(h) == hTask)
        {
            HANDLE hdrvDestroy;

            //
            //  hack for the wave/midi mapper, always free handles backward.
            //
            if (hNext && GetHandleOwner(hNext) == hTask) {
                h = hNext;
                continue;
            }

            //
            // do this so even if the close fails we will not
            // find it again.
            //
            SetHandleOwner(h, NULL);

            //
            // set the hdrvDestroy global so DriverCallback will not
            // do anything for this device
            //
            hdrvDestroy = h;

            switch(GetHandleType(h))
            {
                case TYPE_WAVEOUT:
                    dprintf1(("WaveOut handle (%04X) was not released.", h));
                    waveOutReset((HWAVEOUT)h);
                    waveOutClose((HWAVEOUT)h);
                    break;

                case TYPE_WAVEIN:
                    dprintf1(("WaveIn handle (%04X) was not released.", h));
                    waveInReset((HWAVEIN)h);
                    waveInClose((HWAVEIN)h);
                    break;

                case TYPE_MIDIOUT:
                    dprintf1(("MidiOut handle (%04X) was not released.", h));
                    midiOutReset((HMIDIOUT)h);
                    midiOutClose((HMIDIOUT)h);
                    break;

                case TYPE_MIDIIN:
                    dprintf1(("MidiIn handle (%04X) was not released.", h));
                    midiInReset((HMIDIIN)h);
                    midiInClose((HMIDIIN)h);
                    break;

                //
                // This is not required because WOW does not open any
                // mmio files.
                //
                // case TYPE_MMIO:
                //     dprintf1(("MMIO handle (%04X) was not released.", h));
                //     if (mmioClose((HMMIO)h, 0) != 0)
                //         mmioClose((HMMIO)h, MMIO_FHOPEN);
                //     break;
            }

            //
            // unset hdrvDestroy so DriverCallback will work.
            // some hosebag drivers (like the TIMER driver)
            // may pass NULL as their driver handle.
            // so dont set it to NULL.
            //
            hdrvDestroy = (HANDLE)-1;

            //
            // the reason we start over is because a single free may cause
            // multiple free's (ie MIDIMAPPER has another HMIDI open, ...)
            //
            h = GetHandleFirst();
        } else {
            h = GetHandleNext(h);
        }
    }
    LeaveCriticalSection(&HandleListCritSec);

    //
    // Clean up an installed IO procs for mmio
    //
    // This is not required because wow does not install any io procs.
    //
    // mmioCleanupIOProcs(hTask);
    //


    // If avicap32.dll is loaded, then ask it to clean up
    // capture drivers
    {
        HMODULE hmod;
        hmod = GetModuleHandle(TEXT("avicap32.dll"));
        if (hmod) {
            typedef void (*AppCleanupProc)(HANDLE);
            AppCleanupProc fp;

            fp = (AppCleanupProc) GetProcAddress(hmod, "AppCleanup");
            if (fp) {
                fp(hTask);
            }
        }
    }
}

BOOL IsWinlogon(void)
{
    TCHAR       szTarget[] = TEXT("winlogon.Exe");
    TCHAR       szTemp[MAX_PATH];
    UINT        ii;
    static BOOL	fAlreadyChecked = FALSE;
    static BOOL fIsWinlogon = FALSE;

    if (fAlreadyChecked) return fIsWinlogon;

    if (0 == GetModuleFileName(NULL, szTemp, sizeof(szTemp)/sizeof(szTemp[0])))
    {
        //
        //  GetModuleFileName fails...
        //

        return FALSE;
    }

    for (ii = lstrlen(szTemp) - 1; ii; ii--)
    {
        if ('\\' == szTemp[ii])
        {
            ii++;

	    fIsWinlogon = !lstrcmpi(&(szTemp[ii]), szTarget);
	    fAlreadyChecked = TRUE;
	    return fIsWinlogon;
        }
    }

    return FALSE;
}

void FreeUnusedDrivers(PMMDRV pmmdrvZ)
{
	PMMDRV pmmdrv = pmmdrvZ->Next;

	while (pmmdrv != pmmdrvZ)
	{
		PMMDRV pmmdrvNext = pmmdrv->Next;
		
		ASSERT(pmmdrv->hDriver);
		
		if ((0 == pmmdrv->NumDevs) && (0 == (pmmdrv->fdwDriver & MMDRV_DESERTED)))
		{
			// For pnp driver we send DRVM_EXIT
			if (pmmdrv->cookie) pmmdrv->drvMessage(0, DRVM_EXIT, 0L, 0L, (DWORD_PTR)pmmdrv->cookie);
			
			DrvClose(pmmdrv->hDriver, 0, 0);

                        DeleteCriticalSection(&pmmdrv->MixerCritSec);

			// Remove from list
			pmmdrv->Prev->Next = pmmdrv->Next;
			pmmdrv->Next->Prev = pmmdrv->Prev;

			// Zero memory to help catch reuse bugs
			ZeroMemory(pmmdrv, sizeof(*pmmdrv));
			
			HeapFree(hHeap, 0, pmmdrv);
		}
				
		pmmdrv = pmmdrvNext;
	}

	return;
}

extern BOOL IMixerLoadDrivers( void );
void InitDevices(void)
{
    cPnpEvents = 0;

    // Initialize various lists
    
    ZeroMemory(&wdmDevZ, sizeof(wdmDevZ));
    
    ZeroMemory(&waveoutdrvZ, sizeof(waveoutdrvZ));
    ZeroMemory(&waveindrvZ, sizeof(waveindrvZ));
    waveoutdrvZ.Next = waveoutdrvZ.Prev = &waveoutdrvZ;
    waveindrvZ.Next = waveindrvZ.Prev = &waveindrvZ;

    ZeroMemory(&midioutdrvZ, sizeof(midioutdrvZ));
    ZeroMemory(&midiindrvZ, sizeof(midiindrvZ));
    midioutdrvZ.Next = midioutdrvZ.Prev = &midioutdrvZ;
    midiindrvZ.Next = midiindrvZ.Prev = &midiindrvZ;

    ZeroMemory(&auxdrvZ, sizeof(auxdrvZ));
    auxdrvZ.Next = auxdrvZ.Prev = &auxdrvZ;

    ZeroMemory(&mixerdrvZ, sizeof(mixerdrvZ));
    mixerdrvZ.Next = mixerdrvZ.Prev = &mixerdrvZ;

    // Now initialize different device classes
    
    WaveInit();

    //
    // The server only needs wave to do message beeps.
    //

    if (!WinmmRunningInServer) {
        MidiInit();
        if (!TimeInit()) {
            dprintf1(("Failed to initialize timer services"));
        }
        midiEmulatorInit();
        AuxInit();
        JoyInit();
        MixerInit();
//      IMixerLoadDrivers();

        //
        // Clear up any drivers which don't have any devices (we do it this
        // way so we don't keep loading and unloading mmdrv.dll).
        //
        // Note - we only load the mappers if there are real devices so we
        // don't need to worry about unloading them.
        //
        
        FreeUnusedDrivers(&waveindrvZ);
        FreeUnusedDrivers(&midioutdrvZ);
        FreeUnusedDrivers(&midiindrvZ);
        FreeUnusedDrivers(&auxdrvZ);
    }
    FreeUnusedDrivers(&waveoutdrvZ);
}

/*****************************************************************************
 * @doc EXTERNAL MMSYSTEM
 *
 * @api UINT | mmsystemGetVersion | This function returns the current
 * version number of the Multimedia extensions system software.
 *
 * @rdesc The return value specifies the major and minor version numbers of
 * the Multimedia extensions.  The high-order byte specifies the major
 * version number.  The low-order byte specifies the minor version number.
 *
 ****************************************************************************/
UINT APIENTRY mmsystemGetVersion(void)
{
    return(MMSYSTEM_VERSION);
}


#define MAXDRIVERORDINAL 9

/****************************************************************************

    strings

****************************************************************************/
STATICDT  SZCODE szWodMessage[]    = WOD_MESSAGE;
STATICDT  SZCODE szWidMessage[]    = WID_MESSAGE;
STATICDT  SZCODE szModMessage[]    = MOD_MESSAGE;
STATICDT  SZCODE szMidMessage[]    = MID_MESSAGE;
STATICDT  SZCODE szAuxMessage[]    = AUX_MESSAGE;
STATICDT  SZCODE szMxdMessage[]    = MXD_MESSAGE;

STATICDT  WSZCODE wszWave[]        = L"wave";
STATICDT  WSZCODE wszMidi[]        = L"midi";
STATICDT  WSZCODE wszAux[]         = L"aux";
STATICDT  WSZCODE wszMixer[]       = L"mixer";
STATICDT  WSZCODE wszMidiMapper[]  = L"midimapper";
STATICDT  WSZCODE wszWaveMapper[]  = L"wavemapper";
STATICDT  WSZCODE wszAuxMapper[]   = L"auxmapper";
STATICDT  WSZCODE wszMixerMapper[] = L"mixermapper";

          WSZCODE wszNull[]        = L"";
          WSZCODE wszSystemIni[]   = L"system.ini";
          WSZCODE wszDrivers[]     = DRIVERS_SECTION;

/*
**  WaveMapperInit
**
**  Initialize the wave mapper if it's not already initialized.
**
*/
BOOL WaveMapperInitialized = FALSE;
void WaveMapperInit(void)
{
    HDRVR h = NULL;
    BOOL  fLoadOutput = TRUE;
    BOOL  fLoadInput  = TRUE;

    EnterNumDevs("WaveMapperInit");
    EnterCriticalSection(&MapperInitCritSec);

    if (WaveMapperInitialized) {
        LeaveCriticalSection(&MapperInitCritSec);
        LeaveNumDevs("WaveMapperInit");
        return;
    }

    /* The wave mapper.
     *
     * MMSYSTEM allows the user to install a special wave driver which is
     * not visible to the application as a physical device (it is not
     * included in the number returned from getnumdevs).
     *
     * An application opens the wave mapper when it does not care which
     * physical device is used to input or output waveform data. Thus
     * it is the wave mapper's task to select a physical device that can
     * render the application-specified waveform format or to convert the
     * data into a format that is renderable by an available physical
     * device.
     */

    if (wTotalWaveInDevs + wTotalWaveOutDevs > 0)
    {
        if (0 != (h = mmDrvOpen(wszWaveMapper)))
        {
            fLoadOutput = mmDrvInstall(h, wszWaveMapper, NULL, MMDRVI_MAPPER|MMDRVI_WAVEOUT|MMDRVI_HDRV);

            if (!WinmmRunningInServer) {
                h = mmDrvOpen(wszWaveMapper);
                fLoadInput = mmDrvInstall(h, wszWaveMapper, NULL, MMDRVI_MAPPER|MMDRVI_WAVEIN |MMDRVI_HDRV);
            }
        }

        WaveMapperInitialized |= ((0 != h) && (fLoadOutput) && (fLoadInput))?TRUE:FALSE;
    }

    LeaveCriticalSection(&MapperInitCritSec);
    LeaveNumDevs("WaveMapperInit");
}

/*
**  MidiMapperInit
**
**  Initialize the MIDI mapper if it's not already initialized.
**
*/
BOOL MidiMapperInitialized = FALSE;
void MidiMapperInit(void)
{
    HDRVR h;

    EnterNumDevs("MidiMapperInit");
    EnterCriticalSection(&MapperInitCritSec);

    if (MidiMapperInitialized) {
        LeaveCriticalSection(&MapperInitCritSec);
        LeaveNumDevs("MidiMapperInit");
        return;
    }

    /* The midi mapper.
     *
     * MMSYSTEM allows the user to install a special midi driver which is
     * not visible to the application as a physical device (it is not
     * included in the number returned from getnumdevs).
     *
     * An application opens the midi mapper when it does not care which
     * physical device is used to input or output midi data. It
     * is the midi mapper's task to modify the midi data so that it is
     * suitable for playback on the connected synthesizer hardware.
     */

//    EnterNumDevs("MidiMapperInit");
    if (wTotalMidiInDevs + wTotalMidiOutDevs > 0)
    {
        if (0 != (h = mmDrvOpen(wszMidiMapper)))
        {
            mmDrvInstall(h, wszMidiMapper, NULL, MMDRVI_MAPPER|MMDRVI_MIDIOUT|MMDRVI_HDRV);

            h = mmDrvOpen(wszMidiMapper);
            mmDrvInstall(h, wszMidiMapper, NULL, MMDRVI_MAPPER|MMDRVI_MIDIIN |MMDRVI_HDRV);
        }

        MidiMapperInitialized = TRUE;
    }
//    LeaveNumDevs("MidiMapperInit");

    LeaveCriticalSection(&MapperInitCritSec);
    LeaveNumDevs("MidiMapperInit");
}

/*****************************************************************************
 * @doc INTERNAL  WAVE
 *
 * @api BOOL | WaveInit | This function initialises the wave services.
 *
 * @rdesc Returns TRUE if the services of all loaded wave drivers are
 *      correctly initialised, FALSE if an error occurs.
 *
 * @comm the wave devices are loaded in the following order
 *
 *      \Device\WaveIn0
 *      \Device\WaveIn1
 *      \Device\WaveIn2
 *      \Device\WaveIn3
 *
 ****************************************************************************/
BOOL WaveInit(void)
{
    WCHAR szKey[ (sizeof(wszWave) + sizeof( WCHAR )) / sizeof( WCHAR ) ];
    int i;
    HDRVR h;

    // Find the real WAVE drivers

    lstrcpyW(szKey, wszWave);
    szKey[ (sizeof(szKey) / sizeof( WCHAR ))  - 1 ] = (WCHAR)'\0';
    for (i=0; i<=MAXDRIVERORDINAL; i++)
    {
        h = mmDrvOpen(szKey);
        if (h)
        {
            mmDrvInstall(h, szKey, NULL, MMDRVI_WAVEOUT|MMDRVI_HDRV);

            if (!WinmmRunningInServer) {
                h = mmDrvOpen(szKey);
                mmDrvInstall(h, szKey, NULL, MMDRVI_WAVEIN |MMDRVI_HDRV);
            }
        }
        szKey[ (sizeof(wszWave) / sizeof(WCHAR)) - 1] = (WCHAR)('1' + i);
    }

    return TRUE;
}

BOOL WaveReInit(void)
{
    WCHAR szKey[ (sizeof(wszWave) + sizeof( WCHAR )) / sizeof( WCHAR ) ];
    int i;
    HDRVR h;

    EnterCriticalSection(&NumDevsCritSec);
    
    // Find the real WAVE drivers

    lstrcpyW(szKey, wszWave);
    szKey[ (sizeof(szKey) / sizeof( WCHAR ))  - 1 ] = (WCHAR)'\0';
    for (i=0; i<=MAXDRIVERORDINAL; i++)
    {
        h = mmDrvOpen(szKey);
        if (h)
        {
            mmDrvInstall(h, szKey, NULL, MMDRVI_WAVEOUT|MMDRVI_HDRV);

            if (!WinmmRunningInServer) {
                h = mmDrvOpen(szKey);
                mmDrvInstall(h, szKey, NULL, MMDRVI_WAVEIN |MMDRVI_HDRV);
            }
        }
        szKey[ (sizeof(wszWave) / sizeof(WCHAR)) - 1] = (WCHAR)('1' + i);
    }

    FreeUnusedDrivers(&waveoutdrvZ);

    LeaveCriticalSection(&NumDevsCritSec);

    return TRUE;
}
/*****************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @api BOOL | MidiInit | This function initialises the midi services.
 *
 * @rdesc The return value is TRUE if the services are initialised, FALSE if
 *      an error occurs
 *
 * @comm the midi devices are loaded from SYSTEM.INI in the following order
 *
 *      midi
 *      midi1
 *      midi2
 *      midi3
 *
****************************************************************************/
BOOL MidiInit(void)
{
    WCHAR szKey[ (sizeof(wszMidi) + sizeof( WCHAR )) / sizeof( WCHAR ) ];
    int   i;
    HDRVR h;

    // Find the real MIDI drivers

    lstrcpyW(szKey, wszMidi);
    szKey[ (sizeof(szKey) / sizeof( WCHAR ))  - 1 ] = (WCHAR)'\0';
    for (i=0; i<=MAXDRIVERORDINAL; i++)
    {
        h = mmDrvOpen(szKey);
        if (h)
        {
            mmDrvInstall(h, szKey, NULL, MMDRVI_MIDIOUT|MMDRVI_HDRV);

            h = mmDrvOpen(szKey);
            mmDrvInstall(h, szKey, NULL, MMDRVI_MIDIIN |MMDRVI_HDRV);
        }

        szKey[ (sizeof(wszMidi) / sizeof(WCHAR)) - 1] = (WCHAR)('1' + i);
    }

    return TRUE;
}

/*****************************************************************************
 * @doc INTERNAL  AUX
 *
 * @api BOOL | AuxInit | This function initialises the auxiliary output
 *  services.
 *
 * @rdesc The return value is TRUE if the services are initialised, FALSE if
 *      an error occurs
 *
 * @comm SYSTEM.INI is searched for auxn.drv=.... where n can be from 1 to 4.
 *      Each driver is loaded and the number of devices it supports is read
 *      from it.
 *
 *      AUX devices are loaded from SYSTEM.INI in the following order
 *
 *      aux
 *      aux1
 *      aux2
 *      aux3
 *
 ****************************************************************************/
BOOL AuxInit(void)
{
    WCHAR szKey[ (sizeof(wszAux) + sizeof( WCHAR )) / sizeof( WCHAR ) ];
    int   i;
    HDRVR h;

    // Find the real Aux drivers

    lstrcpyW(szKey, wszAux);
    szKey[ (sizeof(szKey) / sizeof( WCHAR ))  - 1 ] = (WCHAR)'\0';
    for (i=0; i<=MAXDRIVERORDINAL; i++)
    {
        h = mmDrvOpen(szKey);
        if (h)
        {
            mmDrvInstall(h, szKey, NULL, MMDRVI_AUX|MMDRVI_HDRV);
        }

        // advance driver ordinal
        szKey[ (sizeof(wszAux) / sizeof(WCHAR)) - 1] = (WCHAR)('1' + i);
    }

    /* The aux mapper.
     *
     * MMSYSTEM allows the user to install a special aux driver which is
     * not visible to the application as a physical device (it is not
     * included in the number returned from getnumdevs).
     *
     * I'm not sure why anyone would do this but I'll provide the
     * capability for symmetry.
     *
     */

    if (wTotalAuxDevs > 0)
    {
        h = mmDrvOpen(wszAuxMapper);
        if (h)
        {
            mmDrvInstall(h, wszAuxMapper, NULL, MMDRVI_MAPPER|MMDRVI_AUX|MMDRVI_HDRV);
        }
    }

    return TRUE;
}

/*****************************************************************************
 * @doc INTERNAL  MIXER
 *
 * @api BOOL | MixerInit | This function initialises the mixer drivers
 *  services.
 *
 * @rdesc The return value is TRUE if the services are initialised, FALSE if
 *      an error occurs
 *
 * @comm SYSTEM.INI is searched for mixern.drv=.... where n can be from 1 to 4.
 *      Each driver is loaded and the number of devices it supports is read
 *      from it.
 *
 *      MIXER devices are loaded from SYSTEM.INI in the following order
 *
 *      mixer
 *      mixer1
 *      mixer2
 *      mixer3
 *
 ****************************************************************************/
BOOL MixerInit(void)
{
    WCHAR szKey[ (sizeof(wszMixer) + sizeof( WCHAR )) / sizeof( WCHAR ) ];
    int   i;
    HDRVR h;

    // Find the real Mixer drivers

    lstrcpyW(szKey, wszMixer);
    szKey[ (sizeof(szKey) / sizeof( WCHAR ))  - 1 ] = (WCHAR)'\0';
    for (i=0; i<=MAXDRIVERORDINAL; i++)
    {
        h = mmDrvOpen(szKey);
        if (h)
        {
            mmDrvInstall(h, szKey, NULL, MMDRVI_MIXER|MMDRVI_HDRV);
        }

        // advance driver ordinal
        szKey[ (sizeof(wszMixer) / sizeof(WCHAR)) - 1] = (WCHAR)('1' + i);
    }

#ifdef MIXER_MAPPER
    /* The Mixer mapper.
     *
     * MMSYSTEM allows the user to install a special aux driver which is
     * not visible to the application as a physical device (it is not
     * included in the number returned from getnumdevs).
     *
     * I'm not sure why anyone would do this but I'll provide the
     * capability for symmetry.
     *
     */

    if (guTotalMixerDevs > 0)
    {
        h = mmDrvOpen(wszMixerMapper);
        if (h)
        {
            mmDrvInstall(h, wszMixerMapper, NULL, MMDRVI_MAPPER|MMDRVI_MIXER|MMDRVI_HDRV);
        }
    }
#endif

    return TRUE;
}


/*****************************************************************************
 *
 * @doc   INTERNAL
 *
 * @api   HANDLE | mmDrvOpen | This function load's an installable driver, but
 *                 first checks weather it exists in the [Drivers] section.
 *
 * @parm LPSTR | szAlias | driver alias to load
 *
 * @rdesc The return value is return value from DrvOpen or NULL if the alias
 *        was not found in the [Drivers] section.
 *
 ****************************************************************************/

HANDLE mmDrvOpen(LPWSTR szAlias)
{
    WCHAR buf[300];    // Make this large to bypass GetPrivate... bug

    if ( winmmGetPrivateProfileString( wszDrivers,
                                       szAlias,
                                       wszNull,
                                       buf,
                                       sizeof(buf) / sizeof(WCHAR),
                                       wszSystemIni) ) {
        return (HANDLE)DrvOpen(szAlias, NULL, 0L);
    }
    else {
        return NULL;
    }
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api HANDLE | mmDrvInstall | This function installs/removes a WAVE/MIDI driver
 *
 * @parm HANDLE | hDriver | Module handle or driver handle containing driver
 *
 * @parm WCHAR * | wszDrvEntry | String corresponding to hDriver to be stored for
 *      later use
 *
 * @parm DRIVERMSGPROC | drvMessage | driver message procedure, if NULL
 *      the standard name will be used (looked for with GetProcAddress)
 *
 * @parm UINT | wFlags | flags
 *
 *      @flag MMDRVI_TYPE      | driver type mask
 *      @flag MMDRVI_WAVEIN    | install driver as a wave input  driver
 *      @flag MMDRVI_WAVEOUT   | install driver as a wave ouput  driver
 *      @flag MMDRVI_MIDIIN    | install driver as a midi input  driver
 *      @flag MMDRVI_MIDIOUT   | install driver as a midi output driver
 *      @flag MMDRVI_AUX       | install driver as a aux driver
 *      @flag MMDRVI_MIXER     | install driver as a mixer driver
 *
 *      @flag MMDRVI_MAPPER    | install this driver as the mapper
 *      @flag MMDRVI_HDRV      | hDriver is a installable driver
 *      @flag MMDRVI_REMOVE    | remove the driver
 *
 *  @rdesc  returns NULL if unable to install driver
 *
 ****************************************************************************/

UINT APIENTRY mmDrvInstall(
    HANDLE hDriver,
    WCHAR * wszDrvEntry,
    DRIVERMSGPROC drvMessage,
    UINT wFlags
    )
{
#define SZ_SIZE 128

    int     i;
    DWORD   dw;
    PMMDRV  pdrvZ;
    PMMDRV  pdrv;
    SIZE_T  cbdrv;
    HANDLE  hModule;
    UINT    msg_num_devs;
    UINT   *pTotalDevs;
    CHAR   *szMessage;
    WCHAR   sz[SZ_SIZE];
    BOOL    fMixerCritSec;

    fMixerCritSec = FALSE;
    pdrvZ = NULL;
    pdrv = NULL;

    if (hDriver && (wFlags & MMDRVI_HDRV))
    {
        hModule = DrvGetModuleHandle(hDriver);
    }
    else
    {
        hModule = hDriver;
        hDriver = NULL;
    }

    switch (wFlags & MMDRVI_TYPE)
    {
        case MMDRVI_WAVEOUT:
      	    pdrvZ        = &waveoutdrvZ;
            cbdrv        = sizeof(WAVEDRV);
            msg_num_devs = WODM_GETNUMDEVS;
            pTotalDevs   = &wTotalWaveOutDevs;
            szMessage    = szWodMessage;
            break;

        case MMDRVI_WAVEIN:
            pdrvZ        = &waveindrvZ;
            cbdrv        = sizeof(WAVEDRV);
            msg_num_devs = WIDM_GETNUMDEVS;
            pTotalDevs   = &wTotalWaveInDevs;
            szMessage    = szWidMessage;
            break;

        case MMDRVI_MIDIOUT:
            pdrvZ        = &midioutdrvZ;
            cbdrv        = sizeof(MIDIDRV);
            msg_num_devs = MODM_GETNUMDEVS;
            pTotalDevs   = &wTotalMidiOutDevs;
            szMessage    = szModMessage;
            break;

        case MMDRVI_MIDIIN:
            pdrvZ        = &midiindrvZ;
            cbdrv        = sizeof(MIDIDRV);
            msg_num_devs = MIDM_GETNUMDEVS;
            pTotalDevs   = &wTotalMidiInDevs;
            szMessage    = szMidMessage;
            break;

       case MMDRVI_AUX:
       	    pdrvZ        = &auxdrvZ;
       	    cbdrv        = sizeof(AUXDRV);
            msg_num_devs = AUXDM_GETNUMDEVS;
            pTotalDevs   = &wTotalAuxDevs;
            szMessage    = szAuxMessage;
            break;

       case MMDRVI_MIXER:
            pdrvZ         = &mixerdrvZ;
            cbdrv         = sizeof(MIXERDRV);
            msg_num_devs = MXDM_GETNUMDEVS;
            pTotalDevs   = &guTotalMixerDevs;
            szMessage    = szMxdMessage;
            break;

         default:
            goto error_exit;
    }

    if (drvMessage == NULL && hModule != NULL)
        drvMessage = (DRIVERMSGPROC)GetProcAddress(hModule, szMessage);

    if (drvMessage == NULL)
        goto error_exit;

    //
    // try to find the driver already installed
    //
    pdrv = pdrvZ->Next;
    while (pdrv != pdrvZ && pdrv->drvMessage != drvMessage) pdrv = pdrv->Next;
    if (pdrv != pdrvZ)
    {
    	pdrv = NULL;
    	goto error_exit;	// we found it, don't reinstall it
    }

    //
    // Make a new MMDRV for the device.
    //
    pdrv = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, cbdrv);
    if (!pdrv) goto error_exit;

    pdrv->hDriver     = hDriver;
    pdrv->Usage       = 1;
    pdrv->cookie      = 0;  //  This is 0 for non-WDM drivers.
    pdrv->fdwDriver   = (wFlags & MMDRVI_MAPPER) ? MMDRV_MAPPER : 0;
    pdrv->fdwDriver  |= DrvIsPreXp(hDriver) ? MMDRV_PREXP : 0;
    pdrv->drvMessage  = drvMessage;
    WinAssert(lstrlenA(szMessage) < sizeof(pdrv->wszMessage)/sizeof(WCHAR));
    mbstowcs(pdrv->wszMessage, szMessage, sizeof(pdrv->wszMessage)/sizeof(WCHAR));
    lstrcpyW( pdrv->wszSessProtocol, SessionProtocolName );

    winmmGetPrivateProfileString(wszDrivers,         // ini section
                     wszDrvEntry,        // key name
                     wszDrvEntry,        // default if no match
                     sz,                 // return buffer
                     SZ_SIZE,            // sizeof of return buffer
                     wszSystemIni);      // ini. file

    lstrcpyW(pdrv->wszDrvEntry,sz);

    if (!mmInitializeCriticalSection(&pdrv->MixerCritSec)) goto error_exit;
    fMixerCritSec = TRUE;

    //
    //  Mixer drivers get extra message?!
    //
    if (MMDRVI_MIXER == (wFlags & MMDRVI_TYPE))
    {
        //
        //  send the init message, if the driver returns a error, should we
        //  unload them???
        //
        dw = drvMessage(0, MXDM_INIT,0L,0L,0L);
    }

    //
    // call driver to get num-devices it supports
    //
    dw = drvMessage(0,msg_num_devs,0L,0L,0L);

    //
    //  the device returned a error, or has no devices
    //
    // if (HIWORD(dw) != 0 || LOWORD(dw) == 0)
    if ((HIWORD(dw) != 0) || (0 == LOWORD(dw))) goto error_exit;

    pdrv->NumDevs = LOWORD(dw);

    //
    // dont increment number of dev's for the mapper
    //
    if (!(pdrv->fdwDriver & MMDRV_MAPPER)) *pTotalDevs += pdrv->NumDevs;

    //
    // add to end of the driver list
    //
    mregAddDriver(pdrvZ, pdrv);

    return TRUE;       // return a non-zero value

error_exit:
    if (hDriver && !(wFlags & MMDRVI_REMOVE))
    	DrvClose(hDriver, 0, 0);
    if (fMixerCritSec) DeleteCriticalSection(&pdrv->MixerCritSec);
    WinAssert(pdrv != pdrvZ);
    if (pdrv) HeapFree(hHeap, 0, pdrv);

    return FALSE;

#undef SZ_SIZE
}

/**************************************************************************

wdmDevInterfaceInstall

Notes:
Assumes that the NumDevsCritSec is owned as necessary

**************************************************************************/
HANDLE wdmDevInterfaceInstall
(
    LPCWSTR pszDev,
    LONG    cPnpEvents
)
{
    PWDMDEVICEINTERFACE pwdmDev;
    
    EnterCriticalSection(&NumDevsCritSec);

    //
    //  Look for device interface...
    //
    pwdmDev = wdmDevZ.Next;
    while (pwdmDev)
    {
    	WinAssert(pwdmDev->cUsage);
    	
    	if (!lstrcmpiW(pwdmDev->szDeviceInterface, pszDev))
    	{
    	    pwdmDev->cUsage++;
    	    pwdmDev->cPnpEvents = cPnpEvents;
    	    break;
    	}
    	pwdmDev = pwdmDev->Next;
    }

    if (!pwdmDev)
    {
    	SIZE_T cbszDev;
    	
        //
        //  Device interface not found...
        //
        cbszDev = (lstrlen(pszDev) + 1) * sizeof(pszDev[0]);
        pwdmDev = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(*pwdmDev) + cbszDev);
        if (pwdmDev)
        {
            pwdmDev->cUsage = 1;
            pwdmDev->cPnpEvents = cPnpEvents;
            lstrcpyW(pwdmDev->szDeviceInterface, pszDev);
            
            pwdmDev->Next = wdmDevZ.Next;
            wdmDevZ.Next = pwdmDev;
        }
    }

    LeaveCriticalSection(&NumDevsCritSec);

    return (pwdmDev ? pwdmDev->szDeviceInterface : NULL);
}


/**************************************************************************

wdmDevInterfaceInc

Notes:
Enters/Leaves the NumDevsCritSec

**************************************************************************/
BOOL wdmDevInterfaceInc
(
    PCWSTR dwCookie
)
{
   PWDMDEVICEINTERFACE pwdmDev;
   
    if (NULL == dwCookie)
    {
        return FALSE;
    }

    EnterCriticalSection(&NumDevsCritSec);

    //
    //  Look for device interface...
    //
    pwdmDev = wdmDevZ.Next;
    while (pwdmDev)
    {
    	WinAssert(pwdmDev->cUsage);
    	if (dwCookie == pwdmDev->szDeviceInterface)
    	{
    	    pwdmDev->cUsage++;
            LeaveCriticalSection(&NumDevsCritSec);
            return TRUE;
    	}
    	pwdmDev = pwdmDev->Next;
    }

    //
    //  If we get down here, it means that we're trying to increment the
    //  reference to a interface that doesn't exist anymore
    //
    WinAssert(FALSE);
    LeaveCriticalSection(&NumDevsCritSec);

    return FALSE;
}

/**************************************************************************

wdmDevInterfaceDec

Notes:
Enters/Leaves the NumDevsCritSec

**************************************************************************/
BOOL wdmDevInterfaceDec
(
    PCWSTR  dwCookie
)
{
    PWDMDEVICEINTERFACE pwdmDevPrev;
    
    if (NULL == dwCookie)
    {
        return FALSE;
    }

    EnterCriticalSection(&NumDevsCritSec);

    //
    //  Look for device interface...
    //
    pwdmDevPrev = &wdmDevZ;
    while (pwdmDevPrev->Next)
    {
    	PWDMDEVICEINTERFACE pwdmDev = pwdmDevPrev->Next;

    	WinAssert(pwdmDev->cUsage);
    	
    	if (dwCookie == pwdmDev->szDeviceInterface)
    	{
 	    if (0 == --pwdmDev->cUsage)
	    {
            	pwdmDevPrev->Next = pwdmDev->Next;
            	HeapFree(hHeap, 0, pwdmDev);
	    }
            LeaveCriticalSection(&NumDevsCritSec);
            return TRUE;
    	}
    	pwdmDevPrev = pwdmDev;
    }
	    	
    //
    //  If we get down here it means that we are trying to decrement the
    //  reference to an interface that doesn't exist anymore.
    //

    WinAssert(FALSE);
    LeaveCriticalSection(&NumDevsCritSec);

    return FALSE;
}


//--------------------------------------------------------------------------;
//
//  void CleanUpHandles
//
//  Description:
//      Given a particular subsystem and device interface, cleans up the
//      handles.
//
//  Arguments:
//      UINT uFlags: Has one of MMDRVI_* flags to indictate which class of
//          handle needs to be checked for desertion.
//
//      HANDLE cookie: Device interface
//
//  Return (void):
//
//  History:
//      01/25/99    Fwong       Adding Pnp Support.
//
//--------------------------------------------------------------------------;

void CleanUpHandles
(
    UINT    wFlags,
    PCWSTR  cookie
)
{
    HANDLE  hMM;
    UINT    uType;
    PHNDL   pSearch;
    BOOL    fFound;

    // Convert MMDRVI_* type flags to TYPE_*
    switch(wFlags & MMDRVI_TYPE)
    {
    	case MMDRVI_WAVEOUT:
    	    uType = TYPE_WAVEOUT;
    	    break;
        case MMDRVI_WAVEIN:
            uType = TYPE_WAVEIN;
            break;
    	case MMDRVI_MIDIOUT:
    	    uType = TYPE_MIDIOUT;
    	    break;
    	case MMDRVI_MIDIIN:
    	    uType = TYPE_MIDIIN;
    	    break;
        case MMDRVI_MIXER:
    	    uType = TYPE_MIXER;
    	    break;
    	case MMDRVI_AUX:
    	    uType = TYPE_AUX;
    	    break;
        default:
            uType = TYPE_UNKNOWN;
            WinAssert(TYPE_UNKNOWN != uType);
    }

    //  Note:  Since we are not freeing any handles (just marking them
    //  deserted), we don't have to mess with the HandleListCritSec

    for (pSearch = pHandleList; NULL != pSearch; pSearch = pSearch->pNext)
    {
        if ((cookie != pSearch->cookie) || (uType != pSearch->uType))
        {
            continue;
        }

        //  Both the cookie and type match...

        hMM = PHtoH(pSearch);

        switch (uType)
        {
            case TYPE_WAVEOUT:
                waveOutDesertHandle((HWAVEOUT)hMM);
                break;

            case TYPE_WAVEIN:
                waveInDesertHandle((HWAVEIN)hMM);
                break;

            case TYPE_MIDIOUT:
                midiOutDesertHandle((HMIDIOUT)hMM);
                break;

            case TYPE_MIDIIN:
                midiInDesertHandle((HMIDIIN)hMM);
                break;

            case TYPE_MIXER:
                mixerDesertHandle((HMIXER)hMM);
                break;
                
            case TYPE_AUX:
                //  We don't expect open handles of this type
                WinAssert(TYPE_AUX != uType);
                break;
        }
    }
} // CleanUpHandles()


UINT APIENTRY wdmDrvInstall
(
    HANDLE      hDriver,
    LPTSTR      pszDriverFile,
    HANDLE      cookie,
    UINT        wFlags
)
{
    int             i;
    DWORD           dw;
    PMMDRV          pdrvZ;
    PMMDRV          pdrv;
    SIZE_T          cbdrv;
    HANDLE          hModule;
    UINT            msg_init;
    UINT            msg_num_devs;
    UINT            *pTotalDevs;
    CHAR            *szMessage;
    DRIVERMSGPROC   pfnDrvMessage;
    WCHAR           sz[MAX_PATH];
    BOOL            fMixerCritSec;

//    Squirt("Entering wdmDrvInstall");

    fMixerCritSec = FALSE;

    pdrv = NULL;
    pfnDrvMessage = NULL;

    if (hDriver && (wFlags & MMDRVI_HDRV))
    {
        hModule = DrvGetModuleHandle(hDriver);
    }
    else
    {
        hModule = hDriver;
        hDriver = NULL;
    }

    switch (wFlags & MMDRVI_TYPE)
    {
        case MMDRVI_WAVEOUT:
            pdrvZ        = &waveoutdrvZ;
            cbdrv        = sizeof(WAVEDRV);
            msg_init     = WODM_INIT;
            msg_num_devs = WODM_GETNUMDEVS;
            pTotalDevs   = &wTotalWaveOutDevs;
            szMessage    = szWodMessage;
            break;

        case MMDRVI_WAVEIN:
            pdrvZ        = &waveindrvZ;
            cbdrv        = sizeof(WAVEDRV);
            msg_init     = WIDM_INIT;
            msg_num_devs = WIDM_GETNUMDEVS;
            pTotalDevs   = &wTotalWaveInDevs;
            szMessage    = szWidMessage;
            break;

        case MMDRVI_MIDIOUT:
            pdrvZ        = &midioutdrvZ;
            cbdrv        = sizeof(MIDIDRV);
            msg_init     = MODM_INIT;
            msg_num_devs = MODM_GETNUMDEVS;
            pTotalDevs   = &wTotalMidiOutDevs;
            szMessage    = szModMessage;
            break;

        case MMDRVI_MIDIIN:
            pdrvZ        = &midiindrvZ;
            cbdrv        = sizeof(MIDIDRV);
            msg_init     = MIDM_INIT;
            msg_num_devs = MIDM_GETNUMDEVS;
            pTotalDevs   = &wTotalMidiInDevs;
            szMessage    = szMidMessage;
            break;

       case MMDRVI_AUX:
       	    pdrvZ        = &auxdrvZ;
       	    cbdrv        = sizeof(AUXDRV);
       	    msg_init     = AUXM_INIT;
            msg_num_devs = AUXDM_GETNUMDEVS;
            pTotalDevs   = &wTotalAuxDevs;
            szMessage    = szAuxMessage;
            break;

       case MMDRVI_MIXER:
            pdrvZ        = &mixerdrvZ;
            cbdrv        = sizeof(MIXERDRV);
            msg_init     = MXDM_INIT;
            msg_num_devs = MXDM_GETNUMDEVS;
            pTotalDevs   = &guTotalMixerDevs;
            szMessage    = szMxdMessage;
            break;

        default:
            goto error_exit;
    }

    pfnDrvMessage = (DRIVERMSGPROC)GetProcAddress(hModule, szMessage);

    if (NULL == pfnDrvMessage) goto error_exit;

    //
    // either install or remove the specified driver
    //
    if (wFlags & MMDRVI_REMOVE)
    {
        //
        // try to find the driver already installed
        //
        for (pdrv = pdrvZ->Next; pdrv != pdrvZ; pdrv = pdrv->Next)
        {
       	    if (pdrv->fdwDriver & MMDRV_DESERTED) continue;
            if (cookie) {
                //  This is a wdm driver so we're matching up with cookie.
            	if (pdrv->cookie == cookie) break;
            } else {
                // ISSUE-2001/01/14-FrankYe Will this ever be called
                //    on non WDM driver???
                //  Not WDM driver, so matching up with pfnDrvMessage.
            	if (pdrv->drvMessage == pfnDrvMessage) break;
            }
        }
        
        //
        //  Driver not found.
        //
        if (pdrv == pdrvZ) pdrv = NULL;
        if (NULL == pdrv) goto error_exit;

        //
        // don't decrement number of dev's for the mapper
        //
        // Note: Moved this to before the usage check...
        //
        if (!(pdrv->fdwDriver & MMDRV_MAPPER)) *pTotalDevs -= pdrv->NumDevs;

	//
        //  Mark no devs otherwise the device mapping will be skewed.
        //
        pdrv->NumDevs  = 0;

	//
	//  Mark this driver as removed
	//
	pdrv->fdwDriver |= MMDRV_DESERTED;

	CleanUpHandles(wFlags & MMDRVI_TYPE, pdrv->cookie);

	mregDecUsagePtr(pdrv);

        return TRUE;
    }
    else
    {
        //
        // try to find the driver already installed
        //
        for (pdrv = pdrvZ->Next; pdrv != pdrvZ; pdrv = pdrv->Next)
        {
       	    if (pdrv->fdwDriver & MMDRV_DESERTED) continue;
            if (cookie) {
                //  This is a wdm driver so we're matching up with cookie.
            	if (pdrv->cookie == cookie) break;
            } else {
                // ISSUE-2001/01/14-FrankYe Will this ever be called
                //    on non WDM driver???
                //  Not WDM driver, so matching up with pfnDrvMessage.
            	if (pdrv->drvMessage == pfnDrvMessage) break;
            }
        }

	//
        //  If driver found, don't re-install.
        //
	if (pdrv != pdrvZ)
        {
            pdrv = NULL;
	    goto error_exit;
        }

        //
        // Create a MMDRV for the device
        //
        pdrv = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, cbdrv);
        if (!pdrv) goto error_exit;

	//
	//  Initialize MMDRV structure
	//
        pdrv->hDriver     = hDriver;
        pdrv->NumDevs     = 0;
        pdrv->Usage       = 1;
        pdrv->cookie      = cookie;
        pdrv->fdwDriver   = (wFlags & MMDRVI_MAPPER) ? MMDRV_MAPPER : 0;
        pdrv->fdwDriver  |= DrvIsPreXp(hDriver) ? MMDRV_PREXP : 0;
        pdrv->drvMessage  = pfnDrvMessage;
        WinAssert(lstrlenA(szMessage) < sizeof(pdrv->wszMessage)/sizeof(WCHAR));
        mbstowcs(pdrv->wszMessage, szMessage, sizeof(pdrv->wszMessage)/sizeof(WCHAR));
        lstrcpyW(pdrv->wszDrvEntry, pszDriverFile);
        
        if (!mmInitializeCriticalSection(&pdrv->MixerCritSec)) goto error_exit;
        fMixerCritSec = TRUE;

        //
        //  Sending init message
        //
        dw = pfnDrvMessage(0,msg_init,0L,0L,(DWORD_PTR)cookie);

        //
        // call driver to get num-devices it supports
        //
        dw = pfnDrvMessage(0,msg_num_devs,0L,(DWORD_PTR)cookie,0L);

        //
        //  the device returned a error, or has no devices
        //
        if (0 != HIWORD(dw) || 0 == LOWORD(dw)) goto error_exit;

        pdrv->NumDevs = LOWORD(dw);
        
        wdmDevInterfaceInc(cookie);

        // Squirt("Driver [%ls:0x%04x] supports %d devices", pszDriverFile, wFlags & MMDRVI_TYPE, dw);

        //
        // dont increment number of dev's for the mapper
        //
        if (!(pdrv->fdwDriver & MMDRV_MAPPER)) *pTotalDevs += pdrv->NumDevs;

        //
        // add to end of the driver list
        //
        mregAddDriver(pdrvZ, pdrv);

        // Squirt("Installed driver");

        return TRUE;
    }

error_exit:
    // ISSUE-2001/01/05-FrankYe On add, if msg_init was sent it might be good
    //    to also send DRVM_EXIT before closing the driver.
    if (fMixerCritSec) DeleteCriticalSection(&pdrv->MixerCritSec);
    if (pdrv) HeapFree(hHeap, 0, pdrv);
    
    return FALSE;
}

void KickMapper
(
    UINT    uFlags
)
{
    PMMDRV        pmd;
    DWORD         dw;
    DRIVERMSGPROC pfnDrvMessage = NULL;
    MMRESULT      mmr;

    switch (uFlags & MMDRVI_TYPE)
    {
        case MMDRVI_WAVEOUT:
        {
            mmr = waveReferenceDriverById(&waveoutdrvZ, WAVE_MAPPER, &pmd, NULL);
            break;
        }
        
        case MMDRVI_WAVEIN:
        {
            mmr = waveReferenceDriverById(&waveindrvZ, WAVE_MAPPER, &pmd, NULL);
            break;
        }

        case MMDRVI_MIDIOUT:
        {
            mmr = midiReferenceDriverById(&midioutdrvZ, MIDI_MAPPER, &pmd, NULL);
            break;
        }

        case MMDRVI_MIDIIN:
        {
            mmr = midiReferenceDriverById(&midiindrvZ, MIDI_MAPPER, &pmd, NULL);
            break;
        }

        case MMDRVI_AUX:
        {
            mmr = auxReferenceDriverById(AUX_MAPPER, &pmd, NULL);
            break;
        }

        case MMDRVI_MIXER:
        {
            #ifdef MIXER_MAPPER
            mmr = mixerReferenceDriverById(MIXER_MAPPER, &pmd, NULL);
            #else
            mmr = MMSYSERR_NODRIVER;
            #endif
            break;
        }

        default:
            WinAssert(FALSE);
            mmr = MMSYSERR_NODRIVER;
            return;
    }

    if (!mmr)
    {
    	if (pmd->drvMessage)
        {
            pmd->drvMessage(0, DRVM_MAPPER_RECONFIGURE, 0L, 0L, 0L);
        }
    	mregDecUsagePtr(pmd);
    }
}


void wdmDriverLoadClass(
    IN HKEY hkey,
    IN PCTSTR DeviceInterface,
    IN UINT uFlags,
    IN OUT PTSTR *ppstrLeftOverDriver,
    IN OUT HDRVR *phLeftOverDriver)
{
    PTSTR pstrClass;
    HKEY hkeyClass;

    WinAssert((NULL == *ppstrLeftOverDriver) == (NULL == *phLeftOverDriver));

    switch (uFlags & MMDRVI_TYPE) {
    case MMDRVI_WAVEOUT:
    case MMDRVI_WAVEIN:
        pstrClass = TEXT("Drivers\\wave");
        break;
    case MMDRVI_MIDIOUT:
    case MMDRVI_MIDIIN:
        pstrClass = TEXT("Drivers\\midi");
        break;
    case MMDRVI_MIXER:
        pstrClass = TEXT("Drivers\\mixer");
        break;
    case MMDRVI_AUX:
        pstrClass = TEXT("Drivers\\aux");
        break;
    default:
        pstrClass = NULL;
    }

    if (pstrClass && !RegOpenKeyEx(hkey, pstrClass, 0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hkeyClass)) {
        DWORD cSubkeys;
        PTSTR pstrSubkeyNameBuffer;
        DWORD cchSubkeyNameBuffer;

        if (!RegPrepareEnum(hkeyClass, &cSubkeys, &pstrSubkeyNameBuffer, &cchSubkeyNameBuffer))
        {
            DWORD dwIndex;

            for (dwIndex = 0; dwIndex < cSubkeys; dwIndex++) {
                HKEY hkeyClassDriver;
                if (!RegEnumOpenKey(hkeyClass, dwIndex, pstrSubkeyNameBuffer, cchSubkeyNameBuffer, KEY_QUERY_VALUE, &hkeyClassDriver))
                {
                    PTSTR pstrDriver;
                    if (!RegQuerySzValue(hkeyClassDriver, TEXT("Driver"), &pstrDriver)) {
                        HDRVR h;
                        BOOL fLoaded = FALSE;

                        // dprintf(("wdmDriverLoadClass  %s %ls on %ls", (uFlags & MMDRVI_REMOVE) ? "removing" : "installing", pstrClass, DeviceInterface));

                        EnterCriticalSection(&NumDevsCritSec);
                        
                        if (!*phLeftOverDriver || lstrcmpi(pstrDriver, *ppstrLeftOverDriver))
                        {
                            if (*phLeftOverDriver)
                            {
                                DrvClose(*phLeftOverDriver, 0, 0);
                                HeapFree(hHeap, 0, *ppstrLeftOverDriver);
                            }
                            // dprintf(("wdmDriverLoadClass, opening driver %ls", pstrDriver));
                            h = mmDrvOpen(pstrDriver);
                        } else {
                            HeapFree(hHeap, 0, pstrDriver);
                            h = *phLeftOverDriver;
                            pstrDriver = *ppstrLeftOverDriver;
                        }
                        *phLeftOverDriver = NULL;
                        *ppstrLeftOverDriver = NULL;

                        if (h) {
                            fLoaded = wdmDrvInstall(h, pstrDriver, (HANDLE)DeviceInterface, uFlags | MMDRVI_HDRV);
                        } else {
                            HeapFree(hHeap, 0, pstrDriver);
                            pstrDriver = NULL;
                        }

                        // dprintf(("wdmDriverLoadClass, fLoaded = %s", fLoaded ? "TRUE" : "FALSE"));
                        
                        if (!fLoaded) 
                        {
                            *phLeftOverDriver = h;
                            *ppstrLeftOverDriver = pstrDriver;
                        }
                        
                        LeaveCriticalSection(&NumDevsCritSec);
                    }

                    RegCloseKey(hkeyClassDriver);
                    
                }
            }
            HeapFree(hHeap, 0, pstrSubkeyNameBuffer);
        }
        RegCloseKey(hkeyClass);
    }
}

void wdmDriverLoadAllClasses(IN PCTSTR DeviceInterface, UINT uFlags)
{
    HKEY hkey = NULL;
    LONG result;
    
    // dprintf(("wdmDriverLoadAllClasses on %ls", DeviceInterface));
    result = wdmDriverOpenDrvRegKey(DeviceInterface, KEY_ENUMERATE_SUB_KEYS, &hkey);
    
    if (!result) {
    	HDRVR hUnusedDriver = NULL;
    	PTSTR pstrUnusedDriver = NULL;
    	
        WinAssert(hkey);
        
        wdmDriverLoadClass(hkey, DeviceInterface, uFlags | MMDRVI_WAVEOUT, &pstrUnusedDriver, &hUnusedDriver);
        wdmDriverLoadClass(hkey, DeviceInterface, uFlags | MMDRVI_WAVEIN, &pstrUnusedDriver, &hUnusedDriver);
        wdmDriverLoadClass(hkey, DeviceInterface, uFlags | MMDRVI_MIDIOUT, &pstrUnusedDriver, &hUnusedDriver);
        wdmDriverLoadClass(hkey, DeviceInterface, uFlags | MMDRVI_MIDIIN, &pstrUnusedDriver, &hUnusedDriver);
        wdmDriverLoadClass(hkey, DeviceInterface, uFlags | MMDRVI_AUX, &pstrUnusedDriver, &hUnusedDriver);
        // wdmDriverLoadClass(hkey, DeviceInterface, uFlags | MMDRVI_JOY);
        wdmDriverLoadClass(hkey, DeviceInterface, uFlags | MMDRVI_MIXER, &pstrUnusedDriver, &hUnusedDriver);

        if (hUnusedDriver) {
           WinAssert(pstrUnusedDriver);
           DrvClose(hUnusedDriver, 0, 0);
           HeapFree(hHeap, 0, pstrUnusedDriver);
        }
        
        RegCloseKey(hkey);
    } else {
        dprintf(("wdmDriverLoadAllClasses: wdmDriverOpenDrvRegKey returned error %d", result));
    }
    return;
}

void wdmPnpUpdateDriver
(
    DWORD   dwType,
    LPCWSTR pszID,
    LONG    cPnpEvents
)
{
    HANDLE  cookie;

    cookie = wdmDevInterfaceInstall(pszID, cPnpEvents);

    if(0 == cookie)
    {
        return;
    }

    if(WinmmRunningInServer)
    {
        Squirt("Running in CSRSS?!?!");
        WinAssert(FALSE);
        return;
    }

    // ISSUE-2001/01/16-FrankYe This violates the order in which locks should
    //   be acquired.  The HandleListCritSec should be the last lock taken,
    //   but here it is held while calling other functions that will acquire
    //   NumDevsCritSec.  I'm not sure why we need to acquire
    //   HandleListCritSec here.

    EnterCriticalSection(&HandleListCritSec);

    switch (dwType)
    {
        case DBT_DEVICEARRIVAL:
            // Squirt("wdmPnpUpdateDriver:DBT_DEVICEARRIVAL [%ls]", pszID);
            wdmDriverLoadAllClasses(cookie, 0);
            break;

        case DBT_DEVICEREMOVECOMPLETE:
            // Squirt("wdmPnpUpdateDriver:DBT_DEVICEREMOVECOMPLETE [%ls]", pszID);
            // ISSUE-2001/02/08-FrankYe I think we never DrvClose drivers anymore!
            wdmDriverLoadAllClasses(cookie, MMDRVI_REMOVE);
            break;

        default:
            break;
    }

    LeaveCriticalSection(&HandleListCritSec);

    wdmDevInterfaceDec(cookie);
} // wdmPnpUpdateDriver()


void KickMappers
(
    void
)
{
    KickMapper(MMDRVI_WAVEOUT);
    KickMapper(MMDRVI_WAVEIN);
    KickMapper(MMDRVI_MIDIOUT);
    KickMapper(MMDRVI_MIDIIN);
    KickMapper(MMDRVI_AUX);
    KickMapper(MMDRVI_MIXER);
}

BOOL ClientPnpChange(void)
{
    BOOL                    fDeviceChange;
    PMMPNPINFO              pPnpInfo;
    LONG                    cbPnpInfo;
    PMMDEVICEINTERFACEINFO  pdii;
    UINT                    ii;

    fDeviceChange = FALSE;

    if (ERROR_SUCCESS != winmmGetPnpInfo(&cbPnpInfo, &pPnpInfo)) return fDeviceChange;
    

    //  Always grab NumDevsCriticalSection before DriverLoadFree CS
    EnterCriticalSection(&NumDevsCritSec);
    EnterCriticalSection(&DriverLoadFreeCritSec);

    cPnpEvents = pPnpInfo->cPnpEvents;
        
    //  Adding new instances...

    pdii = (PMMDEVICEINTERFACEINFO)&(pPnpInfo[1]);
    pdii = PAD_POINTER(pdii);

    for (ii = pPnpInfo->cDevInterfaces; ii; ii--)
    {
        PWDMDEVICEINTERFACE pwdmDev;
        PWSTR pstr;
        UINT  jj;

        pstr = &(pdii->szName[0]);

	pwdmDev = wdmDevZ.Next;
	while (pwdmDev)
	{
	    WinAssert(pwdmDev->cUsage);
            {
                if (0 == lstrcmpi(pwdmDev->szDeviceInterface, pstr))
                {
                    if (pdii->cPnpEvents > pwdmDev->cPnpEvents)
                    {
                        //  if it has to be updated it must be removed first...
                        wdmPnpUpdateDriver(DBT_DEVICEREMOVECOMPLETE, pstr, 0);
                        if (0 == (pdii->fdwInfo & MMDEVICEINFO_REMOVED))
                        {
                            wdmPnpUpdateDriver(DBT_DEVICEARRIVAL, pstr, pdii->cPnpEvents);
                        }

                        fDeviceChange = TRUE;
                    }

                    break;
                }
                pwdmDev = pwdmDev->Next;
            }
        }

        if (!pwdmDev)
        {
            //  Device interface should be installed.

            if (0 == (pdii->fdwInfo & MMDEVICEINFO_REMOVED))
            {
                wdmPnpUpdateDriver(DBT_DEVICEARRIVAL, pstr, pdii->cPnpEvents);
            }

            fDeviceChange = TRUE;
        }

        pdii = (PMMDEVICEINTERFACEINFO)(pstr + lstrlenW(pstr) + 1);
        pdii = PAD_POINTER(pdii);
        pstr = (PWSTR)(&pdii[1]);
    }

    LeaveCriticalSection(&DriverLoadFreeCritSec);
    LeaveCriticalSection(&NumDevsCritSec);

    HeapFree(hHeap, 0, pPnpInfo);

    return fDeviceChange;
        
}

void ClientUpdatePnpInfo(void)
{
    static BOOL fFirstCall = TRUE;
    static BOOL InThisFunction = FALSE;
    BOOL fWasFirstCall;

    if (IsWinlogon() && !gfLogon)
    {
    	dprintf(("ClientUpdatePnpInfo: warning: called in winlogon before logged on"));
    	return;
    }

    fWasFirstCall = InterlockedExchange(&fFirstCall, FALSE);
    if (fWasFirstCall)
    {
    	// Note AudioSrvBinding happens in WinmmLogon for winlogon
    	winmmWaitForService();
        if (!IsWinlogon()) AudioSrvBinding();

        if (NULL == pClientPnpInfo) {
            hClientPnpInfo = OpenFileMapping(FILE_MAP_READ, FALSE, MMGLOBALPNPINFONAME);
            if (hClientPnpInfo) {
                pClientPnpInfo = MapViewOfFile(hClientPnpInfo, FILE_MAP_READ, 0, 0, 0);
                if (!pClientPnpInfo) {
                    CloseHandle(hClientPnpInfo);
                    hClientPnpInfo = NULL;
                }
            }
            if (!hClientPnpInfo) dprintf(("ClientUpdatePnpInfo: WARNING: Could not OpenFileMapping"));
        }

        SetEvent(hEventApiInit);

    } else {
        WaitForSingleObjectEx(hEventApiInit, INFINITE, FALSE);
    }


    EnterCriticalSection(&PnpCritSec);
    if (!InterlockedExchange(&InThisFunction, TRUE))
    {
        BOOL fDeviceChange;
        BOOL fPreferredDeviceChange;
        
        fPreferredDeviceChange = CheckSessionChanged();

        fDeviceChange = FALSE;

        if (pClientPnpInfo && (cPnpEvents != pClientPnpInfo->cPnpEvents)) fDeviceChange = ClientPnpChange();

        if (fDeviceChange) InvalidatePreferredDevices();

        fPreferredDeviceChange |= (pClientPnpInfo && (cPreferredDeviceChanges != pClientPnpInfo->cPreferredDeviceChanges));
        if (fPreferredDeviceChange && pClientPnpInfo) cPreferredDeviceChanges = pClientPnpInfo->cPreferredDeviceChanges;

        if (fWasFirstCall || fDeviceChange || fPreferredDeviceChange) RefreshPreferredDevices();

        if (fDeviceChange) KickMappers();

        InterlockedExchange(&InThisFunction, FALSE);
    }
    LeaveCriticalSection(&PnpCritSec);
    
}

void WinmmLogon(BOOL fConsole)
{
 // dprintf(("WinmmLogon (%s session)", fConsole ? "console" : "remote"));

    WinAssert(IsWinlogon());
    WinAssert(!gfLogon);
 // WinAssert(fConsole ? !WinmmRunningInSession : WinmmRunningInSession);
    if (!IsWinlogon()) return;
    AudioSrvBinding();
    gfLogon = TRUE;
    // ISSUE-2001/05/04-FrankYe This is a NOP now, should remove this and 
    //   implementation in audiosrv.
    gfxLogon(GetCurrentProcessId());
    return;
}

void WinmmLogoff(void)
{
    HANDLE handle;
 // dprintf(("WinmmLogoff"));
    WinAssert(IsWinlogon());
    WinAssert(gfLogon);
    if (!IsWinlogon()) return;
    gfxLogoff();
    
    // It is very important to close this context handle now because it is associated
    // with the logged on user.  Otherwise the handle remains open, associated with the
    // logged on user, even after he logs off.
    if (ghSessionNotification)
    {
        WinAssert(ghSessionNotificationEvent);
        winmmUnregisterSessionNotification(ghSessionNotification);
        CloseHandle(ghSessionNotificationEvent);
        ghSessionNotification = NULL;
        ghSessionNotificationEvent = NULL;
    }
    else
    {
        WinAssert(!ghSessionNotificationEvent);
    }
    
    AudioSrvBindingFree();
    gfLogon = FALSE;
    return;
}

/*
 *************************************************************************
 *   MigrateSoundEvents
 *
 *      Description:
 *              Looks at the sounds section in win.ini for sound entries.
 *              Gets a current scheme name from the current section in control.ini
 *              Failing that it tries to find the current scheme in the registry
 *              Failing that it uses .default as the current scheme.
 *              Copies each of the entries in the win.ini sound section into the
 *              registry under the scheme name obtained
 *              If the scheme name came from control.ini, it creates a key from the
 *              scheme name. This key is created by removing all the existing spaces
 *              in the scheme name. This key and scheme name is added to the registry
 *
 *************************************************************************
 */
// ISSUE-2000/10/30-FrankYe Delete Winlogon's call to this function, then
//    delete this function
void MigrateAllDrivers(void)
{
    return;
}

void MigrateSoundEvents (void)
{
    TCHAR   aszEvent[SCH_TYPE_MAX_LENGTH];

    // If a MediaPathUnexpanded key exists (it will be something
    // like "%SystemRoot%\Media"), expand it into a fully-qualified
    // path and write out a matching MediaPath key (which will look
    // like "c:\win\media").  This is done every time we enter the
    // migration path, whether or not there's anything else to do.
    //
    // Setup would like to write the MediaPath key with the
    // "%SystemRoot%" stuff still in it--but while we could touch
    // our apps to understand expansion, any made-for-Win95 apps
    // probably wouldn't think to expand the string, and so wouldn't
    // work properly.  Instead, it writes the MediaPathUnexpanded
    // key, and we make sure that the MediaPath key is kept up-to-date
    // in the event that the Windows drive gets remapped (isn't
    // NT cool that way?).
    //
            
    if (mmRegQueryMachineValue (aszSetup, aszValMediaUnexpanded,
                                cchLENGTH(aszEvent), aszEvent))
    {
        WCHAR szExpanded[MAX_PATH];

        ExpandEnvironmentStrings (aszEvent, szExpanded, cchLENGTH(szExpanded));
        mmRegSetMachineValue (aszSetup, aszValMedia, szExpanded);
    }
}

int lstrncmpi (LPTSTR pszA, LPTSTR pszB, size_t cch)
{
#ifdef UNICODE
   size_t  cchA, cchB;
   TCHAR  *pch;

   for (cchA = 1, pch = pszA; cchA < cch; cchA++, pch++)
      {
      if (*pch == TEXT('\0'))
         break;
      }
   for (cchB = 1, pch = pszB; cchB < cch; cchB++, pch++)
      {
      if (*pch == TEXT('\0'))
         break;
      }

   return (CompareStringW (GetThreadLocale(), NORM_IGNORECASE,
                           pszA, cchA, pszB, cchB)
          )-2;  // CompareStringW returns {1,2,3} instead of {-1,0,1}.
#else
   return strnicmp (pszA, pszB, cch);
#endif
}

#if DBG

void Squirt(LPSTR lpszFormat, ...)
{
    char buf[512];
    UINT n;
    va_list va;

    n = wsprintfA(buf, "WINMM: (pid %x) ", GetCurrentProcessId());

    va_start(va, lpszFormat);
    n += vsprintf(buf+n, lpszFormat, va);
    va_end(va);

    buf[n++] = '\n';
    buf[n] = 0;
    OutputDebugStringA(buf);
    Sleep(0);  // let terminal catch up
}

#else

void Squirt(LPSTR lpszFormat, ...)
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\winmmi.h ===
/***************************************************************************
 *  winmmi.h
 *
 *  Copyright (c) 1990-2001 Microsoft Corporation
 *
 *  private include file
 *
 *  History
 *
 *  15 Jan 92 - Robin Speed (RobinSp) and Steve Davies (SteveDav) -
 *      major NT update
 *  6  Feb 92 - LaurieGr replaced HLOCAL by HANDLE
 *
 ***************************************************************************/

/***************************************************************************


 Useful include files for winmm component


 ***************************************************************************/
#define DEBUG_RETAIL        /* Parameter checking is IN         */
#if DBG
  #ifndef DEBUG
    #define DEBUG
  #endif
#endif

#ifndef WINMMI_H
    #define WINMMI_H        /* Protect against double inclusion */

#ifndef RC_INVOKED

#include <string.h>
#include <stdio.h>

#endif /* RC_INVOKED */

#include <windows.h>
#include "mmsystem.h"       /* Pick up the public header */
#include "mmsysp.h"         /* pick up the internal definitions */
#include "mmcommon.h"       /* pick up the definitions common to the NT project */

#ifndef NODDK
#include "mmddkp.h"
#endif


extern BOOL             WinmmRunningInWOW;   // Are we running in WOW


/*--------------------------------------------------------------------*\
 * Unicode helper macros
\*--------------------------------------------------------------------*/
#define SZCODE  CHAR
#define WSZCODE WCHAR

#define BYTE_GIVEN_CHAR(x)  ( (x) * sizeof( WCHAR ) )
#define CHAR_GIVEN_BYTE(x)  ( (x) / sizeof( WCHAR ) )

int Iwcstombs(LPSTR lpstr, LPCWSTR lpwstr, int len);
int Imbstowcs(LPWSTR lpwstr, LPCSTR lpstr, int len);

/***************************************************************************


 Definitions to help with common windows code


 ***************************************************************************/

#define HPSTR LPSTR

#ifndef RC_INVOKED  /* These are defined to RC */
#define STATICDT
#define STATICFN
#define STATIC

#if DBG
    extern void InitDebugLevel(void);
    void mciCheckLocks(void);

    #undef STATICDT
    #undef STATICFN
    #undef STATIC
    #define STATICDT
    #define STATICFN
    #define STATIC
#else
    #define InitDebugLevel()
#endif  /* DBG */

#endif  /* RC_INVOKED */


/**************************************************************************



 **************************************************************************/

#define APPLICATION_DESKTOP_NAME TEXT("Default")


/**************************************************************************


  Strings related to INI files


 **************************************************************************/

/*
// File and section names for sound aliases
*/

#define SOUND_INI_FILE      L"win.ini"
#define SOUND_SECTION       L"Sounds"
#define SOUND_DEFAULT       L".Default"
#define SOUND_RESOURCE_TYPE_SOUND L"SOUND"     // in .rc file
#define SOUND_RESOURCE_TYPE_WAVE  L"WAVE"      // in .rc file
extern  WSZCODE szSystemDefaultSound[];  // Name of the default sound
extern  WSZCODE szSoundSection[];        // WIN.INI section for sounds
extern  WSZCODE wszSystemIni[];          // defined in Winmm.c
extern  WSZCODE wszDrivers[];            // defined in Winmm.c
extern  WSZCODE wszNull[];               // defined in Winmm.c

//  HACK!!  HACK!!  Should update \nt\private\inc\mmcommon.h

#ifndef MMDRVI_MIXER
#define MMDRVI_MIXER        0x0007
#define MXD_MESSAGE         "mxdMessage";
#endif

#define STR_ALIAS_SYSTEMASTERISK        3000
#define STR_ALIAS_SYSTEMQUESTION        3001
#define STR_ALIAS_SYSTEMHAND            3002
#define STR_ALIAS_SYSTEMEXIT            3003
#define STR_ALIAS_SYSTEMSTART           3004
#define STR_ALIAS_SYSTEMWELCOME         3005
#define STR_ALIAS_SYSTEMEXCLAMATION     3006
#define STR_ALIAS_SYSTEMDEFAULT         3007

#define STR_LABEL_APPGPFAULT            3008
#define STR_LABEL_CLOSE                 3009
#define STR_LABEL_EMPTYRECYCLEBIN       3010
#define STR_LABEL_MAXIMIZE              3011
#define STR_LABEL_MENUCOMMAND           3012
#define STR_LABEL_MENUPOPUP             3013
#define STR_LABEL_MINIMIZE              3014
#define STR_LABEL_OPEN                  3015
#define STR_LABEL_RESTOREDOWN           3016
#define STR_LABEL_RESTOREUP             3017
#define STR_LABEL_RINGIN                3018
#define STR_LABEL_RINGOUT               3019
#define STR_LABEL_SYSTEMASTERISK        3020
#define STR_LABEL_SYSTEMDEFAULT         3021
#define STR_LABEL_SYSTEMEXCLAMATION     3022
#define STR_LABEL_SYSTEMEXIT            3023
#define STR_LABEL_SYSTEMHAND            3024
#define STR_LABEL_SYSTEMQUESTION        3025
#define STR_LABEL_SYSTEMSTART           3026

#define STR_WINDOWS_APP_NAME            3027
#define STR_EXPLORER_APP_NAME           3028
#define STR_JOYSTICKNAME                3029

/*
// File and section names for the mci functions
*/

#define MCIDRIVERS_INI_FILE L"system.ini"
#define MCI_HANDLERS        MCI_SECTION

/***********************************************************************
 *
 *    Wrap InitializeCriticalSection to make it easier to handle error
 *
 ***********************************************************************/
_inline BOOL mmInitializeCriticalSection(OUT LPCRITICAL_SECTION lpCriticalSection)
{
    try {
	InitializeCriticalSection(lpCriticalSection);
	return TRUE;
    } except (EXCEPTION_EXECUTE_HANDLER) {
	return FALSE;
    }
}

/***********************************************************************
 *
 *    Speed up profile stuff by going straight to the registry
 *
 ***********************************************************************/

LONG
RegQuerySzValue(
    HKEY hkey,
    PCTSTR pValueName,
    PTSTR *ppstrValue
);

VOID mmRegFree(VOID);
BOOL
mmRegCreateUserKey (
    LPCWSTR lpszPathName,
    LPCWSTR lpszKeyName
);

BOOL
mmRegQueryUserKey (
    LPCWSTR lpszKeyName
);

BOOL
mmRegDeleteUserKey (
    LPCWSTR lpszKeyName
);

BOOL
mmRegSetUserValue (
    LPCWSTR lpszSectionName,
    LPCWSTR lpszValueName,
    LPCWSTR lpszValue
);

BOOL
mmRegQueryUserValue (
    LPCWSTR lpszSectionName,
    LPCWSTR lpszValueName,
    ULONG   dwLen,
    LPWSTR  lpszValue
);

BOOL
mmRegCreateMachineKey (
    LPCWSTR lpszPath,
    LPCWSTR lpszNewKey
);

BOOL
mmRegSetMachineValue (
    LPCWSTR lpszSectionName,
    LPCWSTR lpszValueName,
    LPCWSTR lpszValue
);

BOOL
mmRegQueryMachineValue (
    LPCWSTR lpszSectionName,
    LPCWSTR lpszValueName,
    ULONG   dwLen,
    LPWSTR  lpszValue
);

DWORD
winmmGetProfileString(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR lpReturnedString,
    DWORD nSize
);

DWORD
winmmGetPrivateProfileString(
    LPCWSTR lpSection,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR  lpReturnedString,
    DWORD   nSize,
    LPCWSTR lpFileName
);

/***********************************************************************
 *
 *    Used by hwndNotify code
 *
 ***********************************************************************/

extern BOOL  sndMessage( LPWSTR lszSoundName, UINT wFlags );
extern BOOL InitAsyncSound(VOID);
extern CRITICAL_SECTION WavHdrCritSec;
extern CRITICAL_SECTION SoundCritSec;
extern CRITICAL_SECTION mciGlobalCritSec;

/***********************************************************************
 *
 *    Critical section for NumDevs/DeviceID's, and other stuff
 *
 ***********************************************************************/

extern CRITICAL_SECTION NumDevsCritSec;
extern HANDLE           hEventApiInit;
extern CRITICAL_SECTION midiStrmHdrCritSec;
extern CRITICAL_SECTION joyCritSec;		//in joy.c, qzheng
extern CRITICAL_SECTION ResolutionCritSec;      //in time.c
extern CRITICAL_SECTION TimerThreadCritSec;	//in time.c

/***********************************************************************
 *
 *    Flag deduced by initialization to special case running in the server
 *
 ***********************************************************************/

extern BOOL    WinmmRunningInServer;  // Are we running in the user/base server?

/***********************************************************************
 *
 *    prototypes from "winmm.c"
 *
 ***********************************************************************/

void WaveMapperInit(void);
void MidiMapperInit(void);
void midiEmulatorInit(void);


/***********************************************************************
 *
 *    prototypes from "mmiomisc.c"
 *
 ***********************************************************************/


PBYTE AsciiStrToUnicodeStr( PBYTE pdst, PBYTE pmax, LPCSTR psrc );
PBYTE UnicodeStrToAsciiStr( PBYTE pdst, PBYTE pmax, LPCWSTR psrc);
LPWSTR     AllocUnicodeStr( LPCSTR lpSourceStr );
BOOL        FreeUnicodeStr( LPWSTR lpStr );
LPSTR        AllocAsciiStr( LPCWSTR lpSourceStr );
BOOL          FreeAsciiStr( LPSTR lpStr );

/***********************************************************************
 *
 *    prototypes from "mmio.c"
 *
 ***********************************************************************/

void mmioCleanupIOProcs(HANDLE hTask);

/***********************************************************************
 *
 *  Timer functions
 *
 ***********************************************************************/

#ifndef MMNOTIMER
 BOOL TimeInit(void);
 void TimeCleanup(DWORD ThreadId);
 UINT timeSetEventInternal(UINT wDelay, UINT wResolution,
     LPTIMECALLBACK lpFunction, DWORD_PTR dwUser, UINT wFlags, BOOL IsWOW);
#endif // !MMNOTIMER


/***********************************************************************
 *
 *  Information structure used to play sounds
 *
 ***********************************************************************/

#define PLAY_NAME_SIZE  256

typedef struct _PLAY_INFO {
    HANDLE hModule;
    HANDLE hRequestingTask; // Handle of thread that requested sound
    DWORD dwFlags;
    WCHAR szName[1];     // the structure will be allocated large enough for the name
} PLAY_INFO, *PPLAY_INFO;


#define WAIT_FOREVER ((DWORD)(-1))

/***************************************************************************

    global data

 ***************************************************************************/

extern HANDLE ghInst;
       HANDLE hHeap;

extern DWORD  gTlsIndex;

extern BOOL   gfDisablePreferredDeviceReordering;

/***************************************************************************
 *
 *  Define the product version to be returned from
 *  mmsystemgetversion and any other messagebox or
 *  API that needs the public product version.
 *
 ***************************************************************************/

#define MMSYSTEM_VERSION 0X030A



typedef UINT    MMMESSAGE;      // Multi media message type (internal)

#ifndef WM_MM_RESERVED_FIRST    // Copy constants from winuserp.h
#define WM_MM_RESERVED_FIRST            0x03A0
#define WM_MM_RESERVED_LAST             0x03DF
#endif
#define MM_POLYMSGBUFRDONE  (WM_MM_RESERVED_FIRST+0x2B)
#define MM_SND_PLAY         (WM_MM_RESERVED_FIRST+0x2C)
#define MM_SND_ABORT        (WM_MM_RESERVED_FIRST+0x2D)
#define MM_SND_SEND         (WM_MM_RESERVED_FIRST+0x2E)
#define MM_SND_WAIT         (WM_MM_RESERVED_FIRST+0x2F)
#define MCIWAITMSG          (MM_SND_WAIT)

#if MM_SND_WAIT > WM_MM_RESERVED_LAST
  #error "MM_SND_WAIT is defined beyond the reserved WM_MM range"
#endif

/***************************************************************************

    DEBUGGING SUPPORT

 ***************************************************************************/


#if DBG

    #ifdef DEBUGLEVELVAR
      // So that other WINMM related modules can use their own debug level
      // variable
      #define winmmDebugLevel DEBUGLEVELVAR
    #endif

    extern int winmmDebugLevel;
    extern void winmmDbgOut(LPSTR lpszFormat, ...);
    extern void dDbgAssert(LPSTR exp, LPSTR file, int line);

    DWORD __dwEval;

    extern void winmmDbgOut(LPSTR lpszFormat, ...);

    #define dprintf( _x_ )                            winmmDbgOut _x_
    #define dprintf1( _x_ ) if (winmmDebugLevel >= 1) winmmDbgOut _x_
    #define dprintf2( _x_ ) if (winmmDebugLevel >= 2) winmmDbgOut _x_
    #define dprintf3( _x_ ) if (winmmDebugLevel >= 3) winmmDbgOut _x_
    #define dprintf4( _x_ ) if (winmmDebugLevel >= 4) winmmDbgOut _x_
    #define dprintf5( _x_ ) if (winmmDebugLevel >= 5) winmmDbgOut _x_
    #define dprintf6( _x_ ) if (winmmDebugLevel >= 6) winmmDbgOut _x_

    #define WinAssert(exp) \
	((exp) ? (void)0 : dDbgAssert(#exp, __FILE__, __LINE__))

    #define WinEval(exp) \
	((__dwEval=(DWORD)(exp)),  \
	  __dwEval ? (void)0 : dDbgAssert(#exp, __FILE__, __LINE__), __dwEval)

    #define DOUT(x) (OutputDebugStringA x, 0)
//  #define DOUTX(x) (OutputDebugStringA x, 0)
//  #define ROUTS(x) (OutputDebugStringA(x), OutputDebugStringA("\r\n"), 0)
    #define ROUTSW(x) (OutputDebugStringW x, OutputDebugStringW(L"\r\n"), 0)
    #define ROUT(x) (OutputDebugStringA x, OutputDebugStringA("\r\n"), 0)
//  #define ROUTX(x) (OutputDebugStringA(x), 0)

#else

    #define dprintf(x)  ((void) 0)
    #define dprintf1(x) ((void) 0)
    #define dprintf2(x) ((void) 0)
    #define dprintf3(x) ((void) 0)
    #define dprintf4(x) ((void) 0)
    #define dprintf5(x) ((void) 0)
    #define dprintf6(x) ((void) 0)

    #define WinAssert(exp) ((void) 0)
    #define WinEval(exp) (exp)

    #define DOUT(x)     ((void) 0)
//  #define DOUTX(x)    ((void) 0)
//  #define ROUTS(x)    ((void) 0)
    #define ROUT(x)     ((void) 0)
//  #define ROUTX(x)    ((void) 0)

#endif



/***************************************************************************

    Resource IDs

***************************************************************************/

#define IDS_TASKSTUB           2000
#define STR_MCIUNKNOWN         2001  /* "Unknown error returned from MCI command" */
// #define STR_WAVEINPUT          2004
// #define STR_WAVEOUTPUT         2005
// #define STR_MIDIINPUT          2006
// #define STR_MIDIOUTPUT         2007
#define STR_MCISSERRTXT        2009
#define STR_MCISCERRTXT        2010
#define STR_MIDIMAPPER         2011
#define STR_DRIVERS            2012
#define STR_SYSTEMINI          2013
#define STR_BOOT               2014

/***************************************************************************

    Memory allocation using our local heap

***************************************************************************/
HANDLE hHeap;
PVOID winmmAlloc(DWORD cb);
PVOID winmmReAlloc(PVOID ptr, DWORD cb);
#define winmmFree(ptr) HeapFree(hHeap, 0, (ptr))
void Squirt(LPSTR lpszFormat, ...);

/***************************************************************************

    LOCKING AND UNLOCKING MEMORY

***************************************************************************/

#if 0
BOOL HugePageLock(LPVOID lpArea, DWORD dwLength);
void HugePageUnlock(LPVOID lpArea, DWORD dwLength);
#else
#define HugePageLock(lpArea, dwLength)      (TRUE)
#define HugePageUnlock(lpArea, dwLength)
#endif

/***************************************************************************

    Pnp Structures and related functions.

***************************************************************************/

void ClientUpdatePnpInfo();

//#ifdef DBG
#if 0
#define EnterNumDevs(a) Squirt("Allocating NumDevs CS [%s]", a); EnterCriticalSection(&NumDevsCritSec)
#define LeaveNumDevs(a) LeaveCriticalSection(&NumDevsCritSec); Squirt("Releasing NumDevs CS [%s]", a)
#else
#define EnterNumDevs(a) EnterCriticalSection(&NumDevsCritSec)
#define LeaveNumDevs(a) LeaveCriticalSection(&NumDevsCritSec)
#endif

BOOL wdmDevInterfaceInc(IN PCWSTR pstrDeviceInterface);
BOOL wdmDevInterfaceDec(IN PCWSTR pstrDeviceInterface);

/****************************************************************************

  API to install/remove/query a MMSYS driver

****************************************************************************/

/* generic prototype for audio device driver entry-point functions
// midMessage(), modMessage(), widMessage(), wodMessage(), auxMessage()
*/
typedef DWORD (APIENTRY *DRIVERMSGPROC)(DWORD, DWORD, DWORD_PTR, DWORD_PTR, DWORD_PTR);

/*
@doc    INTERNAL MMSYSTEM
@type   UINT | HMD |
	This type definition specifies a handle to media resource entry. This
	can be used as a unique identifier when specifying a media resource.
*/

DECLARE_HANDLE(HMD);

typedef struct _MMDRV* PMMDRV;
void mregAddDriver(IN PMMDRV pdrvZ, IN PMMDRV pdrv);
MMRESULT mregCreateStringIdFromDriverPort(IN PMMDRV pdrv, IN UINT port, OUT PWSTR* pStringId, OUT ULONG* pcbStringId);
MMRESULT mregGetIdFromStringId(IN PMMDRV pdrvZ, IN PCWSTR StringId, OUT UINT *puDeviceID);
BOOL FAR PASCAL mregHandleInternalMessages(IN PMMDRV pdrv, DWORD dwType, UINT Port, UINT msg, DWORD_PTR dw1, DWORD_PTR dw2, MMRESULT * pmmr);
DWORD FAR PASCAL mregDriverInformation(UINT uDeviceID, WORD fwClass, UINT uMessage, DWORD dwParam1, DWORD dwParam2);
UINT FAR PASCAL mregIncUsage(HMD hmd);
UINT FAR PASCAL mregIncUsagePtr(IN PMMDRV pmd);
UINT FAR PASCAL mregDecUsage(HMD hmd);
UINT FAR PASCAL mregDecUsagePtr(IN PMMDRV pmd);
MMRESULT FAR PASCAL mregFindDevice(UINT uDeviceID, WORD fwFindDevice, HMD FAR* phmd, UINT FAR* puDevicePort);

/*****************************************************************************

  Driver stuff - This will change when we work out the real
  installable driver story on NT

 ****************************************************************************/
LRESULT DrvClose(HANDLE hDriver, LPARAM lParam1, LPARAM lParam2);
HANDLE  DrvOpen(LPCWSTR szDriverName, LPCWSTR szSectionName, LPARAM lParam2);
LRESULT DrvSendMessage(HANDLE hDriver, UINT message, LPARAM lParam1, LPARAM lParam2);
//HMODULE APIENTRY DrvGetModuleHandle(HDRVR hDriver);
BOOL    DrvIsPreXp(IN HANDLE hDriver);

typedef DWORD (DRVPROC)(HANDLE hDriver, UINT msg, LONG lp1, LONG lp2);
typedef DRVPROC *LPDRVPROC;

//
// Init and Cleanup Joystick service, in joy.c
//

BOOL JoyInit(void);
void JoyCleanup(void);

/*
**  Special function for creating threads inside the server process (we only
**  use this to create the thread for playing sounds)
*/

BOOLEAN CreateServerPlayingThread(PVOID ThreadStartRoutine);

/*
// exclude some stuff if MMDDK.H is not included
*/
#ifdef MMDDKINC   /* use this to test for MMDDK.H */

    #define MMDRV_DESERTED  0x00000001
    #define MMDRV_MAPPER    0x00000002
    #define MMDRV_PREXP     0x00000004

    //
    // base drv instance list node struct
    //
    typedef struct _MMDRV *PMMDRV;
    typedef struct _MMDRV
    {
    PMMDRV              Next;
    PMMDRV              Prev;
    PMMDRV              NextStringIdDictNode;
    PMMDRV              PrevStringIdDictNode;
    HANDLE              hDriver;            /* handle to the module                  */
    WCHAR               wszMessage[20];     /* name of entry point                   */
    DRIVERMSGPROC       drvMessage;         /* pointer to entry point                */
    ULONG               NumDevs;            /* number of devices supported           */
    ULONG               Usage;              /* usage count (number of handle's open) */
    // ISSUE-2001/01/05-FrankYe Rename cookie to DeviceInterface
    PCWSTR              cookie;             /* PnP driver device interface           */
    DWORD               fdwDriver;          /* flags for driver                      */
    CRITICAL_SECTION    MixerCritSec;       /* Serialize use of mixer                */
    WCHAR               wszDrvEntry[64];    /* driver filename                       */
    WCHAR               wszSessProtocol[10];
                                            /* Session protocol name, empty
                                               if console driver               */
    } MMDRV, *PMMDRV;

    #ifndef MMNOMIDI


/****************************************************************************

   Preferred devices

****************************************************************************/
void     waveOutGetCurrentConsoleVoiceComId(PUINT pPrefId, PDWORD pdwFlags);
void     waveOutGetCurrentPreferredId(PUINT pPrefId, PDWORD pdwFlags);
MMRESULT waveOutSetPersistentConsoleVoiceComId(UINT PrefId, DWORD dwFlags);
MMRESULT waveOutSetPersistentPreferredId(UINT PrefId, DWORD dwFlags);

void     waveInGetCurrentConsoleVoiceComId(PUINT pPrefId, PDWORD pdwFlags);
void     waveInGetCurrentPreferredId(PUINT pPrefId, PDWORD pdwFlags);
MMRESULT waveInSetPersistentPreferredId(UINT PrefId, DWORD dwFlags);
MMRESULT waveInSetPersistentConsoleVoiceComId(UINT PrefId, DWORD dwFlags);

void     midiOutGetCurrentPreferredId(PUINT pPrefId, PDWORD dwFlags);
MMRESULT midiOutSetPersistentPreferredId(UINT PrefId, DWORD dwFlags);

void     InvalidatePreferredDevices(void);
void     RefreshPreferredDevices(void);

/****************************************************************************

    Clock routines used by MIDI. These routines provide clocks which run
    at the current tempo or SMPTE rate based on timeGetTime().

****************************************************************************/

    typedef DWORD   MILLISECS;
    typedef long        TICKS;

    #define CLK_CS_PAUSED   0x00000001L
    #define CLK_CS_RUNNING  0x00000002L

    #define CLK_TK_NOW      ((TICKS)-1L)

    //
    // This structure is allocated by the client (probably in a handle structure)
    // in MMSYSTEM's DS and passed as a near pointer.
    //

    typedef struct tag_clock *PCLOCK;

    typedef DWORD (FAR PASCAL *CLK_TIMEBASE)(PCLOCK);
    typedef struct tag_clock
    {
    MILLISECS       msPrev;
    TICKS           tkPrev;
    MILLISECS       msT0;
    DWORD           dwNum;
    DWORD           dwDenom;
    DWORD           dwState;
    CLK_TIMEBASE    fnTimebase;
    }   CLOCK;

    void FAR PASCAL      clockInit(PCLOCK pclock, MILLISECS msPrev, TICKS tkPrev, CLK_TIMEBASE fnTimebase);
    void FAR PASCAL      clockSetRate(PCLOCK pclock, TICKS tkWhen, DWORD dwNum, DWORD dwDenom);
    void FAR PASCAL      clockPause(PCLOCK pclock, TICKS tkWhen);
    void FAR PASCAL      clockRestart(PCLOCK pclock, TICKS tkWhen, MILLISECS msWhen);
    TICKS FAR PASCAL     clockTime(PCLOCK pclock);
    MILLISECS FAR PASCAL clockMsTime(PCLOCK pclock);
    MILLISECS FAR PASCAL clockOffsetTo(PCLOCK pclock, TICKS tkWhen);

/****************************************************************************

    Macros and prototypes shared by the MIDI subsystem.

****************************************************************************/

    // #pragma message() with file/line numbers!
    //
    #define __PRAGMSG(l,x,c) message(__FILE__"("#l") : "c": "x)
    #define _WARN(l,x) __PRAGMSG(l,x, "warning")
    #define WARNMSG(x) _WARN(__LINE__,x)

    #define _FIX(l,x) __PRAGMSG(l,x, "fix")
    #define FIXMSG(x) _FIX(__LINE__,x)

    #define DEFAULT_TEMPO   500000L         // 500,000 uSec/qn == 120 BPM
    #define DEFAULT_TIMEDIV 24              // 24 ticks per quarter note
    #define DEFAULT_CBTIMEOUT   100         // 100 milliseconds

    #define PM_STATE_READY      0           // polymsg ready to play
    #define PM_STATE_BLOCKED    1           // Blocked on outgoing SysEx
    #define PM_STATE_EMPTY          2           // No polymsg queued
    #define PM_STATE_STOPPED    3           // Just opened/reset/stopped
									   // No polymsg sent yet.
    #define PM_STATE_PAUSED     4           // Paused at some position

    #define MIN_PERIOD          1           // millisecs of timer resolution

    //
    // Macros for dealing with time division dword
    //
    #define IS_SMPTE 0x00008000L
    #define METER_NUM(dw) (UINT)((HIWORD(dw)>>8)&0x00FF)
    #define METER_DENOM(dw) (UINT)(HIWORD(dw)&0x00FF)
    #define TICKS_PER_QN(dw) (UINT)((dw)&0x7FFF)
    #define SMPTE_FORMAT(dw) (((int)((dw)&0xFF00))>>8)
    #define TICKS_PER_FRAME(dw) (UINT)((dw)&0x00FF)

    //
    // Constants for 30-Drop format conversion
    //
    #define S30D_FRAMES_PER_10MIN       17982
    #define S30D_FRAMES_PER_MIN         1798

    //
    // SMPTE formats from MIDI file time division
    //
    #define SMPTE_24                    24
    #define SMPTE_25                    25
    #define SMPTE_30DROP                29
    #define SMPTE_30                    30

    //
    // Stuff that's part of MIDI spec
    //
    #define MIDI_NOTEOFF        (BYTE)(0x80)
    #define MIDI_NOTEON         (BYTE)(0x90)
    #define MIDI_CONTROLCHANGE  (BYTE)(0xB0)
    #define MIDI_SYSEX          (BYTE)(0xF0)
    #define MIDI_TIMING_CLK     (BYTE)(0xF8)

    #define MIDI_SUSTAIN        (BYTE)(0x40)    // w/ MIDI_CONTROLCHANGE

    //
    // Indices into dwReserved[] fields of struct
    //
    // 0,1,2 -- MMSYSTEM (core, emulator)
    // 3,4,5 -- MIDI mapper
    // 6,7   -- DDK (3rd party drivers)
    #define MH_REFCNT           0       // MMSYSTEM core (stream header only)
    #define MH_PARENT           0       // MMSYSTEM core (shadow header only)
    #define MH_STREAM           0       // Emulator (long msg header only)
    #define MH_SHADOW           1       // MMSYSTEM core (stream header only)
    #define MH_BUFIDX           1       // Emulator (shadow header only)
    #define MH_STRMPME          2       // Emulator (shadow header, long msg header)

/*****************************************************************************
 *
 * @doc INTERNAL MIDI
 *
 * @types MIDIDRV | This structure contains all of the information about an
 *  open <t HMIDIIN> or <t HMIDIOUT> handle.
 *
 * @field HMD | hmd |
 *  Handle to media device for this driver.
 *
 * @field UINT | uDevice |
 *  Index of this device off of HMD (subunit number relative to this driver).
 *
 * @field DRIVERMSGPROC | drvMessage |
 *  Pointer to the associated driver entry point.
 *
 * @field DWORD | dwDrvUser |
 *  Driver user DWORD; used by driver to differentiate open instance. Set
 *  by driver on OPEN message; passed back to driver on every call.
 *
 * @field PMIDIDRV | pdevNext |
 *  Specifies the next handle in the linked list of open handles.
 *  (Only kept for <t HMIDIOUT> handles.
 *
 * @field UINT | uLockCount |
 *  Semaphore to serialize access to the handle structure between API calls
 *  and interrupt callbacks.
 *
 * @field DWORD | dwTimeDiv |
 *  The time division setting that is active right now during polymsg playback
 *  on this handle. The format is the same as described for
 *  <f midiOutSetTimeDivision>.
 *
 * @field DWORD | dwTempo |
 *  Current tempo for polymsg out in microseconds per quarter note (as in the
 *  Standard MIDI File specification).
 *
 * @field DWORD | dwPolyMsgState |
 *  The current state of polymsg playback for emulation.
 *  @flag PM_STATE_READY | Events may be played and are waiting.
 *  @flag PM_STATE_BLOCKED | Driver is busy sending SysEx; don't play anything
 *   else.
 *  @flag PM_STATE_EMPTY | Not busy but nothing else in the queue to play.
 *  @flag PM_STATE_PAUSED | Device has been paused with <f midiOutPause>.
 *
 * @field DWORD | dwSavedState |
 *  If the device is paused, this field will contain the state to be
 *  restored when restart occurs.
 *
 * @field LPMIDIHDR | lpmhFront |
 *  Front of queue of MIDIHDR's waiting to be played via polymsg in/out. The
 *  header pointed to by this field is the header currently being played/
 *  recorded.
 *
 * @field LPMIDIHDR | lpmhRear |
 *  End of MIDIHDR queue. Buffers are inserted from the app here.
 *
 * @field DWORD | dwCallback |
 *  Address of user callback.
 *
 * @field DWORD | dwFlags |
 *  User-supplied callback flags.
 *
 * @field BOOL | fEmulate |
 *  TRUE if we are emulating polymsg in/out.
 *
 * @field BOOL | fReset |
 *  TRUE if we're in the middle of a MIDM_RESET. Checked to see if we should
 *  give our shadow buffers back to the driver or retain them for cleanup.
 *
 * @field BOOL | fStarted |
 *  TRUE if MIDI input has been started.
 *
 * @field UINT | uCBTimeout |
 *  Time in milliseconds that a buffer can be help in MIDI input w/o being
 *  called back.
 *
 * @field UINT | uCBTimer |
 *  Timer ID of the timer which is being used to determine if a MIDI
 *  input buffer has been queued for too long.
 *
 * @field DWORD | dwInputBuffers |
 *  The maximum number of input buffers that have been prepared on this handle.
 *  Used for calculating shadow buffer pool.
 *
 * @field DWORD | cbInputBuffers |
 *  The maximum size of input buffer which has been prepared on this handle.
 *  Used for calculating shadow buffer pool.
 *
 * @field DWORD | dwShadowBuffers |
 *  The current number of shadow buffers allocated on this handle.
 *
 * @field CLOCK | clock |
 *  Clock maintained by the clock API's for timebase of both output and
 *  input emulation.
 *
 * @field DWORD | tkNextEventDue | Tick time of the next event due
 *  on polymsg emulation.
 *
 * @field TICKS | tkTimeOfLastEvent | Tick time that emulator sent the
 *  last event.
 *
 * @field DWORD | tkPlayed | Total ticks played on stream.
 *
 * @field DWORD | tkTime | Tick position in stream now.
 *
 * @field DWORD | dwTimebase | Flag indicating where timebase is coming
 *  from. May be one of:
 *  @flag MIDI_TBF_INTERNAL | Timebase is <f timeGetTime>
 *  @flag MIDI_TBF_MIDICLK | Timebase is MIDI input clocks.
 *
 * @field BYTE | rbNoteOn[] | Array of note-on counts per-channel per-note.
 *  Only allocated for output handles which are doing COOKED mode emulation.
 *
 *****************************************************************************/

    #define ELESIZE(t,e) (sizeof(((t*)NULL)->e))

    //#define MDV_F_EXPANDSTATUS      0x00000001L
    #define MDV_F_EMULATE           0x00000002L
    #define MDV_F_RESET             0x00000004L
    #define MDV_F_STARTED           0x00000008L
    #define MDV_F_ZOMBIE            0x00000010L
    #define MDV_F_SENDING           0x00000020L
    #define MDV_F_OWNED             0x00000040L
    #define MDV_F_LOCKED            0x00000080L

    #define MEM_MAX_LATENESS        64


    typedef MMDRV MIDIDRV, *PMIDIDRV;

    typedef struct midistrm_tag *PMIDISTRM;
    typedef struct mididev_tag *PMIDIDEV;
    typedef struct midiemu_tag *PMIDIEMU;

    typedef struct mididev_tag {
    PMIDIDRV    mididrv;
    UINT        wDevice;
    DWORD_PTR   dwDrvUser;
    UINT        uDeviceID;
    DWORD       fdwHandle;
    PMIDIDEV    pmThru;            /* pointer to midi thru device           */
    PMIDIEMU    pme;               /* Iff owned by emulator                 */
    } MIDIDEV;
    typedef MIDIDEV *PMIDIDEV;

    extern MIDIDRV midioutdrvZ;                     /* output device driver list */
    extern MIDIDRV midiindrvZ;                      /* input device driver list  */
    extern UINT    wTotalMidiOutDevs;               /* total midi output devices */
    extern UINT    wTotalMidiInDevs;                /* total midi input devices  */

    typedef struct midiemusid_tag {
    DWORD       dwStreamID;
    HMIDI       hMidi;
    } MIDIEMUSID, *PMIDIEMUSID;

    typedef struct midiemu_tag {
    PMIDIEMU                pNext;
    HMIDISTRM               hStream;
    DWORD                   fdwDev;
    LONG                    lLockCount;         // Must be 32-bit aligned
    CRITICAL_SECTION        CritSec;            // Serialize access
    DWORD                   dwSignature;        // Cookie to keep track of validity
    DWORD                   dwTimeDiv;          // Time division in use right now
    DWORD                   dwTempo;            // Current tempo
    DWORD                   dwPolyMsgState;     // Ready or blocked on SysEx
    DWORD                   dwSavedState;       // State saved when paused
    LPMIDIHDR               lpmhFront ;         // Front of PolyMsg queue
    LPMIDIHDR               lpmhRear ;          // Rear of PolyMsg queue
    DWORD_PTR               dwCallback;         // User callback
    DWORD                   dwFlags;            // User callback flags
    DWORD_PTR               dwInstance;
    DWORD                   dwSupport;          // From MODM_GETDEVCAPS
    BYTE                    bRunningStatus;     // Track running status

	//
	// Rewrite midiOutPolyMsg timekeeping - new stuff!!!
	//
    CLOCK       clock;

    TICKS       tkNextEventDue;     // Tick time of next event
    TICKS       tkTimeOfLastEvent;  // Tick time of last received event
    TICKS       tkPlayed;           // Cumulative ticks played so far
    TICKS       tkTime;             // Tick position in stream *NOW*

    LPBYTE      rbNoteOn;           // Count of notes on per channel per note

    UINT        cSentLongMsgs;      // Oustanding long messages

    UINT        chMidi;             // # Stream ID's

    UINT        cPostedBuffers;     // Posted to mmtask for cleanup

    #ifdef DEBUG
    DWORD       cEvents;
    UINT        auLateness[MEM_MAX_LATENESS];
								   // 0..64 milliseconds late
    #endif

    MIDIEMUSID  rIds[];             // HMIDI's indexed by stream ID
    } MIDIEMU;

    #define MSI_F_EMULATOR                      0x00000001L
    #define MSI_F_FIRST                         0x00000002L
    #define MSI_F_OPENED                        0x00000004L
    #define MSI_F_INITIALIZEDCRITICALSECTION	0x00000008L

    #define MSE_SIGNATURE       0x12341234L

    typedef struct midistrmid_tag {
    HMD hmd;
    UINT uDevice;
    DRIVERMSGPROC drvMessage;
    DWORD_PTR dwDrvUser;
    DWORD fdwId;
    CRITICAL_SECTION CritSec;
    } MIDISTRMID, *PMIDISTRMID;

    #define MDS_F_STOPPING      0x00000001L

    typedef struct midistrm_tag {
    DWORD       fdwOpen;
    DWORD       fdwStrm;
    DWORD_PTR   dwCallback;
    DWORD_PTR   dwInstance;
    DWORD       cDrvrs;             // # unique drivers in rgIds[]
    DWORD       cIds;
    MIDISTRMID  rgIds[];
    } MIDISTRM;


/*****************************************************************************
 *
 * @doc INTERNAL MIDI
 *
 * @types MIDIHDREXT |
 *  This structure is allocated by <f midiOutPolyMsg> and is pointed to by the
 *  <t reserved> field of the associated <t MIDIHDR>. It contains information
 *  about what embedded long messages are in the polymsg buffer described
 *  by the MIDIHDR.
 *
 *  The <t MIDIHDREXT> is followed by multiple <t MIDIDHR> structures, also
 *  allocated by <f midiOutPolyMsg>, which describe each of the embedded
 *  long messages which need to be played.
 *
 * @field DWORD | dwTimeDivision |
 *  The time division specified with <f midiOutPolyMsg> to play this buffer
 *  with.
 *
 * @field UINT | nHeaders |
 *  The number of <t MIDIHDR> structures which follow the end of this
 *  <MIDIHDREXT>.
 *
 * @field LPMIDIHDR | lpmidihdr |
 *  Pointer to the next <t MIDIHDR> structure due to be played.
 *
 *
 *****************************************************************************/
    typedef struct midihdrext_tag {
    UINT        nHeaders ;
    LPMIDIHDR   lpmidihdr ;
    } MIDIHDREXT, FAR *LPMIDIHDREXT ;

	extern HANDLE g_hClosepme;

    /*
     * Internal prototypes for MIDI
     */
    extern MMRESULT midiReferenceDriverById(
        IN PMIDIDRV pwavedrvZ,
        IN UINT id,
        OUT PMIDIDRV *ppwavedrv OPTIONAL,
        OUT UINT *pport OPTIONAL
    );

    extern BOOL FAR PASCAL midiLockPageable(void);
    extern void NEAR PASCAL midiUnlockPageable(void);
    extern MMRESULT NEAR PASCAL midiPrepareHeader(LPMIDIHDR lpMidiHdr, UINT wSize);
    extern MMRESULT NEAR PASCAL midiUnprepareHeader(LPMIDIHDR lpMidiHdr, UINT wSize);
    extern STATIC MMRESULT midiMessage(HMIDI hMidi, UINT msg, DWORD_PTR dwP1, DWORD_PTR dwP2);
    extern DWORD FAR PASCAL midiStreamMessage(PMIDISTRMID pmsi, UINT msg, DWORD_PTR dwP1, DWORD_PTR dwP2);
    extern DWORD FAR PASCAL midiStreamBroadcast(PMIDISTRM pms, UINT msg, DWORD_PTR dwP1, DWORD_PTR dwP2);
    extern STATIC MMRESULT midiIDMessage(PMIDIDRV pmididrvZ, UINT wTotalNumDevs, UINT_PTR uDeviceID, UINT wMessage, DWORD_PTR dwParam1, DWORD_PTR dwParam2);
    extern MMRESULT NEAR PASCAL midiGetPosition(PMIDISTRM pms, LPMMTIME pmmt, UINT cbmmt);
    extern MMRESULT NEAR PASCAL midiGetErrorText(MMRESULT wError, LPSTR lpText, UINT wSize);


    extern MMRESULT WINAPI midiOutGetID(HMIDIOUT hMidiOut, UINT FAR* lpuDeviceID);
    extern MMRESULT FAR PASCAL mseOutSend(PMIDIEMU pme, LPMIDIHDR lpMidiHdr, UINT cbMidiHdr);
    extern void FAR PASCAL midiOutSetClockRate(PMIDIEMU pme, TICKS tkWhen);
    extern BOOL NEAR PASCAL midiOutScheduleNextEvent(PMIDIEMU pme);
    #ifdef DEBUG
    extern void NEAR PASCAL midiOutPlayNextPolyEvent(PMIDIEMU pme, DWORD dwStartTime);
    #else
    extern void NEAR PASCAL midiOutPlayNextPolyEvent(PMIDIEMU pme);
    #endif

    extern void NEAR PASCAL midiOutDequeueAndCallback(PMIDIEMU pme);
    extern void FAR PASCAL midiOutNukePMBuffer(PMIDIEMU pme, LPMIDIHDR lpmh);
    extern void CALLBACK midiOutTimerTick(UINT uTimerID, UINT wMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2);
    extern void CALLBACK midiOutCallback(HMIDIOUT hMidiOut, WORD wMsg, DWORD_PTR dwInstance, DWORD_PTR dwParam1, DWORD_PTR dwParam2);
    extern void NEAR PASCAL midiOutAllNotesOff(PMIDIEMU pme);

    extern void CALLBACK midiOutStreamCallback(HMIDISTRM hMidiOut, WORD wMsg, DWORD_PTR dwInstance, DWORD_PTR dwParam1, DWORD_PTR dwParam2);

    extern MMRESULT midiInSetThru (HMIDI hmi, HMIDIOUT hmo, BOOL bAdd);

    // mseXXX - MIDI Stream Emulator
    //
    extern DWORD FAR PASCAL mseMessage(UINT msg, DWORD_PTR dwUser, DWORD_PTR dwParam1, DWORD_PTR dwParam2);


    #endif /* ifndef MMNOMIDI */

    #ifndef MMNOWAVE

    typedef MMDRV WAVEDRV, *PWAVEDRV;

    extern WAVEDRV waveoutdrvZ;                     /* output device driver list */
    extern WAVEDRV waveindrvZ;                      /* input device driver list  */
    extern UINT    wTotalWaveOutDevs;               /* total wave output devices */
    extern UINT    wTotalWaveInDevs;                /* total wave input devices  */

    extern MMRESULT waveReferenceDriverById(
        IN PWAVEDRV pwavedrvZ,
        IN UINT id,
        OUT PWAVEDRV *ppwavedrv OPTIONAL,
        OUT UINT *pport OPTIONAL
    );

    #endif /*ifndef MMNOWAVE */

    #ifndef MMNOMIXER

    typedef MMDRV MIXERDRV, *PMIXERDRV;

    extern MIXERDRV mixerdrvZ;                      /* mixer device driver list */
    extern UINT     guTotalMixerDevs;               /* total mixer devices */

    MMRESULT mixerReferenceDriverById(
        IN UINT id,
        OUT PMIXERDRV *ppdrv OPTIONAL,
        OUT UINT *pport OPTIONAL
    );

    #endif /*ifndef MMNOMIXER */

    #ifndef MMNOAUX

    typedef MMDRV AUXDRV, *PAUXDRV;

    extern AUXDRV auxdrvZ;                         /* auxiliary device driver list   */
    extern UINT   wTotalAuxDevs;                   /* total auxiliary output devices */

    MMRESULT auxReferenceDriverById(
        IN UINT id,
        OUT PAUXDRV *ppauxdrv OPTIONAL,
        OUT UINT *pport OPTIONAL
    );

    #endif /* ifndef MMNOAUX */

    #ifdef DEBUG_RETAIL
    extern BYTE    fIdReverse;
    #endif /* ifdef DEBUG_RETAIL */

#endif //ifdef MMDDKINC

/****************************************************************************

    handle apis's

****************************************************************************/

/*
// all MMSYSTEM handles are tagged with the following structure.
//
// a MMSYSTEM handle is really a fixed local memory object.
//
// the functions NewHandle() and FreeHandle() create and release a MMSYSTEM
// handle.
//
*/
typedef struct tagHNDL {
    struct  tagHNDL *pNext; // link to next handle
    UINT    uType;          // type of handle wave, midi, mmio, ...
    DWORD   fdwHandle;      // Particulars about this handle, Deserted? Busy?
    HANDLE  hThread;        // task that owns it
    UINT    h16;            // Corresponding WOW handle
    PCWSTR  cookie;         // Device interface name for driver handles
    CRITICAL_SECTION CritSec; // Serialize access
} HNDL, *PHNDL;
/*************************************************************************/

#define MMHANDLE_DESERTED   MMDRV_DESERTED
#define MMHANDLE_BUSY       0x00000002

#define HtoPH(h)        ((PHNDL)(h)-1)
#define PHtoH(ph)       ((ph) ? (HANDLE)((PHNDL)(ph)+1) : 0)
#define HtoPT(t,h)      ((t)(h))
#define PTtoH(t,pt)     ((t)(pt))


//
// Handles can be tested for ownership and reserved at the same time
//

#define ENTER_MM_HANDLE(h) (EnterCriticalSection(&HtoPH(h)->CritSec))
#define LEAVE_MM_HANDLE(h) ((void)LeaveCriticalSection(&HtoPH(h)->CritSec))

/*
// all wave and midi handles will be linked into
// a global list, so we can enumerate them latter if needed.
//
// all handle structures start with a HNDL structure, that contain common fields
//
// pHandleList points to the first handle in the list
//
// HandleListCritSec protects the handle list
//
// the NewHandle() and FreeHandle() functions are used to add/remove
// a handle to/from the list
*/

PHNDL pHandleList;
CRITICAL_SECTION HandleListCritSec;

extern HANDLE NewHandle(UINT uType, PCWSTR cookie, UINT size);
extern void   ReleaseHandleListResource();
extern void   AcquireHandleListResourceShared();
extern void   AcquireHandleListResourceExclusive();
extern void   FreeHandle(HANDLE h);
extern void   InvalidateHandle(HANDLE h);

#define GetHandleType(h)        (HtoPH(h)->uType)
#define GetHandleOwner(h)       (HtoPH(h)->hThread)
#define GetHandleFirst()        (PHtoH(pHandleList))
#define GetHandleNext(h)        (PHtoH(HtoPH(h)->pNext))
#define SetHandleOwner(h,hOwn)  (HtoPH(h)->hThread = (hOwn))
#define SetHandleFlag(h,f)      (HtoPH(h)->fdwHandle |= (f))
#define ClearHandleFlag(h,f)    (HtoPH(h)->fdwHandle &= (~(f)))
#define CheckHandleFlag(h,f)    (HtoPH(h)->fdwHandle & (f))
#define IsHandleDeserted(h)     (0 != CheckHandleFlag((h), MMHANDLE_DESERTED))
#define IsHandleBusy(h)         (0 != CheckHandleFlag((h), MMHANDLE_BUSY))

#define GetWOWHandle(h)         (HtoPH(h)->h16)
#define SetWOWHandle(h, myh16)  (HtoPH(h)->h16 = (myh16))

/**************************************************************************

    Test whether the current process is the WOW process.  This
    is not a very nice test to have to make but it's the best we
    can think of until the WOW people come up with a proper call

 **************************************************************************/

#define IS_WOW_PROCESS (NULL != GetModuleHandleW(L"WOW32.DLL"))


/****************************************************************************

    user debug support

****************************************************************************/

#define DebugErr(x,y)
#define DebugErr1(flags, sz, a)

#ifdef DEBUG_RETAIL

#define MM_GET_DEBUG        DRV_USER
#define MM_GET_DEBUGOUT     DRV_USER+1
#define MM_SET_DEBUGOUT     DRV_USER+2
#define MM_GET_MCI_DEBUG    DRV_USER+3
#define MM_SET_MCI_DEBUG    DRV_USER+4
#define MM_GET_MM_DEBUG     DRV_USER+5
#define MM_SET_MM_DEBUG     DRV_USER+6

#define MM_HINFO_NEXT       DRV_USER+10
#define MM_HINFO_TASK       DRV_USER+11
#define MM_HINFO_TYPE       DRV_USER+12
#define MM_HINFO_MCI        DRV_USER+20

#define MM_DRV_RESTART      DRV_USER+30

/*
// these validation routines can be found in DEBUG.C
*/
// The kernel validation is turned OFF because it appeared to test every page
// before use and this took over a minute for soundrec with a 10MB buffer
//
//#define USE_KERNEL_VALIDATION
#ifdef USE_KERNEL_VALIDATION

#define  ValidateReadPointer(p, len)     (!IsBadReadPtr(p, len))
#define  ValidateWritePointer(p, len)    (!IsBadWritePtr(p, len))
#define  ValidateString(lsz, max_len)    (!IsBadStringPtrA(lsz, max_len))
#define  ValidateStringW(lsz, max_len)   (!IsBadStringPtrW(lsz, max_len))

#else

BOOL  ValidateReadPointer(LPVOID p, DWORD len);
BOOL  ValidateWritePointer(LPVOID p, DWORD len);
BOOL  ValidateString(LPCSTR lsz, DWORD max_len);
BOOL  ValidateStringW(LPCWSTR lsz, DWORD max_len);

#endif // USE_KERNEL_VALIDATION

BOOL  ValidateHandle(HANDLE h, UINT uType);
BOOL  ValidateHeader(LPVOID p, UINT uSize, UINT uType);
BOOL  ValidateCallbackType(DWORD_PTR dwCallback, UINT uType);

/********************************************************************
* When time permits we should change to using the Kernel supplied and
* supported validation routines:
*
* BOOL  WINAPI IsBadReadPtr(CONST VOID *lp, UINT ucb );
* BOOL  WINAPI IsBadWritePtr(LPVOID lp, UINT ucb );
* BOOL  WINAPI IsBadHugeReadPtr(CONST VOID *lp, UINT ucb);
* BOOL  WINAPI IsBadHugeWritePtr(LPVOID lp, UINT ucb);
* BOOL  WINAPI IsBadCodePtr(FARPROC lpfn);
* BOOL  WINAPI IsBadStringPtrA(LPCSTR lpsz, UINT ucchMax);
* BOOL  WINAPI IsBadStringPtrW(LPCWSTR lpsz, UINT ucchMax);
*
* These routines can be found in * \nt\private\WINDOWS\BASE\CLIENT\PROCESS.C
*
********************************************************************/

#define V_HANDLE(h, t, r)       { if (!ValidateHandle(h, t)) return (r); }
#define V_HANDLE_ACQ(h, t, r)   { AcquireHandleListResourceShared(); if (!ValidateHandle(h, t)) { ReleaseHandleListResource(); return (r);} }
#define BAD_HANDLE(h, t)            ( !(ValidateHandle((h), (t))) )
#define V_HEADER(p, w, t, r)    { if (!ValidateHeader((p), (w), (t))) return (r); }
#define V_RPOINTER(p, l, r)     { if (!ValidateReadPointer((PVOID)(p), (l))) return (r); }
#define V_RPOINTER0(p, l, r)    { if ((p) && !ValidateReadPointer((PVOID)(p), (l))) return (r); }
#define V_WPOINTER(p, l, r)     { if (!ValidateWritePointer((PVOID)(p), (l))) return (r); }
#define V_WPOINTER0(p, l, r)    { if ((p) && !ValidateWritePointer((PVOID)(p), (l))) return (r); }
#define V_DCALLBACK(d, w, r)    { if ((d) && !ValidateCallbackType((d), (w))) return(r); }
//#define V_DCALLBACK(d, w, r)    0
#define V_TCALLBACK(d, r)       0
#define V_CALLBACK(f, r)        { if (IsBadCodePtr((f))) return (r); }
#define V_CALLBACK0(f, r)       { if ((f) && IsBadCodePtr((f))) return (r); }
#define V_STRING(s, l, r)       { if (!ValidateString(s,l)) return (r); }
#define V_STRING_W(s, l, r)       { if (!ValidateStringW(s,l)) return (r); }
#define V_FLAGS(t, b, f, r)     { if ((t) & ~(b)) { return (r); }}
#define V_DFLAGS(t, b, f, r)    { if ((t) & ~(b)) {/* LogParamError(ERR_BAD_DFLAGS, (FARPROC)(f), (LPVOID)(DWORD)(t));*/ return (r); }}
#define V_MMSYSERR(e, f, t, r)  { /* LogParamError(e, (FARPROC)(f), (LPVOID)(DWORD)(t));*/ return (r); }

#else /*ifdef DEBUG_RETAIL */

#define V_HANDLE(h, t, r)       { if (!(h)) return (r); }
#define V_HANDLE_ACQ(h, t, r)   { AcquireHandleListResourceShared(); if (!ValidateHandle(h, t)) { ReleaseHandleListResource(); return (r);} }
#define BAD_HANDLE(h, t)            ( !(ValidateHandle((h), (t))) )
#define V_HEADER(p, w, t, r)    { if (!(p)) return (r); }
#define V_RPOINTER(p, l, r)     { if (!(p)) return (r); }
#define V_RPOINTER0(p, l, r)    0
#define V_WPOINTER(p, l, r)     { if (!(p)) return (r); }
#define V_WPOINTER0(p, l, r)    0
#define V_DCALLBACK(d, w, r)    { if ((d) && !ValidateCallbackType((d), (w))) return(r); }
//#define V_DCALLBACK(d, w, r)    0
#define V_TCALLBACK(d, r)       0
#define V_CALLBACK(f, r)        { if (IsBadCodePtr((f))) return (r); }
#define V_CALLBACK0(f, r)       { if ((f) && IsBadCodePtr((f))) return (r); }
//#define V_CALLBACK(f, r)        { if (!(f)) return (r); }
#define V_CALLBACK0(f, r)       0
#define V_STRING(s, l, r)       { if (!(s)) return (r); }
#define V_STRING_W(s, l, r)     { if (!(s)) return (r); }
#define V_FLAGS(t, b, f, r)     0
#define V_DFLAGS(t, b, f, r)    { if ((t) & ~(b)) return (r); }
#define V_MMSYSERR(e, f, t, r)  { return (r); }

#endif /* ifdef DEBUG_RETAIL */

 /**************************************************************************
//
//**************************************************************************/
#define TYPE_UNKNOWN            0
#define TYPE_WAVEOUT            1
#define TYPE_WAVEIN             2
#define TYPE_MIDIOUT            3
#define TYPE_MIDIIN             4
#define TYPE_MMIO               5
#define TYPE_MCI                6
#define TYPE_DRVR               7
#define TYPE_MIXER              8
#define TYPE_MIDISTRM           9
#define TYPE_AUX               10



/**************************************************************************/


/****************************************************************************

    RIFF constants used to access wave files

****************************************************************************/

#define FOURCC_FMT  mmioFOURCC('f', 'm', 't', ' ')
#define FOURCC_DATA mmioFOURCC('d', 'a', 't', 'a')
#define FOURCC_WAVE mmioFOURCC('W', 'A', 'V', 'E')


extern HWND hwndNotify;

void FAR PASCAL WaveOutNotify(DWORD wParam, LONG lParam);    // in PLAYWAV.C

/*
// Things not in Win32
*/

#define GetCurrentTask() ((HANDLE)(DWORD_PTR)GetCurrentThreadId())

/*
// other stuff
*/

	 // Maximum length, including the terminating NULL, of an Scheme entry.
	 //
#define SCH_TYPE_MAX_LENGTH 64

	 // Maximum length, including the terminating NULL, of an Event entry.
	 //
#define EVT_TYPE_MAX_LENGTH 32

	 // Maximum length, including the terminating NULL, of an App entry.
	 //
#define APP_TYPE_MAX_LENGTH 64

	 // Sound event names can be a fully qualified filepath with a NULL
	 // terminator.
	 //
#define MAX_SOUND_NAME_CHARS    144

	 //  sound atom names are composed of:
	 //     <1 char id>
	 //     <reg key name>
	 //     <1 char sep>
	 //     <filepath>
	 //
#define MAX_SOUND_ATOM_CHARS    (1 + 40 + 1 + MAX_SOUND_NAME_CHARS)

#if 0
#undef hmemcpy
#define hmemcpy CopyMemory
#endif

//
// for terminal server defination and security
//
extern BOOL   WinmmRunningInSession;
extern WCHAR  SessionProtocolName[];
extern BOOL   gfLogon;

BOOL IsWinlogon(void);
BOOL WTSCurrentSessionIsDisconnected(void);

//  Keep winmm loaded
extern BOOL LoadWINMM();

#endif /* WINMMI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\array.c ===
/******************************Module*Header*******************************\
* Module Name: array.c
*
* OpenGL client side vertex array functions.
*
* Created: 1-30-1996
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "os.h"
#include "glsbcltu.h"
#include "glclt.h"
#include "compsize.h"
#include "glsize.h"
#include "context.h"
#include "global.h"
#include "lcfuncs.h"

void FASTCALL VA_ArrayElementB(__GLcontext *gc, GLint firstVertex, GLint nVertices);
void FASTCALL VA_ArrayElement_V2F_B(__GLcontext *gc, GLint firstVertex, GLint nVertices);
void FASTCALL VA_ArrayElement_V3F_B(__GLcontext *gc, GLint firstVertex, GLint nVertices);
void FASTCALL VA_ArrayElement_C3F_V3F_B(__GLcontext *gc, GLint firstVertex, GLint nVertices);
void FASTCALL VA_ArrayElement_N3F_V3F_B(__GLcontext *gc, GLint firstVertex, GLint nVertices);
void FASTCALL VA_ArrayElement_C3F_N3F_V3F_B(__GLcontext *gc, GLint firstVertex, GLint nVertices);
void FASTCALL VA_ArrayElement_C4F_N3F_V3F_B(__GLcontext *gc, GLint firstVertex, GLint nVertices);
void FASTCALL VA_ArrayElement_T2F_V3F_B(__GLcontext *gc, GLint firstVertex, GLint nVertices);
void FASTCALL VA_ArrayElement_T2F_C3F_V3F_B(__GLcontext *gc, GLint firstVertex, GLint nVertices);
void FASTCALL VA_ArrayElement_T2F_N3F_V3F_B(__GLcontext *gc, GLint firstVertex,  GLint nVertices);
void FASTCALL VA_ArrayElement_T2F_C3F_N3F_V3F_B(__GLcontext *gc, GLint firstVertex, GLint nVertices);
void FASTCALL VA_ArrayElement_T2F_C4F_N3F_V3F_B(__GLcontext *gc, GLint firstVertex, GLint nVertices);

void FASTCALL VA_ArrayElementBI(__GLcontext *gc, GLint nVertices, VAMAP* indices);
void FASTCALL VA_ArrayElement_V2F_BI(__GLcontext *gc, GLint nVertices, VAMAP* indices);
void FASTCALL VA_ArrayElement_V3F_BI(__GLcontext *gc, GLint nVertices, VAMAP* indices);
void FASTCALL VA_ArrayElement_C3F_V3F_BI(__GLcontext *gc, GLint nVertices, VAMAP* indices);
void FASTCALL VA_ArrayElement_N3F_V3F_BI(__GLcontext *gc, GLint nVertices, VAMAP* indices);
void FASTCALL VA_ArrayElement_C3F_N3F_V3F_BI(__GLcontext *gc, GLint nVertices, VAMAP* indices);
void FASTCALL VA_ArrayElement_C4F_N3F_V3F_BI(__GLcontext *gc, GLint nVertices, VAMAP* indices);
void FASTCALL VA_ArrayElement_T2F_V3F_BI(__GLcontext *gc, GLint nVertices, VAMAP* indices);
void FASTCALL VA_ArrayElement_T2F_C3F_V3F_BI(__GLcontext *gc, GLint nVertices, VAMAP* indices);
void FASTCALL VA_ArrayElement_T2F_N3F_V3F_BI(__GLcontext *gc, GLint nVertices, VAMAP* indices);
void FASTCALL VA_ArrayElement_T2F_C3F_N3F_V3F_BI(__GLcontext *gc, GLint nVertices, VAMAP* indices);
void FASTCALL VA_ArrayElement_T2F_C4F_N3F_V3F_BI(__GLcontext *gc, GLint nVertices, VAMAP* indices);

void FASTCALL VA_ArrayElement(__GLcontext *gc, GLint i);
void FASTCALL VA_ArrayElement_V2F(__GLcontext *gc, GLint i);
void FASTCALL VA_ArrayElement_V3F(__GLcontext *gc, GLint i);
void FASTCALL VA_ArrayElement_C3F_V3F(__GLcontext *gc, GLint i);
void FASTCALL VA_ArrayElement_N3F_V3F(__GLcontext *gc, GLint i);
void FASTCALL VA_ArrayElement_C3F_N3F_V3F(__GLcontext *gc, GLint i);
void FASTCALL VA_ArrayElement_C4F_N3F_V3F(__GLcontext *gc, GLint i);
void FASTCALL VA_ArrayElement_T2F_V3F(__GLcontext *gc, GLint i);
void FASTCALL VA_ArrayElement_T2F_C3F_V3F(__GLcontext *gc, GLint i);
void FASTCALL VA_ArrayElement_T2F_N3F_V3F(__GLcontext *gc, GLint i);
void FASTCALL VA_ArrayElement_T2F_C3F_N3F_V3F(__GLcontext *gc, GLint i);
void FASTCALL VA_ArrayElement_T2F_C4F_N3F_V3F(__GLcontext *gc, GLint i);

#define VAMASK_FORMAT_C3F \
  (VAMASK_COLOR_ENABLE_MASK | VAMASK_COLOR_SIZE_3 | VAMASK_COLOR_TYPE_FLOAT)
#define VAMASK_FORMAT_C4F \
  (VAMASK_COLOR_ENABLE_MASK | VAMASK_COLOR_SIZE_4 | VAMASK_COLOR_TYPE_FLOAT)
#define VAMASK_FORMAT_C4UB \
  (VAMASK_COLOR_ENABLE_MASK | VAMASK_COLOR_SIZE_4 | VAMASK_COLOR_TYPE_UBYTE)
#define VAMASK_FORMAT_N3F \
  (VAMASK_NORMAL_ENABLE_MASK | VAMASK_NORMAL_TYPE_FLOAT)
#define VAMASK_FORMAT_T2F \
  (VAMASK_TEXCOORD_ENABLE_MASK | VAMASK_TEXCOORD_SIZE_2 | VAMASK_TEXCOORD_TYPE_FLOAT)
#define VAMASK_FORMAT_T4F \
  (VAMASK_TEXCOORD_ENABLE_MASK | VAMASK_TEXCOORD_SIZE_4 | VAMASK_TEXCOORD_TYPE_FLOAT)
#define VAMASK_FORMAT_V2F \
  (VAMASK_VERTEX_ENABLE_MASK | VAMASK_VERTEX_SIZE_2 | VAMASK_VERTEX_TYPE_FLOAT)
#define VAMASK_FORMAT_V3F \
  (VAMASK_VERTEX_ENABLE_MASK | VAMASK_VERTEX_SIZE_3 | VAMASK_VERTEX_TYPE_FLOAT)
#define VAMASK_FORMAT_V4F \
  (VAMASK_VERTEX_ENABLE_MASK | VAMASK_VERTEX_SIZE_4 | VAMASK_VERTEX_TYPE_FLOAT)
#define VAMASK_FORMAT_C3F_V3F \
  (VAMASK_FORMAT_C3F | VAMASK_FORMAT_V3F)
#define VAMASK_FORMAT_N3F_V3F \
  (VAMASK_FORMAT_N3F | VAMASK_FORMAT_V3F)
#define VAMASK_FORMAT_C3F_N3F_V3F \
  (VAMASK_FORMAT_C3F | VAMASK_FORMAT_N3F | VAMASK_FORMAT_V3F)
#define VAMASK_FORMAT_C4F_N3F_V3F \
  (VAMASK_FORMAT_C4F | VAMASK_FORMAT_N3F | VAMASK_FORMAT_V3F)
#define VAMASK_FORMAT_T2F_V3F \
  (VAMASK_FORMAT_T2F | VAMASK_FORMAT_V3F)
#define VAMASK_FORMAT_T2F_C3F_V3F \
  (VAMASK_FORMAT_T2F | VAMASK_FORMAT_C3F | VAMASK_FORMAT_V3F)
#define VAMASK_FORMAT_T2F_N3F_V3F \
  (VAMASK_FORMAT_T2F | VAMASK_FORMAT_N3F | VAMASK_FORMAT_V3F)
#define VAMASK_FORMAT_T2F_C3F_N3F_V3F \
  (VAMASK_FORMAT_T2F | VAMASK_FORMAT_C3F | VAMASK_FORMAT_N3F | VAMASK_FORMAT_V3F)
#define VAMASK_FORMAT_T2F_C4F_N3F_V3F \
  (VAMASK_FORMAT_T2F | VAMASK_FORMAT_C4F | VAMASK_FORMAT_N3F | VAMASK_FORMAT_V3F)
#define VAMASK_FORMAT_C4UB_V2F \
  (VAMASK_FORMAT_C4UB | VAMASK_FORMAT_V2F)
#define VAMASK_FORMAT_C4UB_V3F \
  (VAMASK_FORMAT_C4UB | VAMASK_FORMAT_V3F)
#define VAMASK_FORMAT_T4F_V4F \
  (VAMASK_FORMAT_T4F | VAMASK_FORMAT_V4F)
#define VAMASK_FORMAT_T2F_C4UB_V3F \
  (VAMASK_FORMAT_T2F | VAMASK_FORMAT_C4UB | VAMASK_FORMAT_V3F)
#define VAMASK_FORMAT_T4F_C4F_N3F_V4F \
  (VAMASK_FORMAT_T4F | VAMASK_FORMAT_C4F | VAMASK_FORMAT_N3F | VAMASK_FORMAT_V4F)

// TYPE_ASSERT
GLint __glTypeSize[] =
{
    sizeof(GLbyte),   // GL_BYTE
    sizeof(GLubyte),  // GL_UNSIGNED_BYTE
    sizeof(GLshort),  // GL_SHORT
    sizeof(GLushort), // GL_UNSIGNED_SHORT
    sizeof(GLint),    // GL_INT
    sizeof(GLuint),   // GL_UNSIGNED_INT
    sizeof(GLfloat),  // GL_FLOAT
    2,                // GL_2_BYTES
    3,                // GL_3_BYTES
    4,                // GL_4_BYTES
    sizeof(GLdouble)  // GL_DOUBLE
};

// ARRAY_TYPE_ASSERT
GLuint vaEnable[] =
{
    VAMASK_VERTEX_ENABLE_MASK,   // GL_VERTEX_ARRAY
    VAMASK_NORMAL_ENABLE_MASK,   // GL_NORMAL_ARRAY
    VAMASK_COLOR_ENABLE_MASK,    // GL_COLOR_ARRAY
    VAMASK_INDEX_ENABLE_MASK,    // GL_INDEX_ARRAY
    VAMASK_TEXCOORD_ENABLE_MASK, // GL_TEXTURE_COORD_ARRAY
    VAMASK_EDGEFLAG_ENABLE_MASK  // GL_EDGE_FLAG_ARRAY
};

PFNGLVECTOR afnTexCoord[] =
{
    (PFNGLVECTOR)glcltTexCoord1sv,
    (PFNGLVECTOR)glcltTexCoord1iv,
    (PFNGLVECTOR)glcltTexCoord1fv,
    (PFNGLVECTOR)glcltTexCoord1dv,

    (PFNGLVECTOR)glcltTexCoord2sv,
    (PFNGLVECTOR)glcltTexCoord2iv,
    (PFNGLVECTOR)glcltTexCoord2fv,
    (PFNGLVECTOR)glcltTexCoord2dv,

    (PFNGLVECTOR)glcltTexCoord3sv,
    (PFNGLVECTOR)glcltTexCoord3iv,
    (PFNGLVECTOR)glcltTexCoord3fv,
    (PFNGLVECTOR)glcltTexCoord3dv,

    (PFNGLVECTOR)glcltTexCoord4sv,
    (PFNGLVECTOR)glcltTexCoord4iv,
    (PFNGLVECTOR)glcltTexCoord4fv,
    (PFNGLVECTOR)glcltTexCoord4dv,
};

PFNGLVECTOR afnTexCoordCompile[] =
{
    (PFNGLVECTOR)__gllc_TexCoord1sv,
    (PFNGLVECTOR)__gllc_TexCoord1iv,
    (PFNGLVECTOR)__gllc_TexCoord1fv,
    (PFNGLVECTOR)__gllc_TexCoord1dv,

    (PFNGLVECTOR)__gllc_TexCoord2sv,
    (PFNGLVECTOR)__gllc_TexCoord2iv,
    (PFNGLVECTOR)__gllc_TexCoord2fv,
    (PFNGLVECTOR)__gllc_TexCoord2dv,

    (PFNGLVECTOR)__gllc_TexCoord3sv,
    (PFNGLVECTOR)__gllc_TexCoord3iv,
    (PFNGLVECTOR)__gllc_TexCoord3fv,
    (PFNGLVECTOR)__gllc_TexCoord3dv,

    (PFNGLVECTOR)__gllc_TexCoord4sv,
    (PFNGLVECTOR)__gllc_TexCoord4iv,
    (PFNGLVECTOR)__gllc_TexCoord4fv,
    (PFNGLVECTOR)__gllc_TexCoord4dv,
};

PFNGLVECTOR afnColor_InRGBA[] =
{
    (PFNGLVECTOR)glcltColor3bv_InRGBA,
    (PFNGLVECTOR)glcltColor3ubv_InRGBA,
    (PFNGLVECTOR)glcltColor3sv_InRGBA,
    (PFNGLVECTOR)glcltColor3usv_InRGBA,
    (PFNGLVECTOR)glcltColor3iv_InRGBA,
    (PFNGLVECTOR)glcltColor3uiv_InRGBA,
    (PFNGLVECTOR)glcltColor3fv_InRGBA,
    (PFNGLVECTOR)glcltColor3dv_InRGBA,

    (PFNGLVECTOR)glcltColor4bv_InRGBA,
    (PFNGLVECTOR)glcltColor4ubv_InRGBA,
    (PFNGLVECTOR)glcltColor4sv_InRGBA,
    (PFNGLVECTOR)glcltColor4usv_InRGBA,
    (PFNGLVECTOR)glcltColor4iv_InRGBA,
    (PFNGLVECTOR)glcltColor4uiv_InRGBA,
    (PFNGLVECTOR)glcltColor4fv_InRGBA,
    (PFNGLVECTOR)glcltColor4dv_InRGBA,
};

PFNGLVECTOR afnColor_InCI[] =
{
    (PFNGLVECTOR)glcltColor3bv_InCI,
    (PFNGLVECTOR)glcltColor3ubv_InCI,
    (PFNGLVECTOR)glcltColor3sv_InCI,
    (PFNGLVECTOR)glcltColor3usv_InCI,
    (PFNGLVECTOR)glcltColor3iv_InCI,
    (PFNGLVECTOR)glcltColor3uiv_InCI,
    (PFNGLVECTOR)glcltColor3fv_InCI,
    (PFNGLVECTOR)glcltColor3dv_InCI,

    (PFNGLVECTOR)glcltColor4bv_InCI,
    (PFNGLVECTOR)glcltColor4ubv_InCI,
    (PFNGLVECTOR)glcltColor4sv_InCI,
    (PFNGLVECTOR)glcltColor4usv_InCI,
    (PFNGLVECTOR)glcltColor4iv_InCI,
    (PFNGLVECTOR)glcltColor4uiv_InCI,
    (PFNGLVECTOR)glcltColor4fv_InCI,
    (PFNGLVECTOR)glcltColor4dv_InCI,
};

PFNGLVECTOR afnColorCompile[] =
{
    (PFNGLVECTOR)__gllc_Color3bv,
    (PFNGLVECTOR)__gllc_Color3ubv,
    (PFNGLVECTOR)__gllc_Color3sv,
    (PFNGLVECTOR)__gllc_Color3usv,
    (PFNGLVECTOR)__gllc_Color3iv,
    (PFNGLVECTOR)__gllc_Color3uiv,
    (PFNGLVECTOR)__gllc_Color3fv,
    (PFNGLVECTOR)__gllc_Color3dv,

    (PFNGLVECTOR)__gllc_Color4bv,
    (PFNGLVECTOR)__gllc_Color4ubv,
    (PFNGLVECTOR)__gllc_Color4sv,
    (PFNGLVECTOR)__gllc_Color4usv,
    (PFNGLVECTOR)__gllc_Color4iv,
    (PFNGLVECTOR)__gllc_Color4uiv,
    (PFNGLVECTOR)__gllc_Color4fv,
    (PFNGLVECTOR)__gllc_Color4dv,
};

PFNGLVECTOR afnIndex_InRGBA[] =
{
    (PFNGLVECTOR)glcltIndexubv_InRGBA,
    (PFNGLVECTOR)glcltIndexsv_InRGBA,
    (PFNGLVECTOR)glcltIndexiv_InRGBA,
    (PFNGLVECTOR)glcltIndexfv_InRGBA,
    (PFNGLVECTOR)glcltIndexdv_InRGBA,
};

PFNGLVECTOR afnIndex_InCI[] =
{
    (PFNGLVECTOR)glcltIndexubv_InCI,
    (PFNGLVECTOR)glcltIndexsv_InCI,
    (PFNGLVECTOR)glcltIndexiv_InCI,
    (PFNGLVECTOR)glcltIndexfv_InCI,
    (PFNGLVECTOR)glcltIndexdv_InCI,
};

PFNGLVECTOR afnIndexCompile[] =
{
    (PFNGLVECTOR)__gllc_Indexubv,
    (PFNGLVECTOR)__gllc_Indexsv,
    (PFNGLVECTOR)__gllc_Indexiv,
    (PFNGLVECTOR)__gllc_Indexfv,
    (PFNGLVECTOR)__gllc_Indexdv,
};

PFNGLVECTOR afnNormal[] =
{
    (PFNGLVECTOR)glcltNormal3bv,
    (PFNGLVECTOR)glcltNormal3sv,
    (PFNGLVECTOR)glcltNormal3iv,
    (PFNGLVECTOR)glcltNormal3fv,
    (PFNGLVECTOR)glcltNormal3dv,
};

PFNGLVECTOR afnNormalCompile[] =
{
    (PFNGLVECTOR)__gllc_Normal3bv,
    (PFNGLVECTOR)__gllc_Normal3sv,
    (PFNGLVECTOR)__gllc_Normal3iv,
    (PFNGLVECTOR)__gllc_Normal3fv,
    (PFNGLVECTOR)__gllc_Normal3dv,
};

PFNGLVECTOR afnVertex[] =
{
    (PFNGLVECTOR)glcltVertex2sv,
    (PFNGLVECTOR)glcltVertex2iv,
    (PFNGLVECTOR)glcltVertex2fv,
    (PFNGLVECTOR)glcltVertex2dv,

    (PFNGLVECTOR)glcltVertex3sv,
    (PFNGLVECTOR)glcltVertex3iv,
    (PFNGLVECTOR)glcltVertex3fv,
    (PFNGLVECTOR)glcltVertex3dv,

    (PFNGLVECTOR)glcltVertex4sv,
    (PFNGLVECTOR)glcltVertex4iv,
    (PFNGLVECTOR)glcltVertex4fv,
    (PFNGLVECTOR)glcltVertex4dv,
};

PFNGLVECTOR afnVertexCompile[] =
{
    (PFNGLVECTOR)__gllc_Vertex2sv,
    (PFNGLVECTOR)__gllc_Vertex2iv,
    (PFNGLVECTOR)__gllc_Vertex2fv,
    (PFNGLVECTOR)__gllc_Vertex2dv,

    (PFNGLVECTOR)__gllc_Vertex3sv,
    (PFNGLVECTOR)__gllc_Vertex3iv,
    (PFNGLVECTOR)__gllc_Vertex3fv,
    (PFNGLVECTOR)__gllc_Vertex3dv,

    (PFNGLVECTOR)__gllc_Vertex4sv,
    (PFNGLVECTOR)__gllc_Vertex4iv,
    (PFNGLVECTOR)__gllc_Vertex4fv,
    (PFNGLVECTOR)__gllc_Vertex4dv,
};

void FASTCALL __glInitVertexArray(__GLcontext *gc)
{
    // Initial vertex array state.
    static __GLvertexArray defaultVertexArrayState =
    {
        __GL_VERTEX_ARRAY_DIRTY,            // flags

        VAMASK_TEXCOORD_SIZE_4 |            // mask
        VAMASK_TEXCOORD_TYPE_FLOAT |
        VAMASK_INDEX_TYPE_FLOAT |
        VAMASK_COLOR_SIZE_4 |
        VAMASK_COLOR_TYPE_FLOAT |
        VAMASK_NORMAL_TYPE_FLOAT |
        VAMASK_VERTEX_SIZE_4 |
        VAMASK_VERTEX_TYPE_FLOAT,

        VA_ArrayElement,                    // pfnArrayElement
        VA_ArrayElementB,                   // pfnArrayElementBatch
        VA_ArrayElementBI,                  // pfnArrayElementBatchIndirect
        {                                   // edgeFlag
            sizeof(GLboolean),              //   ibytes
            0,                              //   stride
            NULL,                           //   pointer
            glcltEdgeFlagv,                 //   pfn
            __gllc_EdgeFlagv,               //   pfnCompile
        },

        {                                   // texcoord
            4,                              //   size
            GL_FLOAT,                       //   type
            4 * sizeof(GLfloat),            //   ibytes
            0,                              //   stride
            NULL,                           //   pointer
            NULL,                           //   pfn
            NULL,                           //   pfnCompile
        },

        {                                   // index
            GL_FLOAT,                       //   type
            sizeof(GLfloat),                //   ibytes
            0,                              //   stride
            NULL,                           //   pointer
            NULL,                           //   pfn
            NULL,                           //   pfnCompile
        },

        {                                   // color
            4,                              //   size
            GL_FLOAT,                       //   type
            4 * sizeof(GLfloat),            //   ibytes
            0,                              //   stride
            NULL,                           //   pointer
            NULL,                           //   pfn
            NULL,                           //   pfnCompile
        },

        {                                   // normal
            GL_FLOAT,                       //   type
            3 * sizeof(GLfloat),            //   ibytes
            0,                              //   stride
            NULL,                           //   pointer
            NULL,                           //   pfn
            NULL,                           //   pfnCompile
        },

        {                                   // vertex
            4,                              //   size
            GL_FLOAT,                       //   type
            4 * sizeof(GLfloat),            //   ibytes
            0,                              //   stride
            NULL,                           //   pointer
            NULL,                           //   pfn
            NULL,                           //   pfnCompile
        },
    };

    gc->vertexArray = defaultVertexArrayState;
}

void APIENTRY glcltEdgeFlagPointer (GLsizei stride, const GLvoid *pointer)
{
    __GL_SETUP();

// Not allowed in begin/end.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

    if (stride < 0)
    {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    } 

    if (stride)
        gc->vertexArray.edgeFlag.ibytes = stride;
    else
        gc->vertexArray.edgeFlag.ibytes = sizeof(GLboolean);

    gc->vertexArray.edgeFlag.stride  = stride;
    gc->vertexArray.edgeFlag.pointer = pointer;
}

void APIENTRY glcltTexCoordPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    GLuint vaMask;
    __GL_SETUP();

// Not allowed in begin/end.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    switch (type)
    {
      case GL_SHORT:
        vaMask = VAMASK_TEXCOORD_TYPE_SHORT;
        break;
      case GL_INT:
        vaMask = VAMASK_TEXCOORD_TYPE_INT;
        break;
      case GL_FLOAT:
        vaMask = VAMASK_TEXCOORD_TYPE_FLOAT;
        break;
      case GL_DOUBLE:
        vaMask = VAMASK_TEXCOORD_TYPE_DOUBLE;
        break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    switch (size)
    {
      case 1:
        vaMask |= VAMASK_TEXCOORD_SIZE_1;
        break;
      case 2:
        vaMask |= VAMASK_TEXCOORD_SIZE_2;
        break;
      case 3:
        vaMask |= VAMASK_TEXCOORD_SIZE_3;
        break;
      case 4:
        vaMask |= VAMASK_TEXCOORD_SIZE_4;
        break;
      default:
	GLSETERROR(GL_INVALID_VALUE);
	return;
    }

    if (stride < 0)
    {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    }

    if (stride)
        gc->vertexArray.texCoord.ibytes = stride;
    else
        gc->vertexArray.texCoord.ibytes = size * __GLTYPESIZE(type);

    gc->vertexArray.texCoord.size    = size;
    gc->vertexArray.texCoord.type    = type;
    gc->vertexArray.texCoord.stride  = stride;
    gc->vertexArray.texCoord.pointer = pointer;
    if ((gc->vertexArray.mask & VAMASK_TEXCOORD_TYPE_SIZE_MASK) != vaMask)
    {
        gc->vertexArray.mask  &= ~VAMASK_TEXCOORD_TYPE_SIZE_MASK;
        gc->vertexArray.mask  |= vaMask;
        gc->vertexArray.flags |= __GL_VERTEX_ARRAY_DIRTY;
    }
}

void APIENTRY glcltColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    GLuint vaMask;
    __GL_SETUP();

// Not allowed in begin/end.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    switch (type)
    {
      case GL_BYTE:
        vaMask = VAMASK_COLOR_TYPE_BYTE;
        break;
      case GL_UNSIGNED_BYTE:
        vaMask = VAMASK_COLOR_TYPE_UBYTE;
        break;
      case GL_SHORT:
        vaMask = VAMASK_COLOR_TYPE_SHORT;
        break;
      case GL_UNSIGNED_SHORT:
        vaMask = VAMASK_COLOR_TYPE_USHORT;
        break;
      case GL_INT:
        vaMask = VAMASK_COLOR_TYPE_INT;
        break;
      case GL_UNSIGNED_INT:
        vaMask = VAMASK_COLOR_TYPE_UINT;
        break;
      case GL_FLOAT:
        vaMask = VAMASK_COLOR_TYPE_FLOAT;
        break;
      case GL_DOUBLE:
        vaMask = VAMASK_COLOR_TYPE_DOUBLE;
        break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    switch (size)
    {
      case 3:
        vaMask |= VAMASK_COLOR_SIZE_3;
        break;
      case 4:
        vaMask |= VAMASK_COLOR_SIZE_4;
        break;
      default:
        GLSETERROR(GL_INVALID_VALUE);
        return;
    }

    if (stride < 0)
    {
        GLSETERROR(GL_INVALID_VALUE);
        return;
    }

    if (stride)
        gc->vertexArray.color.ibytes = stride;
    else
        gc->vertexArray.color.ibytes = size * __GLTYPESIZE(type);

    gc->vertexArray.color.size    = size;
    gc->vertexArray.color.type    = type;
    gc->vertexArray.color.stride  = stride;
    gc->vertexArray.color.pointer = pointer;
    if ((gc->vertexArray.mask & VAMASK_COLOR_TYPE_SIZE_MASK) != vaMask)
    {
        gc->vertexArray.mask  &= ~VAMASK_COLOR_TYPE_SIZE_MASK;
        gc->vertexArray.mask  |= vaMask;
        gc->vertexArray.flags |= __GL_VERTEX_ARRAY_DIRTY;
    }
}

void APIENTRY glcltIndexPointer (GLenum type, GLsizei stride, const GLvoid *pointer)
{
    GLuint vaMask;
    __GL_SETUP();

// Not allowed in begin/end.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    switch (type)
    {
      case GL_UNSIGNED_BYTE:
        vaMask = VAMASK_INDEX_TYPE_UBYTE;
	break;
      case GL_SHORT:
        vaMask = VAMASK_INDEX_TYPE_SHORT;
	break;
      case GL_INT:
        vaMask = VAMASK_INDEX_TYPE_INT;
	break;
      case GL_FLOAT:
        vaMask = VAMASK_INDEX_TYPE_FLOAT;
	break;
      case GL_DOUBLE:
        vaMask = VAMASK_INDEX_TYPE_DOUBLE;
	break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    if (stride < 0)
    {
        GLSETERROR(GL_INVALID_VALUE);
        return;
    }

    if (stride)
        gc->vertexArray.index.ibytes = stride;
    else
        gc->vertexArray.index.ibytes = __GLTYPESIZE(type);

    gc->vertexArray.index.type    = type;
    gc->vertexArray.index.stride  = stride;
    gc->vertexArray.index.pointer = pointer;
    // update index function pointer!
    if ((gc->vertexArray.mask & VAMASK_INDEX_TYPE_SIZE_MASK) != vaMask)
    {
        gc->vertexArray.mask  &= ~VAMASK_INDEX_TYPE_SIZE_MASK;
        gc->vertexArray.mask  |= vaMask;
        gc->vertexArray.flags |= __GL_VERTEX_ARRAY_DIRTY;
    }
}

void APIENTRY glcltNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer)
{
    GLuint vaMask;
    __GL_SETUP();

// Not allowed in begin/end.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    switch (type)
    {
      case GL_BYTE:
        vaMask = VAMASK_NORMAL_TYPE_BYTE;
        break;
      case GL_SHORT:
        vaMask = VAMASK_NORMAL_TYPE_SHORT;
        break;
      case GL_INT:
        vaMask = VAMASK_NORMAL_TYPE_INT;
        break;
      case GL_FLOAT:
        vaMask = VAMASK_NORMAL_TYPE_FLOAT;
        break;
      case GL_DOUBLE:
        vaMask = VAMASK_NORMAL_TYPE_DOUBLE;
        break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    if (stride < 0)
    {
        GLSETERROR(GL_INVALID_VALUE);
        return;
    }

    if (stride)
        gc->vertexArray.normal.ibytes = stride;
    else
        gc->vertexArray.normal.ibytes = 3 * __GLTYPESIZE(type);

    gc->vertexArray.normal.type    = type;
    gc->vertexArray.normal.stride  = stride;
    gc->vertexArray.normal.pointer = pointer;
    if ((gc->vertexArray.mask & VAMASK_NORMAL_TYPE_SIZE_MASK) != vaMask)
    {
        gc->vertexArray.mask  &= ~VAMASK_NORMAL_TYPE_SIZE_MASK;
        gc->vertexArray.mask  |= vaMask;
        gc->vertexArray.flags |= __GL_VERTEX_ARRAY_DIRTY;
    }
}

void APIENTRY glcltVertexPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    GLuint vaMask;
    __GL_SETUP();

// Not allowed in begin/end.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    switch (type)
    {
      case GL_SHORT:
        vaMask = VAMASK_VERTEX_TYPE_SHORT;
        break;
      case GL_INT:
        vaMask = VAMASK_VERTEX_TYPE_INT;
        break;
      case GL_FLOAT:
        vaMask = VAMASK_VERTEX_TYPE_FLOAT;
        break;
      case GL_DOUBLE:
        vaMask = VAMASK_VERTEX_TYPE_DOUBLE;
        break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    switch (size)
    {
      case 2:
        vaMask |= VAMASK_VERTEX_SIZE_2;
        break;
      case 3:
        vaMask |= VAMASK_VERTEX_SIZE_3;
        break;
      case 4:
        vaMask |= VAMASK_VERTEX_SIZE_4;
        break;
      default:
        GLSETERROR(GL_INVALID_VALUE);
        return;
    }

    if (stride < 0)
    {
        GLSETERROR(GL_INVALID_VALUE);
        return;
    }

    if (stride)
        gc->vertexArray.vertex.ibytes = stride;
    else
        gc->vertexArray.vertex.ibytes = size * __GLTYPESIZE(type);

    gc->vertexArray.vertex.size    = size;
    gc->vertexArray.vertex.type    = type;
    gc->vertexArray.vertex.stride  = stride;
    gc->vertexArray.vertex.pointer = pointer;
    if ((gc->vertexArray.mask & VAMASK_VERTEX_TYPE_SIZE_MASK) != vaMask)
    {
        gc->vertexArray.mask  &= ~VAMASK_VERTEX_TYPE_SIZE_MASK;
        gc->vertexArray.mask  |= vaMask;
        gc->vertexArray.flags |= __GL_VERTEX_ARRAY_DIRTY;
    }
}

void APIENTRY glcltEnableClientState (GLenum cap)
{
    __GL_SETUP();

// Not allowed in begin/end.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    // ARRAY_TYPE_ASSERT
    if (RANGE(cap,GL_VERTEX_ARRAY,GL_EDGE_FLAG_ARRAY))
    {
        if (!(gc->vertexArray.mask & vaEnable[cap - GL_VERTEX_ARRAY]))
        {
            gc->vertexArray.mask  |= vaEnable[cap - GL_VERTEX_ARRAY];
            gc->vertexArray.flags |= __GL_VERTEX_ARRAY_DIRTY;
        }
    }
}

void APIENTRY glcltDisableClientState (GLenum cap)
{
    __GL_SETUP();

// Not allowed in begin/end.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    // ARRAY_TYPE_ASSERT
    if (RANGE(cap,GL_VERTEX_ARRAY,GL_EDGE_FLAG_ARRAY))
    {
        if (gc->vertexArray.mask & vaEnable[cap - GL_VERTEX_ARRAY])
        {
	        gc->vertexArray.mask  &= ~vaEnable[cap - GL_VERTEX_ARRAY];
	        gc->vertexArray.flags |= __GL_VERTEX_ARRAY_DIRTY;
        }
    }
}

void APIENTRY glcltGetPointerv (GLenum pname, GLvoid* *params)
{
    __GL_SETUP();

// Not allowed in begin/end.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    switch (pname)
    {
      case GL_VERTEX_ARRAY_POINTER:
        *params = (GLvoid *) gc->vertexArray.vertex.pointer;
        break;
      case GL_NORMAL_ARRAY_POINTER:
        *params = (GLvoid *) gc->vertexArray.normal.pointer;
        break;
      case GL_COLOR_ARRAY_POINTER:
        *params = (GLvoid *) gc->vertexArray.color.pointer;
        break;
      case GL_INDEX_ARRAY_POINTER:
        *params = (GLvoid *) gc->vertexArray.index.pointer;
        break;
      case GL_TEXTURE_COORD_ARRAY_POINTER:
        *params = (GLvoid *) gc->vertexArray.texCoord.pointer;
        break;
      case GL_EDGE_FLAG_ARRAY_POINTER:
        *params = (GLvoid *) gc->vertexArray.edgeFlag.pointer;
        break;
      case GL_SELECTION_BUFFER_POINTER:
        // The client pointer is maintained current at all times.
        *params = (GLvoid *) gc->select.resultBase;
        break;
      case GL_FEEDBACK_BUFFER_POINTER:
        // The client pointer is maintained current at all times.
        *params = (GLvoid *) gc->feedback.resultBase;
        break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        break;
    }
}

// We have special cases for the following formats.  They also match the
// special cases in display list.
//
//   V2F
//   V3F
//   C3F_V3F
//   N3F_V3F
//   C3F_N3F_V3F     (non 1.1 format)
//   C4F_N3F_V3F
//   T2F_V3F
//   T2F_C3F_V3F
//   T2F_N3F_V3F
//   T2F_C3F_N3F_V3F (non 1.1 format)
//   T2F_C4F_N3F_V3F
//
// There are no special cases for the following 1.1 formats:
//
//   C4UB_V2F
//   C4UB_V3F
//   T4F_V4F
//   T2F_C4UB_V3F
//   T4F_C4F_N3F_V4F

void FASTCALL VA_ValidateArrayPointers(__GLcontext *gc)
{
    GLuint vaMask;
    GLuint formatMask;
    PFNVAELEMENT fp;
    PFNVAELEMENTBATCH fpB;
    PFNVAELEMENTBATCHINDIRECT fpBI;

    fp = VA_ArrayElement;
    fpB  = VA_ArrayElementB;
    fpBI = VA_ArrayElementBI;
    vaMask = gc->vertexArray.mask;

// The fast routines are for RGBA mode only.  Edge flag and index array
// pointers are disabled in these routines.  Vertex array pointer is enabled.

    if (!gc->modes.colorIndexMode &&
        !(vaMask & (VAMASK_EDGEFLAG_ENABLE_MASK | VAMASK_INDEX_ENABLE_MASK)) &&
        (vaMask & VAMASK_VERTEX_ENABLE_MASK))
    {
        formatMask = VAMASK_VERTEX_TYPE_SIZE_MASK | VAMASK_VERTEX_ENABLE_MASK;
        if (vaMask & VAMASK_TEXCOORD_ENABLE_MASK)
	        formatMask |= VAMASK_TEXCOORD_TYPE_SIZE_MASK | VAMASK_TEXCOORD_ENABLE_MASK;
        if (vaMask & VAMASK_COLOR_ENABLE_MASK)
	        formatMask |= VAMASK_COLOR_TYPE_SIZE_MASK | VAMASK_COLOR_ENABLE_MASK;
        if (vaMask & VAMASK_NORMAL_ENABLE_MASK)
	        formatMask |= VAMASK_NORMAL_TYPE_SIZE_MASK | VAMASK_NORMAL_ENABLE_MASK;

        switch (vaMask & formatMask)
        {
          case VAMASK_FORMAT_V2F:
	        fp = VA_ArrayElement_V2F;
	        fpB = VA_ArrayElement_V2F_B;
	        fpBI = VA_ArrayElement_V2F_BI;
	        break;
          case VAMASK_FORMAT_V3F:
	        fp = VA_ArrayElement_V3F;
	        fpB = VA_ArrayElement_V3F_B;
	        fpBI = VA_ArrayElement_V3F_BI;
	        break;
          case VAMASK_FORMAT_C3F_V3F:
	        fp = VA_ArrayElement_C3F_V3F;
	        fpB = VA_ArrayElement_C3F_V3F_B;
	        fpBI = VA_ArrayElement_C3F_V3F_BI;
	        break;
          case VAMASK_FORMAT_N3F_V3F:
	        fp = VA_ArrayElement_N3F_V3F;
	        fpB = VA_ArrayElement_N3F_V3F_B;
	        fpBI = VA_ArrayElement_N3F_V3F_BI;
	        break;
          case VAMASK_FORMAT_C3F_N3F_V3F:
	        fp = VA_ArrayElement_C3F_N3F_V3F;
	        fpB = VA_ArrayElement_C3F_N3F_V3F_B;
	        fpBI = VA_ArrayElement_C3F_N3F_V3F_BI;
	        break;
          case VAMASK_FORMAT_C4F_N3F_V3F:
	        fp = VA_ArrayElement_C4F_N3F_V3F;
	        fpB = VA_ArrayElement_C4F_N3F_V3F_B;
	        fpBI = VA_ArrayElement_C4F_N3F_V3F_BI;
	        break;
          case VAMASK_FORMAT_T2F_V3F:
	        fp = VA_ArrayElement_T2F_V3F;
	        fpB = VA_ArrayElement_T2F_V3F_B;
	        fpBI = VA_ArrayElement_T2F_V3F_BI;
	        break;
          case VAMASK_FORMAT_T2F_C3F_V3F:
	        fp = VA_ArrayElement_T2F_C3F_V3F;
	        fpB = VA_ArrayElement_T2F_C3F_V3F_B;
	        fpBI = VA_ArrayElement_T2F_C3F_V3F_BI;
	        break;
          case VAMASK_FORMAT_T2F_N3F_V3F:
	        fp = VA_ArrayElement_T2F_N3F_V3F;
	        fpB = VA_ArrayElement_T2F_N3F_V3F_B;
	        fpBI = VA_ArrayElement_T2F_N3F_V3F_BI;
	        break;
          case VAMASK_FORMAT_T2F_C3F_N3F_V3F:
	        fp = VA_ArrayElement_T2F_C3F_N3F_V3F;
	        fpB = VA_ArrayElement_T2F_C3F_N3F_V3F_B;
	        fpBI = VA_ArrayElement_T2F_C3F_N3F_V3F_BI;
	        break;
          case VAMASK_FORMAT_T2F_C4F_N3F_V3F:
	        fp = VA_ArrayElement_T2F_C4F_N3F_V3F;
	        fpB = VA_ArrayElement_T2F_C4F_N3F_V3F_B;
	        fpBI = VA_ArrayElement_T2F_C4F_N3F_V3F_BI;
	        break;
        }
    }

// The default function pointers are used outside Begin.

    ASSERTOPENGL(gc->vertexArray.edgeFlag.pfn == (PFNGLVECTOR) glcltEdgeFlagv &&
                 gc->vertexArray.edgeFlag.pfnCompile == (PFNGLVECTOR) __gllc_EdgeFlagv,
	"edgeFlag.pfn and edgeFlag.pfnCompile not initialized\n");
    gc->vertexArray.texCoord.pfn
	= afnTexCoord[(vaMask & VAMASK_TEXCOORD_TYPE_SIZE_MASK) >> VAMASK_TEXCOORD_TYPE_SHIFT];
    gc->vertexArray.texCoord.pfnCompile
	= afnTexCoordCompile[(vaMask & VAMASK_TEXCOORD_TYPE_SIZE_MASK) >> VAMASK_TEXCOORD_TYPE_SHIFT];
    if (gc->modes.colorIndexMode)
    {
        gc->vertexArray.color.pfn
	        = afnColor_InCI[(vaMask & VAMASK_COLOR_TYPE_SIZE_MASK) >> VAMASK_COLOR_TYPE_SHIFT];
        gc->vertexArray.index.pfn
	        = afnIndex_InCI[(vaMask & VAMASK_INDEX_TYPE_SIZE_MASK) >> VAMASK_INDEX_TYPE_SHIFT];
    }
    else
    {
        gc->vertexArray.color.pfn
	        = afnColor_InRGBA[(vaMask & VAMASK_COLOR_TYPE_SIZE_MASK) >> VAMASK_COLOR_TYPE_SHIFT];
        gc->vertexArray.index.pfn
	        = afnIndex_InRGBA[(vaMask & VAMASK_INDEX_TYPE_SIZE_MASK) >> VAMASK_INDEX_TYPE_SHIFT];
    }
    gc->vertexArray.color.pfnCompile
        = afnColorCompile[(vaMask & VAMASK_COLOR_TYPE_SIZE_MASK) >> VAMASK_COLOR_TYPE_SHIFT];
    gc->vertexArray.index.pfnCompile
        = afnIndexCompile[(vaMask & VAMASK_INDEX_TYPE_SIZE_MASK) >> VAMASK_INDEX_TYPE_SHIFT];
    gc->vertexArray.normal.pfn
        = afnNormal[(vaMask & VAMASK_NORMAL_TYPE_SIZE_MASK) >> VAMASK_NORMAL_TYPE_SHIFT];
    gc->vertexArray.normal.pfnCompile
        = afnNormalCompile[(vaMask & VAMASK_NORMAL_TYPE_SIZE_MASK) >> VAMASK_NORMAL_TYPE_SHIFT];
    gc->vertexArray.vertex.pfn
        = afnVertex[(vaMask & VAMASK_VERTEX_TYPE_SIZE_MASK) >> VAMASK_VERTEX_TYPE_SHIFT];
    gc->vertexArray.vertex.pfnCompile
        = afnVertexCompile[(vaMask & VAMASK_VERTEX_TYPE_SIZE_MASK) >> VAMASK_VERTEX_TYPE_SHIFT];

    gc->vertexArray.pfnArrayElement = fp;
    gc->vertexArray.pfnArrayElementBatch = fpB;
    gc->vertexArray.pfnArrayElementBatchIndirect = fpBI;
    gc->vertexArray.flags &= ~__GL_VERTEX_ARRAY_DIRTY;
}

void APIENTRY glcltArrayElement (GLint i)
{
    __GL_SETUP();

    if (gc->vertexArray.flags & __GL_VERTEX_ARRAY_DIRTY)
	VA_ValidateArrayPointers(gc);

// The fast routines are called in Begin only.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
        (*gc->vertexArray.pfnArrayElement)(gc, i);
    else
        VA_ArrayElement(gc, i);
}

// Define fast VA_ArrayElement functions.

#define __VA_ARRAY_ELEMENT_V2F			1
    #include "array.h"
#undef __VA_ARRAY_ELEMENT_V2F

#define __VA_ARRAY_ELEMENT_V3F			1
    #include "array.h"
#undef __VA_ARRAY_ELEMENT_V3F

#define __VA_ARRAY_ELEMENT_C3F_V3F		1
    #include "array.h"
#undef __VA_ARRAY_ELEMENT_C3F_V3F

#define __VA_ARRAY_ELEMENT_N3F_V3F		1
    #include "array.h"
#undef __VA_ARRAY_ELEMENT_N3F_V3F

#define __VA_ARRAY_ELEMENT_C3F_N3F_V3F		1
    #include "array.h"
#undef __VA_ARRAY_ELEMENT_C3F_N3F_V3F

#define __VA_ARRAY_ELEMENT_C4F_N3F_V3F		1
    #include "array.h"
#undef __VA_ARRAY_ELEMENT_C4F_N3F_V3F

#define __VA_ARRAY_ELEMENT_T2F_V3F		1
    #include "array.h"
#undef __VA_ARRAY_ELEMENT_T2F_V3F

#define __VA_ARRAY_ELEMENT_T2F_C3F_V3F		1
    #include "array.h"
#undef __VA_ARRAY_ELEMENT_T2F_C3F_V3F

#define __VA_ARRAY_ELEMENT_T2F_N3F_V3F		1
    #include "array.h"
#undef __VA_ARRAY_ELEMENT_T2F_N3F_V3F

#define __VA_ARRAY_ELEMENT_T2F_C3F_N3F_V3F	1
    #include "array.h"
#undef __VA_ARRAY_ELEMENT_T2F_C3F_N3F_V3F

#define __VA_ARRAY_ELEMENT_T2F_C4F_N3F_V3F	1
    #include "array.h"
#undef __VA_ARRAY_ELEMENT_T2F_C4F_N3F_V3F

#define CALLARRAYPOINTER(ap, i) \
    ((*(ap).pfn)((ap).pointer + (i) * (ap).ibytes))

#define CALLARRAYPOINTERS                               \
    if (vaMask & VAMASK_EDGEFLAG_ENABLE_MASK)           \
        CALLARRAYPOINTER(gc->vertexArray.edgeFlag, i);  \
    if (vaMask & VAMASK_TEXCOORD_ENABLE_MASK)           \
        CALLARRAYPOINTER(gc->vertexArray.texCoord, i);  \
    if (vaMask & VAMASK_COLOR_ENABLE_MASK)              \
        CALLARRAYPOINTER(gc->vertexArray.color, i);     \
    if (vaMask & VAMASK_INDEX_ENABLE_MASK)              \
        CALLARRAYPOINTER(gc->vertexArray.index, i);     \
    if (vaMask & VAMASK_NORMAL_ENABLE_MASK)             \
        CALLARRAYPOINTER(gc->vertexArray.normal, i);    \
    if (vaMask & VAMASK_VERTEX_ENABLE_MASK)             \
        CALLARRAYPOINTER(gc->vertexArray.vertex, i);

void FASTCALL VA_ArrayElementB(__GLcontext *gc, GLint firstVertex, GLint nVertices)
{
    GLint   k, i;
    GLuint  vaMask = gc->vertexArray.mask;

    for (k=0; k < nVertices; k++)
    {
        i = k+firstVertex;
        CALLARRAYPOINTERS;
    }
}

void FASTCALL VA_ArrayElementBI(__GLcontext *gc, GLint nVertices, VAMAP* indices)
{
    GLint   k, i;
    GLuint  vaMask = gc->vertexArray.mask;

    for (k=0; k < nVertices; k++)
    {
        i = indices[k].iIn;
        CALLARRAYPOINTERS;
    }
}

void FASTCALL VA_ArrayElement(__GLcontext *gc, GLint i)
{
    GLuint vaMask = gc->vertexArray.mask;

    CALLARRAYPOINTERS;
}

void APIENTRY glcltDrawArrays (GLenum mode, GLint first, GLsizei count)
{
    int i;
    POLYARRAY    *pa;
    PFNVAELEMENTBATCH pfn;

    __GL_SETUP();

    pa = gc->paTeb;

// Not allowed in begin/end.

    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

    if ((GLuint) mode > GL_POLYGON)
    {
        GLSETERROR(GL_INVALID_ENUM);
	return;
    }

    if (count < 0)
    {
        GLSETERROR(GL_INVALID_VALUE);
        return;
    } else if (!count)
        return;

// Find array element function to use.

    if (gc->vertexArray.flags & __GL_VERTEX_ARRAY_DIRTY)
	VA_ValidateArrayPointers(gc);

    pfn = gc->vertexArray.pfnArrayElementBatch;

// Check polyarray buffer size before calling Begin.
// We will minimize breaking poly data records into batches where possible.
// The number 8 is loosely chosen to allow for the poly array entry
// and the flush limit.  At worst, it causes an unnecessary attention!

    if (count <= (GLsizei) gc->vertex.pdBufSize - 8 &&
        count >= (GLsizei) (pa->pdBufferMax - pa->pdBufferNext + 1 - 8))
        glsbAttention();

// Draw the array elements.

    glcltBegin(mode);
    pa->flags |= POLYARRAY_SAME_POLYDATA_TYPE;

    (*pfn)(gc, first, count);

    glcltEnd();
}

// Do not modify these constants.  The code will likely break if they are
// changed.
#define VA_HASH_SIZE            256
#define VA_HASH(indexIn)        ((GLubyte) indexIn)

// If the size of the mapping array is greater than 256, we need to change
// datatype and code below.
#if (VA_DRAWELEM_MAP_SIZE > 256)
#error "VA_DRAWELEM_MAP_SIZE is too large"
#endif

/******************************Public*Routine******************************\
* ReduceDrawElements
*
* Takes a set of DrawElements indices and reduces it into small chunks
* of unique vertex indices
*
* History:
*  Sat Mar 02 14:25:26 1996     -by-    Hock San Lee    [hockl]
* Wrote original version embedded in DrawElements
*  Sat Mar 02 14:25:26 1996     -by-    Drew Bliss      [drewb]
* Split into function shared between immediate and dlist
*
\**************************************************************************/

void FASTCALL ReduceDrawElements(__GLcontext *gc,
                                 GLenum mode, GLsizei count, GLenum type,
                                 const GLvoid *pIn,
                                 pfnReducedElementsHandler pfnHandler)
{
    GLushort     _aHash[VA_HASH_SIZE + 2];
    GLushort     *pHash;
    VAMAP        aMap[VA_DRAWELEM_MAP_SIZE];
    GLushort     iMap, iMapNext;
    GLushort     iOutNext;
    GLubyte      aOut[VA_DRAWELEM_INDEX_SIZE];
    GLsizei      iPartialIndices;
    GLsizei      iCount, nLeft;
    GLuint       iIn;
    
// We will now sort the input index array using a hash table.  The output
// index array will be zero based.  For example, if the input array is
// [103, 101,   0,   2, 105, 103,   2,   4], the output index will be
// [0,     1,   2,   3,   4,   0,   3,   5].  This allows us to store
// vertices in a consecutive order.
// Dword aligned hash array.

    pHash = (GLushort *) (((UINT_PTR) _aHash + 3) & ~3);

// Initialize input index array pointer.

    iCount = 0;
    iPartialIndices = 0;

DrawElements_NextBatch:

// Reset output index array for this batch.
// Initialize identity mapping for the first reserved vertex entries.
// New vertices are accumulated after them.

    for (iOutNext = 0; iOutNext < (GLushort) iPartialIndices; iOutNext++)
	aOut[iOutNext] = (GLubyte) iOutNext;

// Reset index mapping array that maps the In array to Out array.
// The index map corresponds to the vertices in the vertex buffer.
// Skip the reserved indices that are used for connectivity between
// partial primitives.

    iMapNext = iOutNext;

// Reset hash array to no mapping (-1).

    RtlFillMemoryUlong((PVOID) pHash, (ULONG) VA_HASH_SIZE * sizeof(*pHash),
	(ULONG) -1);

// There are 3 possibilities in the following loop:
//
// 1. All input indices have been processed.  The primitive is complete!
// 2. The index map overflows.  We have accumulated 256 vertices for a partial
//    primitive.
// 3. The output index array overflows.  We have exceeded our estimated size
//    of the output index array for a partial primitive.

    for ( ; iCount < count; iCount++)
    {
// Get next input index.

	if (type == GL_UNSIGNED_BYTE)
	    iIn = (GLuint) ((GLubyte *)  pIn)[iCount];
	else if (type == GL_UNSIGNED_SHORT)
	    iIn = (GLuint) ((GLushort *) pIn)[iCount];
	else
	    iIn = (GLuint) ((GLuint *)   pIn)[iCount];

#if DRAWELEM_DEBUG
	DbgPrint("iCount %d ", iCount);
	DbgPrint("iIn %d ", iIn);
	DbgPrint("iMapNext %d iOutNext %d",
                 (GLuint) iMapNext, (GLuint) iOutNext);
#endif

// Look up previously mapped index if one exists.

	iMap = pHash[VA_HASH(iIn)];
	while (iMap != (GLushort) -1 && aMap[iMap].iIn != iIn)
	    iMap = aMap[iMap].next;

#if DRAWELEM_DEBUG
	DbgPrint("iMapFound %d\n", (GLuint) iMap);
#endif

// If aMap or aOut overflows, flush the partial primitive.

	if (iOutNext >= VA_DRAWELEM_INDEX_SIZE ||
            (iMap == (GLushort) -1 && iMapNext >= VA_DRAWELEM_MAP_SIZE))
        {
#if DRAWELEM_DEBUG
            DbgPrint("Flush iMapNext %d iOutNext %d\n",
                     (GLuint) iMapNext, (GLuint) iOutNext);
#endif

// We have accumulated enough vertices for a partial primitive.  We now
// need to figure out the exact number of vertices to flush and redo
// the leftover vertices in the next partial primitive.

#if DBG
            if (iOutNext >= VA_DRAWELEM_INDEX_SIZE)
                DbgPrint("DrawElements: aOut buffer overflows\n");
#endif

// Find the flush vertex of this partial primitive.

            nLeft = 0;
            switch (mode)
            {
            case GL_LINE_STRIP:
            case GL_TRIANGLE_FAN:
                break;
            case GL_POINTS:
            case GL_LINE_LOOP:
            case GL_POLYGON:
                ASSERTOPENGL(FALSE, "unexpected primitive type\n");
                break;
            case GL_LINES:
            case GL_TRIANGLE_STRIP:
            case GL_QUAD_STRIP:
                // number of vertices must be a multiple of 2
                if (iOutNext % 2)
                    nLeft++;
                break;
            case GL_TRIANGLES:
                // number of vertices must be a multiple of 3
                switch (iOutNext % 3)
                {
                case 2: nLeft++;        // fall through
                case 1: nLeft++;
                }
                break;
            case GL_QUADS:
                // number of vertices must be a multiple of 4
                switch (iOutNext % 4)
                {
                case 3: nLeft++;        // fall through
                case 2: nLeft++;        // fall through
                case 1: nLeft++;
                }
                break;
            }

// Add the leftover vertices back to the input array and redo them
// in the next partial primitive.

            iCount   -= nLeft;
            iOutNext -= (GLushort) nLeft;

            // When passing on our data, skip any vertices
            // that were reserved from a previous partial primitive
            (*pfnHandler)(gc, mode,
                          iMapNext-iPartialIndices, 0, aMap+iPartialIndices,
                          iOutNext, aOut, GL_TRUE);

            iPartialIndices = nReservedIndicesPartialBegin[mode];
                
// Continue to process remaining vertices.

            goto DrawElements_NextBatch;
        }

// If no previously mapped index is found, add the new vertex.

        if (iMap == (GLushort) -1)
        {
            ASSERTOPENGL(iMapNext < VA_DRAWELEM_MAP_SIZE,
                         "index map overflows!\n");

#if DRAWELEM_DEBUG
            DbgPrint("    Add iIn %d iMap %d iHash %d\n",
                     iIn, (GLuint) iMapNext, (GLuint) VA_HASH(iIn));
#endif

            iMap = iMapNext++;
            aMap[iMap].iIn  = iIn;
            aMap[iMap].next = pHash[VA_HASH(iIn)];
            pHash[VA_HASH(iIn)] = iMap;
        }

// Add the mapped index to output index array.

	ASSERTOPENGL(iMap < VA_DRAWELEM_MAP_SIZE, "bad mapped index\n");
	ASSERTOPENGL(iOutNext < VA_DRAWELEM_INDEX_SIZE,
                     "aOut array overflows!\n");

#if DRAWELEM_DEBUG
	DbgPrint("    Add iOutNext %d iMap %d\n",
                 (GLuint) iOutNext, (GLuint) iMap);
#endif
	aOut[iOutNext++] = (GLubyte) iMap;
    }

// We have processed all input vertices.
// Pass on any remaining data

    (*pfnHandler)(gc, mode,
                  iMapNext-iPartialIndices, 0, aMap+iPartialIndices,
                  iOutNext, aOut, GL_FALSE);
}

void FASTCALL glcltReducedElementsHandler(__GLcontext *gc,
                                          GLenum mode,
                                          GLsizei iVertexCount,
                                          GLsizei iVertexBase,
                                          VAMAP *pvmVertices,
                                          GLsizei iElementCount,
                                          GLubyte *pbElements,
                                          GLboolean fPartial)
{
    POLYARRAY *pa = gc->paTeb;
    PFNVAELEMENT pfn;
    GLsizei i;
    
    // Set up the vertex data
    pfn = gc->vertexArray.pfnArrayElement;
    if (pvmVertices != NULL)
    {
        PFNVAELEMENTBATCHINDIRECT pfn = gc->vertexArray.pfnArrayElementBatchIndirect;
        (*pfn)(gc, iVertexCount, pvmVertices);
    }
    else
    {
        // Access consecutive block of vertices, starting at iVertexBase
        PFNVAELEMENTBATCH pfn = gc->vertexArray.pfnArrayElementBatch;
        (*pfn)(gc, iVertexBase, iVertexCount);
    }
    
// Copy the index array to the end of the polyarray primitive.

    pa->nIndices = (GLuint) iElementCount;
    // skip terminator vertex
    pa->aIndices = (GLubyte *) (pa->pdNextVertex + 1);
    ASSERTOPENGL(pa->aIndices + pa->nIndices
                 <= (GLubyte *) (pa->pdBufferMax+1),
                 "Vertex buffer overflows!\n");
    memcpy(pa->aIndices, pbElements, pa->nIndices * sizeof(GLubyte));

    if (fPartial)
    {
    // Flush the partial primitive.

        VA_DrawElementsFlushPartialPrimitive(pa, mode);
    }
    else
    {
        VA_DrawElementsEnd(pa);
    }
}

// This handles primitive modes that DrawElements or DrawRangeElements don't.
void FASTCALL VA_DrawElementsHandleOtherPrimTypes( __GLcontext *gc,
                                                   GLenum mode,
                                                   GLsizei count,
                                                   GLenum type,
                                                   GLvoid *pIn )
{
    GLsizei      iCount;
    PFNVAELEMENT pfn;
    POLYARRAY    *pa;
    GLuint       iIn;

    pa = gc->paTeb;
    pfn = gc->vertexArray.pfnArrayElement;

    glcltBegin(mode);
    pa->flags |= POLYARRAY_SAME_POLYDATA_TYPE;

    for (iCount = 0; iCount < count; iCount++)
    {
        // Get next input index.
        if (type == GL_UNSIGNED_BYTE)
	        iIn = (GLuint) ((GLubyte *)  pIn)[iCount];
        else if (type == GL_UNSIGNED_SHORT)
	        iIn = (GLuint) ((GLushort *) pIn)[iCount];
        else
	        iIn = (GLuint) ((GLuint *)   pIn)[iCount];

        (*pfn)(gc, iIn);
    }

    glcltEnd();
}

void APIENTRY glcltDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *pIn)
{
    POLYARRAY    *pa;
    GLuint       iIn;
    GLsizei      iCount;

    __GL_SETUP();

    pa = gc->paTeb;

#define DRAWELEM_DEBUG 0
#if DRAWELEM_DEBUG
{
    DbgPrint("mode %d, count %d, type %d\n", mode, count, type);
    DbgPrint("pIn: ");
    for (iCount = 0; iCount < count; iCount++)
    {
	if (type == GL_UNSIGNED_BYTE)
	    iIn = (GLuint) ((GLubyte *)  pIn)[iCount];
	else if (type == GL_UNSIGNED_SHORT)
	    iIn = (GLuint) ((GLushort *) pIn)[iCount];
	else
	    iIn = (GLuint) ((GLuint *)   pIn)[iCount];

	DbgPrint("%d ", iIn);
    }
    DbgPrint("\n");
}
#endif

// If we are already in the begin/end bracket, return an error.

    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

    if ((GLuint) mode > GL_POLYGON)
    {
        GLSETERROR(GL_INVALID_ENUM);
	return;
    }

    if (count < 0)
    {
        GLSETERROR(GL_INVALID_VALUE);
        return;
    } else if (!count)
        return;

    switch (type)
    {
      case GL_UNSIGNED_BYTE:
      case GL_UNSIGNED_SHORT:
      case GL_UNSIGNED_INT:
	break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

// Find array element function to use.

    if (gc->vertexArray.flags & __GL_VERTEX_ARRAY_DIRTY)
        VA_ValidateArrayPointers(gc);

// Send Points, Line Loop, and Polygon to Begin/End call.  Points and Polygon
// don't benefit from optimization in this function.  Further, Polygon and
// Line Loop are too tricky to deal with in this function.

    if (mode == GL_POINTS || mode == GL_LINE_LOOP || mode == GL_POLYGON)
    {
        VA_DrawElementsHandleOtherPrimTypes( gc, mode, count, type, (GLvoid *) pIn );
	    return;
    }

// Begin primitive.

    VA_DrawElementsBegin(pa, mode, count);

    // The primitive will be ended on the last batch of
    // elements
    ReduceDrawElements(gc, mode, count, type, pIn,
                       glcltReducedElementsHandler);
}

void RebaseIndices( GLvoid *pIn, GLubyte *aOut, GLsizei count, GLuint start, 
                    GLenum type )
{
    if (type == GL_UNSIGNED_BYTE) {
        while( count-- )
            *aOut++ = (GLubyte) ( ((GLuint) *( ((GLubyte *) pIn) ++ )) - start);
    }
    else if (type == GL_UNSIGNED_SHORT) {
        while( count-- )
            *aOut++ = (GLubyte) ( ((GLuint) *( ((GLushort *) pIn) ++ )) - start);
    }
    else {
        while( count-- )
            *aOut++ = (GLubyte) ( ((GLuint) *( ((GLuint *) pIn) ++ )) - start);
    }
}

void APIENTRY glcltDrawRangeElementsWIN(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *pIn)
{
    POLYARRAY    *pa;
    GLuint       iVertexCount;
    GLubyte      aOut[VA_DRAWELEM_INDEX_SIZE];

    __GL_SETUP();

    pa = gc->paTeb;

// If we are already in the begin/end bracket, return an error.

    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

    if ((GLuint) mode > GL_POLYGON)
    {
        GLSETERROR(GL_INVALID_ENUM);
	return;
    }

    iVertexCount = end-start+1;
    if( (count < 0) || 
        (end < start) )
    {
        GLSETERROR(GL_INVALID_VALUE);
        return;
    }
    else if (!count)
    {
        return;
    }

    switch (type)
    {
      case GL_UNSIGNED_BYTE:
      case GL_UNSIGNED_SHORT:
      case GL_UNSIGNED_INT:
	break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    if (gc->vertexArray.flags & __GL_VERTEX_ARRAY_DIRTY)
	VA_ValidateArrayPointers(gc);

// Send Points, Line Loop, and Polygon to Begin/End call.  Points and Polygon
// don't benefit from optimization in this function.  Further, Polygon and
// Line Loop are too tricky to deal with in this function.

    if (mode == GL_POINTS || mode == GL_LINE_LOOP || mode == GL_POLYGON)
    {
        VA_DrawElementsHandleOtherPrimTypes( gc, mode, count, type, (GLvoid *) pIn );
	return;
    }

    // Begin primitive.

    VA_DrawElementsBegin(pa, mode, count);

    if ( (count > VA_DRAWRANGEELEM_MAX_INDICES) ||
         (iVertexCount > VA_DRAWRANGEELEM_MAX_VERTICES) )
    {
        // The primitive is too large to be processed directly so
        // we have to reduce it. The primitive will be ended on the
        // last batch of elements.
        ReduceDrawElements(gc, mode, count, type, pIn,
                           glcltReducedElementsHandler);
    }
    else
    {
        // Need to rebase (0-base) the indices and convert them to ubyte for
        // the reduced element handler.
        RebaseIndices( (GLvoid *) pIn, aOut, count, start, type );

        // Finish primitive
        glcltReducedElementsHandler(gc, mode, 
                                    iVertexCount,
                                    start, // iVertexBase
                                    NULL,
                                    count,
                                    aOut,
                                    GL_FALSE);
    }
}

// Interleaved array AND mask.
// INTERLEAVED_FORMAT_ASSERT
GLuint iaAndMask[14] =
{
// GL_V2F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_TEXCOORD_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK |
    VAMASK_COLOR_TYPE_SIZE_MASK |
    VAMASK_NORMAL_TYPE_SIZE_MASK,
// GL_V3F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_TEXCOORD_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK |
    VAMASK_COLOR_TYPE_SIZE_MASK |
    VAMASK_NORMAL_TYPE_SIZE_MASK,
// GL_C4UB_V2F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_TEXCOORD_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK |
    VAMASK_NORMAL_TYPE_SIZE_MASK,
// GL_C4UB_V3F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_TEXCOORD_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK |
    VAMASK_NORMAL_TYPE_SIZE_MASK,
// GL_C3F_V3F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_TEXCOORD_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK |
    VAMASK_NORMAL_TYPE_SIZE_MASK,
// GL_N3F_V3F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_TEXCOORD_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK |
    VAMASK_COLOR_TYPE_SIZE_MASK,
// GL_C4F_N3F_V3F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_TEXCOORD_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK,
// GL_T2F_V3F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK |
    VAMASK_COLOR_TYPE_SIZE_MASK |
    VAMASK_NORMAL_TYPE_SIZE_MASK,
// GL_T4F_V4F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK |
    VAMASK_COLOR_TYPE_SIZE_MASK |
    VAMASK_NORMAL_TYPE_SIZE_MASK,
// GL_T2F_C4UB_V3F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK |
    VAMASK_NORMAL_TYPE_SIZE_MASK,
// GL_T2F_C3F_V3F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK |
    VAMASK_NORMAL_TYPE_SIZE_MASK,
// GL_T2F_N3F_V3F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK |
    VAMASK_COLOR_TYPE_SIZE_MASK,
// GL_T2F_C4F_N3F_V3F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK,
// GL_T4F_C4F_N3F_V4F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK,
};

// Interleaved array OR mask.
// INTERLEAVED_FORMAT_ASSERT
GLuint iaOrMask[14] =
{
    VAMASK_FORMAT_V2F,             // GL_V2F
    VAMASK_FORMAT_V3F,             // GL_V3F
    VAMASK_FORMAT_C4UB_V2F,        // GL_C4UB_V2F
    VAMASK_FORMAT_C4UB_V3F,        // GL_C4UB_V3F
    VAMASK_FORMAT_C3F_V3F,         // GL_C3F_V3F
    VAMASK_FORMAT_N3F_V3F,         // GL_N3F_V3F
    VAMASK_FORMAT_C4F_N3F_V3F,     // GL_C4F_N3F_V3F
    VAMASK_FORMAT_T2F_V3F,         // GL_T2F_V3F
    VAMASK_FORMAT_T4F_V4F,         // GL_T4F_V4F
    VAMASK_FORMAT_T2F_C4UB_V3F,    // GL_T2F_C4UB_V3F
    VAMASK_FORMAT_T2F_C3F_V3F,     // GL_T2F_C3F_V3F
    VAMASK_FORMAT_T2F_N3F_V3F,     // GL_T2F_N3F_V3F
    VAMASK_FORMAT_T2F_C4F_N3F_V3F, // GL_T2F_C4F_N3F_V3F
    VAMASK_FORMAT_T4F_C4F_N3F_V4F, // GL_T4F_C4F_N3F_V4F
};

// Interleaved array default strides.
GLuint iaStride[14] =
{
     2 * sizeof(GLfloat),                       // GL_V2F
     3 * sizeof(GLfloat),                       // GL_V3F
     2 * sizeof(GLfloat) + 4 * sizeof(GLubyte), // GL_C4UB_V2F
     3 * sizeof(GLfloat) + 4 * sizeof(GLubyte), // GL_C4UB_V3F
     6 * sizeof(GLfloat),                       // GL_C3F_V3F
     6 * sizeof(GLfloat),                       // GL_N3F_V3F
    10 * sizeof(GLfloat),                       // GL_C4F_N3F_V3F
     5 * sizeof(GLfloat),                       // GL_T2F_V3F
     8 * sizeof(GLfloat),                       // GL_T4F_V4F
     5 * sizeof(GLfloat) + 4 * sizeof(GLubyte), // GL_T2F_C4UB_V3F
     8 * sizeof(GLfloat),                       // GL_T2F_C3F_V3F
     8 * sizeof(GLfloat),                       // GL_T2F_N3F_V3F
    12 * sizeof(GLfloat),                       // GL_T2F_C4F_N3F_V3F
    15 * sizeof(GLfloat),                       // GL_T4F_C4F_N3F_V4F
};

void APIENTRY glcltInterleavedArrays (GLenum format, GLsizei stride, const GLvoid *pointer)
{
    GLuint iFormat, iStride;
    GLuint vaMask;
    const GLbyte *pb = pointer;
    __GL_SETUP();

// Not allowed in begin/end.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

    // INTERLEAVED_FORMAT_ASSERT
    iFormat = (GLuint) (format - GL_V2F);
    if (iFormat > GL_T4F_C4F_N3F_V4F)
    {
	GLSETERROR(GL_INVALID_ENUM);
	return;
    }

    if (stride < 0)
    {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    }

    if (stride)
	iStride = stride;
    else
	iStride = iaStride[iFormat];

// Compute new mask.
// If we are disabling an array, don't modify its type and size field!

    vaMask  = gc->vertexArray.mask;
    vaMask &= iaAndMask[iFormat];
    vaMask |= iaOrMask[iFormat];

    if (gc->vertexArray.mask != vaMask)
    {
	gc->vertexArray.mask  = vaMask;
	gc->vertexArray.flags |= __GL_VERTEX_ARRAY_DIRTY;
    }

    if (vaMask & VAMASK_TEXCOORD_ENABLE_MASK)
    {
	gc->vertexArray.texCoord.type    = GL_FLOAT;
	gc->vertexArray.texCoord.stride  = iStride;
	gc->vertexArray.texCoord.ibytes  = iStride;
	gc->vertexArray.texCoord.pointer = pb;
	if ((vaMask & VAMASK_TEXCOORD_TYPE_SIZE_MASK) ==
	      (VAMASK_TEXCOORD_SIZE_4 | VAMASK_TEXCOORD_TYPE_FLOAT))
	{
	    gc->vertexArray.texCoord.size = 4;
	    pb += 4 * sizeof(GLfloat);
	}
	else
	{
	    ASSERTOPENGL((vaMask & VAMASK_TEXCOORD_TYPE_SIZE_MASK) ==
	        (VAMASK_TEXCOORD_SIZE_2 | VAMASK_TEXCOORD_TYPE_FLOAT),
	        "unhandled texcoord format\n");
	    gc->vertexArray.texCoord.size = 2;
	    pb += 2 * sizeof(GLfloat);
	}
    }

    if (vaMask & VAMASK_COLOR_ENABLE_MASK)
    {
	gc->vertexArray.color.stride  = iStride;
	gc->vertexArray.color.ibytes  = iStride;
	gc->vertexArray.color.pointer = pb;

	switch (vaMask & VAMASK_COLOR_TYPE_SIZE_MASK)
	{
          case VAMASK_COLOR_TYPE_UBYTE | VAMASK_COLOR_SIZE_4:
	    gc->vertexArray.color.type = GL_UNSIGNED_BYTE;
	    gc->vertexArray.color.size = 4;
	    pb += 4 * sizeof(GLubyte);
	    break;
          case VAMASK_COLOR_TYPE_FLOAT | VAMASK_COLOR_SIZE_3:
	    gc->vertexArray.color.type = GL_FLOAT;
	    gc->vertexArray.color.size = 3;
	    pb += 3 * sizeof(GLfloat);
	    break;
          case VAMASK_COLOR_TYPE_FLOAT | VAMASK_COLOR_SIZE_4:
	    gc->vertexArray.color.type = GL_FLOAT;
	    gc->vertexArray.color.size = 4;
	    pb += 4 * sizeof(GLfloat);
	    break;
          default:
	    ASSERTOPENGL(FALSE, "unhandled color format\n");
	    break;
	}
    }

    if (vaMask & VAMASK_NORMAL_ENABLE_MASK)
    {
	gc->vertexArray.normal.type    = GL_FLOAT;
	gc->vertexArray.normal.stride  = iStride;
	gc->vertexArray.normal.ibytes  = iStride;
	gc->vertexArray.normal.pointer = pb;
	pb += 3 * sizeof(GLfloat);
    }

    gc->vertexArray.vertex.type    = GL_FLOAT;
    gc->vertexArray.vertex.stride  = iStride;
    gc->vertexArray.vertex.ibytes  = iStride;
    gc->vertexArray.vertex.pointer = pb;
    switch (vaMask & VAMASK_VERTEX_TYPE_SIZE_MASK)
    {
      case VAMASK_VERTEX_TYPE_FLOAT | VAMASK_VERTEX_SIZE_4:
	gc->vertexArray.vertex.size = 4;
	break;
      case VAMASK_VERTEX_TYPE_FLOAT | VAMASK_VERTEX_SIZE_3:
	gc->vertexArray.vertex.size = 3;
	break;
      case VAMASK_VERTEX_TYPE_FLOAT | VAMASK_VERTEX_SIZE_2:
	gc->vertexArray.vertex.size = 2;
	break;
      default:
	ASSERTOPENGL(FALSE, "unhandled vertex format\n");
	break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\wave.c ===
/****************************************************************************
    wave.c

    Level 1 kitchen sink DLL wave support module

    Copyright (c) 1990-2001 Microsoft Corporation

    Changes for NT :
        Change parameters for MapWaveId to return the driver index rather
        than a pointer

        change list of include files

        widen function parameters and return codes

        Change WINAPI to APIENTRY
****************************************************************************/

#include "winmmi.h"

/****************************************************************************

    local structures

****************************************************************************/

typedef struct wavedev_tag {
    PWAVEDRV    wavedrv;
    UINT        wDevice;
    DWORD_PTR   dwDrvUser;
    UINT        uDeviceID;
    DWORD       fdwHandle;
} WAVEDEV, *PWAVEDEV;

extern UINT gRealWaveOutPreferredId;
extern UINT gRealWaveInPreferredId;
extern BOOL WaveMapperInitialized; // Wave mapper safely loaded

/*****************************************************************************
 * @doc INTERNAL  WAVE validation code for WAVEHDRs
 *
 ****************************************************************************/

#define IsWaveHeaderPrepared(hWave, lpwh)      ((lpwh)->dwFlags &  WHDR_PREPARED)
#define MarkWaveHeaderPrepared(hWave, lpwh)    ((lpwh)->dwFlags |= WHDR_PREPARED)
#define MarkWaveHeaderUnprepared(hWave, lpwh)  ((lpwh)->dwFlags &=~WHDR_PREPARED)

/*****************************************************************************
 * @doc INTERNAL  WAVE
 *
 * @api MMRESULT | wavePrepareHeader | This function prepares the header and data
 *   if the driver returns MMSYSERR_NOTSUPPORTED.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it
 *   specifies an error number.
 ****************************************************************************/
STATIC MMRESULT wavePrepareHeader(LPWAVEHDR lpWaveHdr, UINT wSize)
{
    if (!HugePageLock(lpWaveHdr, (DWORD)sizeof(WAVEHDR)))
        return MMSYSERR_NOMEM;

    if (!HugePageLock(lpWaveHdr->lpData, lpWaveHdr->dwBufferLength)) {
        HugePageUnlock(lpWaveHdr, (DWORD)sizeof(WAVEHDR));
        return MMSYSERR_NOMEM;
    }

    lpWaveHdr->dwFlags |= WHDR_PREPARED;

    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc INTERNAL  WAVE
 *
 * @api MMRESULT | waveUnprepareHeader | This function unprepares the header and
 *   data if the driver returns MMSYSERR_NOTSUPPORTED.
 *
 * @rdesc Currently always returns MMSYSERR_NOERROR.
 ****************************************************************************/
STATIC MMRESULT waveUnprepareHeader(LPWAVEHDR lpWaveHdr, UINT wSize)
{
    HugePageUnlock(lpWaveHdr->lpData, lpWaveHdr->dwBufferLength);
    HugePageUnlock(lpWaveHdr, (DWORD)sizeof(WAVEHDR));

    lpWaveHdr->dwFlags &= ~WHDR_PREPARED;

    return MMSYSERR_NOERROR;
}

/****************************************************************************
 * @doc INTERNAL  WAVE
 *
 * @api MMRESULT | waveReferenceDriverById | This function maps a logical id
 *   to a device driver and physical id.
 *
 * @parm IN PWAVEDRV | pwavedrvZ | The list of wave drivers.
 *
 * @parm IN UINT | id | The logical id to be mapped.
 *
 * @parm OUT PWAVEDRV* OPTIONAL | ppwavedrv | Pointer to WAVEDRV structure
 *    describing the driver supporting the id.
 *
 * @parm OUT UINT* OPTIONAL | pport | The driver-relative device number. If
 *    the caller supplies this buffer then it must also supply ppwavedrv.
 *
 * @rdesc The return value is zero if successful, MMSYSERR_BADDEVICEID if
 *   the id is out of range.
 *
 * @comm If the caller specifies ppwavedrv then this function increments
 *       the wavedrv's usage before returning.  The caller must ensure
 *       the usage is eventually decremented.
 *
 ****************************************************************************/
MMRESULT waveReferenceDriverById(
    IN PWAVEDRV pwavedrvZ,
    IN UINT id,
    OUT PWAVEDRV *ppwavedrv OPTIONAL,
    OUT UINT *pport OPTIONAL
)
{
    PWAVEDRV pwavedrv;
    MMRESULT mmr;

    // Should not be called asking for port but not wavedrv
    WinAssert(!(pport && !ppwavedrv));
    
    if (id == WAVE_MAPPER) {
        /*
        **  Make sure we've tried to load it
        */
        WaveMapperInit();
        // WinAssert(((WaveMapperInitialized) || (0 == wTotalWaveInDevs + wTotalWaveOutDevs)));
    }

    EnterNumDevs("waveReferenceDriverById");

    if (WAVE_MAPPER == id)
    {
        id = 0;
    	for (pwavedrv = pwavedrvZ->Next; pwavedrv != pwavedrvZ; pwavedrv = pwavedrv->Next)
    	{
	    if (pwavedrv->fdwDriver & MMDRV_MAPPER) break;
	}
    } else {
    	for (pwavedrv = pwavedrvZ->Next; pwavedrv != pwavedrvZ; pwavedrv = pwavedrv->Next)
	{
	    if (pwavedrv->fdwDriver & MMDRV_MAPPER) continue;
	    if (pwavedrv->NumDevs > id) break;
	    id -= pwavedrv->NumDevs;
	}
    }

    if (pwavedrv != pwavedrvZ)
    {
    	if (ppwavedrv) {
    	    mregIncUsagePtr(pwavedrv);
    	    *ppwavedrv = pwavedrv;
    	    if (pport) *pport = id;
    	}
    	mmr = MMSYSERR_NOERROR;
    } else {
    	mmr = MMSYSERR_BADDEVICEID;
    }

    LeaveNumDevs("waveReferenceDriverById");

    return mmr;
}

PCWSTR waveReferenceDevInterfaceById(PWAVEDRV pdrvZ, UINT_PTR id)
{

    PWAVEDRV pdrv;
    PCWSTR DevInterface;
    
    if ((pdrvZ == &waveoutdrvZ && ValidateHandle((HANDLE)id, TYPE_WAVEOUT)) ||
        (pdrvZ == &waveindrvZ  && ValidateHandle((HANDLE)id, TYPE_WAVEIN)))
    {
    	DevInterface = ((PWAVEDEV)id)->wavedrv->cookie;
    	if (DevInterface) wdmDevInterfaceInc(DevInterface);
    	return DevInterface;
    }

    if (!waveReferenceDriverById(pdrvZ, (UINT)id, &pdrv, NULL))
    {
    	DevInterface = pdrv->cookie;
    	if (DevInterface) wdmDevInterfaceInc(DevInterface);
    	mregDecUsagePtr(pdrv);
    	return DevInterface;
    }

    return NULL;
}

/*****************************************************************************
 * @doc INTERNAL  WAVE
 *
 * @func MMRESULT | waveMessage | This function sends messages to the waveform
 *   output device drivers.
 *
 * @parm HWAVE | hWave | The handle to the audio device.
 *
 * @parm UINT | wMsg | The message to send.
 *
 * @parm DWORD | dwP1 | Parameter 1.
 *
 * @parm DWORD | dwP2 | Parameter 2.
 *
 * @rdesc Returns the value returned from the driver.
 ****************************************************************************/
STATIC MMRESULT waveMessage(HWAVE hWave, UINT msg, DWORD_PTR dwP1, DWORD_PTR dwP2)
{
    MMRESULT mrc;

    ENTER_MM_HANDLE(hWave);       // Serialize on handle
    
    ReleaseHandleListResource();
    
    //  Is handle deserted?
    if (IsHandleDeserted(hWave))
    {
        LEAVE_MM_HANDLE(hWave);
        return (MMSYSERR_NODRIVER);
    }
    
    //  Are we busy (in the middle of an open/close)?
    if (IsHandleBusy(hWave))
    {
        LEAVE_MM_HANDLE(hWave);
        return (MMSYSERR_HANDLEBUSY);
    }

    //  ISSUE:  We should no longer have to check for invalid handle... every
    //  function that calls this check with with a read lock on the handle
    //  resource.
    if (BAD_HANDLE(hWave, TYPE_WAVEOUT) && BAD_HANDLE(hWave, TYPE_WAVEIN)) {
	    WinAssert(!"Bad Handle within waveMessage");
        mrc = MMSYSERR_INVALHANDLE;
    } else {
        mrc = (MMRESULT)(*(((PWAVEDEV)hWave)->wavedrv->drvMessage))
            (((PWAVEDEV)hWave)->wDevice, msg, ((PWAVEDEV)hWave)->dwDrvUser, dwP1, dwP2);
    }

    LEAVE_MM_HANDLE(hWave);

    return mrc;
}

/****************************************************************************
 * @doc INTERNAL  WAVE
 *
 * @func MMRESULT | waveIDMessage | This function sends a message to the device
 * ID specified.  It also performs error checking on the ID passed.
 *
 * @parm PWAVEDRV | wavedrv | Pointer to the input or output device list.
 *
 * @parm UINT | wTotalNumDevs | Total number of devices in device list.
 *
 * @parm UINT | uDeviceID | Device ID to send message to.
 *
 * @parm UINT | wMessage | The message to send.
 *
 * @parm DWORD | dwParam1 | Parameter 1.
 *
 * @parm DWORD | dwParam2 | Parameter 2.
 *
 * @rdesc The return value is the low word of the returned message.
 ***************************************************************************/
// ISSUE-2001/01/09-FrankYe This should take UINT_PTR uDeviceID if we expect
//    it to accept handles.  If we change it, then review all calls to this
//    function.
STATIC  MMRESULT waveIDMessage(
    PWAVEDRV    pwavedrvZ,
    UINT        wTotalNumDevs,
    UINT_PTR    uDeviceID,
    UINT        wMessage,
    DWORD_PTR   dwParam1,
    DWORD_PTR   dwParam2)
{
    DWORD     mmr;
    DWORD     dwClass;
    UINT      port;
    PWAVEDRV  wavedrv;

    if (uDeviceID>=wTotalNumDevs && uDeviceID!=WAVE_MAPPER) {
        // this cannot be a device ID.
        // it could be a wave handle.  Try it.
        // First we have to verify which type of handle it is (OUT or IN)
        // We can work this out as waveIDMessage is only ever called with
        // pwavedrvZ == &waveoutdrvZ or &waveindrvZ

        if ((pwavedrvZ == &waveoutdrvZ && ValidateHandle((HANDLE)uDeviceID, TYPE_WAVEOUT))
         || (pwavedrvZ == &waveindrvZ && ValidateHandle((HANDLE)uDeviceID, TYPE_WAVEIN) ))
        {

            if (0 != (((PWAVEDEV)uDeviceID)->wavedrv->fdwDriver & MMDRV_DESERTED))
            {
                //  The driver has been deserted, all calls should return
                //  MMSYSERR_NODRIVER.
	        return MMSYSERR_NODRIVER;
            }

            dprintf2(("waveIDMessage passed ID==%x, translating to handle", uDeviceID));
            // to preserve as much compatibility with previous code paths
            // we do NOT call waveMessage as that calls ENTER_MM_HANDLE

            return (MMRESULT)(*(((PWAVEDEV)uDeviceID)->wavedrv->drvMessage))
                             (((PWAVEDEV)uDeviceID)->wDevice,
                             wMessage,
                            ((PWAVEDEV)uDeviceID)->dwDrvUser, dwParam1, dwParam2);
        } else {
            return(MMSYSERR_BADDEVICEID);
        }
    }

    mmr = waveReferenceDriverById(pwavedrvZ, (UINT)uDeviceID, &wavedrv, &port);
    if (mmr)
    {
    	return mmr;
    }
    
    if (pwavedrvZ == &waveindrvZ)
       dwClass = TYPE_WAVEIN;
    else if (pwavedrvZ == &waveoutdrvZ)
       dwClass = TYPE_WAVEOUT;
    else
       dwClass = TYPE_UNKNOWN;

    if (!wavedrv->drvMessage)
    {
    	mmr = MMSYSERR_NODRIVER;
    }
    else if (!mregHandleInternalMessages(wavedrv, dwClass, port, wMessage, dwParam1, dwParam2, &mmr))
    {
    	mmr = (MMRESULT)((*(wavedrv->drvMessage))(port, wMessage, 0L, dwParam1, dwParam2));
    }

    mregDecUsagePtr(wavedrv);
    return mmr;
    	
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutGetNumDevs | This function retrieves the number of
 *   waveform output devices present in the system.
 *
 * @rdesc Returns the number of waveform output devices present in the system.
 *
 * @xref waveOutGetDevCaps
 ****************************************************************************/
UINT APIENTRY waveOutGetNumDevs(void)
{
    UINT    cDevs;

    ClientUpdatePnpInfo();

    if (WinmmRunningInServer)
    {
        if (0 == wTotalWaveOutDevs)
        {
            Squirt("Returning 1 for CSRSS process.");

            return 1;
        }

        return wTotalWaveOutDevs;
    }

    EnterNumDevs("waveOutGetNumDevs");
    cDevs = wTotalWaveOutDevs;
    LeaveNumDevs("waveOutGetNumDevs");

    dprintf3(("waveOutGetNumDevs returning %d devices", wTotalWaveOutDevs));

    return cDevs;
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api MMRESULT | waveOutMessage | This function sends messages to the waveform
 *   output device drivers.
 *
 * @parm HWAVEOUT | hWaveOut | The handle to the audio device.
 *
 * @parm UINT | msg  | The message to send.
 *
 * @parm DWORD | dw1 | Parameter 1.
 *
 * @parm DWORD | dw2 | Parameter 2.
 *
 * @rdesc Returns the value returned from the driver.
 ****************************************************************************/
MMRESULT APIENTRY waveOutMessage(HWAVEOUT hWaveOut, UINT msg, DWORD_PTR dw1, DWORD_PTR dw2)
{
    ClientUpdatePnpInfo();

    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE((HWAVE)hWaveOut, TYPE_WAVEOUT))
    {
        ReleaseHandleListResource();
        return waveIDMessage(&waveoutdrvZ, wTotalWaveOutDevs, (UINT)(UINT_PTR)hWaveOut, msg, dw1, dw2);
    }
    else
    {
        return waveMessage((HWAVE)hWaveOut, msg, dw1, dw2);
    }
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveOutGetDevCaps | This function queries a specified waveform
 *   device to determine its capabilities.
 *
 * @parm UINT | uDeviceID | Identifies the waveform output device.
 *
 * @parm LPWAVEOUTCAPS | lpCaps | Specifies a far pointer to a <t WAVEOUTCAPS>
 *   structure.  This structure is filled with information about the
 *   capabilities of the device.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEOUTCAPS> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Use <f waveOutGetNumDevs> to determine the number of waveform output
 *   devices present in the system.  The device ID specified by <p uDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The WAVE_MAPPER constant may also be used as a device id. Only
 *   <p wSize> bytes (or less) of information is copied to the location
 *   pointed to by <p lpCaps>.  If <p wSize> is zero, nothing is copied, and
 *   the function returns zero.
 *
 * @xref waveOutGetNumDevs
 ****************************************************************************/
MMRESULT APIENTRY waveOutGetDevCapsW(UINT_PTR uDeviceID, LPWAVEOUTCAPSW lpCaps, UINT wSize)
{
    DWORD_PTR       dwParam1, dwParam2;
    MDEVICECAPSEX   mdCaps;
    PWAVEDRV        waveoutdrv;
    PCWSTR          DevInterface;
    MMRESULT        mmr;

    if (wSize == 0)
        return MMSYSERR_NOERROR;

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    // Because some 32-bit applications use the value 0x0000FFFF for
    // WAVE_MAPPER instead of 0xFFFFFFFF, we clamp up to the correct value.
    // This just happened to work on Win9x because WinMM would thunk down
    // to MMSystem and send down the lower word to the 16-bit interface.
    if (uDeviceID == LOWORD(WAVE_MAPPER)) {
        uDeviceID = WAVE_MAPPER;
    }

    ClientUpdatePnpInfo();

    DevInterface = waveReferenceDevInterfaceById(&waveoutdrvZ, uDeviceID);
    dwParam2 = (DWORD_PTR)DevInterface;

    if (0 == dwParam2)
    {
        dwParam1 = (DWORD_PTR)lpCaps;
        dwParam2 = (DWORD)wSize;
    }
    else
    {
        mdCaps.cbSize = (DWORD)wSize;
        mdCaps.pCaps  = lpCaps;
        dwParam1      = (DWORD_PTR)&mdCaps;
    }

    //
    //  Don't allow non proper drivers in TS environement
    //
    // ISSUE-2001/01/09-FrankYe Instead of cast to UINT.  Should check whether
    //    this is a handle and get wavedrv from handle if it is.
    waveoutdrv = NULL;
    if ((!waveReferenceDriverById(&waveoutdrvZ, (UINT)uDeviceID, &waveoutdrv, NULL)) &&
    	lstrcmpW(waveoutdrv->wszSessProtocol, SessionProtocolName))
    {
        mmr = MMSYSERR_NODRIVER;
    }
    else
    {
        AcquireHandleListResourceShared();

        if (BAD_HANDLE((HWAVE)uDeviceID, TYPE_WAVEOUT))
        {
    	    int cRecursion;

            ReleaseHandleListResource();
            
            // Unless it's the mapper, increment the recursion depth counter.  Then,
            // check whether this thread is now recursing through waveOutGetDevCaps.  If it
            // is, then disable preferred device reordering.
            cRecursion = PtrToInt(TlsGetValue(gTlsIndex));
            if ((uDeviceID != WAVE_MAPPER) && (waveoutdrv) && (waveoutdrv->fdwDriver & MMDRV_PREXP)) TlsSetValue(gTlsIndex, IntToPtr(cRecursion + 1));
            if (cRecursion) gfDisablePreferredDeviceReordering = TRUE;
    	
    	    mmr = waveIDMessage(&waveoutdrvZ, wTotalWaveOutDevs, (UINT)uDeviceID, WODM_GETDEVCAPS, dwParam1, dwParam2);
    	    
            // Restore recursion counter
            TlsSetValue(gTlsIndex, IntToPtr(cRecursion));
        }
        else
        {
    	    mmr = (MMRESULT)waveMessage((HWAVE)uDeviceID, WODM_GETDEVCAPS, dwParam1, dwParam2);
        }

    }

    if (waveoutdrv) mregDecUsagePtr(waveoutdrv);
    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    return mmr;
    
}

MMRESULT APIENTRY waveOutGetDevCapsA(UINT_PTR uDeviceID, LPWAVEOUTCAPSA lpCaps, UINT wSize)
{
    WAVEOUTCAPS2W   wDevCaps2;
    WAVEOUTCAPS2A   aDevCaps2;
    DWORD_PTR       dwParam1, dwParam2;
    MDEVICECAPSEX   mdCaps;
    MMRESULT        mmRes;
    PWAVEDRV        waveoutdrv;
    PCWSTR          DevInterface;

    if (wSize == 0)
        return MMSYSERR_NOERROR;

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    // Because some 32-bit applications use the value 0x0000FFFF for
    // WAVE_MAPPER instead of 0xFFFFFFFF, we clamp up to the correct value.
    // This just happened to work on Win9x because WinMM would thunk down
    // to MMSystem and send down the lower word to the 16-bit interface.
    if (uDeviceID == LOWORD(WAVE_MAPPER)) {
        uDeviceID = WAVE_MAPPER;
    }

    ClientUpdatePnpInfo();

    DevInterface = waveReferenceDevInterfaceById(&waveoutdrvZ, uDeviceID);
    dwParam2 = (DWORD_PTR)DevInterface;

    memset(&wDevCaps2, 0, sizeof(wDevCaps2));

    if (0 == dwParam2)
    {
        dwParam1 = (DWORD_PTR)&wDevCaps2;
        dwParam2 = (DWORD)sizeof(wDevCaps2);
    }
    else
    {
        mdCaps.cbSize = (DWORD)sizeof(wDevCaps2);
        mdCaps.pCaps  = &wDevCaps2;
        dwParam1      = (DWORD_PTR)&mdCaps;
    }

    //
    //  Don't allow non proper drivers in TS environement
    //
    // ISSUE-2001/01/09-FrankYe Bad cast to UINT.  Should check whether this
    //    is a handle and get wavedrv from handle if it is.
    waveoutdrv = NULL;
    if ( uDeviceID < wTotalWaveOutDevs &&
         !waveReferenceDriverById(&waveoutdrvZ, (UINT)uDeviceID, &waveoutdrv, NULL) &&
    	 lstrcmpW(waveoutdrv->wszSessProtocol, SessionProtocolName) )
    {
    	mregDecUsagePtr(waveoutdrv);
    	if (DevInterface) wdmDevInterfaceDec(DevInterface);
    	return MMSYSERR_NODRIVER;
    }
    
    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE((HWAVE)uDeviceID, TYPE_WAVEOUT))
    {
        ReleaseHandleListResource();
        mmRes = waveIDMessage(&waveoutdrvZ, wTotalWaveOutDevs, (UINT)uDeviceID,
        	              WODM_GETDEVCAPS, dwParam1, dwParam2);
    }
    else
    {
        mmRes = waveMessage((HWAVE)uDeviceID,
        	            WODM_GETDEVCAPS,
        	            dwParam1,
        	            dwParam2);
    }

    if (waveoutdrv) mregDecUsagePtr(waveoutdrv);
    if (DevInterface) wdmDevInterfaceDec(DevInterface);

    //
    // Make sure the call worked before proceeding with the thunk.
    //
    if ( mmRes != MMSYSERR_NOERROR ) {
        return  mmRes;
    }

    aDevCaps2.wMid             = wDevCaps2.wMid;
    aDevCaps2.wPid             = wDevCaps2.wPid;
    aDevCaps2.vDriverVersion   = wDevCaps2.vDriverVersion;
    aDevCaps2.dwFormats        = wDevCaps2.dwFormats;
    aDevCaps2.wChannels        = wDevCaps2.wChannels;
    aDevCaps2.dwSupport        = wDevCaps2.dwSupport;
    aDevCaps2.ManufacturerGuid = wDevCaps2.ManufacturerGuid;
    aDevCaps2.ProductGuid      = wDevCaps2.ProductGuid;
    aDevCaps2.NameGuid         = wDevCaps2.NameGuid;

    // copy and convert lpwText to lpText here.
    Iwcstombs(aDevCaps2.szPname, wDevCaps2.szPname, MAXPNAMELEN);

    //
    // now copy the required amount into the callers buffer.
    //
    CopyMemory( lpCaps, &aDevCaps2, min(wSize, sizeof(aDevCaps2)));

    return mmRes;
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api MMRESULT | waveOutGetVolume | This function queries the current volume
 *   setting of a waveform output device.
 *
 * @parm UINT | uDeviceID | Identifies the waveform output device.
 *
 * @parm LPDWORD | lpdwVolume | Specifies a far pointer to a location to
 *   be filled with the current volume setting.  The low-order word of
 *   this location contains the left channel volume setting, and the high-order
 *   word contains the right channel setting. A value of 0xFFFF represents
 *   full volume, and a value of 0x0000 is silence.
 *
 *   If a device does not support both left and right volume
 *   control, the low-order word of the specified location contains
 *   the mono volume level.
 *
 *   The full 16-bit setting(s)
 *   set with <f waveOutSetVolume> is returned, regardless of whether
 *   the device supports the full 16 bits of volume-level control.
 *
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Not all devices support volume changes. To determine whether the
 *   device supports volume control, use the WAVECAPS_VOLUME
 *   flag to test the <e WAVEOUTCAPS.dwSupport> field of the <t WAVEOUTCAPS>
 *   structure (filled by <f waveOutGetDevCaps>).
 *
 *   To determine whether the device supports volume control on both
 *   the left and right channels, use the WAVECAPS_VOLUME
 *   flag to test the <e WAVEOUTCAPS.dwSupport> field of the <t WAVEOUTCAPS>
 *   structure (filled by <f waveOutGetDevCaps>).
 *
 * @xref waveOutSetVolume
 ****************************************************************************/
MMRESULT APIENTRY waveOutGetVolume(HWAVEOUT hwo, LPDWORD lpdwVolume)
{
    PCWSTR      DevInterface;
    MMRESULT    mmr;

    V_WPOINTER(lpdwVolume, sizeof(DWORD), MMSYSERR_INVALPARAM);

    // Because some 32-bit applications use the value 0x0000FFFF for
    // WAVE_MAPPER instead of 0xFFFFFFFF, we clamp up to the correct value.
    // This just happened to work on Win9x because WinMM would thunk down
    // to MMSystem and send down the lower word to the 16-bit interface.
    if ((UINT_PTR)hwo == LOWORD(WAVE_MAPPER)) {
        (UINT_PTR)hwo = WAVE_MAPPER;
    }

    ClientUpdatePnpInfo();

    DevInterface = waveReferenceDevInterfaceById(&waveoutdrvZ, (UINT_PTR)hwo);

    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE(hwo, TYPE_WAVEOUT))
    {
        ReleaseHandleListResource();
    	mmr = waveIDMessage(&waveoutdrvZ, wTotalWaveOutDevs, PtrToUint(hwo), WODM_GETVOLUME, (DWORD_PTR)lpdwVolume, (DWORD_PTR)DevInterface);
    }
    else
    {
    	mmr = (MMRESULT)waveMessage((HWAVE)hwo, WODM_GETVOLUME, (DWORD_PTR)lpdwVolume, (DWORD_PTR)DevInterface);
    }

    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    return mmr;
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api MMRESULT | waveOutSetVolume | This function sets the volume of a
 *   waveform output device.
 *
 * @parm UINT | uDeviceID | Identifies the waveform output device.
 *
 * @parm DWORD | dwVolume | Specifies the new volume setting.  The
 *   low-order word contains the left channel volume setting, and the
 *   high-order word contains the right channel setting. A value of
 *   0xFFFF represents full volume, and a value of 0x0000 is silence.
 *
 *   If a device does
 *   not support both left and right volume control, the low-order word of
 *   <p dwVolume> specifies the volume level, and the high-order word is
 *   ignored.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Not all devices support volume changes. To determine whether the
 *   device supports volume control, use the WAVECAPS_VOLUME
 *   flag to test the <e WAVEOUTCAPS.dwSupport> field of the <t WAVEOUTCAPS>
 *   structure (filled by <f waveOutGetDevCaps>).
 *
 *   To determine whether the device supports volume control on both the
 *   left and right channels, use the WAVECAPS_LRVOLUME flag
 *   flag to test the <e WAVEOUTCAPS.dwSupport> field of the <t WAVEOUTCAPS>
 *   structure (filled by <f waveOutGetDevCaps>).
 *
 *   Most devices don't support the full 16 bits of volume level control
 *   and will not use the high-order bits of the requested volume setting.
 *   For example, for a device that supports 4 bits of volume control,
 *   requested volume level values of 0x4000, 0x4fff, and 0x43be
 *   all produce the same physical volume setting, 0x4000. The
 *   <f waveOutGetVolume> function returns the full 16-bit setting set
 *   with <f waveOutSetVolume>.
 *
 *   Volume settings are interpreted logarithmically. This means the
 *   perceived increase in volume is the same when increasing the
 *   volume level from 0x5000 to 0x6000 as it is from 0x4000 to 0x5000.
 *
 * @xref waveOutGetVolume
 ****************************************************************************/
MMRESULT APIENTRY waveOutSetVolume(HWAVEOUT hwo, DWORD dwVolume)
{
    PCWSTR   DevInterface;
    MMRESULT mmr;

    ClientUpdatePnpInfo();

    // Because some 32-bit applications use the value 0x0000FFFF for
    // WAVE_MAPPER instead of 0xFFFFFFFF, we clamp up to the correct value.
    // This just happened to work on Win9x because WinMM would thunk down
    // to MMSystem and send down the lower word to the 16-bit interface.
    if ((UINT_PTR)hwo == LOWORD(WAVE_MAPPER)) {
        (UINT_PTR)hwo = WAVE_MAPPER;
    }

    DevInterface = waveReferenceDevInterfaceById(&waveoutdrvZ, (UINT_PTR)hwo);

    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE(hwo, TYPE_WAVEOUT))
    {
        ReleaseHandleListResource();
        mmr = waveIDMessage(&waveoutdrvZ, wTotalWaveOutDevs, PtrToUint(hwo), WODM_SETVOLUME, dwVolume, (DWORD_PTR)DevInterface);
    }
    else
    {
    	mmr = (MMRESULT)waveMessage((HWAVE)hwo, WODM_SETVOLUME, dwVolume, (DWORD_PTR)DevInterface);
    }

    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    return mmr;
}

/*****************************************************************************
 * @doc INTERNAL WAVE
 *
 * @func UINT | waveGetErrorText | This function retrieves a textual
 *   description of the error identified by the specified error number.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPTSTR | lpText | Specifies a far pointer to a buffer which
 *   is filled with the textual error description.
 *
 * @parm UINT | wSize | Specifies the length in characters of the buffer
 *   pointed to by <p lpText>.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADERRNUM | Specified error number is out of range.
 *
 * @comm If the textual error description is longer than the specified buffer,
 *   the description is truncated.  The returned error string is always
 *   null-terminated. If <p wSize> is zero, nothing is copied and MMSYSERR_NOERROR
 *   is returned.  All error descriptions are less than 80 characters long.
 ****************************************************************************/

STATIC MMRESULT waveGetErrorTextW(UINT wError, LPWSTR lpText, UINT wSize)
{
    lpText[0] = 0;

#if MMSYSERR_BASE
    if (((wError < MMSYSERR_BASE) || (wError > MMSYSERR_LASTERROR)) && ((wError < WAVERR_BASE) || (wError > WAVERR_LASTERROR)))
#else
    if ((wError > MMSYSERR_LASTERROR) && ((wError < WAVERR_BASE) || (wError > WAVERR_LASTERROR)))
#endif
        return MMSYSERR_BADERRNUM;

    if (wSize > 1)
    {
        if (!LoadStringW(ghInst, wError, lpText, wSize))
            return MMSYSERR_BADERRNUM;
    }

    return MMSYSERR_NOERROR;
}

STATIC MMRESULT waveGetErrorTextA(UINT wError, LPSTR lpText, UINT wSize)
{
    lpText[0] = 0;

#if MMSYSERR_BASE
    if (((wError < MMSYSERR_BASE) || (wError > MMSYSERR_LASTERROR)) && ((wError < WAVERR_BASE) || (wError > WAVERR_LASTERROR)))
#else
    if ((wError > MMSYSERR_LASTERROR) && ((wError < WAVERR_BASE) || (wError > WAVERR_LASTERROR)))
#endif
        return MMSYSERR_BADERRNUM;

    if (wSize > 1)
    {
        if (!LoadStringA(ghInst, wError, lpText, wSize))
            return MMSYSERR_BADERRNUM;
    }

    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveOutGetErrorText | This function retrieves a
 *   textual description of the error identified by the specified
 *   error number.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPTSTR | lpText | Specifies a far pointer to a buffer to be
 *   filled with the textual error description.
 *
 * @parm UINT | wSize | Specifies the length in characters of the buffer
 *   pointed to by <p lpText>.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADERRNUM | Specified error number is out of range.
 *
 * @comm If the textual error description is longer than the specified buffer,
 *   the description is truncated.  The returned error string is always
 *   null-terminated. If <p wSize> is zero, nothing is copied, and the function
 *   returns zero. All error descriptions are less than MAXERRORLENGTH characters long.
 ****************************************************************************/
MMRESULT APIENTRY waveOutGetErrorTextW(UINT wError, LPWSTR lpText, UINT wSize)
{
    if (wSize == 0)
        return MMSYSERR_NOERROR;

    V_WPOINTER(lpText, wSize*sizeof(WCHAR), MMSYSERR_INVALPARAM);

    return waveGetErrorTextW(wError, lpText, wSize);
}

MMRESULT APIENTRY waveOutGetErrorTextA(UINT wError, LPSTR lpText, UINT wSize)
{
    if (wSize == 0)
        return MMSYSERR_NOERROR;

    V_WPOINTER(lpText, wSize, MMSYSERR_INVALPARAM);

    return waveGetErrorTextA(wError, lpText, wSize );
}

/****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveOutOpen | This function opens a specified waveform output
 *   device for playback.
 *
 * @parm LPHWAVEOUT | lphWaveOut | Specifies a far pointer to an HWAVEOUT
 *   handle.  This location is filled with a handle identifying the opened
 *   waveform output device.  Use the handle to identify the device when
 *   calling other waveform output functions.  This parameter may be
 *   NULL if the WAVE_FORMAT_QUERY flag is specified for <p dwFlags>.
 *
 * @parm UINT | uDeviceID | Identifies the waveform output device to open.
 *  Use a valid device ID or the following flag:
 *
 *   @flag WAVE_MAPPER | If this flag is specified, the function
 *     selects a waveform output device
 *     capable of playing the given format.
 *
 * @parm LPWAVEFORMATEX | lpFormat | Specifies a pointer to a <t WAVEFORMATEX>
 *   structure that identifies the format of the waveform data
 *   to be sent to the waveform output device.
 *
 * @parm DWORD | dwCallback | Specifies the address of a callback
 *   function or a handle to a window called during waveform
 *   playback to process messages related to the progress of the playback.
 *   Specify NULL for this parameter if no callback is desired.
 *
 * @parm DWORD | dwCallbackInstance | Specifies user instance data
 *   passed to the callback.  This parameter is not used with
 *   window callbacks.
 *
 * @parm DWORD | dwFlags | Specifies flags for opening the device.
 *   @flag WAVE_FORMAT_QUERY | If this flag is specified, the device is
 *   queried to determine if it supports the given format but is not
 *      actually opened.
 *   @flag WAVE_ALLOWSYNC | If this flag is not specified, then the
 *   device will fail to open if it is a synchronous device.
 *   @flag CALLBACK_WINDOW | If this flag is specified, <p dwCallback> is
 *      assumed to be a window handle.
 *   @flag CALLBACK_FUNCTION | If this flag is specified, <p dwCallback> is
 *      assumed to be a callback procedure address.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_ALLOCATED | Specified resource is already allocated.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *   @flag WAVERR_BADFORMAT | Attempted to open with an unsupported wave format.
 *
 * @comm Use <f waveOutGetNumDevs> to determine the number of waveform output
 *   devices present in the system.  The device ID specified by <p uDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The WAVE_MAPPER constant may also be used as a device id.
 *
 *   The <t WAVEFORMAT> structure pointed to by <p lpFormat> may be extended
 *   to include type-specific information for certain data formats.
 *   For example, for PCM data, an extra WORD is added to specify the number
 *   of bits per sample.  Use the <t PCMWAVEFORMAT> structure in this case.
 *
 *   If a window is chosen to receive callback information, the following
 *   messages are sent to the window procedure function to indicate the
 *   progress of waveform output:  <m MM_WOM_OPEN>, <m MM_WOM_CLOSE>,
 *   <m MM_WOM_DONE>
 *
 *   If a function is chosen to receive callback information, the following
 *   messages are sent to the function to indicate the progress of waveform
 *   output: <m WOM_OPEN>, <m WOM_CLOSE>, <m WOM_DONE>.  The callback function
 *   must reside in a DLL.  You do not have to use <f MakeProcInstance> to get
 *   a procedure-instance address for the callback function.
 *
 * @cb void CALLBACK | WaveOutFunc | <f WaveOutFunc> is a placeholder for the
 *   application-supplied function name.  The actual name must be exported by
 *   including it in an EXPORTS statement in the DLL's module-definition file.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform device
 *   associated with the callback.
 *
 * @parm UINT | wMsg | Specifies a waveform output message.
 *
 * @parm DWORD | dwInstance | Specifies the user instance data
 *   specified with <f waveOutOpen>.
 *
 * @parm DWORD | dwParam1 | Specifies a parameter for the message.
 *
 * @parm DWORD | dwParam2 | Specifies a parameter for the message.
 *
 * @comm Because the callback is accessed at interrupt time, it must reside
 *   in a DLL and its code segment must be specified as FIXED in the
 *   module-definition file for the DLL.  Any data that the callback accesses
 *   must be in a FIXED data segment as well. The callback may not make any
 *   system calls except for <f PostMessage>, <f timeGetSystemTime>,
 *   <f timeGetTime>, <f timeSetEvent>, <f timeKillEvent>,
 *   <f midiOutShortMsg>, <f midiOutLongMsg>, and <f OutputDebugStr>.
 *
 * @xref waveOutClose
 ****************************************************************************/
MMRESULT APIENTRY waveOutOpen(LPHWAVEOUT lphWaveOut, UINT uDeviceID,
                            LPCWAVEFORMATEX lpFormat, DWORD_PTR dwCallback,
                            DWORD_PTR dwInstance, DWORD dwFlags)
{
    WAVEOPENDESC wo;
    PWAVEDEV     pdev;
    PWAVEDRV     wavedrv;
    UINT         port;
    MMRESULT     wRet;
    DWORD_PTR    dwDrvUser;
    int          cRecursion;

    V_RPOINTER(lpFormat, sizeof(WAVEFORMAT), MMSYSERR_INVALPARAM);
    V_DCALLBACK(dwCallback, HIWORD(dwFlags), MMSYSERR_INVALPARAM);
    // Because some 32-bit applications use the value 0x0000FFFF for
    // WAVE_MAPPER instead of 0xFFFFFFFF, we clamp up to the correct value.
    // This just happened to work on Win9x because WinMM would thunk down
    // to MMSystem and send down the lower word to the 16-bit interface.
    if (uDeviceID == LOWORD(WAVE_MAPPER)) {
        uDeviceID = WAVE_MAPPER;
    }
    if (uDeviceID == WAVE_MAPPER) {
        V_FLAGS(LOWORD(dwFlags), WAVE_VALID & ~(WAVE_MAPPED), waveOutOpen, MMSYSERR_INVALFLAG);
    } else {
        V_FLAGS(LOWORD(dwFlags), WAVE_VALID, waveOutOpen, MMSYSERR_INVALFLAG);
    }
    if ((lpFormat->wFormatTag != WAVE_FORMAT_PCM)) {
        V_RPOINTER(lpFormat, sizeof(WAVEFORMATEX), MMSYSERR_INVALPARAM);
        if ((lpFormat->cbSize)) {
            V_RPOINTER(lpFormat + 1, lpFormat->cbSize, MMSYSERR_INVALPARAM);
        }
    }

    if ((dwFlags & WAVE_FORMAT_QUERY)) {
        lphWaveOut = NULL;
    } else
    {
            V_WPOINTER(lphWaveOut, sizeof(HWAVEOUT), MMSYSERR_INVALPARAM);
        //  WAVE_FORMAT_DIRECT was bounced on Win95.  Now we
        //  accept this flag.
        //
        //   if (dwFlags & WAVE_FORMAT_DIRECT)
        //       return MMSYSERR_INVALFLAG;
            *lphWaveOut = NULL;
    }

    ClientUpdatePnpInfo();

    if ((!wTotalWaveOutDevs) || waveReferenceDriverById(&waveoutdrvZ, (dwFlags & WAVE_MAPPED) ? WAVE_MAPPER : uDeviceID, &wavedrv, &port))
    {
        return MMSYSERR_BADDEVICEID;
    }

    //
    //  check if the device is appropriate for the current TS session
    //
    if (!(wavedrv->fdwDriver & MMDRV_MAPPER) &&
    	lstrcmpW(wavedrv->wszSessProtocol, SessionProtocolName))
    {
    	mregDecUsagePtr(wavedrv);
        return MMSYSERR_NODRIVER;
    }

    /* Default wave mapper :
     *
     * If a wave mapper is installed as a separate DLL then all wave mapper
     * messages are routed to it. If no wave mapper is installed, simply
     * loop through the wave devices looking for a match.
     */
    // ISSUE-2001/01/06-FrankYe This logic looks broken for the WAVE_MAPPER case
    if ((uDeviceID == WAVE_MAPPER) && !wavedrv->drvMessage) {
        MMRESULT    wErr;

        mregDecUsagePtr(wavedrv);
        wErr = MMSYSERR_ALLOCATED;

        if (dwFlags & WAVE_MAPPED)
        {
            if (wErr = waveReferenceDriverById(&waveoutdrvZ, uDeviceID, &wavedrv, &port))
                return wErr;

            if (mregHandleInternalMessages(wavedrv,
                                      MMDRVI_WAVEOUT,
                                      port,
                                      DRV_QUERYMAPPABLE,
                                      0, 0, &wErr) ||
                 (MMSYSERR_NOERROR != wErr))
            {
            	mregDecUsagePtr(wavedrv);
                return wErr;
            }
            wErr = waveOutOpen(lphWaveOut, uDeviceID, lpFormat, dwCallback, dwInstance, dwFlags & ~WAVE_MAPPED);
            mregDecUsagePtr(wavedrv);
        }
        else
        {
            for (uDeviceID=0; uDeviceID<wTotalWaveOutDevs; uDeviceID++) {
                wErr = waveOutOpen(lphWaveOut, uDeviceID, lpFormat, dwCallback, dwInstance, dwFlags);
                if (!wErr)
                    break;
            }
        }
        return wErr;

    }
    
    if (dwFlags & WAVE_FORMAT_QUERY)
        pdev = NULL;
    else {
        if (!(pdev = (PWAVEDEV)NewHandle(TYPE_WAVEOUT, wavedrv->cookie, sizeof(WAVEDEV))))
        {
            mregDecUsagePtr(wavedrv);
            return MMSYSERR_NOMEM;
        }
        
        ENTER_MM_HANDLE(pdev);
        SetHandleFlag(pdev, MMHANDLE_BUSY);
        ReleaseHandleListResource();

        pdev->wavedrv = wavedrv;
        pdev->wDevice = port;
        pdev->uDeviceID = uDeviceID;
        pdev->fdwHandle = 0;
    }

    wo.hWave      = (HWAVE)pdev;
    wo.dwCallback = dwCallback;
    wo.dwInstance = dwInstance;
    wo.uMappedDeviceID = uDeviceID;
    wo.lpFormat   = (LPWAVEFORMAT)lpFormat;  // cast away the CONST to eliminate wng
    wo.dnDevNode  = (DWORD_PTR)wavedrv->cookie;

    // Unless it's the mapper, increment the recursion depth counter.  Then,
    // check whether this thread is now recursing through waveOutOpen.  If it
    // is, then disable preferred device reordering.
    cRecursion = PtrToInt(TlsGetValue(gTlsIndex));
    if (uDeviceID != WAVE_MAPPER) TlsSetValue(gTlsIndex, IntToPtr(cRecursion + 1));
    if ((uDeviceID != WAVE_MAPPER) && (wavedrv->fdwDriver & MMDRV_PREXP)) TlsSetValue(gTlsIndex, IntToPtr(cRecursion + 1));
    if (cRecursion) gfDisablePreferredDeviceReordering = TRUE;
    	
    wRet = ((*(wavedrv->drvMessage))
        (port, WODM_OPEN, (DWORD_PTR)&dwDrvUser, (DWORD_PTR)(LPWAVEOPENDESC)&wo, dwFlags));

    // Restore recursion counter
    TlsSetValue(gTlsIndex, IntToPtr(cRecursion));

    if (pdev) {
        //  Mark as not busy on successful open...
        if (!wRet)
            ClearHandleFlag(pdev, MMHANDLE_BUSY);
            
        LEAVE_MM_HANDLE(pdev);
    
        if (wRet)
            FreeHandle((HWAVEOUT)pdev);
        else {
            // Inc usage since we opened a handle on it
            mregIncUsagePtr(wavedrv);
            *lphWaveOut = (HWAVEOUT)pdev;
            pdev->dwDrvUser = dwDrvUser;
        }
    }

    mregDecUsagePtr(wavedrv);
    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveOutClose | This function closes the specified waveform
 *   output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device. If the function is successful, the handle is no
 *   longer valid after this call.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag WAVERR_STILLPLAYING | There are still buffers in the queue.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @comm If the device is still playing a waveform, the close
 *   operation will fail.  Use <f waveOutReset> to terminate waveform
 *   playback before calling <f waveOutClose>.
 *
 * @xref waveOutOpen waveOutReset
 ****************************************************************************/
MMRESULT APIENTRY waveOutClose(HWAVEOUT hWaveOut)
{
    MMRESULT    wRet;
    PWAVEDRV    pwavedrv;
    PWAVEDEV    pDev = (PWAVEDEV)hWaveOut;

    ClientUpdatePnpInfo();
    
    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);

    ENTER_MM_HANDLE((HWAVE)hWaveOut);
    ReleaseHandleListResource();

    if (IsHandleDeserted(hWaveOut))
    {
        //  This handle has been deserted.  Let's just free it.

        LEAVE_MM_HANDLE((HWAVE)hWaveOut);
        FreeHandle(hWaveOut);
        return MMSYSERR_NOERROR;
    }

    if (IsHandleBusy(hWaveOut))
    {
        //  Not quite invalid, but marked as closed.
    
        LEAVE_MM_HANDLE(hWaveOut);
        return (MMSYSERR_HANDLEBUSY);
    }

    //  Marking handle as 'invalid/closed'.
    SetHandleFlag(hWaveOut, MMHANDLE_BUSY);
    
    pwavedrv = pDev->wavedrv;

    wRet = (MMRESULT)(*(pwavedrv->drvMessage))(pDev->wDevice, WODM_CLOSE, pDev->dwDrvUser, 0L, 0L);

    if (MMSYSERR_NOERROR != wRet)
    {
        //  Error closing, set the flag as valid.
        ClearHandleFlag(hWaveOut, MMHANDLE_BUSY);
    }

    LEAVE_MM_HANDLE((HWAVE)hWaveOut);
    
    if (!wRet)
    {
        FreeHandle(hWaveOut);
    	mregDecUsagePtr(pwavedrv);
        return wRet;
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveOutPrepareHeader | This function prepares a
 *   waveform data block for playback.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @parm LPWAVEHDR | lpWaveOutHdr | Specifies a pointer to a
 *   <t WAVEHDR> structure that identifies the data block to be prepared.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @comm The <t WAVEHDR> data structure and the data block pointed to by its
 *   <e WAVEHDR.lpData> field must be allocated with <f GlobalAlloc> using the
 *   GMEM_MOVEABLE and GMEM_SHARE flags, and locked with <f GlobalLock>.
 *   Preparing a header that has already been prepared has no effect, and
 *   the function returns zero.
 *
 * @xref waveOutUnprepareHeader
 ****************************************************************************/
MMRESULT APIENTRY waveOutPrepareHeader(HWAVEOUT hWaveOut, LPWAVEHDR lpWaveOutHdr, UINT wSize)
{
    MMRESULT     wRet;

    V_HEADER(lpWaveOutHdr, wSize, TYPE_WAVEOUT, MMSYSERR_INVALPARAM);

    if (IsWaveHeaderPrepared(hWaveOut, lpWaveOutHdr))
    {
        DebugErr(DBF_WARNING,"waveOutPrepareHeader: header is already prepared.");
        return MMSYSERR_NOERROR;
    }

    ClientUpdatePnpInfo();
    
    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    
    lpWaveOutHdr->dwFlags &= (WHDR_BEGINLOOP | WHDR_ENDLOOP);
    
    wRet = waveMessage((HWAVE)hWaveOut, WODM_PREPARE, (DWORD_PTR)lpWaveOutHdr, (DWORD)wSize);

    if (wRet == MMSYSERR_NOTSUPPORTED)
        wRet = wavePrepareHeader(lpWaveOutHdr, wSize);

    if (wRet == MMSYSERR_NOERROR)
        MarkWaveHeaderPrepared(hWaveOut, lpWaveOutHdr);

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveOutUnprepareHeader | This function cleans up the
 *   preparation performed by <f waveOutPrepareHeader>. The function
 *   must be called after
 *   the device driver is finished with a data block. You must call this
 *   function before freeing the data buffer.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @parm LPWAVEHDR | lpWaveOutHdr |  Specifies a pointer to a <t WAVEHDR>
 *   structure identifying the data block to be cleaned up.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag WAVERR_STILLPLAYING | <p lpWaveOutHdr> is still in the queue.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @comm This function is the complementary function to
 * <f waveOutPrepareHeader>. You must call this function before freeing the
 *  data buffer with <f GlobalFree>.
 *   After passing a buffer to the device driver with <f waveOutWrite>, you
 *   must wait until the driver is finished with the buffer before calling
 *   <f waveOutUnprepareHeader>.
 *
 *  Unpreparing a buffer that has not been
 *  prepared has no effect, and the function returns zero.
 *
 * @xref waveOutPrepareHeader
 ****************************************************************************/
MMRESULT APIENTRY waveOutUnprepareHeader(HWAVEOUT hWaveOut,
                                            LPWAVEHDR lpWaveOutHdr, UINT wSize)
{
    MMRESULT    wRet;

    V_HEADER(lpWaveOutHdr, wSize, TYPE_WAVEOUT, MMSYSERR_INVALPARAM);

    if(lpWaveOutHdr->dwFlags & WHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING,"waveOutUnprepareHeader: header still in queue.");
        return WAVERR_STILLPLAYING;
    }

    if (!IsWaveHeaderPrepared(hWaveOut, lpWaveOutHdr))
    {
        DebugErr(DBF_WARNING,"waveOutUnprepareHeader: header is not prepared.");
        return MMSYSERR_NOERROR;
    }

    ClientUpdatePnpInfo();
    
    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    
    wRet = waveMessage((HWAVE)hWaveOut, WODM_UNPREPARE, (DWORD_PTR)lpWaveOutHdr, (DWORD)wSize);
    
    if (wRet == MMSYSERR_NOTSUPPORTED)
        wRet = waveUnprepareHeader(lpWaveOutHdr, wSize);

    if ((wRet == MMSYSERR_NODRIVER) && (IsHandleDeserted(hWaveOut)))
    {
        wRet = MMSYSERR_NOERROR;
    }

    if (wRet == MMSYSERR_NOERROR)
        MarkWaveHeaderUnprepared(hWaveOut, lpWaveOutHdr);

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveOutWrite | This function sends a data block to the
 *   specified waveform output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *  device.
 *
 * @parm LPWAVEHDR | lpWaveOutHdr | Specifies a far pointer to a <t WAVEHDR>
 *   structure containing information about the data block.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag WAVERR_UNPREPARED | <p lpWaveOutHdr> hasn't been prepared.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @comm The data buffer must be prepared with <f waveOutPrepareHeader> before
 *   it is passed to <f waveOutWrite>.  The <t WAVEHDR> data structure
 *   and the data buffer pointed to by its <e WAVEHDR.lpData> field must be allocated
 *   with <f GlobalAlloc> using the GMEM_MOVEABLE and GMEM_SHARE flags, and
 *   locked with <f GlobalLock>.  Unless the device is paused by calling
 *   <f waveOutPause>, playback begins when the first data block is sent to
 *   the device.
 *
 * @xref waveOutPrepareHeader waveOutPause waveOutReset waveOutRestart
 ****************************************************************************/
MMRESULT APIENTRY waveOutWrite(HWAVEOUT hWaveOut, LPWAVEHDR lpWaveOutHdr, UINT wSize)
{
    V_HEADER(lpWaveOutHdr, wSize, TYPE_WAVEOUT, MMSYSERR_INVALPARAM);

    if (!IsWaveHeaderPrepared(hWaveOut, lpWaveOutHdr))
    {
        DebugErr(DBF_WARNING,"waveOutWrite: header not prepared");
        return WAVERR_UNPREPARED;
    }

    if (lpWaveOutHdr->dwFlags & WHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING,"waveOutWrite: header is still in queue");
        return WAVERR_STILLPLAYING;
    }

    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    lpWaveOutHdr->dwFlags &= ~WHDR_DONE;

    return waveMessage((HWAVE)hWaveOut, WODM_WRITE, (DWORD_PTR)lpWaveOutHdr, (DWORD)wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveOutPause | This function pauses playback on a specified
 *   waveform output device.  The current playback position is saved.  Use
 *   <f waveOutRestart> to resume playback from the current playback position.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @comm Calling this function when the output is already paused has no
 *   effect, and the function returns zero.
 *
 * @xref waveOutRestart waveOutBreakLoop
 ****************************************************************************/
MMRESULT APIENTRY waveOutPause(HWAVEOUT hWaveOut)
{
    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    
    return waveMessage((HWAVE)hWaveOut, WODM_PAUSE, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveOutRestart | This function restarts a paused waveform
 *   output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @comm Calling this function when the output is not paused has no
 *   effect, and the function returns zero.
 *
 * @xref waveOutPause waveOutBreakLoop
 ****************************************************************************/
MMRESULT APIENTRY waveOutRestart(HWAVEOUT hWaveOut)
{
    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);

    return waveMessage((HWAVE)hWaveOut, WODM_RESTART, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveOutReset | This function stops playback on a given waveform
 *   output device and resets the current position to 0.  All pending
 *   playback buffers are marked as done and returned to the application.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @xref waveOutWrite waveOutClose
/****************************************************************************/
MMRESULT APIENTRY waveOutReset(HWAVEOUT hWaveOut)
{
    MMRESULT    mmr;

    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    
    mmr = waveMessage((HWAVE)hWaveOut, WODM_RESET, 0L, 0L);
    
    if ((MMSYSERR_NODRIVER == mmr) && (IsHandleDeserted(hWaveOut)))
    {
        mmr = MMSYSERR_NOERROR;
    }
    
    return (mmr);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveOutBreakLoop | This function breaks a loop on a
 *   given waveform output device and allows playback to continue with the
 *   next block in the driver list.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @comm Waveform looping is controlled by the <e WAVEHDR.dwLoops> and
 *   <e WAVEHDR.dwFlags> fields in the <t WAVEHDR> structures passed to the device
 *   with <f waveOutWrite>. Use the WHDR_BEGINLOOP and WHDR_ENDLOOP flags
 *   in the <e WAVEHDR.dwFlags> field to specify the beginning and ending data
 *   blocks for looping.
 *
 *   To loop on a single block, specify both flags for the same block.
 *   To specify the number of loops, use the <e WAVEHDR.dwLoops> field in
 *   the <t WAVEHDR> structure for the first block in the loop.
 *
 *   The blocks making up the loop are played to the end before the loop
 *   is terminated.
 *
 *   Calling this function when the nothing is playing or looping has no
 *   effect, and the function returns zero.
 *
 * @xref waveOutWrite waveOutPause waveOutRestart
/****************************************************************************/
MMRESULT APIENTRY waveOutBreakLoop(HWAVEOUT hWaveOut)
{
    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    
    return waveMessage((HWAVE)hWaveOut, WODM_BREAKLOOP, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveOutGetPosition | This function retrieves the current
 *   playback position of the specified waveform output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @parm LPMMTIME | lpInfo | Specifies a far pointer to an <t MMTIME>
 *   structure.
 *
 * @parm UINT | wSize | Specifies the size of the <t MMTIME> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @comm Before calling <f waveOutGetPosition>, set the <e MMTIME.wType> field of the
 *   MMTIME structure to indicate the time format that you desire.  After
 *   calling <f waveOutGetPosition>, check the <e MMTIME.wType> field
 *   to determine if the desired time format is supported.  If the desired
 *   format is not supported, <e MMTIME.wType> will specify an alternative format.
 *
 *  The position is set to zero when the device is opened or reset.
 ****************************************************************************/
MMRESULT APIENTRY waveOutGetPosition(HWAVEOUT hWaveOut, LPMMTIME lpInfo,
                                                        UINT wSize)
{
    V_WPOINTER(lpInfo, wSize, MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    
    return waveMessage((HWAVE)hWaveOut, WODM_GETPOS, (DWORD_PTR)lpInfo, (DWORD)wSize);
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api MMRESULT | waveOutGetPitch | This function queries the the current pitch
 *   setting of a waveform output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @parm LPDWORD | lpdwPitch | Specifies a far pointer to a location
 *   to be filled with the current pitch multiplier setting. The pitch
 *   multiplier indicates the current change in pitch from the original
 *   authored setting. The pitch multiplier must be a positive value.
 *
 * The pitch multiplier is specified as a fixed-point value. The high-order word
 * of the DWORD location contains the signed integer part of the number,
 * and the low-order word contains the fractional part. The fraction is
 * expressed as a WORD in which a value of 0x8000 represents one half,
 * and 0x4000 represents one quarter. For example, the value 0x00010000
 * specifies a multiplier of 1.0 (no pitch change), and a value of
 * 0x000F8000 specifies a multiplier of 15.5.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @comm Changing the pitch does not change the playback rate, sample
 *   rate, or playback time.  Not all devices support
 *   pitch changes. To determine whether the device supports pitch control,
 *   use the WAVECAPS_PITCH flag to test the <e WAVEOUTCAPS.dwSupport>
 *   field of the <t WAVEOUTCAPS> structure (filled by <f waveOutGetDevCaps>).
 *
 * @xref waveOutSetPitch waveOutGetPlaybackRate waveOutSetPlaybackRate
 ****************************************************************************/
MMRESULT APIENTRY waveOutGetPitch(HWAVEOUT hWaveOut, LPDWORD lpdwPitch)
{
    V_WPOINTER(lpdwPitch, sizeof(DWORD), MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    
    return waveMessage((HWAVE)hWaveOut, WODM_GETPITCH, (DWORD_PTR)lpdwPitch, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api MMRESULT | waveOutSetPitch | This function sets the pitch of a waveform
 *   output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform
 *   output device.
 *
 * @parm DWORD | dwPitch | Specifies the new pitch multiplier setting.
 *  The pitch multiplier setting indicates the current change in pitch
 *  from the original authored setting. The pitch multiplier must be a
 *  positive value.
 *
 * The pitch multiplier is specified as a fixed-point value. The high-order word
 * location contains the signed integer part of the number,
 * and the low-order word contains the fractional part. The fraction is
 * expressed as a WORD in which a value of 0x8000 represents one half,
 * and 0x4000 represents one quarter.
 * For example, the value 0x00010000 specifies a multiplier
 * of 1.0 (no pitch change), and a value of 0x000F8000 specifies a
 * multiplier of 15.5.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @comm Changing the pitch does not change the playback rate or the sample
 *   rate.  The playback time is also unchanged. Not all devices support
 *   pitch changes. To determine whether the device supports pitch control,
 *   use the WAVECAPS_PITCH flag to test the <e WAVEOUTCAPS.dwSupport>
 *   field of the <t WAVEOUTCAPS> structure (filled by <f waveOutGetDevCaps>).
 *
 * @xref waveOutGetPitch waveOutSetPlaybackRate waveOutGetPlaybackRate
 ****************************************************************************/
MMRESULT APIENTRY waveOutSetPitch(HWAVEOUT hWaveOut, DWORD dwPitch)
{
    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    
    return waveMessage((HWAVE)hWaveOut, WODM_SETPITCH, dwPitch, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api MMRESULT | waveOutGetPlaybackRate | This function queries the
 *   current playback rate setting of a waveform output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @parm LPDWORD | lpdwRate | Specifies a far pointer to a location
 *   to be filled with the current playback rate. The playback rate setting
 *  is a multiplier indicating the current change in playback rate from
 *  the original authored setting. The playback rate multiplier must be
 *  a positive value.
 *
 * The rate is specified as a fixed-point value. The high-order word
 * of the DWORD location contains the signed integer part of the number,
 * and the low-order word contains the fractional part. The fraction is
 * expressed as a WORD in which a value of 0x8000 represents one half,
 * and 0x4000 represents one quarter. For example, the value 0x00010000
 * specifies a multiplier of 1.0 (no playback rate change), and a value
 * of 0x000F8000 specifies a multiplier of 15.5.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @comm Changing the playback rate does not change the sample rate but does
 *   change the playback time.
 *
 *   Not all devices support playback rate changes. To determine whether a
 *   device supports playback rate changes, use
 *   the WAVECAPS_PLAYBACKRATE flag to test the <e WAVEOUTCAPS.dwSupport> field of the
 *   <t WAVEOUTCAPS> structure (filled by <f waveOutGetDevCaps>).
 *
 * @xref waveOutSetPlaybackRate waveOutSetPitch waveOutGetPitch
 ****************************************************************************/
MMRESULT APIENTRY waveOutGetPlaybackRate(HWAVEOUT hWaveOut, LPDWORD lpdwRate)
{
    V_WPOINTER(lpdwRate, sizeof(DWORD), MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    
    return waveMessage((HWAVE)hWaveOut, WODM_GETPLAYBACKRATE, (DWORD_PTR)lpdwRate, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api MMRESULT | waveOutSetPlaybackRate | This function sets the
 *   playback rate of a waveform output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform
 *   output device.
 *
 * @parm DWORD | dwRate | Specifies the new playback rate setting.
 *  The playback rate setting is a multiplier indicating the current
 *  change in playback rate from the original authored setting. The playback
 *  rate multiplier must be a positive value.
 *
 * The rate is specified as a fixed-point value. The high-order word
 * contains the signed integer part of the number,
 * and the low-order word contains the fractional part. The fraction is
 * expressed as a WORD in which a value of 0x8000 represents one half,
 * and 0x4000 represents one quarter.
 * For example, the value 0x00010000 specifies a multiplier of 1.0 (no
 * playback rate change), and a value of 0x000F8000 specifies a
 * multiplier of 15.5.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @comm Changing the playback rate does not change the sample rate but does
 *   change the playback time.
 *
 * Not all devices support playback rate changes. To determine whether a
 *   device supports playback rate changes,
 *   use the WAVECAPS_PLAYBACKRATE flag to test the <e WAVEOUTCAPS.dwSupport> field of the
 *   <t WAVEOUTCAPS> structure (filled by <f waveOutGetDevCaps>).
 *
 * @xref waveOutGetPlaybackRate waveOutSetPitch waveOutGetPitch
 ****************************************************************************/
MMRESULT APIENTRY waveOutSetPlaybackRate(HWAVEOUT hWaveOut, DWORD dwRate)
{
    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    
    return waveMessage((HWAVE)hWaveOut, WODM_SETPLAYBACKRATE, dwRate, 0L);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInGetNumDevs | This function returns the number of waveform
 *   input devices.
 *
 * @rdesc Returns the number of waveform input devices present in the system.
 *
 * @xref waveInGetDevCaps
 ****************************************************************************/
UINT APIENTRY waveInGetNumDevs(void)
{
    ClientUpdatePnpInfo();

    dprintf3(("waveInGetNumDevs returning %d devices", wTotalWaveInDevs));

//    EnterNumDevs("waveInGetNumDevs");
    return wTotalWaveInDevs;
//    LeaveNumDevs("waveInGetNumDevs");
}


//--------------------------------------------------------------------------;
//
//  MMRESULT waveOutDesertHandle
//
//  Description:
//      Cleans up the wave out handle and marks it as deserted.
//
//  Arguments:
//      HWAVEOUT hWaveOut:  Wave out handle
//
//  Return (MMRESULT):  Error code.
//
//  History:
//      01/25/99    Fwong       Adding Pnp Support.
//
//--------------------------------------------------------------------------;

MMRESULT waveOutDesertHandle
(
    HWAVEOUT    hWaveOut
)
{
    MMRESULT    mmr;
    PWAVEDEV    pDev = (PWAVEDEV)hWaveOut;

    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    
    ENTER_MM_HANDLE((HWAVE)hWaveOut);
    ReleaseHandleListResource();
    
    if (IsHandleDeserted(hWaveOut))
    {
        LEAVE_MM_HANDLE((HWAVE)hWaveOut);
        return (MMSYSERR_NOERROR);
    }
    
    if (IsHandleBusy(hWaveOut))
    {
        //  Not quite invalid, but marked as closed.
    
        LEAVE_MM_HANDLE(hWaveOut);
        return (MMSYSERR_HANDLEBUSY);
    }

    //  Marking handle as deserted
    SetHandleFlag(hWaveOut, MMHANDLE_DESERTED);

    //  Since the handle was invalidated, we have to send the message ourselves...

    (*(pDev->wavedrv->drvMessage))(pDev->wDevice, WODM_RESET, pDev->dwDrvUser, 0L, 0L);
    (*(pDev->wavedrv->drvMessage))(pDev->wDevice, WODM_CLOSE, pDev->dwDrvUser, 0L, 0L);
    
    LEAVE_MM_HANDLE((HWAVE)hWaveOut);

    // ISSUE-2001/01/14-FrankYe Probably don't want to dec usage here,
    //    dec on close instead.
    mregDecUsagePtr(pDev->wavedrv);

    return MMSYSERR_NOERROR;
} // waveOutDesertHandle()


/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api MMRESULT | waveInMessage | This function sends messages to the waveform
 *   output device drivers.
 *
 * @parm HWAVEIN | hWave | The handle to the audio device.
 *
 * @parm UINT | wMsg | The message to send.
 *
 * @parm DWORD | dw1 | Parameter 1.
 *
 * @parm DWORD | dw2 | Parameter 2.
 *
 * @rdesc Returns the value returned from the driver.
 ****************************************************************************/
MMRESULT APIENTRY waveInMessage(HWAVEIN hWaveIn, UINT msg, DWORD_PTR dw1, DWORD_PTR dw2)
{
    ClientUpdatePnpInfo();

    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE((HWAVE)hWaveIn, TYPE_WAVEIN))
    {
        ReleaseHandleListResource();
        return waveIDMessage(&waveindrvZ, wTotalWaveInDevs, PtrToUint(hWaveIn), msg, dw1, dw2);
    }
    else
    {
        return waveMessage((HWAVE)hWaveIn, msg, dw1, dw2);
    }
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveInGetDevCaps | This function queries a specified waveform
 *   input device to determine its capabilities.
 *
 * @parm UINT | uDeviceID | Identifies the waveform input device.
 *
 * @parm LPWAVEINCAPS | lpCaps | Specifies a far pointer to a <t WAVEINCAPS>
 *   structure.  This structure is filled with information about the
 *   capabilities of the device.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEINCAPS> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Use <f waveInGetNumDevs> to determine the number of waveform input
 *   devices present in the system.  The device ID specified by <p uDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The WAVE_MAPPER constant may also be used as a device id. Only
 *   <p wSize> bytes (or less) of information is copied to the location
 *   pointed to by <p lpCaps>.  If <p wSize> is zero, nothing is copied, and
 *   the function returns zero.
 *
 * @xref waveInGetNumDevs
 ****************************************************************************/
MMRESULT APIENTRY waveInGetDevCapsW(UINT_PTR uDeviceID, LPWAVEINCAPSW lpCaps,UINT wSize)
{
    DWORD_PTR       dwParam1, dwParam2;
    MDEVICECAPSEX   mdCaps;
    PWAVEDRV        waveindrv;
    PCWSTR          DevInterface;
    MMRESULT        mmr;

    if (wSize == 0)
        return MMSYSERR_NOERROR;

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    DevInterface = waveReferenceDevInterfaceById(&waveindrvZ, uDeviceID);
    dwParam2 = (DWORD_PTR)DevInterface;

    if (0 == dwParam2)
    {
        dwParam1 = (DWORD_PTR)lpCaps;
        dwParam2 = (DWORD)wSize;
    }
    else
    {
        mdCaps.cbSize = (DWORD)wSize;
        mdCaps.pCaps  = lpCaps;
        dwParam1      = (DWORD_PTR)&mdCaps;
    }
    
    //
    //  Don't allow non proper drivers in TS environement
    //
    // ISSUE-2001/01/09-FrankYe Instead of cast to UINT.  Should check whether
    //    this is a handle and get wavedrv from handle if it is.
    waveindrv = NULL;
    if ((!waveReferenceDriverById(&waveindrvZ, (UINT)uDeviceID, &waveindrv, NULL)) &&
    	lstrcmpW(waveindrv->wszSessProtocol, SessionProtocolName))
    {
        mmr = MMSYSERR_NODRIVER;
    }
    else
    {
        AcquireHandleListResourceShared();
    
        if (BAD_HANDLE((HWAVE)uDeviceID, TYPE_WAVEIN))
        {
            ReleaseHandleListResource();
    	    mmr = waveIDMessage(&waveindrvZ, wTotalWaveInDevs, (UINT)uDeviceID, WIDM_GETDEVCAPS, dwParam1, dwParam2);
        }
        else
        {
    	    mmr = (MMRESULT)waveMessage((HWAVE)uDeviceID, WIDM_GETDEVCAPS, dwParam1, dwParam2);
        }
    }
    
    if (waveindrv) mregDecUsagePtr(waveindrv);
    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    return mmr;
}

MMRESULT APIENTRY waveInGetDevCapsA(UINT_PTR uDeviceID, LPWAVEINCAPSA lpCaps,UINT wSize)
{
    WAVEINCAPS2W   wDevCaps2;
    WAVEINCAPS2A   aDevCaps2;
    DWORD_PTR      dwParam1, dwParam2;
    MDEVICECAPSEX  mdCaps;
    PCWSTR         DevInterface;
    PWAVEDRV       waveindrv;
    MMRESULT       mmRes;

    if (wSize == 0)
        return MMSYSERR_NOERROR;

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    DevInterface = waveReferenceDevInterfaceById(&waveindrvZ, uDeviceID);
    dwParam2 = (DWORD_PTR)DevInterface;

    memset(&wDevCaps2, 0, sizeof(wDevCaps2));

    if (0 == dwParam2)
    {
        dwParam1 = (DWORD_PTR)&wDevCaps2;
        dwParam2 = (DWORD)sizeof(wDevCaps2);
    }
    else
    {
        mdCaps.cbSize = (DWORD)sizeof(wDevCaps2);
        mdCaps.pCaps  = &wDevCaps2;
        dwParam1      = (DWORD_PTR)&mdCaps;
    }

    //
    //  Don't allow non proper drivers in TS environement
    //
    // ISSUE-2001/01/09-FrankYe Bad cast to UINT.  Should check whether this
    //    is a handle and get wavedrv from handle if it is.
    waveindrv = NULL;
    if ( uDeviceID < wTotalWaveInDevs &&
         !waveReferenceDriverById(&waveindrvZ, (UINT)uDeviceID, &waveindrv, NULL) &&
    	 lstrcmpW(waveindrv->wszSessProtocol, SessionProtocolName) )
    {
    	mregDecUsagePtr(waveindrv);
    	if (DevInterface) wdmDevInterfaceDec(DevInterface);
    	return MMSYSERR_NODRIVER;
    }
    
    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE((HWAVE)uDeviceID, TYPE_WAVEIN))
    {
        ReleaseHandleListResource();
        mmRes = waveIDMessage( &waveindrvZ, wTotalWaveInDevs, (UINT)uDeviceID,
                            WIDM_GETDEVCAPS, dwParam1, dwParam2);
    }
    else
    {
        mmRes = waveMessage((HWAVE)uDeviceID, WIDM_GETDEVCAPS,
                            dwParam1, dwParam2);
    }

    if (waveindrv) mregDecUsagePtr(waveindrv);
    if (DevInterface) wdmDevInterfaceDec(DevInterface);

    //
    // Make sure the call worked before proceeding with the thunk.
    //
    if ( mmRes != MMSYSERR_NOERROR ) {
        return  mmRes;
    }

    aDevCaps2.wMid             = wDevCaps2.wMid;
    aDevCaps2.wPid             = wDevCaps2.wPid;
    aDevCaps2.vDriverVersion   = wDevCaps2.vDriverVersion;
    aDevCaps2.dwFormats        = wDevCaps2.dwFormats;
    aDevCaps2.wChannels        = wDevCaps2.wChannels;
    aDevCaps2.ManufacturerGuid = wDevCaps2.ManufacturerGuid;
    aDevCaps2.ProductGuid      = wDevCaps2.ProductGuid;
    aDevCaps2.NameGuid         = wDevCaps2.NameGuid;

    // copy and convert unicode to ascii here.
    Iwcstombs(aDevCaps2.szPname, wDevCaps2.szPname, MAXPNAMELEN);

    //
    // now copy the required amount into the callers buffer.
    //
    CopyMemory( lpCaps, &aDevCaps2, min(wSize, sizeof(aDevCaps2)));

    return mmRes;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveInGetErrorText | This function retrieves a textual
 *   description of the error identified by the specified error number.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPTSTR | lpText | Specifies a far pointer to the buffer to be
 *   filled with the textual error description.
 *
 * @parm UINT | wSize | Specifies the length in characters of the buffer
 *   pointed to by <p lpText>.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADERRNUM | Specified error number is out of range.
 *
 * @comm If the textual error description is longer than the specified buffer,
 *   the description is truncated.  The returned error string is always
 *   null-terminated. If <p wSize> is zero, nothing is copied, and the function
 *   returns zero. All error descriptions are less than MAXERRORLENGTH characters long.
 ****************************************************************************/
MMRESULT APIENTRY waveInGetErrorTextW(UINT wError, LPWSTR lpText, UINT wSize)
{
    if (wSize == 0)
        return MMSYSERR_NOERROR;

    V_WPOINTER(lpText, wSize*sizeof(WCHAR), MMSYSERR_INVALPARAM);

    return waveGetErrorTextW(wError, lpText, wSize);
}

MMRESULT APIENTRY waveInGetErrorTextA(UINT wError, LPSTR lpText, UINT wSize)
{
    if (wSize == 0)
        return MMSYSERR_NOERROR;

    V_WPOINTER(lpText, wSize, MMSYSERR_INVALPARAM);

    return waveGetErrorTextA(wError, lpText, wSize );
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveInOpen | This function opens a specified waveform
 *   input device for recording.
 *
 * @parm LPHWAVEIN | lphWaveIn | Specifies a far pointer to a HWAVEIN
 *   handle.  This location is filled with a handle identifying the opened
 *   waveform input device.  Use this handle to identify the device when
 *   calling other waveform input functions.  This parameter may be NULL
 *   if the WAVE_FORMAT_QUERY flag is specified for <p dwFlags>.
 *
 * @parm UINT | uDeviceID | Identifies the waveform input device to open. Use
 *  a valid device ID or the following flag:
 *
 * @flag WAVE_MAPPER | If this flag is specified, the function
 *   selects a waveform input device capable of recording in the
 *   given format.
 *
 * @parm LPWAVEFORMATEX | lpFormat | Specifies a pointer to a <t WAVEFORMATEX>
 *   data structure that identifies the desired format for recording
 *   waveform data.
 *
 * @parm DWORD | dwCallback | Specifies the address of a callback
 *   function or a handle to a window called during waveform
 *   recording to process messages related to the progress of recording.
 *
 * @parm DWORD | dwCallbackInstance | Specifies user
 *  instance data passed to the callback.  This parameter is not
 *  used with window callbacks.
 *
 * @parm DWORD | dwFlags | Specifies flags for opening the device.
 *   @flag WAVE_FORMAT_QUERY | If this flag is specified, the device will
 *   be queried to determine if it supports the given format but will not
 *      actually be opened.
 *   @flag WAVE_ALLOWSYNC | If this flag is not specified, then the
 *   device will fail to open if it is a synchronous device.
 *   @flag CALLBACK_WINDOW | If this flag is specified, <p dwCallback> is
 *      assumed to be a window handle.
 *   @flag CALLBACK_FUNCTION | If this flag is specified, <p dwCallback> is
 *      assumed to be a callback procedure address.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_ALLOCATED | Specified resource is already allocated.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *   @flag WAVERR_BADFORMAT | Attempted to open with an unsupported wave format.
 *
 * @comm Use <f waveInGetNumDevs> to determine the number of waveform input
 *   devices present in the system.  The device ID specified by <p uDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The WAVE_MAPPER constant may also be used as a device id.
 *
 *   If a window is chosen to receive callback information, the following
 *   messages are sent to the window procedure function to indicate the
 *   progress of waveform input:  <m MM_WIM_OPEN>, <m MM_WIM_CLOSE>,
 *   <m MM_WIM_DATA>
 *
 *   If a function is chosen to receive callback information, the following
 *   messages are sent to the function to indicate the progress of waveform
 *   input: <m WIM_OPEN>, <m WIM_CLOSE>, <m WIM_DATA>.  The callback function
 *   must reside in a DLL.  You do not have to use <f MakeProcInstance> to get
 *   a procedure-instance address for the callback function.
 *
 * @cb void CALLBACK | WaveInFunc | <f WaveInFunc> is a placeholder for the
 *   application-supplied function name.  The actual name must be exported by
 *   including it in an EXPORTS statement in the DLL's module-definition file.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform device
 *   associated with the callback.
 *
 * @parm UINT | wMsg | Specifies a waveform input device.
 *
 * @parm DWORD | dwInstance | Specifies the user instance
 *   data specified with <f waveInOpen>.
 *
 * @parm DWORD | dwParam1 | Specifies a parameter for the message.
 *
 * @parm DWORD | dwParam2 | Specifies a parameter for the message.
 *
 * @comm Because the callback is accessed at interrupt time, it must reside
 *   in a DLL and its code segment must be specified as FIXED in the
 *   module-definition file for the DLL.  Any data that the callback accesses
 *   must be in a FIXED data segment as well. The callback may not make any
 *   system calls except for <f PostMessage>, <f timeGetSystemTime>,
 *   <f timeGetTime>, <f timeSetEvent>, <f timeKillEvent>,
 *   <f midiOutShortMsg>, <f midiOutLongMsg>, and <f OutputDebugStr>.
 *
 * @xref waveInClose
 ****************************************************************************/
MMRESULT APIENTRY waveInOpen(LPHWAVEIN lphWaveIn, UINT uDeviceID,
                           LPCWAVEFORMATEX lpFormat, DWORD_PTR dwCallback,
                           DWORD_PTR dwInstance, DWORD dwFlags)
{
    WAVEOPENDESC wo;
    UINT         port;
    PWAVEDEV     pdev;
    PWAVEDRV     wavedrv;
    MMRESULT     wRet;
    DWORD_PTR    dwDrvUser;

    V_RPOINTER(lpFormat, sizeof(WAVEFORMAT), MMSYSERR_INVALPARAM);
    V_DCALLBACK(dwCallback, HIWORD(dwFlags), MMSYSERR_INVALPARAM);
    // Because some 32-bit applications use the value 0x0000FFFF for
    // WAVE_MAPPER instead of 0xFFFFFFFF, we clamp up to the correct value.
    // This just happened to work on Win9x because WinMM would thunk down
    // to MMSystem and send down the lower word to the 16-bit interface.
    if (uDeviceID == LOWORD(WAVE_MAPPER)) {
        uDeviceID = WAVE_MAPPER;
    }
    if (uDeviceID == WAVE_MAPPER) {
        V_FLAGS(LOWORD(dwFlags), WAVE_VALID & ~(WAVE_MAPPED), waveInOpen, MMSYSERR_INVALFLAG);
    } else {
        V_FLAGS(LOWORD(dwFlags), WAVE_VALID, waveInOpen, MMSYSERR_INVALFLAG);
    }

    if (lpFormat->wFormatTag != WAVE_FORMAT_PCM) {
        V_RPOINTER(lpFormat, sizeof(WAVEFORMATEX), MMSYSERR_INVALPARAM);
        if (lpFormat->cbSize) {
            V_RPOINTER(lpFormat + 1, lpFormat->cbSize, MMSYSERR_INVALPARAM);
        }
    }

    if (dwFlags & WAVE_FORMAT_QUERY) {
        lphWaveIn = NULL;
    } else {
        V_WPOINTER((LPVOID)lphWaveIn, sizeof(HWAVEIN), MMSYSERR_INVALPARAM);
        //  WAVE_FORMAT_DIRECT was bounced on Win95.  Now we
        //  accept this flag
        //
        //  if (dwFlags & WAVE_FORMAT_DIRECT)
        //      return MMSYSERR_INVALFLAG;
        *lphWaveIn = NULL;
    }

    ClientUpdatePnpInfo();

    if ((!wTotalWaveInDevs) || waveReferenceDriverById(&waveindrvZ, (dwFlags & WAVE_MAPPED) ? WAVE_MAPPER : uDeviceID, &wavedrv, &port))
    {
        return MMSYSERR_BADDEVICEID;
    }

    //
    //  check if the device is appropriate for the current TS session
    //
    if (!(wavedrv->fdwDriver & MMDRV_MAPPER) &&
    	lstrcmpW(wavedrv->wszSessProtocol, SessionProtocolName))
    {
    	mregDecUsagePtr(wavedrv);
        return MMSYSERR_NODRIVER;
    }

    /* Default wave mapper :
     *
     * If a wave mapper is installed as a separate DLL then all wave mapper
     * messages are routed to it. If no wave mapper is installed, simply
     * loop through the wave devices looking for a match.
     */
    // ISSUE-2001/01/06-FrankYe This logic looks broken for the WAVE_MAPPED case
    if ((uDeviceID == WAVE_MAPPER && !wavedrv->drvMessage)) {
        UINT    wErr;

        mregDecUsagePtr(wavedrv);
        wErr = MMSYSERR_ALLOCATED;

        if (dwFlags & WAVE_MAPPED)
        {
            if (wErr = waveReferenceDriverById(&waveindrvZ, uDeviceID, &wavedrv, &port))
                return wErr;

            if (mregHandleInternalMessages(wavedrv,
                                           MMDRVI_WAVEIN,
                                           port,
                                           DRV_QUERYMAPPABLE,
                                           0, 0, &wErr) ||
                 (MMSYSERR_NOERROR != wErr))
            {
            	mregDecUsagePtr(wavedrv);
                return wErr;
            }
            wErr = waveInOpen(lphWaveIn, uDeviceID, lpFormat, dwCallback, dwInstance, dwFlags & ~WAVE_MAPPED);
            mregDecUsagePtr(wavedrv);
        }
        else
        {
            for (uDeviceID=0; uDeviceID<wTotalWaveInDevs; uDeviceID++) {
                wErr = waveInOpen(lphWaveIn, uDeviceID, lpFormat, dwCallback, dwInstance, dwFlags);
                if (!wErr)
                    break;
            }
        }
        return wErr;
    }
    
    if (dwFlags & WAVE_FORMAT_QUERY)
        pdev = NULL;
    else {
        if (!(pdev = (PWAVEDEV)NewHandle(TYPE_WAVEIN, wavedrv->cookie, sizeof(WAVEDEV))))
            return MMSYSERR_NOMEM;
        
        ENTER_MM_HANDLE(pdev);
        SetHandleFlag(pdev, MMHANDLE_BUSY);
        ReleaseHandleListResource();    

        pdev->wavedrv = wavedrv;
        pdev->wDevice = port;
        pdev->uDeviceID = uDeviceID;
        pdev->fdwHandle = 0;
    }

    wo.hWave        = (HWAVE)pdev;
    wo.dwCallback   = dwCallback;
    wo.dwInstance   = dwInstance;
    wo.uMappedDeviceID = uDeviceID;
    wo.lpFormat     = (LPWAVEFORMAT)lpFormat;  // cast away the CONST to eliminate wng
    wo.dnDevNode    = (DWORD_PTR)wavedrv->cookie;

    wRet = (MMRESULT)((*(wavedrv->drvMessage))
        (port, WIDM_OPEN, (DWORD_PTR)&dwDrvUser, (DWORD_PTR)(LPWAVEOPENDESC)&wo, dwFlags));

    if (pdev) {
        //  Mark as not busy on successful open...
        if (!wRet)
            ClearHandleFlag(pdev, MMHANDLE_BUSY);
            
        LEAVE_MM_HANDLE(pdev);
    
        if (wRet)
            FreeHandle((HWAVEIN)pdev);
        else {
            // Inc usage since we opened a handle on it
            mregIncUsagePtr(wavedrv);
            *lphWaveIn = (HWAVEIN)pdev;
            pdev->dwDrvUser = dwDrvUser;
        }
    }

    mregDecUsagePtr(wavedrv);
    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveInClose | This function closes the specified waveform
 *   input device.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input device.
 *  If the function is successful, the handle is no longer
 *   valid after this call.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag WAVERR_STILLPLAYING | There are still buffers in the queue.
 *
 * @comm If there are input buffers that have been sent with
 *   <f waveInAddBuffer>, and haven't been returned to the application,
 *   the close operation will fail.  Call <f waveInReset> to mark all
 *   pending buffers as done.
 *
 * @xref waveInOpen waveInReset
 ****************************************************************************/
MMRESULT APIENTRY waveInClose(HWAVEIN hWaveIn)
{
    MMRESULT    wRet;
    PWAVEDRV    pwavedrv;
    PWAVEDEV    pDev = (PWAVEDEV)hWaveIn;

    ClientUpdatePnpInfo();
    
    V_HANDLE_ACQ(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);
    
    ENTER_MM_HANDLE((HWAVE)hWaveIn);
    ReleaseHandleListResource();
    
    if (IsHandleDeserted(hWaveIn))
    {
        //  This handle has been deserted.  Let's just free it.

        LEAVE_MM_HANDLE((HWAVE)hWaveIn);
        FreeHandle(hWaveIn);
        return MMSYSERR_NOERROR;
    }
    
    if (IsHandleBusy(hWaveIn))
    {
        //  Not quite invalid, but marked as closed.
    
        LEAVE_MM_HANDLE(hWaveIn);
        return (MMSYSERR_HANDLEBUSY);
    }

    //  Marking handle as 'invalid/closed'.
    SetHandleFlag(hWaveIn, MMHANDLE_BUSY);
    
    pwavedrv = pDev->wavedrv;

    wRet = (MMRESULT)(*(pwavedrv->drvMessage))(pDev->wDevice, WIDM_CLOSE, pDev->dwDrvUser, 0L, 0L);

    if (MMSYSERR_NOERROR != wRet)
    {
        ClearHandleFlag(hWaveIn, MMHANDLE_BUSY);
    }

    LEAVE_MM_HANDLE((HWAVE)hWaveIn);

    if (!wRet)
    {
        FreeHandle(hWaveIn);
    	mregDecUsagePtr(pwavedrv);
        return wRet;
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveInPrepareHeader | This function prepares a buffer
 *   for waveform input.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input
 *   device.
 *
 * @parm LPWAVEHDR | lpWaveInHdr | Specifies a pointer to a
 *   <t WAVEHDR> structure that identifies the buffer to be prepared.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveIn> is in use on another
 *      thread.
 *
 * @comm The <t WAVEHDR> data structure and the data block pointed to by its
 *   <e WAVEHDR.lpData> field must be allocated with <f GlobalAlloc> using the
 *   GMEM_MOVEABLE and GMEM_SHARE flags, and locked with <f GlobalLock>.
 *   Preparing a header that has already been prepared will have no effect,
 *   and the function will return zero.
 *
 * @xref waveInUnprepareHeader
 ****************************************************************************/
MMRESULT APIENTRY waveInPrepareHeader(HWAVEIN hWaveIn, LPWAVEHDR lpWaveInHdr,
                                                                  UINT wSize)
{
    MMRESULT         wRet;

    V_HEADER(lpWaveInHdr, wSize, TYPE_WAVEIN, MMSYSERR_INVALPARAM);

    if (IsWaveHeaderPrepared(hWaveIn, lpWaveInHdr))
    {
        DebugErr(DBF_WARNING,"waveInPrepareHeader: header is already prepared.");
        return MMSYSERR_NOERROR;
    }

    lpWaveInHdr->dwFlags = 0;

    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);
    
    wRet = waveMessage((HWAVE)hWaveIn, WIDM_PREPARE, (DWORD_PTR)lpWaveInHdr, (DWORD)wSize);

    if (wRet == MMSYSERR_NOTSUPPORTED)
        wRet = wavePrepareHeader(lpWaveInHdr, wSize);

    if (wRet == MMSYSERR_NOERROR)
        MarkWaveHeaderPrepared(hWaveIn, lpWaveInHdr);

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveInUnprepareHeader | This function cleans up the
 * preparation performed by <f waveInPrepareHeader>. The function must
 * be called after the device
 *   driver fills a data buffer and returns it to the application. You
 *  must call this function before freeing the data buffer.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input
 *   device.
 *
 * @parm LPWAVEHDR | lpWaveInHdr |  Specifies a pointer to a <t WAVEHDR>
 *   structure identifying the data buffer to be cleaned up.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag WAVERR_STILLPLAYING | <p lpWaveInHdr> is still in the queue.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveIn> is in use on another
 *      thread.
 *
 * @comm This function is the complementary function to <f waveInPrepareHeader>.
 * You must call this function before freeing the data buffer with <f GlobalFree>.
 *   After passing a buffer to the device driver with <f waveInAddBuffer>, you
 *   must wait until the driver is finished with the buffer before calling
 *   <f waveInUnprepareHeader>. Unpreparing a buffer that has not been
 *   prepared has no effect, and the function returns zero.
 *
 * @xref waveInPrepareHeader
 ****************************************************************************/
MMRESULT APIENTRY waveInUnprepareHeader(HWAVEIN hWaveIn, LPWAVEHDR lpWaveInHdr, UINT wSize)
{
    MMRESULT        wRet;

    V_HEADER(lpWaveInHdr, wSize, TYPE_WAVEIN, MMSYSERR_INVALPARAM);

    if (lpWaveInHdr->dwFlags & WHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING, "waveInUnprepareHeader: buffer still in queue.");
        return WAVERR_STILLPLAYING;
    }

    if (!IsWaveHeaderPrepared(hWaveIn, lpWaveInHdr))
    {
        DebugErr(DBF_WARNING,"waveInUnprepareHeader: header is not prepared.");
        return MMSYSERR_NOERROR;
    }

    ClientUpdatePnpInfo();
    
    V_HANDLE_ACQ(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);
    
    wRet = waveMessage((HWAVE)hWaveIn, WIDM_UNPREPARE, (DWORD_PTR)lpWaveInHdr, (DWORD)wSize);

    if (wRet == MMSYSERR_NOTSUPPORTED)
        wRet = waveUnprepareHeader(lpWaveInHdr, wSize);

    if ((wRet == MMSYSERR_NODRIVER) && (IsHandleDeserted(hWaveIn)))
    {
        wRet = MMSYSERR_NOERROR;
    }

    if (wRet == MMSYSERR_NOERROR)
        MarkWaveHeaderUnprepared(hWaveIn, lpWaveInHdr);

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveInAddBuffer | This function sends an input buffer to a
 *   waveform input device.  When the buffer is filled, it is sent back
 *   to the application.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input device.
 *
 * @parm LPWAVEHDR | lpWaveInHdr | Specifies a far pointer to a <t WAVEHDR>
 *   structure that identifies the buffer.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag WAVERR_UNPREPARED | <p lpWaveInHdr> hasn't been prepared.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveIn> is in use on another
 *      thread.
 *
 * @comm The data buffer must be prepared with <f waveInPrepareHeader> before
 *   it is passed to <f waveInAddBuffer>.  The <t WAVEHDR> data structure
 *   and the data buffer pointed to by its <e WAVEHDR.lpData> field must be allocated
 *   with <f GlobalAlloc> using the GMEM_MOVEABLE and GMEM_SHARE flags, and
 *   locked with <f GlobalLock>.
 *
 * @xref waveInPrepareHeader
 ****************************************************************************/
MMRESULT APIENTRY waveInAddBuffer(HWAVEIN hWaveIn, LPWAVEHDR lpWaveInHdr,
                                                                UINT wSize)
{
    V_HEADER(lpWaveInHdr, wSize, TYPE_WAVEIN, MMSYSERR_INVALPARAM);

    if (!IsWaveHeaderPrepared(hWaveIn, lpWaveInHdr))
    {
        DebugErr(DBF_WARNING, "waveInAddBuffer: buffer not prepared.");
        return WAVERR_UNPREPARED;
    }

    if (lpWaveInHdr->dwFlags & WHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING, "waveInAddBuffer: buffer already in queue.");
        return WAVERR_STILLPLAYING;
    }

    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);
    
    return waveMessage((HWAVE)hWaveIn, WIDM_ADDBUFFER, (DWORD_PTR)lpWaveInHdr, (DWORD)wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveInStart | This function starts input on the specified
 *   waveform input device.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveIn> is in use on another
 *      thread.
 *
 * @comm Buffers are returned to the client when full or when <f waveInReset>
 *   is called (the <e WAVEHDR.dwBytesRecorded> field in the header will contain the
 *   actual length of data). If there are no buffers in the queue, the data is
 *   thrown away without notification to the client, and input continues.
 *
 *   Calling this function when input is already started has no effect, and
 *   the function returns zero.
 *
 * @xref waveInStop waveInReset
 ****************************************************************************/
MMRESULT APIENTRY waveInStart(HWAVEIN hWaveIn)
{
    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);

    return waveMessage((HWAVE)hWaveIn, WIDM_START, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveInStop | This function stops waveform input.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input
 *   device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveIn> is in use on another
 *      thread.
 *
 * @comm If there are any buffers in the queue, the current buffer will be
 *   marked as done (the <e WAVEHDR.dwBytesRecorded> field in the header will contain
 *   the actual length of data), but any empty buffers in the queue will remain
 *   there.  Calling this function when input is not started has no effect,
 *   and the function returns zero.
 *
 * @xref waveInStart waveInReset
 ****************************************************************************/
MMRESULT APIENTRY waveInStop(HWAVEIN hWaveIn)
{
    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);

    return waveMessage((HWAVE)hWaveIn, WIDM_STOP, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveInReset | This function stops input on a given waveform
 *   input device and resets the current position to 0.  All pending
 *   buffers are marked as done and returned to the application.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveIn> is in use on another
 *      thread.
 *
 * @xref waveInStart waveInStop waveInAddBuffer waveInClose
/****************************************************************************/
MMRESULT APIENTRY waveInReset(HWAVEIN hWaveIn)
{
    MMRESULT    mmr;

    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);
    
    mmr = waveMessage((HWAVE)hWaveIn, WIDM_RESET, 0L, 0L);
    
    if ((MMSYSERR_NODRIVER == mmr) && (IsHandleDeserted(hWaveIn)))
    {
        mmr = MMSYSERR_NOERROR;
    }
    
    return (mmr);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveInGetPosition | This function retrieves the current input
 *   position of the specified waveform input device.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input device.
 *
 * @parm LPMMTIME | lpInfo | Specifies a far pointer to an <t MMTIME>
 *   structure.
 *
 * @parm UINT | wSize | Specifies the size of the <t MMTIME> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm Before calling <f waveInGetPosition>, set the <e MMTIME.wType> field of the
 *   <t MMTIME> structure to indicate the time format that you desire.  After
 *   calling <f waveInGetPosition>, be sure to check the <e MMTIME.wType> field to
 *   determine if the desired time format is supported.  If the desired
 *   format is not supported, <e MMTIME.wType> will specify an alternative format.
 *
 *  The position is set to zero when the device is opened or reset.
 ****************************************************************************/
MMRESULT APIENTRY waveInGetPosition(HWAVEIN hWaveIn, LPMMTIME lpInfo,
                                                        UINT wSize)
{
    V_WPOINTER(lpInfo, wSize, MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();
    
    V_HANDLE_ACQ(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);

    return waveMessage((HWAVE)hWaveIn, WIDM_GETPOS, (DWORD_PTR)lpInfo, (DWORD)wSize);
}


//--------------------------------------------------------------------------;
//
//  MMRESULT waveInDesertHandle
//
//  Description:
//      Cleans up the wave in handle and marks it as deserted.
//
//  Arguments:
//      HWAVEIN hWaveIn:  Wave in handle
//
//  Return (MMRESULT):  Error code.
//
//  History:
//      01/25/99    Fwong       Adding Pnp Support.
//
//--------------------------------------------------------------------------;

MMRESULT waveInDesertHandle
(
    HWAVEIN hWaveIn
)
{
    MMRESULT    mmr;
    PWAVEDEV    pDev = (PWAVEDEV)hWaveIn;

    V_HANDLE_ACQ(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);
    
    ENTER_MM_HANDLE((HWAVE)hWaveIn);
    ReleaseHandleListResource();
    
    if (IsHandleDeserted(hWaveIn))
    {
        LEAVE_MM_HANDLE((HWAVE)hWaveIn);
        return (MMSYSERR_NOERROR);
    }

    if (IsHandleBusy(hWaveIn))
    {
        //  Not quite invalid, but marked as closed.
    
        LEAVE_MM_HANDLE(hWaveIn);
        return (MMSYSERR_HANDLEBUSY);
    }

    //  Marking handle as deserted
    SetHandleFlag(hWaveIn, MMHANDLE_DESERTED);
    
    //  Since the handle was invalidated, we have to send the message ourselves...
    
    (*(pDev->wavedrv->drvMessage))(pDev->wDevice, WIDM_RESET, pDev->dwDrvUser, 0L, 0L);
    (*(pDev->wavedrv->drvMessage))(pDev->wDevice, WIDM_CLOSE, pDev->dwDrvUser, 0L, 0L);

    LEAVE_MM_HANDLE((HWAVE)hWaveIn);
    
    // ISSUE-2001/01/14-FrankYe Probably don't want to dec usage here,
    //    dec on close instead.
    mregDecUsagePtr(pDev->wavedrv);

    return MMSYSERR_NOERROR;
} // waveInDesertHandle()


/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api MMRESULT | waveInGetID | This function gets the device ID for a
 * waveform input device.
 *
 * @parm HWAVEIN | hWaveIn | Specifies the handle to the waveform
 * input device.
 * @parm PUINT  | lpuDeviceID | Specifies a pointer to the UINT-sized memory
 * location to be filled with the device ID.
 *
 * @rdesc Returns zero if successful. Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | The <p hWaveIn> parameter specifies an
 * invalid handle.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveIn> is in use on another
 *      thread.
 *
 ****************************************************************************/
MMRESULT APIENTRY waveInGetID(HWAVEIN hWaveIn, PUINT lpuDeviceID)
{
    V_WPOINTER(lpuDeviceID, sizeof(UINT), MMSYSERR_INVALPARAM);
    V_HANDLE_ACQ(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);

    *lpuDeviceID = ((PWAVEDEV)hWaveIn)->uDeviceID;

    ReleaseHandleListResource();
    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api MMRESULT | waveOutGetID | This function gets the device ID for a
 * waveform output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies the handle to the waveform
 * output device.
 * @parm PUINT  | lpuDeviceID | Specifies a pointer to the UINT-sized memory
 * location to be filled with the device ID.
 *
 * @rdesc Returns zero if successful. Otherwise, it returns
 *   an error number.  Possible error returns are:
 * @flag MMSYSERR_INVALHANDLE | The <p hWaveIn> parameter specifies an
 * invalid handle.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 ****************************************************************************/
MMRESULT APIENTRY waveOutGetID(HWAVEOUT hWaveOut, PUINT lpuDeviceID)
{
    V_WPOINTER(lpuDeviceID, sizeof(UINT), MMSYSERR_INVALPARAM);
    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);

    *lpuDeviceID = ((PWAVEDEV)hWaveOut)->uDeviceID;

    ReleaseHandleListResource();
    return MMSYSERR_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\util.c ===
/****************************************************************************
 *
 *   util.c
 *
 *   Copyright (c) 1992-1999 Microsoft Corporation
 *
 ***************************************************************************/

#include "winmmi.h"

//
//  Assist with unicode conversions
//


// This function translates from Unicode strings to multibyte strings.
// It will automatically munge down the Unicode string until the translation
// is guaranteed to succeed with the buffer space available in the multibyte
// buffer.  Then it performs the conversion.


int Iwcstombs(LPSTR lpstr, LPCWSTR lpwstr, int len)
{

int wlength;

wlength=wcslen(lpwstr)+1;

	while (WideCharToMultiByte(GetACP(), 0, lpwstr, wlength, NULL, 0, NULL, NULL)>len && wlength>0) {
		wlength--;
		}

    return WideCharToMultiByte(GetACP(), 0, lpwstr, wlength, lpstr, len, NULL, NULL);
}

int Imbstowcs(LPWSTR lpwstr, LPCSTR lpstr, int len)
{
    return MultiByteToWideChar(GetACP(),
                               MB_PRECOMPOSED,
                               lpstr,
                               -1,
                               lpwstr,
                               len);
}

#if 0
BOOL HugePageLock(LPVOID lpArea, DWORD dwLength)
{
     PVOID BaseAddress = lpArea;
     ULONG RegionSize = dwLength;
     NTSTATUS Status;

     Status =
         NtLockVirtualMemory(NtCurrentProcess(),
                             &BaseAddress,
                             &RegionSize,
                             MAP_PROCESS);

     //
     // People without the right priviledge will not have the luxury
     // of having their pages locked
     // (maybe we should do something else to commit it ?)
     //

     if (!NT_SUCCESS(Status) && Status != STATUS_PRIVILEGE_NOT_HELD) {
         dprintf2(("Failed to lock virtual memory - code %X", Status));
         return FALSE;
     }
     return TRUE;
}

void HugePageUnlock(LPVOID lpArea, DWORD dwLength)
{
     PVOID BaseAddress = lpArea;
     ULONG RegionSize = dwLength;
     NTSTATUS Status;

     Status =
         NtUnlockVirtualMemory(NtCurrentProcess(),
                               &BaseAddress,
                               &RegionSize,
                               MAP_PROCESS);

     //
     // People without the right priviledge will not have the luxury
     // of having their pages locked
     // (maybe we should do something else to commit it ?)
     //

     if (!NT_SUCCESS(Status) && Status != STATUS_PRIVILEGE_NOT_HELD) {
         dprintf2(("Failed to unlock virtual memory - code %X", Status));
     }
}
#endif

/****************************************************************************
*
*   @doc DDK MMSYSTEM
*
*   @api BOOL | DriverCallback | This function notifies a client
*     application by sending a message to a window or callback
*     function or by unblocking a task.
*
*   @parm   DWORD   | dwCallBack    | Specifies either the address of
*     a callback function, a window handle, or a task handle, depending on
*     the flags specified in the <p wFlags> parameter.
*
*   @parm   DWORD   | dwFlags        | Specifies how the client
*     application is notified, according to one of the following flags:
*
*   @flag   DCB_FUNCTION        | The application is notified by
*     sending a message to a callback function.  The <p dwCallback>
*     parameter specifies a procedure-instance address.
*   @flag   DCB_WINDOW          | The application is notified by
*     sending a message to a window.  The low-order word of the
*     <p dwCallback> parameter specifies a window handle.
*   @flag   DCB_TASK            | The application is notified by
*     calling mmTaskSignal
*   @flag   DCB_EVENT           | The application is notified by
*     calling SetEvent on the (assumed) event handle
*
*   @parm   HANDLE   | hDevice       | Specifies a handle to the device
*     associated with the notification.  This is the handle assigned by
*     MMSYSTEM when the device was opened.
*
*   @parm   DWORD   | dwMsg          | Specifies a message to send to the
*     application.
*
*   @parm   DWORD   | dwUser        | Specifies the DWORD of user instance
*     data supplied by the application when the device was opened.
*
*   @parm   DWORD   | dwParam1      | Specifies a message-dependent parameter.
*   @parm   DWORD   | dwParam2      | Specifies a message-dependent parameter.
*
*   @rdesc Returns TRUE if the callback was performed, else FALSE if an invalid
*     parameter was passed, or the task's message queue was full.
*
*   @comm  This function can be called from an APC routine.
*
*   The flags DCB_FUNCTION and DCB_WINDOW are equivalent to the
*   high-order word of the corresponding flags CALLBACK_FUNCTION
*   and CALLBACK_WINDOW specified when the device was opened.
*
*   If notification is done with a callback function, <p hDevice>,
*   <p wMsg>, <p dwUser>, <p dwParam1>, and <p dwParam2> are passed to
*   the callback.  If notification is done with a window, only <p wMsg>,
*   <p hDevice>, and <p dwParam1> are passed to the window.
 ***************************************************************************/

BOOL APIENTRY DriverCallback(DWORD_PTR       dwCallBack,
                             DWORD           dwFlags,
                             HDRVR           hDrv,
                             DWORD           dwMsg,
                             DWORD_PTR       dwUser,
                             DWORD_PTR       dw1,
                             DWORD_PTR       dw2)
{

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
//   if this is a MIM_DATA message, and thruing is enabled for this
//   device, pass the data on the the thru device
//   NOTE: we do this BEFORE we check for NULL callback type on purpose!
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;

//
//	if this is not a MIM_DATA message, or if we have no
//	thruing handle installed in the midi in device,
//	we can skip all of the midi thruing code
//
    if ((dwMsg == MIM_DATA) && (HtoPT(PMIDIDEV,hDrv)->pmThru))
	{
	    MMRESULT mmr;

		mmr = midiOutShortMsg((HMIDIOUT)HtoPT(PMIDIDEV,hDrv)->pmThru, (DWORD)dw1);

		if (MIDIERR_DONT_CONTINUE == mmr)
		{
		    return FALSE;
		}

		if (MMSYSERR_INVALHANDLE == mmr)
		{
		    HtoPT(PMIDIDEV,hDrv)->pmThru = NULL;
		}
	}

	//
    // If the callback routine is null or erroneous flags are set return
    // at once
    //

    if (dwCallBack == 0L) {
        return FALSE;
    }

    //
    // Test what type of callback we're to make
    //

    switch (dwFlags & DCB_TYPEMASK) {

    case DCB_WINDOW:
        //
        // Send message to window
        //

        return PostMessage(*(HWND *)&dwCallBack, dwMsg, (WPARAM)hDrv, (LPARAM)dw1);

    case DCB_TASK:
        //
        // Send message to task
        //
        PostThreadMessage((DWORD)dwCallBack, dwMsg, (WPARAM)hDrv, (LPARAM)dw1);
        return mmTaskSignal((DWORD)dwCallBack);

    case DCB_FUNCTION:
        //
        // Call back the user's callback
        //
        (**(PDRVCALLBACK *)&dwCallBack)(hDrv, dwMsg, dwUser, dw1, dw2);
        return TRUE;

    case DCB_EVENT:
        //
        // Signal the user's event
        //
	SetEvent((HANDLE)dwCallBack);
        return TRUE;

    default:
        return FALSE;
    }
}

/*
 * @doc INTERNAL MCI
 * @api PVOID | mciAlloc | Allocate memory from our heap and zero it
 *
 * @parm DWORD | cb | The amount of memory to allocate
 *
 * @rdesc returns pointer to the new memory
 *
 */

PVOID winmmAlloc(DWORD cb)
{
    PVOID ptr;

    ptr = (PVOID)HeapAlloc(hHeap, 0, cb);

    if (ptr == NULL) {
        return NULL;
    } else {
        ZeroMemory(ptr, cb);
        return ptr;
    }

}

/*
 * @doc INTERNAL MCI
 * @api PVOID | mciReAlloc | ReAllocate memory from our heap and zero extra
 *
 * @parm DWORD | cb | The new size
 *
 * @rdesc returns pointer to the new memory
 *
 */

PVOID winmmReAlloc(PVOID ptr, DWORD cb)
{
    PVOID newptr;
    DWORD oldcb;

    newptr = (PVOID)HeapAlloc(hHeap, 0, cb);

    if (newptr != NULL) {
        oldcb = (DWORD)HeapSize(hHeap, 0, ptr);
        if (oldcb<cb) {  // Block is being expanded
            ZeroMemory((PBYTE)newptr+oldcb, cb-oldcb);
            cb = oldcb;
        }
        CopyMemory(newptr, ptr, cb);
        HeapFree(hHeap, 0, ptr);
    }
    return newptr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\array.h ===
/******************************Module*Header*******************************\
* Module Name: array.h
*
* Fast VA_ArrayElement functions.
*
* Created: 1-31-1996
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#ifndef __array_h_
#define __array_h_

#define __VA_PD_FLAGS_T2F     (POLYDATA_TEXTURE_VALID|POLYDATA_DLIST_TEXTURE2)
#define __VA_PD_FLAGS_C3F     (POLYDATA_COLOR_VALID)
#define __VA_PD_FLAGS_C4F     (POLYDATA_COLOR_VALID| POLYDATA_DLIST_COLOR_4)
#define __VA_PD_FLAGS_N3F     (POLYDATA_NORMAL_VALID)
#define __VA_PD_FLAGS_V2F     (POLYDATA_VERTEX2)
#define __VA_PD_FLAGS_V3F     (POLYDATA_VERTEX3)
#define __VA_PD_FLAGS_V4F     (POLYDATA_VERTEX4)

#define __VA_PA_FLAGS_T2F     (POLYARRAY_TEXTURE2)
#define __VA_PA_FLAGS_C3F     (0)
#define __VA_PA_FLAGS_C4F     (0)
#define __VA_PA_FLAGS_N3F     (0)
#define __VA_PA_FLAGS_V2F     (POLYARRAY_VERTEX2)
#define __VA_PA_FLAGS_V3F     (POLYARRAY_VERTEX3)
#define __VA_PA_FLAGS_V4F     (POLYARRAY_VERTEX4)

#endif // __array_h_

#ifdef __VA_ARRAY_ELEMENT_V2F
    #define __VA_NAME        VA_ArrayElement_V2F
    #define __VA_NAMEB       VA_ArrayElement_V2F_B
    #define __VA_NAMEBI      VA_ArrayElement_V2F_BI
    #define __VA_T2F         0
    #define __VA_C3F         0
    #define __VA_C4F         0
    #define __VA_N3F         0
    #define __VA_V2F         1
    #define __VA_V3F         0
    #define __VA_V4F         0
#endif
#ifdef __VA_ARRAY_ELEMENT_V3F
    #define __VA_NAME        VA_ArrayElement_V3F
    #define __VA_NAMEB       VA_ArrayElement_V3F_B
    #define __VA_NAMEBI      VA_ArrayElement_V3F_BI
    #define __VA_T2F         0
    #define __VA_C3F         0
    #define __VA_C4F         0
    #define __VA_N3F         0
    #define __VA_V2F         0
    #define __VA_V3F         1
    #define __VA_V4F         0
#endif
#ifdef __VA_ARRAY_ELEMENT_C3F_V3F
    #define __VA_NAME        VA_ArrayElement_C3F_V3F
    #define __VA_NAMEB       VA_ArrayElement_C3F_V3F_B
    #define __VA_NAMEBI      VA_ArrayElement_C3F_V3F_BI
    #define __VA_T2F         0
    #define __VA_C3F         1
    #define __VA_C4F         0
    #define __VA_N3F         0
    #define __VA_V2F         0
    #define __VA_V3F         1
    #define __VA_V4F         0
#endif
#ifdef __VA_ARRAY_ELEMENT_N3F_V3F
    #define __VA_NAME        VA_ArrayElement_N3F_V3F
    #define __VA_NAMEB       VA_ArrayElement_N3F_V3F_B
    #define __VA_NAMEBI      VA_ArrayElement_N3F_V3F_BI
    #define __VA_T2F         0
    #define __VA_C3F         0
    #define __VA_C4F         0
    #define __VA_N3F         1
    #define __VA_V2F         0
    #define __VA_V3F         1
    #define __VA_V4F         0
#endif
#ifdef __VA_ARRAY_ELEMENT_C3F_N3F_V3F
    #define __VA_NAME        VA_ArrayElement_C3F_N3F_V3F
    #define __VA_NAMEB       VA_ArrayElement_C3F_N3F_V3F_B
    #define __VA_NAMEBI      VA_ArrayElement_C3F_N3F_V3F_BI
    #define __VA_T2F         0
    #define __VA_C3F         1
    #define __VA_C4F         0
    #define __VA_N3F         1
    #define __VA_V2F         0
    #define __VA_V3F         1
    #define __VA_V4F         0
#endif
#ifdef __VA_ARRAY_ELEMENT_C4F_N3F_V3F
    #define __VA_NAME        VA_ArrayElement_C4F_N3F_V3F
    #define __VA_NAMEB       VA_ArrayElement_C4F_N3F_V3F_B
    #define __VA_NAMEBI      VA_ArrayElement_C4F_N3F_V3F_BI
    #define __VA_T2F         0
    #define __VA_C3F         0
    #define __VA_C4F         1
    #define __VA_N3F         1
    #define __VA_V2F         0
    #define __VA_V3F         1
    #define __VA_V4F         0
#endif
#ifdef __VA_ARRAY_ELEMENT_T2F_V3F
    #define __VA_NAME        VA_ArrayElement_T2F_V3F
    #define __VA_NAMEB       VA_ArrayElement_T2F_V3F_B
    #define __VA_NAMEBI      VA_ArrayElement_T2F_V3F_BI
    #define __VA_T2F         1
    #define __VA_C3F         0
    #define __VA_C4F         0
    #define __VA_N3F         0
    #define __VA_V2F         0
    #define __VA_V3F         1
    #define __VA_V4F         0
#endif
#ifdef __VA_ARRAY_ELEMENT_T2F_C3F_V3F
    #define __VA_NAME        VA_ArrayElement_T2F_C3F_V3F
    #define __VA_NAMEB       VA_ArrayElement_T2F_C3F_V3F_B
    #define __VA_NAMEBI      VA_ArrayElement_T2F_C3F_V3F_BI
    #define __VA_T2F         1
    #define __VA_C3F         1
    #define __VA_C4F         0
    #define __VA_N3F         0
    #define __VA_V2F         0
    #define __VA_V3F         1
    #define __VA_V4F         0
#endif
#ifdef __VA_ARRAY_ELEMENT_T2F_N3F_V3F
    #define __VA_NAME        VA_ArrayElement_T2F_N3F_V3F
    #define __VA_NAMEB       VA_ArrayElement_T2F_N3F_V3F_B
    #define __VA_NAMEBI      VA_ArrayElement_T2F_N3F_V3F_BI
    #define __VA_T2F         1
    #define __VA_C3F         0
    #define __VA_C4F         0
    #define __VA_N3F         1
    #define __VA_V2F         0
    #define __VA_V3F         1
    #define __VA_V4F         0
#endif
#ifdef __VA_ARRAY_ELEMENT_T2F_C3F_N3F_V3F
    #define __VA_NAME        VA_ArrayElement_T2F_C3F_N3F_V3F
    #define __VA_NAMEB       VA_ArrayElement_T2F_C3F_N3F_V3F_B
    #define __VA_NAMEBI      VA_ArrayElement_T2F_C3F_N3F_V3F_BI
    #define __VA_T2F         1
    #define __VA_C3F         1
    #define __VA_C4F         0
    #define __VA_N3F         1
    #define __VA_V2F         0
    #define __VA_V3F         1
    #define __VA_V4F         0
#endif
#ifdef __VA_ARRAY_ELEMENT_T2F_C4F_N3F_V3F
    #define __VA_NAME        VA_ArrayElement_T2F_C4F_N3F_V3F
    #define __VA_NAMEB       VA_ArrayElement_T2F_C4F_N3F_V3F_B
    #define __VA_NAMEBI      VA_ArrayElement_T2F_C4F_N3F_V3F_BI
    #define __VA_T2F         1
    #define __VA_C3F         0
    #define __VA_C4F         1
    #define __VA_N3F         1
    #define __VA_V2F         0
    #define __VA_V3F         1
    #define __VA_V4F         0
#endif

/*************************************************************************/
// Compute pd flags and pa flags

#if __VA_T2F
    #define __VA_PD_FLAGS_T   __VA_PD_FLAGS_T2F
    #define __VA_PA_FLAGS_T   __VA_PA_FLAGS_T2F
#else
    #define __VA_PD_FLAGS_T   0
    #define __VA_PA_FLAGS_T   0
#endif

#if __VA_C3F
    #define __VA_PD_FLAGS_C   __VA_PD_FLAGS_C3F
    #define __VA_PA_FLAGS_C   __VA_PA_FLAGS_C3F
#elif __VA_C4F
    #define __VA_PD_FLAGS_C   __VA_PD_FLAGS_C4F
    #define __VA_PA_FLAGS_C   __VA_PA_FLAGS_C4F
#else
    #define __VA_PD_FLAGS_C   0
    #define __VA_PA_FLAGS_C   0
#endif

#if __VA_N3F
    #define __VA_PD_FLAGS_N   __VA_PD_FLAGS_N3F
    #define __VA_PA_FLAGS_N   __VA_PA_FLAGS_N3F
#else
    #define __VA_PD_FLAGS_N   0
    #define __VA_PA_FLAGS_N   0
#endif

#if __VA_V2F
    #define __VA_PD_FLAGS_V   __VA_PD_FLAGS_V2F
    #define __VA_PA_FLAGS_V   __VA_PA_FLAGS_V2F
#elif __VA_V3F
    #define __VA_PD_FLAGS_V   __VA_PD_FLAGS_V3F
    #define __VA_PA_FLAGS_V   __VA_PA_FLAGS_V3F
#elif __VA_V4F
    #define __VA_PD_FLAGS_V   __VA_PD_FLAGS_V4F
    #define __VA_PA_FLAGS_V   __VA_PA_FLAGS_V4F
#endif

#define __VA_PD_FLAGS \
    (__VA_PD_FLAGS_T|__VA_PD_FLAGS_C|__VA_PD_FLAGS_N|__VA_PD_FLAGS_V)
#define __VA_PA_FLAGS \
    (__VA_PA_FLAGS_T|__VA_PA_FLAGS_C|__VA_PA_FLAGS_N|__VA_PA_FLAGS_V)

#define VA_COPY_VERTEX_V2F(dataCoord)           \
    pd->obj.x = ((__GLcoord *) dataCoord)->x;   \
    pd->obj.y = ((__GLcoord *) dataCoord)->y;   \
    pd->obj.z = __glZero;                       \
    pd->obj.w = __glOne;                        

#define VA_COPY_VERTEX_V3F(dataCoord)           \
    pd->obj.x = ((__GLcoord *) dataCoord)->x;   \
    pd->obj.y = ((__GLcoord *) dataCoord)->y;   \
    pd->obj.z = ((__GLcoord *) dataCoord)->z;   \
    pd->obj.w = __glOne;                        

#define VA_COPY_VERTEX_V4F(dataCoord)           \
    pd->obj = *((__GLcoord *) data);            

#define VA_COPY_TEXTURE_T2F(dataTexture)            \
    pd->texture.x = ((__GLcoord *) dataTexture)->x; \
    pd->texture.y = ((__GLcoord *) dataTexture)->y; \
    pd->texture.z = __glZero;                       \
    pd->texture.w = __glOne;

#define VA_COPY_COLOR_C3F(dataColor)                                \
    __GL_SCALE_AND_CHECK_CLAMP_RGB(pd->colors[0].r,                 \
                                   pd->colors[0].g,                 \
                                   pd->colors[0].b,                 \
				                   gc, pa->flags,                   \
                                   ((__GLcolor *) dataColor)->r,    \
                                   ((__GLcolor *) dataColor)->g,    \
                                   ((__GLcolor *) dataColor)->b);   \
    pd->colors[0].a = gc->alphaVertexScale;

#define VA_COPY_COLOR_C4F(dataColor)                                \
__GL_SCALE_AND_CHECK_CLAMP_RGBA(pd->colors[0].r,                    \
                                pd->colors[0].g,                    \
                                pd->colors[0].b,                    \
                                pd->colors[0].a,                    \
                                gc, pa->flags,                      \
                                ((__GLcolor *) dataColor)->r,       \
                                ((__GLcolor *) dataColor)->g,       \
                                ((__GLcolor *) dataColor)->b,       \
                                ((__GLcolor *) dataColor)->a);

#define VA_COPY_NORMAL_N3F(dataNormal)                              \
            pd->normal.x = ((__GLcoord *) dataNormal)->x;           \
            pd->normal.y = ((__GLcoord *) dataNormal)->y;           \
            pd->normal.z = ((__GLcoord *) dataNormal)->z;

/*************************************************************************/
// Define a fast VA_ArrayElement function for batch mode.
// This function is called in Begin and in RGBA mode only!
//
void FASTCALL __VA_NAMEB(__GLcontext *gc, GLint firstIndex, GLint nVertices)
{
    POLYARRAY* const    pa = gc->paTeb;
    POLYDATA*           pd;
    const GLbyte *dataCoord     = gc->vertexArray.vertex.pointer;
    const int   coordStride     = gc->vertexArray.vertex.ibytes;
#if __VA_N3F
    const GLbyte *dataNormal    = gc->vertexArray.normal.pointer;
    const int   normalStride    = gc->vertexArray.normal.ibytes;
#endif
#if __VA_T2F
    const GLbyte *dataTexture   = gc->vertexArray.texCoord.pointer;
    const int   textureStride   = gc->vertexArray.texCoord.ibytes;
#endif
#if __VA_C3F ||  __VA_C4F
    const GLbyte *dataColor     = gc->vertexArray.color.pointer;
    const int   colorStride     = gc->vertexArray.color.ibytes;
#endif

    if (firstIndex != 0)
    {
        dataCoord  += firstIndex*coordStride;
#if __VA_N3F
        dataNormal += firstIndex*normalStride;
#endif
#if __VA_T2F
        dataTexture+= firstIndex*textureStride;
#endif
#if __VA_C3F ||  __VA_C4F
        dataColor  += firstIndex*colorStride;
#endif
    }

    ASSERTOPENGL(pa->flags & POLYARRAY_IN_BEGIN,
	"VA_ArrayElement called outside Begin!\n");

    while (nVertices > 0)
    {
        int     n, nProcess;
        int     needFlush = FALSE;
        
        pa->flags |= __VA_PA_FLAGS;
        pd = pa->pdNextVertex; 
        if (&pd[nVertices-1] >= pa->pdFlush)
        {
            nProcess = (int)((ULONG_PTR)(pa->pdFlush - pd) + 1);
            needFlush = TRUE;
        }
        else
            nProcess = nVertices;

        for (n=nProcess; n > 0; n--)
        {

        // Update pd attributes.

            pd->flags = __VA_PD_FLAGS;

        #if __VA_V2F
            VA_COPY_VERTEX_V2F(dataCoord);
        #elif __VA_V3F
            VA_COPY_VERTEX_V3F(dataCoord);
        #elif __VA_V4F
            VA_COPY_VERTEX_V4F(dataCoord);
        #endif
            dataCoord += coordStride;

        #if __VA_T2F
            VA_COPY_TEXTURE_T2F(dataTexture);
            dataTexture += textureStride;
        #endif

        #if __VA_C3F
            // Color
            VA_COPY_COLOR_C3F(dataColor);
            dataColor += colorStride;
        #elif __VA_C4F
            // Color
            VA_COPY_COLOR_C4F(dataColor);
            dataColor += colorStride;
        #endif

        #if __VA_N3F
            // Normal
            VA_COPY_NORMAL_N3F(dataNormal);
            dataNormal += normalStride;
        #endif
            pd++;
        } // End of loop
        
        pa->pdNextVertex = pd;
        pd->flags = 0;
        pd--;
    #if __VA_T2F
        pa->pdCurTexture = pd;
    #endif
    #if __VA_C3F || __VA_C4F
        pa->pdCurColor   = pd;
    #endif
    #if __VA_N3F
        pa->pdCurNormal  = pd;
    #endif
        nVertices-= nProcess;
        if (needFlush) 
            PolyArrayFlushPartialPrimitive();
    }
}

/*************************************************************************/
// Define a fast VA_ArrayElement function for batch indirect mode.
// This function is called in Begin and in RGBA mode only!
//
void FASTCALL __VA_NAMEBI(__GLcontext *gc, GLint nVertices, VAMAP* indices)
{
    POLYARRAY* const    pa = gc->paTeb;
    POLYDATA*           pd;
    const GLbyte *dataCoord0    = gc->vertexArray.vertex.pointer;
    const int   coordStride     = gc->vertexArray.vertex.ibytes;
#if __VA_N3F
    const GLbyte *dataNormal0    = gc->vertexArray.normal.pointer;
    const int   normalStride    = gc->vertexArray.normal.ibytes;
#endif
#if __VA_T2F
    const GLbyte *dataTexture0  = gc->vertexArray.texCoord.pointer;
    const int   textureStride   = gc->vertexArray.texCoord.ibytes;
#endif
#if __VA_C3F || __VA_C4F
    const GLbyte *dataColor0    = gc->vertexArray.color.pointer;
    const int   colorStride     = gc->vertexArray.color.ibytes;
#endif

    ASSERTOPENGL(pa->flags & POLYARRAY_IN_BEGIN,
	"VA_ArrayElement called outside Begin!\n");

    while (nVertices > 0)
    {
        int     n, nProcess;
        int     needFlush = FALSE;

        pa->flags |= __VA_PA_FLAGS;
        pd = pa->pdNextVertex; 
        if (&pd[nVertices-1] >= pa->pdFlush)
        {
            nProcess = (int)((ULONG_PTR)(pa->pdFlush - pd) + 1);
            needFlush = TRUE;
        }
        else
            nProcess = nVertices;
        for (n=nProcess; n > 0; n--)
        {
            int  i = indices->iIn;
            const GLbyte* dataCoord;
        #if __VA_N3F
            const GLbyte* dataNormal;
        #endif
        #if __VA_C3F ||  __VA_C4F
            const GLbyte* dataColor;
        #endif
        #if __VA_T2F
            const GLbyte* dataTexture;
        #endif
            indices++;

        // Update pd attributes.

            pd->flags = __VA_PD_FLAGS;

            dataCoord   = dataCoord0 + i * coordStride;
        #if __VA_V2F
            VA_COPY_VERTEX_V2F(dataCoord);
        #elif __VA_V3F
            VA_COPY_VERTEX_V3F(dataCoord);
        #elif __VA_V4F
            VA_COPY_VERTEX_V4F(dataCoord);
        #endif

        #if __VA_T2F
            dataTexture = dataTexture0 + i * textureStride;
            VA_COPY_TEXTURE_T2F(dataTexture);
        #endif

        #if __VA_C3F
            // Color
            dataColor   = dataColor0 + i * colorStride;
            VA_COPY_COLOR_C3F(dataColor);
        #elif __VA_C4F
            // Color
            dataColor   = dataColor0 + i * colorStride;
            VA_COPY_COLOR_C4F(dataColor);
        #endif

        #if __VA_N3F
            // Normal
            dataNormal  = dataNormal0 + i * normalStride;
            VA_COPY_NORMAL_N3F(dataNormal);
        #endif
            pd++;
        } // End of loop
        
        pa->pdNextVertex = pd;
        pd->flags = 0;
        pd--;
    #if __VA_T2F
        pa->pdCurTexture = pd;
    #endif
    #if __VA_C3F || __VA_C4F
        pa->pdCurColor   = pd;
    #endif
    #if __VA_N3F
        pa->pdCurNormal  = pd;
    #endif
        nVertices-= nProcess;
        if (needFlush) 
            PolyArrayFlushPartialPrimitive();
    }
}
/*************************************************************************/
// Define a fast VA_ArrayElement function.
// This function is called in Begin and in RGBA mode only!
void FASTCALL __VA_NAME(__GLcontext *gc, GLint i)
{
    POLYARRAY    *pa;
    POLYDATA     *pd;
    const GLbyte *data;

    pa = gc->paTeb;

    ASSERTOPENGL(pa->flags & POLYARRAY_IN_BEGIN,
	"VA_ArrayElement called outside Begin!\n");

// Update pa fields.

    pa->flags |= __VA_PA_FLAGS;
    pd = pa->pdNextVertex++;

#if __VA_T2F
    pa->pdCurTexture = pd;
#endif
#if __VA_C3F || __VA_C4F
    pa->pdCurColor   = pd;
#endif
#if __VA_N3F
    pa->pdCurNormal  = pd;
#endif

// Update pd attributes.

    pd->flags |= __VA_PD_FLAGS;

    data = gc->vertexArray.vertex.pointer + i * gc->vertexArray.vertex.ibytes;
#if __VA_V2F
    VA_COPY_VERTEX_V2F(data);
#elif __VA_V3F
    VA_COPY_VERTEX_V3F(data);
#elif __VA_V4F
    VA_COPY_VERTEX_V4F(data);
#endif

#if __VA_T2F
    data = gc->vertexArray.texCoord.pointer + i * gc->vertexArray.texCoord.ibytes;
    VA_COPY_TEXTURE_T2F(data);
#endif

#if __VA_C3F
    data = gc->vertexArray.color.pointer + i * gc->vertexArray.color.ibytes;
    VA_COPY_COLOR_C3F(data);
#elif __VA_C4F
    data = gc->vertexArray.color.pointer + i * gc->vertexArray.color.ibytes;
    VA_COPY_COLOR_C4F(data);
#endif

#if __VA_N3F
    // Normal
    data = gc->vertexArray.normal.pointer + i * gc->vertexArray.normal.ibytes;
    VA_COPY_NORMAL_N3F(data);
#endif

    pd[1].flags = 0;
    if (pd >= pa->pdFlush)
        PolyArrayFlushPartialPrimitive();
}

    #undef __VA_NAMEB
    #undef __VA_NAMEBI
    #undef VA_COPY_VERTEX_V2F
    #undef VA_COPY_VERTEX_V3F
    #undef VA_COPY_VERTEX_V4F
    #undef VA_COPY_TEXTURE
    #undef VA_COPY_COLOR_C3F
    #undef VA_COPY_COLOR_C4F
    #undef VA_COPY_NORMAL
    #undef __VA_NAME
    #undef __VA_T2F
    #undef __VA_C3F
    #undef __VA_C4F
    #undef __VA_N3F
    #undef __VA_V2F
    #undef __VA_V3F
    #undef __VA_V4F
    #undef __VA_PD_FLAGS_T
    #undef __VA_PD_FLAGS_C
    #undef __VA_PD_FLAGS_N
    #undef __VA_PD_FLAGS_V
    #undef __VA_PA_FLAGS_T
    #undef __VA_PA_FLAGS_C
    #undef __VA_PA_FLAGS_N
    #undef __VA_PA_FLAGS_V
    #undef __VA_PD_FLAGS
    #undef __VA_PA_FLAGS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\ddtex.c ===
/******************************Module*Header*******************************\
* Module Name: ddtex.c
*
* wgl DirectDraw texture support
*
* Created: 02-10-1997
* Author: Drew Bliss [drewb]
*
* Copyright (c) 1993-1997 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "gencx.h"

// Simple surface description for supported texture formats

#define DDTF_BGRA               0
#define DDTF_BGR                1
#define DDTF_PALETTED           2

typedef struct _DDTEXFORMAT
{
    int iFormat;
    int cColorBits;
} DDTEXFORMAT;

// Supported formats
static DDTEXFORMAT ddtfFormats[] =
{
    DDTF_BGRA, 32,
    DDTF_BGR, 32,
    DDTF_PALETTED, 8
};
#define NDDTF (sizeof(ddtfFormats)/sizeof(ddtfFormats[0]))

/******************************Public*Routine******************************\
*
* DescribeDdtf
*
* Fill out a DDSURFACEDESC from a DDTEXFORMAT
*
* History:
*  Tue Sep 03 18:16:50 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void DescribeDdtf(DDTEXFORMAT *pddtf, DDSURFACEDESC *pddsd)
{
    memset(pddsd, 0, sizeof(*pddsd));
    pddsd->dwSize = sizeof(*pddsd);
    pddsd->dwFlags = DDSD_CAPS | DDSD_PIXELFORMAT;
    pddsd->ddsCaps.dwCaps = DDSCAPS_MIPMAP | DDSCAPS_TEXTURE;
    pddsd->ddpfPixelFormat.dwFlags = DDPF_RGB;
    pddsd->ddpfPixelFormat.dwRGBBitCount = pddtf->cColorBits;
    switch(pddtf->iFormat)
    {
    case DDTF_BGRA:
        pddsd->dwFlags |= DDSD_ALPHABITDEPTH;
        pddsd->dwAlphaBitDepth = pddtf->cColorBits/4;
        pddsd->ddsCaps.dwCaps |= DDSCAPS_ALPHA;
        pddsd->ddpfPixelFormat.dwFlags |= DDPF_ALPHAPIXELS;
        // Fall through
    case DDTF_BGR:
        switch(pddtf->cColorBits)
        {
        case 32:
            pddsd->ddpfPixelFormat.dwRBitMask = 0xff0000;
            pddsd->ddpfPixelFormat.dwGBitMask = 0xff00;
            pddsd->ddpfPixelFormat.dwBBitMask = 0xff;
            if (pddtf->iFormat == DDTF_BGRA)
            {
                pddsd->ddpfPixelFormat.dwRGBAlphaBitMask = 0xff000000;
            }
            break;
        }
        break;
    case DDTF_PALETTED:
        switch(pddtf->cColorBits)
        {
        case 1:
            pddsd->ddpfPixelFormat.dwFlags |= DDPF_PALETTEINDEXED1;
            break;
        case 2:
            pddsd->ddpfPixelFormat.dwFlags |= DDPF_PALETTEINDEXED2;
            break;
        case 4:
            pddsd->ddpfPixelFormat.dwFlags |= DDPF_PALETTEINDEXED4;
            break;
        case 8:
            pddsd->ddpfPixelFormat.dwFlags |= DDPF_PALETTEINDEXED8;
            break;
        }
        break;
    }
}

/******************************Public*Routine******************************\
*
* CacheTextureFormats
*
* Creates list of valid texture formats for a context
*
* History:
*  Fri Sep 27 16:14:29 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL CacheTextureFormats(PLRC plrc)
{
    int i;
    int nFmts;
    int nMcdFmts;
    DDTEXFORMAT *pddtf;
    DDSURFACEDESC *pddsdAlloc, *pddsd;
    __GLGENcontext *gengc;

    ASSERTOPENGL(plrc->pddsdTexFormats == NULL,
                 "CacheTextureFormats overwriting cache\n");

    if (plrc->dhrc != 0)
    {
        // Call the ICD
        if (plrc->pGLDriver->pfnDrvEnumTextureFormats == NULL)
        {
            nFmts = 0;
        }
        else
        {
            nFmts = plrc->pGLDriver->pfnDrvEnumTextureFormats(0, NULL);
            if (nFmts < 0)
            {
                return FALSE;
            }
        }
    }
    else
    {
        gengc = (__GLGENcontext *)GLTEB_SRVCONTEXT();
        ASSERTOPENGL(gengc != NULL, "No server context\n");

        nFmts = NDDTF;
        nMcdFmts = 0;

#if MCD_VER_MAJOR >= 2 || (MCD_VER_MAJOR == 1 && MCD_VER_MINOR >= 0x10)
        if (gengc->pMcdState != NULL &&
            McdDriverInfo.mcdDriver.pMCDrvGetTextureFormats != NULL)
        {
            nMcdFmts = GenMcdGetTextureFormats(gengc, 0, NULL);
            if (nMcdFmts < 0)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
            }
            
            nFmts += nMcdFmts;
        }
#endif // 1.1
    }
        
    pddsdAlloc = (DDSURFACEDESC *)ALLOC(sizeof(DDSURFACEDESC)*nFmts);
    if (pddsdAlloc == NULL)
    {
        return FALSE;
    }

    if (plrc->dhrc != 0)
    {
        if (nFmts > 0)
        {
            nFmts = plrc->pGLDriver->pfnDrvEnumTextureFormats(nFmts,
                                                              pddsdAlloc);
            if (nFmts < 0)
            {
                FREE(pddsdAlloc);
                return FALSE;
            }
        }
    }
    else
    {
        pddsd = pddsdAlloc;
        pddtf = ddtfFormats;
        for (i = 0; i < NDDTF; i++)
        {
            DescribeDdtf(pddtf, pddsd);
            pddtf++;
            pddsd++;
        }

        if (gengc->pMcdState != NULL && nMcdFmts > 0)
        {
            nMcdFmts = GenMcdGetTextureFormats(gengc, nMcdFmts, pddsd);
            if (nMcdFmts < 0)
            {
                FREE(pddsdAlloc);
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
            }
        }
    }

    plrc->pddsdTexFormats = pddsdAlloc;
    plrc->nDdTexFormats = nFmts;
    
    return TRUE;
}

/******************************Public*Routine******************************\
*
* wglEnumTextureFormats
*
* Enumerates texture formats supported for DirectDraw surfaces
*
* History:
*  Tue Sep 03 17:52:17 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#ifdef ALLOW_DDTEX
BOOL WINAPI wglEnumTextureFormats(WGLENUMTEXTUREFORMATSCALLBACK pfnCallback,
                                  LPVOID pvUser)
{
    int i;
    DDSURFACEDESC *pddsd;
    BOOL bRet = TRUE;
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();
    if (plrc == NULL)
    {
        SetLastError(ERROR_INVALID_FUNCTION);
        return FALSE;
    }

    glFlush();
    
    if (plrc->pddsdTexFormats == NULL &&
        !CacheTextureFormats(plrc))
    {
        return FALSE;
    }

    pddsd = plrc->pddsdTexFormats;
    for (i = 0; i < plrc->nDdTexFormats; i++)
    {
        if (!pfnCallback(pddsd, pvUser))
        {
            break;
        }
        
        pddsd++;
    }

    // Should this return FALSE if the enumeration was terminated?
    return bRet;
}
#endif

/******************************Public*Routine******************************\
*
* wglBindDirectDrawTexture
*
* Makes a DirectDraw surface the current 2D texture source
*
* History:
*  Tue Sep 03 17:53:43 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL WINAPI wglBindDirectDrawTexture(LPDIRECTDRAWSURFACE pdds)
{
    DDSURFACEDESC ddsd;
    int i;
    DDSURFACEDESC *pddsd;
    __GLcontext *gc;
    int iLev = 0;
    PLRC plrc;
    LPDIRECTDRAWSURFACE apdds[__GL_WGL_MAX_MIPMAP_LEVEL];
    GLuint ulFlags;

    plrc = GLTEB_CLTCURRENTRC();
    if (plrc == NULL)
    {
        SetLastError(ERROR_INVALID_FUNCTION);
        return FALSE;
    }

    glFlush();

    if (plrc->dhrc != 0)
    {
        if (plrc->pGLDriver->pfnDrvBindDirectDrawTexture == NULL)
        {
            SetLastError(ERROR_INVALID_FUNCTION);
            return FALSE;
        }
    }
    else
    {
        gc = (__GLcontext *)GLTEB_SRVCONTEXT();
        ASSERTOPENGL(gc != NULL, "No server context\n");
    }

    if (pdds == NULL)
    {
        // Clear any previous binding
        if (plrc->dhrc != 0)
        {
            return plrc->pGLDriver->pfnDrvBindDirectDrawTexture(pdds);
        }
        else
        {
            glsrvUnbindDirectDrawTexture(gc);
            // If we're just unbinding, we're done
            return TRUE;
        }
    }
    
    memset(&ddsd, 0, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);
    if (pdds->lpVtbl->GetSurfaceDesc(pdds, &ddsd) != DD_OK)
    {
        return FALSE;
    }

    // Surface must be a texture
    // Surface must have a width and height which are powers of two
    if ((ddsd.dwFlags & (DDSD_CAPS | DDSD_PIXELFORMAT | DDSD_WIDTH |
                         DDSD_HEIGHT)) !=
        (DDSD_CAPS | DDSD_PIXELFORMAT | DDSD_WIDTH | DDSD_HEIGHT) ||
        (ddsd.ddsCaps.dwCaps & DDSCAPS_TEXTURE) == 0 ||
        (ddsd.dwWidth & (ddsd.dwWidth-1)) != 0 ||
        (ddsd.dwHeight & (ddsd.dwHeight-1)) != 0)
    {
        return FALSE;
    }

    // Surface must match a supported format
    if (plrc->pddsdTexFormats == NULL &&
        !CacheTextureFormats(plrc))
    {
        return FALSE;
    }

    pddsd = plrc->pddsdTexFormats;
    for (i = 0; i < plrc->nDdTexFormats; i++)
    {
        if (ddsd.ddpfPixelFormat.dwFlags & DDPF_RGB)
        {
            if (ddsd.ddpfPixelFormat.dwRGBBitCount ==
		(DWORD)pddsd->ddpfPixelFormat.dwRGBBitCount)
            {
                if (ddsd.ddpfPixelFormat.dwRBitMask !=
                    pddsd->ddpfPixelFormat.dwRBitMask ||
                    ddsd.ddpfPixelFormat.dwGBitMask !=
                    pddsd->ddpfPixelFormat.dwGBitMask ||
                    ddsd.ddpfPixelFormat.dwBBitMask !=
                    pddsd->ddpfPixelFormat.dwBBitMask)
                {
                    return FALSE;
                }
                else
                {
                    break;
                }
            }
        }
        else
        {
            if ((ddsd.ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED1 |
                                                 DDPF_PALETTEINDEXED2 |
                                                 DDPF_PALETTEINDEXED4 |
                                                 DDPF_PALETTEINDEXED8)) !=
                (pddsd->ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED1 |
                                                   DDPF_PALETTEINDEXED2 |
                                                   DDPF_PALETTEINDEXED4 |
                                                   DDPF_PALETTEINDEXED8)))
            {
                return FALSE;
            }
            else
            {
                break;
            }
        }

        pddsd++;
    }

    if (i == plrc->nDdTexFormats)
    {
        return FALSE;
    }

    ulFlags = 0;

    if (i < NDDTF)
    {
        ulFlags |= DDTEX_GENERIC_FORMAT;
    }
    
    if (plrc->dhrc != 0)
    {
        return plrc->pGLDriver->pfnDrvBindDirectDrawTexture(pdds);
    }
    
    pdds->lpVtbl->AddRef(pdds);

    // Track whether the texture is in video memory or not.
    ulFlags |= DDTEX_VIDEO_MEMORY;
    if ((ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) == 0)
    {
        ulFlags &= ~DDTEX_VIDEO_MEMORY;
    }
    
    // If mipmaps are given, all mipmaps must be present
    if (ddsd.ddsCaps.dwCaps & DDSCAPS_MIPMAP)
    {
        DWORD dwWidth;
        DWORD dwHeight;
        LONG lPitch;
        int cColorBits;
        LPDIRECTDRAWSURFACE pddsMipmap, pddsNext;
        DDSCAPS ddscaps;
        DDSURFACEDESC ddsdMipmap;

        // Determine pixel depth
        if (ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED1)
        {
            cColorBits = 1;
        }
        else if (ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED2)
        {
            cColorBits = 2;
        }
        else if (ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED4)
        {
            cColorBits = 4;
        }
        else if (ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8)
        {
            cColorBits = 8;
        }
        else
        {
            ASSERTOPENGL(ddsd.ddpfPixelFormat.dwFlags & DDPF_RGB,
                         "DDPF_RGB expected\n");
            
            cColorBits =
                DdPixDepthToCount(pddsd->ddpfPixelFormat.dwRGBBitCount);
        }

        dwWidth = ddsd.dwWidth;
        dwHeight = ddsd.dwHeight;
        
        // Compute pitch from pixel depth.  The generic texturing code
        // doesn't support a pitch that differs from the natural pitch
        // given the width and depth of the surface.
        lPitch = (cColorBits*dwWidth+7)/8;

        if (ddsd.lPitch != lPitch)
        {
            goto CleanMipmap;
        }
        
        pddsMipmap = pdds;
        ddscaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
	ddsdMipmap.dwSize = sizeof(DDSURFACEDESC);
        for (;;)
        {
            apdds[iLev++] = pddsMipmap;

            if (pddsMipmap->lpVtbl->
                GetSurfaceDesc(pddsMipmap, &ddsdMipmap) != DD_OK ||
                ((ddsdMipmap.ddpfPixelFormat.dwFlags & DDPF_RGB) &&
                 ddsdMipmap.ddpfPixelFormat.dwRGBBitCount !=
                 ddsd.ddpfPixelFormat.dwRGBBitCount) ||
                ((ddsdMipmap.ddpfPixelFormat.dwFlags & DDPF_RGB) == 0 &&
                 (ddsdMipmap.ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED1 |
                                                        DDPF_PALETTEINDEXED2 |
                                                        DDPF_PALETTEINDEXED4 |
                                                        DDPF_PALETTEINDEXED8)) !=
                 (ddsd.ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED1 |
                                                  DDPF_PALETTEINDEXED2 |
                                                  DDPF_PALETTEINDEXED4 |
                                                  DDPF_PALETTEINDEXED8))) ||
                ddsdMipmap.dwWidth != dwWidth ||
                ddsdMipmap.dwHeight != dwHeight ||
                ddsdMipmap.lPitch != lPitch)
            {
                goto CleanMipmap;
            }

            if ((ddsdMipmap.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) == 0)
            {
                ulFlags &= ~DDTEX_VIDEO_MEMORY;
            }
            
            if (iLev > gc->constants.maxMipMapLevel ||
                (dwWidth == 1 && dwHeight == 1))
            {
                break;
            }
            
            if (pddsMipmap->lpVtbl->
                GetAttachedSurface(pddsMipmap, &ddscaps, &pddsNext) != DD_OK)
            {
                goto CleanMipmap;
            }
            pddsMipmap = pddsNext;

            if (dwWidth != 1)
            {
                dwWidth >>= 1;
                lPitch >>= 1;
            }
            if (dwHeight != 1)
            {
                dwHeight >>= 1;
            }
        }
    }
    else
    {
        apdds[iLev++] = pdds;
    }

    if (glsrvBindDirectDrawTexture(gc, iLev, apdds, &ddsd, ulFlags))
    {
        return TRUE;
    }

 CleanMipmap:
    while (--iLev >= 0)
    {
        apdds[iLev]->lpVtbl->Release(apdds[iLev]);
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\compsize.c ===
/******************************Module*Header*******************************\
* Module Name: compsize.c
*
* Functions to compute size of input buffer.
*
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#ifndef _CLIENTSIDE_
#include "precomp.h"
#pragma hdrstop

#include "compsize.h"
#include "glsize.h"

// Server code will flag the bad enum

#define GL_BAD_SIZE(x)   {return(0);}

static GLint gaiMapSize[] = {
                4,  //GL_MAP1_COLOR_4        , GL_MAP2_COLOR_4
                1,  //GL_MAP1_INDEX          , GL_MAP2_INDEX
                3,  //GL_MAP1_NORMAL         , GL_MAP2_NORMAL
                1,  //GL_MAP1_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_1
                2,  //GL_MAP1_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_2
                3,  //GL_MAP1_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_3
                4,  //GL_MAP1_TEXTURE_COORD_4, GL_MAP2_TEXTURE_COORD_4
                3,  //GL_MAP1_VERTEX_3       , GL_MAP2_VERTEX_3
                4,  //GL_MAP1_VERTEX_4       , GL_MAP2_VERTEX_4
                };

#define RANGE_MAP1SIZE(n) RANGE(n,GL_MAP1_COLOR_4,GL_MAP1_VERTEX_4)
#define MAP1SIZE(n)       gaiMapSize[(n)-GL_MAP1_COLOR_4]
#define RANGE_MAP2SIZE(n) RANGE(n,GL_MAP2_COLOR_4,GL_MAP2_VERTEX_4)
#define MAP2SIZE(n)       gaiMapSize[(n)-GL_MAP2_COLOR_4]

GLint gaiGLTypeSize[] = {
         1,  //GL_BYTE
         1,  //GL_UNSIGNED_BYTE
         2,  //GL_SHORT
         2,  //GL_UNSIGNED_SHORT
         4,  //GL_INT
         4,  //GL_UNSIGNED_INT
         4,  //GL_FLOAT
         2,  //GL_2_BYTES
         3,  //GL_3_BYTES
         4   //GL_4_BYTES
         };

GLint __glCallLists_size(GLint n, GLenum type)
{
    if ( RANGE_GLTYPESIZE(type) )
        return(GLTYPESIZE(type) * n);

    GL_BAD_SIZE(type);
}

GLint __glCltMap1_size(GLenum target)
{
    if (RANGE_MAP1SIZE(target))
        return(MAP1SIZE(target));

    GL_BAD_SIZE(target);
}

//XXX Optimize if (vstride != MAP2SIZE) or (ustride != MAP2SIZE * vorder)
//XXX by changing vstride to MAP1SIZE, ustride to MAPSIZE * vorder
//XXX and copying minimal data to the shared memory window.

GLint __glCltMap2_size(GLenum target)
{
// PTAR: (uorder - 1) ???
// How come nothing is done with target?
//
//    if (RANGE_MAP2SIZE(target)
//     && ustride >= MAP2SIZE(target) && vstride >= MAP2SIZE(target)
//     && uorder >= 1 && vorder >= 1)
//        return(ustride * (uorder - 1) + vstride * vorder);

    if (RANGE_MAP2SIZE(target))
        return(MAP2SIZE(target));

    GL_BAD_SIZE(target);
}

GLint __glGetMap_size(GLenum target, GLenum query)
{
    GLint order, majorMinor[2];

    if ( RANGE_MAP1SIZE(target) )
    {
        switch (query)
        {
        case GL_COEFF:
            glGetMapiv(target, GL_ORDER, &order);
            return (order * MAP1SIZE(target));
        case GL_ORDER:
            return 1;
        case GL_DOMAIN:
            return 2;
        }
    }
    else if ( RANGE_MAP2SIZE(target) )
    {
        switch (query)
        {
        case GL_COEFF:
            glGetMapiv(target, GL_ORDER, majorMinor);
            return (majorMinor[0] * majorMinor[1] * MAP2SIZE(target));
        case GL_ORDER:
            return 2;
        case GL_DOMAIN:
            return 4;
        }
    }

    GL_BAD_SIZE(target);
}

GLint __glGetPixelMap_size(GLenum map)
{
    GLint size;

    if ( RANGE(map, GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_A_TO_A) )
    {
    // For each GL_PIXEL_* there is a corresponding GL_PIXEL_*_SIZE
    // for which we can call glGetIntergerv.  We convert GL_PIXEL_*
    // to GL_PIXEL_*_SIZE by exploiting the contiguous nature of the
    // indices (i.e., we add to map the offset of the GL_PIXEL_*_SIZE
    // range from the GL_PIXEL_* range).

        glGetIntegerv(map+(GL_PIXEL_MAP_I_TO_I_SIZE - GL_PIXEL_MAP_I_TO_I), &size);
        return size;
    }

    GL_BAD_SIZE(map);
}

#define GET_INDEX_MIN      GL_CURRENT_COLOR
#define GET_INDEX_MAX      GL_TEXTURE_2D

static GLubyte gabGetSize[GET_INDEX_MAX - GET_INDEX_MIN + 1] = 
{
    4,   // GL_CURRENT_COLOR                 0x0B00
    1,   // GL_CURRENT_INDEX                 0x0B01
    3,   // GL_CURRENT_NORMAL                0x0B02
    4,   // GL_CURRENT_TEXTURE_COORDS        0x0B03
    4,   // GL_CURRENT_RASTER_COLOR          0x0B04
    1,   // GL_CURRENT_RASTER_INDEX          0x0B05
    4,   // GL_CURRENT_RASTER_TEXTURE_COORDS 0x0B06
    4,   // GL_CURRENT_RASTER_POSITION       0x0B07
    1,   // GL_CURRENT_RASTER_POSITION_VALID 0x0B08
    1,   // GL_CURRENT_RASTER_DISTANCE       0x0B09
    0,   //                                  0x0B0A
    0,   //                                  0x0B0B
    0,   //                                  0x0B0C
    0,   //                                  0x0B0D
    0,   //                                  0x0B0E
    0,   //                                  0x0B0F
    1,   // GL_POINT_SMOOTH                  0x0B10
    1,   // GL_POINT_SIZE                    0x0B11
    2,   // GL_POINT_SIZE_RANGE              0x0B12
    1,   // GL_POINT_SIZE_GRANULARITY        0x0B13
    0,   //                                  0x0B14
    0,   //                                  0x0B15
    0,   //                                  0x0B16
    0,   //                                  0x0B17
    0,   //                                  0x0B18
    0,   //                                  0x0B19
    0,   //                                  0x0B1A
    0,   //                                  0x0B1B
    0,   //                                  0x0B1C
    0,   //                                  0x0B1D
    0,   //                                  0x0B1E
    0,   //                                  0x0B1F
    1,   // GL_LINE_SMOOTH                   0x0B20
    1,   // GL_LINE_WIDTH                    0x0B21
    2,   // GL_LINE_WIDTH_RANGE              0x0B22
    1,   // GL_LINE_WIDTH_GRANULARITY        0x0B23
    1,   // GL_LINE_STIPPLE                  0x0B24
    1,   // GL_LINE_STIPPLE_PATTERN          0x0B25
    1,   // GL_LINE_STIPPLE_REPEAT           0x0B26
    0,   //                                  0x0B27
    0,   //                                  0x0B28
    0,   //                                  0x0B29
    0,   //                                  0x0B2A
    0,   //                                  0x0B2B
    0,   //                                  0x0B2C
    0,   //                                  0x0B2D
    0,   //                                  0x0B2E
    0,   //                                  0x0B2F
    1,   // GL_LIST_MODE                     0x0B30
    1,   // GL_MAX_LIST_NESTING              0x0B31
    1,   // GL_LIST_BASE                     0x0B32
    1,   // GL_LIST_INDEX                    0x0B33
    0,   //                                  0x0B34
    0,   //                                  0x0B35
    0,   //                                  0x0B36
    0,   //                                  0x0B37
    0,   //                                  0x0B38
    0,   //                                  0x0B39
    0,   //                                  0x0B3A
    0,   //                                  0x0B3B
    0,   //                                  0x0B3C
    0,   //                                  0x0B3D
    0,   //                                  0x0B3E
    0,   //                                  0x0B3F
    2,   // GL_POLYGON_MODE                  0x0B40
    1,   // GL_POLYGON_SMOOTH                0x0B41
    1,   // GL_POLYGON_STIPPLE               0x0B42
    1,   // GL_EDGE_FLAG                     0x0B43
    1,   // GL_CULL_FACE                     0x0B44
    1,   // GL_CULL_FACE_MODE                0x0B45
    1,   // GL_FRONT_FACE                    0x0B46
    0,   //                                  0x0B47
    0,   //                                  0x0B48
    0,   //                                  0x0B49
    0,   //                                  0x0B4A
    0,   //                                  0x0B4B
    0,   //                                  0x0B4C
    0,   //                                  0x0B4D
    0,   //                                  0x0B4E
    0,   //                                  0x0B4F
    1,   // GL_LIGHTING                      0x0B50
    1,   // GL_LIGHT_MODEL_LOCAL_VIEWER      0x0B51
    1,   // GL_LIGHT_MODEL_TWO_SIDE          0x0B52
    4,   // GL_LIGHT_MODEL_AMBIENT           0x0B53
    1,   // GL_SHADE_MODEL                   0x0B54
    1,   // GL_COLOR_MATERIAL_FACE           0x0B55
    1,   // GL_COLOR_MATERIAL_PARAMETER      0x0B56
    1,   // GL_COLOR_MATERIAL                0x0B57
    0,   //                                  0x0B58
    0,   //                                  0x0B59
    0,   //                                  0x0B5A
    0,   //                                  0x0B5B
    0,   //                                  0x0B5C
    0,   //                                  0x0B5D
    0,   //                                  0x0B5E
    0,   //                                  0x0B5F
    1,   // GL_FOG                           0x0B60
    1,   // GL_FOG_INDEX                     0x0B61
    1,   // GL_FOG_DENSITY                   0x0B62
    1,   // GL_FOG_START                     0x0B63
    1,   // GL_FOG_END                       0x0B64
    1,   // GL_FOG_MODE                      0x0B65
    4,   // GL_FOG_COLOR                     0x0B66
    0,   //                                  0x0B67
    0,   //                                  0x0B68
    0,   //                                  0x0B69
    0,   //                                  0x0B6A
    0,   //                                  0x0B6B
    0,   //                                  0x0B6C
    0,   //                                  0x0B6D
    0,   //                                  0x0B6E
    0,   //                                  0x0B6F
    2,   // GL_DEPTH_RANGE                   0x0B70
    1,   // GL_DEPTH_TEST                    0x0B71
    1,   // GL_DEPTH_WRITEMASK               0x0B72
    1,   // GL_DEPTH_CLEAR_VALUE             0x0B73
    1,   // GL_DEPTH_FUNC                    0x0B74
    0,   //                                  0x0B75
    0,   //                                  0x0B76
    0,   //                                  0x0B77
    0,   //                                  0x0B78
    0,   //                                  0x0B79
    0,   //                                  0x0B7A
    0,   //                                  0x0B7B
    0,   //                                  0x0B7C
    0,   //                                  0x0B7D
    0,   //                                  0x0B7E
    0,   //                                  0x0B7F
    4,   // GL_ACCUM_CLEAR_VALUE             0x0B80
    0,   //                                  0x0B81
    0,   //                                  0x0B82
    0,   //                                  0x0B83
    0,   //                                  0x0B84
    0,   //                                  0x0B85
    0,   //                                  0x0B86
    0,   //                                  0x0B87
    0,   //                                  0x0B88
    0,   //                                  0x0B89
    0,   //                                  0x0B8A
    0,   //                                  0x0B8B
    0,   //                                  0x0B8C
    0,   //                                  0x0B8D
    0,   //                                  0x0B8E
    0,   //                                  0x0B8F
    1,   // GL_STENCIL_TEST                  0x0B90
    1,   // GL_STENCIL_CLEAR_VALUE           0x0B91
    1,   // GL_STENCIL_FUNC                  0x0B92
    1,   // GL_STENCIL_VALUE_MASK            0x0B93
    1,   // GL_STENCIL_FAIL                  0x0B94
    1,   // GL_STENCIL_PASS_DEPTH_FAIL       0x0B95
    1,   // GL_STENCIL_PASS_DEPTH_PASS       0x0B96
    1,   // GL_STENCIL_REF                   0x0B97
    1,   // GL_STENCIL_WRITEMASK             0x0B98
    0,   //                                  0x0B99
    0,   //                                  0x0B9A
    0,   //                                  0x0B9B
    0,   //                                  0x0B9C
    0,   //                                  0x0B9D
    0,   //                                  0x0B9E
    0,   //                                  0x0B9F
    1,   // GL_MATRIX_MODE                   0x0BA0
    1,   // GL_NORMALIZE                     0x0BA1
    4,   // GL_VIEWPORT                      0x0BA2
    1,   // GL_MODELVIEW_STACK_DEPTH         0x0BA3
    1,   // GL_PROJECTION_STACK_DEPTH        0x0BA4
    1,   // GL_TEXTURE_STACK_DEPTH           0x0BA5
    16,  // GL_MODELVIEW_MATRIX              0x0BA6
    16,  // GL_PROJECTION_MATRIX             0x0BA7
    16,  // GL_TEXTURE_MATRIX                0x0BA8
    0,   //                                  0x0BA9
    0,   //                                  0x0BAA
    0,   //                                  0x0BAB
    0,   //                                  0x0BAC
    0,   //                                  0x0BAD
    0,   //                                  0x0BAE
    0,   //                                  0x0BAF
    1,   // GL_ATTRIB_STACK_DEPTH            0x0BB0
    0,   //                                  0x0BB1
    0,   //                                  0x0BB2
    0,   //                                  0x0BB3
    0,   //                                  0x0BB4
    0,   //                                  0x0BB5
    0,   //                                  0x0BB6
    0,   //                                  0x0BB7
    0,   //                                  0x0BB8
    0,   //                                  0x0BB9
    0,   //                                  0x0BBA
    0,   //                                  0x0BBB
    0,   //                                  0x0BBC
    0,   //                                  0x0BBD
    0,   //                                  0x0BBE
    0,   //                                  0x0BBF
    1,   // GL_ALPHA_TEST                    0x0BC0
    1,   // GL_ALPHA_TEST_FUNC               0x0BC1
    1,   // GL_ALPHA_TEST_REF                0x0BC2
    0,   //                                  0x0BC3
    0,   //                                  0x0BC4
    0,   //                                  0x0BC5
    0,   //                                  0x0BC6
    0,   //                                  0x0BC7
    0,   //                                  0x0BC8
    0,   //                                  0x0BC9
    0,   //                                  0x0BCA
    0,   //                                  0x0BCB
    0,   //                                  0x0BCC
    0,   //                                  0x0BCD
    0,   //                                  0x0BCE
    0,   //                                  0x0BCF
    1,   // GL_DITHER                        0x0BD0
    0,   //                                  0x0BD1
    0,   //                                  0x0BD2
    0,   //                                  0x0BD3
    0,   //                                  0x0BD4
    0,   //                                  0x0BD5
    0,   //                                  0x0BD6
    0,   //                                  0x0BD7
    0,   //                                  0x0BD8
    0,   //                                  0x0BD9
    0,   //                                  0x0BDA
    0,   //                                  0x0BDB
    0,   //                                  0x0BDC
    0,   //                                  0x0BDD
    0,   //                                  0x0BDE
    0,   //                                  0x0BDF
    1,   // GL_BLEND_DST                     0x0BE0
    1,   // GL_BLEND_SRC                     0x0BE1
    1,   // GL_BLEND                         0x0BE2
    0,   //                                  0x0BE3
    0,   //                                  0x0BE4
    0,   //                                  0x0BE5
    0,   //                                  0x0BE6
    0,   //                                  0x0BE7
    0,   //                                  0x0BE8
    0,   //                                  0x0BE9
    0,   //                                  0x0BEA
    0,   //                                  0x0BEB
    0,   //                                  0x0BEC
    0,   //                                  0x0BED
    0,   //                                  0x0BEE
    0,   //                                  0x0BEF
    1,   // GL_LOGIC_OP_MODE                 0x0BF0
    1,   // GL_LOGIC_OP                      0x0BF1
    0,   //                                  0x0BF2
    0,   //                                  0x0BF3
    0,   //                                  0x0BF4
    0,   //                                  0x0BF5
    0,   //                                  0x0BF6
    0,   //                                  0x0BF7
    0,   //                                  0x0BF8
    0,   //                                  0x0BF9
    0,   //                                  0x0BFA
    0,   //                                  0x0BFB
    0,   //                                  0x0BFC
    0,   //                                  0x0BFD
    0,   //                                  0x0BFE
    0,   //                                  0x0BFF
    1,   // GL_AUX_BUFFERS                   0x0C00
    1,   // GL_DRAW_BUFFER                   0x0C01
    1,   // GL_READ_BUFFER                   0x0C02
    0,   //                                  0x0C03
    0,   //                                  0x0C04
    0,   //                                  0x0C05
    0,   //                                  0x0C06
    0,   //                                  0x0C07
    0,   //                                  0x0C08
    0,   //                                  0x0C09
    0,   //                                  0x0C0A
    0,   //                                  0x0C0B
    0,   //                                  0x0C0C
    0,   //                                  0x0C0D
    0,   //                                  0x0C0E
    0,   //                                  0x0C0F
    4,   // GL_SCISSOR_BOX                   0x0C10
    1,   // GL_SCISSOR_TEST                  0x0C11
    0,   //                                  0x0C12
    0,   //                                  0x0C13
    0,   //                                  0x0C14
    0,   //                                  0x0C15
    0,   //                                  0x0C16
    0,   //                                  0x0C17
    0,   //                                  0x0C18
    0,   //                                  0x0C19
    0,   //                                  0x0C1A
    0,   //                                  0x0C1B
    0,   //                                  0x0C1C
    0,   //                                  0x0C1D
    0,   //                                  0x0C1E
    0,   //                                  0x0C1F
    1,   // GL_INDEX_CLEAR_VALUE             0x0C20
    1,   // GL_INDEX_WRITEMASK               0x0C21
    4,   // GL_COLOR_CLEAR_VALUE             0x0C22
    4,   // GL_COLOR_WRITEMASK               0x0C23
    0,   //                                  0x0C24
    0,   //                                  0x0C25
    0,   //                                  0x0C26
    0,   //                                  0x0C27
    0,   //                                  0x0C28
    0,   //                                  0x0C29
    0,   //                                  0x0C2A
    0,   //                                  0x0C2B
    0,   //                                  0x0C2C
    0,   //                                  0x0C2D
    0,   //                                  0x0C2E
    0,   //                                  0x0C2F
    1,   // GL_INDEX_MODE                    0x0C30
    1,   // GL_RGBA_MODE                     0x0C31
    1,   // GL_DOUBLEBUFFER                  0x0C32
    1,   // GL_STEREO                        0x0C33
    0,   //                                  0x0C34
    0,   //                                  0x0C35
    0,   //                                  0x0C36
    0,   //                                  0x0C37
    0,   //                                  0x0C38
    0,   //                                  0x0C39
    0,   //                                  0x0C3A
    0,   //                                  0x0C3B
    0,   //                                  0x0C3C
    0,   //                                  0x0C3D
    0,   //                                  0x0C3E
    0,   //                                  0x0C3F
    1,   // GL_RENDER_MODE                   0x0C40
    0,   //                                  0x0C41
    0,   //                                  0x0C42
    0,   //                                  0x0C43
    0,   //                                  0x0C44
    0,   //                                  0x0C45
    0,   //                                  0x0C46
    0,   //                                  0x0C47
    0,   //                                  0x0C48
    0,   //                                  0x0C49
    0,   //                                  0x0C4A
    0,   //                                  0x0C4B
    0,   //                                  0x0C4C
    0,   //                                  0x0C4D
    0,   //                                  0x0C4E
    0,   //                                  0x0C4F
    1,   // GL_PERSPECTIVE_CORRECTION_HINT   0x0C50
    1,   // GL_POINT_SMOOTH_HINT             0x0C51
    1,   // GL_LINE_SMOOTH_HINT              0x0C52
    1,   // GL_POLYGON_SMOOTH_HINT           0x0C53
    1,   // GL_FOG_HINT                      0x0C54
    0,   //                                  0x0C55
    0,   //                                  0x0C56
    0,   //                                  0x0C57
    0,   //                                  0x0C58
    0,   //                                  0x0C59
    0,   //                                  0x0C5A
    0,   //                                  0x0C5B
    0,   //                                  0x0C5C
    0,   //                                  0x0C5D
    0,   //                                  0x0C5E
    0,   //                                  0x0C5F
    1,   // GL_TEXTURE_GEN_S                 0x0C60
    1,   // GL_TEXTURE_GEN_T                 0x0C61
    1,   // GL_TEXTURE_GEN_R                 0x0C62
    1,   // GL_TEXTURE_GEN_Q                 0x0C63
    0,   //                                  0x0C64
    0,   //                                  0x0C65
    0,   //                                  0x0C66
    0,   //                                  0x0C67
    0,   //                                  0x0C68
    0,   //                                  0x0C69
    0,   //                                  0x0C6A
    0,   //                                  0x0C6B
    0,   //                                  0x0C6C
    0,   //                                  0x0C6D
    0,   //                                  0x0C6E
    0,   //                                  0x0C6F
    0,   // GL_PIXEL_MAP_I_TO_I              0x0C70
    0,   // GL_PIXEL_MAP_S_TO_S              0x0C71
    0,   // GL_PIXEL_MAP_I_TO_R              0x0C72
    0,   // GL_PIXEL_MAP_I_TO_G              0x0C73
    0,   // GL_PIXEL_MAP_I_TO_B              0x0C74
    0,   // GL_PIXEL_MAP_I_TO_A              0x0C75
    0,   // GL_PIXEL_MAP_R_TO_R              0x0C76
    0,   // GL_PIXEL_MAP_G_TO_G              0x0C77
    0,   // GL_PIXEL_MAP_B_TO_B              0x0C78
    0,   // GL_PIXEL_MAP_A_TO_A              0x0C79
    0,   //                                  0x0C7A
    0,   //                                  0x0C7B
    0,   //                                  0x0C7C
    0,   //                                  0x0C7D
    0,   //                                  0x0C7E
    0,   //                                  0x0C7F
    0,   //                                  0x0C80
    0,   //                                  0x0C81
    0,   //                                  0x0C82
    0,   //                                  0x0C83
    0,   //                                  0x0C84
    0,   //                                  0x0C85
    0,   //                                  0x0C86
    0,   //                                  0x0C87
    0,   //                                  0x0C88
    0,   //                                  0x0C89
    0,   //                                  0x0C8A
    0,   //                                  0x0C8B
    0,   //                                  0x0C8C
    0,   //                                  0x0C8D
    0,   //                                  0x0C8E
    0,   //                                  0x0C8F
    0,   //                                  0x0C90
    0,   //                                  0x0C91
    0,   //                                  0x0C92
    0,   //                                  0x0C93
    0,   //                                  0x0C94
    0,   //                                  0x0C95
    0,   //                                  0x0C96
    0,   //                                  0x0C97
    0,   //                                  0x0C98
    0,   //                                  0x0C99
    0,   //                                  0x0C9A
    0,   //                                  0x0C9B
    0,   //                                  0x0C9C
    0,   //                                  0x0C9D
    0,   //                                  0x0C9E
    0,   //                                  0x0C9F
    0,   //                                  0x0CA0
    0,   //                                  0x0CA1
    0,   //                                  0x0CA2
    0,   //                                  0x0CA3
    0,   //                                  0x0CA4
    0,   //                                  0x0CA5
    0,   //                                  0x0CA6
    0,   //                                  0x0CA7
    0,   //                                  0x0CA8
    0,   //                                  0x0CA9
    0,   //                                  0x0CAA
    0,   //                                  0x0CAB
    0,   //                                  0x0CAC
    0,   //                                  0x0CAD
    0,   //                                  0x0CAE
    0,   //                                  0x0CAF
    1,   // GL_PIXEL_MAP_I_TO_I_SIZE         0x0CB0
    1,   // GL_PIXEL_MAP_S_TO_S_SIZE         0x0CB1
    1,   // GL_PIXEL_MAP_I_TO_R_SIZE         0x0CB2
    1,   // GL_PIXEL_MAP_I_TO_G_SIZE         0x0CB3
    1,   // GL_PIXEL_MAP_I_TO_B_SIZE         0x0CB4
    1,   // GL_PIXEL_MAP_I_TO_A_SIZE         0x0CB5
    1,   // GL_PIXEL_MAP_R_TO_R_SIZE         0x0CB6
    1,   // GL_PIXEL_MAP_G_TO_G_SIZE         0x0CB7
    1,   // GL_PIXEL_MAP_B_TO_B_SIZE         0x0CB8
    1,   // GL_PIXEL_MAP_A_TO_A_SIZE         0x0CB9
    0,   //                                  0x0CBA
    0,   //                                  0x0CBB
    0,   //                                  0x0CBC
    0,   //                                  0x0CBD
    0,   //                                  0x0CBE
    0,   //                                  0x0CBF
    0,   //                                  0x0CC0
    0,   //                                  0x0CC1
    0,   //                                  0x0CC2
    0,   //                                  0x0CC3
    0,   //                                  0x0CC4
    0,   //                                  0x0CC5
    0,   //                                  0x0CC6
    0,   //                                  0x0CC7
    0,   //                                  0x0CC8
    0,   //                                  0x0CC9
    0,   //                                  0x0CCA
    0,   //                                  0x0CCB
    0,   //                                  0x0CCC
    0,   //                                  0x0CCD
    0,   //                                  0x0CCE
    0,   //                                  0x0CCF
    0,   //                                  0x0CD0
    0,   //                                  0x0CD1
    0,   //                                  0x0CD2
    0,   //                                  0x0CD3
    0,   //                                  0x0CD4
    0,   //                                  0x0CD5
    0,   //                                  0x0CD6
    0,   //                                  0x0CD7
    0,   //                                  0x0CD8
    0,   //                                  0x0CD9
    0,   //                                  0x0CDA
    0,   //                                  0x0CDB
    0,   //                                  0x0CDC
    0,   //                                  0x0CDD
    0,   //                                  0x0CDE
    0,   //                                  0x0CDF
    0,   //                                  0x0CE0
    0,   //                                  0x0CE1
    0,   //                                  0x0CE2
    0,   //                                  0x0CE3
    0,   //                                  0x0CE4
    0,   //                                  0x0CE5
    0,   //                                  0x0CE6
    0,   //                                  0x0CE7
    0,   //                                  0x0CE8
    0,   //                                  0x0CE9
    0,   //                                  0x0CEA
    0,   //                                  0x0CEB
    0,   //                                  0x0CEC
    0,   //                                  0x0CED
    0,   //                                  0x0CEE
    0,   //                                  0x0CEF
    1,   // GL_UNPACK_SWAP_BYTES             0x0CF0
    1,   // GL_UNPACK_LSB_FIRST              0x0CF1
    1,   // GL_UNPACK_ROW_LENGTH             0x0CF2
    1,   // GL_UNPACK_SKIP_ROWS              0x0CF3
    1,   // GL_UNPACK_SKIP_PIXELS            0x0CF4
    1,   // GL_UNPACK_ALIGNMENT              0x0CF5
    0,   //                                  0x0CF6
    0,   //                                  0x0CF7
    0,   //                                  0x0CF8
    0,   //                                  0x0CF9
    0,   //                                  0x0CFA
    0,   //                                  0x0CFB
    0,   //                                  0x0CFC
    0,   //                                  0x0CFD
    0,   //                                  0x0CFE
    0,   //                                  0x0CFF
    1,   // GL_PACK_SWAP_BYTES               0x0D00
    1,   // GL_PACK_LSB_FIRST                0x0D01
    1,   // GL_PACK_ROW_LENGTH               0x0D02
    1,   // GL_PACK_SKIP_ROWS                0x0D03
    1,   // GL_PACK_SKIP_PIXELS              0x0D04
    1,   // GL_PACK_ALIGNMENT                0x0D05
    0,   //                                  0x0D06
    0,   //                                  0x0D07
    0,   //                                  0x0D08
    0,   //                                  0x0D09
    0,   //                                  0x0D0A
    0,   //                                  0x0D0B
    0,   //                                  0x0D0C
    0,   //                                  0x0D0D
    0,   //                                  0x0D0E
    0,   //                                  0x0D0F
    1,   // GL_MAP_COLOR                     0x0D10
    1,   // GL_MAP_STENCIL                   0x0D11
    1,   // GL_INDEX_SHIFT                   0x0D12
    1,   // GL_INDEX_OFFSET                  0x0D13
    1,   // GL_RED_SCALE                     0x0D14
    1,   // GL_RED_BIAS                      0x0D15
    1,   // GL_ZOOM_X                        0x0D16
    1,   // GL_ZOOM_Y                        0x0D17
    1,   // GL_GREEN_SCALE                   0x0D18
    1,   // GL_GREEN_BIAS                    0x0D19
    1,   // GL_BLUE_SCALE                    0x0D1A
    1,   // GL_BLUE_BIAS                     0x0D1B
    1,   // GL_ALPHA_SCALE                   0x0D1C
    1,   // GL_ALPHA_BIAS                    0x0D1D
    1,   // GL_DEPTH_SCALE                   0x0D1E
    1,   // GL_DEPTH_BIAS                    0x0D1F
    0,   //                                  0x0D20
    0,   //                                  0x0D21
    0,   //                                  0x0D22
    0,   //                                  0x0D23
    0,   //                                  0x0D24
    0,   //                                  0x0D25
    0,   //                                  0x0D26
    0,   //                                  0x0D27
    0,   //                                  0x0D28
    0,   //                                  0x0D29
    0,   //                                  0x0D2A
    0,   //                                  0x0D2B
    0,   //                                  0x0D2C
    0,   //                                  0x0D2D
    0,   //                                  0x0D2E
    0,   //                                  0x0D2F
    1,   // GL_MAX_EVAL_ORDER                0x0D30
    1,   // GL_MAX_LIGHTS                    0x0D31
    1,   // GL_MAX_CLIP_PLANES               0x0D32
    1,   // GL_MAX_TEXTURE_SIZE              0x0D33
    1,   // GL_MAX_PIXEL_MAP_TABLE           0x0D34
    1,   // GL_MAX_ATTRIB_STACK_DEPTH        0x0D35
    1,   // GL_MAX_MODELVIEW_STACK_DEPTH     0x0D36
    1,   // GL_MAX_NAME_STACK_DEPTH          0x0D37
    1,   // GL_MAX_PROJECTION_STACK_DEPTH    0x0D38
    1,   // GL_MAX_TEXTURE_STACK_DEPTH       0x0D39
    2,   // GL_MAX_VIEWPORT_DIMS             0x0D3A
    0,   //                                  0x0D3B
    0,   //                                  0x0D3C
    0,   //                                  0x0D3D
    0,   //                                  0x0D3E
    0,   //                                  0x0D3F
    0,   //                                  0x0D40
    0,   //                                  0x0D41
    0,   //                                  0x0D42
    0,   //                                  0x0D43
    0,   //                                  0x0D44
    0,   //                                  0x0D45
    0,   //                                  0x0D46
    0,   //                                  0x0D47
    0,   //                                  0x0D48
    0,   //                                  0x0D49
    0,   //                                  0x0D4A
    0,   //                                  0x0D4B
    0,   //                                  0x0D4C
    0,   //                                  0x0D4D
    0,   //                                  0x0D4E
    0,   //                                  0x0D4F
    1,   // GL_SUBPIXEL_BITS                 0x0D50
    1,   // GL_INDEX_BITS                    0x0D51
    1,   // GL_RED_BITS                      0x0D52
    1,   // GL_GREEN_BITS                    0x0D53
    1,   // GL_BLUE_BITS                     0x0D54
    1,   // GL_ALPHA_BITS                    0x0D55
    1,   // GL_DEPTH_BITS                    0x0D56
    1,   // GL_STENCIL_BITS                  0x0D57
    1,   // GL_ACCUM_RED_BITS                0x0D58
    1,   // GL_ACCUM_GREEN_BITS              0x0D59
    1,   // GL_ACCUM_BLUE_BITS               0x0D5A
    1,   // GL_ACCUM_ALPHA_BITS              0x0D5B
    0,   //                                  0x0D5C
    0,   //                                  0x0D5D
    0,   //                                  0x0D5E
    0,   //                                  0x0D5F
    0,   //                                  0x0D60
    0,   //                                  0x0D61
    0,   //                                  0x0D62
    0,   //                                  0x0D63
    0,   //                                  0x0D64
    0,   //                                  0x0D65
    0,   //                                  0x0D66
    0,   //                                  0x0D67
    0,   //                                  0x0D68
    0,   //                                  0x0D69
    0,   //                                  0x0D6A
    0,   //                                  0x0D6B
    0,   //                                  0x0D6C
    0,   //                                  0x0D6D
    0,   //                                  0x0D6E
    0,   //                                  0x0D6F
    1,   // GL_NAME_STACK_DEPTH              0x0D70
    0,   //                                  0x0D71
    0,   //                                  0x0D72
    0,   //                                  0x0D73
    0,   //                                  0x0D74
    0,   //                                  0x0D75
    0,   //                                  0x0D76
    0,   //                                  0x0D77
    0,   //                                  0x0D78
    0,   //                                  0x0D79
    0,   //                                  0x0D7A
    0,   //                                  0x0D7B
    0,   //                                  0x0D7C
    0,   //                                  0x0D7D
    0,   //                                  0x0D7E
    0,   //                                  0x0D7F
    1,   // GL_AUTO_NORMAL                   0x0D80
    0,   //                                  0x0D81
    0,   //                                  0x0D82
    0,   //                                  0x0D83
    0,   //                                  0x0D84
    0,   //                                  0x0D85
    0,   //                                  0x0D86
    0,   //                                  0x0D87
    0,   //                                  0x0D88
    0,   //                                  0x0D89
    0,   //                                  0x0D8A
    0,   //                                  0x0D8B
    0,   //                                  0x0D8C
    0,   //                                  0x0D8D
    0,   //                                  0x0D8E
    0,   //                                  0x0D8F
    1,   // GL_MAP1_COLOR_4                  0x0D90
    1,   // GL_MAP1_INDEX                    0x0D91
    1,   // GL_MAP1_NORMAL                   0x0D92
    1,   // GL_MAP1_TEXTURE_COORD_1          0x0D93
    1,   // GL_MAP1_TEXTURE_COORD_2          0x0D94
    1,   // GL_MAP1_TEXTURE_COORD_3          0x0D95
    1,   // GL_MAP1_TEXTURE_COORD_4          0x0D96
    1,   // GL_MAP1_VERTEX_3                 0x0D97
    1,   // GL_MAP1_VERTEX_4                 0x0D98
    0,   //                                  0x0D99
    0,   //                                  0x0D9A
    0,   //                                  0x0D9B
    0,   //                                  0x0D9C
    0,   //                                  0x0D9D
    0,   //                                  0x0D9E
    0,   //                                  0x0D9F
    0,   //                                  0x0DA0
    0,   //                                  0x0DA1
    0,   //                                  0x0DA2
    0,   //                                  0x0DA3
    0,   //                                  0x0DA4
    0,   //                                  0x0DA5
    0,   //                                  0x0DA6
    0,   //                                  0x0DA7
    0,   //                                  0x0DA8
    0,   //                                  0x0DA9
    0,   //                                  0x0DAA
    0,   //                                  0x0DAB
    0,   //                                  0x0DAC
    0,   //                                  0x0DAD
    0,   //                                  0x0DAE
    0,   //                                  0x0DAF
    1,   // GL_MAP2_COLOR_4                  0x0DB0
    1,   // GL_MAP2_INDEX                    0x0DB1
    1,   // GL_MAP2_NORMAL                   0x0DB2
    1,   // GL_MAP2_TEXTURE_COORD_1          0x0DB3
    1,   // GL_MAP2_TEXTURE_COORD_2          0x0DB4
    1,   // GL_MAP2_TEXTURE_COORD_3          0x0DB5
    1,   // GL_MAP2_TEXTURE_COORD_4          0x0DB6
    1,   // GL_MAP2_VERTEX_3                 0x0DB7
    1,   // GL_MAP2_VERTEX_4                 0x0DB8
    0,   //                                  0x0DB9
    0,   //                                  0x0DBA
    0,   //                                  0x0DBB
    0,   //                                  0x0DBC
    0,   //                                  0x0DBD
    0,   //                                  0x0DBE
    0,   //                                  0x0DBF
    0,   //                                  0x0DC0
    0,   //                                  0x0DC1
    0,   //                                  0x0DC2
    0,   //                                  0x0DC3
    0,   //                                  0x0DC4
    0,   //                                  0x0DC5
    0,   //                                  0x0DC6
    0,   //                                  0x0DC7
    0,   //                                  0x0DC8
    0,   //                                  0x0DC9
    0,   //                                  0x0DCA
    0,   //                                  0x0DCB
    0,   //                                  0x0DCC
    0,   //                                  0x0DCD
    0,   //                                  0x0DCE
    0,   //                                  0x0DCF
    2,   // GL_MAP1_GRID_DOMAIN              0x0DD0
    1,   // GL_MAP1_GRID_SEGMENTS            0x0DD1
    4,   // GL_MAP2_GRID_DOMAIN              0x0DD2
    2,   // GL_MAP2_GRID_SEGMENTS            0x0DD3
    0,   //                                  0x0DD4
    0,   //                                  0x0DD5
    0,   //                                  0x0DD6
    0,   //                                  0x0DD7
    0,   //                                  0x0DD8
    0,   //                                  0x0DD9
    0,   //                                  0x0DDA
    0,   //                                  0x0DDB
    0,   //                                  0x0DDC
    0,   //                                  0x0DDD
    0,   //                                  0x0DDE
    0,   //                                  0x0DDF
    1,   // GL_TEXTURE_1D                    0x0DE0
    1,   // GL_TEXTURE_2D                    0x0DE1
};

GLint __glGet_size(GLenum sq)
{
    if (RANGE(sq, GET_INDEX_MIN, GET_INDEX_MAX))
        return((GLint) gabGetSize[sq - GET_INDEX_MIN]);
    else if (RANGE(sq, GL_CLIP_PLANE0, GL_CLIP_PLANE5)
          || RANGE(sq, GL_LIGHT0, GL_LIGHT7))
        return(1);
    else
        return(0);
}
#endif //!_CLIENTSIDE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\fontextr.c ===
#include "precomp.h"
#pragma hdrstop

#include <commdlg.h>
#include <ptypes32.h>
#include <pwin32.h>
#include <math.h>

#include <GL\gl.h>
#include <GL\glu.h>

#include <imports.h>
#include <types.h>

#include "fontoutl.h"

// Extrusion types
#define EXTR_LINES    0
#define EXTR_POLYGONS 1

// Prim to prim transitions
#define EXTR_LINE_LINE      0
#define EXTR_LINE_CURVE     1
#define EXTR_CURVE_LINE     2
#define EXTR_CURVE_CURVE    3

static const double   CurveCurveCutoffAngle = PI/2.0;
static const double   LineCurveCutoffAngle = PI/4.0;

static BOOL   InitFaceBuf(      EXTRContext *ec );

#ifndef VARRAY
static void   DrawFacePolygons( EXTRContext *ec,
                                FLOAT       z );
#endif

static BOOL   DrawSidePolygons( EXTRContext *ec, 
                                LOOP_LIST   *pLoopList );

static void   DrawPrims(        EXTRContext *ec, 
                                LOOP        *pLoop );

static void   DrawQuads(        PRIM        *pPrim, 
                                FLOAT       zExtrusion );

static void   DrawQuadStrip(    EXTRContext *ec, 
                                PRIM        *pPrim );

static BOOL   AppendToFaceBuf(  EXTRContext *ec, 
                                FLOAT       value );

static BOOL   ReallocFaceBuf(   EXTRContext *ec );


static BOOL   CalculateFaceNormals(   LOOP        *pLoop, 
                                      GLenum      orientation );

static BOOL   CalculateVertexNormals( LOOP        *pLoop );

static void   ConsolidatePrims(       LOOP        *pLoop );

static double PrimNormAngle(          PRIM        *pPrimA, 
                                      PRIM        *pPrimB );

static int    PrimTransition(         PRIM        *pPrevPrim, 
                                      PRIM        *pPrim );

static GLenum LoopOrientation(        LOOP_LIST   *pLoopList );

static LOOP*  GetMaxExtentLoop(       LOOP_LIST   *pLoopList );

double        CalcAngle(              POINT2D     *v1, 
                                      POINT2D     *v2 );

static void   CalcNormal2d(           POINT2D     *p, 
                                      POINT2D     *n,
                                      GLenum      orientation );

static void   Normalize2d(            POINT2D     *n );

static void   AddVectors3d(           POINT3D     *v1, 
                                      POINT3D     *v2, 
                                      POINT3D     *n );

static void   FreeLoopMem(            LOOP        *pLoop );


#ifdef VARRAY

static PFNGLVERTEXPOINTEREXTPROC     glWFOVertexPointerEXT    ;
static PFNGLNORMALPOINTEREXTPROC     glWFONormalPointerEXT    ;
static PFNGLDRAWARRAYSEXTPROC        glWFODrawArraysEXT       ;

static BOOL InitVArray( EXTRContext *ec );
static BOOL VArrayBufSize( EXTRContext *ec, DWORD size );

#endif

/*****************************************************************************
 * exported functions
*****************************************************************************/

/*****************************************************************************
 * extr_Init
 *
 * Initialises extrusion for a wglUseFontOutline call

*****************************************************************************/

EXTRContext *
extr_Init( FLOAT extrusion, INT format )
{
    EXTRContext *ec;

    ec = (EXTRContext *) ALLOCZ(sizeof(EXTRContext) );

    if( !ec )
        return NULL;

    ec->zExtrusion = -extrusion;

    switch( format ) {
        case WGL_FONT_LINES :
            ec->extrType = EXTR_LINES;
#ifdef FONT_DEBUG
            ec->bSidePolys = FALSE;
            ec->bFacePolys = FALSE;
#endif
            break;
        case WGL_FONT_POLYGONS :
            ec->extrType = EXTR_POLYGONS;
#ifdef FONT_DEBUG
            ec->bSidePolys = TRUE;
            ec->bFacePolys = TRUE;
#endif
#ifdef VARRAY
            if( ! InitVArray( ec ) ) {
                FREE( ec );
                return NULL;
            }
#endif
            break;
        default:
            ASSERTOPENGL( FALSE, "extr_Init(): invalid format\n" );
    }
    return ec;
}

/*****************************************************************************
 * extr_Finish
 *
 * Finishes extrusion for a wglUseFontOutline call

*****************************************************************************/

void
extr_Finish( EXTRContext *ec )
{
#ifdef VARRAY
    if( ec->extrType == EXTR_POLYGONS )
        FREE( ec->vaBuf );
#endif
    FREE( ec );
}

/*****************************************************************************
 * extr_PolyInit
 *
 * Initializes the extrusion of a single glyph.
 * If the extrusion is polygonal, it sets up FaceBuf, which holds a buffer
 * of primitives for drawing the faces of the extruded glyphs.
 *
*****************************************************************************/

BOOL extr_PolyInit( EXTRContext *ec )
{
    if( ec->extrType == EXTR_LINES )
        return WFO_SUCCESS;

    ec->FaceBuf = (FLOAT *) NULL;
    if( !InitFaceBuf( ec ) ||
        !AppendToFaceBuf( ec, 0.0f) ) // primitive count at FaceBuf[0]
        return WFO_FAILURE;

    // initialize error flag
    ec->TessErrorOccurred = 0;

    return WFO_SUCCESS;
}

/*****************************************************************************
 * extr_PolyFinish
 *
 * Cleans up stuff from processing a single glyph

*****************************************************************************/

void extr_PolyFinish(  EXTRContext *ec )
{
    if( ec->extrType == EXTR_LINES )
        return;

    if( ec->FaceBuf ) {
        FREE( ec->FaceBuf );
        ec->FaceBuf = (FLOAT *) NULL;
    }
}

/*****************************************************************************
 * extr_DrawLines
 *
 * Draws the lines in a glyph loop for Line extrusion

*****************************************************************************/

void extr_DrawLines( EXTRContext *ec, LOOP_LIST *pLoopList )
{
    DWORD   nLoops, nVerts;
    POINT2D *p;
    LOOP    *pLoop;

    nLoops = pLoopList->nLoops;
    pLoop = pLoopList->LoopBuf;
    for( ; nLoops; nLoops--, pLoop++ ) {

        // Draw the back face loop

#ifdef FONT_DEBUG
        DrawColorCodedLineLoop( pLoop, ec->zExtrusion );
#else
        glBegin(GL_LINE_LOOP);

            nVerts = pLoop->nVerts - 1; // skip last point
            p = pLoop->VertBuf;
            for ( ; nVerts; nVerts--, p++ ) {
                glVertex3f( p->x, p->y, ec->zExtrusion );
            }

        glEnd();
#endif

        // Draw the lines along the sides

#ifdef FONT_DEBUG
        glColor3d( 0.0, 0.0, 1.0 );
#endif

        glBegin(GL_LINES);

            nVerts = pLoop->nVerts - 1; // skip last point
            p = pLoop->VertBuf;
            for( ; nVerts; nVerts--, p++ ) {
                glVertex2fv( (GLfloat *) p);
                glVertex3f( p->x, p->y, ec->zExtrusion );
            }

        glEnd();
    }
}

/*****************************************************************************
 * extr_glBegin
 *
 * Tesselation callback for glBegin.
 * Buffers data into FaceBuf
 *
*****************************************************************************/

void CALLBACK
extr_glBegin( GLenum primType, void *data )
{
    EXTRContext *ec = ((OFContext *)data)->ec;

    // buffer face data
    ec->FaceBuf[0] += 1.0f; // increment prim counter
    ec->FaceVertexCountIndex = ec->FaceBufIndex+1; // mark vertex count index

    if( !AppendToFaceBuf( ec, (FLOAT) primType ) ||  // enter prim type
        !AppendToFaceBuf( ec, 0.0f ) )               // vertex count
        ec->TessErrorOccurred = GLU_OUT_OF_MEMORY;
}

/*****************************************************************************
 * extr_glEnd
 *
 * Tesselation callback for glEnd.
 * Noop, since we are just tracking the tesselation at this point.
 *
*****************************************************************************/

void CALLBACK
extr_glEnd( void )
{
}

/*****************************************************************************
 * extr_glVertex
 *
 * Tesselation callback for glVertex.
 * Buffers data into FaceBuf
 *
*****************************************************************************/

void CALLBACK
extr_glVertex( GLfloat *v, void *data )
{
    EXTRContext *ec = ((OFContext *)data)->ec;

    // put vertex in face buffer
    if( !AppendToFaceBuf( ec, v[0]) || !AppendToFaceBuf( ec, v[1]) )
        ec->TessErrorOccurred = GLU_OUT_OF_MEMORY;

    // increment vertex counter
    ec->FaceBuf[ec->FaceVertexCountIndex] += 1.0f;
}


/*****************************************************************************
 * extr_DrawPolygons
 *
 * Draws the side and face polygons of a glyph for polygonal extrusion
 * Gets polygon information from LineBuf, which was created during
 * MakeLinesFromGlyph().

*****************************************************************************/

BOOL
extr_DrawPolygons( EXTRContext *ec, LOOP_LIST *pLoopList ) 
{
#ifdef FONT_DEBUG
    if( ec->bSidePolys )
        if( !DrawSidePolygons( ec, pLoopList ) ) {
            return WFO_FAILURE;
        }

    if( ec->bFacePolys ) {
        DrawFacePolygons( ec, 0.0f );              // front face
        DrawFacePolygons( ec, ec->zExtrusion );    // back face
    }
#else
    if( !DrawSidePolygons( ec, pLoopList ) )
        return WFO_FAILURE;

    DrawFacePolygons( ec, 0.0f );              // front face
    DrawFacePolygons( ec, ec->zExtrusion );    // back face
#endif

    return WFO_SUCCESS;
}


/*****************************************************************************
 * internal functions
*****************************************************************************/


/*****************************************************************************
 * DrawSidePolygons
 *
 * Draw the side prims, using several passes on each prim loop:
 *  1) Calculate face normals for all the prims
 *  2) Consolidate prims if possible
 *  3) Calculate vertex normals for curve prims
 *  4) Draw the prims
 * Side effects: sets glFrontFace 

*****************************************************************************/

static BOOL
DrawSidePolygons( EXTRContext *ec,
                  LOOP_LIST   *pLoopList )
{
    DWORD nLoops;
    LOOP *pLoop;
    GLenum orientation;

    nLoops = pLoopList->nLoops;
    if( !nLoops )
        return WFO_SUCCESS;

    /* 
     * Determine orientation of loop
     */
    orientation = LoopOrientation( pLoopList );

    glFrontFace( orientation );

    pLoop = pLoopList->LoopBuf;
    for( ; nLoops; nLoops--, pLoop++ ) {

        // Calculate face normals
        if( !CalculateFaceNormals( pLoop, orientation ) )
            return WFO_FAILURE;

        // Consolidate list of prims
        ConsolidatePrims( pLoop );

        // Calculate vertex normals
        if( !CalculateVertexNormals( pLoop ) ) {
            FreeLoopMem( pLoop ); // free mem alloc'd by CalculateFaceNormals
            return WFO_FAILURE;
        }
    
        DrawPrims( ec, pLoop );

        // Free memory allocated during loop processing
        FreeLoopMem( pLoop );
    }
    return WFO_SUCCESS;
}

/*****************************************************************************
 * FreeLoopMem
 *
 * Frees up memory associated with each prim loop

*****************************************************************************/

static void 
FreeLoopMem( LOOP *pLoop )
{
    PRIM *pPrim;

    if( !pLoop )
        return;

    if( pLoop->FNormBuf )
        FREE( pLoop->FNormBuf );
    if( pLoop->VNormBuf )
        FREE( pLoop->VNormBuf );
}

/*****************************************************************************
 * DrawPrims
 *
 * Draws a loop of Prims

*****************************************************************************/

static void 
DrawPrims( EXTRContext *ec, LOOP *pLoop )
{
    PRIM  *pPrim;
    DWORD nPrims;

    nPrims = pLoop->nPrims;
    pPrim = pLoop->PrimBuf;

    for( ; nPrims; nPrims--, pPrim++ ) {

        switch( pPrim->primType ) {
            case PRIM_LINE:
                DrawQuads( pPrim, ec->zExtrusion ); 
                break;

            case PRIM_CURVE:
                DrawQuadStrip( ec, pPrim ); 
                break;
        }
    }
}


//#define EXTRANORMAL 1

/*****************************************************************************
 * DrawQuads
 *
 * Draws independent quads of a PRIM.

*****************************************************************************/

static void
DrawQuads( PRIM *pPrim, FLOAT zExtrusion )
{
    POINT2D *p;
    POINT3D *pNorm;
    ULONG quadCount;

    quadCount = pPrim->nVerts - 1;

    glBegin( GL_QUADS );

        p = pPrim->pVert;
        pNorm = pPrim->pFNorm;

        while( quadCount-- ) {
            Normalize2d( (POINT2D *) pNorm );     // normalize
            glNormal3fv( (GLfloat *) pNorm );

            glVertex3f( p->x, p->y, 0.0f );
            glVertex3f( p->x, p->y, zExtrusion );
            p++;
#ifdef EXTRANORMAL
            glNormal3fv( (GLfloat *) pNorm );
#endif
            glVertex3f( p->x, p->y, zExtrusion );
            glVertex3f( p->x, p->y, 0.0f );
            pNorm++;
        }

    glEnd();
}

/*****************************************************************************
 * DrawQuadStrip
 *
 * Draws a quadstrip from a PRIM

*****************************************************************************/

static void
DrawQuadStrip( EXTRContext *ec, PRIM *pPrim )
{
#ifndef VARRAY
    POINT3D *pNorm;
    POINT2D *p;
    ULONG   nVerts;


    glBegin( GL_QUAD_STRIP );

        // initialize pointers, setup
        nVerts = pPrim->nVerts;
        p = pPrim->pVert;
        pNorm = pPrim->pVNorm;

        while( nVerts-- ) {
            glNormal3fv( (GLfloat *) pNorm );
            glVertex3f( p->x, p->y, 0.0f );
#ifdef EXTRANORMAL
            glNormal3fv( (GLfloat *) pNorm );
#endif
            glVertex3f( p->x, p->y, ec->zExtrusion );

            // reset pointers
            p++;  // next point
            pNorm++;  // next vertex normal
        }

    glEnd();
#else
    POINT3D *n;
    POINT2D *p;
    ULONG   nVerts;
    ULONG   i;
    FLOAT   *pDst, *pVert, *pNorm;

    nVerts = pPrim->nVerts;

    // For every vertex in prim, need in varray buf: 2 verts, 2 normals
    if( !VArrayBufSize( ec, nVerts * 2 * 2 * 3) )
        return; // nothing drawn
 
    // setup vertices

    p = pPrim->pVert;
    pVert = pDst = ec->vaBuf;
    for( i = 0; i < nVerts; i++, p++ ) {
        *pDst++ = p->x;
        *pDst++ = p->y;
        *pDst++ = 0.0f;
        *pDst++ = p->x;
        *pDst++ = p->y;
        *pDst++ = ec->zExtrusion;
    }

    // setup normals

    n = pPrim->pVNorm;
    pNorm = pDst;
    for( i = 0; i < nVerts; i++, n++ ) {
        *( ((POINT3D *) pDst)++ ) = *n;
        *( ((POINT3D *) pDst)++ ) = *n;
    }

    // send it
    glEnable(GL_NORMAL_ARRAY_EXT);
    glWFOVertexPointerEXT(3, GL_FLOAT, 0, nVerts*2, pVert );
    glWFONormalPointerEXT(   GL_FLOAT, 0, nVerts*2, pNorm );
    glWFODrawArraysEXT( GL_QUAD_STRIP, 0, nVerts*2);
    glDisable(GL_NORMAL_ARRAY_EXT);
#endif
}



/*****************************************************************************
 * DrawFacePolygons
 *
 * Draws the front or back facing polygons of a glyph.
 * If z is 0.0, the front face of the glyph is drawn, otherwise the back
 * face is drawn.

*****************************************************************************/
#ifdef VARRAY
void 
#else
static void 
#endif
DrawFacePolygons( EXTRContext *ec, FLOAT z )
{
    ULONG primCount, vertexCount;
    GLenum primType;
    FLOAT *FaceBuf = ec->FaceBuf;
    FLOAT *p;
#ifdef VARRAY
    POINT3D normal = {0.0f, 0.0f, 0.0f};
    FLOAT *pVert, *pNorm, *pDst;
    ULONG i;
#endif

    if( z == 0.0f ) {
        glNormal3f( 0.0f, 0.0f, 1.0f );
        glFrontFace( GL_CCW );
    } else {
        glNormal3f( 0.0f, 0.0f, -1.0f );
        glFrontFace( GL_CW );
    }

    primCount = (ULONG) FaceBuf[0];
    p = &FaceBuf[1];

#ifndef VARRAY
    while( primCount-- ) {
    
        primType = (GLenum) *p++;
        vertexCount = (ULONG) *p++;

        glBegin( primType ); 

        for( ; vertexCount; vertexCount--, p+=2 )
            glVertex3f( p[0], p[1], z );

        glEnd();
    }
#else
    if( z == 0.0f )
        normal.z = 1.0f;
    else
        normal.z = -1.0f;

    while( primCount-- ) {
    
        primType = (GLenum) *p++;
        vertexCount = (ULONG) *p++;

        if( !VArrayBufSize( ec, vertexCount * 3 ) )
            return; // nothing drawn
 
        pVert = pDst = ec->vaBuf;

        // put vertices into varray buf
        for( i = 0; i < vertexCount; i++, p+=2 ) {
            *pDst++ = p[0];
            *pDst++ = p[1];
            *pDst++ = z;
        }

        glWFOVertexPointerEXT(3, GL_FLOAT, 0, vertexCount, pVert );
        glWFODrawArraysEXT( primType, 0, vertexCount );
    }
#endif
}

/*****************************************************************************
 * ConsolidatePrims
 *
 *  Consolidate a loop of prims.
 *  Go through list of prims, consolidating consecutive Curve and Line prims
 *  When 2 prims are consolidated into one, the first prim is set to
 *  null by setting it's nVerts=0.  The second prim get's the first's stuff.
 *  If joining occured, the array of prims is compacted at the end.
 *

*****************************************************************************/

static void
ConsolidatePrims( LOOP *pLoop )
{
    DWORD nPrims, nJoined = 0;
    BOOL bJoined; 
    PRIM *pPrim, *pPrevPrim;
    int trans;
    double angle;

    nPrims = pLoop->nPrims;
    if( nPrims < 2 )
        return;

    pPrim = pLoop->PrimBuf;
    pPrevPrim = pPrim++;

    nPrims--; // nPrim-1 comparisons
    for( ; nPrims; nPrims--, pPrevPrim = pPrim++ ) {

        bJoined = FALSE;
        trans = PrimTransition( pPrevPrim, pPrim );
        switch( trans ) {
            case EXTR_LINE_LINE:
                // always consolidate 2 lines
                bJoined = TRUE;
                break;

            case EXTR_LINE_CURVE:
                break;

            case EXTR_CURVE_LINE:
                break;

            case EXTR_CURVE_CURVE:
                /*
                 * Join the prims if angle_between_norms < cutoff_angle
                 */
                angle = PrimNormAngle( pPrevPrim, pPrim );
                if( angle < CurveCurveCutoffAngle ) {
                    bJoined = TRUE;
                }
                break;
        }
        if( bJoined ) {
            // nullify the prev prim - move all data to current prim
            pPrim->nVerts += (pPrevPrim->nVerts - 1);
            pPrim->pVert = pPrevPrim->pVert;
            pPrim->pFNorm = pPrevPrim->pFNorm;
            pPrevPrim->nVerts = 0;
            nJoined++;
        }
    }

    if( nJoined ) {
        // one or more prims eliminated - compact the list

        nPrims = pLoop->nPrims;
        pPrim = pLoop->PrimBuf;
        // set new nPrims value
        pLoop->nPrims = nPrims - nJoined;
        nJoined = 0;  // nJoined now used as counter
        for( ; nPrims; nPrims--, pPrim++ ) {
            if( pPrim->nVerts == 0 ) {
                nJoined++;
                continue;
            }
            *(pPrim-nJoined) = *pPrim;
        }
    }
}

/*****************************************************************************
 * PrimTransition
 *
 * Given two adjacent prims, returns a code based on prim-type transition.
 *
*****************************************************************************/

static int
PrimTransition( PRIM *pPrevPrim, PRIM *pPrim )
{
    int trans;

    if( pPrevPrim->primType == PRIM_LINE ) {
        if( pPrim->primType == PRIM_LINE )
            trans = EXTR_LINE_LINE;
        else
            trans = EXTR_LINE_CURVE;
    } else {
        if( pPrim->primType == PRIM_LINE )
            trans = EXTR_CURVE_LINE;
        else
            trans = EXTR_CURVE_CURVE;
    }

    return trans;
}

/*****************************************************************************
 * LoopOrientation
 *
 * Check for glyphs that have incorrectly specified the contour direction (for
 * example, many of the Wingding glyphs).  We do this by first determining
 * the loop in the glyph that has the largest extent.  We then make the
 * assumption that this loop is external, and check it's orientation.  If
 * the orientation is CCW (non-default), we have to set the orientation to
 * GL_CCW in the extrusion context, so that normals will be generated
 * correctly.

* The method used here may fail for any loops that intersect themselves.
* This will happen if the loops created by the intersections are in the opposite
* direction to the main loop (if 1 such extra loop exists, then the sum of
* angles around the entire contour will be 0 - we put in a check for this,
* and always default to CW in this case)
*
* Note that this method *always* works for properly designed TruyType glyphs.
* From the TrueType font spec "The direction of the curves has to be such that,
* if the curve is followed in the direction of increasing point numbers, the
* black space (the filled area) will always be to the right."  So this means
* that the outer loop should always be CW.
* 
*****************************************************************************/

// These macros handle the rare case of a self-intersecting, polarity-reversing
// loop as explained above.  (Observed in animals1.ttf)  Note that will only
// catch some cases.
#define INTERSECTING_LOOP_WORKAROUND 1
#define NEAR_ZERO( fAngle ) \
    ( fabs(fAngle) < 0.00001 )

static GLenum
LoopOrientation( LOOP_LIST *pLoopList )
{
    DWORD  nLoops, nVerts;
    double angle = 0;
    POINT2D *p1, *p2, v1, v2;
    LOOP *pMaxLoop;

    nLoops = pLoopList->nLoops;
    if( !nLoops )
        return GL_CW; // default value

    // determine which loop has the maximum extent

    pMaxLoop = GetMaxExtentLoop( pLoopList );

    nVerts = pMaxLoop->nVerts;
    if( nVerts < 3 )
        return GL_CW;  // can't determine angle

    p1 = pMaxLoop->VertBuf + nVerts - 2;  // 2nd to last point
    p2 = pMaxLoop->VertBuf; // first point

    /* 
     * Accumulate relative angle between consecutive line segments along
     * the loop - this will tell us the loop's orientation.
     */
    v1.x = p2->x - p1->x;
    v1.y = p2->y - p1->y;
    nVerts--; // n-1 comparisons

    for( ; nVerts; nVerts-- ) {
        // calc next vector
        p1 = p2++;
        v2.x = p2->x - p1->x;
        v2.y = p2->y - p1->y;
        angle += CalcAngle( &v1, &v2 );
        v1 = v2;
    }

#ifdef INTERSECTING_LOOP_WORKAROUND
    if( NEAR_ZERO( angle ) ) {
        DBGPRINT( "wglUseFontOutlines:LoopOrientation : Total loop angle is zero, assuming CW orientation\n" );
        return GL_CW;
    }
#endif

    if( angle > 0.0 )
        return GL_CCW;
    else
        return GL_CW;
}


/*****************************************************************************
 * GetMaxExtentLoop
 *
 * Determine which of the loops in a glyph description has the maximum
 * extent, and return a ptr to it.  We check extents in the x direction.

*****************************************************************************/

LOOP *
GetMaxExtentLoop( LOOP_LIST *pLoopList )
{
    DWORD nLoops, nVerts;
    FLOAT curxExtent, xExtent=0.0f, x, xMin, xMax;
    LOOP  *pMaxLoop, *pLoop;
    POINT2D *p;

    pMaxLoop = pLoop = pLoopList->LoopBuf;

    nLoops = pLoopList->nLoops;
    if( nLoops == 1 )
        // just one loop - no comparison required
        return pMaxLoop;

    for( ; nLoops; nLoops--, pLoop++ ) {
        nVerts = pLoop->nVerts;
        p = pLoop->VertBuf;
        // use x value of first point as reference
        x = p->x;
        xMin = xMax = x;
        // compare x's of rest of points
        for( ; nVerts; nVerts--, p++ ) {
            x = p->x;
            if( x < xMin )
                xMin = x;
            else if( x > xMax )
                xMax = x;
        }
        curxExtent = xMax - xMin;
        if( curxExtent > xExtent ) {
            xExtent = curxExtent;
            pMaxLoop = pLoop;
        }
    }
    return pMaxLoop;
}

/*****************************************************************************
 * CalcAngle
 *
 * Determine the signed angle between 2 vectors.  The angle is measured CCW
 * from vector 1 to vector 2.

*****************************************************************************/

double
CalcAngle( POINT2D *v1, POINT2D *v2 )
{
    double angle1, angle2, angle;

    // Calculate absolute angle of each vector

    /* Check for (0,0) vectors - this shouldn't happen unless 2 consecutive
     * vertices in the VertBuf are equal.
     */
    if( (v1->y == 0.0f) && (v1->x == 0.0f) )
        angle1 = 0.0f;
    else
        angle1 = __GL_ATAN2F( v1->y, v1->x ); // range: -PI to PI

    if( (v2->y == 0.0f) && (v2->x == 0.0f) )
        angle1 = 0.0f;
    else
        angle2 = __GL_ATAN2F( v2->y, v2->x ); // range: -PI to PI

    // Calculate relative angle between vectors
    angle = angle2 - angle1;        // range:  -2*PI to 2*PI

    // force angle to be in range -PI to PI
    if( angle < -PI  )
        angle += TWO_PI;
    else if( angle > PI )
        angle -= TWO_PI;

    return angle;
}

/*****************************************************************************
 * CalculateFaceNormals
 *
 * Calculate face normals for a prim loop.
 * The normals are NOT normalized.
 *
*****************************************************************************/

static BOOL
CalculateFaceNormals( LOOP      *pLoop, 
                      GLenum    orientation )
{
    DWORD nPrims;
    ULONG nQuads = 0;
    POINT2D *p;
    POINT3D *pNorm;
    PRIM *pPrim;

    // Need 1 normal per vertex
    pNorm = (POINT3D*) ALLOC(pLoop->nVerts*sizeof(POINT3D));
    pLoop->FNormBuf = pNorm;
    if( !pNorm )
        return WFO_FAILURE;

    // Calculate the face normals

    nPrims = pLoop->nPrims;
    pPrim = pLoop->PrimBuf;
    for( ; nPrims; nPrims--, pPrim++ ) {
        pPrim->pFNorm = pNorm;   // ptr to each prims norms
        nQuads = pPrim->nVerts - 1;
        p = pPrim->pVert;
        for( ; nQuads; nQuads--, p++, pNorm++ ) {
            CalcNormal2d( p, (POINT2D *) pNorm, orientation );
            pNorm->z = 0.0f;    // normals in xy plane
        }
    }
    return WFO_SUCCESS;
}

/*****************************************************************************
 * CalculateVertexNormals
 *
 * Calculate vertex normals for a prim loop, only for those prims that
 * are of type 'CURVE'.
 * Uses previously calculated face normals to generate the vertex normals.
 * Allocates memory for the normals by calculating memory requirements on
 * the fly. 
 * The normals are normalized.
 * Handles closing of loops properly.
 * 
*****************************************************************************/

static BOOL
CalculateVertexNormals( LOOP *pLoop )
{
    ULONG nPrims, nVerts = 0;
    POINT3D *pVNorm, *pFNorm, *pDstNorm;
    PRIM    *pPrim, *pPrevPrim;
    double angle;
    GLenum trans;

    // How much memory we need for the normals?

    nPrims = pLoop->nPrims;
    pPrim = pLoop->PrimBuf;
    for( ; nPrims; nPrims--, pPrim++ ) {
        if( pPrim->primType == PRIM_CURVE )
            nVerts += pPrim->nVerts;
    }

    if( !nVerts )
        return WFO_SUCCESS;

    // XXX: could just allocate 2*nVerts of mem for the normals
    pVNorm = (POINT3D*) ALLOC( nVerts*sizeof(POINT3D) );
    pLoop->VNormBuf = pVNorm;
    if( !pVNorm )
        return WFO_FAILURE;

    // First pass: calculate normals for all vertices of Curve prims

    nPrims = pLoop->nPrims;
    pPrim = pLoop->PrimBuf;
    for( ; nPrims; nPrims--, pPrim++ ) {

        if( pPrim->primType == PRIM_LINE )
            continue;

        nVerts = pPrim->nVerts;
        pPrim->pVNorm = pVNorm;   // ptr to each prims norms
        pFNorm = pPrim->pFNorm;   // ptr to face norms already calculated

        // set the first vnorm to the fnorm
        *pVNorm = *pFNorm;

        Normalize2d( (POINT2D *) pVNorm );         // normalize it
        nVerts--;  // one less vertex to worry about
        pVNorm++;  // advance ptrs
        pFNorm++;

        nVerts--;  // do last vertex after this loop
        for( ; nVerts; nVerts--, pFNorm++, pVNorm++ ) {
            // use neighbouring face normals to get vertex normal
            AddVectors3d( pFNorm, pFNorm-1, pVNorm );
            Normalize2d( (POINT2D *) pVNorm );      // normalize it
        }

        // last vnorm is same as fnorm of *previous* vertex
        *pVNorm = *(pFNorm-1);
        Normalize2d( (POINT2D *) pVNorm );         // normalize it

        pVNorm++;  // next available space in vnorm buffer
    }

    // Second pass: calculate normals on prim boundaries

    nPrims = pLoop->nPrims;
    pPrim = pLoop->PrimBuf;
    // set pPrevPrim to last prim in loop
    pPrevPrim = pLoop->PrimBuf + pLoop->nPrims - 1;

    for( ; nPrims; nPrims--, pPrevPrim = pPrim++ ) {
        trans = PrimTransition( pPrevPrim, pPrim );
        angle = PrimNormAngle( pPrevPrim, pPrim );

        switch( trans ) {
            case EXTR_LINE_CURVE:
                if( angle < LineCurveCutoffAngle ) {
                    // set curve's first vnorm to line's last fnorm
                    *(pPrim->pVNorm) = 
                                *(pPrevPrim->pFNorm + pPrevPrim->nVerts -2);
                    Normalize2d( (POINT2D *) pPrim->pVNorm );
                }
                break;

            case EXTR_CURVE_LINE:
                if( angle < LineCurveCutoffAngle ) {
                    // set curve's last vnorm to line's first fnorm
                    pDstNorm = pPrevPrim->pVNorm + pPrevPrim->nVerts - 1;
                    *pDstNorm = *(pPrim->pFNorm);
                    Normalize2d( (POINT2D *) pDstNorm );
                }
                break;

            case EXTR_CURVE_CURVE:
                if( angle < CurveCurveCutoffAngle ) {
                    // average normals of adjoining faces, and
                    // set last curve's first vnorm to averaged normal
                    AddVectors3d( pPrevPrim->pFNorm + pPrevPrim->nVerts - 2, 
                                  pPrim->pFNorm, 
                                  pPrim->pVNorm );
                    Normalize2d( (POINT2D *) pPrim->pVNorm );
                    // set first curve's last vnorm to averaged normal
                    *(pPrevPrim->pVNorm + pPrevPrim->nVerts - 1) =
                                                        *(pPrim->pVNorm); 
                }
                break;
            case EXTR_LINE_LINE:
                // nothing to do
                break;
        }

    }
    return WFO_SUCCESS;
}


/*****************************************************************************
 * PrimNormAngle
 *
 *  Determine angle between the last face's normal of primA, and the first
 *  face's normal of primB.
 *
 *  The result should be an angle between -PI and PI.
 *  For now, we only care about the relative angle, so we return the
 *  absolute value of the signed angle between the faces.
 *
*****************************************************************************/

static double
PrimNormAngle( PRIM *pPrimA, PRIM *pPrimB )
{
    double angle;
    // last face norm at index (nvert-2)
    POINT3D *normA = pPrimA->pFNorm + pPrimA->nVerts - 2;
    POINT3D *normB = pPrimB->pFNorm;

    angle = CalcAngle( (POINT2D *) normA, (POINT2D *) normB );

    return fabs(angle); // don't care about sign of angle for now
}


/*****************************************************************************
 * InitFaceBuf
 * 
 * Initializes FaceBuf and its associated size and current-element
 * counters.
 * 
*****************************************************************************/

static BOOL
InitFaceBuf( EXTRContext *ec )
{
    DWORD initSize = 1000;

    if( !(ec->FaceBuf = 
        (FLOAT*) ALLOC(initSize*sizeof(FLOAT))) )
        return WFO_FAILURE;
    ec->FaceBufSize = initSize;
    ec->FaceBufIndex = 0;
    return WFO_SUCCESS;
}


/*****************************************************************************
 * AppendToFaceBuf
 *
 * Appends one floating-point value to the FaceBuf array.

*****************************************************************************/

static BOOL
AppendToFaceBuf(EXTRContext *ec, FLOAT value)
{
    if (ec->FaceBufIndex >= ec->FaceBufSize)
    {
       if( !ReallocFaceBuf( ec ) )
            return WFO_FAILURE;
    }
    ec->FaceBuf[ec->FaceBufIndex++] = value;
    return WFO_SUCCESS;
}

/*****************************************************************************
 * ReallocBuf
 *
 * Increases size of FaceBuf by a constant value.
 *
*****************************************************************************/

static BOOL
ReallocFaceBuf( EXTRContext *ec )
{
    FLOAT* f;
    DWORD increase = 1000; // in floats

    f = (FLOAT*) REALLOC(ec->FaceBuf, 
        (ec->FaceBufSize += increase)*sizeof(FLOAT));
    if (!f)
        return WFO_FAILURE;
    ec->FaceBuf = f;
    return WFO_SUCCESS;
}


/*****************************************************************************
 * CalcNormal2d
 *
 * Calculates the 2d normal of a 2d vector, by rotating the vector:
 * - CCW 90 degrees for CW contours.
 * - CW 90 degrees for CCW contours.
 * Does not normalize.
 *
*****************************************************************************/

static void
CalcNormal2d( POINT2D *p, POINT2D *n, GLenum orientation )
{
    static POINT2D v;

    v.x = (p+1)->x - p->x;
    v.y = (p+1)->y - p->y;
    if( orientation == GL_CW ) {
        n->x = -v.y;
        n->y = v.x;
    } else {
        n->x = v.y;
        n->y = -v.x;
    }
}


/*****************************************************************************
 * Normalize2d
 *
 * Normalizes a 2d vector
 *
*****************************************************************************/

static void
Normalize2d( POINT2D *n )
{
    float len;

    len = (n->x * n->x) + (n->y * n->y);
    if (len > ZERO_EPS)
        len = 1.0f / __GL_SQRTF(len);
    else
        len = 1.0f;

    n->x *= len;
    n->y *= len;
}

/*****************************************************************************
 * AddVectors3d
 *
 * Adds two 3d vectors.
 *
*****************************************************************************/

static void
AddVectors3d( POINT3D *v1, POINT3D *v2, POINT3D *n )
{
    n->x = v1->x + v2->x;
    n->y = v1->y + v2->y;
    n->z = v1->z + v2->z;
}

#ifdef VARRAY
static BOOL
InitVArray( EXTRContext *ec )
{
    int size = 500;

    // set up global buffer
    ec->vaBufSize = size;
    ec->vaBuf =  (FLOAT*) ALLOC( size*sizeof(FLOAT) );
    if( !ec->vaBuf ) {
        return WFO_FAILURE;
    }

    // set up and enable ptrs
    glWFOVertexPointerEXT     = (PFNGLVERTEXPOINTEREXTPROC       )wglGetProcAddress("glVertexPointerEXT");
    glWFONormalPointerEXT     = (PFNGLNORMALPOINTEREXTPROC       )wglGetProcAddress("glNormalPointerEXT");
    glWFODrawArraysEXT        = (PFNGLDRAWARRAYSEXTPROC          )wglGetProcAddress("glDrawArraysEXT");

    if(    (glWFOVertexPointerEXT == NULL)
        || (glWFONormalPointerEXT == NULL)
        || (glWFODrawArraysEXT == NULL) ) {
        FREE( ec->vaBuf );
        return WFO_FAILURE;
    }
        
    glEnable(GL_VERTEX_ARRAY_EXT);
    return WFO_SUCCESS;
}

/*****************************************************************************
 *
 * Size is in floats

 *
*****************************************************************************/

static BOOL
VArrayBufSize( EXTRContext *ec, DWORD size )
{
    if( size > ec->vaBufSize )
    {
        FLOAT *f;

        f = (FLOAT*) REALLOC( ec->vaBuf, size*sizeof(FLOAT));
        if( !f )
            return WFO_FAILURE;
        ec->vaBuf = f;
        ec->vaBufSize = size;
    }
    return WFO_SUCCESS;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\dllinit.c ===
/******************************Module*Header*******************************\
* Module Name: dllinit.c
*
* (Brief description)
*
* Created: 18-Oct-1993 14:13:21
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1993 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "batchinf.h"
#include "glteb.h"
#include "glapi.h"
#include "glsbcltu.h"
#ifdef _CLIENTSIDE_
#include "glscreen.h"
#include "glgenwin.h"
#endif //_CLIENTSIDE_
#include "context.h"
#include "global.h"
#include "parray.h"
#include "gencx.h"
#include "cpu.h"
#include "fixed.h"

#ifdef _CLIENTSIDE_
// Global screen access info.  This is NULL if screen access is not available.

SCREENINFO *gpScreenInfo = NULL;

extern GLubyte *dBufFill;
extern GLubyte *dBufTopLeft;

//
// This global multiply-lookup table helps with pixel-related functions.
//

BYTE gbMulTable[256*256+4];
BYTE gbSatTable[256+256];

//
// This global inverse-lookup table helps with rasterization setup
//

#define INV_TABLE_SIZE  (1 << __GL_VERTEX_FRAC_BITS) * (__GL_MAX_INV_TABLE + 1)

__GLfloat invTable[INV_TABLE_SIZE];

// Global thread local storage index.  Allocated at process attach.
// This is the slot reserved in thread local storage for per-thread
// GLTLSINFO structures.

static DWORD dwTlsIndex = 0xFFFFFFFF;

static BOOL bProcessInitialized = FALSE;

// Offset into the TEB where dwTlsIndex is
// This enables us to directly access our TLS data in the TEB

#if defined(_WIN64)
#define NT_TLS_OFFSET 5248
#else
#define NT_TLS_OFFSET 3600
#endif

#define WIN95_TLS_OFFSET 136

DWORD dwTlsOffset;

// Platform indicator for conditional code
DWORD dwPlatformId;

// Thread count
LONG lThreadsAttached = 0;

// Global header node for the linked list of GLGENwindow structures.
// The semaphore in the header node is used as the list access semaphore.

GLGENwindow gwndHeader;

// Synchronization object for pixel formats
CRITICAL_SECTION gcsPixelFormat;

// Protection for palette watcher
CRITICAL_SECTION gcsPaletteWatcher;

#ifdef GL_METAFILE
BOOL (APIENTRY *pfnGdiAddGlsRecord)(HDC hdc, DWORD cb, BYTE *pb,
                                    LPRECTL prclBounds);
BOOL (APIENTRY *pfnGdiAddGlsBounds)(HDC hdc, LPRECTL prclBounds);
BOOL (APIENTRY *pfnGdiIsMetaPrintDC)(HDC hdc);
#endif

#endif //_CLIENTSIDE_

// OpenGL client debug flag
#if DBG
long glDebugLevel;
ULONG glDebugFlags;
#endif

BOOL bDirectScreen = FALSE;

PFN_GETSURFACEFROMDC pfnGetSurfaceFromDC = NULL;

/******************************Public*Routine******************************\
*
* DdbdToCount
*
* Converts a DDBD constant to its equivalent number
*
* History:
*  Mon Aug 26 14:11:34 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DWORD APIENTRY DdbdToCount(DWORD ddbd)
{
    switch(ddbd)
    {
    case DDBD_1:
        return 1;
    case DDBD_2:
        return 2;
    case DDBD_4:
        return 4;
    case DDBD_8:
        return 8;
    case DDBD_16:
        return 16;
    case DDBD_24:
        return 24;
    case DDBD_32:
        return 32;
    }
    ASSERTOPENGL(FALSE, "DdbdToCount: Invalid ddbd\n");
    return 0;
}

/******************************Public*Routine******************************\
* GLInitializeProcess
*
* Called from OPENGL32.DLL entry point for PROCESS_ATTACH.
*
* History:
*  01-Nov-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL GLInitializeProcess()
{
    PVOID pv;
#ifdef _CLIENTSIDE_
    OSVERSIONINFO osvi;
#endif

    // Attempt to locate GDI exports for metafiling support
    {
        HMODULE hdll;

        hdll = GetModuleHandleA("gdi32");
        ASSERTOPENGL(hdll != NULL, "Unable to get gdi32 handle\n");
        *(PROC *)&pfnGdiAddGlsRecord = GetProcAddress(hdll, "GdiAddGlsRecord");
        *(PROC *)&pfnGdiAddGlsBounds = GetProcAddress(hdll, "GdiAddGlsBounds");
        *(PROC *)&pfnGdiIsMetaPrintDC = GetProcAddress(hdll,
                                                       "GdiIsMetaPrintDC");

#ifdef ALLOW_DDRAW_SURFACES
        hdll = GetModuleHandleA("ddraw");
        ASSERTOPENGL(hdll != NULL, "Unable to get ddraw handle\n");
        pfnGetSurfaceFromDC = (PFN_GETSURFACEFROMDC)
            GetProcAddress(hdll, "GetSurfaceFromDC");
#endif
    }

#if DBG
#define STR_OPENGL_DEBUG (PCSTR)"Software\\Microsoft\\Windows\\CurrentVersion\\DebugOpenGL"
    {
        HKEY hkDebug;

        // Initialize debugging level and flags.

        glDebugLevel = LEVEL_ERROR;
        glDebugFlags = 0;
        if ( RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                           STR_OPENGL_DEBUG,
                           0,
                           KEY_QUERY_VALUE,
                           &hkDebug) == ERROR_SUCCESS )
        {
            DWORD dwDataType;
            DWORD cjSize;
            long lTmp;

            cjSize = sizeof(long);
            if ( (RegQueryValueExA(hkDebug,
                                   (LPSTR) "glDebugLevel",
                                   (LPDWORD) NULL,
                                   &dwDataType,
                                   (LPBYTE) &lTmp,
                                   &cjSize) == ERROR_SUCCESS) )
            {
                glDebugLevel = lTmp;
            }

            cjSize = sizeof(long);
            if ( (RegQueryValueExA(hkDebug,
                                   (LPSTR) "glDebugFlags",
                                   (LPDWORD) NULL,
                                   &dwDataType,
                                   (LPBYTE) &lTmp,
                                   &cjSize) == ERROR_SUCCESS) )
            {
                glDebugFlags = (ULONG) lTmp;
            }

            RegCloseKey(hkDebug);
        }
    }
#endif

#ifdef _CLIENTSIDE_
// Determine which platform we're running on and remember it

    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (!GetVersionEx(&osvi))
    {
        WARNING1("GetVersionEx failed with %d\n", GetLastError());
        goto EH_Fail;
    }

    dwPlatformId = osvi.dwPlatformId;

    if (!(
          (dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) ||
          (dwPlatformId == VER_PLATFORM_WIN32_NT
             && !(osvi.dwMajorVersion == 3 && osvi.dwMinorVersion <= 51)
          )
         )
       )
    {
        WARNING("DLL must be run on NT 4.0 or Win95");
        goto EH_Fail;
    }

// Allocate a thread local storage slot.

    if ( (dwTlsIndex = TlsAlloc()) == 0xFFFFFFFF )
    {
        WARNING("DllInitialize: TlsAlloc failed\n");
        goto EH_Fail;
    }

    // Set up the offset to the TLS slot, OS-specific

    if (dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        ASSERTOPENGL(FIELD_OFFSET(TEB, TlsSlots) == NT_TLS_OFFSET,
                     "NT TLS offset not at expected location");

        dwTlsOffset = dwTlsIndex*sizeof(DWORD_PTR)+NT_TLS_OFFSET;
    }

#if !defined(_WIN64)

    else
    {
        // We don't have Win95's TIB type available so the assert is
        // slightly different
        ASSERTOPENGL(((ULONG_PTR)(NtCurrentTeb()->ThreadLocalStoragePointer)-
                      (ULONG_PTR)NtCurrentTeb()) == WIN95_TLS_OFFSET,
                     "Win95 TLS offset not at expected location");

        dwTlsOffset = dwTlsIndex*sizeof(DWORD)+WIN95_TLS_OFFSET;
    }

#endif
#endif

// Reserve memory for the local handle table.

    if ( (pLocalTable = (PLHE) VirtualAlloc (
                            (LPVOID) NULL,    // let base locate it
                            MAX_HANDLES*sizeof(LHE),
                            MEM_RESERVE | MEM_TOP_DOWN,
                            PAGE_READWRITE
                            )) == (PLHE) NULL )
    {
        WARNING("DllInitialize: VirtualAlloc failed\n");
        goto EH_TlsIndex;
    }

    // Initialize the local handle manager semaphore.
    __try
    {
        INITIALIZECRITICALSECTION(&semLocal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        goto EH_LocalTable;
    }

#ifdef _CLIENTSIDE_
    // Initialize the GLGENwindow list semaphore.
    __try
    {
        INITIALIZECRITICALSECTION(&gwndHeader.sem);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        goto EH_semLocal;
    }
    gwndHeader.pNext = &gwndHeader;

    // Initialize the pixel format critical section
    __try
    {
        INITIALIZECRITICALSECTION(&gcsPixelFormat);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        goto EH_gwndHeader;
    }

    // Initialize the palette watcher critical section.
    __try
    {
        INITIALIZECRITICALSECTION(&gcsPaletteWatcher);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        goto EH_PixelFormat;
    }

// Initialize direct screen access.

    if (GetSystemMetrics(SM_CMONITORS) > 1)
    {
        gpScreenInfo = NULL;
    }
    else
    {
#if _WIN32_WINNT >= 0x0501
        BOOL wow64Process;

        if (IsWow64Process(GetCurrentProcess(), &wow64Process) && wow64Process)
            gpScreenInfo = NULL;
        else
#endif
        gpScreenInfo = (SCREENINFO *)ALLOCZ(sizeof(SCREENINFO));
    }

    if ( gpScreenInfo )
    {
        UINT uiOldErrorMode;
        HRESULT hr;

        // We want to ensure that DDraw doesn't pop up any message
        // boxes on failure when we call DirectDrawCreate.  DDraw
        // does errors on a different thread which it creates just
        // for the error.  It waits for the error to complete before
        // returning.  This function is running inside the loader
        // DllInitialize critical section, though, so other threads
        // do not get to run, causing a deadlock.
        // Force the error mode to get around this.
        uiOldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

        hr = DirectDrawCreate(NULL, &gpScreenInfo->pdd, NULL);

        SetErrorMode(uiOldErrorMode);

        if (hr == DD_OK)
        {
            hr = gpScreenInfo->pdd->lpVtbl->
                SetCooperativeLevel(gpScreenInfo->pdd, NULL, DDSCL_NORMAL);

            if (hr == DD_OK)
            {
                gpScreenInfo->gdds.ddsd.dwSize = sizeof(DDSURFACEDESC);
                gpScreenInfo->gdds.ddsd.dwFlags = DDSD_CAPS;
                gpScreenInfo->gdds.ddsd.ddsCaps.dwCaps =
                    DDSCAPS_PRIMARYSURFACE;
                hr = gpScreenInfo->pdd->lpVtbl->
                    CreateSurface(gpScreenInfo->pdd, &gpScreenInfo->gdds.ddsd,
                                  &gpScreenInfo->gdds.pdds, NULL);
            }

            if (hr == DD_OK)
            {
#if DBG

#define LEVEL_SCREEN   LEVEL_INFO

                gpScreenInfo->gdds.pdds->lpVtbl->
                    GetSurfaceDesc(gpScreenInfo->gdds.pdds,
                                   &gpScreenInfo->gdds.ddsd);
                DBGLEVEL (LEVEL_SCREEN, "=============================\n");
                DBGLEVEL (LEVEL_SCREEN, "Direct screen access enabled for OpenGL\n\n");
                DBGLEVEL (LEVEL_SCREEN, "Surface info:\n");
                DBGLEVEL1(LEVEL_SCREEN, "\tdwSize        = 0x%lx\n",
                    gpScreenInfo->gdds.ddsd.dwSize);
                DBGLEVEL1(LEVEL_SCREEN, "\tdwWidth       = %ld\n",
                    gpScreenInfo->gdds.ddsd.dwWidth);
                DBGLEVEL1(LEVEL_SCREEN, "\tdwHeight      = %ld\n",
                    gpScreenInfo->gdds.ddsd.dwHeight);
                DBGLEVEL1(LEVEL_SCREEN, "\tlStride       = 0x%lx\n",
                    gpScreenInfo->gdds.ddsd.lPitch);
                DBGLEVEL1(LEVEL_SCREEN, "\tdwBitCount    = %ld\n",
                    gpScreenInfo->gdds.ddsd.ddpfPixelFormat.dwRGBBitCount);

                gpScreenInfo->gdds.pdds->lpVtbl->
                    Lock(gpScreenInfo->gdds.pdds,
                         NULL, &gpScreenInfo->gdds.ddsd,
                         DDLOCK_SURFACEMEMORYPTR, NULL);
                DBGLEVEL1(LEVEL_SCREEN, "\tdwOffSurface  = 0x%lx\n",
                    gpScreenInfo->gdds.ddsd.lpSurface);
                gpScreenInfo->gdds.pdds->lpVtbl->
                    Unlock(gpScreenInfo->gdds.pdds, gpScreenInfo->gdds.ddsd.lpSurface);
                DBGLEVEL (LEVEL_SCREEN, "=============================\n");
#endif

           // Verify screen access

                if (gpScreenInfo->gdds.pdds->lpVtbl->
                    GetSurfaceDesc(gpScreenInfo->gdds.pdds,
                                   &gpScreenInfo->gdds.ddsd) != DD_OK ||
                    gpScreenInfo->gdds.pdds->lpVtbl->
                    Lock(gpScreenInfo->gdds.pdds,
                         NULL, &gpScreenInfo->gdds.ddsd,
                         DDLOCK_SURFACEMEMORYPTR, NULL) != DD_OK)
                {
                    DBGLEVEL(LEVEL_SCREEN,
                             "Direct screen access failure : disabling\n");
                }
                else
                {
                    gpScreenInfo->gdds.dwBitDepth =
                        DdPixDepthToCount(gpScreenInfo->gdds.ddsd.
                                          ddpfPixelFormat.dwRGBBitCount);
                    gpScreenInfo->gdds.pdds->lpVtbl->
                        Unlock(gpScreenInfo->gdds.pdds,
                               gpScreenInfo->gdds.ddsd.lpSurface);

                    bDirectScreen = TRUE;
                }
            }
#if DBG
            else
            {
                DBGLEVEL (LEVEL_SCREEN, "=============================\n");
                DBGLEVEL2(LEVEL_SCREEN,
                          "Screen access failed code 0x%08lX (%s)\n",
                          hr, (hr == DDERR_NOTFOUND) ? "DDERR_NOTFOUND" :
                                                       "unknown");
                DBGLEVEL (LEVEL_SCREEN, "=============================\n");
            }
#endif
        }
        else
        {
            DBGLEVEL(LEVEL_SCREEN, "DirectDrawCreate failed\n");
        }
    }

    if (!bDirectScreen)
    {
        if (gpScreenInfo)
        {
            if (gpScreenInfo->gdds.pdds)
            {
                gpScreenInfo->gdds.pdds->lpVtbl->
                    Release(gpScreenInfo->gdds.pdds);
            }
            if (gpScreenInfo->pdd)
            {
                gpScreenInfo->pdd->lpVtbl->Release(gpScreenInfo->pdd);
            }
            FREE(gpScreenInfo);
	    gpScreenInfo = NULL;
        }
    }

#endif

    // Set up our multiplication table:

    {
        BYTE *pMulTable = gbMulTable;
        ULONG i, j;

        for (i = 0; i < 256; i++) {
            ULONG tmp = 0;

            for (j = 0; j < 256; j++, tmp += i) {
                *pMulTable++ = (BYTE)(tmp >> 8);
            }
        }
    }

    // Set up our saturation table:

    {
        ULONG i;

        for (i = 0; i < 256; i++)
            gbSatTable[i] = (BYTE)i;

        for (; i < (256+256); i++)
            gbSatTable[i] = 255;
    }

    // Set up inverse-lookup table:

    {
       __GLfloat accum = (__GLfloat)(1.0 / (__GLfloat)__GL_VERTEX_FRAC_ONE);
       GLint i;

       invTable[0] = (__GLfloat)0.0;

       for (i = 1; i < INV_TABLE_SIZE; i++) {

           invTable[i] = __glOne / accum;
           accum += (__GLfloat)(1.0 / (__GLfloat)__GL_VERTEX_FRAC_ONE);
        }
    }

    bProcessInitialized = TRUE;

    return TRUE;

 EH_PixelFormat:
    DELETECRITICALSECTION(&gcsPixelFormat);
 EH_gwndHeader:
    DELETECRITICALSECTION(&gwndHeader.sem);
 EH_semLocal:
    DELETECRITICALSECTION(&semLocal);
 EH_LocalTable:
    VirtualFree(pLocalTable, 0, MEM_RELEASE);
 EH_TlsIndex:
    TlsFree(dwTlsIndex);
    dwTlsIndex = 0xFFFFFFFF;
 EH_Fail:
    return FALSE;
}

/******************************Public*Routine******************************\
* GLUnInitializeProcess
*
* Called from OPENGL32.DLL entry point for PROCESS_DETACH.
*
* History:
*  01-Nov-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void GLUnInitializeProcess()
{
// If we never finished process initialization, quit now.

    if (!bProcessInitialized)
	return;

// Cleanup stray HGLRCs that the app may have forgotten to delete.
    {
        static GLTEBINFO gltebInfoTmp;

    // Need a temporary GLTEBINFO for this thread in order to do the
    // cleanup processing.

        ASSERTOPENGL(!CURRENT_GLTEBINFO(),
                     "GLUnInitializeProcess: GLTEBINFO not NULL!\n");
        // made static and no longer need memset
        // memset(&gltebInfoTmp, 0, sizeof(gltebInfoTmp));
        SET_CURRENT_GLTEBINFO(&gltebInfoTmp);

        vCleanupAllLRC();

        SET_CURRENT_GLTEBINFO((PGLTEBINFO) NULL);
    }

// Cleanup window tracking structures (GLGENwindow structs).

    vCleanupWnd();

// Cleanup evaluator arrays

    if (dBufFill)
	FREE(dBufFill);
    if (dBufTopLeft)
	FREE(dBufTopLeft);

// Screen access shutdown.

    if (gpScreenInfo)
    {
        if (gpScreenInfo->gdds.pdds)
        {
            gpScreenInfo->gdds.pdds->lpVtbl->Release(gpScreenInfo->gdds.pdds);
        }
        if (gpScreenInfo->pdd)
        {
            gpScreenInfo->pdd->lpVtbl->Release(gpScreenInfo->pdd);
        }
        FREE(gpScreenInfo);
    }

// Free the TLS slot.

    if (dwTlsIndex != 0xFFFFFFFF)
	if (!TlsFree(dwTlsIndex))
	    RIP("DllInitialize: TlsFree failed\n");

// Free the global semaphores.

    DELETECRITICALSECTION(&gcsPaletteWatcher);
    DELETECRITICALSECTION(&gcsPixelFormat);
    DELETECRITICALSECTION(&gwndHeader.sem);
    DELETECRITICALSECTION(&semLocal);

// Free the local handle table.

    if ( pLocalTable )
        VirtualFree(pLocalTable, 0, MEM_RELEASE);
}

/******************************Public*Routine******************************\
* GLInitializeThread
*
* Called from OPENGL32.DLL entry point for THREAD_ATTACH.  May assume that
* GLInitializeProcess has succeeded.
*
\**************************************************************************/

VOID GLInitializeThread(ULONG ulReason)
{
    GLTEBINFO *pglti;
    GLMSGBATCHINFO *pMsgBatchInfo;
    POLYARRAY *pa;

#if !defined(_WIN95_) && defined(_X86_)
    {
        TEB *pteb;

        pteb = NtCurrentTeb();

        // Set up linear pointers to TEB regions in the TEB
        // this saves an addition when referencing these values
        // This must occur early so that these pointers are available
        // for the rest of thread initialization
        ((POLYARRAY *)pteb->glReserved1)->paTeb =
            (POLYARRAY *)pteb->glReserved1;
        pteb->glTable = pteb->glDispatchTable;
    }
#endif

    pglti = (GLTEBINFO *)ALLOCZ(sizeof(GLTEBINFO));
    SET_CURRENT_GLTEBINFO(pglti);

    if (pglti)
    {
        pa = GLTEB_CLTPOLYARRAY();
        pa->flags = 0;      // not in begin mode

        // Save shared section pointer in POLYARRAY for fast pointer access
        pa->pMsgBatchInfo = (PVOID) pglti->glMsgBatchInfo;

        pMsgBatchInfo = (GLMSGBATCHINFO *) pa->pMsgBatchInfo;
        pMsgBatchInfo->MaximumOffset
            = SHARED_SECTION_SIZE - GLMSG_ALIGN(sizeof(ULONG));
        pMsgBatchInfo->FirstOffset
            = GLMSG_ALIGN(sizeof(GLMSGBATCHINFO));
        pMsgBatchInfo->NextOffset
            = GLMSG_ALIGN(sizeof(GLMSGBATCHINFO));
        SetCltProcTable(&glNullCltProcTable, &glNullExtProcTable, TRUE);
        GLTEB_SET_CLTCURRENTRC(NULL);
        GLTEB_SET_CLTPOLYMATERIAL(NULL);
        GLTEB_SET_CLTDRIVERSLOT(NULL);

#if !defined(_WIN95_)
        ASSERTOPENGL((ULONG_PTR) pMsgBatchInfo == GLMSG_ALIGNPTR(pMsgBatchInfo),
                     "bad shared memory alignment!\n");
#endif
    }
    else
    {
        // This can be made into a WARNING (debug builds only) later on.
        DbgPrint ("Memory alloc failed for TebInfo structure, thread may AV if GL calls are made without MakeCurrent\n");
    }
}

/******************************Public*Routine******************************\
* GLUnInitializeThread
*
* Called from OPENGL32.DLL entry point for THREAD_DETACH.
*
* The server generic driver should cleanup on its own.  Same for the
* installable driver.
*
\**************************************************************************/

VOID GLUnInitializeThread(VOID)
{
// If we never finished process initialization, quit now.

    if (!bProcessInitialized)
	return;

    if (!CURRENT_GLTEBINFO())
    {
        return;
    }

    if (GLTEB_CLTCURRENTRC() != NULL)
    {
        PLRC plrc = GLTEB_CLTCURRENTRC();

        // May be an application error

        DBGERROR("GLUnInitializeThread: RC is current when thread exits\n");

        // Release the RC

        plrc->tidCurrent = INVALID_THREAD_ID;
        plrc->gwidCurrent.iType = GLWID_ERROR;
        GLTEB_SET_CLTCURRENTRC(NULL);
        vUnlockHandle((ULONG_PTR)(plrc->hrc));
    }
    // GLTEB_SET_CLTPROCTABLE(&glNullCltProcTable,&glNullExtProcTable);

    if (GLTEB_CLTPOLYMATERIAL())
	FreePolyMaterial();

    FREE(CURRENT_GLTEBINFO());
    SET_CURRENT_GLTEBINFO(NULL);
}

/******************************Public*Routine******************************\
* DllInitialize
*
* This is the entry point for OPENGL32.DLL, which is called each time
* a process or thread that is linked to it is created or terminated.
*
\**************************************************************************/

BOOL DllInitialize(HMODULE hModule, ULONG Reason, PVOID Reserved)
{
// Do the appropriate task for process and thread attach/detach.

    DBGLEVEL3(LEVEL_INFO, "DllInitialize: %s  Pid %d, Tid %d\n",
        Reason == DLL_PROCESS_ATTACH ? "PROCESS_ATTACH" :
        Reason == DLL_PROCESS_DETACH ? "PROCESS_DETACH" :
        Reason == DLL_THREAD_ATTACH  ? "THREAD_ATTACH" :
        Reason == DLL_THREAD_DETACH  ? "THREAD_DETACH" :
                                       "Reason UNKNOWN!",
        GetCurrentProcessId(), GetCurrentThreadId());

    switch (Reason)
    {
    case DLL_THREAD_ATTACH:
    case DLL_PROCESS_ATTACH:

        if (Reason == DLL_PROCESS_ATTACH)
        {
            if (!GLInitializeProcess())
                return FALSE;
        }

        InterlockedIncrement(&lThreadsAttached);
        GLInitializeThread(Reason);

        break;

    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:

        GLUnInitializeThread();
        InterlockedDecrement(&lThreadsAttached);

        if ( Reason == DLL_PROCESS_DETACH )
        {
            GLUnInitializeProcess();
        }

        break;

    default:
        RIP("DllInitialize: unknown reason!\n");
        break;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\eval.c ===
/******************************Module*Header*******************************\
* Module Name: eval.c
*
* OpenGL Evaluator functions on the client side.
*
* Created: 
* Author: 
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "glsbcltu.h"
#include "glclt.h"
#include "compsize.h"

#include "glsize.h"

#include "context.h"
#include "global.h"
#include "attrib.h"
#include "imports.h"

////////////////////////////////////////////////////////////////////
// Stuff needed for PA_EvalMesh2 ///////////////////////////////////
////////////////////////////////////////////////////////////////////
#define MV_VERTEX3    0x0001
#define MV_VERTEX4    0x0002
#define MV_NORMAL     0x0004
#define MV_COLOR      0x0008
#define MV_INDEX      0x0010
#define MV_TEXTURE1   0x0020
#define MV_TEXTURE2   0x0040
#define MV_TEXTURE3   0x0080
#define MV_TEXTURE4   0x0100

// Assumption: U is moving, left to right. V is moving top to bottom
#define MV_TOP        0x0001
#define MV_LEFT       0x0002

typedef struct {
    __GLcoord vertex;
    __GLcoord normal;
    __GLcoord texture;
    __GLcolor color;
} MESHVERTEX;


#define MAX_MESH_VERTICES     MAX_U_SIZE*MAX_V_SIZE
#define MAX_U_SIZE       16
#define MAX_V_SIZE       16

GLubyte *dBufFill;     //fill only
GLuint totFillPts;
GLubyte *dBufTopLeft;     //for mv_left 
GLuint totTopLeftPts;
GLubyte *dBufTopRight;      //for non mv_left
GLuint totTopRightPts;

//////////////////////////////////////////////////////////////////////
/// Function Prototypes //////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
void FASTCALL PADoEval1(__GLcontext *, __GLfloat);
void FASTCALL PADoEval2(__GLcontext *, __GLfloat, __GLfloat);
void FASTCALL PADoEval2VArray(__GLcontext *, __GLfloat, __GLfloat, 
                              MESHVERTEX *, GLuint *);
static void PreEvaluate(GLint , __GLfloat , __GLfloat *);
static void PreEvaluateWithDeriv(GLint, __GLfloat, __GLfloat *, __GLfloat *);
void DoDomain2(__GLevaluatorMachine *, __GLfloat, __GLfloat, 
               __GLevaluator2 *, __GLfloat *, __GLfloat *);
void DoDomain2WithDerivs(__GLevaluatorMachine *, __GLfloat,    __GLfloat, 
                            __GLevaluator2 *, __GLfloat *,    __GLfloat *, 
                         __GLfloat *, __GLfloat *);
int FASTCALL genMeshElts (GLenum, GLuint, GLint, GLint, GLubyte *);
void FASTCALL PA_EvalMesh2Fast(__GLcontext *, GLint, GLint, GLint,
                               GLint, GLint, GLenum, GLuint);
void glcltColor4fv_Eval (__GLfloat *c4);
void glcltIndexf_Eval (__GLfloat ci);
void glcltNormal3fv_Eval(__GLfloat *n3);
void glcltTexCoord1fv_Eval(__GLfloat *t1);
void glcltTexCoord2fv_Eval(__GLfloat *t2);
void glcltTexCoord3fv_Eval(__GLfloat *t3);
void glcltTexCoord4fv_Eval(__GLfloat *t4);

/************************************************************************/
/********************** Client-side entry points ************************/
/********************** for 1-D Evaluators       ************************/
/************************************************************************/


void APIENTRY
glcltEvalMesh1 ( IN GLenum mode, IN GLint u1, IN GLint u2 )
{
    __GL_SETUP ();
    POLYARRAY *pa;
    GLenum     primType;
    GLint      i;
    WORD       flags = (WORD) GET_EVALSTATE (gc);
    __GLfloat u;
    __GLfloat du;
    __GLevaluatorGrid *gu;
    
    // Not allowed in begin/end.

    pa = GLTEB_CLTPOLYARRAY();
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    switch(mode)
    {
      case GL_LINE:
        primType = GL_LINE_STRIP;
        break;
      case GL_POINT:
        primType = GL_POINTS;
        break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    // if there are any pending API calls that affect the Evaluator state
    // then flush the message buffer

    if (flags & (__EVALS_AFFECTS_1D_EVAL|
                 __EVALS_AFFECTS_ALL_EVAL))
        glsbAttention();

    gu = &gc->state.evaluator.u1;
    //du = (gu->finish - gu->start)/(__GLfloat)gu->n;
    du = gu->step;

    // Call Begin/End.  

    glcltBegin(primType);
    for (i = u1; i <= u2; i++)
    {
        u = (i == gu->n) ? gu->finish : (gu->start + i * du);
        PADoEval1(gc, u);
    }
    glcltEnd();
}


void APIENTRY
glcltEvalPoint1 ( IN GLint i )
{
    __GL_SETUP ();
    POLYARRAY *pa;
    __GLfloat u;
    __GLfloat du;
    __GLevaluatorGrid *gu;

    // This call has no effect outside begin/end 
    // (unless it is being compiled).

    pa = GLTEB_CLTPOLYARRAY();

    if (!(pa->flags & POLYARRAY_IN_BEGIN))
    {
        return;
    }

    gu = &gc->state.evaluator.u1;
    du = gu->step;
    //du = (gu->finish - gu->start)/(__GLfloat)gu->n;
    u = (i == gu->n) ? gu->finish : (gu->start + i * du);

    PADoEval1(gc, u);
}

void APIENTRY
glcltEvalCoord1f ( IN GLfloat u )
{
    __GL_SETUP ();
    POLYARRAY *pa;

    // This call has no effect outside begin/end 
    // (unless it is being compiled).

    pa = GLTEB_CLTPOLYARRAY();

    // If not in Begin-End block, return without doing anything
    if (!(pa->flags & POLYARRAY_IN_BEGIN))
    {
        return;
    }

    PADoEval1(gc, u);
}

void APIENTRY
glcltEvalCoord1d ( IN GLdouble u )
{
    glcltEvalCoord1f((GLfloat) u);
}

void APIENTRY
glcltEvalCoord1dv ( IN const GLdouble u[1] )
{
    glcltEvalCoord1f((GLfloat) u[0]);
}

void APIENTRY
glcltEvalCoord1fv ( IN const GLfloat u[1] )
{
    glcltEvalCoord1f((GLfloat) u[0]);
}

void APIENTRY
glcltMapGrid1d ( IN GLint un, IN GLdouble u1, IN GLdouble u2 )
{
    glcltMapGrid1f(un, (GLfloat) u1, (GLfloat) u2);
}

void APIENTRY
glcltMapGrid1f ( IN GLint un, IN GLfloat u1, IN GLfloat u2 )
{
    POLYARRAY *pa;
    __GL_SETUP ();
    WORD     flags = (WORD) GET_EVALSTATE (gc);

    // Check if it is called inside a Begin-End block
    // If we are already in the begin/end bracket, return an error.

    pa = GLTEB_CLTPOLYARRAY();
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    // if there are any pending API calls that affect the Evaluator state
    // then flush the message buffer

    if (flags & (__EVALS_PUSH_EVAL_ATTRIB | __EVALS_POP_EVAL_ATTRIB))
        glsbAttention ();
    
#ifdef NT
    if (un <= 0)
    {
    __glSetError(GL_INVALID_VALUE);
    return;
    }
#endif
    gc->state.evaluator.u1.start = (__GLfloat)u1;
    gc->state.evaluator.u1.finish = (__GLfloat)u2;
    gc->state.evaluator.u1.n = un;
    gc->state.evaluator.u1.step = ((__GLfloat)u2 - (__GLfloat)u1)/(__GLfloat)un;
}


void APIENTRY
glcltMap1d ( IN GLenum target, IN GLdouble u1, IN GLdouble u2, IN GLint stride, IN GLint order, IN const GLdouble points[] )
{
    __GLevaluator1 *ev;
    __GLfloat *data;
    POLYARRAY *pa;
    __GL_SETUP ();

    // Check if it is called inside a Begin-End block
    // If we are already in the begin/end bracket, return an error.

    pa = GLTEB_CLTPOLYARRAY();
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    ev = __glSetUpMap1(gc, target, order, u1, u2);
    if (ev == 0) {
    return;
    }
    if (stride < ev->k) {
    __glSetError(GL_INVALID_VALUE);
    return;
    }
    data = gc->eval.eval1Data[__GL_EVAL1D_INDEX(target)];
    __glFillMap1d(ev->k, order, stride, points, data);
}

void APIENTRY
glcltMap1f ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint stride, IN GLint order, IN const GLfloat points[] )
{
    __GLevaluator1 *ev;
    __GLfloat *data;
    POLYARRAY *pa;
    __GL_SETUP ();

    // Check if it is called inside a Begin-End block
    // If we are already in the begin/end bracket, return an error.

    pa = GLTEB_CLTPOLYARRAY();
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    ev = __glSetUpMap1(gc, target, order, u1, u2);
    if (ev == 0) {
    return;
    }
    if (stride < ev->k) {
    __glSetError(GL_INVALID_VALUE);
    return;
    }
    data = gc->eval.eval1Data[__GL_EVAL1D_INDEX(target)];
    __glFillMap1f(ev->k, order, stride, points, data);
}

/************************************************************************/
/********************** Client-side entry points ************************/
/********************** for 2-D Evaluators       ************************/
/************************************************************************/

void APIENTRY
glcltEvalMesh2 ( IN GLenum mode, IN GLint u1, IN GLint u2, IN GLint v1, IN GLint v2 )
{
    POLYARRAY *pa;
    GLint      i, j, meshSize;
    __GL_SETUP();
    GLboolean done_v, done_u;
    GLint v_beg, v_end, u_beg, u_end, u_len;
    GLuint sides;
    WORD   flags = (WORD) GET_EVALSTATE (gc);

    // Flush the command buffer before we start.  We need to access the
    // latest evaluator states in this function.
    // if there are any pending API calls that affect the Evaluator state
    // then flush the message buffer

    if (flags & (__EVALS_AFFECTS_2D_EVAL|
                 __EVALS_AFFECTS_ALL_EVAL))
        glsbAttention ();

    // Not allowed in begin/end.

    pa = gc->paTeb;
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    // If vertex map is not enabled, this is a noop.

    if (!(gc->state.enables.eval2 & (__GL_MAP2_VERTEX_4_ENABLE |
                                     __GL_MAP2_VERTEX_3_ENABLE)))
        return;

    // Make sure that the mesh is not empty.

    if (u1 > u2 || v1 > v2)
        return;

    if (mode == GL_FILL && dBufFill == NULL) 
    {
        if (!(dBufFill = (GLubyte *) ALLOC (
                           4 * MAX_U_SIZE * MAX_V_SIZE * sizeof (GLubyte)))) 
        {
            GLSETERROR(GL_OUT_OF_MEMORY);
            return;
        }

        totFillPts = genMeshElts (GL_FILL, MV_TOP | MV_LEFT, MAX_U_SIZE, 
                                    MAX_V_SIZE, dBufFill);
    }

    if (mode == GL_LINE && dBufTopLeft == NULL) 
    {
        if (!(dBufTopLeft = (GLubyte *) ALLOC (
                        2 * 4 * MAX_U_SIZE * MAX_V_SIZE * sizeof (GLubyte))))
        {
            GLSETERROR(GL_OUT_OF_MEMORY);
            return;
        }
        dBufTopRight = &dBufTopLeft[4 * MAX_U_SIZE * MAX_V_SIZE];

        totTopLeftPts = genMeshElts (GL_LINE, MV_TOP | MV_LEFT, MAX_U_SIZE, 
                                     MAX_V_SIZE,  dBufTopLeft);
        totTopRightPts = genMeshElts (GL_LINE, MV_TOP, MAX_U_SIZE, MAX_V_SIZE,
                                      dBufTopRight);
    }

    switch(mode)
    {
      case GL_POINT:
        glcltBegin(GL_POINTS);
        for (i = v1; i <= v2; i++)
            for (j = u1; j <= u2; j++)
                glcltEvalPoint2(j, i);
        glcltEnd();
        break ;

      case GL_LINE:
      case GL_FILL: // the sides argument in the fastcall is ignored
        meshSize = (u2 - u1 + 1)*(v2 - v1 + 1);
        if (meshSize <= MAX_MESH_VERTICES)
            PA_EvalMesh2Fast(gc, u1, u2, v1, v2, meshSize, mode, 
                             (GLubyte) 15);
        else {
            u_beg = u1;
            u_end = u_beg + MAX_U_SIZE - 1;
            done_u = GL_FALSE;
            while (!done_u) {           //Along U side
                if(u_end >= u2) {
                    u_end = u2;
                    done_u = GL_TRUE;
                }
                u_len = u_end - u_beg + 1;        
                v_beg = v1;
                v_end = v_beg + MAX_V_SIZE - 1;
                done_v = GL_FALSE;

                while(!done_v) {       //Along V side
                    if(v_end >= v2) {
                        v_end = v2;
                        done_v = GL_TRUE;
                    }
                    meshSize = u_len*(v_end - v_beg + 1);
                    sides = 0;
                    if (u_beg == u1) 
                        sides |= MV_LEFT;
                    if (v_beg == v1)
                        sides |= MV_TOP;
                    PA_EvalMesh2Fast(gc, u_beg, u_end,
                                     v_beg, v_end, meshSize, mode, sides);
                    v_beg = v_end;
                    v_end = v_beg+MAX_V_SIZE-1;
                }
                u_beg = u_end;
                u_end = u_beg + MAX_U_SIZE - 1;
            }
        }
        break ;

      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }
}


void APIENTRY
glcltEvalCoord2f ( IN GLfloat u, IN GLfloat v )
{
    __GL_SETUP ();
    POLYARRAY *pa;

    // This call has no effect outside begin/end
    // (unless it is being compiled).

    pa = GLTEB_CLTPOLYARRAY();

    if (!(pa->flags & POLYARRAY_IN_BEGIN))
    {
        return;
    }

    PADoEval2(gc, u, v);
}

void APIENTRY
glcltEvalCoord2d ( IN GLdouble u, IN GLdouble v )
{
    glcltEvalCoord2f((GLfloat) u, (GLfloat) v);
}

void APIENTRY
glcltEvalCoord2dv ( IN const GLdouble u[2] )
{
    glcltEvalCoord2f((GLfloat) u[0], (GLfloat) u[1]);
}

void APIENTRY
glcltEvalCoord2fv ( IN const GLfloat u[2] )
{
    glcltEvalCoord2f((GLfloat) u[0], (GLfloat) u[1]);
}

void APIENTRY
glcltEvalPoint2 ( IN GLint i, IN GLint j )
{
    __GL_SETUP ();
    POLYARRAY *pa;
    __GLfloat u, v;
    __GLfloat du, dv;
    __GLevaluatorGrid *gu;
    __GLevaluatorGrid *gv;

    // This call has no effect outside begin/end
    // (unless it is being compiled).

    pa = GLTEB_CLTPOLYARRAY();

    if (!(pa->flags & POLYARRAY_IN_BEGIN))
    {
        return;
    }

    gu = &gc->state.evaluator.u2;
    gv = &gc->state.evaluator.v2;
    du = gu->step;
    dv = gv->step;

    //du = (gu->finish - gu->start)/(__GLfloat)gu->n;
    //dv = (gv->finish - gv->start)/(__GLfloat)gv->n;
    u = (i == gu->n) ? gu->finish : (gu->start + i * du);
    v = (j == gv->n) ? gv->finish : (gv->start + j * dv);

    PADoEval2 (gc, u, v);
}

void APIENTRY
glcltMapGrid2d ( IN GLint un, IN GLdouble u1, IN GLdouble u2, IN GLint vn, IN GLdouble v1, IN GLdouble v2 )
{
    glcltMapGrid2f(un, (GLfloat) u1, (GLfloat) u2, vn, (GLfloat) v1, (GLfloat) v2);
}

void APIENTRY
glcltMapGrid2f ( IN GLint un, IN GLfloat u1, IN GLfloat u2, IN GLint vn, IN GLfloat v1, IN GLfloat v2 )
{
    POLYARRAY *pa;
    __GL_SETUP ();
    WORD flags = (WORD) GET_EVALSTATE (gc);

    // Check if it is called inside a Begin-End block
    // If we are already in the begin/end bracket, return an error.

    pa = GLTEB_CLTPOLYARRAY();
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    // if there are any pending API calls that affect the Evaluator state
    // then flush the message buffer

    if (flags & (__EVALS_PUSH_EVAL_ATTRIB|
                 __EVALS_POP_EVAL_ATTRIB))
        glsbAttention ();

#ifdef NT
    if (un <= 0 || vn <= 0)
    {
    __glSetError(GL_INVALID_VALUE);
    return;
    }
#endif
    gc->state.evaluator.u2.start = (__GLfloat)u1;
    gc->state.evaluator.u2.finish = (__GLfloat)u2;
    gc->state.evaluator.u2.n = un;
    gc->state.evaluator.u2.step = ((__GLfloat)u2 - (__GLfloat)u1)/(__GLfloat)un;
    
    gc->state.evaluator.v2.start = (__GLfloat)v1;
    gc->state.evaluator.v2.finish = (__GLfloat)v2;
    gc->state.evaluator.v2.n = vn;
    gc->state.evaluator.v2.step = ((__GLfloat)v2 - (__GLfloat)v1)/(__GLfloat)vn;
}


void APIENTRY
glcltMap2d ( IN GLenum target, IN GLdouble u1, IN GLdouble u2, IN GLint ustride, IN GLint uorder, IN GLdouble v1, IN GLdouble v2, IN GLint vstride, IN GLint vorder, IN const GLdouble points[] )
{
    __GLevaluator2 *ev;
    __GLfloat *data;
    POLYARRAY *pa;
    __GL_SETUP ();

    // Check if it is called inside a Begin-End block
    // If we are already in the begin/end bracket, return an error.

    pa = GLTEB_CLTPOLYARRAY();
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    ev = __glSetUpMap2(gc, target, uorder, vorder, u1, u2, v1, v2);
    if (ev == 0) {
        return;
    }
    if (ustride < ev->k) {
        __glSetError(GL_INVALID_VALUE);
        return;
    }
    if (vstride < ev->k) {
        __glSetError(GL_INVALID_VALUE);
        return;
    }
    data = gc->eval.eval2Data[__GL_EVAL2D_INDEX(target)];
    __glFillMap2d(ev->k, uorder, vorder, ustride, vstride,
                  points, data);
}

void APIENTRY
glcltMap2f ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint ustride, IN GLint uorder, IN GLfloat v1, IN GLfloat v2, IN GLint vstride, IN GLint vorder, IN const GLfloat points[] )
{
    __GLevaluator2 *ev;
    __GLfloat *data;
    POLYARRAY *pa;
    __GL_SETUP ();

    // Check if it is called inside a Begin-End block
    // If we are already in the begin/end bracket, return an error.

    pa = GLTEB_CLTPOLYARRAY();
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    ev = __glSetUpMap2(gc, target, uorder, vorder, u1, u2, v1, v2);
    if (ev == 0) {
        return;
    }
    if (ustride < ev->k) {
        __glSetError(GL_INVALID_VALUE);
        return;
    }
    if (vstride < ev->k) {
        __glSetError(GL_INVALID_VALUE);
        return;
    }
    data = gc->eval.eval2Data[__GL_EVAL2D_INDEX(target)];
    __glFillMap2f(ev->k, uorder, vorder, ustride, vstride,
                  points, data);
}

/************************************************************************/
/********************** Evaluator helper functions **********************/
/********************** taken from so_eval.c       **********************/
/************************************************************************/

GLint FASTCALL __glEvalComputeK(GLenum target)
{
    switch(target) {
      case GL_MAP1_VERTEX_4:
      case GL_MAP1_COLOR_4:
      case GL_MAP1_TEXTURE_COORD_4:
      case GL_MAP2_VERTEX_4:
      case GL_MAP2_COLOR_4:
      case GL_MAP2_TEXTURE_COORD_4:
    return 4;
      case GL_MAP1_VERTEX_3:
      case GL_MAP1_TEXTURE_COORD_3:
      case GL_MAP1_NORMAL:
      case GL_MAP2_VERTEX_3:
      case GL_MAP2_TEXTURE_COORD_3:
      case GL_MAP2_NORMAL:
    return 3;
      case GL_MAP1_TEXTURE_COORD_2:
      case GL_MAP2_TEXTURE_COORD_2:
    return 2;
      case GL_MAP1_TEXTURE_COORD_1:
      case GL_MAP2_TEXTURE_COORD_1:
      case GL_MAP1_INDEX:
      case GL_MAP2_INDEX:
    return 1;
      default:
    return -1;
    }
}


void ComputeNormal2(__GLcontext *gc, __GLfloat *n, __GLfloat *pu, 
               __GLfloat *pv)
{
    n[0] = pu[1]*pv[2] - pu[2]*pv[1];
    n[1] = pu[2]*pv[0] - pu[0]*pv[2];
    n[2] = pu[0]*pv[1] - pu[1]*pv[0];
    
#ifdef NT
// Only need to normalize auto normals if normalization is not enabled!
    if (!(gc->state.enables.general & __GL_NORMALIZE_ENABLE))
#endif
        __glNormalize(n, n);
}


void ComputeFirstPartials(__GLfloat *p, __GLfloat *pu, __GLfloat *pv)
{
    pu[0] = pu[0]*p[3] - pu[3]*p[0];
    pu[1] = pu[1]*p[3] - pu[3]*p[1];
    pu[2] = pu[2]*p[3] - pu[3]*p[2];

    pv[0] = pv[0]*p[3] - pv[3]*p[0];
    pv[1] = pv[1]*p[3] - pv[3]*p[1];
    pv[2] = pv[2]*p[3] - pv[3]*p[2];
}

/*
** define a one dimensional map
*/
__GLevaluator1 *__glSetUpMap1(__GLcontext *gc, GLenum type,
                  GLint order, __GLfloat u1, __GLfloat u2)
{
    __GLevaluator1 *ev;
    __GLfloat **evData;
    __GLfloat *pevData;

    switch (type) 
    {
      case GL_MAP1_COLOR_4:
      case GL_MAP1_INDEX:
      case GL_MAP1_NORMAL:
      case GL_MAP1_TEXTURE_COORD_1:
      case GL_MAP1_TEXTURE_COORD_2:
      case GL_MAP1_TEXTURE_COORD_3:
      case GL_MAP1_TEXTURE_COORD_4:
      case GL_MAP1_VERTEX_3:
      case GL_MAP1_VERTEX_4:
    ev = &gc->eval.eval1[__GL_EVAL1D_INDEX(type)];
    evData = &gc->eval.eval1Data[__GL_EVAL1D_INDEX(type)];
    break;
      default:
    __glSetError(GL_INVALID_ENUM);
    return 0;
    }
    if (u1 == u2 || order < 1 || order > gc->constants.maxEvalOrder) 
    {
        __glSetError(GL_INVALID_VALUE);
        return 0;
    }
    pevData = (__GLfloat *)
        GCREALLOC(gc, *evData,
                  (__glMap1_size(ev->k, order) * sizeof(__GLfloat)));
    if (!pevData)
    {
        __glSetError(GL_OUT_OF_MEMORY);
        return 0;
    }
    *evData = pevData;

    ev->order = order;
    ev->u1 = u1;
    ev->u2 = u2;

    return ev;
}

/*
** define a two dimensional map
*/
__GLevaluator2 *__glSetUpMap2(__GLcontext *gc, GLenum type,
                  GLint majorOrder, GLint minorOrder,
                  __GLfloat u1, __GLfloat u2,
                  __GLfloat v1, __GLfloat v2)
{
    __GLevaluator2 *ev;
    __GLfloat **evData;
    __GLfloat *pevData;

    switch (type) {
      case GL_MAP2_COLOR_4:
      case GL_MAP2_INDEX:
      case GL_MAP2_NORMAL:
      case GL_MAP2_TEXTURE_COORD_1:
      case GL_MAP2_TEXTURE_COORD_2:
      case GL_MAP2_TEXTURE_COORD_3:
      case GL_MAP2_TEXTURE_COORD_4:
      case GL_MAP2_VERTEX_3:
      case GL_MAP2_VERTEX_4:
    ev = &gc->eval.eval2[__GL_EVAL2D_INDEX(type)];
    evData = &gc->eval.eval2Data[__GL_EVAL2D_INDEX(type)];
    break;
      default:
    __glSetError(GL_INVALID_ENUM);
    return 0;
    }
    if (minorOrder < 1 || minorOrder > gc->constants.maxEvalOrder ||
        majorOrder < 1 || majorOrder > gc->constants.maxEvalOrder ||
        u1 == u2 || v1 == v2) 
    {
        __glSetError(GL_INVALID_VALUE);
        return 0;
    }
    pevData = (__GLfloat *)
        GCREALLOC(gc, *evData,
                  (__glMap2_size(ev->k, majorOrder, minorOrder)
                   * sizeof(__GLfloat)));
    if (!pevData)
    {
        __glSetError(GL_OUT_OF_MEMORY);
        return 0;
    }
    *evData = pevData;

    ev->majorOrder = majorOrder;
    ev->minorOrder = minorOrder;
    ev->u1 = u1;
    ev->u2 = u2;
    ev->v1 = v1;
    ev->v2 = v2;

    return ev;
}


/*
** Fill our data from user data
*/
void APIPRIVATE __glFillMap1f(GLint k, GLint order, GLint stride, 
           const GLfloat *points, __GLfloat *data)
{
    int i,j;

#ifndef __GL_DOUBLE
    /* Optimization always hit during display list execution */
    if (k == stride) 
    {
        __GL_MEMCOPY(data, points, 
                    __glMap1_size(k, order) * sizeof(__GLfloat));
        return;
    }
#endif
    for (i=0; i<order; i++) 
    {
        for (j=0; j<k; j++) 
        {
            data[j] = points[j];
        }
        points += stride;
        data += k;
    }
}


void APIPRIVATE __glFillMap1d(GLint k, GLint order, GLint stride, 
           const GLdouble *points, __GLfloat *data)
{
    int i,j;

    for (i=0; i<order; i++) 
    {
        for (j=0; j<k; j++) 
        {
            data[j] = points[j];
        }
        points += stride;
        data += k;
    }
}

void APIPRIVATE __glFillMap2f(GLint k, GLint majorOrder, GLint minorOrder, 
           GLint majorStride, GLint minorStride,
           const GLfloat *points, __GLfloat *data)
{
    int i,j,x;

#ifndef __GL_DOUBLE
    /* Optimization always hit during display list execution */
    if (k == minorStride && majorStride == k * minorOrder) 
    {
        __GL_MEMCOPY(data, points, 
            __glMap2_size(k, majorOrder, minorOrder) * sizeof(__GLfloat));
        return;
    }
#endif
    for (i=0; i<majorOrder; i++) 
    {
        for (j=0; j<minorOrder; j++) 
        {
            for (x=0; x<k; x++) 
            {
                data[x] = points[x];
            }
            points += minorStride;
            data += k;
        }
        points += majorStride - minorStride * minorOrder;
    }
}

void APIPRIVATE __glFillMap2d(GLint k, GLint majorOrder, GLint minorOrder, 
           GLint majorStride, GLint minorStride,
           const GLdouble *points, __GLfloat *data)
{
    int i,j,x;

    for (i=0; i<majorOrder; i++) 
    {
        for (j=0; j<minorOrder; j++) 
        {
            for (x=0; x<k; x++) 
            {
                data[x] = points[x];
            }
            points += minorStride;
            data += k;
        }
        points += majorStride - minorStride * minorOrder;
    }
}


#define TYPE_COEFF_AND_DERIV    1
#define TYPE_COEFF        2


void DoDomain1(__GLevaluatorMachine *em, __GLfloat u, __GLevaluator1 *e, 
    __GLfloat *v, __GLfloat *baseData)
{
    GLint j, row;
    __GLfloat uprime;
    __GLfloat *data;
    GLint k;

#ifdef NT
    ASSERTOPENGL(e->u2 != e->u1, "Assert in DoDomain1 failed\n");
    // assert(e->u2 != e->u1);
#else
    if(e->u2 == e->u1)
    return;
#endif
    uprime = (u - e->u1) / (e->u2 - e->u1);

    /* Use already cached values if possible */
    if (em->uvalue != uprime || em->uorder != e->order) 
    {
        /* Compute coefficients for values */
        PreEvaluate(e->order, uprime, em->ucoeff);
        em->utype = TYPE_COEFF;
        em->uorder = e->order;
        em->uvalue = uprime;
    }

    k=e->k;
    for (j = 0; j < k; j++) 
    {
        data=baseData+j;
        v[j] = 0;
        for (row = 0; row < e->order; row++) 
        {
            v[j] += em->ucoeff[row] * (*data);
            data += k;
        }
    }
}

// Helper Macro  used in PADoEval1 and PADoEval2
#ifdef __NO_OPTIMIZE_FOR_DLIST

#define  PropagateToNextPolyData (eval, pa)                       \
{                                                                 \
    if ((gc)->eval.accFlags & EVAL_COLOR_VALID)                   \
    {                                                             \
        (pa)->pdNextVertex->flags &= ~POLYDATA_EVAL_COLOR;        \
        if ((gc)->modes.colorIndexMode)                           \
            glcltIndexf_InCI((gc)->eval.color.r);                 \
        else                                                      \
            glcltColor4f_InRGBA ((gc)->eval.color.r,              \
                                 (gc)->eval.color.g,              \
                                 (gc)->eval.color.b,              \
                                 (gc)->eval.color.a);             \
    }                                                             \
                                                                  \
    if ((gc)->eval.accFlags & EVAL_NORMAL_VALID)                  \
    {                                                             \
        (pa)->pdNextVertex->flags &= ~POLYDATA_EVAL_NORMAL;       \
        glcltNormal3f ((gc)->eval.normal.x,                       \
                       (gc)->eval.normal.y,                       \
                       (gc)->eval.normal.z);                      \
    }                                                             \
                                                                  \
    if ((gc)->eval.accFlags & EVAL_TEXTURE_VALID)                 \
    {                                                             \
        (pa)->pdNextVertex->flags &= ~POLYDATA_EVAL_TEXCOORD;     \
        if (__GL_FLOAT_COMPARE_PONE((gc)->eval.texture.w, !=))    \
            glcltTexCoord4f ((gc)->eval.texture.x,                \
                             (gc)->eval.texture.y,                \
                             (gc)->eval.texture.z,                \
                             (gc)->eval.texture.w);               \
        else if (__GL_FLOAT_NEZ((gc)->eval.texture.z))            \
            glcltTexCoord3f ((gc)->eval.texture.x,                \
                             (gc)->eval.texture.y,                \
                             (gc)->eval.texture.z);               \
        else if (__GL_FLOAT_NEZ((gc)->eval.texture.y))            \
            glcltTexCoord2f ((gc)->eval.texture.x,                \
                             (gc)->eval.texture.y);               \
        else                                                      \
            glcltTexCoord1f ((gc)->eval.texture.x);               \
    }                                                             \
}

#else

#define  PropagateToNextPolyData(eval,pa)                         \
                                                                  \
    if ((gc)->eval.accFlags & EVAL_COLOR_VALID)                   \
    {                                                             \
        (pa)->pdNextVertex->flags &= ~POLYDATA_EVAL_COLOR;        \
        if ((gc)->modes.colorIndexMode)                           \
            glcltIndexf_InCI((gc)->eval.color.r);                 \
        else                                                      \
            glcltColor4f_InRGBA ((gc)->eval.color.r,              \
                                 (gc)->eval.color.g,              \
                                 (gc)->eval.color.b,              \
                                 (gc)->eval.color.a);             \
    }                                                             \
                                                                  \
    if ((gc)->eval.accFlags & EVAL_NORMAL_VALID)                  \
    {                                                             \
        (pa)->pdNextVertex->flags &= ~POLYDATA_EVAL_NORMAL;       \
        glcltNormal3f ((gc)->eval.normal.x,                       \
                       (gc)->eval.normal.y,                       \
                       (gc)->eval.normal.z);                      \
    }                                                             \
                                                                  \
    if ((gc)->eval.accFlags & EVAL_TEXTURE_VALID)                 \
    {                                                             \
        (pa)->pdNextVertex->flags &= ~POLYDATA_EVAL_TEXCOORD;     \
        glcltTexCoord4f ((gc)->eval.texture.x,                    \
                         (gc)->eval.texture.y,                    \
                         (gc)->eval.texture.z,                    \
                         (gc)->eval.texture.w);                   \
    }                                                             

#endif



//////////////////////////////////////////////////////
// Assuming that the latest State is available here //
//////////////////////////////////////////////////////
void FASTCALL PADoEval1(__GLcontext *gc, __GLfloat u)
{
    __GLevaluator1 *eval;
    __GLfloat **evalData;
    __GLevaluatorMachine em;
    __GLfloat v4[4];
    __GLfloat n3[3];
    __GLfloat t4[4];
    __GLfloat c4[4];
    __GLfloat ci;
    POLYARRAY *pa;
    
    pa = gc->paTeb;

    eval = gc->eval.eval1;
    evalData = gc->eval.eval1Data;
    em = gc->eval;
    
    // Initialize the flag
    gc->eval.accFlags = 0;
    
    // Evaluated color, index, normal and texture coords are ignored 
    // in selection

    if ((gc->renderMode != GL_SELECT) &&
        (gc->state.enables.eval1 & (__GL_MAP1_VERTEX_4_ENABLE | 
                                    __GL_MAP1_VERTEX_3_ENABLE ))
        )
    {
        if (gc->modes.colorIndexMode)
        {
            if (!(gc->state.enables.general & __GL_LIGHTING_ENABLE))
            {
                if (gc->state.enables.eval1 & __GL_MAP1_INDEX_ENABLE)
                {
                    DoDomain1(&em, u, &eval[__GL_I], &ci, evalData[__GL_I]);
                    glcltIndexf_Eval(ci);
                }
            }
        }
        else
        {
            if (gc->state.enables.eval1 & __GL_MAP1_COLOR_4_ENABLE)
            {
                // NOTE: In OpenGL 1.0, color material does not apply to 
                // evaluated colors.
                // In OpenGL 1.1, this behavior was changed.  
                // This (1.1) code assumes that ColorMaterial applies to 
                // evaluated colors to simplify the graphics pipeline.
                // Otherwise, the evaluated colors have no effect when 
                // lighting is enabled.

                DoDomain1(&em, u, &eval[__GL_C4], c4, evalData[__GL_C4]);
                
                // If some color is set in the current polydata, then
                // Save it in a temporary buffer and call glcltColor later
                // Also make sure that the current-color pointer is updated 
                // appropriately

                glcltColor4fv_Eval(c4);
            }

            if (gc->state.enables.eval1 & __GL_MAP1_TEXTURE_COORD_4_ENABLE)
            {
                DoDomain1(&em, u, &eval[__GL_T4], t4, evalData[__GL_T4]);
                glcltTexCoord4fv_Eval(t4);
            }
            else if (gc->state.enables.eval1 &
                                          __GL_MAP1_TEXTURE_COORD_3_ENABLE)
            {
                DoDomain1(&em, u, &eval[__GL_T3], t4, evalData[__GL_T3]);
                glcltTexCoord3fv_Eval(t4);
            }
            else if (gc->state.enables.eval1 & 
                                        __GL_MAP1_TEXTURE_COORD_2_ENABLE)
            {
                DoDomain1(&em, u, &eval[__GL_T2], t4, evalData[__GL_T2]);
                glcltTexCoord2fv_Eval(t4);
            }
            else if (gc->state.enables.eval1 & 
                                        __GL_MAP1_TEXTURE_COORD_1_ENABLE)
            {
                DoDomain1(&em, u, &eval[__GL_T1], t4, evalData[__GL_T1]);
                glcltTexCoord1fv_Eval(t4);
            }
        }

        if (gc->state.enables.eval1 & __GL_MAP1_NORMAL_ENABLE)
        {
            DoDomain1(&em, u, &eval[__GL_N3], n3, evalData[__GL_N3]);
            glcltNormal3fv_Eval(n3);
        }
    }

    /* Vertex */

    if (gc->state.enables.eval1 & __GL_MAP1_VERTEX_4_ENABLE)
    {
        DoDomain1(&em, u, &eval[__GL_V4], v4, evalData[__GL_V4]);
        glcltVertex4fv (v4);
    }
    else if (gc->state.enables.eval1 & __GL_MAP1_VERTEX_3_ENABLE)
    {
        DoDomain1(&em, u, &eval[__GL_V3], v4, evalData[__GL_V3]);
        glcltVertex3fv (v4);
    }

    // If there are any prior glcltColor, glcltIndex, glcltTexCoord
    // or glcltNormal calls. The values are saved in gc->eval. Use
    // these and propagate them, to the next PolyData

    PropagateToNextPolyData (eval, pa);
}


// Compute the color, texture, normal, vertex based upon u and v.
//
// NOTE: This function is called by the client side EvalMesh2 functions.
//       If you modify it, make sure that you modify the callers too!

//////////////////////////////////////////////////////
// Assuming that the latest State is available here //
//////////////////////////////////////////////////////
void FASTCALL PADoEval2(__GLcontext *gc, __GLfloat u, __GLfloat v)
{
    __GLevaluator2 *eval = gc->eval.eval2;
    __GLfloat **evalData = gc->eval.eval2Data;
    __GLevaluatorMachine em = gc->eval;
    __GLfloat v4[4];
    __GLfloat n3[3];
    __GLfloat t4[4];
    __GLfloat c4[4];
    __GLfloat ci;
    POLYARRAY *pa;
    
    pa = gc->paTeb;

    // Mark this PolyArray to indicate that it has a Evaluator vertex
    // pa->flags |= POLYARRAY_EVALCOORD;
    
// Evaluated colors, normals and texture coords are ignored in selection.

    if (gc->renderMode == GL_SELECT)
    {
        if (gc->state.enables.eval2 & __GL_MAP2_VERTEX_4_ENABLE)
        {
            DoDomain2(&em, u, v, &eval[__GL_V4], v4, evalData[__GL_V4]);
            glcltVertex4fv (v4);
        }
        else if (gc->state.enables.eval2 & __GL_MAP2_VERTEX_3_ENABLE)
        {
            DoDomain2(&em, u, v, &eval[__GL_V3], v4, evalData[__GL_V3]);
            glcltVertex3fv (v4);
        }
        return;
    }

    if (gc->state.enables.eval2 & (__GL_MAP2_VERTEX_3_ENABLE |
                                   __GL_MAP2_VERTEX_4_ENABLE))
    {
        if (gc->modes.colorIndexMode)
        {
            if (!(gc->state.enables.general & __GL_LIGHTING_ENABLE))
            {
                if (gc->state.enables.eval2 & __GL_MAP2_INDEX_ENABLE)
                {
                    DoDomain2(&em, u, v, &eval[__GL_I], &ci, evalData[__GL_I]);
                    glcltIndexf_Eval(ci);
                }
            }
        }
        else
        {
            if (gc->state.enables.eval2 & __GL_MAP2_COLOR_4_ENABLE)
            {
                DoDomain2(&em, u, v, &eval[__GL_C4], c4, evalData[__GL_C4]);
                glcltColor4fv_Eval(c4);
            }
            
            if (gc->state.enables.eval2 & __GL_MAP2_TEXTURE_COORD_4_ENABLE)
            {
                DoDomain2(&em, u, v, &eval[__GL_T4], t4, evalData[__GL_T4]);
                glcltTexCoord4fv_Eval(t4);
            }
            else if (gc->state.enables.eval2 & 
                     __GL_MAP2_TEXTURE_COORD_3_ENABLE)
            {
                DoDomain2(&em, u, v, &eval[__GL_T3], t4, evalData[__GL_T3]);
                glcltTexCoord3fv_Eval(t4);
            }
            else if (gc->state.enables.eval2 & 
                     __GL_MAP2_TEXTURE_COORD_2_ENABLE)
            {
                DoDomain2(&em, u, v, &eval[__GL_T2], t4, evalData[__GL_T2]);
                glcltTexCoord2fv_Eval(t4);
            }
            else if (gc->state.enables.eval2 & 
                     __GL_MAP2_TEXTURE_COORD_1_ENABLE)
            {
                DoDomain2(&em, u, v, &eval[__GL_T1], t4, evalData[__GL_T1]); 
                glcltTexCoord1fv_Eval(t4);
            }
        }

        if (gc->state.enables.general & __GL_AUTO_NORMAL_ENABLE)
        {
            if (gc->state.enables.eval2 & __GL_MAP2_VERTEX_4_ENABLE)
            {
                __GLfloat du[4];
                __GLfloat dv[4];

                DoDomain2WithDerivs(&em, u, v, &eval[__GL_V4], v4, du, dv,
                                    evalData[__GL_V4]);
                ComputeFirstPartials(v4, du, dv);
                ComputeNormal2(gc, n3, du, dv);
                glcltNormal3fv_Eval(n3);
                glcltVertex4fv(v4);
            }
            else if (gc->state.enables.eval2 & __GL_MAP2_VERTEX_3_ENABLE)
            {
                __GLfloat du[3];
                __GLfloat dv[3];
                DoDomain2WithDerivs(&em, u, v, &eval[__GL_V3], v4, du, dv,
                                    evalData[__GL_V3]);
                ComputeNormal2(gc, n3, du, dv);
                glcltNormal3fv_Eval(n3);
                glcltVertex3fv(v4);
            }
        }
        else
        {
            if (gc->state.enables.eval2 & __GL_MAP2_NORMAL_ENABLE)
            {
                DoDomain2(&em, u, v, &eval[__GL_N3], n3, evalData[__GL_N3]);
                glcltNormal3fv_Eval(n3);
            }
            if (gc->state.enables.eval2 & __GL_MAP2_VERTEX_4_ENABLE)
            {
                DoDomain2(&em, u, v, &eval[__GL_V4], v4, evalData[__GL_V4]);
                glcltVertex4fv(v4);
            }
            else if (gc->state.enables.eval2 & __GL_MAP2_VERTEX_3_ENABLE)
            {
                DoDomain2(&em, u, v, &eval[__GL_V3], v4, evalData[__GL_V3]);
                glcltVertex3fv(v4);
            }
        }
    }
    
    // If there are any prior glcltColor, glcltIndex, glcltTexCoord
    // or glcltNormal calls. The values are saved in gc->eval. Use
    // these and propagate them, to the next PolyData

    PropagateToNextPolyData (eval, pa);
}

#define COPYMESHVERTEX(m,v)                                          \
{                                                                    \
    (m)->vertex.x = (v)[0];                                          \
    (m)->vertex.y = (v)[1];                                          \
    (m)->vertex.z = (v)[2];                                          \
    (m)->vertex.w = (v)[3];                                          \
}                                                               

#define COPYMESHNORMAL(m,n)                                          \
{                                                                    \
    (m)->normal.x = (n)[0];                                          \
    (m)->normal.y = (n)[1];                                          \
    (m)->normal.z = (n)[2];                                          \
}                                                               

#define COPYMESHCOLOR(m,c)                                          \
{                                                                   \
    (m)->color.r = (c)[0];                                          \
    (m)->color.g = (c)[1];                                          \
    (m)->color.b = (c)[2];                                          \
    (m)->color.a = (c)[3];                                          \
}                                                               

#define COPYMESHTEXTURE(m,t)                                          \
{                                                                     \
    (m)->texture.x = (t)[0];                                          \
    (m)->texture.y = (t)[1];                                          \
    (m)->texture.z = (t)[2];                                          \
    (m)->texture.w = (t)[3];                                          \
}                                                               

//////////////////////////////////////////////////////
// Assuming that the latest State is available here //
//////////////////////////////////////////////////////
void FASTCALL PADoEval2VArray(__GLcontext *gc, __GLfloat u, __GLfloat v, 
                              MESHVERTEX *mv, GLuint *flags)
{
    __GLevaluator2 *eval = gc->eval.eval2;
    __GLfloat **evalData = gc->eval.eval2Data;
    __GLevaluatorMachine em = gc->eval;
    __GLfloat v4[4];
    __GLfloat n3[3];
    __GLfloat t4[4];
    __GLfloat c4[4];
    __GLfloat ci;
    
// Evaluated colors, normals and texture coords are ignored in selection.

    if (gc->renderMode == GL_SELECT)
    {
        if (gc->state.enables.eval2 & __GL_MAP2_VERTEX_4_ENABLE)
        {
            DoDomain2(&em, u, v, &eval[__GL_V4], v4, evalData[__GL_V4]);
            *flags = *flags | MV_VERTEX4;
        }
        else if (gc->state.enables.eval2 & __GL_MAP2_VERTEX_3_ENABLE)
        {
            DoDomain2(&em, u, v, &eval[__GL_V3], v4, evalData[__GL_V3]);
            *flags = *flags | MV_VERTEX3;
        }
        COPYMESHVERTEX (mv, v4);
        return;
    }

    if (gc->state.enables.general & __GL_AUTO_NORMAL_ENABLE)
    {
        if (gc->state.enables.eval2 & __GL_MAP2_VERTEX_4_ENABLE)
        {
            __GLfloat du[4];
            __GLfloat dv[4];

            DoDomain2WithDerivs(&em, u, v, &eval[__GL_V4], v4, du, dv,
                                evalData[__GL_V4]);
            ComputeFirstPartials(v4, du, dv);
            ComputeNormal2(gc, n3, du, dv);
            *flags = *flags | MV_VERTEX4 | MV_NORMAL;
        }
        else if (gc->state.enables.eval2 & __GL_MAP2_VERTEX_3_ENABLE)
        {
            __GLfloat du[3];
            __GLfloat dv[3];
            DoDomain2WithDerivs(&em, u, v, &eval[__GL_V3], v4, du, dv,
                                evalData[__GL_V3]);
            ComputeNormal2(gc, n3, du, dv);
            *flags = *flags | MV_VERTEX3 | MV_NORMAL;
        }
        COPYMESHNORMAL (mv, n3);
        COPYMESHVERTEX (mv, v4);
    }
    else
    {
        if (gc->state.enables.eval2 & __GL_MAP2_NORMAL_ENABLE)
        {
            DoDomain2(&em, u, v, &eval[__GL_N3], n3, evalData[__GL_N3]);
            COPYMESHNORMAL (mv, n3);
            *flags = *flags | MV_NORMAL;
        }
        if (gc->state.enables.eval2 & __GL_MAP2_VERTEX_4_ENABLE)
        {
            DoDomain2(&em, u, v, &eval[__GL_V4], v4, evalData[__GL_V4]);
            COPYMESHVERTEX (mv, v4);
            *flags = *flags | MV_VERTEX4;
        }
        else if (gc->state.enables.eval2 & __GL_MAP2_VERTEX_3_ENABLE)
        {
            DoDomain2(&em, u, v, &eval[__GL_V3], v4, evalData[__GL_V3]);
            COPYMESHVERTEX (mv, v4);
            *flags = *flags | MV_VERTEX3;
        }
    }

    if (gc->modes.colorIndexMode)
    {
        if (!(gc->state.enables.general & __GL_LIGHTING_ENABLE))
        {
            if (gc->state.enables.eval2 & __GL_MAP2_INDEX_ENABLE)
            {
                DoDomain2(&em, u, v, &eval[__GL_I], &(mv->color.r), 
                evalData[__GL_I]);
                *flags = *flags | MV_INDEX;
            }
        }
    }
    else
    {
        if (gc->state.enables.eval2 & __GL_MAP2_COLOR_4_ENABLE)
        {
            DoDomain2(&em, u, v, &eval[__GL_C4], c4, evalData[__GL_C4]);
            COPYMESHCOLOR (mv, c4);
            *flags = *flags | MV_COLOR;
        }

        if (gc->state.enables.eval2 & __GL_MAP2_TEXTURE_COORD_4_ENABLE)
        {
            DoDomain2(&em, u, v, &eval[__GL_T4], t4, evalData[__GL_T4]);
            COPYMESHTEXTURE (mv, t4);
            *flags = *flags | MV_TEXTURE4;
        }
        else if (gc->state.enables.eval2 & __GL_MAP2_TEXTURE_COORD_3_ENABLE)
        {
            DoDomain2(&em, u, v, &eval[__GL_T3], t4, evalData[__GL_T3]);
            COPYMESHTEXTURE (mv, t4);
            *flags = *flags | MV_TEXTURE3;
        }
        else if (gc->state.enables.eval2 & __GL_MAP2_TEXTURE_COORD_2_ENABLE)
        {
            DoDomain2(&em, u, v, &eval[__GL_T2], t4, evalData[__GL_T2]);
            COPYMESHTEXTURE (mv, t4);
            *flags = *flags | MV_TEXTURE2;
        }
        else if (gc->state.enables.eval2 & __GL_MAP2_TEXTURE_COORD_1_ENABLE)
        {
            DoDomain2(&em, u, v, &eval[__GL_T1], t4, evalData[__GL_T1]); 
            COPYMESHTEXTURE (mv, t4);
            *flags = *flags | MV_TEXTURE1;
        }
    }
}


/*
** Optimization to precompute coefficients for polynomial evaluation.
*/
static void PreEvaluate(GLint order, __GLfloat vprime, __GLfloat *coeff)
{
    GLint i, j;
    __GLfloat oldval, temp;
    __GLfloat oneMinusvprime;

    /*
    ** Minor optimization
    ** Compute orders 1 and 2 outright, and set coeff[0], coeff[1] to
    ** their i==1 loop values to avoid the initialization and the i==1 loop.
    */
    if (order == 1) 
    {
        coeff[0] = ((__GLfloat) 1.0);
        return;
    }

    oneMinusvprime = 1-vprime;
    coeff[0] = oneMinusvprime;
    coeff[1] = vprime;
    if (order == 2) return;

    for (i = 2; i < order; i++) 
    {
        oldval = coeff[0] * vprime;
        coeff[0] = oneMinusvprime * coeff[0];
        for (j = 1; j < i; j++) 
        {
            temp = oldval;
            oldval = coeff[j] * vprime;
            coeff[j] = temp + oneMinusvprime * coeff[j];
        }
        coeff[j] = oldval;
    }
}

/*
** Optimization to precompute coefficients for polynomial evaluation.
*/
static void PreEvaluateWithDeriv(GLint order, __GLfloat vprime, 
    __GLfloat *coeff, __GLfloat *coeffDeriv)
{
    GLint i, j;
    __GLfloat oldval, temp;
    __GLfloat oneMinusvprime;

    oneMinusvprime = 1-vprime;
    /*
    ** Minor optimization
    ** Compute orders 1 and 2 outright, and set coeff[0], coeff[1] to 
    ** their i==1 loop values to avoid the initialization and the i==1 loop.
    */
    if (order == 1) 
    {
        coeff[0] = ((__GLfloat) 1.0);
        coeffDeriv[0] = __glZero;
        return;
    } 
    else if (order == 2) 
    {
        coeffDeriv[0] = __glMinusOne;
        coeffDeriv[1] = ((__GLfloat) 1.0);
        coeff[0] = oneMinusvprime;
        coeff[1] = vprime;
        return;
    }
    coeff[0] = oneMinusvprime;
    coeff[1] = vprime;
    for (i = 2; i < order - 1; i++) 
    {
        oldval = coeff[0] * vprime;
        coeff[0] = oneMinusvprime * coeff[0];
        for (j = 1; j < i; j++) 
        {
            temp = oldval;
            oldval = coeff[j] * vprime;
            coeff[j] = temp + oneMinusvprime * coeff[j];
        }
        coeff[j] = oldval;
    }
    coeffDeriv[0] = -coeff[0];
    /*
    ** Minor optimization:
    ** Would make this a "for (j=1; j<order-1; j++)" loop, but it is always
    ** executed at least once, so this is more efficient.
    */
    j=1;
    do 
    {
        coeffDeriv[j] = coeff[j-1] - coeff[j];
        j++;
    } while (j < order - 1);
    coeffDeriv[j] = coeff[j-1];

    oldval = coeff[0] * vprime;
    coeff[0] = oneMinusvprime * coeff[0];
    for (j = 1; j < i; j++) 
    {
        temp = oldval;
        oldval = coeff[j] * vprime;
        coeff[j] = temp + oneMinusvprime * coeff[j];
    }
    coeff[j] = oldval;
}

void DoDomain2(__GLevaluatorMachine *em, __GLfloat u, __GLfloat v, 
    __GLevaluator2 *e, __GLfloat *r, __GLfloat *baseData)
{
    GLint j, row, col;
    __GLfloat uprime;
    __GLfloat vprime;
    __GLfloat p;
    __GLfloat *data;
    GLint k;
    
#ifdef NT
    ASSERTOPENGL((e->u2 != e->u1) && (e->v2 != e->v1), "In DoDomain2\n");
    // assert((e->u2 != e->u1) && (e->v2 != e->v1));
#else
    if((e->u2 == e->u1) || (e->v2 == e->v1))
    return;
#endif
    uprime = (u - e->u1) / (e->u2 - e->u1);
    vprime = (v - e->v1) / (e->v2 - e->v1);

    /* Compute coefficients for values */

    /* Use already cached values if possible */
    if (em->uvalue != uprime || em->uorder != e->majorOrder) 
    {
        PreEvaluate(e->majorOrder, uprime, em->ucoeff);
        em->utype = TYPE_COEFF;
        em->uorder = e->majorOrder;
        em->uvalue = uprime;
    }
    if (em->vvalue != vprime || em->vorder != e->minorOrder) 
    {
        PreEvaluate(e->minorOrder, vprime, em->vcoeff);
        em->vtype = TYPE_COEFF;
        em->vorder = e->minorOrder;
        em->vvalue = vprime;
    }
    
    k=e->k;
    for (j = 0; j < k; j++) 
    { 
        data=baseData+j;
        r[j] = 0;
        for (row = 0; row < e->majorOrder; row++)  
        {
            /* 
            ** Minor optimization.
            ** The col == 0 part of the loop is extracted so we don't
            ** have to initialize p to 0.
            */
            p=em->vcoeff[0] * (*data);
            data += k;
            for (col = 1; col < e->minorOrder; col++) 
            {
                p += em->vcoeff[col] * (*data);
                data += k;
            }
            r[j] += em->ucoeff[row] * p;
        }
    }
}

void DoDomain2WithDerivs(__GLevaluatorMachine *em, __GLfloat u, 
        __GLfloat v, __GLevaluator2 *e, __GLfloat *r,
        __GLfloat *du, __GLfloat *dv, __GLfloat *baseData)
{
    GLint j, row, col;
    __GLfloat uprime;
    __GLfloat vprime;
    __GLfloat p;
    __GLfloat pdv;
    __GLfloat n[3];
    __GLfloat *data;
    GLint k;

#ifdef NT
    ASSERTOPENGL((e->u2 != e->u1) && (e->v2 != e->v1), 
                 "In Dodomain2WithDerivs\n");
    // assert((e->u2 != e->u1) && (e->v2 != e->v1));
#else
    if((e->u2 == e->u1) || (e->v2 == e->v1))
    return;
#endif
    uprime = (u - e->u1) / (e->u2 - e->u1);
    vprime = (v - e->v1) / (e->v2 - e->v1);
    
    /* Compute coefficients for values and derivs */

    /* Use already cached values if possible */
    if (em->uvalue != uprime || em->utype != TYPE_COEFF_AND_DERIV || 
      em->uorder != e->majorOrder) 
    {
        PreEvaluateWithDeriv(e->majorOrder, uprime, em->ucoeff, 
                             em->ucoeffDeriv);
        em->utype = TYPE_COEFF_AND_DERIV;
        em->uorder = e->majorOrder;
        em->uvalue = uprime;
    }
    if (em->vvalue != vprime || em->vtype != TYPE_COEFF_AND_DERIV ||
      em->vorder != e->minorOrder) 
    {
        PreEvaluateWithDeriv(e->minorOrder, vprime, em->vcoeff, 
                             em->vcoeffDeriv);
        em->vtype = TYPE_COEFF_AND_DERIV;
        em->vorder = e->minorOrder;
        em->vvalue = vprime;
    }

    k=e->k;
    for (j = 0; j < k; j++) 
    {
        data=baseData+j;
        r[j] = du[j] = dv[j] = __glZero;
        for (row = 0; row < e->majorOrder; row++)  
        {
            /* 
            ** Minor optimization.
            ** The col == 0 part of the loop is extracted so we don't
            ** have to initialize p and pdv to 0.
            */
            p = em->vcoeff[0] * (*data);
            pdv = em->vcoeffDeriv[0] * (*data);
            data += k;
            for (col = 1; col < e->minorOrder; col++) 
            {
                /* Incrementally build up p, pdv value */
                p += em->vcoeff[col] * (*data);
                pdv += em->vcoeffDeriv[col] * (*data);
                data += k;
            }
            /* Use p, pdv value to incrementally add up r, du, dv */
            r[j] += em->ucoeff[row] * p;
            du[j] += em->ucoeffDeriv[row] * p;
            dv[j] += em->ucoeff[row] * pdv;
        }
    }
}

int FASTCALL genMeshElts (GLenum mode, GLuint sides, GLint nu, GLint nv, 
                          GLubyte *buff)
{
GLint start;
GLint i, j, k;

// Compute the DrawElements Indices

    switch(mode) {
      case GL_LINE :
        // Draw lines along U direction
        start = 1;
        k = 0;
        if (sides & MV_TOP)
            start = 0 ;
        for (i=start; i<nv; i++)
            for(j=0; j<nu-1; j++) {
                buff[k++] = i*nu+j;
                buff[k++] = i*nu+j+1;
            }

        // Draw lines along V direction
        start = 1 ;
        if (sides & MV_LEFT)
            start = 0;
        for (i=start; i<nu; i++)
            for (j=0; j<nv-1; j++) {
                buff[k++] = j*nu+i;
                buff[k++] = (j+1)*nu+i;
            }
        break ;

      case GL_FILL  :
        for (i=0, k=0; i<nv-1; i++)
            for (j=0; j<nu-1; j++) {
                buff[k++] = i*nu+j;
                buff[k++] = (i+1)*nu+j;
                buff[k++] = (i+1)*nu+j+1;
                buff[k++] = i*nu+j+1;
            }
        break ;
    }
    return k; //the total number of points
}

void FASTCALL PA_EvalMesh2Fast(__GLcontext *gc, GLint u1, GLint u2, GLint v1,
                               GLint v2, GLint meshSize, GLenum mode, 
                               GLuint sides)
{
    GLint i, j, k, nu, nv;
    __GLcolor currentColor;
    __GLcoord currentNormal, currentTexture;
    GLboolean currentEdgeFlag;
    MESHVERTEX *mv, mvBuf[MAX_U_SIZE*MAX_V_SIZE];
    GLuint mflags = 0;
    GLuint stride;
    GLubyte *disBuf;
    __GLvertexArray currentVertexInfo;
    GLuint texSize = 0, start, totalPts;
    GLubyte dBufSmall[4*MAX_U_SIZE*MAX_V_SIZE];     //small
    __GLfloat u, v;
    __GLfloat du, dv;
    __GLevaluatorGrid *gu;
    __GLevaluatorGrid *gv;

    // Now build the mesh vertex array [0..u2-u1, 0..v2-v1]
  
    gu = &gc->state.evaluator.u2;
    gv = &gc->state.evaluator.v2;

    du = gu->step;
    dv = gv->step;
    //du = (gu->finish - gu->start)/(__GLfloat)gu->n;
    //dv = (gv->finish - gv->start)/(__GLfloat)gv->n;

    mv = &mvBuf[0];
    nu = u2 - u1 + 1;
    nv = v2 - v1 + 1;
    for (i = v1; i < nv+v1; i++)                     //along V 
    {                   
        for (j = u1; j < nu+u1; j++)                 //along U
        {               
            u = (j == gu->n) ? gu->finish : (gu->start + j * du);
            v = (i == gv->n) ? gv->finish : (gv->start + i * dv);
            PADoEval2VArray(gc, u, v, mv, &mflags);
            mv++;
        }
    }
    
    if ((nv != MAX_V_SIZE) || (nu != MAX_U_SIZE)) {
        disBuf = dBufSmall;
        totalPts = genMeshElts (mode, sides, nu, nv, disBuf);
    } else {
        if (mode == GL_FILL) {
            disBuf = dBufFill;
            totalPts = totFillPts;
        } else
            switch (sides) {
              case (MV_TOP | MV_LEFT): 
                disBuf = dBufTopLeft;
                totalPts = totTopLeftPts;
                break;
              case (MV_TOP): 
                disBuf = dBufTopRight;
                totalPts = totTopRightPts;
                break;
              case (MV_LEFT): 
                disBuf = &dBufTopLeft [(MAX_U_SIZE - 1) * 2];
                totalPts = totTopLeftPts - (MAX_U_SIZE - 1) * 2;
                break;
              default : //NONE
                disBuf = &dBufTopRight [(MAX_V_SIZE - 1) * 2];
                totalPts = totTopRightPts - (MAX_V_SIZE - 1) * 2;
                break;
            }
    }

    if (mflags & MV_TEXTURE4)
            texSize = 4;
    else if (mflags & MV_TEXTURE3)
            texSize = 3;
    else if (mflags & MV_TEXTURE2)
            texSize = 2;
    else if (mflags & MV_TEXTURE1)
            texSize = 1;
    
    // Save current values.

    if (mflags & MV_NORMAL)
        currentNormal = gc->state.current.normal;

    if (mflags & MV_INDEX)
        currentColor.r = gc->state.current.userColorIndex;
    else if (mflags & MV_COLOR)
        currentColor = gc->state.current.userColor;

    if (texSize)
        currentTexture = gc->state.current.texture;

    // Always force edge flag on in GL_FILL mode.  The spec uses QUAD_STRIP
    // which implies that edge flag is on for the evaluated mesh.
    currentEdgeFlag = gc->state.current.edgeTag;
    gc->state.current.edgeTag = GL_TRUE;

    currentVertexInfo = gc->vertexArray;

//Enable the appropriate arrays    

    // Disable the arrays followed by enabling each individual array.
    gc->vertexArray.flags |= __GL_VERTEX_ARRAY_DIRTY;
    gc->vertexArray.mask &= ~(VAMASK_VERTEX_ENABLE_MASK |
                  VAMASK_NORMAL_ENABLE_MASK |
                  VAMASK_COLOR_ENABLE_MASK |
                  VAMASK_INDEX_ENABLE_MASK |
                  VAMASK_TEXCOORD_ENABLE_MASK |
                  VAMASK_EDGEFLAG_ENABLE_MASK);

    stride = sizeof(MESHVERTEX);
    if (mflags & MV_NORMAL) 
    {
        gc->vertexArray.mask |= VAMASK_NORMAL_ENABLE_MASK;
        glcltNormalPointer(GL_FLOAT, stride, &(mvBuf[0].normal.x));        
    }

    if (mflags & MV_INDEX) {
    gc->vertexArray.mask |= VAMASK_INDEX_ENABLE_MASK;
        glcltIndexPointer(GL_FLOAT, stride, &(mvBuf[0].color.r));
    } else if (mflags & MV_COLOR) {
    gc->vertexArray.mask |= VAMASK_COLOR_ENABLE_MASK;
        glcltColorPointer(3, GL_FLOAT, stride, &(mvBuf[0].color.r));
    }

    if (texSize) 
    {
        glcltTexCoordPointer(texSize, GL_FLOAT, stride, 
                             &(mvBuf[0].texture.x));
        gc->vertexArray.mask |= VAMASK_TEXCOORD_ENABLE_MASK;
    }

    if (mflags & MV_VERTEX3)
        glcltVertexPointer(3, GL_FLOAT, stride, &(mvBuf[0].vertex.x));
    else
        glcltVertexPointer(4, GL_FLOAT, stride, &(mvBuf[0].vertex.x));
    gc->vertexArray.mask |= VAMASK_VERTEX_ENABLE_MASK;

    if (mode == GL_FILL)
        glcltDrawElements(GL_QUADS, totalPts, GL_UNSIGNED_BYTE, disBuf);
    else
        glcltDrawElements(GL_LINES, totalPts, GL_UNSIGNED_BYTE, disBuf);

    // Execute the command now.  
    // Otherwise, the current states will be messed up.

    glsbAttention();

    // Restore current values.

    if (mflags & MV_NORMAL)
        gc->state.current.normal = currentNormal;
    
    if (mflags & MV_INDEX)
        gc->state.current.userColorIndex = currentColor.r;
    else if (mflags & MV_COLOR)
        gc->state.current.userColor = currentColor;

    if (texSize)
        gc->state.current.texture = currentTexture;

    gc->state.current.edgeTag = currentEdgeFlag;
    gc->vertexArray = currentVertexInfo ;
}


void glcltColor4fv_Eval (__GLfloat *c4)
{
    __GL_SETUP ();
    POLYARRAY *pa;
    POLYDATA *pd;
    // POLYDATA *pdNext;
    
    pa = gc->paTeb; 
	pd = pa->pdNextVertex;					            

    // We are in RGBA mode.
    ASSERTOPENGL (!gc->modes.colorIndexMode, "We should be in RGBA mode\n");

    // Do not update the CurColor pointer 

    // If the color has already been set by a previous glcltColor call,
    // simply, push this color to the next POLYDATA. 
    // This is a COLOR and not an INDEX. 
    if ((pd->flags & POLYDATA_COLOR_VALID) &&
        !(pd->flags & POLYDATA_EVAL_COLOR))
    {
        gc->eval.color.r = pd->colors[0].r;
        gc->eval.color.g = pd->colors[0].g;
        gc->eval.color.b = pd->colors[0].b;
        gc->eval.color.a = pd->colors[0].a;
        gc->eval.accFlags |= EVAL_COLOR_VALID;
    }


    __GL_SCALE_AND_CHECK_CLAMP_RGBA(pd->colors[0].r,                    
                                    pd->colors[0].g,                
                                    pd->colors[0].b,                
                                    pd->colors[0].a,                
                                    gc, pa->flags,                  
                                    c4[0], c4[1], c4[2], c4[3]);       
    pd->flags |= (POLYDATA_COLOR_VALID | POLYDATA_DLIST_COLOR_4 | 
                  POLYDATA_EVAL_COLOR) ;	   
    pa->pdLastEvalColor = pd;
}

void glcltIndexf_Eval (__GLfloat ci)
{
    __GL_SETUP ();
    POLYARRAY *pa;
    POLYDATA *pd;
    
    pa = gc->paTeb; 
	pd = pa->pdNextVertex;					            

    // We are in CI mode.
    ASSERTOPENGL (gc->modes.colorIndexMode, "We should be in CI mode\n");

    // Do not update the CurColor pointer 

    // If the index has already been set by a previous glcltIndex call,
    // simply, push this color to the next POLYDATA. 
    // This is an INDEX and not a COLOR. 
    if ((pd->flags & POLYDATA_COLOR_VALID) &&
        !(pd->flags & POLYDATA_EVAL_COLOR))
    {
        gc->eval.color.r = pd->colors[0].r;
        gc->eval.accFlags |= EVAL_COLOR_VALID;
    }
    
    __GL_CHECK_CLAMP_CI(pd->colors[0].r, gc, pa->flags, ci);	
    pd->flags |= (POLYDATA_COLOR_VALID | POLYDATA_EVAL_COLOR) ;	   
    pa->pdLastEvalColor = pd;
}

void glcltTexCoord1fv_Eval (__GLfloat *t1)
{
    __GL_SETUP ();
    POLYARRAY *pa;
    POLYDATA *pd;
    
    pa = GLTEB_CLTPOLYARRAY();
	pa->flags |= POLYARRAY_TEXTURE1;
	pd = pa->pdNextVertex;					            

    // Do not update the CurTexture pointer 

    if (pd->flags & POLYDATA_TEXTURE_VALID) 
    {
        ASSERTOPENGL (!(pd->flags & POLYDATA_EVAL_TEXCOORD), 
                      "This cannot have been generated by an evaluator\n");
        gc->eval.texture.x = pd->texture.x;
        gc->eval.texture.y = pd->texture.y;
        gc->eval.texture.z = pd->texture.z;
        gc->eval.texture.w = pd->texture.w;
        gc->eval.accFlags |= EVAL_TEXTURE_VALID;
    }

	pd->texture.x = t1[0];
	pd->texture.y = __glZero;
	pd->texture.z = __glZero;
	pd->texture.w = __glOne;
	pd->flags |= (POLYDATA_TEXTURE_VALID | POLYDATA_DLIST_TEXTURE1 |
                  POLYDATA_EVAL_TEXCOORD);
    pa->pdLastEvalTexture = pd;
}

void glcltTexCoord2fv_Eval (__GLfloat *t2)
{
    __GL_SETUP ();
    POLYARRAY *pa;
    POLYDATA *pd;
    
    pa = GLTEB_CLTPOLYARRAY();
	pa->flags |= POLYARRAY_TEXTURE2;
	pd = pa->pdNextVertex;					            

    // Do not update the CurTexture pointer 

    if (pd->flags & POLYDATA_TEXTURE_VALID) 
    {
        ASSERTOPENGL (!(pd->flags & POLYDATA_EVAL_TEXCOORD), 
                      "This cannot have been generated by an evaluator\n");
        gc->eval.texture.x = pd->texture.x;
        gc->eval.texture.y = pd->texture.y;
        gc->eval.texture.z = pd->texture.z;
        gc->eval.texture.w = pd->texture.w;
        gc->eval.accFlags |= EVAL_TEXTURE_VALID;
    }

	pd->texture.x = t2[0];
	pd->texture.y = t2[1];
	pd->texture.z = __glZero;
	pd->texture.w = __glOne;
	pd->flags |= (POLYDATA_TEXTURE_VALID | POLYDATA_DLIST_TEXTURE2 |
                  POLYDATA_EVAL_TEXCOORD);
    pa->pdLastEvalTexture = pd;
}

void glcltTexCoord3fv_Eval (__GLfloat *t3)
{
    __GL_SETUP ();
    POLYARRAY *pa;
    POLYDATA *pd;
    
    pa = GLTEB_CLTPOLYARRAY();
	pa->flags |= POLYARRAY_TEXTURE3;
	pd = pa->pdNextVertex;					            

    if (pd->flags & POLYDATA_TEXTURE_VALID) 
    {
        ASSERTOPENGL (!(pd->flags & POLYDATA_EVAL_TEXCOORD), 
                      "This cannot have been generated by an evaluator\n");
        gc->eval.texture.x = pd->texture.x;
        gc->eval.texture.y = pd->texture.y;
        gc->eval.texture.z = pd->texture.z;
        gc->eval.texture.w = pd->texture.w;
        gc->eval.accFlags |= EVAL_TEXTURE_VALID;
    }

	pd->texture.x = t3[0];
	pd->texture.y = t3[1];
	pd->texture.z = t3[2];
	pd->texture.w = __glOne;
	pd->flags |= (POLYDATA_TEXTURE_VALID | POLYDATA_DLIST_TEXTURE3 | 
                  POLYDATA_EVAL_TEXCOORD) ;
    pa->pdLastEvalTexture = pd;
}

// Do not update the CurTexture pointer
void glcltTexCoord4fv_Eval (__GLfloat *t4)
{
    __GL_SETUP ();
    POLYARRAY *pa;
    POLYDATA *pd;
    
    pa = GLTEB_CLTPOLYARRAY();
	pa->flags |= POLYARRAY_TEXTURE4;
	pd = pa->pdNextVertex;					            

    if (pd->flags & POLYDATA_TEXTURE_VALID)
    {
        ASSERTOPENGL (!(pd->flags & POLYDATA_EVAL_TEXCOORD), 
                      "This cannot have been generated by an evaluator\n");
        gc->eval.texture.x = pd->texture.x;
        gc->eval.texture.y = pd->texture.y;
        gc->eval.texture.z = pd->texture.z;
        gc->eval.texture.w = pd->texture.w;
        gc->eval.accFlags |= EVAL_TEXTURE_VALID;
    }

	pd->texture.x = t4[0];
	pd->texture.y = t4[1];
	pd->texture.z = t4[2];
	pd->texture.w = t4[4];
	pd->flags |= (POLYDATA_TEXTURE_VALID | POLYDATA_DLIST_TEXTURE4 |
                  POLYDATA_EVAL_TEXCOORD);
    pa->pdLastEvalTexture = pd;
}

// We do not update the CurNormal pointer here
void glcltNormal3fv_Eval (__GLfloat *n3)
{
    __GL_SETUP ();
    POLYARRAY *pa;
    POLYDATA *pd;
    
    pa = GLTEB_CLTPOLYARRAY();
	pd = pa->pdNextVertex;					            

    // If the existing normal is not from an evaluator, store it
    // so that it can be set later.

    if (pd->flags & POLYDATA_NORMAL_VALID)
    {
        ASSERTOPENGL (!(pd->flags & POLYDATA_EVAL_NORMAL), 
                      "This cannot have been generated by an evaluator\n");
        
        gc->eval.normal.x = pd->normal.x;
        gc->eval.normal.y = pd->normal.y;
        gc->eval.normal.z = pd->normal.z;
        gc->eval.accFlags |= EVAL_NORMAL_VALID;
    }

	pd->normal.x = n3[0];
	pd->normal.y = n3[1];
	pd->normal.z = n3[2];
	pd->flags |= (POLYDATA_NORMAL_VALID | POLYDATA_EVAL_NORMAL);
    pa->pdLastEvalNormal = pd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\fontoutl.c ===
#include "precomp.h"
#pragma hdrstop

#include <math.h>
#include <GL\glu.h>

#include "batchinf.h"
#include "glteb.h"
#include "glapi.h"
#include "glsbcltu.h"

#include "fontoutl.h"

static OFContext* CreateOFContext(      HDC         hdc,
                                        FLOAT       chordalDeviation,
                                        FLOAT       extrusion, 
                                        int         type,
                                        BOOL        bUnicode );

static BOOL  ScaleFont(                 HDC         hdc, 
                                        OFContext*  ofc,
                                        BOOL        bUnicode );

static void  DestroyOFContext(          HDC         hdc,
                                        OFContext*  ofc );

static BOOL  DrawGlyph(                 OFContext*  ofc );

static BOOL  MakeDisplayListFromGlyph(  OFContext*     ofc, 
                                        DWORD          listName,
                                        LPGLYPHMETRICS glyphMetrics );


static BOOL  MakeLinesFromArc(          OFContext*  ofc, 
                                        LOOP*       pLoop,
                                        PRIM*       pPrim,
                                        POINT2D     p0,
                                        POINT2D     p1,
                                        POINT2D     p2,
                                        FLOAT       chordalDeviationSquared);

static LOOP_LIST* MakeLinesFromGlyph(   OFContext*  ofc );

static BOOL  MakeLinesFromTTLine(       OFContext*  ofc, 
                                        LOOP*       pLoop,
                                        PRIM*       pPrim,
                                        UCHAR**     pp,
                                        WORD        pointCount );

static BOOL  MakeLinesFromTTPolycurve(  OFContext*  ofc, 
                                        LOOP*       pLoop,
                                        UCHAR**     pp );

static BOOL  MakeLinesFromTTPolygon(    OFContext*  ofc, 
                                        LOOP_LIST*  pLoopList,
                                        UCHAR**     pp );

static BOOL  MakeLinesFromTTQSpline(    OFContext*  ofc, 
                                        LOOP*       pLoop,
                                        PRIM*       pPrim,
                                        UCHAR**     pp,
                                        WORD        pointCount );

static void CALLBACK TessError(         GLenum      error,
                                        void        *data);

static void CALLBACK TessCombine(       GLdouble    coord[3], 
                                        POINT2D*    data[4], 
                                        GLfloat     w[4],
                                        POINT2D**   dataOut,
                                        void        *userData);

static void FreeCombinePool(            MEM_POOL    *combinePool );

static void ApplyVertexFilter(          LOOP_LIST   *pLoopList );

static void CheckRedundantVertices(     LOOP*       pLoop );

static BOOL PointsColinear(             POINT2D     *p1, 
                                        POINT2D     *p2, 
                                        POINT2D     *p3 ); 

static FLOAT      GetFixed(             UCHAR**     p );

static LOOP_LIST* InitLoopBuf(          void );

static LOOP*      NewLoop(              LOOP_LIST   *Loops, 
                                        POINT2D     *pFirstPoint );

static void       FreeLoopList(         LOOP_LIST   *pLoopList );

static PRIM*      NewPrim(              LOOP        *pLoop, 
                                        DWORD       primType );

static void       CalcVertPtrs(         LOOP        *pLoop );

static BOOL       AppendToVertBuf(      LOOP*       pLoop,
                                        PRIM*       pPrim,
                                        POINT2D     *p );


// macros to access data from byte streams:

// get WORD from byte stream, increment stream ptr by WORD
#define GetWord( p ) \
    ( *( ((UNALIGNED WORD *) *p)++ ) ) 

// get DWORD from byte stream, increment stream ptr by DWORD
#define GetDWord( p ) \
    ( *( ((UNALIGNED DWORD *) *p)++ ) ) 

// get signed word (SHORT) from byte stream, increment stream ptr by SHORT
#define GetSignedWord( p ) \
    ( *( ((UNALIGNED SHORT *) *p)++ ) ) 


#define POINT2DEQUAL( p1, p2 ) \
    ( (p1->x == p2->x) && (p1->y == p2->y) )

/******************************Public*Routine******************************\
* wglUseFontOutlinesA
* wglUseFontOutlinesW
*
* Stubs that call wglUseFontOutlinesAW with the bUnicode flag set
* appropriately.
*
\**************************************************************************/

BOOL WINAPI
wglUseFontOutlinesAW( HDC   hDC,
                      DWORD first,
                      DWORD count,
                      DWORD listBase,
                      FLOAT chordalDeviation,
                      FLOAT extrusion,
                      int   format,
                      LPGLYPHMETRICSFLOAT lpgmf,
                      BOOL  bUnicode );

BOOL WINAPI
wglUseFontOutlinesA(  HDC   hDC,
                      DWORD first,
                      DWORD count,
                      DWORD listBase,
                      FLOAT chordalDeviation,
                      FLOAT extrusion,
                      int   format,
                      LPGLYPHMETRICSFLOAT lpgmf )
{
    return wglUseFontOutlinesAW( hDC, first, count, listBase, chordalDeviation,
                                 extrusion, format, lpgmf, FALSE );
}

BOOL WINAPI
wglUseFontOutlinesW(  HDC   hDC,
                      DWORD first,
                      DWORD count,
                      DWORD listBase,
                      FLOAT chordalDeviation,
                      FLOAT extrusion,
                      int   format,
                      LPGLYPHMETRICSFLOAT lpgmf )
{
    return wglUseFontOutlinesAW( hDC, first, count, listBase, chordalDeviation,
                                 extrusion, format, lpgmf, TRUE );
}

/*****************************************************************************
 * wglUseFontOutlinesAW
 * 
 * Converts a subrange of the glyphs in a TrueType font to OpenGL display
 * lists.
 *
 * History:
 *  15-Dec-1994 -by- Marc Fortier [marcfo]
 * Wrote it.
*****************************************************************************/

BOOL WINAPI
wglUseFontOutlinesAW( HDC   hDC,
                      DWORD first,
                      DWORD count,
                      DWORD listBase,
                      FLOAT chordalDeviation,
                      FLOAT extrusion,
                      int   format,
                      LPGLYPHMETRICSFLOAT lpgmf,
                      BOOL  bUnicode
)
{
    DWORD       glyphIndex;
    DWORD       listIndex = listBase;
    UCHAR*      glyphBuf;
    DWORD       glyphBufSize, error;
    OFContext*  ofc;
    BOOL        status=WFO_FAILURE;


    // Return error if there is no current RC.

    if (!GLTEB_CLTCURRENTRC())
    {
        WARNING("wglUseFontOutlines: no current RC\n");
        SetLastError(ERROR_INVALID_HANDLE);
        return status;
    }

    /*
     * Flush any previous OpenGL errors.  This allows us to check for
     * new errors so they can be reported.
     */
    while (glGetError() != GL_NO_ERROR)
        ;

    /*
     * Preallocate a buffer for the outline data, and track its size:
     */
    // XXX: do we need to start with such a big size for this buffer ?
    glyphBuf = (UCHAR*) ALLOC(glyphBufSize = 10240);
    if (!glyphBuf) {
        WARNING("Alloc of glyphBuf failed\n");
        return status;
    }

    /*
     * Create font outline context
     */
    ofc = CreateOFContext( hDC, chordalDeviation, extrusion, format,
                           bUnicode );
    if( !ofc ) {
        WARNING("CreateOFContext failed\n");
        goto exit;
    }

    /*
     * Process each glyph in the given range:
    */
    for (glyphIndex = first; glyphIndex - first < count; ++glyphIndex)
    {
        GLYPHMETRICS    glyphMetrics;
        DWORD           glyphSize;
        static MAT2 matrix =
        {
            {0, 1}, {0, 0},
            {0, 0}, {0, 1}
        };


        /*
         * Determine how much space is needed to store the glyph's
         * outlines.  If our glyph buffer isn't large enough,
         * resize it.
         */
        if( bUnicode )
            glyphSize = GetGlyphOutlineW( hDC, glyphIndex, GGO_NATIVE,
                                          &glyphMetrics, 0, NULL, &matrix );
        else
            glyphSize = GetGlyphOutlineA( hDC, glyphIndex, GGO_NATIVE,
                                          &glyphMetrics, 0, NULL, &matrix );

        if( glyphSize == GDI_ERROR ) {
            WARNING("GetGlyphOutline() failed\n");
            goto exit;
        }

        if (glyphSize > glyphBufSize)
        {
            FREE(glyphBuf);
            glyphBuf = (UCHAR*) ALLOC(glyphBufSize = glyphSize);
            if (!glyphBuf) {
                WARNING("Alloc of glyphBuf failed\n");
                goto exit;
            }
        }


        /*
         * Get the glyph's outlines.
         */
        if( bUnicode )
            error = GetGlyphOutlineW( hDC, glyphIndex, GGO_NATIVE, 
                        &glyphMetrics, glyphBufSize, glyphBuf, &matrix );
        else
            error = GetGlyphOutlineA( hDC, glyphIndex, GGO_NATIVE, 
                        &glyphMetrics, glyphBufSize, glyphBuf, &matrix );

        if( error == GDI_ERROR ) {
            WARNING("GetGlyphOutline() failed\n");
            goto exit;
        }

        /*
         * Turn the glyph into a display list:
         */
        ofc->glyphBuf = glyphBuf;
        ofc->glyphSize = glyphSize;

        if (!MakeDisplayListFromGlyph(  ofc,
                                        listIndex,
                                        &glyphMetrics)) {
            WARNING("MakeDisplayListFromGlyph() failed\n");
            listIndex++;  // so it will be deleted
            goto exit;
        }

        /*
         * Supply scaled glyphMetrics if requested
         */
        if( lpgmf ) {
            lpgmf->gmfBlackBoxX = 
                ofc->scale * (FLOAT) glyphMetrics.gmBlackBoxX;
            lpgmf->gmfBlackBoxY = 
                ofc->scale * (FLOAT) glyphMetrics.gmBlackBoxY;
            lpgmf->gmfptGlyphOrigin.x = 
                ofc->scale * (FLOAT) glyphMetrics.gmptGlyphOrigin.x;
            lpgmf->gmfptGlyphOrigin.y = 
                ofc->scale * (FLOAT) glyphMetrics.gmptGlyphOrigin.y;
            lpgmf->gmfCellIncX = 
                ofc->scale * (FLOAT) glyphMetrics.gmCellIncX;
            lpgmf->gmfCellIncY = 
                ofc->scale * (FLOAT) glyphMetrics.gmCellIncY;

            lpgmf++;
        }

        listIndex++;
    }

    // Set status to SUCCESS if we get this far
    status = WFO_SUCCESS;

    /*
     * Clean up temporary storage and return.  If an error occurred,
     * set error flags and return FAILURE status;
     * otherwise just return SUCCESS.
     */

exit:
    if( glyphBuf )
        FREE(glyphBuf);

    if( ofc )
        DestroyOFContext( hDC, ofc);

    if( !status ) 
    {
        // assume memory error
        WARNING("wglUseFontOutlines: not enough memory\n");
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);

        // free up display lists
        glDeleteLists( listBase, listIndex-listBase );
    }

    return status;
}



/*****************************************************************************
 * MakeDisplayListFromGlyph
 * 
 * Converts the outline of a glyph to an OpenGL display list.
 *
 * Return value is nonzero for success, zero for failure.
 *
 * Does not check for OpenGL errors, so if the caller needs to know about them,
 * it should call glGetError().

*****************************************************************************/

static BOOL
MakeDisplayListFromGlyph( IN  OFContext*        ofc, 
                          IN  DWORD             listName,
                          IN  LPGLYPHMETRICS    glyphMetrics )
{
    BOOL status;

    glNewList(listName, GL_COMPILE);
    /*
     * Set normal and orientation for front face of glyph
     */
    glNormal3f( 0.0f, 0.0f, 1.0f );
    glFrontFace( GL_CCW );

    status = DrawGlyph( ofc );

    /*
     * Translate by gmCellIncX, gmCellIncY
     */
    glTranslatef( ofc->scale * (FLOAT) glyphMetrics->gmCellIncX, 
                  ofc->scale * (FLOAT) glyphMetrics->gmCellIncY, 
                  0.0f );
    glEndList();

    // Check for GL errors occuring during processing of the glyph

    while( glGetError() != GL_NO_ERROR )
        status = WFO_FAILURE; 

    return status;
}



/*****************************************************************************
 * DrawGlyph
 * 
 * Converts the outline of a glyph to OpenGL drawing primitives, tessellating
 * as needed, and then draws the glyph.  Tessellation of the quadratic splines
 * in the outline is controlled by "chordalDeviation", and the drawing
 * primitives (lines or polygons) are selected by "format".
 *
 * Return value is nonzero for success, zero for failure.
 *
 * Does not check for OpenGL errors, so if the caller needs to know about them,
 * it should call glGetError().

 * History:
 *  26-Sep-1995 -by- Marc Fortier [marcfo]
 * Use extrusioniser to draw polygonal faces with extrusion=0

*****************************************************************************/


static BOOL
DrawGlyph( IN OFContext *ofc )
{
    BOOL                status = WFO_FAILURE;
    DWORD               nLoops;
    DWORD               point;
    DWORD               nVerts;
    LOOP_LIST           *pLoopList;
    LOOP                *pLoop;
    POINT2D             *p;
    MEM_POOL            *mp = NULL;

    /*
     * Convert the glyph outlines to a set of polyline loops.
     * (See MakeLinesFromGlyph() for the format of the loop data
     * structure.)
     */
    if( !(pLoopList = MakeLinesFromGlyph(ofc)) )
        goto exit;

    /*
     * Filter out unnecessary vertices
     */
    ApplyVertexFilter( pLoopList );

    /*
     * Now draw the loops in the appropriate format:
     */
    if( ofc->format == WGL_FONT_LINES )
    {
        /*
         * This is the easy case.  Just draw the outlines.
         */
        nLoops = pLoopList->nLoops;
        pLoop = pLoopList->LoopBuf;
#ifndef FONT_DEBUG
        for( ; nLoops; nLoops--, pLoop++ )
        {
            glBegin(GL_LINE_LOOP);

            nVerts = pLoop->nVerts;
            p = pLoop->VertBuf;
            for( ; nVerts; nVerts--, p++ ) {
                glVertex2fv( (FLOAT*) p );
            }

            glEnd();

        }
#else
        // color code the primitives

        for( ; nLoops; nLoops--, pLoop++ )
        {
            DrawColorCodedLineLoop( pLoop, 0.0f );
        }
#endif
        if( ofc->ec )
            extr_DrawLines( ofc->ec, pLoopList );
        status = WFO_SUCCESS;
    }

    else if (ofc->format == WGL_FONT_POLYGONS)
    {
        GLdouble v[3];

        /*
         * This is the hard case.  We have to set up a tessellator
         * to convert the outlines into a set of polygonal
         * primitives, which the tessellator passes to some
         * auxiliary routines for drawing.
         */

        /* Initialize polygon extrusion for the glyph.
         * This prepares for tracking of the tesselation in order to
         * build the Back-facing polygons.
         */

        mp = &ofc->combinePool;
        ofc->curCombinePool = mp;
        mp->index = 0;
        mp->next = NULL;

        if( ofc->ec ) {
            if( !extr_PolyInit( ofc->ec ) )
                goto exit;

        }

        ofc->TessErrorOccurred = 0;
        v[2] = 0.0;
        gluTessBeginPolygon( ofc->tess, ofc );

        /*
         * Each loop returned from MakeLinesFromGlyph is closed (first and 
         * last points are the same).  The old tesselator had trouble with
         * this.  Since the tesselator automatically closes all loops,
         * we skip the last point to be on the safe side.
         */

        nLoops = pLoopList->nLoops;
        pLoop = pLoopList->LoopBuf;
        for( ; nLoops; nLoops--, pLoop++ )
        {
            gluTessBeginContour( ofc->tess );
                
            nVerts = pLoop->nVerts - 1;  // skip last point

            p = pLoop->VertBuf;
            for( ; nVerts; nVerts--, p++ )
            {
                v[0] = p->x;
                v[1] = p->y;
                gluTessVertex(ofc->tess, v, p);
            }
            gluTessEndContour( ofc->tess );
        }

        gluTessEndPolygon( ofc->tess );

        if (ofc->TessErrorOccurred)
            goto exit;

        if( ofc->ec ) {
            /* check for OUT_OF_MEMORY_ERROR in extrusion lib, that might
             * have occured during tesselation tracking.
             */
            if( ofc->ec->TessErrorOccurred )
                goto exit;
#ifdef VARRAY
            if( ofc->ec->zExtrusion == 0.0f )
                DrawFacePolygons( ofc->ec, 0.0f );
            else if( !extr_DrawPolygons( ofc->ec, pLoopList ) )
                goto exit;
#else
            if( !extr_DrawPolygons( ofc->ec, pLoopList ) ) 
                goto exit; 
#endif
        }
        status = WFO_SUCCESS;
    }

exit:
    /*
     * Putting PolyFinish here means PolyInit may not have been called.
     * This is ok.
     */
    if( mp )
        FreeCombinePool( mp );
    if( pLoopList )
        FreeLoopList( pLoopList );
    if( ofc->ec )
        extr_PolyFinish( ofc->ec );

    return status;
}

/*****************************************************************************
 * TessCombine
 *
 * Tesselation callback for loop intersection.  We have to allocate a vertex
 * and return it to tesselator.  Allocation is from the context's static pool.
 * If this runs dry, then a linked list of MEM_POOL blocks is used.

*****************************************************************************/
 
static void CALLBACK
TessCombine( GLdouble coord[3], POINT2D *data[4], GLfloat w[4],
             POINT2D **dataOut, void *userData )
{
    OFContext *ofc = (OFContext *) userData;
    MEM_POOL *mp = ofc->curCombinePool;
    POINT2D *p;

    // make sure there's room available in the current pool block
    if( mp->index >=  POOL_SIZE )
    {
        // we need to allocate another MEM_POOL block
        MEM_POOL *newPool;

        newPool = (MEM_POOL *) ALLOC( sizeof(MEM_POOL) );
        if( !newPool )
            // tesselator will handle any problem with this
            return;

        newPool->index = 0;
        newPool->next = NULL;
        mp->next = newPool;
        mp = newPool;
        ofc->curCombinePool = mp; // new pool becomes the current pool
    }

    p = mp->pool + mp->index;
    p->x = (GLfloat) coord[0];        
    p->y = (GLfloat) coord[1];        
    mp->index ++;

    *dataOut = p;
}

/*****************************************************************************
 * FreeCombinePool
 *
 * Frees any pools of memory allocated by TessCombine callback

*****************************************************************************/
static void
FreeCombinePool( MEM_POOL *memPool )
{
    MEM_POOL *nextPool;

    memPool = memPool->next;  // first pool in list is static part of context
    while( memPool ) {
        nextPool = memPool->next;
        FREE( memPool );
        memPool = nextPool;
    }
}

/*****************************************************************************
 * TessError
 *
 * Saves the last tessellator error code in ofc->TessErrorOccurred.

*****************************************************************************/
 
static void CALLBACK
TessError(GLenum error, void *data)
{
    OFContext *ofc = (OFContext *) data;

    // Only some of these errors are fatal:
    switch( error ) {
        case GLU_TESS_COORD_TOO_LARGE:
        case GLU_TESS_NEED_COMBINE_CALLBACK:
            ofc->TessErrorOccurred = error;
            break;
        default:
            break;
    }
}



/*****************************************************************************
 * MakeLinesFromGlyph
 * 
 * Converts the outline of a glyph from the TTPOLYGON format into
 * structures of Loops, Primitives and Vertices.
 *
 * Line segments from the TTPOLYGON are transferred to the output array in
 * the obvious way.  Quadratic splines in the TTPOLYGON are converted to
 * collections of line segments

*****************************************************************************/


static LOOP_LIST*
MakeLinesFromGlyph( IN OFContext* ofc )
{
    UCHAR*  p;
    BOOL status = WFO_FAILURE;
    LOOP_LIST *pLoopList;

    /*
     * Initialize the buffer into which we place the loop data:
     */
    if( !(pLoopList = InitLoopBuf()) )
        return NULL;

    p = ofc->glyphBuf;
    while (p < ofc->glyphBuf + ofc->glyphSize)
    {
        if( !MakeLinesFromTTPolygon( ofc, pLoopList, &p) )
            goto exit;
    }

    status = WFO_SUCCESS;

exit:
    if (!status) {
        FreeLoopList( pLoopList );
        pLoopList = (LOOP_LIST *) NULL;
    }
    
    return pLoopList;
}



/*****************************************************************************
 * MakeLinesFromTTPolygon
 *
 * Converts a TTPOLYGONHEADER and its associated curve structures into a
 * LOOP structure.

*****************************************************************************/

static BOOL
MakeLinesFromTTPolygon( IN      OFContext*  ofc, 
                        IN      LOOP_LIST*  pLoopList,
                        IN OUT  UCHAR**     pp)
{
    DWORD   polySize;
    UCHAR*  polyStart;
    POINT2D *pFirstP, *pLastP, firstPoint;
    LOOP    *pLoop;
    PRIM    *pPrim;

    /*
     * Record where the polygon data begins.
     */
    polyStart = *pp;

    /*
     * Extract relevant data from the TTPOLYGONHEADER:
     */
    polySize = GetDWord(pp);
    if( GetDWord(pp) != TT_POLYGON_TYPE )  /* polygon type */
        return WFO_FAILURE;
    firstPoint.x = ofc->scale * GetFixed(pp); // 1st X coord
    firstPoint.y = ofc->scale * GetFixed(pp); // 1st Y coord

    /* 
     * Initialize a new LOOP struct in the LoopBuf, with the first point
     */
    if( !(pLoop = NewLoop( pLoopList, &firstPoint )) )
        return WFO_FAILURE;
    
    /*
     * Process each of the TTPOLYCURVE structures in the polygon:
     */

    while (*pp < polyStart + polySize) {
        if( !MakeLinesFromTTPolycurve(  ofc, pLoop, pp ) )
            return WFO_FAILURE;
    }

    /* Now have to fix up end of loop : after studying the chars, it
     * was determined that if a curve started with a line, and ended with
     * a qspline, AND the first and last point were not the same, then there
     * is an implied line joining the two.
     * In any case, we also make sure here that first and last points are
     * coincident.
     */
    
    pLastP = (POINT2D *) (pLoop->VertBuf+pLoop->nVerts-1);
    pFirstP = &firstPoint;

    if( !POINT2DEQUAL( pLastP, pFirstP ) ) {
        // add 1-vertex line prim at the end

        if( !(pPrim = NewPrim( pLoop, TT_PRIM_LINE)) )
            return WFO_FAILURE;

        if ( !AppendToVertBuf( pLoop, pPrim, pFirstP) )
            return WFO_FAILURE;
    }

    /* At end of each loop, calculate pVert for each PRIM from its
     * VertIndex value (for convenience later).
     */
    CalcVertPtrs( pLoop );

    return WFO_SUCCESS;
}


/*****************************************************************************
 * MakeLinesFromTTPolyCurve
 *
 * Converts the lines and splines in a single TTPOLYCURVE structure to points
 * in the Loop.

*****************************************************************************/

static BOOL
MakeLinesFromTTPolycurve( IN     OFContext* ofc, 
                          IN     LOOP*      pLoop,
                          IN OUT UCHAR**    pp )
{
    WORD type;
    WORD pointCount;
    PRIM *pPrim;

    /*
     * Pick up the relevant fields of the TTPOLYCURVE structure:
     */
    type = GetWord(pp);
    pointCount = GetWord(pp);

    if( !(pPrim = NewPrim( pLoop, type )) )
        return WFO_FAILURE;

    /*
     * Convert the "curve" to line segments:
     */
    if (type == TT_PRIM_LINE) {
        return MakeLinesFromTTLine( ofc, pLoop, pPrim, pp, pointCount);

    } else if (type == TT_PRIM_QSPLINE) {
        return MakeLinesFromTTQSpline( ofc, pLoop, pPrim, pp, pointCount );

    } else
        return WFO_FAILURE;
}



/*****************************************************************************
 * MakeLinesFromTTLine
 *
 * Converts points from the polyline in a TT_PRIM_LINE structure to
 * equivalent points in the Loop.

*****************************************************************************/
static BOOL
MakeLinesFromTTLine(    IN     OFContext* ofc, 
                        IN     LOOP*      pLoop,
                        IN     PRIM*      pPrim,
                        IN OUT UCHAR**    pp,
                        IN     WORD       pointCount)
{
    POINT2D p;

    /*
     * Just copy the line segments into the vertex buffer (converting
     * type as we go):
     */

    while (pointCount--)
    {
        p.x = ofc->scale * GetFixed(pp); // X coord 
        p.y = ofc->scale * GetFixed(pp); // Y coord
        if( !AppendToVertBuf( pLoop, pPrim, &p ) )
            return WFO_FAILURE;
    }

    return WFO_SUCCESS;
}


/*****************************************************************************
 * MakeLinesFromTTQSpline
 *
 * Converts points from the poly quadratic spline in a TT_PRIM_QSPLINE
 * structure to polyline points in the Loop. 

*****************************************************************************/

static BOOL
MakeLinesFromTTQSpline( IN      OFContext*  ofc, 
                        IN      LOOP*       pLoop,
                        IN      PRIM*       pPrim,
                        IN  OUT UCHAR**     pp,
                        IN      WORD        pointCount )
{
    POINT2D p0, p1, p2;
    WORD point;
    POINT2D p, *pLastP;

    /*
     * Process each of the non-interpolated points in the outline.
     * To do this, we need to generate two interpolated points (the
     * start and end of the arc) for each non-interpolated point.
     * The first interpolated point is always the one most recently
     * stored in VertBuf, so we just extract it from there.  The
     * second interpolated point is either the average of the next
     * two points in the QSpline, or the last point in the QSpline
     * if only one remains.
     */

    // Start with last generated point in VertBuf
    p0 = *(pLoop->VertBuf + pLoop->nVerts - 1);

    // pointCount should be >=2, but in case it's not...
    p1 = p2 = p0;

    for (point = 0; point < pointCount - 1; ++point)
    {
        p1.x = ofc->scale * GetFixed(pp);
        p1.y = ofc->scale * GetFixed(pp);

        if (point == pointCount - 2)
        {
            /*
             * This is the last arc in the QSpline.  The final
             * point is the end of the arc.
             */
            p2.x = ofc->scale * GetFixed(pp);
            p2.y = ofc->scale * GetFixed(pp);
        }
        else
        {
            /*
             * Peek at the next point in the input to compute
             * the end of the arc:
             */
            p.x = ofc->scale * GetFixed(pp);
            p.y = ofc->scale * GetFixed(pp);
            p2.x = 0.5f * (p1.x + p.x);
            p2.y = 0.5f * (p1.y + p.y);
            /*
             * Push the point back onto the input so it will
             * be reused as the next off-curve point:
             */
            *pp -= 2*sizeof(FIXED); // x and y
        }

        if( !MakeLinesFromArc(  ofc,
                                pLoop,
                                pPrim,
                                p0,
                                p1,
                                p2,
                                ofc->chordalDeviation * ofc->chordalDeviation))
            return WFO_FAILURE;

        // p0 is now the last interpolated point (p2)
        p0 = p2;
    }

    // put in last point in arc
    if( !AppendToVertBuf( pLoop, pPrim, &p2 ) )
        return WFO_FAILURE;

    return WFO_SUCCESS;
}


/*****************************************************************************
 * MakeLinesFromArc
 *
 * Subdivides one arc of a quadratic spline until the chordal deviation
 * tolerance requirement is met, then places the resulting set of line
 * segments in the Loop.

*****************************************************************************/

static BOOL
MakeLinesFromArc(   IN OFContext *ofc, 
                    IN LOOP*     pLoop,
                    IN PRIM*     pPrim,
                    IN POINT2D   p0,
                    IN POINT2D   p1,
                    IN POINT2D   p2,
                    IN FLOAT     chordalDeviationSquared)
{
    POINT2D p01;
    POINT2D p12;
    POINT2D midPoint;
    FLOAT   deltaX;
    FLOAT   deltaY;

    /*
     * Calculate midpoint of the curve by de Casteljau:
     */
    p01.x = 0.5f * (p0.x + p1.x);
    p01.y = 0.5f * (p0.y + p1.y);
    p12.x = 0.5f * (p1.x + p2.x);
    p12.y = 0.5f * (p1.y + p2.y);
    midPoint.x = 0.5f * (p01.x + p12.x);
    midPoint.y = 0.5f * (p01.y + p12.y);


    /*
     * Estimate chordal deviation by the distance from the midpoint
     * of the curve to its non-interpolated control point.  If this
     * distance is greater than the specified chordal deviation
     * constraint, then subdivide.  Otherwise, generate polylines
     * from the three control points.
     */
    deltaX = midPoint.x - p1.x;
    deltaY = midPoint.y - p1.y;
    if (deltaX * deltaX + deltaY * deltaY > chordalDeviationSquared)
    {
        if( !MakeLinesFromArc( ofc, pLoop, pPrim, 
                               p0,
                               p01,
                               midPoint,
                               chordalDeviationSquared) )
            return WFO_FAILURE;

        if( !MakeLinesFromArc( ofc, pLoop, pPrim, 
                               midPoint,
                               p12,
                               p2,
                               chordalDeviationSquared) )
            return WFO_FAILURE;
    }
    else
    {
        /*
         * The "pen" is already at (x0, y0), so we don't need to
         * add that point to the LineBuf.
         */
        if( !AppendToVertBuf( pLoop, pPrim, &p1 ) )
            return WFO_FAILURE;
    }

    return WFO_SUCCESS;
}


/*****************************************************************************
 * ApplyVertexFilter
 *
 * Filter the vertex buffer to get rid of redundant vertices.
 * These can occur on Primitive boundaries.

*****************************************************************************/
static void ApplyVertexFilter( LOOP_LIST *pLoopList )
{
    DWORD nLoops;
    LOOP *pLoop;

    nLoops = pLoopList->nLoops;
    pLoop = pLoopList->LoopBuf;

    for( ; nLoops; nLoops--, pLoop++ ) {
        CheckRedundantVertices( pLoop );
    }
}

/*****************************************************************************
 * CheckRedundantVertices
 *
 * Check for redundant vertices on Curve-Curve boundaries (including loop
 * closure), and get rid of them, using in-place algorithm.

*****************************************************************************/

static void CheckRedundantVertices( LOOP  *pLoop )
{
    PRIM *pPrim, *pNextPrim; 
    DWORD primType, nextPrimType, nVerts;
    BOOL bEliminate, bLastEliminate;
    DWORD nEliminated=0, nPrims;
    POINT2D *pVert, *pVert2ndToLast;
    
    nPrims = pLoop->nPrims;
    if( nPrims < 2 )
        return;

    pPrim = pLoop->PrimBuf;
    pNextPrim = pPrim + 1;
    
    nPrims--; // the last prim is dealt with afterwards
    for( ; nPrims; nPrims--, pPrim = pNextPrim++ ) {
        bEliminate = FALSE;
        nVerts = pPrim->nVerts;

        // check spline<->* boundaries
        if( (pPrim->nVerts >= 2) &&
            ((pPrim->primType     == PRIM_CURVE ) || 
             (pNextPrim->primType == PRIM_CURVE )) ) {

            /* get ptr to 2nd-to-last vertex in current prim 
             * !! Note that last vertex in current prim and first vertex in
             *  next prim are the same.
             */
            pVert2ndToLast = pPrim->pVert + pPrim->nVerts - 2;
            if( PointsColinear( pVert2ndToLast, 
                                pVert2ndToLast+1,
                                pNextPrim->pVert+1 ) ) {
                // we eliminate last vertex in current prim
                bEliminate = TRUE;
                pPrim->nVerts--; 
                nVerts--;
            }
        }

        /* move vertices up in vertBuf if necessary (if any vertices
         * were PREVIOUSLY eliminated)
         */
        if( nEliminated ) {
            pVert = pPrim->pVert - nEliminated; // new pVert
            memcpy( pVert+1, pPrim->pVert+1, (nVerts-1)*sizeof(POINT2D));
            pPrim->pVert = pVert;
        }
        if( bEliminate ) {
            nEliminated += 1;
        }
    }

    /* also check for redundancy at closure:
     * - replace firstPrim's first vertex with 2nd-to-last of last prim
     * - eliminate last vertex in last prim
     */
    bLastEliminate = bEliminate;
    bEliminate = FALSE;
    nVerts = pPrim->nVerts;
    pNextPrim = pLoop->PrimBuf; // first prim in loop

    if( (pPrim->nVerts >= 2) &&
        ((pPrim->primType     == PRIM_CURVE ) || 
         (pNextPrim->primType == PRIM_CURVE )) ) {

        POINT2D *pVertLast;

        pVert2ndToLast = pPrim->pVert + pPrim->nVerts - 2; // always >=2 verts
        pVertLast = pVert2ndToLast + 1;

        if( (pPrim->nVerts == 2) && bLastEliminate )
            /* 2ndToLast vert (same as first vert) of this prim has
             * been eliminated.  Deal with it by backing up the ptr.
             * This didn't matter in above loop, because there wasn't the
             * possibility of munging the first vertex in the loop
             */
            pVert2ndToLast--;

        // point to 2nd-to-last vertex in prim
        if( PointsColinear( pVert2ndToLast, 
                            pVertLast,
                            pNextPrim->pVert+1 ) ) {
            bEliminate = TRUE;
            pPrim->nVerts--; 
            // munge first prim's first vertex
            /* problem here if have 2 eliminations in a row, and pPrim was
             * a 2 vertex prim - then pVert2ndToLast is pointing to an
             * eliminated vertex
             */
            *(pNextPrim->pVert) = *(pVert2ndToLast);
            nVerts--;
        }
    }

    // move up last prim's vertices if necessary
    if( nEliminated ) {
        pVert = pPrim->pVert - nEliminated; // new pVert
        memcpy( pVert+1, pPrim->pVert+1, (nVerts-1)*sizeof(POINT2D) );
        // This misses copying one vertex
        pPrim->pVert = pVert;
    }

    if( bEliminate ) {
        nEliminated += 1;
    }

    // now update vertex count in Loop
    pLoop->nVerts -= nEliminated;

    // Check for prims with nVerts=1 (invalidated), and remove them

    nPrims = pLoop->nPrims;
    pPrim = pLoop->PrimBuf;
    nEliminated = 0;
    for( ; nPrims; nPrims--, pPrim++ ) {
        if( pPrim->nVerts == 1 ) {
            nEliminated++;
            continue;
        }
        *(pPrim-nEliminated) = *pPrim;
    }
    pLoop->nPrims -= nEliminated;
}

/*****************************************************************************
 * PointsColinear
 *
 * Returns TRUE if the 3 points are colinear enough.

*****************************************************************************/

static BOOL PointsColinear( POINT2D *p1,
                            POINT2D *p2,
                            POINT2D *p3 )
{
    POINT2D v1, v2;

    // compare slopes of the 2 vectors? - optimize later
    if( POINT2DEQUAL( p1, p2 ) || POINT2DEQUAL( p2, p3 ) )
        // avoid sending 0 vector to CalcAngle (generates FPE)
        return TRUE;

    v1.x = p2->x - p1->x;
    v1.y = p2->y - p1->y;
    v2.x = p3->x - p2->x;
    v2.y = p3->y - p2->y;
    if( fabs(CalcAngle( &v1, &v2 )) < CoplanarThresholdAngle )
        return TRUE;

    return FALSE;
}


/*****************************************************************************
 * CreateOFContext
 *
 * Create and initialize the outline font context.
 *
 * History:
 *  26-Sep-1995 -by- Marc Fortier [marcfo]
 * Use extrusioniser to draw polygonal faces with extrusion=0

*****************************************************************************/

static OFContext* CreateOFContext( HDC    hdc,
                                   FLOAT  chordalDeviation,
                                   FLOAT  extrusion, 
                                   INT    format,
                                   BOOL   bUnicode )
{
    OFContext *ofc = (OFContext *) NULL;
    BOOL status = WFO_FAILURE;

    // validate parameters

    if( (format != WGL_FONT_LINES) && (format != WGL_FONT_POLYGONS) ) {
        WARNING("wglUseFontOutlines: invalid format parameter\n");
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if( chordalDeviation < 0.0f ) {
        WARNING("wglUseFontOutlines: invalid deviation parameter\n");
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if( extrusion < 0.0f ) {
        WARNING("wglUseFontOutlines: invalid extrusion parameter\n");
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    ofc = (OFContext *) ALLOCZ( sizeof(OFContext) );

    if( !ofc ) 
        return NULL;

    ofc->format = format;
    ofc->chordalDeviation = chordalDeviation;

    if( !ScaleFont( hdc, ofc, bUnicode ) )
        goto exit;

    // handle extrusion
#ifdef VARRAY
    if( !((format == WGL_FONT_LINES) && (extrusion == 0.0f)) ) {
#else
    if( extrusion != 0.0f ) {
#endif
        ofc->ec = extr_Init( extrusion, format );
        if( !ofc->ec ) {
            goto exit;
        }
    } else {
        ofc->ec = (EXTRContext *) NULL;
    }

    // init a tess obj
    ofc->tess = NULL;
    if( ofc->format == WGL_FONT_POLYGONS ) {
        GLUtesselator *tess;

        if (!(tess = gluNewTess()))
            goto exit;

        if( ofc->ec ) {
            gluTessCallback(tess, GLU_TESS_BEGIN_DATA,  
                                    (void(CALLBACK*)()) extr_glBegin);
            gluTessCallback(tess, GLU_TESS_END,    
                                    (void(CALLBACK*)()) extr_glEnd);
            gluTessCallback(tess, GLU_TESS_VERTEX_DATA, 
                                    (void(CALLBACK*)()) extr_glVertex);
        } else {
            gluTessCallback(tess, GLU_BEGIN,  (void(CALLBACK*)()) glBegin);
            gluTessCallback(tess, GLU_END,    (void(CALLBACK*)()) glEnd);
            gluTessCallback(tess, GLU_VERTEX, (void(CALLBACK*)()) glVertex2fv);
        }
        gluTessCallback(tess, GLU_TESS_ERROR_DATA,        
                                        (void(CALLBACK*)()) TessError);
        gluTessCallback(tess, GLU_TESS_COMBINE_DATA, 
                                        (void(CALLBACK*)()) TessCombine);

        // set tesselator normal and winding rule

        gluTessNormal( tess, 0.0, 0.0, 1.0 );
        gluTessProperty( tess, GLU_TESS_WINDING_RULE, GLU_TESS_WINDING_NONZERO);

        ofc->tess = tess;
    }

    status = WFO_SUCCESS;

exit:
    if( !status ) {
        DestroyOFContext( hdc, ofc );
        return NULL;
    }
    return ofc;
}

/*****************************************************************************
* ScaleFont
*
* To get the best representation of the font, we use its design height, or
* the emSquare size.  We then scale emSquare to 1.0.
* A maxChordTolerance value is set, otherwise it was found that some
* glyphs displayed ugly loop intersections.  The value .035f was chosen
* after cursory examination of the glyphs. 
*
* History:
*  31-Jul-1995 -by- [marcfo]
* Get rid of unicode functions - since we're just accessing text metrics,
* the default 'string' functions should work on all platforms.
*****************************************************************************/

static BOOL
ScaleFont( HDC hdc, OFContext *ofc, BOOL bUnicode )
{
    OUTLINETEXTMETRIC otm;
    HFONT       hfont;
    LOGFONT    lf;
    DWORD       textMetricsSize;
    FLOAT       scale, maxChordTolerance=0.035f;
    UINT        otmEMSquare;

    // Query font metrics

    if( GetOutlineTextMetrics( hdc, sizeof(otm), &otm) <= 0 )
        // cmd failed, or buffer size=0
        return WFO_FAILURE;

    otmEMSquare = otm.otmEMSquare;

    /*
     * The font data is scaled, so that 1.0 maps to the font's em square
     * size.  Note that it is still possible for glyphs to extend beyond
     * this square.
     */
    scale = 1.0f / (FLOAT) otmEMSquare;

    // create new font object, using largest size

    hfont = GetCurrentObject( hdc, OBJ_FONT );
    GetObject( hfont, sizeof(LOGFONT), &lf );
    lf.lfHeight = otmEMSquare;
    lf.lfWidth = 0;  // this will choose default width for the height
    hfont = CreateFontIndirect(&lf);

    // select new font into DC, and save current font
    ofc->hfontOld = SelectObject( hdc, hfont );

    // set ofc values

    ofc->scale = scale;

    /* check chord tolerance: in design space, minimum chord tolerance is
     * ~1 logical unit, = ofc->scale.
     */
    if( ofc->chordalDeviation == 0.0f ) {
        // select minimum tolerance in this case
        ofc->chordalDeviation = ofc->scale;
    }
    /* also impose a maximum, or things can get ugly */
    else if( ofc->chordalDeviation > maxChordTolerance ) {
        // XXX might want to change maxChordTolerance based on scale ?
        ofc->chordalDeviation = maxChordTolerance;
    }

    return WFO_SUCCESS;
}

/*****************************************************************************
 * DestroyOFContext
 *
*****************************************************************************/

static void 
DestroyOFContext( HDC hdc, OFContext* ofc )
{
    HFONT hfont;

    if( ofc->ec ) {
        extr_Finish( ofc->ec );
    }

    // put back original font object
    if( ofc->hfontOld ) {
        hfont = SelectObject( hdc, ofc->hfontOld );
        DeleteObject( hfont );
    }

    if( ofc->format == WGL_FONT_POLYGONS ) {
        if( ofc->tess )
            gluDeleteTess( ofc->tess );
    }

    FREE( ofc );
}

/*****************************************************************************
 * InitLoopBuf
 *
 * Initializes a LOOP_LIST structure for the Loops of each glyph.

*****************************************************************************/

static LOOP_LIST*
InitLoopBuf( void )
{
    LOOP *pLoop;
    LOOP_LIST *pLoopList;
    DWORD initSize = 10;

    pLoopList = (LOOP_LIST*) ALLOC( sizeof(LOOP_LIST) );
    if( !pLoopList )
        return( (LOOP_LIST *) NULL );

    pLoop = (LOOP*) ALLOC( initSize * sizeof(LOOP) );
    if( !pLoop ) {
        FREE( pLoopList );
        return( (LOOP_LIST *) NULL );
    }

    pLoopList->LoopBuf = pLoop;
    pLoopList->nLoops = 0;
    pLoopList->LoopBufSize = initSize;

    return pLoopList; 
}

/*****************************************************************************
 * NewLoop
 * 
 * Create a new LOOP structure.  The first point in the loop is supplied.

*****************************************************************************/

static LOOP*
NewLoop( LOOP_LIST *pLoopList, POINT2D *pFirstPoint )
{
    LOOP    *pNewLoop;
    PRIM    *pPrim;
    POINT2D *pVert;
    DWORD   size = 50;

    if( pLoopList->nLoops >=  pLoopList->LoopBufSize)
    {
        // need to increase size of LoopBuf
        LOOP *pLoop;

        pLoop = (LOOP*) REALLOC(pLoopList->LoopBuf,  
                                (pLoopList->LoopBufSize += size) *
                                sizeof(LOOP));
        if( !pLoop )
            return (LOOP *) NULL;
        pLoopList->LoopBuf = pLoop;
    }

    pNewLoop = pLoopList->LoopBuf + pLoopList->nLoops;

    // give the loop a block of prims to work with
    pPrim = (PRIM *) ALLOC( size * sizeof(PRIM) );
    if( !pPrim )
        return (LOOP *) NULL;
    pNewLoop->PrimBuf = pPrim;
    pNewLoop->nPrims = 0;
    pNewLoop->PrimBufSize = size;

    // give the loop a block of vertices to work with
    pVert = (POINT2D*) ALLOC( size * sizeof(POINT2D) );
    if( !pVert ) {
        FREE( pPrim );
        return (LOOP *) NULL;
    }
    pNewLoop->VertBuf = pVert;
    pNewLoop->nVerts = 0;
    pNewLoop->VertBufSize = size;

    // stick that first point in
    pVert->x = pFirstPoint->x;
    pVert->y = pFirstPoint->y;
    pNewLoop->nVerts++;

    // normal buffers - used by extrusion
    pNewLoop->FNormBuf = (POINT3D *) NULL;
    pNewLoop->VNormBuf = (POINT3D *) NULL;

    pLoopList->nLoops++; // increment loop count

    return pNewLoop;
}

/*****************************************************************************
 * NewPrim
 *
 * Create a new PRIM structure.  The primType is supplied.

*****************************************************************************/

static PRIM*
NewPrim( LOOP *pLoop, DWORD primType )
{
    PRIM    *pNewPrim;
    POINT2D *pVert;
    DWORD   size = 50;

    if( pLoop->nPrims >=  pLoop->PrimBufSize)
    {
        // need to increase size of PrimBuf
        PRIM *pPrim;

        pPrim = (PRIM *) REALLOC(pLoop->PrimBuf,  
                                 (pLoop->PrimBufSize += size) * sizeof(PRIM));
        if( !pPrim )
            return (PRIM *) NULL;
        pLoop->PrimBuf = pPrim;
    }

    pNewPrim = pLoop->PrimBuf + pLoop->nPrims;
    // translate primType to extrusion prim type
    primType = (primType == TT_PRIM_LINE) ? PRIM_LINE : PRIM_CURVE;
    pNewPrim->primType = primType;
    pNewPrim->nVerts = 1;  // since we include last point:
    /* 
     * VertIndex must point to the last point of the previous prim
     */
    pNewPrim->VertIndex = pLoop->nVerts - 1;
    // normal pointers - used by extrusion
    pNewPrim->pFNorm = (POINT3D *) NULL;
    pNewPrim->pVNorm = (POINT3D *) NULL;

    pLoop->nPrims++; // increment prim count

    return pNewPrim;
}

/*****************************************************************************
 * FreeLoopList
 *
 * Free up all memory associated with processing a glyph.
 *
*****************************************************************************/

static void
FreeLoopList( LOOP_LIST *pLoopList )
{
    DWORD nLoops;

    if( !pLoopList )
        return;

    if( pLoopList->LoopBuf ) {
        // free up each loop
        LOOP *pLoop = pLoopList->LoopBuf;

        nLoops = pLoopList->nLoops;
        for( ; nLoops; nLoops--, pLoop++ ) {
            if( pLoop->PrimBuf )
                FREE( pLoop->PrimBuf );
            if( pLoop->VertBuf )
                FREE( pLoop->VertBuf );
        } 
        FREE( pLoopList->LoopBuf );
    }
    FREE( pLoopList );
}

/*****************************************************************************
 * AppendToVertBuf
 *
 * Append a vertex to the Loop's VertBuf

*****************************************************************************/

static BOOL
AppendToVertBuf( LOOP      *pLoop,
                 PRIM      *pPrim,
                 POINT2D   *p )
{
    if( pLoop->nVerts >=  pLoop->VertBufSize)
    {
        POINT2D *vertBuf;
        DWORD   size = 100;

        vertBuf = (POINT2D *) REALLOC(pLoop->VertBuf,
                                      (pLoop->VertBufSize += size) *
                                      sizeof(POINT2D));
        if( !vertBuf )
            return WFO_FAILURE;
        pLoop->VertBuf = vertBuf;
    }
    pLoop->VertBuf[pLoop->nVerts] = *p;
    pLoop->nVerts++;
    pPrim->nVerts++;
    return WFO_SUCCESS;
}

/*****************************************************************************
 * CalcVertPtrs
 *
 * Calculate vertex ptrs from index values for the prims in a loop.

*****************************************************************************/

static void
CalcVertPtrs( LOOP *pLoop )
{
    DWORD nPrims;
    PRIM  *pPrim;

    nPrims = pLoop->nPrims;
    pPrim = pLoop->PrimBuf;

    for( ; nPrims; pPrim++, nPrims-- ) {
        pPrim->pVert = pLoop->VertBuf + pPrim->VertIndex;
    }
}


/*****************************************************************************
 * GetFixed
 *
 * Fetch the next 32-bit fixed-point value from a little-endian byte stream,
 * convert it to floating-point, and increment the stream pointer to the next
 * unscanned byte.

*****************************************************************************/

static FLOAT GetFixed(UCHAR** p)
{
    FLOAT value;
    FLOAT fraction;

    fraction = ((FLOAT) (UINT) GetWord(p)) / 65536.0f;
    value    = (FLOAT) GetSignedWord(p);

    return value+fraction;
}

#ifdef FONT_DEBUG
void
DrawColorCodedLineLoop( LOOP *pLoop, FLOAT zextrusion )
{
    POINT2D *p;
    DWORD   nPrims;
    DWORD   nVerts;
    PRIM    *pPrim;

    nPrims = pLoop->nPrims;
    pPrim  = pLoop->PrimBuf;
    for( ; nPrims; nPrims--, pPrim++ ) {

        if( pPrim->primType == PRIM_LINE ) {
            if( nPrims == pLoop->nPrims ) // first prim
                glColor3d( 0.5, 0.0, 0.0 );
            else
                glColor3d( 1.0, 0.0, 0.0 );
        } else {
            if( nPrims == pLoop->nPrims ) // first prim
                glColor3d( 0.5, 0.5, 0.0 );
            else
                glColor3d( 1.0, 1.0, 0.0 );
        }
        
        nVerts = pPrim->nVerts;
        p = pPrim->pVert;
        glBegin(GL_LINE_STRIP);
        for( ; nVerts; nVerts--, p++ ) {
            glVertex3f( p->x, p->y, zextrusion );
        }
        glEnd();
#define DRAW_POINTS 1
#ifdef DRAW_POINTS
        glColor3d( 0.0, 0.5, 0.0 );
        nVerts = pPrim->nVerts;
        p = pPrim->pVert;
        glPointSize( 4.0f );
        glBegin( GL_POINTS );
        for( ; nVerts; nVerts--, p++ ) {
            glVertex3f( p->x, p->y, zextrusion );
        }
        glEnd();
#endif
    }

    // Draw bright green point at start of loop
    if( pLoop->nVerts ) {
        glColor3d( 0.0, 1.0, 0.0 );
        glPointSize( 4.0f );
        glBegin( GL_POINTS );
        p = pLoop->VertBuf;
        glVertex3f( p->x, p->y, zextrusion );
        glEnd();
        glPointSize( 1.0f );
    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\fontoutl.h ===
#define WFO_FAILURE   FALSE 
#define WFO_SUCCESS   TRUE

#define PI      3.141592653589793
#define TWO_PI  2.0*PI   

#define ZERO_EPS    0.00000001

//#define VARRAY 1

static const double   CoplanarThresholdAngle = PI/180.0/2.0; // 0.5 degreees

// outline prim types
#define PRIM_LINE     3
#define PRIM_CURVE    4

typedef struct {
    FLOAT x,y;
} POINT2D;

typedef struct {
    FLOAT x,y,z;
} POINT3D;

typedef struct {
    DWORD   primType;
    DWORD   nVerts;
    DWORD   VertIndex;// index into Loop's VertBuf
    POINT2D *pVert;   // ptr to vertex list in Loop's VertBuf
    POINT3D *pFNorm;  // face normals
    POINT3D *pVNorm;  // vertex normals
} PRIM;


typedef struct {
    PRIM    *PrimBuf;  // array of prims
    DWORD   nPrims;
    DWORD   PrimBufSize;
    POINT2D *VertBuf;  // buffer of vertices for the loop
    DWORD   nVerts;
    DWORD   VertBufSize;
    POINT3D *FNormBuf;  // buffer of face normals
    POINT3D *VNormBuf;  // buffer of vertex normals
} LOOP;

typedef struct {
    LOOP    *LoopBuf;  // array of loops
    DWORD   nLoops;
    DWORD   LoopBufSize;
} LOOP_LIST;

typedef struct {
    FLOAT        zExtrusion;
    INT          extrType;
    FLOAT*       FaceBuf;
    DWORD        FaceBufSize;
    DWORD        FaceBufIndex;
    DWORD        FaceVertexCountIndex;
#ifdef VARRAY
    FLOAT*       vaBuf;
    DWORD        vaBufSize;
#endif
#ifdef FONT_DEBUG
    BOOL         bSidePolys;
    BOOL         bFacePolys;
#endif
    GLenum       TessErrorOccurred;
} EXTRContext;

// Memory pool for tesselation Combine callback
#define POOL_SIZE 50
typedef struct MEM_POOL MEM_POOL;

struct MEM_POOL {
    int      index;             // next free space in pool
    POINT2D  pool[POOL_SIZE];   // memory pool
    MEM_POOL *next;             // next pool
};

typedef struct {
    GLenum              TessErrorOccurred;
    FLOAT               chordalDeviation;
    FLOAT               scale;
    int                 format;
    UCHAR*              glyphBuf;
    DWORD               glyphSize;
    HFONT               hfontOld;
    GLUtesselator*      tess;
    MEM_POOL            combinePool;     // start of MEM_POOL chain
    MEM_POOL            *curCombinePool; // currently active MEM_POOL
    EXTRContext         *ec;
} OFContext;  // Outline Font Context

extern EXTRContext*   extr_Init(                FLOAT       extrusion,  
                                                INT         format ); 

extern void           extr_Finish(              EXTRContext *ec );

extern void           extr_DrawLines(           EXTRContext *ec, 
                                                LOOP_LIST   *pLoopList );

extern BOOL           extr_DrawPolygons(        EXTRContext *ec,
                                                LOOP_LIST   *pLoopList );

#ifdef VARRAY
extern void           DrawFacePolygons(         EXTRContext *ec,  
                                                FLOAT       z );
#endif

extern BOOL           extr_PolyInit(            EXTRContext *ec );

extern void           extr_PolyFinish(          EXTRContext *ec );

extern void CALLBACK  extr_glBegin(             GLenum      primType,
                                                void        *data );

extern void CALLBACK  extr_glVertex(            GLfloat     *v,
                                                void        *data );

extern void CALLBACK  extr_glEnd(               void );

extern double         CalcAngle(                POINT2D     *v1, 
                                                POINT2D     *v2 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\glapi.c ===
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* AUTOMATICALLY UPDATED OR GENERATED BY SGI: DO NOT EDIT */

#include "precomp.h"
#pragma hdrstop

#include "glapi.h"

void APIENTRY
glNewList ( IN GLuint list, IN GLenum mode )
{
    (*GLTEB_CLTDISPATCHTABLE()->glNewList)( list, mode );
}

void APIENTRY
glEndList ( void )
{
    (*GLTEB_CLTDISPATCHTABLE()->glEndList)( );
}

void APIENTRY
glCallList ( IN GLuint list )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glCallList)( list );
}

void APIENTRY
glCallLists ( IN GLsizei n, IN GLenum type, IN const GLvoid *lists )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glCallLists)( n, type, lists );
}

void APIENTRY
glDeleteLists ( IN GLuint list, IN GLsizei range )
{
    (*GLTEB_CLTDISPATCHTABLE()->glDeleteLists)( list, range );
}

GLuint APIENTRY
glGenLists ( IN GLsizei range )
{
    return( (*GLTEB_CLTDISPATCHTABLE()->glGenLists)( range ) );
}

void APIENTRY
glListBase ( IN GLuint base )
{
    (*GLTEB_CLTDISPATCHTABLE()->glListBase)( base );
}

void APIENTRY
glBegin ( IN GLenum mode )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glBegin)( mode );
}

void APIENTRY
glBitmap ( IN GLsizei width, IN GLsizei height, IN GLfloat xorig, IN GLfloat yorig, IN GLfloat xmove, IN GLfloat ymove, IN const GLubyte bitmap[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glBitmap)( width, height, xorig, yorig, xmove, ymove, bitmap );
}

void APIENTRY
glColor3b ( IN GLbyte red, IN GLbyte green, IN GLbyte blue )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3b)( red, green, blue );
}

void APIENTRY
glColor3bv ( IN const GLbyte v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3bv)( v );
}

void APIENTRY
glColor3d ( IN GLdouble red, IN GLdouble green, IN GLdouble blue )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3d)( red, green, blue );
}

void APIENTRY
glColor3dv ( IN const GLdouble v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3dv)( v );
}

void APIENTRY
glColor3f ( IN GLfloat red, IN GLfloat green, IN GLfloat blue )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3f)( red, green, blue );
}

void APIENTRY
glColor3fv ( IN const GLfloat v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3fv)( v );
}

void APIENTRY
glColor3i ( IN GLint red, IN GLint green, IN GLint blue )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3i)( red, green, blue );
}

void APIENTRY
glColor3iv ( IN const GLint v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3iv)( v );
}

void APIENTRY
glColor3s ( IN GLshort red, IN GLshort green, IN GLshort blue )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3s)( red, green, blue );
}

void APIENTRY
glColor3sv ( IN const GLshort v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3sv)( v );
}

void APIENTRY
glColor3ub ( IN GLubyte red, IN GLubyte green, IN GLubyte blue )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3ub)( red, green, blue );
}

void APIENTRY
glColor3ubv ( IN const GLubyte v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3ubv)( v );
}

void APIENTRY
glColor3ui ( IN GLuint red, IN GLuint green, IN GLuint blue )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3ui)( red, green, blue );
}

void APIENTRY
glColor3uiv ( IN const GLuint v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3uiv)( v );
}

void APIENTRY
glColor3us ( IN GLushort red, IN GLushort green, IN GLushort blue )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3us)( red, green, blue );
}

void APIENTRY
glColor3usv ( IN const GLushort v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3usv)( v );
}

void APIENTRY
glColor4b ( IN GLbyte red, IN GLbyte green, IN GLbyte blue, IN GLbyte alpha )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4b)( red, green, blue, alpha );
}

void APIENTRY
glColor4bv ( IN const GLbyte v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4bv)( v );
}

void APIENTRY
glColor4d ( IN GLdouble red, IN GLdouble green, IN GLdouble blue, IN GLdouble alpha )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4d)( red, green, blue, alpha );
}

void APIENTRY
glColor4dv ( IN const GLdouble v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4dv)( v );
}

void APIENTRY
glColor4f ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4f)( red, green, blue, alpha );
}

void APIENTRY
glColor4fv ( IN const GLfloat v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4fv)( v );
}

void APIENTRY
glColor4i ( IN GLint red, IN GLint green, IN GLint blue, IN GLint alpha )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4i)( red, green, blue, alpha );
}

void APIENTRY
glColor4iv ( IN const GLint v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4iv)( v );
}

void APIENTRY
glColor4s ( IN GLshort red, IN GLshort green, IN GLshort blue, IN GLshort alpha )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4s)( red, green, blue, alpha );
}

void APIENTRY
glColor4sv ( IN const GLshort v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4sv)( v );
}

void APIENTRY
glColor4ub ( IN GLubyte red, IN GLubyte green, IN GLubyte blue, IN GLubyte alpha )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4ub)( red, green, blue, alpha );
}

void APIENTRY
glColor4ubv ( IN const GLubyte v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4ubv)( v );
}

void APIENTRY
glColor4ui ( IN GLuint red, IN GLuint green, IN GLuint blue, IN GLuint alpha )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4ui)( red, green, blue, alpha );
}

void APIENTRY
glColor4uiv ( IN const GLuint v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4uiv)( v );
}

void APIENTRY
glColor4us ( IN GLushort red, IN GLushort green, IN GLushort blue, IN GLushort alpha )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4us)( red, green, blue, alpha );
}

void APIENTRY
glColor4usv ( IN const GLushort v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4usv)( v );
}

void APIENTRY
glEdgeFlag ( IN GLboolean flag )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEdgeFlag)( flag );
}

void APIENTRY
glEdgeFlagv ( IN const GLboolean flag[1] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEdgeFlagv)( flag );
}

void APIENTRY
glEnd ( void )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEnd)( );
}

void APIENTRY
glIndexd ( IN GLdouble c )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glIndexd)( c );
}

void APIENTRY
glIndexdv ( IN const GLdouble c[1] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glIndexdv)( c );
}

void APIENTRY
glIndexf ( IN GLfloat c )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glIndexf)( c );
}

void APIENTRY
glIndexfv ( IN const GLfloat c[1] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glIndexfv)( c );
}

void APIENTRY
glIndexi ( IN GLint c )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glIndexi)( c );
}

void APIENTRY
glIndexiv ( IN const GLint c[1] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glIndexiv)( c );
}

void APIENTRY
glIndexs ( IN GLshort c )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glIndexs)( c );
}

void APIENTRY
glIndexsv ( IN const GLshort c[1] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glIndexsv)( c );
}

void APIENTRY
glNormal3b ( IN GLbyte nx, IN GLbyte ny, IN GLbyte nz )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glNormal3b)( nx, ny, nz );
}

void APIENTRY
glNormal3bv ( IN const GLbyte v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glNormal3bv)( v );
}

void APIENTRY
glNormal3d ( IN GLdouble nx, IN GLdouble ny, IN GLdouble nz )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glNormal3d)( nx, ny, nz );
}

void APIENTRY
glNormal3dv ( IN const GLdouble v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glNormal3dv)( v );
}

void APIENTRY
glNormal3f ( IN GLfloat nx, IN GLfloat ny, IN GLfloat nz )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glNormal3f)( nx, ny, nz );
}

void APIENTRY
glNormal3fv ( IN const GLfloat v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glNormal3fv)( v );
}

void APIENTRY
glNormal3i ( IN GLint nx, IN GLint ny, IN GLint nz )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glNormal3i)( nx, ny, nz );
}

void APIENTRY
glNormal3iv ( IN const GLint v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glNormal3iv)( v );
}

void APIENTRY
glNormal3s ( IN GLshort nx, IN GLshort ny, IN GLshort nz )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glNormal3s)( nx, ny, nz );
}

void APIENTRY
glNormal3sv ( IN const GLshort v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glNormal3sv)( v );
}

void APIENTRY
glRasterPos2d ( IN GLdouble x, IN GLdouble y )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos2d)( x, y );
}

void APIENTRY
glRasterPos2dv ( IN const GLdouble v[2] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos2dv)( v );
}

void APIENTRY
glRasterPos2f ( IN GLfloat x, IN GLfloat y )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos2f)( x, y );
}

void APIENTRY
glRasterPos2fv ( IN const GLfloat v[2] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos2fv)( v );
}

void APIENTRY
glRasterPos2i ( IN GLint x, IN GLint y )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos2i)( x, y );
}

void APIENTRY
glRasterPos2iv ( IN const GLint v[2] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos2iv)( v );
}

void APIENTRY
glRasterPos2s ( IN GLshort x, IN GLshort y )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos2s)( x, y );
}

void APIENTRY
glRasterPos2sv ( IN const GLshort v[2] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos2sv)( v );
}

void APIENTRY
glRasterPos3d ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos3d)( x, y, z );
}

void APIENTRY
glRasterPos3dv ( IN const GLdouble v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos3dv)( v );
}

void APIENTRY
glRasterPos3f ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos3f)( x, y, z );
}

void APIENTRY
glRasterPos3fv ( IN const GLfloat v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos3fv)( v );
}

void APIENTRY
glRasterPos3i ( IN GLint x, IN GLint y, IN GLint z )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos3i)( x, y, z );
}

void APIENTRY
glRasterPos3iv ( IN const GLint v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos3iv)( v );
}

void APIENTRY
glRasterPos3s ( IN GLshort x, IN GLshort y, IN GLshort z )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos3s)( x, y, z );
}

void APIENTRY
glRasterPos3sv ( IN const GLshort v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos3sv)( v );
}

void APIENTRY
glRasterPos4d ( IN GLdouble x, IN GLdouble y, IN GLdouble z, IN GLdouble w )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos4d)( x, y, z, w );
}

void APIENTRY
glRasterPos4dv ( IN const GLdouble v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos4dv)( v );
}

void APIENTRY
glRasterPos4f ( IN GLfloat x, IN GLfloat y, IN GLfloat z, IN GLfloat w )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos4f)( x, y, z, w );
}

void APIENTRY
glRasterPos4fv ( IN const GLfloat v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos4fv)( v );
}

void APIENTRY
glRasterPos4i ( IN GLint x, IN GLint y, IN GLint z, IN GLint w )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos4i)( x, y, z, w );
}

void APIENTRY
glRasterPos4iv ( IN const GLint v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos4iv)( v );
}

void APIENTRY
glRasterPos4s ( IN GLshort x, IN GLshort y, IN GLshort z, IN GLshort w )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos4s)( x, y, z, w );
}

void APIENTRY
glRasterPos4sv ( IN const GLshort v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos4sv)( v );
}

void APIENTRY
glRectd ( IN GLdouble x1, IN GLdouble y1, IN GLdouble x2, IN GLdouble y2 )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRectd)( x1, y1, x2, y2 );
}

void APIENTRY
glRectdv ( IN const GLdouble v1[2], IN const GLdouble v2[2] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRectdv)( v1, v2 );
}

void APIENTRY
glRectf ( IN GLfloat x1, IN GLfloat y1, IN GLfloat x2, IN GLfloat y2 )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRectf)( x1, y1, x2, y2 );
}

void APIENTRY
glRectfv ( IN const GLfloat v1[2], IN const GLfloat v2[2] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRectfv)( v1, v2 );
}

void APIENTRY
glRecti ( IN GLint x1, IN GLint y1, IN GLint x2, IN GLint y2 )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRecti)( x1, y1, x2, y2 );
}

void APIENTRY
glRectiv ( IN const GLint v1[2], IN const GLint v2[2] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRectiv)( v1, v2 );
}

void APIENTRY
glRects ( IN GLshort x1, IN GLshort y1, IN GLshort x2, IN GLshort y2 )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRects)( x1, y1, x2, y2 );
}

void APIENTRY
glRectsv ( IN const GLshort v1[2], IN const GLshort v2[2] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRectsv)( v1, v2 );
}

void APIENTRY
glTexCoord1d ( IN GLdouble s )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord1d)( s );
}

void APIENTRY
glTexCoord1dv ( IN const GLdouble v[1] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord1dv)( v );
}

void APIENTRY
glTexCoord1f ( IN GLfloat s )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord1f)( s );
}

void APIENTRY
glTexCoord1fv ( IN const GLfloat v[1] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord1fv)( v );
}

void APIENTRY
glTexCoord1i ( IN GLint s )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord1i)( s );
}

void APIENTRY
glTexCoord1iv ( IN const GLint v[1] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord1iv)( v );
}

void APIENTRY
glTexCoord1s ( IN GLshort s )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord1s)( s );
}

void APIENTRY
glTexCoord1sv ( IN const GLshort v[1] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord1sv)( v );
}

void APIENTRY
glTexCoord2d ( IN GLdouble s, IN GLdouble t )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord2d)( s, t );
}

void APIENTRY
glTexCoord2dv ( IN const GLdouble v[2] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord2dv)( v );
}

void APIENTRY
glTexCoord2f ( IN GLfloat s, IN GLfloat t )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord2f)( s, t );
}

void APIENTRY
glTexCoord2fv ( IN const GLfloat v[2] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord2fv)( v );
}

void APIENTRY
glTexCoord2i ( IN GLint s, IN GLint t )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord2i)( s, t );
}

void APIENTRY
glTexCoord2iv ( IN const GLint v[2] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord2iv)( v );
}

void APIENTRY
glTexCoord2s ( IN GLshort s, IN GLshort t )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord2s)( s, t );
}

void APIENTRY
glTexCoord2sv ( IN const GLshort v[2] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord2sv)( v );
}

void APIENTRY
glTexCoord3d ( IN GLdouble s, IN GLdouble t, IN GLdouble r )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord3d)( s, t, r );
}

void APIENTRY
glTexCoord3dv ( IN const GLdouble v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord3dv)( v );
}

void APIENTRY
glTexCoord3f ( IN GLfloat s, IN GLfloat t, IN GLfloat r )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord3f)( s, t, r );
}

void APIENTRY
glTexCoord3fv ( IN const GLfloat v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord3fv)( v );
}

void APIENTRY
glTexCoord3i ( IN GLint s, IN GLint t, IN GLint r )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord3i)( s, t, r );
}

void APIENTRY
glTexCoord3iv ( IN const GLint v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord3iv)( v );
}

void APIENTRY
glTexCoord3s ( IN GLshort s, IN GLshort t, IN GLshort r )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord3s)( s, t, r );
}

void APIENTRY
glTexCoord3sv ( IN const GLshort v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord3sv)( v );
}

void APIENTRY
glTexCoord4d ( IN GLdouble s, IN GLdouble t, IN GLdouble r, IN GLdouble q )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord4d)( s, t, r, q );
}

void APIENTRY
glTexCoord4dv ( IN const GLdouble v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord4dv)( v );
}

void APIENTRY
glTexCoord4f ( IN GLfloat s, IN GLfloat t, IN GLfloat r, IN GLfloat q )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord4f)( s, t, r, q );
}

void APIENTRY
glTexCoord4fv ( IN const GLfloat v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord4fv)( v );
}

void APIENTRY
glTexCoord4i ( IN GLint s, IN GLint t, IN GLint r, IN GLint q )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord4i)( s, t, r, q );
}

void APIENTRY
glTexCoord4iv ( IN const GLint v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord4iv)( v );
}

void APIENTRY
glTexCoord4s ( IN GLshort s, IN GLshort t, IN GLshort r, IN GLshort q )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord4s)( s, t, r, q );
}

void APIENTRY
glTexCoord4sv ( IN const GLshort v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord4sv)( v );
}

void APIENTRY
glVertex2d ( IN GLdouble x, IN GLdouble y )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex2d)( x, y );
}

void APIENTRY
glVertex2dv ( IN const GLdouble v[2] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex2dv)( v );
}

void APIENTRY
glVertex2f ( IN GLfloat x, IN GLfloat y )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex2f)( x, y );
}

void APIENTRY
glVertex2fv ( IN const GLfloat v[2] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex2fv)( v );
}

void APIENTRY
glVertex2i ( IN GLint x, IN GLint y )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex2i)( x, y );
}

void APIENTRY
glVertex2iv ( IN const GLint v[2] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex2iv)( v );
}

void APIENTRY
glVertex2s ( IN GLshort x, IN GLshort y )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex2s)( x, y );
}

void APIENTRY
glVertex2sv ( IN const GLshort v[2] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex2sv)( v );
}

void APIENTRY
glVertex3d ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex3d)( x, y, z );
}

void APIENTRY
glVertex3dv ( IN const GLdouble v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex3dv)( v );
}

void APIENTRY
glVertex3f ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex3f)( x, y, z );
}

void APIENTRY
glVertex3fv ( IN const GLfloat v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex3fv)( v );
}

void APIENTRY
glVertex3i ( IN GLint x, IN GLint y, IN GLint z )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex3i)( x, y, z );
}

void APIENTRY
glVertex3iv ( IN const GLint v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex3iv)( v );
}

void APIENTRY
glVertex3s ( IN GLshort x, IN GLshort y, IN GLshort z )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex3s)( x, y, z );
}

void APIENTRY
glVertex3sv ( IN const GLshort v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex3sv)( v );
}

void APIENTRY
glVertex4d ( IN GLdouble x, IN GLdouble y, IN GLdouble z, IN GLdouble w )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex4d)( x, y, z, w );
}

void APIENTRY
glVertex4dv ( IN const GLdouble v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex4dv)( v );
}

void APIENTRY
glVertex4f ( IN GLfloat x, IN GLfloat y, IN GLfloat z, IN GLfloat w )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex4f)( x, y, z, w );
}

void APIENTRY
glVertex4fv ( IN const GLfloat v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex4fv)( v );
}

void APIENTRY
glVertex4i ( IN GLint x, IN GLint y, IN GLint z, IN GLint w )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex4i)( x, y, z, w );
}

void APIENTRY
glVertex4iv ( IN const GLint v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex4iv)( v );
}

void APIENTRY
glVertex4s ( IN GLshort x, IN GLshort y, IN GLshort z, IN GLshort w )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex4s)( x, y, z, w );
}

void APIENTRY
glVertex4sv ( IN const GLshort v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex4sv)( v );
}

void APIENTRY
glClipPlane ( IN GLenum plane, IN const GLdouble equation[4] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glClipPlane)( plane, equation );
}

void APIENTRY
glColorMaterial ( IN GLenum face, IN GLenum mode )
{
    (*GLTEB_CLTDISPATCHTABLE()->glColorMaterial)( face, mode );
}

void APIENTRY
glCullFace ( IN GLenum mode )
{
    (*GLTEB_CLTDISPATCHTABLE()->glCullFace)( mode );
}

void APIENTRY
glFogf ( IN GLenum pname, IN GLfloat param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glFogf)( pname, param );
}

void APIENTRY
glFogfv ( IN GLenum pname, IN const GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glFogfv)( pname, params );
}

void APIENTRY
glFogi ( IN GLenum pname, IN GLint param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glFogi)( pname, param );
}

void APIENTRY
glFogiv ( IN GLenum pname, IN const GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glFogiv)( pname, params );
}

void APIENTRY
glFrontFace ( IN GLenum mode )
{
    (*GLTEB_CLTDISPATCHTABLE()->glFrontFace)( mode );
}

void APIENTRY
glHint ( IN GLenum target, IN GLenum mode )
{
    (*GLTEB_CLTDISPATCHTABLE()->glHint)( target, mode );
}

void APIENTRY
glLightf ( IN GLenum light, IN GLenum pname, IN GLfloat param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glLightf)( light, pname, param );
}

void APIENTRY
glLightfv ( IN GLenum light, IN GLenum pname, IN const GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glLightfv)( light, pname, params );
}

void APIENTRY
glLighti ( IN GLenum light, IN GLenum pname, IN GLint param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glLighti)( light, pname, param );
}

void APIENTRY
glLightiv ( IN GLenum light, IN GLenum pname, IN const GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glLightiv)( light, pname, params );
}

void APIENTRY
glLightModelf ( IN GLenum pname, IN GLfloat param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glLightModelf)( pname, param );
}

void APIENTRY
glLightModelfv ( IN GLenum pname, IN const GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glLightModelfv)( pname, params );
}

void APIENTRY
glLightModeli ( IN GLenum pname, IN GLint param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glLightModeli)( pname, param );
}

void APIENTRY
glLightModeliv ( IN GLenum pname, IN const GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glLightModeliv)( pname, params );
}

void APIENTRY
glLineStipple ( IN GLint factor, IN GLushort pattern )
{
    (*GLTEB_CLTDISPATCHTABLE()->glLineStipple)( factor, pattern );
}

void APIENTRY
glLineWidth ( IN GLfloat width )
{
    (*GLTEB_CLTDISPATCHTABLE()->glLineWidth)( width );
}

void APIENTRY
glMaterialf ( IN GLenum face, IN GLenum pname, IN GLfloat param )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMaterialf)( face, pname, param );
}

void APIENTRY
glMaterialfv ( IN GLenum face, IN GLenum pname, IN const GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMaterialfv)( face, pname, params );
}

void APIENTRY
glMateriali ( IN GLenum face, IN GLenum pname, IN GLint param )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMateriali)( face, pname, param );
}

void APIENTRY
glMaterialiv ( IN GLenum face, IN GLenum pname, IN const GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMaterialiv)( face, pname, params );
}

void APIENTRY
glPointSize ( IN GLfloat size )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPointSize)( size );
}

void APIENTRY
glPolygonMode ( IN GLenum face, IN GLenum mode )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPolygonMode)( face, mode );
}

void APIENTRY
glPolygonStipple ( IN const GLubyte mask[128] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPolygonStipple)( mask );
}

void APIENTRY
glScissor ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height )
{
    (*GLTEB_CLTDISPATCHTABLE()->glScissor)( x, y, width, height );
}

void APIENTRY
glShadeModel ( IN GLenum mode )
{
    (*GLTEB_CLTDISPATCHTABLE()->glShadeModel)( mode );
}

void APIENTRY
glTexParameterf ( IN GLenum target, IN GLenum pname, IN GLfloat param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexParameterf)( target, pname, param );
}

void APIENTRY
glTexParameterfv ( IN GLenum target, IN GLenum pname, IN const GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexParameterfv)( target, pname, params );
}

void APIENTRY
glTexParameteri ( IN GLenum target, IN GLenum pname, IN GLint param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexParameteri)( target, pname, param );
}

void APIENTRY
glTexParameteriv ( IN GLenum target, IN GLenum pname, IN const GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexParameteriv)( target, pname, params );
}

void APIENTRY
glTexImage1D ( IN GLenum target, IN GLint level, IN GLint components, IN GLsizei width, IN GLint border, IN GLenum format, IN GLenum type, IN const GLvoid *pixels )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexImage1D)( target, level, components, width, border, format, type, pixels );
}

void APIENTRY
glTexImage2D ( IN GLenum target, IN GLint level, IN GLint components, IN GLsizei width, IN GLsizei height, IN GLint border, IN GLenum format, IN GLenum type, IN const GLvoid *pixels )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexImage2D)( target, level, components, width, height, border, format, type, pixels );
}

void APIENTRY
glTexEnvf ( IN GLenum target, IN GLenum pname, IN GLfloat param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexEnvf)( target, pname, param );
}

void APIENTRY
glTexEnvfv ( IN GLenum target, IN GLenum pname, IN const GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexEnvfv)( target, pname, params );
}

void APIENTRY
glTexEnvi ( IN GLenum target, IN GLenum pname, IN GLint param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexEnvi)( target, pname, param );
}

void APIENTRY
glTexEnviv ( IN GLenum target, IN GLenum pname, IN const GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexEnviv)( target, pname, params );
}

void APIENTRY
glTexGend ( IN GLenum coord, IN GLenum pname, IN GLdouble param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexGend)( coord, pname, param );
}

void APIENTRY
glTexGendv ( IN GLenum coord, IN GLenum pname, IN const GLdouble params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexGendv)( coord, pname, params );
}

void APIENTRY
glTexGenf ( IN GLenum coord, IN GLenum pname, IN GLfloat param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexGenf)( coord, pname, param );
}

void APIENTRY
glTexGenfv ( IN GLenum coord, IN GLenum pname, IN const GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexGenfv)( coord, pname, params );
}

void APIENTRY
glTexGeni ( IN GLenum coord, IN GLenum pname, IN GLint param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexGeni)( coord, pname, param );
}

void APIENTRY
glTexGeniv ( IN GLenum coord, IN GLenum pname, IN const GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexGeniv)( coord, pname, params );
}

void APIENTRY
glFeedbackBuffer ( IN GLsizei size, IN GLenum type, OUT GLfloat buffer[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glFeedbackBuffer)( size, type, buffer );
}

void APIENTRY
glSelectBuffer ( IN GLsizei size, OUT GLuint buffer[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glSelectBuffer)( size, buffer );
}

GLint APIENTRY
glRenderMode ( IN GLenum mode )
{
    return( (*GLTEB_CLTDISPATCHTABLE()->glRenderMode)( mode ) );
}

void APIENTRY
glInitNames ( void )
{
    (*GLTEB_CLTDISPATCHTABLE()->glInitNames)( );
}

void APIENTRY
glLoadName ( IN GLuint name )
{
    (*GLTEB_CLTDISPATCHTABLE()->glLoadName)( name );
}

void APIENTRY
glPassThrough ( IN GLfloat token )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPassThrough)( token );
}

void APIENTRY
glPopName ( void )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPopName)( );
}

void APIENTRY
glPushName ( IN GLuint name )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPushName)( name );
}

void APIENTRY
glDrawBuffer ( IN GLenum mode )
{
    (*GLTEB_CLTDISPATCHTABLE()->glDrawBuffer)( mode );
}

void APIENTRY
glClear ( IN GLbitfield mask )
{
    (*GLTEB_CLTDISPATCHTABLE()->glClear)( mask );
}

void APIENTRY
glClearAccum ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha )
{
    (*GLTEB_CLTDISPATCHTABLE()->glClearAccum)( red, green, blue, alpha );
}

void APIENTRY
glClearIndex ( IN GLfloat c )
{
    (*GLTEB_CLTDISPATCHTABLE()->glClearIndex)( c );
}

void APIENTRY
glClearColor ( IN GLclampf red, IN GLclampf green, IN GLclampf blue, IN GLclampf alpha )
{
    (*GLTEB_CLTDISPATCHTABLE()->glClearColor)( red, green, blue, alpha );
}

void APIENTRY
glClearStencil ( IN GLint s )
{
    (*GLTEB_CLTDISPATCHTABLE()->glClearStencil)( s );
}

void APIENTRY
glClearDepth ( IN GLclampd depth )
{
    (*GLTEB_CLTDISPATCHTABLE()->glClearDepth)( depth );
}

void APIENTRY
glStencilMask ( IN GLuint mask )
{
    (*GLTEB_CLTDISPATCHTABLE()->glStencilMask)( mask );
}

void APIENTRY
glColorMask ( IN GLboolean red, IN GLboolean green, IN GLboolean blue, IN GLboolean alpha )
{
    (*GLTEB_CLTDISPATCHTABLE()->glColorMask)( red, green, blue, alpha );
}

void APIENTRY
glDepthMask ( IN GLboolean flag )
{
    (*GLTEB_CLTDISPATCHTABLE()->glDepthMask)( flag );
}

void APIENTRY
glIndexMask ( IN GLuint mask )
{
    (*GLTEB_CLTDISPATCHTABLE()->glIndexMask)( mask );
}

void APIENTRY
glAccum ( IN GLenum op, IN GLfloat value )
{
    (*GLTEB_CLTDISPATCHTABLE()->glAccum)( op, value );
}

void APIENTRY
glDisable ( IN GLenum cap )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glDisable)( cap );
}

void APIENTRY
glEnable ( IN GLenum cap )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEnable)( cap );
}

void APIENTRY
glFinish ( void )
{
    (*GLTEB_CLTDISPATCHTABLE()->glFinish)( );
}

void APIENTRY
glFlush ( void )
{
    (*GLTEB_CLTDISPATCHTABLE()->glFlush)( );
}

void APIENTRY
glPopAttrib ( void )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glPopAttrib)( );
}

void APIENTRY
glPushAttrib ( IN GLbitfield mask )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glPushAttrib)( mask );
}

void APIENTRY
glMap1d ( IN GLenum target, IN GLdouble u1, IN GLdouble u2, IN GLint stride, IN GLint order, IN const GLdouble points[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glMap1d)( target, u1, u2, stride, order, points );
}

void APIENTRY
glMap1f ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint stride, IN GLint order, IN const GLfloat points[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glMap1f)( target, u1, u2, stride, order, points );
}

void APIENTRY
glMap2d ( IN GLenum target, IN GLdouble u1, IN GLdouble u2, IN GLint ustride, IN GLint uorder, IN GLdouble v1, IN GLdouble v2, IN GLint vstride, IN GLint vorder, IN const GLdouble points[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glMap2d)( target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points );
}

void APIENTRY
glMap2f ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint ustride, IN GLint uorder, IN GLfloat v1, IN GLfloat v2, IN GLint vstride, IN GLint vorder, IN const GLfloat points[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glMap2f)( target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points );
}

void APIENTRY
glMapGrid1d ( IN GLint un, IN GLdouble u1, IN GLdouble u2 )
{
    (*GLTEB_CLTDISPATCHTABLE()->glMapGrid1d)( un, u1, u2 );
}

void APIENTRY
glMapGrid1f ( IN GLint un, IN GLfloat u1, IN GLfloat u2 )
{
    (*GLTEB_CLTDISPATCHTABLE()->glMapGrid1f)( un, u1, u2 );
}

void APIENTRY
glMapGrid2d ( IN GLint un, IN GLdouble u1, IN GLdouble u2, IN GLint vn, IN GLdouble v1, IN GLdouble v2 )
{
    (*GLTEB_CLTDISPATCHTABLE()->glMapGrid2d)( un, u1, u2, vn, v1, v2 );
}

void APIENTRY
glMapGrid2f ( IN GLint un, IN GLfloat u1, IN GLfloat u2, IN GLint vn, IN GLfloat v1, IN GLfloat v2 )
{
    (*GLTEB_CLTDISPATCHTABLE()->glMapGrid2f)( un, u1, u2, vn, v1, v2 );
}

void APIENTRY
glEvalCoord1d ( IN GLdouble u )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEvalCoord1d)( u );
}

void APIENTRY
glEvalCoord1dv ( IN const GLdouble u[1] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEvalCoord1dv)( u );
}

void APIENTRY
glEvalCoord1f ( IN GLfloat u )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEvalCoord1f)( u );
}

void APIENTRY
glEvalCoord1fv ( IN const GLfloat u[1] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEvalCoord1fv)( u );
}

void APIENTRY
glEvalCoord2d ( IN GLdouble u, IN GLdouble v )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEvalCoord2d)( u, v );
}

void APIENTRY
glEvalCoord2dv ( IN const GLdouble u[2] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEvalCoord2dv)( u );
}

void APIENTRY
glEvalCoord2f ( IN GLfloat u, IN GLfloat v )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEvalCoord2f)( u, v );
}

void APIENTRY
glEvalCoord2fv ( IN const GLfloat u[2] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEvalCoord2fv)( u );
}

void APIENTRY
glEvalMesh1 ( IN GLenum mode, IN GLint i1, IN GLint i2 )
{
    (*GLTEB_CLTDISPATCHTABLE()->glEvalMesh1)( mode, i1, i2 );
}

void APIENTRY
glEvalPoint1 ( IN GLint i )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEvalPoint1)( i );
}

void APIENTRY
glEvalMesh2 ( IN GLenum mode, IN GLint i1, IN GLint i2, IN GLint j1, IN GLint j2 )
{
    (*GLTEB_CLTDISPATCHTABLE()->glEvalMesh2)( mode, i1, i2, j1, j2 );
}

void APIENTRY
glEvalPoint2 ( IN GLint i, IN GLint j )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEvalPoint2)( i, j );
}

void APIENTRY
glAlphaFunc ( IN GLenum func, IN GLclampf ref )
{
    (*GLTEB_CLTDISPATCHTABLE()->glAlphaFunc)( func, ref );
}

void APIENTRY
glBlendFunc ( IN GLenum sfactor, IN GLenum dfactor )
{
    (*GLTEB_CLTDISPATCHTABLE()->glBlendFunc)( sfactor, dfactor );
}

void APIENTRY
glLogicOp ( IN GLenum opcode )
{
    (*GLTEB_CLTDISPATCHTABLE()->glLogicOp)( opcode );
}

void APIENTRY
glStencilFunc ( IN GLenum func, IN GLint ref, IN GLuint mask )
{
    (*GLTEB_CLTDISPATCHTABLE()->glStencilFunc)( func, ref, mask );
}

void APIENTRY
glStencilOp ( IN GLenum fail, IN GLenum zfail, IN GLenum zpass )
{
    (*GLTEB_CLTDISPATCHTABLE()->glStencilOp)( fail, zfail, zpass );
}

void APIENTRY
glDepthFunc ( IN GLenum func )
{
    (*GLTEB_CLTDISPATCHTABLE()->glDepthFunc)( func );
}

void APIENTRY
glPixelZoom ( IN GLfloat xfactor, IN GLfloat yfactor )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPixelZoom)( xfactor, yfactor );
}

void APIENTRY
glPixelTransferf ( IN GLenum pname, IN GLfloat param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPixelTransferf)( pname, param );
}

void APIENTRY
glPixelTransferi ( IN GLenum pname, IN GLint param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPixelTransferi)( pname, param );
}

void APIENTRY
glPixelStoref ( IN GLenum pname, IN GLfloat param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPixelStoref)( pname, param );
}

void APIENTRY
glPixelStorei ( IN GLenum pname, IN GLint param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPixelStorei)( pname, param );
}

void APIENTRY
glPixelMapfv ( IN GLenum map, IN GLint mapsize, IN const GLfloat values[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPixelMapfv)( map, mapsize, values );
}

void APIENTRY
glPixelMapuiv ( IN GLenum map, IN GLint mapsize, IN const GLuint values[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPixelMapuiv)( map, mapsize, values );
}

void APIENTRY
glPixelMapusv ( IN GLenum map, IN GLint mapsize, IN const GLushort values[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPixelMapusv)( map, mapsize, values );
}

void APIENTRY
glReadBuffer ( IN GLenum mode )
{
    (*GLTEB_CLTDISPATCHTABLE()->glReadBuffer)( mode );
}

void APIENTRY
glCopyPixels ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height, IN GLenum type )
{
    (*GLTEB_CLTDISPATCHTABLE()->glCopyPixels)( x, y, width, height, type );
}

void APIENTRY
glReadPixels ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height, IN GLenum format, IN GLenum type, OUT GLvoid *pixels )
{
    (*GLTEB_CLTDISPATCHTABLE()->glReadPixels)( x, y, width, height, format, type, pixels );
}

void APIENTRY
glDrawPixels ( IN GLsizei width, IN GLsizei height, IN GLenum format, IN GLenum type, IN const GLvoid *pixels )
{
    (*GLTEB_CLTDISPATCHTABLE()->glDrawPixels)( width, height, format, type, pixels );
}

void APIENTRY
glGetBooleanv ( IN GLenum pname, OUT GLboolean params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetBooleanv)( pname, params );
}

void APIENTRY
glGetClipPlane ( IN GLenum plane, OUT GLdouble equation[4] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetClipPlane)( plane, equation );
}

void APIENTRY
glGetDoublev ( IN GLenum pname, OUT GLdouble params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetDoublev)( pname, params );
}

GLenum APIENTRY
glGetError ( void )
{
    return( (*GLTEB_CLTDISPATCHTABLE()->glGetError)( ) );
}

void APIENTRY
glGetFloatv ( IN GLenum pname, OUT GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetFloatv)( pname, params );
}

void APIENTRY
glGetIntegerv ( IN GLenum pname, OUT GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetIntegerv)( pname, params );
}

void APIENTRY
glGetLightfv ( IN GLenum light, IN GLenum pname, OUT GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetLightfv)( light, pname, params );
}

void APIENTRY
glGetLightiv ( IN GLenum light, IN GLenum pname, OUT GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetLightiv)( light, pname, params );
}

void APIENTRY
glGetMapdv ( IN GLenum target, IN GLenum query, OUT GLdouble v[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetMapdv)( target, query, v );
}

void APIENTRY
glGetMapfv ( IN GLenum target, IN GLenum query, OUT GLfloat v[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetMapfv)( target, query, v );
}

void APIENTRY
glGetMapiv ( IN GLenum target, IN GLenum query, OUT GLint v[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetMapiv)( target, query, v );
}

void APIENTRY
glGetMaterialfv ( IN GLenum face, IN GLenum pname, OUT GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetMaterialfv)( face, pname, params );
}

void APIENTRY
glGetMaterialiv ( IN GLenum face, IN GLenum pname, OUT GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetMaterialiv)( face, pname, params );
}

void APIENTRY
glGetPixelMapfv ( IN GLenum map, OUT GLfloat values[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetPixelMapfv)( map, values );
}

void APIENTRY
glGetPixelMapuiv ( IN GLenum map, OUT GLuint values[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetPixelMapuiv)( map, values );
}

void APIENTRY
glGetPixelMapusv ( IN GLenum map, OUT GLushort values[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetPixelMapusv)( map, values );
}

void APIENTRY
glGetPolygonStipple ( OUT GLubyte mask[128] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetPolygonStipple)( mask );
}

const GLubyte * APIENTRY
glGetString ( IN GLenum name )
{
    return( (*GLTEB_CLTDISPATCHTABLE()->glGetString)( name ) );
}

void APIENTRY
glGetTexEnvfv ( IN GLenum target, IN GLenum pname, OUT GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetTexEnvfv)( target, pname, params );
}

void APIENTRY
glGetTexEnviv ( IN GLenum target, IN GLenum pname, OUT GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetTexEnviv)( target, pname, params );
}

void APIENTRY
glGetTexGendv ( IN GLenum coord, IN GLenum pname, OUT GLdouble params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetTexGendv)( coord, pname, params );
}

void APIENTRY
glGetTexGenfv ( IN GLenum coord, IN GLenum pname, OUT GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetTexGenfv)( coord, pname, params );
}

void APIENTRY
glGetTexGeniv ( IN GLenum coord, IN GLenum pname, OUT GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetTexGeniv)( coord, pname, params );
}

void APIENTRY
glGetTexImage ( IN GLenum target, IN GLint level, IN GLenum format, IN GLenum type, OUT GLvoid *pixels )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetTexImage)( target, level, format, type, pixels );
}

void APIENTRY
glGetTexParameterfv ( IN GLenum target, IN GLenum pname, OUT GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetTexParameterfv)( target, pname, params );
}

void APIENTRY
glGetTexParameteriv ( IN GLenum target, IN GLenum pname, OUT GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetTexParameteriv)( target, pname, params );
}

void APIENTRY
glGetTexLevelParameterfv ( IN GLenum target, IN GLint level, IN GLenum pname, OUT GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetTexLevelParameterfv)( target, level, pname, params );
}

void APIENTRY
glGetTexLevelParameteriv ( IN GLenum target, IN GLint level, IN GLenum pname, OUT GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetTexLevelParameteriv)( target, level, pname, params );
}

GLboolean APIENTRY
glIsEnabled ( IN GLenum cap )
{
    return( (*GLTEB_CLTDISPATCHTABLE()->glIsEnabled)( cap ) );
}

GLboolean APIENTRY
glIsList ( IN GLuint list )
{
    return( (*GLTEB_CLTDISPATCHTABLE()->glIsList)( list ) );
}

void APIENTRY
glDepthRange ( IN GLclampd zNear, IN GLclampd zFar )
{
    (*GLTEB_CLTDISPATCHTABLE()->glDepthRange)( zNear, zFar );
}

void APIENTRY
glFrustum ( IN GLdouble left, IN GLdouble right, IN GLdouble bottom, IN GLdouble top, IN GLdouble zNear, IN GLdouble zFar )
{
    (*GLTEB_CLTDISPATCHTABLE()->glFrustum)( left, right, bottom, top, zNear, zFar );
}

void APIENTRY
glLoadIdentity ( void )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glLoadIdentity)( );
}

void APIENTRY
glLoadMatrixf ( IN const GLfloat m[16] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glLoadMatrixf)( m );
}

void APIENTRY
glLoadMatrixd ( IN const GLdouble m[16] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glLoadMatrixd)( m );
}

void APIENTRY
glMatrixMode ( IN GLenum mode )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMatrixMode)( mode );
}

void APIENTRY
glMultMatrixf ( IN const GLfloat m[16] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMultMatrixf)( m );
}

void APIENTRY
glMultMatrixd ( IN const GLdouble m[16] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMultMatrixd)( m );
}

void APIENTRY
glOrtho ( IN GLdouble left, IN GLdouble right, IN GLdouble bottom, IN GLdouble top, IN GLdouble zNear, IN GLdouble zFar )
{
    (*GLTEB_CLTDISPATCHTABLE()->glOrtho)( left, right, bottom, top, zNear, zFar );
}

void APIENTRY
glPopMatrix ( void )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glPopMatrix)( );
}

void APIENTRY
glPushMatrix ( void )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glPushMatrix)( );
}

void APIENTRY
glRotated ( IN GLdouble angle, IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glRotated)( angle, x, y, z );
}

void APIENTRY
glRotatef ( IN GLfloat angle, IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glRotatef)( angle, x, y, z );
}

void APIENTRY
glScaled ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glScaled)( x, y, z );
}

void APIENTRY
glScalef ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glScalef)( x, y, z );
}

void APIENTRY
glTranslated ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTranslated)( x, y, z );
}

void APIENTRY
glTranslatef ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTranslatef)( x, y, z );
}

void APIENTRY
glViewport ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height )
{
    (*GLTEB_CLTDISPATCHTABLE()->glViewport)( x, y, width, height );
}

GLboolean APIENTRY
glAreTexturesResident(GLsizei n, const GLuint *textures,
                                            GLboolean *residences)
{
    return (*GLTEB_CLTDISPATCHTABLE()->glAreTexturesResident)(n, textures, residences);
}

void APIENTRY
glBindTexture(GLenum target, GLuint texture)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glBindTexture)(target, texture);
}

void APIENTRY
glCopyTexImage1D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLint border)
{
    (*GLTEB_CLTDISPATCHTABLE()->glCopyTexImage1D)(target, level,
                                                  internalformat,
                                                  x, y, width, border);
}

void APIENTRY
glCopyTexImage2D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLsizei height, GLint border)
{
    (*GLTEB_CLTDISPATCHTABLE()->glCopyTexImage2D)(target, level, internalformat, x, y, width, height, border);
}

void APIENTRY
glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                     GLint x, GLint y, GLsizei width)
{
    (*GLTEB_CLTDISPATCHTABLE()->glCopyTexSubImage1D)(target, level, xoffset, x, y, width);
}

void APIENTRY
glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                     GLint yoffset, GLint x, GLint y,
                                     GLsizei width, GLsizei height)
{
    (*GLTEB_CLTDISPATCHTABLE()->glCopyTexSubImage2D)(target, level, xoffset, yoffset, x, y, width, height);
}

void APIENTRY
glDeleteTextures(GLsizei n, const GLuint *textures)
{
    (*GLTEB_CLTDISPATCHTABLE()->glDeleteTextures)(n, textures);
}

void APIENTRY
glGenTextures(GLsizei n, GLuint *textures)
{
    (*GLTEB_CLTDISPATCHTABLE()->glGenTextures)(n, textures);
}

GLboolean APIENTRY
glIsTexture(GLuint texture)
{
    return (*GLTEB_CLTDISPATCHTABLE()->glIsTexture)(texture);
}

void APIENTRY
glPrioritizeTextures(GLsizei n, const GLuint *textures,
                                      const GLclampf *priorities)
{
    (*GLTEB_CLTDISPATCHTABLE()->glPrioritizeTextures)(n, textures, priorities);
}

void APIENTRY
glTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                 GLsizei width, GLenum format, GLenum type,
                                 const GLvoid *pixels)
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexSubImage1D)(target, level, xoffset, width, format, type, pixels);
}

void APIENTRY
glTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                 GLint yoffset, GLsizei width, GLsizei height,
                                 GLenum format, GLenum type,
                                 const GLvoid *pixels)
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexSubImage2D)(target, level, xoffset, yoffset, width, height, format, type, pixels);
}

void APIENTRY
glArrayElement(GLint i)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glArrayElement)(i);
}

void APIENTRY
glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColorPointer)(size, type, stride, pointer);
}

void APIENTRY
glDisableClientState(GLenum array)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glDisableClientState)(array);
}

void APIENTRY
glDrawArrays(GLenum mode, GLint first, GLsizei count)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glDrawArrays)(mode, first, count);
}

void APIENTRY
glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glDrawElements)(mode, count, type, indices);
}

void APIENTRY
glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEdgeFlagPointer)(stride, pointer);
}

void APIENTRY
glEnableClientState(GLenum array)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEnableClientState)(array);
}

void APIENTRY
glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glIndexPointer)(type, stride, pointer);
}

void APIENTRY
glIndexub(GLubyte c)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glIndexub)(c);
}

void APIENTRY
glIndexubv(const GLubyte *c)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glIndexubv)(c);
}

void APIENTRY
glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glInterleavedArrays)(format, stride, pointer);
}

void APIENTRY
glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glNormalPointer)(type, stride, pointer);
}

void APIENTRY
glPolygonOffset(GLfloat factor, GLfloat units)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glPolygonOffset)(factor, units);
}

void APIENTRY
glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoordPointer)(size, type, stride, pointer);
}

void APIENTRY
glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertexPointer)(size, type, stride, pointer);
}

void APIENTRY
glGetPointerv(GLenum pname, GLvoid* *params)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glGetPointerv)(pname, params);
}

void APIENTRY
glPopClientAttrib(void)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glPopClientAttrib)();
}

void APIENTRY
glPushClientAttrib(IN GLbitfield mask)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glPushClientAttrib)(mask);
}

void APIENTRY
glDrawRangeElementsWIN(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glDrawRangeElementsWIN)(mode, start, end, count, type, indices);
}

void APIENTRY glColorTableEXT( GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *data)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColorTableEXT)(target, internalFormat, width, format, type, data);
}

void APIENTRY glColorSubTableEXT( GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColorSubTableEXT)(target, start, count, format, type, data);
}

void APIENTRY glGetColorTableEXT( GLenum target, GLenum format, GLenum type, GLvoid *data)
{
    (*GLTEB_EXTDISPATCHTABLE()->glGetColorTableEXT)(target, format, type, data);
}

void APIENTRY glGetColorTableParameterivEXT( GLenum target, GLenum pname, GLint *params)
{
    (*GLTEB_EXTDISPATCHTABLE()->glGetColorTableParameterivEXT)(target, pname, params);
}

void APIENTRY glGetColorTableParameterfvEXT( GLenum target, GLenum pname, GLfloat *params)
{
    (*GLTEB_EXTDISPATCHTABLE()->glGetColorTableParameterfvEXT)(target, pname, params);
}

#ifdef GL_WIN_multiple_textures
void APIENTRY glCurrentTextureIndexWIN
    (GLuint index)
{
    (*GLTEB_CLTTDISPATCHTABLE_FAST()->glCurrentTextureIndexWIN)
        (index);
}

void APIENTRY glMultiTexCoord1dWIN
    (GLbitfield mask, GLdouble s)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord1dWIN)
        (mask, s);
}

void APIENTRY glMultiTexCoord1dvWIN
    (GLbitfield mask, const GLdouble *v)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord1dvWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord1fWIN
    (GLbitfield mask, GLfloat s)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMultiTexCoord1fWIN)
        (mask, s);
}

void APIENTRY glMultiTexCoord1fvWIN
    (GLbitfield mask, const GLfloat *v)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMultiTexCoord1fvWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord1iWIN
    (GLbitfield mask, GLint s)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMultiTexCoord1iWIN)
        (mask, s);
}

void APIENTRY glMultiTexCoord1ivWIN
    (GLbitfield mask, const GLint *v)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMultiTexCoord1ivWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord1sWIN
    (GLbitfield mask, GLshort s)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord1sWIN)
        (mask, s);
}

void APIENTRY glMultiTexCoord1svWIN
    (GLbitfield mask, const GLshort *v)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord1svWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord2dWIN
    (GLbitfield mask, GLdouble s, GLdouble t)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord2dWIN)
        (mask, s, t);
}

void APIENTRY glMultiTexCoord2dvWIN
    (GLbitfield mask, const GLdouble *v)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord2dvWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord2fWIN
    (GLbitfield mask, GLfloat s, GLfloat t)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMultiTexCoord2fWIN)
        (mask, s, t);
}

void APIENTRY glMultiTexCoord2fvWIN
    (GLbitfield mask, const GLfloat *v)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMultiTexCoord2fvWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord2iWIN
    (GLbitfield mask, GLint s, GLint t)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMultiTexCoord2iWIN)
        (mask, s, t);
}

void APIENTRY glMultiTexCoord2ivWIN
    (GLbitfield mask, const GLint *v)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMultiTexCoord2ivWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord2sWIN
    (GLbitfield mask, GLshort s, GLshort t)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord2sWIN)
        (mask, s, t);
}

void APIENTRY glMultiTexCoord2svWIN
    (GLbitfield mask, const GLshort *v)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord2svWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord3dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord3dWIN)
        (mask, s, t, r);
}

void APIENTRY glMultiTexCoord3dvWIN
    (GLbitfield mask, const GLdouble *v)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord3dvWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord3fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord3fWIN)
        (mask, s, t, r);
}

void APIENTRY glMultiTexCoord3fvWIN
    (GLbitfield mask, const GLfloat *v)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord3fvWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord3iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord3iWIN)
        (mask, s, t, r);
}

void APIENTRY glMultiTexCoord3ivWIN
    (GLbitfield mask, const GLint *v)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord3ivWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord3sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord3sWIN)
        (mask, s, t, r);
}

void APIENTRY glMultiTexCoord3svWIN
    (GLbitfield mask, const GLshort *v)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord3svWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord4dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord4dWIN)
        (mask, s, t, r, q);
}

void APIENTRY glMultiTexCoord4dvWIN
    (GLbitfield mask, const GLdouble *v)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord4dvWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord4fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord4fWIN)
        (mask, s, t, r, q);
}

void APIENTRY glMultiTexCoord4fvWIN
    (GLbitfield mask, const GLfloat *v)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord4fvWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord4iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r, GLint q)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord4iWIN)
        (mask, s, t, r, q);
}

void APIENTRY glMultiTexCoord4ivWIN
    (GLbitfield mask, const GLint *v)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord4ivWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord4sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r, GLshort q)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord4sWIN)
        (mask, s, t, r, q);
}

void APIENTRY glMultiTexCoord4svWIN
    (GLbitfield mask, const GLshort *v)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord4svWIN)
        (mask, v);
}

void APIENTRY glBindNthTextureWIN
    (GLuint index, GLenum target, GLuint texture)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glBindNthTextureWIN)
        (index, target, texture);
}

void APIENTRY glNthTexCombineFuncWIN
    (GLuint index,
     GLenum leftColorFactor, GLenum colorOp, GLenum rightColorFactor,
     GLenum leftAlphaFactor, GLenum alphaOp, GLenum rightAlphaFactor)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glNthTexCombineFuncWIN)
        (index, leftColorFactor, colorOp, rightColorFactor,
         leftAlphaFactor, alphaOp, rightAlphaFactor);
}
#endif // GL_WIN_multiple_textures
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\glcltgs.c ===
/******************************Module*Header*******************************\
* Module Name: glcltgs.c
*
* Routines to batch function calls and primitives
*
* Copyright (c) 1993-1996 Microsoft Corporation
\**************************************************************************/
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/


/*
 * AUTOMATICALLY UPDATED OR GENERATED BY SGI: DO NOT EDIT
 * IF YOU MUST MODIFY THIS FILE, PLEASE CONTACT ptar@sgi.com 415-390-1483
 */

#include "precomp.h"
#pragma hdrstop

/* Generic OpenGL Client using subbatching. */
#include <string.h>

#include "imports.h"
#include "types.h"

#include "glsbmsg.h"
#include "glsbmsgh.h"
#include "glsrvspt.h"

#include "subbatch.h"
#include "batchinf.h"
#include "glteb.h"
#include "glsbcltu.h"
#include "glclt.h"
#include "compsize.h"
#include "context.h"
#include "global.h"
#include "parray.h"
#include "glarray.h"
#include "lighting.h"
#include "imfuncs.h"
#include "..\dlist\dlistopt.h"

#ifdef NEW_PARTIAL_PRIM

// Vertex flags that should be propagated to polyarray flags
//
#define VERTEX_FLAGS_FOR_POLYARRAY (POLYDATA_VERTEX2 | POLYDATA_VERTEX3 | \
                                    POLYDATA_VERTEX4)

#define VERTEX_MATERIAL(pm, pa, pd) (pm->pdMaterial0[pd - pa->pdBuffer0])

PDMATERIAL* FASTCALL GetVertexMaterial(POLYARRAY *pa, POLYDATA *pd)
{
    POLYMATERIAL *pm = GLTEB_CLTPOLYMATERIAL();
    if (!pm)
    {
        PAMatAlloc();
        pm = GLTEB_CLTPOLYMATERIAL();
        if (!pm)
            return NULL;
    }
    return &VERTEX_MATERIAL(pm, pa, pd);
}
//------------------------------------------------------------------------
// Assumes that POLYMATERIAL structure is valid
//
PDMATERIAL* FASTCALL GetVertexMaterialSafe(POLYARRAY *pa, POLYDATA *pd)
{
    POLYMATERIAL *pm = GLTEB_CLTPOLYMATERIAL();
    return &VERTEX_MATERIAL(pm, pa, pd);
}
//------------------------------------------------------------------------
// Copy material changes from src to pd material
//
void FASTCALL SetVertexMaterial(POLYARRAY *pa, 
                                POLYDATA *pd, 
                                __GLmatChange *src, 
                                GLint faceOrientation)
{
    __GLmatChange *pdMat;
    PDMATERIAL    *mat;

   // Get POLYMATERIAL pointer after PAMatAlloc!
    mat = GetVertexMaterial(pa, pd);
    if (!mat) 
        return;
    if (faceOrientation == __GL_FRONTFACE)
    {
       mat->front = PAMatAlloc();
       if (!mat->front)
           return;
       pdMat = mat->front;
    }
    else
    {
       mat->back = PAMatAlloc();
       pdMat = mat->back;
    }
    if (pdMat)
        *pdMat = *src;
}
//-----------------------------------------------------------------------------
// Save shared vertex for a partial primitive
//
// We have to save all data applicapable for vertex (all data that can be inside 
// BEGIN END brackets): flags, color, texture, normal, coordinate, material, edge flag. 
// We do not save evaluator data, because it was processed earlier.
//
void SaveSharedVertex(SAVEREGION *dst, POLYDATA *src, POLYARRAY *pa)
{                
    dst->pd.flags = src->flags;       
    dst->pd.obj = src->obj;         
    if (src->flags & POLYDATA_TEXTURE_VALID)  
        dst->pd.texture = src->texture;    
    if (src->flags & POLYDATA_NORMAL_VALID)   
        dst->pd.normal = src->normal;     
    if (src->flags & POLYDATA_COLOR_VALID)    
        dst->pd.colors[0] = src->colors[0];
    if (src->flags & POLYDATA_MATERIAL_FRONT)
        dst->front = *(GetVertexMaterial(pa, src)->front);
    if (src->flags & POLYDATA_MATERIAL_BACK)
        dst->back = *(GetVertexMaterial(pa, src)->back);
}
//
// dst  - POLYDATA
// src  - SAVEREGION
// pa   - POLYARRAY
//
#define RESTOREMATERIAL(dst, src, pa)                                   \
    if (dst->flags & POLYDATA_MATERIAL_FRONT)                           \
    {                                                                   \
        SetVertexMaterial(pa, dst, &src->front, __GL_FRONTFACE);        \
    }                                                                   \
    if (dst->flags & POLYDATA_MATERIAL_BACK)                            \
    {                                                                   \
        SetVertexMaterial(pa, dst, &src->back, __GL_BACKFACE);          \
    }
// Restore shared vertex for a partial primitive
//
// We have to restore all data applicapable for vertex (all data that can be inside 
// BEGIN END brackets): flags, color, texture, normal, coordinate, material, edge flag. 
// We do not restore evaluator data, because it was processed earlier.
// We must update POLYARRAY flags and current color, normal, edge flag, texture pointers.
// We also must intitialize flags for a next vertex.
//
void RestoreSharedVertex(POLYDATA *dst, SAVEREGION *src, POLYARRAY *pa)               
{
    dst->flags = src->pd.flags;            
    dst->obj = src->pd.obj;              
    if (dst->flags & POLYDATA_TEXTURE_VALID)   
    {                                            
        dst->texture = src->pd.texture;      
        if (src->pd.flags & POLYDATA_EVAL_TEXCOORD)
            pa->pdLastEvalTexture = dst;
        else
            pa->pdCurTexture = dst;                
    }                                            
    if (dst->flags & POLYDATA_NORMAL_VALID)    
    {                                            
        dst->normal = src->pd.normal;       
        if (src->pd.flags & POLYDATA_EVAL_NORMAL)
            pa->pdLastEvalNormal = dst;
        else
            pa->pdCurNormal = dst;               
    }                                            
    if (dst->flags & POLYDATA_COLOR_VALID)     
    {                                            
        dst->colors[0] = src->pd.colors[0];    
        if (src->pd.flags & POLYDATA_EVAL_COLOR)
            pa->pdLastEvalColor = dst;
        else
            pa->pdCurColor = dst;                  
    }                                            
    if (dst->flags & POLYDATA_EDGEFLAG_VALID)  
        pa->pdCurEdgeFlag = dst;               

    RESTOREMATERIAL(dst, src, pa);
    
    pa->flags |= (dst->flags & VERTEX_FLAGS_FOR_POLYARRAY);
    (dst+1)->flags = 0;     // Initialize flag for a next vertex
}
//------------------------------------------------------------------------------
// Copy data from Graphics Context
//
void FASTCALL CopyColorFromGC(__GLcontext *gc, POLYARRAY *pa, POLYDATA *pd)
{
    __GLcolor scaledUserColor;

    pd->flags |= POLYDATA_COLOR_VALID;
    if (!gc->modes.colorIndexMode) 
    {
        __GL_SCALE_AND_CHECK_CLAMP_RGBA(scaledUserColor.r,
                                        scaledUserColor.g,
                                        scaledUserColor.b,
                                        scaledUserColor.a,
                                        gc, pa->flags,
                                        gc->state.current.userColor.r,
                                        gc->state.current.userColor.g,
                                        gc->state.current.userColor.b,
                                        gc->state.current.userColor.a);
    } 
    else 
    {
        __GL_CHECK_CLAMP_CI(scaledUserColor.r, gc, pa->flags, 
                            gc->state.current.userColorIndex);
    }
    pd->colors[0] = scaledUserColor;
}

void FASTCALL CopyTextureFromGC(__GLcontext *gc, POLYARRAY *pa, POLYDATA *pd)
{
    pd->flags |= POLYDATA_TEXTURE_VALID;
    pd->texture = gc->state.current.texture;

    if (__GL_FLOAT_COMPARE_PONE(pd->texture.w, !=))
        pa->flags |= POLYARRAY_TEXTURE4;
    else if (__GL_FLOAT_NEZ(pd->texture.z))
        pa->flags |= POLYARRAY_TEXTURE3;
    else if (__GL_FLOAT_NEZ(pd->texture.y))
        pa->flags |= POLYARRAY_TEXTURE2;
    else
        pa->flags |= POLYARRAY_TEXTURE1;
}

void FASTCALL CopyEdgeFlagFromGC(__GLcontext *gc, POLYDATA *pd)
{
    pd->flags |= POLYDATA_EDGEFLAG_VALID;
    if (gc->state.current.edgeTag)
        pd->flags |= POLYDATA_EDGEFLAG_BOUNDARY;
}

void FASTCALL CopyNormalFromGC(__GLcontext *gc, POLYDATA *pd)
{
    pd->flags |= POLYDATA_NORMAL_VALID;
    pd->normal = gc->state.current.normal;
}
//-------------------------------------------------------------------------------
// Copy material state corresponding to changeBits from GC to mat.
// face defines front or back material to use.
//
void FASTCALL CopyMaterialFromGC(__GLcontext *gc, __GLmatChange *mat, 
                                 GLuint changeBits, GLint face)
{
    __GLmaterialState *ms;

    ms = &gc->state.light.front;
    if (face != __GL_FRONTFACE)
        ms = &gc->state.light.back;
     
    // Take data from graphics context

    if (changeBits & __GL_MATERIAL_AMBIENT)
        mat->ambient = ms->ambient;

    if (changeBits & __GL_MATERIAL_DIFFUSE)
        mat->diffuse = ms->diffuse;

    if (changeBits & __GL_MATERIAL_SPECULAR)
        mat->specular = ms->specular;

    if (changeBits & __GL_MATERIAL_EMISSIVE)
    {
        mat->emissive.r = ms->emissive.r * gc->oneOverRedVertexScale;   
        mat->emissive.g = ms->emissive.g * gc->oneOverGreenVertexScale;   
        mat->emissive.b = ms->emissive.b * gc->oneOverBlueVertexScale;    
        mat->emissive.a = ms->emissive.a * gc->oneOverAlphaVertexScale;   
    }

    if (changeBits & __GL_MATERIAL_SHININESS)
         mat->shininess = ms->specularExponent;

    if (changeBits & __GL_MATERIAL_COLORINDEXES)
    {
        mat->cmapa = ms->cmapa;
        mat->cmapd = ms->cmapd;
        mat->cmaps = ms->cmaps;
    }
}
//-------------------------------------------------------------------------------
// Compute complete vertex state to restore state modified by pdLast vertex.
//
// We have to preserve the following state for a vertex:
// - normal
// - texture
// - color
// - edge flag
// - material
//
// Input:
//  dst     - where to copy vertex state
//  pdStart - we go from this vertex to the beginning of a polyarray to find 
//            material changes
//  pdLast  - we have to update vertex state only if the state is changed by 
//            this vertex
//
void FASTCALL UpdateVertexState(__GLcontext *gc, 
                                POLYARRAY   *pa, 
                                SAVEREGION  *dst, 
                                POLYDATA    *pdStart,
                                POLYDATA    *pdLast)
{
    GLuint flags = dst->pd.flags;
    GLuint flagsLast = pdLast ? pdLast->flags : 0xFFFFFFFF;
    POLYDATA *pd0 = pa->pd0;

    ASSERTOPENGL(pdStart >= pd0, "Infinite loop possible!");

    // If last vertex changes normal we have to find nearest previous normal
    // and propagate it to the dst
    if (flagsLast & POLYDATA_NORMAL_VALID && !(flags & POLYDATA_NORMAL_VALID))
    {
        POLYDATA *pd;
        // Find nearest normal
        for (pd = pdStart; pd >= pd0; pd--)
        {
            if (pd->flags & POLYDATA_NORMAL_VALID && 
                !(pd->flags & POLYDATA_EVAL_NORMAL))
                break;
        }
        flags |= POLYDATA_NORMAL_VALID;
        if (pd < pd0)
            //  We have not found any normal, so take value from graphics state
            CopyNormalFromGC(gc, &dst->pd);
        else
            dst->pd.normal = pd->normal;
    }

    // If last vertex changes texture we have to find nearest previous texture
    // and propagate it to the dst
    if (flagsLast & POLYDATA_TEXTURE_VALID && !(flags & POLYDATA_TEXTURE_VALID))
    {
        POLYDATA *pd;
        // Find latest texture
        for (pd = pdStart; pd >= pd0; pd--)
        {
            if (pd->flags & POLYDATA_TEXTURE_VALID && 
                !(pd->flags & POLYDATA_EVAL_TEXCOORD))
                break;
        }
        flags |= POLYDATA_TEXTURE_VALID;
        if (pd < pd0)
            //  We have not found any vertex, so take value from graphics state
            CopyTextureFromGC(gc, pa, &dst->pd);
        else
            dst->pd.texture = pd->texture;
    }

    // If last vertex changes color we have to find nearest previous color
    // and propagate it to the dst
    if (flagsLast & POLYDATA_COLOR_VALID && !(flags & POLYDATA_COLOR_VALID))
    {
        POLYDATA *pd;
        // Find latest color
        for (pd = pdStart; pd >= pd0; pd--)
        {
            if (pd->flags & POLYDATA_COLOR_VALID && 
                !(pd->flags & POLYDATA_EVAL_COLOR))
                break;
        }
        flags |= POLYDATA_COLOR_VALID;
        if (pd < pd0)
            //  We have not found any vertex, so take value from graphics state
            CopyColorFromGC(gc, pa, &dst->pd);
        else
            dst->pd.colors[0] = pd->colors[0];
    }

    if (flagsLast & POLYDATA_EDGEFLAG_VALID && !(flags & POLYDATA_EDGEFLAG_VALID))
    {
        POLYDATA *pd;
        // Find latest edge flag
        for (pd = pdStart; pd >= pd0; pd--)
        {
            if (pd->flags & POLYDATA_EDGEFLAG_VALID)
                break;
        }
        flags |= POLYDATA_EDGEFLAG_VALID;
        if (pd < pd0)
        { 
            //  We have not found any vertex, so take value from graphics state
            if (gc->state.current.edgeTag)
                flags |= POLYDATA_EDGEFLAG_BOUNDARY;
        }
        else
            flags |= (pd->flags & POLYDATA_EDGEFLAG_BOUNDARY);
    }

    dst->pd.flags |= flags;

    // Now we have to update material state

    if (pdLast->flags & (POLYARRAY_MATERIAL_FRONT | POLYARRAY_MATERIAL_BACK))
    {
        // We have to compute material state for pdLast1, because after the primitive is
        // processed, current material state will have changes from pdLast2 vertex.

        __GLmatChange *mat;
        __GLmatChange *pdMatLast;
        POLYDATA      *pd;
        GLint         face;
        GLuint        matMask;
        GLuint        changeBits;

        for (face = __GL_BACKFACE, matMask = POLYARRAY_MATERIAL_BACK;
              face >= 0;
              face--, matMask = POLYARRAY_MATERIAL_FRONT
             )
        {
            if (!(pa->flags & matMask))
                continue;

            // Only reset material data changed by pdLast
            if (face == __GL_FRONTFACE)
            {
                pdMatLast = GetVertexMaterial(pa, pdLast)->front;
                changeBits = pdMatLast->dirtyBits;
                mat  = &dst->front;
                // Don't modify color materials if they are in effect!
                changeBits &= ~gc->light.front.colorMaterialChange;
            }
            else
            {
                pdMatLast = GetVertexMaterial(pa, pdLast)->back;
                changeBits = pdMatLast->dirtyBits;
                mat  = &dst->back;
                // Don't modify color materials if they are in effect!
                changeBits &= ~gc->light.back.colorMaterialChange;
            }

            // Don't modify material settings used by this vertex
            changeBits &= ~mat->dirtyBits;

            if (!changeBits) 
                continue;   

            mat->dirtyBits |= changeBits;

            // Apply changes from vertices
            // We go backwards and apply the latest change
            for (pd = pdStart; pd >= pd0; pd--)
            {
                __GLmatChange *pdMat;
                GLuint dirtyBits;
                if (pd->flags & matMask)
                {
                    GLuint dirtyBits;
              
                    pdMat = GetVertexMaterial(pa, pd)->front + face;
                    dirtyBits  = pdMat->dirtyBits & changeBits;

                    if (!dirtyBits) 
                        continue;

                    if (dirtyBits & __GL_MATERIAL_AMBIENT)
                    {
                        mat->ambient = pdMat->ambient;
                    }
              
                    if (dirtyBits & __GL_MATERIAL_DIFFUSE)
                    {
                        mat->diffuse = pdMat->diffuse;
                    }

                    if (dirtyBits & __GL_MATERIAL_SPECULAR)
                    {
                        mat->specular = pdMat->specular;
                    }
              
                    if (dirtyBits & __GL_MATERIAL_EMISSIVE)
                    {
                        mat->emissive = pdMat->emissive;
                    }
              
                    if (dirtyBits & __GL_MATERIAL_SHININESS)
                    {
                        mat->shininess = pdMat->shininess;
                    }

                    if (dirtyBits & __GL_MATERIAL_COLORINDEXES)
                    {
                        mat->cmapa = pdMat->cmapa;
                        mat->cmapd = pdMat->cmapd;
                        mat->cmaps = pdMat->cmaps;
                    }

                    // Clear processed bits
                    changeBits &= ~dirtyBits;

                    if (!changeBits)
                        break;
                }
            }

            if (changeBits)
                CopyMaterialFromGC (gc, mat, changeBits, face);

            dst->pd.flags |= matMask;
        }
    }
}
//-------------------------------------------------------------------------------------
// Propagate vertex state from GC to the vertex.
//
// Already set vertex data should be preserved.
//
void FASTCALL UpdateVertexStateUsingGC(__GLcontext *gc, POLYARRAY *pa, SAVEREGION *dst)
{ 
    POLYDATA * const pd = &dst->pd;
    if (!(pd->flags & POLYDATA_NORMAL_VALID))
        CopyNormalFromGC(gc, pd);

    if (!(pd->flags & POLYDATA_TEXTURE_VALID))
        CopyTextureFromGC(gc, pa, pd);

    if (!(pd->flags & POLYDATA_COLOR_VALID))
        CopyColorFromGC(gc, pa, pd);

    if (!(pd->flags & POLYDATA_EDGEFLAG_VALID))
        CopyEdgeFlagFromGC(gc, pd);

    if (pa->flags & (POLYARRAY_MATERIAL_FRONT | POLYARRAY_MATERIAL_BACK))
    {
        // Compute material state for the vertex, using GC
        // Do not override material changes in the vertex

        __GLmatChange *mat;
        GLint         face;
        GLuint        matMask;
        GLuint        changeBits;

        for (face = __GL_BACKFACE, matMask = POLYARRAY_MATERIAL_BACK;
              face >= 0;
              face--, matMask = POLYARRAY_MATERIAL_FRONT
             )
        {
            GLuint  dirtyBits;
            if (!(pa->flags & matMask))
                continue;

            // Don't modify color materials if they are in effect or if they are set 
            // by pdFirst!

            changeBits = 0xFFFFFFFF;
            if (face == __GL_FRONTFACE)
            {
                if (pd->flags & matMask)
                    changeBits &= ~dst->front.dirtyBits;

                changeBits &= ~gc->light.front.colorMaterialChange;
                mat = &dst->front;
            }
            else
            {
                if (pd->flags & matMask)
                    changeBits &= ~dst->back.dirtyBits;
                changeBits  = ~gc->light.back.colorMaterialChange;
                mat = &dst->back;
            }

            // Apply changes from vertices
            // We go backwards and remember the latest change

            if (changeBits)
            {
                CopyMaterialFromGC (gc, mat, changeBits, face);
                // Update changes for the vertex
                pd->flags |= matMask;
                mat->dirtyBits |= changeBits;
            }

        }
    }
}
#endif // NEW_PARTIAL_PRIM

//
// extension apis these are not exported
//

void APIENTRY
glAddSwapHintRectWIN(IN GLint x, IN GLint y, IN GLint width, IN GLint height)
{
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL || plrc->dhrc != 0) {
        // this api should only be called if there is a generic rc
        // currently selected.
        return;
    }

    GLCLIENT_BEGIN( AddSwapHintRectWIN, ADDSWAPHINTRECTWIN )
        pMsg->xs = x;
        pMsg->ys = y;
        pMsg->xe = x + width;
        pMsg->ye = y + height;
    return;
    GLCLIENT_END
}

#ifdef PRIMITIVE_TRACK
static ULONG prim_entries;
static ULONG prim_total = 0;
static ULONG prim_count = 0;
#endif

// Polyarray begin flags.  Reset line stipple for new line loop,
// line strip, and polygon.
// Assume that all vertices have the same color.
GLuint aPolyArrayBeginFlags[] =
{
    POLYARRAY_IN_BEGIN | POLYARRAY_SAME_COLOR_DATA, // GL_POINTS
    POLYARRAY_IN_BEGIN | POLYARRAY_SAME_COLOR_DATA, // GL_LINES
    POLYARRAY_IN_BEGIN | POLYARRAY_SAME_COLOR_DATA | POLYARRAY_RESET_STIPPLE, // GL_LINE_LOOP
    POLYARRAY_IN_BEGIN | POLYARRAY_SAME_COLOR_DATA | POLYARRAY_RESET_STIPPLE, // GL_LINE_STRIP
    POLYARRAY_IN_BEGIN | POLYARRAY_SAME_COLOR_DATA, // GL_TRIANGLES
    POLYARRAY_IN_BEGIN | POLYARRAY_SAME_COLOR_DATA, // GL_TRIANGLE_STRIP
    POLYARRAY_IN_BEGIN | POLYARRAY_SAME_COLOR_DATA, // GL_TRIANGLE_FAN
    POLYARRAY_IN_BEGIN | POLYARRAY_SAME_COLOR_DATA, // GL_QUADS
    POLYARRAY_IN_BEGIN | POLYARRAY_SAME_COLOR_DATA, // GL_QUAD_STRIP
    POLYARRAY_IN_BEGIN | POLYARRAY_SAME_COLOR_DATA | POLYARRAY_RESET_STIPPLE  // GL_POLYGON
};

// If you modify this function, you need to also modify VA_DrawElementsBegin.
void APIENTRY
glcltBegin ( IN GLenum mode )
{
    POLYARRAY *pa;
    POLYDATA  *pd0, *pdFlush;
    GLMSG_DRAWPOLYARRAY *pMsgDrawPolyArray;
    __GL_SETUP();
    DWORD flags = GET_EVALSTATE (gc);


    // The invalid functions within begin/end are detected in glsbAttention.

    pa = GLTEB_CLTPOLYARRAY();

    // The vertex buffer is used as follows.  The first entry contains the
    // POLYARRAY structure.  The incoming vertices will be saved beginning
    // at a following entry.  As an optimization, the POLYARRAY structure is
    // kept in the TEB.  When glEnd is called, it will be copied to the
    // vertex buffer.

#ifndef _WIN95_
    ASSERTOPENGL(sizeof(POLYARRAY) <= sizeof(NtCurrentTeb()->glReserved1),
       "POLYARRAY and TEB sizes mismatch!");
#endif

    ASSERTOPENGL(sizeof(POLYDATA) == sizeof(__GLvertex),
       "POLYDATA and __GLvertex sizes mismatch!");

    ASSERTOPENGL(sizeof(POLYARRAY) <= sizeof(POLYDATA),
       "POLYARRAY and POLYDATA sizes mismatch!");

    // Keep vertex structure a multiple of 4 bytes (or 8 bytes).
    // The vertex buffer must be 4-byte aligned.

    ASSERTOPENGL(!(sizeof(POLYDATA) & 0x3), "bad POLYDATA size!");
    ASSERTOPENGL(!((ULONG_PTR)pa->pdBuffer0 & 0x3), "POLYDATA should be aligned!\n");

    // If we are already in the begin/end bracket, return an error.

    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    if ((GLuint) mode > GL_POLYGON)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

	// if there are any pending API calls that affect the Evaluator state
    // then flush the message buffer

    if (flags & (__EVALS_AFFECTS_ALL_EVAL|
                 __EVALS_AFFECTS_1D_EVAL|
                 __EVALS_AFFECTS_2D_EVAL))
        glsbAttention ();

    // Flush the command buffer if the vertex buffer is nearly full.
    // Otherwise, just continue with the next available vertex buffer entry.

    if (pa->pdBufferNext > pa->pdBufferMax - MIN_POLYDATA_BATCH_SIZE)
    {
#ifdef PRIMITIVE_TRACK
        DbgPrint("* Min-not-present flush\n");
#endif
        glsbAttention();	// it resets pdBufferNext pointer too

        ASSERTOPENGL(pa->nextMsgOffset == PA_nextMsgOffset_RESET_VALUE, 
                 "bad nextMsgOffset\n");
    }

    // Batch POLYARRAY command in the command buffer.
    // We want to leave enough room to accomodate at least one invalid command
    // that may be batched in the begin/end bracket.  When glsbAttention,
    // glsbAttentionAlt, or glcltEnd is called, we will remove these invalid
    // commands.
    //
    // Combine adjacent DrawPolyArray commands into one command.

    // request DRAWPOLYARRAY_LARGE structure to make room for invalid commands
    GLCLIENT_BEGIN(DrawPolyArray, DRAWPOLYARRAY_LARGE)
    // need msg pointer to update pa later
    pMsgDrawPolyArray = (GLMSG_DRAWPOLYARRAY *) pMsg;

	if (pa->nextMsgOffset == CurrentOffset)
	{
	    // rewind command buffer pointer
	    pMsgBatchInfo->NextOffset = CurrentOffset;
	    ((BYTE *) pMsgDrawPolyArray) -= 
		 GLMSG_ALIGN(sizeof(GLMSG_DRAWPOLYARRAY));

	    // chain adjacent DrawPolyArray commands
	    ((POLYARRAY *) pMsgDrawPolyArray->paLast)->paNext
		= (POLYARRAY *) pa->pdBufferNext;
	    ((POLYARRAY *) pMsgDrawPolyArray->paLast)
		= (POLYARRAY *) pa->pdBufferNext;
	}
	else
	{
	    // resize the msg to the real size
	    pMsgBatchInfo->NextOffset = CurrentOffset
		+ GLMSG_ALIGN(sizeof(GLMSG_DRAWPOLYARRAY));

	    // remember the end of the primitive command
	    pa->nextMsgOffset = pMsgBatchInfo->NextOffset;

	    // start of a new chain
	    pMsgDrawPolyArray->pa0    =
	    pMsgDrawPolyArray->paLast = (PVOID) pa->pdBufferNext;
	}
    GLCLIENT_END


// Compute the start of the primitive.  A new primitive always begins with a
// POLYARRAY entry immediately followed by vertex entries.

    pd0 = pa->pdBufferNext + 1;

    // Initialize first polydata.

    pd0->flags = 0;

    ASSERTOPENGL(pd0->color == &pd0->colors[__GL_FRONTFACE],
                 "bad color pointer!\n");
    
    // Initialize the polyarray structure in the TEB.

    pa->flags         = aPolyArrayBeginFlags[mode];
    pa->pdNextVertex  =
    pa->pd0           = pd0;
    pa->primType      = mode;
    pa->pdCurColor    =	
    pa->pdCurNormal   =	
    pa->pdCurTexture  =	
    pa->pdCurEdgeFlag =	NULL;
    pa->paNext        = NULL;
    pa->nIndices      = 0;
    pa->aIndices      = NULL;	// identity mapping
    pa->pdLastEvalColor   =
    pa->pdLastEvalNormal  =
    pa->pdLastEvalTexture = NULL;
           
    // Compute the flush vertex for this primitive.  When the flush vertex is
    // reached, we will have accumulated enough vertices to render a partially
    // composed primitive.

    pdFlush = pa->pdBufferMax;
    switch (mode)
    {
      case GL_POINTS:
      case GL_LINE_STRIP:
      case GL_TRIANGLE_FAN:
        break;
      case GL_LINE_LOOP:
        // Line loop reserves an additional end vertex to close the loop.
        pdFlush--;
        break;
      case GL_POLYGON:
        // The polygon decomposer can only handle up to
        // __GL_MAX_POLYGON_CLIP_SIZE vertices.
        if (pdFlush > pd0 + __GL_MAX_POLYGON_CLIP_SIZE - 1)
	    pdFlush = pd0 + __GL_MAX_POLYGON_CLIP_SIZE - 1;
        break;
      case GL_LINES:
      case GL_TRIANGLE_STRIP:
      case GL_QUAD_STRIP:
        // number of vertices must be a multiple of 2
        if ((pdFlush - pd0 + 1) % 2)
            pdFlush--;
        break;
      case GL_TRIANGLES:
        // number of vertices must be a multiple of 3
        switch ((pdFlush - pd0 + 1) % 3)
        {
          case 2: pdFlush--;        // fall through
          case 1: pdFlush--;
        }
        break;
      case GL_QUADS:
        // number of vertices must be a multiple of 4
        switch ((pdFlush - pd0 + 1) % 4)
        {
          case 3: pdFlush--;        // fall through
          case 2: pdFlush--;        // fall through
          case 1: pdFlush--;
        }
        break;
    }
    pa->pdFlush = pdFlush;

#ifdef PRIMITIVE_TRACK
    DbgPrint("glcltBegin with %3d space left\n", pdFlush-pd0+1);
    prim_entries = 0;
#endif
}

// Special version of Begin for DrawElements.
// If you modify this function, you need to also modify glcltBegin.
void FASTCALL VA_DrawElementsBegin(POLYARRAY *pa, GLenum mode, GLsizei count)
{
    POLYDATA  *pd0;
    GLMSG_DRAWPOLYARRAY *pMsgDrawPolyArray;
    GLint     maxVertexCount;

    // The vertex buffer is used as follows.  The first entry contains the
    // POLYARRAY structure.  The incoming vertices will be saved beginning
    // at a following entry.  As an optimization, the POLYARRAY structure is
    // kept in the TEB.  When VA_DrawElementsEnd is called, it will be copied
    // to the vertex buffer.

    // We don't handle Points, Line Loop, and Polygon here.  They should
    // have been sent to Begin/End.

    ASSERTOPENGL(mode != GL_POINTS && mode != GL_LINE_LOOP && mode != GL_POLYGON,
    "Primitive type not handled\n");

    // Flush the command buffer if the vertex buffer will overflow.
    // Otherwise, just continue with the next available vertex buffer entry.

    // Maximum number of vertex entries that we will handle in next batch
    maxVertexCount = min(count,VA_DRAWELEM_MAP_SIZE)
    // Add maximum number of entries used for index map
    + (VA_DRAWELEM_INDEX_SIZE + sizeof(POLYDATA) - 1) / sizeof(POLYDATA)
    // Reserve an extra vertex entry to prevent calling
    // PolyArrayFlushPartialPrimitive in the Vertex routines.
    // It should call VA_DrawElementsFlushPartialPrimitive instead.
    + 1
    // Add an entry for POLYARRAY
    + 1
    // Add a few more entries to be safe
    + 4;

    if (pa->pdBufferNext > pa->pdBufferMax - maxVertexCount + 1)
    {
#ifdef PRIMITIVE_TRACK
        DbgPrint("* Min-not-present flush\n");
#endif
        glsbAttention();    // it resets pdBufferNext pointer too

        ASSERTOPENGL(pa->nextMsgOffset == PA_nextMsgOffset_RESET_VALUE, 
                     "bad nextMsgOffset\n");
    }

    // The vertex buffer must have at least maxVertexCount (currently <= 277)
    // entries.
    ASSERTOPENGL(maxVertexCount <= pa->pdBufferMax - pa->pdBuffer0 + 1,
    "vertex buffer is too small!\n");

    // Batch POLYARRAY command in the command buffer.
    // Combine adjacent DrawPolyArray commands into one command.

    GLCLIENT_BEGIN(DrawPolyArray, DRAWPOLYARRAY)
    // need msg pointer to update pa later
    pMsgDrawPolyArray = pMsg;

    if (pa->nextMsgOffset == CurrentOffset)
    {
        // rewind command buffer pointer
        pMsgBatchInfo->NextOffset = CurrentOffset;
        ((BYTE *) pMsgDrawPolyArray) -= 
         GLMSG_ALIGN(sizeof(GLMSG_DRAWPOLYARRAY));

        // chain adjacent DrawPolyArray commands
        ((POLYARRAY *) pMsgDrawPolyArray->paLast)->paNext
        = (POLYARRAY *) pa->pdBufferNext;
        ((POLYARRAY *) pMsgDrawPolyArray->paLast)
        = (POLYARRAY *) pa->pdBufferNext;
    }
    else
    {
        // remember the end of the primitive command
        pa->nextMsgOffset = pMsgBatchInfo->NextOffset;

        // start of a new chain
        pMsgDrawPolyArray->pa0    =
        pMsgDrawPolyArray->paLast = (PVOID) pa->pdBufferNext;
    }
    GLCLIENT_END


// Compute the start of the primitive.  A new primitive always begins with a
// POLYARRAY entry immediately followed by vertex entries.

    pd0 = pa->pdBufferNext + 1;

    // Initialize first polydata.

    pd0->flags = 0;
    
    ASSERTOPENGL(pd0->color == &pd0->colors[__GL_FRONTFACE],
                 "bad color pointer!\n");
    
    // Initialize the polyarray structure in the TEB.

    pa->flags         = aPolyArrayBeginFlags[mode] | POLYARRAY_SAME_POLYDATA_TYPE;
    pa->pdNextVertex  =
    pa->pd0           = pd0;
    pa->primType      = mode;
    pa->pdCurColor    =
    pa->pdCurNormal   =
    pa->pdCurTexture  =
    pa->pdCurEdgeFlag = NULL;
    pa->paNext        = NULL;
    pa->nIndices      = 0;
    pa->aIndices      = PA_aIndices_INITIAL_VALUE; // this is updated in End

    // For consistency
    pa->pdLastEvalColor    =
    pa->pdLastEvalNormal   =
    pa->pdLastEvalTexture  = NULL;

// The flush vertex for this primitive should never be reached.  We have
// reserved enough room for a vertex batch.  Set it to maximum and assert
// that we never reach the vertex in PolyArrayFlushPartialPrimitive!

    pa->pdFlush = pa->pdBufferMax;

#ifdef PRIMITIVE_TRACK
    DbgPrint("VA_DrawElementsBegin with %3d space left\n", pa->pdBufferMax-pd0+1);
#endif
    return;
}

void APIENTRY
glcltEnd ( void )
{
    POLYARRAY *pa;
    GLMSG_DRAWPOLYARRAY *pMsgDrawPolyArray;

#ifdef NEW_PARTIAL_PRIM
    __GL_SETUP();
    pa = gc->paTeb;
#else
    pa = GLTEB_CLTPOLYARRAY();
#endif

// Flush invalid commands accumulated in the command buffer if there is any.

    glsbAttention();

    // If we are not in the begin/end bracket, return an error.

    if (!(pa->flags & POLYARRAY_IN_BEGIN))
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    // Clear the POLYARRAY_IN_BEGIN flag in the TEB.  We are now out of
    // the begin/end bracket.

    pa->flags &= ~POLYARRAY_IN_BEGIN;

    // Clear POLYARRAY_SAME_COLOR_DATA flag if the primitive uses more than
    // one color.  Also clear the flag if an evaluator is used.  We cannot
    // tell if an evaluator modifies the color on the client side.

    // If there are evaluator calls in this polyarray that also generate
    // color, then too, remove the POLYARRAY_SAME_COLOR_DATA flag

    if ((pa->pdCurColor != pa->pd0) ||
        ((pa->pd0->flags & POLYDATA_COLOR_VALID) &&
         (pa->flags & POLYARRAY_PARTIAL_BEGIN)) || 
        (pa->pdLastEvalColor != NULL))
        pa->flags &= ~POLYARRAY_SAME_COLOR_DATA;

    // Compute nIndices.  It is the final number of vertices passed to the low
    // level render routines and is different from the number of polydata's
    // accumulated.  The final number includes the reserved vertices and the
    // accumulated vertices.

    pa->nIndices += (GLint)((ULONG_PTR)(pa->pdNextVertex - pa->pd0));
    /*
    // If there are no vertices and no attributes to propagate to a next 
    // primitive, we can remove this polyarray from the batch
    if (pa->nIndices == 0 && pa->pdNextVertex->flags == 0)
        return;
        */

#ifdef NEW_PARTIAL_PRIM
    if (pa->primType == GL_LINE_LOOP)
    {
        if (pa->nIndices > 1)
        {
        // We have to add an additional vertex at the end. It could be
        //   - saved vertex if primitive is partial begin OR 
        //   - first vertex
        // We will change primitive type to GL_LINE_STRIP after we update 
        // current color, normal, texture, edge flag in __glim_DrawPolyArray
        //
            POLYDATA   *pd = pa->pdNextVertex++;
            SAVEREGION firstVertex;
            SAVEREGION lastVertex;
            SAVEREGION *reg;
            // We have to propagate vertex state for next primitive before we 
            // insert the vertex.

            pa->nIndices++;  
            if (pa->flags & POLYARRAY_PARTIAL_BEGIN)
            { // This is partial primitive
                reg = &gc->vertex.regSaved;
            }
            else
            { // This is non partial primitive
                SaveSharedVertex(&firstVertex, pa->pd0, pa);
                reg = &firstVertex;
            }
            // Save pdNextVertex before we override it
            SaveSharedVertex(&lastVertex, pd, pa);      
            // Insert first vertex at the end
            RestoreSharedVertex(pd, reg, pa); 
            // Compute state for last vertex, because we have to override 
            // changes made by first vertex.
            UpdateVertexState(gc, pa, &lastVertex, pd-1, pd);
            // pdNextVertex will have state for a next primitive
            RestoreSharedVertex(pa->pdNextVertex, &lastVertex, pa);
        }

        pa->primType = GL_LINE_STRIP;
    }
#else // NEW_PARTIAL_PRIM
    if (pa->primType == GL_LINE_LOOP)
        pa->nIndices++;     // add one extra vertex when a line loop is closed.
                            // It's okay not to advance pdBufferNext since we
                            // don't need attributes after they've been
                            // processed.
#endif // NEWFLUSH

    // Save the POLYARRAY structure in the batch.

    pMsgDrawPolyArray = (GLMSG_DRAWPOLYARRAY *)
    ((BYTE *) pa->pMsgBatchInfo + pa->nextMsgOffset -
         GLMSG_ALIGN(sizeof(GLMSG_DRAWPOLYARRAY)));
    *(POLYARRAY *) pMsgDrawPolyArray->paLast = *pa;

#ifdef PRIMITIVE_TRACK
    prim_entries += pa->pdNextVertex-pa->pd0;
    prim_total += prim_entries;
    prim_count++;
    DbgPrint("glcltEnd   with %3d polydata entries, %3d now, avg %d\n",
         prim_entries, pa->pdNextVertex-pa->pd0, prim_total/prim_count);
#endif

// Advance polyarray batch pointer.
// Skip a vertex because it may contain attributes for the current batch.

    pa->pdBufferNext = pa->pdNextVertex + 1;
}

void FASTCALL VA_DrawElementsEnd(POLYARRAY *pa)
{
    GLMSG_DRAWPOLYARRAY *pMsgDrawPolyArray;

    ASSERTOPENGL(pa->flags & POLYARRAY_IN_BEGIN, "not in begin\n");
    ASSERTOPENGL(pa->aIndices && (pa->aIndices != PA_aIndices_INITIAL_VALUE),
	"no output index array!\n");

// Clear the POLYARRAY_IN_BEGIN flag in the TEB.  We are now out of
// the begin/end bracket.

    pa->flags &= ~POLYARRAY_IN_BEGIN;

// Clear POLYARRAY_SAME_COLOR_DATA flag if the primitive uses more than
// one color.

    if (pa->pdCurColor != pa->pd0)
	pa->flags &= ~POLYARRAY_SAME_COLOR_DATA;

// Save the POLYARRAY structure in the batch.

    pMsgDrawPolyArray = (GLMSG_DRAWPOLYARRAY *)
	((BYTE *) pa->pMsgBatchInfo + pa->nextMsgOffset -
         GLMSG_ALIGN(sizeof(GLMSG_DRAWPOLYARRAY)));
    *(POLYARRAY *) pMsgDrawPolyArray->paLast = *pa;

#ifdef PRIMITIVE_TRACK
    prim_count++;
    DbgPrint("VA_DrawElementsEnd called\n");
#endif

// Advance polyarray batch pointer.

    pa->pdBufferNext = (POLYDATA *) (pa->aIndices +
	(pa->nIndices + sizeof(POLYDATA) - 1) / sizeof(POLYDATA) * sizeof(POLYDATA));
}

#ifdef NEW_PARTIAL_PRIM

typedef void (*PFNSAVERESTORE)(__GLcontext*, POLYARRAY*, SAVEREGION*);

void FASTCALL SaveFirstVertex(__GLcontext* gc, POLYARRAY* pa)
{
    if (!(pa->flags & POLYARRAY_PARTIAL_BEGIN))
    {
        GLuint  flags = pa->flags & (POLYARRAY_MATERIAL_FRONT | POLYARRAY_MATERIAL_BACK);
        SaveSharedVertex(&gc->vertex.regSaved, pa->pd0, pa);
        // Save vertex state to restore it later
        pa->flags |= (POLYARRAY_MATERIAL_FRONT | POLYARRAY_MATERIAL_BACK);
        UpdateVertexStateUsingGC(gc, pa, &gc->vertex.regSaved);
        // Restore pa flags
        pa->flags &= ~(POLYARRAY_MATERIAL_FRONT | POLYARRAY_MATERIAL_BACK);
        pa->flags |= flags;
    }
}

// This function is used by GL_POINTS, GL_LINES, GL_TRIANGLES, GL_QUADS, 
// because for these cases parts of broken primitive are not connected. 
// We also clear POLYARRAY_PARTIAL_END flag, because in DrawPolyArray we 
// can remove this partial primitive if it is clipped out (we do not have
// to preserve line stipple for these primitives).
//
void SaveEmpty(__GLcontext *gc, POLYARRAY *pa, SAVEREGION *r)
{
    pa->flags &= ~POLYARRAY_PARTIAL_END;
}

// A line loop is the same as a line strip except that a final segment is
// added from the final specified vertex to the first vertex.  We convert 
// the line loop into a strip here. We have to save first vertex of line 
// loop only if the primitive is not partial begin (i.e. it is not a middle 
// part of a line loop broken into more than two polyarrays). 
// We do not clear POLYARRAY_PARTIAL_END flag, because in DrawPolyArray we 
// can not remove this partial primitive if it is clipped out to preserve 
// line stipple. 
// Index mapping is always indentity for GL_LINE_LOOP.
// We save first vertex in graphics state, because it will be restored in glcltEnd.
// We change line loop to line strip here.
//
// When the first vertex is saved we have preserve its state to restore it in the next part
// of partial primitive.
//
void SaveLineLoop(__GLcontext *gc, POLYARRAY *pa, SAVEREGION *r)
{
    POLYDATA*  pd;

    SaveFirstVertex(gc, pa);

    pd = pa->pdNextVertex-1;
    SaveSharedVertex(r, pd, pa);
    pa->primType = GL_LINE_STRIP;
}

// For GL_LINE_STRIP we save last vertex. We do not clear POLYARRAY_PARTIAL_END flag,
// because in DrawPolyArray we can not remove this partial primitive if it is clipped
// out to preserve line stipple.
// We do not preserve index because it is assumed to be 0 for the next part
// of the primitive.
//
void SaveLineStrip(__GLcontext *gc, POLYARRAY *pa, SAVEREGION *r)
{
    POLYDATA *pd;
    if (pa->aIndices)
        pd = &pa->pd0[pa->aIndices[pa->nIndices-1]];
    else
        pd = pa->pdNextVertex-1;
    SaveSharedVertex(r, pd, pa);
}

// For GL_TRIANLE_FAN we save first and last vertices. Line stipple is reset for every 
// triangle in a fan, so we can clear POLYARRAY_PARTIAL_END flag
// We do not preserve indices because they are assumed to be 0 and 1 for the next part
// of the primitive.
//
// When we restore first vertex it must have the same state as when we saved it.
// But this state should no affect vertex last vertex.
// So we have to compute vertex state for the first when we save it and compute
// vertex state for the lase vertex when we restore it.
// First vertex and its state should be computed only once, even if a primitive is broken 
// several times.
//
void SaveTFan(__GLcontext *gc, POLYARRAY *pa, SAVEREGION *r)
{
    if (pa->aIndices)
    {
        POLYDATA *pd;
        GLubyte  *aIndices = pa->aIndices;

        pd = &pa->pd0[aIndices[0]];
        SaveSharedVertex(&gc->vertex.regSaved, pd, pa);

        pd = &pa->pd0[aIndices[pa->nIndices-1]];
        SaveSharedVertex(r, pd, pa);
    }
    else
    {
        POLYDATA *pd;
        // Compute state for the first vertex only for the very first part
        // of partial primitive
        SaveFirstVertex(gc, pa);

        pd = pa->pdNextVertex-1;
        SaveSharedVertex(r, pd, pa);
    }
    pa->flags &= ~POLYARRAY_PARTIAL_END;
}

// This function handles GL_TRIANGLE_STRIP and GL_QUAD_STRIP.
// We save two last vertices.
// Line stipple is reset for every triangle (quad) in a strip, so we can clear 
// POLYARRAY_PARTIAL_END flag.
// We do not preserve indices because they are assumed to be 0 and 1 for the 
// next part of the primitive.
//
// We have to save 2 last vertices: v1 and v2 (last vertex).
// Next part of partial primitive will start with vertex v1.
// v2 could change vertex state, so we have to compute vertex state for v1 and
// restore it. This should be done only for non indexed case.
//
void SaveTStrip(__GLcontext *gc, POLYARRAY *pa, SAVEREGION *r)
{
    if (pa->aIndices)
    {
        POLYDATA *pd;
        GLint     nIndices = pa->nIndices;
        GLubyte  *aIndices = pa->aIndices;

        pd = &pa->pd0[aIndices[nIndices-2]];
        SaveSharedVertex(r, pd, pa);
        pd = &pa->pd0[aIndices[nIndices-1]];
        SaveSharedVertex(r+1, pd, pa);
    }
    else
    {
        POLYDATA *pd = pa->pdNextVertex-2;

        SaveSharedVertex(r, pd, pa);
        // Compute vertex state, changed by vertex pd+1
        UpdateVertexState(gc, pa, r, pd-1, pd+1);
        pd++;
        SaveSharedVertex(r+1, pd, pa);
    }
    pa->flags &= ~POLYARRAY_PARTIAL_END;
}

// For GL_POLYGON we first and last two vertices, because we do not know 
// if the last vertex of this part is the last vertex for the primitive. We need this
// information to compute edge flag for the last vertex.
// We remove last vertex from the primitive. It will be processed in the next part of 
// the primitive.
// We need POLYARRAY_PARTIAL_END flag when we compute edge flag in DrawPolyArray.
//
void SavePolygon(__GLcontext *gc, POLYARRAY *pa, SAVEREGION *r)
{
    POLYDATA *pd;
    // Compute state for the first vertex only for the very first part
    // of partial primitive
    SaveFirstVertex(gc, pa);

    pd = pa->pdNextVertex-2;
    SaveSharedVertex(r, pd, pa);

    r++;
    pd = pa->pdNextVertex-1;
    SaveSharedVertex(r, pd, pa);

// Remove last vertex from the primitive
    pa->nIndices--;
    pa->pdNextVertex--;
}

PFNSAVERESTORE  pfnSaveFunc[] =
{
    SaveEmpty,      // GL_POINTS
    SaveEmpty,      // GL_LINES
    SaveLineLoop,   // GL_LINE_LOOP
    SaveLineStrip,  // GL_LINE_STRIP
    SaveEmpty,      // GL_TRIANGLES
    SaveTStrip,     // GL_TRIANGLE_STRIP
    SaveTFan,       // GL_TRIANGLE_FAN
    SaveEmpty,      // GL_QUADS
    SaveTStrip,     // GL_QUAD_STRIP
    SavePolygon     // GL_POLYGON
};

// This function is used by GL_POINTS, GL_LINES, GL_TRIANGLES, GL_QUADS, 
// because for these cases parts of broken primitive are not connected. We 
// also clear POLYARRAY_PARTIAL_BEGIN flag, because in DrawPolyArray we can 
// remove this partial primitive if it is clipped out (we do not have to 
// preserve line stipple for these primitives).
//
void RestoreEmpty(__GLcontext *gc, POLYARRAY *pa, SAVEREGION *r)
{
    pa->flags &= ~POLYARRAY_PARTIAL_BEGIN;
}

// For GL_LINE_LOOP and GL_LINE_STRIP last vertex from previous part will be the first.
// We will convert line loop into line strip in glcltEnd or PolyArrayFlushPartialPrimitive
// To preserve line stipple we need POLYARRAY_PARTIAL_BEGIN flag.
//
void RestoreLineStrip(__GLcontext *gc, POLYARRAY *pa, SAVEREGION *r)
{
    POLYDATA *pd = pa->pdNextVertex++;

    RestoreSharedVertex(pd, r, pa);
}

// For GL_TRIANGLE_STRIP and GL_QUAD_STRIP we have to add two saved
// vertices at the beginning of primitive.
// We do not to preserve line stipple, so we clear POLYARRAY_PARTIAL_BEGIN flag.
//
void RestoreTStrip(__GLcontext *gc, POLYARRAY *pa, SAVEREGION *r)
{
    POLYDATA *pd = pa->pdNextVertex++;

    RestoreSharedVertex(pd, r, pa);
                 
    r++;
    pd = pa->pdNextVertex++;
    RestoreSharedVertex(pd, r, pa);

    pa->flags &= ~POLYARRAY_PARTIAL_BEGIN;
}

// For GL_TRIANGLE_FAN we have to add two saved vertices at the beginning 
// of primitive. Last vertex should have a state, not modified by previous vertex.
// We do not to preserve line stipple, so we clear POLYARRAY_PARTIAL_BEGIN flag.
//
void RestoreTFan(__GLcontext *gc, POLYARRAY *pa, SAVEREGION *r)
{
    POLYDATA *pd = pa->pdNextVertex++;

    RestoreSharedVertex(pd, &gc->vertex.regSaved, pa);

    pd = pa->pdNextVertex++;
    if (!pa->aIndices)
        // Compute state for last vertex, because it could be modified 
        // by first vertex
        UpdateVertexStateUsingGC(gc, pa, r);
    RestoreSharedVertex(pd, r, pa);
}

// For GL_POLYGON we have to add three saved vertices at the beginning of primitive.
// We need POLYARRAY_PARTIAL_BEGIN flag to compute edge flag in DrawPolyArray.
//
void RestorePolygon(__GLcontext *gc, POLYARRAY *pa, SAVEREGION *r)
{
    POLYDATA *pd = pa->pdNextVertex++;

    RestoreSharedVertex(pd, &gc->vertex.regSaved, pa);
                 
    // Compute state for this vertex, because it could be modified 
    // by first vertex
    UpdateVertexStateUsingGC(gc, pa, r);
    pd = pa->pdNextVertex++;
    RestoreSharedVertex(pd, r, pa);

    r++;
    pd = pa->pdNextVertex++;
    RestoreSharedVertex(pd, r, pa);
}

PFNSAVERESTORE  pfnRestoreFunc[] =
{
    RestoreEmpty,      // GL_POINTS
    RestoreEmpty,      // GL_LINES
    RestoreLineStrip,  // GL_LINE_LOOP
    RestoreLineStrip,  // GL_LINE_STRIP
    RestoreEmpty,      // GL_TRIANGLES
    RestoreTStrip,     // GL_TRIANGLE_STRIP
    RestoreTFan,       // GL_TRIANGLE_FAN
    RestoreEmpty,      // GL_QUADS
    RestoreTStrip,     // GL_QUAD_STRIP
    RestorePolygon     // GL_POLYGON
};               

#endif // NEW_PARTIAL_PRIM

// Number of reserved vertices for partial Begin.
GLint nReservedIndicesPartialBegin[] =
{
    0, // GL_POINTS
    0, // GL_LINES
    1, // GL_LINE_LOOP
    1, // GL_LINE_STRIP
    0, // GL_TRIANGLES
    2, // GL_TRIANGLE_STRIP
    2, // GL_TRIANGLE_FAN
    0, // GL_QUADS
    2, // GL_QUAD_STRIP
    3  // GL_POLYGON
};

// If you modify this function, you need to also modify
// VA_DrawElementsFlushPartialPrimitive.
void FASTCALL PolyArrayFlushPartialPrimitive()
{
    POLYARRAY *pa;
    POLYDATA  *pd0, *pdFlush;
    GLenum    mode;
    GLMSG_DRAWPOLYARRAY *pMsgDrawPolyArray;
    GLuint    paFlags;
#ifdef NEW_PARTIAL_PRIM
    SAVEREGION savereg[3];     // Temporary storage for vertices, shared between
#endif // NEW_PARTIAL_PRIM     // parts of decomposed primitive                 
    __GL_SETUP();

    pa = gc->paTeb;

#ifdef PRIMITIVE_TRACK
    prim_entries += pa->pdNextVertex-pa->pd0;
    DbgPrint("* Flush partial primitive with %d polydata entries\n",
          pa->pdNextVertex-pa->pd0);
#endif

    ASSERTOPENGL(pa->flags & POLYARRAY_IN_BEGIN, "not in begin\n");
    ASSERTOPENGL(!pa->aIndices || (pa->aIndices == PA_aIndices_INITIAL_VALUE),
                 "Flushing DrawElements unexpected!\n");

// Flush invalid commands accumulated in the command buffer if there is any.

    glsbAttention();

    // Clear the POLYARRAY_IN_BEGIN flag in the TEB.  We are now out of
    // the begin/end bracket temporarily.  glsbAttention does not flush
    // unless the flag is clear.

    pa->flags &= ~POLYARRAY_IN_BEGIN;

    // Mark it as a partially completed primitive batch.

    pa->flags |= POLYARRAY_PARTIAL_END;

    // Clear POLYARRAY_SAME_COLOR_DATA flag if the primitive uses more than
    // one color.  Also clear the flag if an evaluator is used.  We cannot
    // tell if an evaluator modifies the color on the client side.

    if ((pa->pdCurColor != pa->pd0) ||
        ((pa->pd0->flags & POLYDATA_COLOR_VALID) &&
         (pa->flags & POLYARRAY_PARTIAL_BEGIN)) ||
        (pa->pdLastEvalColor != pa->pd0))
        pa->flags &= ~POLYARRAY_SAME_COLOR_DATA;

    // Save some pa flags for next partial primitive.
    // Need to preserve POLYARRAY_CLAMP_COLOR flag in dlist playback.

#ifdef NEW_PARTIAL_PRIM
    // We have to preserve material flags to handle first vertex
    //
    paFlags = pa->flags & (POLYARRAY_SAME_POLYDATA_TYPE |
                           POLYARRAY_SAME_COLOR_DATA |
                           POLYARRAY_TEXTURE1 |
                           POLYARRAY_TEXTURE2 |
                           POLYARRAY_TEXTURE3 |
                           POLYARRAY_TEXTURE4 |
                           POLYARRAY_VERTEX2  |
                           POLYARRAY_VERTEX3  |
                           POLYARRAY_VERTEX4  |
                           POLYDATA_MATERIAL_FRONT | 
                           POLYDATA_MATERIAL_BACK  |
                           POLYARRAY_CLAMP_COLOR);
#else
    paFlags = pa->flags & (POLYARRAY_SAME_POLYDATA_TYPE |
                           POLYARRAY_SAME_COLOR_DATA |
                           POLYARRAY_CLAMP_COLOR);
#endif
    // Compute nIndices.  It is the final number of vertices passed to the low
    // level render routines and is different from the number of polydata's
    // accumulated.  The final number includes the reserved vertices and the
    // accumulated vertices.

    pa->nIndices += (GLint)((ULONG_PTR)(pa->pdNextVertex - pa->pd0));

    // Save states before flushing the batch.

    mode = pa->primType;

#ifdef NEW_PARTIAL_PRIM
    // Save shared vertices for the next part of the partial primitive

    pfnSaveFunc[mode](gc, pa, savereg);
#endif // NEW_PARTIAL_PRIM

    // Save the POLYARRAY structure in the batch.

    pMsgDrawPolyArray = (GLMSG_DRAWPOLYARRAY *)
    
    ((BYTE *) pa->pMsgBatchInfo + pa->nextMsgOffset -
       GLMSG_ALIGN(sizeof(GLMSG_DRAWPOLYARRAY)));
    *(POLYARRAY *) pMsgDrawPolyArray->paLast = *pa;


    // Flush the command buffer and reset pointer for the next batch.
    // If we are compiling poly array primitive in dlist, record the last poly
    // data record.

    if (gc->dlist.beginRec)
    {
        // Record the poly data.
        __glDlistCompilePolyData(gc, GL_FALSE);

        // We just recorded this vertex, don't record it in the compile
        // code again!
        gc->dlist.skipPolyData = GL_TRUE;

        if (gc->dlist.mode == GL_COMPILE_AND_EXECUTE)
            glsbAttention();    // reset pdBufferNext pointer too!
        else
            glsbResetBuffers(TRUE); // reset pointers but no execution
    }
    else
    {
        glsbAttention();    // reset pdBufferNext pointer too!
    }

    ASSERTOPENGL(pa->nextMsgOffset == PA_nextMsgOffset_RESET_VALUE, 
                 "bad nextMsgOffset\n");

    // Batch new POLYARRAY command in the command buffer.
    
    GLCLIENT_BEGIN(DrawPolyArray, DRAWPOLYARRAY)
    // need msg pointer to update pa later
    pMsgDrawPolyArray = pMsg;

    // start of a new chain
    pMsgDrawPolyArray->pa0    =
    pMsgDrawPolyArray->paLast = (PVOID) pa->pdBufferNext;

    // remember the end of the primitive command
    pa->nextMsgOffset = pMsgBatchInfo->NextOffset;
    GLCLIENT_END

#ifdef NEW_PARTIAL_PRIM
// Compute the start of the PARTIAL primitive.  A partial primitive begins
// with a POLYARRAY entry followed by vertex entries.  We DO NOT not need to
// reserve additional vertex entries at the beginning for connectivity
// between decomposed primitives. Because we just add them at the beginning

    pd0 = pa->pdBufferNext + 1;
#else
// Compute the start of the PARTIAL primitive.  A partial primitive begins
// with a POLYARRAY entry followed by vertex entries.  We need to
// reserve additional vertex entries at the beginning for connectivity
// between decomposed primitives.

    pd0 = pa->pdBufferNext + 1 + nReservedIndicesPartialBegin[mode];

#endif // NEW_PARTIAL_PRIM

    // Initialize first polydata.

    pd0->flags = 0;
    
    ASSERTOPENGL(pd0->color == &pd0->colors[__GL_FRONTFACE],
                 "bad color pointer!\n");
    
    // Initialize the polyarray structure in the TEB.

    pa->flags         = POLYARRAY_IN_BEGIN | POLYARRAY_PARTIAL_BEGIN | paFlags;
    pa->pdNextVertex  =
    pa->pd0           = pd0;
    pa->primType      = mode;
    pa->paNext        = NULL;
#ifdef NEW_PARTIAL_PRIM
    pa->nIndices      = 0;          // WE do not reserve any vertices
#else
    pa->nIndices      = nReservedIndicesPartialBegin[mode];
#endif // NEW_PARTIAL_PRIM
    pa->aIndices      = NULL;   // identity mapping
    pa->pdCurColor    =
    pa->pdCurNormal   =
    pa->pdCurTexture  =
    pa->pdCurEdgeFlag =
    pa->pdLastEvalColor    =
    pa->pdLastEvalNormal   =
    pa->pdLastEvalTexture  = NULL;


    // Compute the flush vertex for this primitive.  When the flush vertex is
    // reached, we will have accumulated enough vertices to render a partially
    // composed primitive.

    pdFlush = pa->pdBufferMax;
    switch (mode)
    {
      case GL_POINTS:
      case GL_LINE_STRIP:
      case GL_TRIANGLE_FAN:
        break;
      case GL_LINE_LOOP:
        // Line loop reserves an additional end vertex to close the loop.
        pdFlush--;
        break;
      case GL_POLYGON:
        // The polygon decomposer can only handle up to
        // __GL_MAX_POLYGON_CLIP_SIZE vertices.  We also need to give
        // allowance for 3 vertices in the decomposed polygons.
        if (pdFlush > (pd0 - 3) + __GL_MAX_POLYGON_CLIP_SIZE - 1)
            pdFlush = (pd0 - 3) + __GL_MAX_POLYGON_CLIP_SIZE - 1;
        ASSERTOPENGL(nReservedIndicesPartialBegin[GL_POLYGON] == 3,
                     "bad reserved size!\n");
        break;
      case GL_LINES:
      case GL_TRIANGLE_STRIP:
      case GL_QUAD_STRIP:
        // number of vertices must be a multiple of 2
        if ((pdFlush - pd0 + 1) % 2)
            pdFlush--;
        break;
      case GL_TRIANGLES:
        // number of vertices must be a multiple of 3
        switch ((pdFlush - pd0 + 1) % 3)
        {
          case 2: pdFlush--;        // fall through
          case 1: pdFlush--;
        }
        break;
      case GL_QUADS:
        // number of vertices must be a multiple of 4
        switch ((pdFlush - pd0 + 1) % 4)
        {
          case 3: pdFlush--;        // fall through
          case 2: pdFlush--;        // fall through
          case 1: pdFlush--;
        }
        break;
    }
    pa->pdFlush = pdFlush;

#ifdef NEW_PARTIAL_PRIM
    // Add saved vertices into the new part of the primitive

    pfnRestoreFunc[mode](gc, pa, savereg);

#endif // NEW_PARTIAL_PRIM
}

// Special version of Flush for DrawElements.
// If you modify this function, you need to also modify
// PolyArrayFlushPartialPrimitive.
void FASTCALL VA_DrawElementsFlushPartialPrimitive(POLYARRAY *pa, GLenum mode)
{
    POLYDATA  *pd0;
    GLMSG_DRAWPOLYARRAY *pMsgDrawPolyArray;
    GLuint    paFlags;
#ifdef NEW_PARTIAL_PRIM
    SAVEREGION  savereg[3];     // Temporary storage for vertices, shared between
#endif // NEW_PARTIAL_PRIM             // parts of decomposed primitive                 
    __GL_SETUP();

#ifdef PRIMITIVE_TRACK
    DbgPrint("VA_DrawElementsFlushPartialPrimitive called\n");
#endif

    // We don't handle Points, Line Loop, and Polygon here.  They should
    // have been sent to Begin/End.

    ASSERTOPENGL(mode != GL_POINTS && mode != GL_LINE_LOOP && mode != GL_POLYGON,
                 "Primitive type not handled\n");

    ASSERTOPENGL(pa->flags & POLYARRAY_IN_BEGIN, "not in begin\n");
    ASSERTOPENGL(pa->aIndices && (pa->aIndices != PA_aIndices_INITIAL_VALUE),
	"no output index array!\n");

    // Clear the POLYARRAY_IN_BEGIN flag in the TEB.  We are now out of
    // the begin/end bracket temporarily.  glsbAttention does not flush
    // unless the flag is clear.

    pa->flags &= ~POLYARRAY_IN_BEGIN;

    // Mark it as a partially completed primitive batch.

    pa->flags |= POLYARRAY_PARTIAL_END;

    // Clear POLYARRAY_SAME_COLOR_DATA flag if the primitive uses more than
    // one color.

    if (pa->pdCurColor != pa->pd0)
        pa->flags &= ~POLYARRAY_SAME_COLOR_DATA;

    // Save some pa flags for next partial primitive.

    paFlags = pa->flags & (POLYARRAY_SAME_COLOR_DATA |
                           POLYARRAY_TEXTURE1 |
                           POLYARRAY_TEXTURE2 |
                           POLYARRAY_TEXTURE3 |
                           POLYARRAY_TEXTURE4 |
                           POLYARRAY_VERTEX2  |
                           POLYARRAY_VERTEX3  |
                           POLYARRAY_VERTEX4  |
                           POLYARRAY_CLAMP_COLOR);

#ifdef NEW_PARTIAL_PRIM
    // Save shared vertices for the next part of partial primitive

    pfnSaveFunc[mode](gc, pa, savereg);

#endif // NEW_PARTIAL_PRIM

    // Save the POLYARRAY structure in the batch.

    pMsgDrawPolyArray = (GLMSG_DRAWPOLYARRAY *)
      ((BYTE *) pa->pMsgBatchInfo + pa->nextMsgOffset -
       GLMSG_ALIGN(sizeof(GLMSG_DRAWPOLYARRAY)));
    *(POLYARRAY *) pMsgDrawPolyArray->paLast = *pa;

    // Flush the command buffer and reset pointer for the next batch.

    ASSERTOPENGL(!gc->dlist.beginRec
                 || gc->dlist.mode == GL_COMPILE_AND_EXECUTE,
                 "dlist complilation unexpected!\n");
    glsbAttention();    // reset pdBufferNext pointer too!

    ASSERTOPENGL(pa->nextMsgOffset == PA_nextMsgOffset_RESET_VALUE, 
                 "bad nextMsgOffset\n");

    // Batch new POLYARRAY command in the command buffer.

    GLCLIENT_BEGIN(DrawPolyArray, DRAWPOLYARRAY)
    // need msg pointer to update pa later
    pMsgDrawPolyArray = pMsg;

    // start of a new chain
    pMsgDrawPolyArray->pa0    =
    pMsgDrawPolyArray->paLast = (PVOID) pa->pdBufferNext;

    // remember the end of the primitive command
    pa->nextMsgOffset = pMsgBatchInfo->NextOffset;
    GLCLIENT_END

#ifdef NEW_PARTIAL_PRIM
// Compute the start of the PARTIAL primitive.  A partial primitive begins
// with a POLYARRAY entry followed by vertex entries.  We DO NOT need to
// reserve additional vertex entries at the beginning for connectivity
// between decomposed primitives.

    pd0 = pa->pdBufferNext + 1;
#else
// Compute the start of the PARTIAL primitive.  A partial primitive begins
// with a POLYARRAY entry followed by vertex entries.  We need to
// reserve additional vertex entries at the beginning for connectivity
// between decomposed primitives.

    pd0 = pa->pdBufferNext + 1 + nReservedIndicesPartialBegin[mode];
#endif

    // Initialize first polydata.

    pd0->flags = 0;
    
    ASSERTOPENGL(pd0->color == &pd0->colors[__GL_FRONTFACE],
                 "bad color pointer!\n");
    
    // Initialize the polyarray structure in the TEB.

    pa->flags         = POLYARRAY_IN_BEGIN | POLYARRAY_PARTIAL_BEGIN |
      POLYARRAY_SAME_POLYDATA_TYPE | paFlags;
    pa->pdNextVertex  =
    pa->pd0           = pd0;
    pa->primType      = mode;
    pa->pdCurColor    =
    pa->pdCurNormal   =
    pa->pdCurTexture  =
    pa->pdCurEdgeFlag = NULL;
    pa->paNext        = NULL;
#ifdef NEW_PARTIAL_PRIM
    pa->nIndices      = 0;
#else
    pa->nIndices      = nReservedIndicesPartialBegin[mode];
#endif // NEW_PARTIAL_PRIM
    pa->aIndices      = PA_aIndices_INITIAL_VALUE;  // this is updated in End
    
// The flush vertex for this primitive should never be reached.  The call
// to glsbAttention in this function has left enough room for a vertex batch.
// Set it to maximum and assert that we never reach the vertex in
// PolyArrayFlushPartialPrimitive!

    pa->pdFlush = pa->pdBufferMax;

#ifdef NEW_PARTIAL_PRIM
    // Add saved vertices into the new part of the primitive

    pfnRestoreFunc[mode](gc, pa, savereg);

#endif // NEW_PARTIAL_PRIM
}

// The vertex functions are called in begin/end only.
#define PA_VERTEX2(x1,y1)					\
								\
    POLYARRAY *pa;						\
    POLYDATA  *pd;						\
								\
    pa = GLTEB_CLTPOLYARRAY();					\
								\
    if (pa->flags & POLYARRAY_IN_BEGIN)				\
    {								\
	pa->flags |= POLYARRAY_VERTEX2;				\
								\
	pd = pa->pdNextVertex++;				\
	pd->flags |= POLYDATA_VERTEX2;				\
	pd->obj.x = x1;						\
	pd->obj.y = y1;						\
	pd->obj.z = __glZero;					\
	pd->obj.w = __glOne;					\
								\
	pd[1].flags = 0;					\
								\
	if (pd >= pa->pdFlush)            			\
	    PolyArrayFlushPartialPrimitive(); 			\
    }      

#define PA_VERTEX3(x1,y1,z1)				\
{								            \
    GLfloat t1;							    \
    POLYARRAY *pa;							\
    POLYDATA  *pd, *pd1;					\
    ULONG	flag1, flag2, flag3;			\
    register GLfloat tone;					\
                                            \
    pa = GLTEB_CLTPOLYARRAY();				\
    tone = 1.0;                             \
                                            \
    pd1 = pa->pdFlush;						\
    flag1 = pa->flags;						\
    pd = pa->pdNextVertex;					\
                                            \
    if (flag1 & POLYARRAY_IN_BEGIN)         \
    {                                       \
        flag3 = pd->flags;                  \
        pa->pdNextVertex++;                 \
        flag2 = flag1 | POLYARRAY_VERTEX3;  \
        flag3 = flag3 | POLYDATA_VERTEX3;   \
                                            \
        pd->obj.x = x1;						\
        pd->obj.y = y1;						\
        pd->obj.z = z1;						\
        pd->obj.w = tone;					\
        pa->flags = flag2;					\
        pd->flags = flag3;					    \
								                \
        pd[1].flags = 0;					    \
								                \
        if (pd >= pd1)		            		\
	        PolyArrayFlushPartialPrimitive();   \
    }                                           \
}

#define PA_VERTEX4(x1,y1,z1,w1)					\
								\
    POLYARRAY *pa;						\
    POLYDATA  *pd;						\
								\
    pa = GLTEB_CLTPOLYARRAY();					\
								\
    if (pa->flags & POLYARRAY_IN_BEGIN)				\
    {								\
	pa->flags |= POLYARRAY_VERTEX4;				\
								\
	pd = pa->pdNextVertex++;				\
	pd->flags |= POLYDATA_VERTEX4;				\
	pd->obj.x = x1;						\
	pd->obj.y = y1;						\
	pd->obj.z = z1;						\
	pd->obj.w = w1;						\
								\
	pd[1].flags = 0;					\
								\
	if (pd >= pa->pdFlush)            			\
	    PolyArrayFlushPartialPrimitive(); 			\
    }

#define PA_COLOR_IN_RGBA_NO_CLAMP1(red,green,blue)		            \
    POLYARRAY *pa;						            \
    POLYDATA  *pd;						            \
    __GL_SETUP();                                                           \
								            \
    pa = gc->paTeb;							    \
								            \
    if (pa->flags & POLYARRAY_IN_BEGIN)				            \
    {								            \
	pd = pa->pdNextVertex;					            \
	pa->pdCurColor = pd;					            \
                                                                            \
        __GL_SCALE_RGB(pd->colors[0].r, pd->colors[0].g, pd->colors[0].b,   \
                       gc, red, green, blue);    	                    \
        pd->colors[0].a = gc->alphaVertexScale;                             \
                                                                            \
	pd->flags |= POLYDATA_COLOR_VALID;				    \
    }								            \
    else							            \
    {								            \
	glcltColor4f_InRGBA_NotInBegin(gc, pa,				    \
	  POLYDATA_COLOR_VALID, red, green, blue, __glOne);		    \
    }

#define PA_COLOR_IN_RGBA_NO_CLAMP(red,green,blue,alpha)		            \
    POLYARRAY *pa;						            \
    POLYDATA  *pd;						            \
    __GL_SETUP();                                                           \
								            \
    pa = gc->paTeb;							    \
								            \
    if (pa->flags & POLYARRAY_IN_BEGIN)				            \
    {								            \
	pd = pa->pdNextVertex;					            \
	pa->pdCurColor = pd;					            \
                                                                            \
        __GL_SCALE_RGBA(pd->colors[0].r,                                    \
                        pd->colors[0].g,                                    \
                        pd->colors[0].b,                                    \
                        pd->colors[0].a,                                    \
                        gc, red, green, blue, alpha);                       \
                                                                            \
	pd->flags |= POLYDATA_COLOR_VALID | POLYDATA_DLIST_COLOR_4;	    \
    }								            \
    else							            \
    {								            \
	glcltColor4f_InRGBA_NotInBegin(gc, pa,				    \
	  POLYDATA_COLOR_VALID | POLYDATA_DLIST_COLOR_4, red, green, blue, alpha);\
    }

#define PA_COLOR_IN_RGB1(red,green,blue)			            \
    POLYARRAY *pa;						            \
    POLYDATA  *pd;						            \
    __GL_SETUP();                                                           \
								            \
    pa = gc->paTeb;						            \
								            \
    if (pa->flags & POLYARRAY_IN_BEGIN)				            \
    {								            \
	pd = pa->pdNextVertex;					            \
	pa->pdCurColor = pd;					            \
                                                                            \
        __GL_SCALE_AND_CHECK_CLAMP_RGB(pd->colors[0].r,                     \
                                       pd->colors[0].g,                     \
                                       pd->colors[0].b,                     \
                                       gc, pa->flags,                       \
                                       red, green, blue);                   \
        pd->colors[0].a = gc->alphaVertexScale;                             \
                                                                            \
	pd->flags |= POLYDATA_COLOR_VALID;			            \
    }								            \
    else							            \
    {								            \
	glcltColor4f_InRGBA_NotInBegin(gc, pa,				    \
	  POLYDATA_COLOR_VALID, red, green, blue, __glOne);		    \
    }

#define PA_COLOR_IN_RGB2(red, green, blue)      \
{                                               \
    POLYARRAY *pa;                              \
    POLYDATA  *pd;                              \
    GLfloat sr, sg, sb;                         \
    ULONG f1, f2, f3, f4, f5, f6;               \
    LONG t1, t2, t3;                            \
                                                \
    __GL_SETUP();                               \
                                                \
    pa = gc->paTeb;                             \
                                                \
    if (pa->flags & POLYARRAY_IN_BEGIN)			\
    {                                           \
                                                \
        t1 = (LONG) (CASTINT(gc->redVertexScale));      \
        t2 = (LONG) (CASTINT(gc->greenVertexScale));	\
        t3 = (LONG) (CASTINT(gc->blueVertexScale));		\
                                                \
        pd = pa->pdNextVertex;                  \
        pa->pdCurColor = pd;                    \
                                                \
        sr = red *  gc->redVertexScale;         \
        sg = green * gc->greenVertexScale;      \
        sb = blue * gc->blueVertexScale;        \
                                                \
        f1 = (ULONG) (CASTINT(sr));             \
        f2 = (ULONG) (CASTINT(sg));             \
        f3 = (ULONG) (CASTINT(sb));             \
							                    \
        f4 = (ULONG) (t1 - CASTINT(sr));		\
        f5 = (ULONG) (t2 - CASTINT(sg));		\
        f6 = (ULONG) (t3 - CASTINT(sb));		\
                                                \
        f1 = f1 | f2;                           \
        f3 = f3 | f4;                           \
        f5 = f5 | f6;                           \
                                                \
        pd->colors[0].r = sr;					\
        pd->colors[0].g = sg;					\
        pd->colors[0].b = sb;					\
                                                \
        f1 = f1 | f3 | f5;                      \
                                                \
        pa->flags |= (f1 & 0x80000000);         \
                                                \
        pd->colors[0].a = gc->alphaVertexScale; \
                             				    \
        pd->flags |= POLYDATA_COLOR_VALID;		\
    }	                                        \
    else                                        \
    {	                                        \
        glcltColor4f_InRGBA_NotInBegin(gc, pa,              \
          POLYDATA_COLOR_VALID, red, green, blue, __glOne);	\
    }								                        \
}

#define PA_COLOR_IN_RGBA(red,green,blue,alpha)			            \
    POLYARRAY *pa;						            \
    POLYDATA  *pd;						            \
    __GL_SETUP();                                                           \
								            \
    pa = gc->paTeb;							    \
								            \
    if (pa->flags & POLYARRAY_IN_BEGIN)				            \
    {								            \
	pd = pa->pdNextVertex;					            \
	pa->pdCurColor = pd;					            \
                                                                            \
        __GL_SCALE_AND_CHECK_CLAMP_RGBA(pd->colors[0].r,                    \
                                        pd->colors[0].g,                    \
                                        pd->colors[0].b,                    \
                                        pd->colors[0].a,                    \
                                        gc, pa->flags,                      \
                                        red, green, blue, alpha);           \
                                                                            \
	pd->flags |= POLYDATA_COLOR_VALID | POLYDATA_DLIST_COLOR_4;	    \
    }								            \
    else							            \
    {								            \
	glcltColor4f_InRGBA_NotInBegin(gc, pa,				    \
	  POLYDATA_COLOR_VALID | POLYDATA_DLIST_COLOR_4, red, green, blue, alpha);\
    }

#define PA_COLOR_IN_CI(red,green,blue,alpha)			\
								\
    POLYARRAY *pa;						\
								\
    pa = GLTEB_CLTPOLYARRAY();					\
								\
    if (pa->flags & POLYARRAY_IN_BEGIN)				\
    {								\
	pa->flags |= POLYARRAY_OTHER_COLOR;			\
	/* need only record the latest values */		\
	/* otherColor in the TEB may not be aligned at 16-byte boundary */ \
	pa->otherColor.r = red;					\
	pa->otherColor.g = green;				\
	pa->otherColor.b = blue;				\
	pa->otherColor.a = alpha;				\
    }								\
    else							\
    {								\
	glcltColor4f_NotInBegin(red, green, blue, alpha);	\
    }

void FASTCALL glcltColor4f_NotInBegin(GLfloat red, GLfloat green,
    GLfloat blue, GLfloat alpha)
{
    GLCLIENT_BEGIN( Color4fv, COLOR4FV )
        pMsg->v[0] = red;
        pMsg->v[1] = green;
        pMsg->v[2] = blue;
        pMsg->v[3] = alpha;
    GLCLIENT_END
}

void FASTCALL glcltColor4f_InRGBA_NotInBegin(__GLcontext *gc, POLYARRAY *pa,
    GLuint pdFlags, GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
    POLYDATA  *pd;
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_DRAWPOLYARRAY *pMsgDrawPolyArray;

    pMsgBatchInfo = (GLMSGBATCHINFO *) pa->pMsgBatchInfo;

    // If the last command is DrawPolyArray, add it to the command.
    // This allows us to chain primitives separated by the attribute.
    if (pMsgBatchInfo->NextOffset == pa->nextMsgOffset)
    {
	pMsgDrawPolyArray = (GLMSG_DRAWPOLYARRAY *)
	    ((BYTE *) pMsgBatchInfo + pMsgBatchInfo->NextOffset -
	     GLMSG_ALIGN(sizeof(GLMSG_DRAWPOLYARRAY)));
        pa = (POLYARRAY *) pMsgDrawPolyArray->paLast;

	pd = pa->pdNextVertex;
	pa->pdCurColor = pd;

        __GL_SCALE_AND_CHECK_CLAMP_RGBA(pd->colors[0].r,
                                        pd->colors[0].g,
                                        pd->colors[0].b,
                                        pd->colors[0].a,
                                        gc, pa->flags,
                                        red, green, blue, alpha);

	pd->flags |= pdFlags;
    }
    else
    {
	glcltColor4f_NotInBegin(red, green, blue, alpha);
    }
}

#define PA_INDEX_IN_RGBA(i)					\
								\
    POLYARRAY *pa;						\
								\
    pa = GLTEB_CLTPOLYARRAY();					\
								\
    if (pa->flags & POLYARRAY_IN_BEGIN)				\
    {								\
	pa->flags |= POLYARRAY_OTHER_COLOR;			\
	/* need only record the latest value */			\
	pa->otherColor.r = i;					\
    }								\
    else							\
    {								\
	glcltIndexf_NotInBegin(i);				\
    }

#define PA_INDEX_IN_CI(i)					\
								\
    POLYARRAY *pa;						\
    POLYDATA  *pd;						\
    __GL_SETUP();                                               \
								\
    pa = gc->paTeb;					        \
								\
    if (pa->flags & POLYARRAY_IN_BEGIN)				\
    {								\
	pd = pa->pdNextVertex;					\
	pa->pdCurColor = pd;					\
        __GL_CHECK_CLAMP_CI(pd->colors[0].r, gc, pa->flags, i);	\
	pd->flags |= POLYDATA_COLOR_VALID;			\
    }								\
    else							\
    {								\
	glcltIndexf_InCI_NotInBegin(gc, pa, i);			\
    }

void FASTCALL glcltIndexf_NotInBegin(GLfloat c)
{
    GLCLIENT_BEGIN( Indexf, INDEXF )
	pMsg->c = c;
    GLCLIENT_END
}

void FASTCALL glcltIndexf_InCI_NotInBegin(__GLcontext *gc, POLYARRAY *pa, GLfloat c)
{
    POLYDATA  *pd;
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_DRAWPOLYARRAY *pMsgDrawPolyArray;

    pMsgBatchInfo = (GLMSGBATCHINFO *) pa->pMsgBatchInfo;

    // If the last command is DrawPolyArray, add it to the command.
    // This allows us to chain primitives separated by the attribute.
    if (pMsgBatchInfo->NextOffset == pa->nextMsgOffset)
    {
	pMsgDrawPolyArray = (GLMSG_DRAWPOLYARRAY *)
	    ((BYTE *) pMsgBatchInfo + pMsgBatchInfo->NextOffset -
	     GLMSG_ALIGN(sizeof(GLMSG_DRAWPOLYARRAY)));
        pa = (POLYARRAY *) pMsgDrawPolyArray->paLast;

	pd = pa->pdNextVertex;
	pa->pdCurColor = pd;
        __GL_CHECK_CLAMP_CI(pd->colors[0].r, gc, pa->flags, c);
	pd->flags |= POLYDATA_COLOR_VALID;
    }
    else
    {
	glcltIndexf_NotInBegin(c);
    }
}

#define PA_TEXTURE1(s1)							\
									\
    POLYARRAY *pa;							\
    POLYDATA  *pd;							\
									\
    pa = GLTEB_CLTPOLYARRAY();						\
									\
    if (pa->flags & POLYARRAY_IN_BEGIN)					\
    {									\
	pa->flags |= POLYARRAY_TEXTURE1;				\
									\
	pd = pa->pdNextVertex;						\
	pa->pdCurTexture = pd;						\
	pd->flags |= POLYDATA_TEXTURE_VALID | POLYDATA_DLIST_TEXTURE1;	\
	pd->texture.x = s1;						\
	pd->texture.y = __glZero;					\
	pd->texture.z = __glZero;					\
	pd->texture.w = __glOne;					\
    }									\
    else								\
    {									\
	glcltTexCoord4f_NotInBegin(pa, POLYARRAY_TEXTURE1,		\
	    s1, __glZero, __glZero, __glOne);				\
    }

#define PA_TEXTURE2(s1,t1)						\
									\
    POLYARRAY *pa;							\
    POLYDATA  *pd;							\
									\
    pa = GLTEB_CLTPOLYARRAY();						\
									\
    if (pa->flags & POLYARRAY_IN_BEGIN)					\
    {									\
	pa->flags |= POLYARRAY_TEXTURE2;				\
									\
	pd = pa->pdNextVertex;						\
	pa->pdCurTexture = pd;						\
	pd->flags |= POLYDATA_TEXTURE_VALID | POLYDATA_DLIST_TEXTURE2;	\
	pd->texture.x = s1;						\
	pd->texture.y = t1;						\
	pd->texture.z = __glZero;					\
	pd->texture.w = __glOne;					\
    }									\
    else								\
    {									\
	glcltTexCoord4f_NotInBegin(pa, POLYARRAY_TEXTURE2,		\
	    s1, t1, __glZero, __glOne);					\
    }

#define PA_TEXTURE3(s1,t1,r1)						\
									\
    POLYARRAY *pa;							\
    POLYDATA  *pd;							\
									\
    pa = GLTEB_CLTPOLYARRAY();						\
									\
    if (pa->flags & POLYARRAY_IN_BEGIN)					\
    {									\
	pa->flags |= POLYARRAY_TEXTURE3;				\
									\
	pd = pa->pdNextVertex;						\
	pa->pdCurTexture = pd;						\
	pd->flags |= POLYDATA_TEXTURE_VALID | POLYDATA_DLIST_TEXTURE3;	\
	pd->texture.x = s1;						\
	pd->texture.y = t1;						\
	pd->texture.z = r1;						\
	pd->texture.w = __glOne;					\
    }									\
    else								\
    {									\
	glcltTexCoord4f_NotInBegin(pa, POLYARRAY_TEXTURE3,		\
	    s1, t1, r1, __glOne);					\
    }

#define PA_TEXTURE4(s1,t1,r1,q1)					\
									\
    POLYARRAY *pa;							\
    POLYDATA  *pd;							\
									\
    pa = GLTEB_CLTPOLYARRAY();						\
									\
    if (pa->flags & POLYARRAY_IN_BEGIN)					\
    {									\
	pa->flags |= POLYARRAY_TEXTURE4;				\
									\
	pd = pa->pdNextVertex;						\
	pa->pdCurTexture = pd;						\
	pd->flags |= POLYDATA_TEXTURE_VALID | POLYDATA_DLIST_TEXTURE4;	\
	pd->texture.x = s1;						\
	pd->texture.y = t1;						\
	pd->texture.z = r1;						\
	pd->texture.w = q1;						\
    }									\
    else								\
    {									\
	glcltTexCoord4f_NotInBegin(pa, POLYARRAY_TEXTURE4,		\
	    s1, t1, r1, q1);						\
    }

void FASTCALL glcltTexCoord4f_NotInBegin(POLYARRAY *pa, GLuint paFlags,
    GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
    POLYDATA  *pd;
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_DRAWPOLYARRAY *pMsgDrawPolyArray;

    pMsgBatchInfo = (GLMSGBATCHINFO *) pa->pMsgBatchInfo;

    // If the last command is DrawPolyArray, add it to the command.
    // This allows us to chain primitives separated by the attribute.
    if (pMsgBatchInfo->NextOffset == pa->nextMsgOffset)
    {
	pMsgDrawPolyArray = (GLMSG_DRAWPOLYARRAY *)
	    ((BYTE *) pMsgBatchInfo + pMsgBatchInfo->NextOffset -
	     GLMSG_ALIGN(sizeof(GLMSG_DRAWPOLYARRAY)));
        pa = (POLYARRAY *) pMsgDrawPolyArray->paLast;

	pa->flags |= paFlags;
	pd = pa->pdNextVertex;
	pa->pdCurTexture = pd;
	pd->flags |= POLYDATA_TEXTURE_VALID | paFlags;
	pd->texture.x = s;
	pd->texture.y = t;
	pd->texture.z = r;
	pd->texture.w = q;
    }
    else
    {
	GLCLIENT_BEGIN( TexCoord4fv, TEXCOORD4FV )
	    pMsg->v[0] = s;
	    pMsg->v[1] = t;
	    pMsg->v[2] = r;
	    pMsg->v[3] = q;
	GLCLIENT_END
    }
}

#define PA_NORMAL(x1, y1, z1)					\
{								\
    POLYARRAY *pa;						\
    POLYDATA  *pd;						\
    ULONG flag1, flag2;						\
								\
    pa = GLTEB_CLTPOLYARRAY();					\
								\
    pd = pa->pdNextVertex;					\
    flag1 = pa->flags;						\
								\
    if (flag1 & POLYARRAY_IN_BEGIN)         \
    {                                       \
        flag2 = pd->flags;					\
        flag2 |= POLYDATA_NORMAL_VALID;	    \
        pa->pdCurNormal = pd;				\
        pd->normal.x = x1;					\
        pd->normal.y = y1;					\
        pd->normal.z = z1;					\
        pd->flags = flag2;					\
    }								\
    else							\
    {								\
        glcltNormal3f_NotInBegin(pa, x1, y1, z1);		\
    }								\
								\
}

void FASTCALL glcltNormal3f_NotInBegin(POLYARRAY *pa, GLfloat nx, GLfloat ny, GLfloat nz)
{
    POLYDATA  *pd;
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_DRAWPOLYARRAY *pMsgDrawPolyArray;

    pMsgBatchInfo = (GLMSGBATCHINFO *) pa->pMsgBatchInfo;

    // If the last command is DrawPolyArray, add it to the command.
    // This allows us to chain primitives separated by the attribute.
    if (pMsgBatchInfo->NextOffset == pa->nextMsgOffset)
    {
	pMsgDrawPolyArray = (GLMSG_DRAWPOLYARRAY *)
	    ((BYTE *) pMsgBatchInfo + pMsgBatchInfo->NextOffset -
	     GLMSG_ALIGN(sizeof(GLMSG_DRAWPOLYARRAY)));
        pa = (POLYARRAY *) pMsgDrawPolyArray->paLast;

	pd = pa->pdNextVertex;
	pa->pdCurNormal = pd;
	pd->flags |= POLYDATA_NORMAL_VALID;
	pd->normal.x = nx;
	pd->normal.y = ny;
	pd->normal.z = nz;
    }
    else
    {
	GLCLIENT_BEGIN( Normal3fv, NORMAL3FV )
	    pMsg->v[ 0] = nx;
	    pMsg->v[ 1] = ny;
	    pMsg->v[ 2] = nz;
	GLCLIENT_END
    }
}

#define PA_EDGEFLAG(edgeflag)						    \
									    \
    POLYARRAY *pa;							    \
    POLYDATA  *pd;							    \
									    \
    pa = GLTEB_CLTPOLYARRAY();						    \
									    \
    if (pa->flags & POLYARRAY_IN_BEGIN)					    \
    {									    \
	pd = pa->pdNextVertex;						    \
	pa->pdCurEdgeFlag = pd;						    \
	if (edgeflag)							    \
	    pd->flags |= POLYDATA_EDGEFLAG_VALID|POLYDATA_EDGEFLAG_BOUNDARY;\
	else								    \
	{								    \
	    /* must clear POLYDATA_EDGEFLAG_BOUNDARY flag here since    */  \
	    /* there may have been a previous edge flag for this same   */  \
	    /* vertex!                                                  */  \
	    pd->flags &= ~POLYDATA_EDGEFLAG_BOUNDARY;			    \
	    pd->flags |= POLYDATA_EDGEFLAG_VALID;			    \
	}								    \
    }									    \
    else								    \
    {									    \
	glcltEdgeFlag_NotInBegin(edgeflag);				    \
    }

void FASTCALL glcltEdgeFlag_NotInBegin(GLboolean flag)
{
    GLCLIENT_BEGIN( EdgeFlag, EDGEFLAG )
	pMsg->flag  = flag;
    GLCLIENT_END
}

void APIENTRY
glcltColor3b_InRGBA ( IN GLbyte red, IN GLbyte green, IN GLbyte blue )
{
    PA_COLOR_IN_RGB1(__GL_B_TO_FLOAT(red), __GL_B_TO_FLOAT(green),
	             __GL_B_TO_FLOAT(blue));
}

void APIENTRY
glcltColor3bv_InRGBA ( IN const GLbyte v[3] )
{
    PA_COLOR_IN_RGB1(__GL_B_TO_FLOAT(v[0]), __GL_B_TO_FLOAT(v[1]),
	             __GL_B_TO_FLOAT(v[2]));
}

void APIENTRY
glcltColor3d_InRGBA ( IN GLdouble red, IN GLdouble green, IN GLdouble blue )
{
    PA_COLOR_IN_RGB1((GLfloat) red, (GLfloat) green,
		     (GLfloat) blue);
}

void APIENTRY
glcltColor3dv_InRGBA ( IN const GLdouble v[3] )
{
    PA_COLOR_IN_RGB1((GLfloat) v[0], (GLfloat) v[1],
		     (GLfloat) v[2]);
}

#ifndef __GL_ASM_GLCLTCOLOR3F_INRGBA
void APIENTRY
glcltColor3f_InRGBA ( IN GLfloat red, IN GLfloat green, IN GLfloat blue )
{
    PA_COLOR_IN_RGB2(red, green, blue);
}
#endif // __GL_ASM_GLCLTCOLOR3F_INRGBA

#ifndef __GL_ASM_GLCLTCOLOR3FV_INRGBA
void APIENTRY
glcltColor3fv_InRGBA ( IN const GLfloat v[3] )
{
    GLfloat red, green, blue;

    red = (GLfloat) v[0];
    green = (GLfloat) v[1];
    blue = (GLfloat) v[2];

    PA_COLOR_IN_RGB2(red, green, blue);
}
#endif // __GL_ASM_GLCLTCOLOR3FV_INRGBA

void APIENTRY
glcltColor3i_InRGBA ( IN GLint red, IN GLint green, IN GLint blue )
{
    PA_COLOR_IN_RGB1(__GL_I_TO_FLOAT(red), __GL_I_TO_FLOAT(green),
	             __GL_I_TO_FLOAT(blue));
}

void APIENTRY
glcltColor3iv_InRGBA ( IN const GLint v[3] )
{
    PA_COLOR_IN_RGB1(__GL_I_TO_FLOAT(v[0]), __GL_I_TO_FLOAT(v[1]),
	             __GL_I_TO_FLOAT(v[2]));
}

void APIENTRY
glcltColor3s_InRGBA ( IN GLshort red, IN GLshort green, IN GLshort blue )
{
    PA_COLOR_IN_RGB1(__GL_S_TO_FLOAT(red), __GL_S_TO_FLOAT(green),
	             __GL_S_TO_FLOAT(blue));
}

void APIENTRY
glcltColor3sv_InRGBA ( IN const GLshort v[3] )
{
    PA_COLOR_IN_RGB1(__GL_S_TO_FLOAT(v[0]), __GL_S_TO_FLOAT(v[1]),
	             __GL_S_TO_FLOAT(v[2]));
}

void APIENTRY
glcltColor3ub_InRGBA ( IN GLubyte red, IN GLubyte green, IN GLubyte blue )
{
    PA_COLOR_IN_RGBA_NO_CLAMP1(__GL_UB_TO_FLOAT(red), __GL_UB_TO_FLOAT(green),
	             __GL_UB_TO_FLOAT(blue));
}

void APIENTRY
glcltColor3ubv_InRGBA ( IN const GLubyte v[3] )
{
    PA_COLOR_IN_RGBA_NO_CLAMP1(__GL_UB_TO_FLOAT(v[0]), __GL_UB_TO_FLOAT(v[1]),
	             __GL_UB_TO_FLOAT(v[2]));
}

void APIENTRY
glcltColor3ui_InRGBA ( IN GLuint red, IN GLuint green, IN GLuint blue )
{
    PA_COLOR_IN_RGB1(__GL_UI_TO_FLOAT(red), __GL_UI_TO_FLOAT(green),
	             __GL_UI_TO_FLOAT(blue));
}

void APIENTRY
glcltColor3uiv_InRGBA ( IN const GLuint v[3] )
{
    PA_COLOR_IN_RGB1(__GL_UI_TO_FLOAT(v[0]), __GL_UI_TO_FLOAT(v[1]),
	             __GL_UI_TO_FLOAT(v[2]));
}

void APIENTRY
glcltColor3us_InRGBA ( IN GLushort red, IN GLushort green, IN GLushort blue )
{
    PA_COLOR_IN_RGBA_NO_CLAMP1(__GL_US_TO_FLOAT(red), __GL_US_TO_FLOAT(green),
	             __GL_US_TO_FLOAT(blue));
}

void APIENTRY
glcltColor3usv_InRGBA ( IN const GLushort v[3] )
{
    PA_COLOR_IN_RGBA_NO_CLAMP1(__GL_US_TO_FLOAT(v[0]), __GL_US_TO_FLOAT(v[1]),
	             __GL_US_TO_FLOAT(v[2]));
}

void APIENTRY
glcltColor4b_InRGBA ( IN GLbyte red, IN GLbyte green, IN GLbyte blue, IN GLbyte alpha )
{
    PA_COLOR_IN_RGBA(__GL_B_TO_FLOAT(red), __GL_B_TO_FLOAT(green),
	             __GL_B_TO_FLOAT(blue), __GL_B_TO_FLOAT(alpha));
}

void APIENTRY
glcltColor4bv_InRGBA ( IN const GLbyte v[4] )
{
    PA_COLOR_IN_RGBA(__GL_B_TO_FLOAT(v[0]), __GL_B_TO_FLOAT(v[1]),
	             __GL_B_TO_FLOAT(v[2]), __GL_B_TO_FLOAT(v[3]));
}

void APIENTRY
glcltColor4d_InRGBA ( IN GLdouble red, IN GLdouble green, IN GLdouble blue, IN GLdouble alpha )
{
    PA_COLOR_IN_RGBA((GLfloat) red, (GLfloat) green,
		     (GLfloat) blue, (GLfloat) alpha);
}

void APIENTRY
glcltColor4dv_InRGBA ( IN const GLdouble v[4] )
{
    PA_COLOR_IN_RGBA((GLfloat) v[0], (GLfloat) v[1],
		     (GLfloat) v[2], (GLfloat) v[3]);
}

#ifndef __GL_ASM_GLCLTCOLOR4F_INRGBA
void APIENTRY
glcltColor4f_InRGBA ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha )
{
    PA_COLOR_IN_RGBA(red, green, blue, alpha);
}
#endif // __GL_ASM_GLCLTCOLOR4F_INRGBA

#ifndef __GL_ASM_GLCLTCOLOR4FV_INRGBA
void APIENTRY
glcltColor4fv_InRGBA ( IN const GLfloat v[4] )
{
    PA_COLOR_IN_RGBA(v[0], v[1], v[2], v[3]);
}
#endif // __GL_ASM_GLCLTCOLOR4FV_INRGBA

void APIENTRY
glcltColor4i_InRGBA ( IN GLint red, IN GLint green, IN GLint blue, IN GLint alpha )
{
    PA_COLOR_IN_RGBA(__GL_I_TO_FLOAT(red), __GL_I_TO_FLOAT(green),
	             __GL_I_TO_FLOAT(blue), __GL_I_TO_FLOAT(alpha));
}

void APIENTRY
glcltColor4iv_InRGBA ( IN const GLint v[4] )
{
    PA_COLOR_IN_RGBA(__GL_I_TO_FLOAT(v[0]), __GL_I_TO_FLOAT(v[1]),
	             __GL_I_TO_FLOAT(v[2]), __GL_I_TO_FLOAT(v[3]));
}

void APIENTRY
glcltColor4s_InRGBA ( IN GLshort red, IN GLshort green, IN GLshort blue, IN GLshort alpha )
{
    PA_COLOR_IN_RGBA(__GL_S_TO_FLOAT(red), __GL_S_TO_FLOAT(green),
	             __GL_S_TO_FLOAT(blue), __GL_S_TO_FLOAT(alpha));
}

void APIENTRY
glcltColor4sv_InRGBA ( IN const GLshort v[4] )
{
    PA_COLOR_IN_RGBA(__GL_S_TO_FLOAT(v[0]), __GL_S_TO_FLOAT(v[1]),
	             __GL_S_TO_FLOAT(v[2]), __GL_S_TO_FLOAT(v[3]));
}

void APIENTRY
glcltColor4ub_InRGBA ( IN GLubyte red, IN GLubyte green, IN GLubyte blue, IN GLubyte alpha )
{
    PA_COLOR_IN_RGBA_NO_CLAMP(__GL_UB_TO_FLOAT(red), __GL_UB_TO_FLOAT(green),
	             __GL_UB_TO_FLOAT(blue), __GL_UB_TO_FLOAT(alpha));
}

void APIENTRY
glcltColor4ubv_InRGBA ( IN const GLubyte v[4] )
{
    PA_COLOR_IN_RGBA_NO_CLAMP(__GL_UB_TO_FLOAT(v[0]), __GL_UB_TO_FLOAT(v[1]),
	             __GL_UB_TO_FLOAT(v[2]), __GL_UB_TO_FLOAT(v[3]));
}

void APIENTRY
glcltColor4ui_InRGBA ( IN GLuint red, IN GLuint green, IN GLuint blue, IN GLuint alpha )
{
    PA_COLOR_IN_RGBA(__GL_UI_TO_FLOAT(red), __GL_UI_TO_FLOAT(green),
	             __GL_UI_TO_FLOAT(blue), __GL_UI_TO_FLOAT(alpha));
}

void APIENTRY
glcltColor4uiv_InRGBA ( IN const GLuint v[4] )
{
    PA_COLOR_IN_RGBA(__GL_UI_TO_FLOAT(v[0]), __GL_UI_TO_FLOAT(v[1]),
	             __GL_UI_TO_FLOAT(v[2]), __GL_UI_TO_FLOAT(v[3]));
}

void APIENTRY
glcltColor4us_InRGBA ( IN GLushort red, IN GLushort green, IN GLushort blue, IN GLushort alpha )
{
    PA_COLOR_IN_RGBA_NO_CLAMP(__GL_US_TO_FLOAT(red), __GL_US_TO_FLOAT(green),
	             __GL_US_TO_FLOAT(blue), __GL_US_TO_FLOAT(alpha));
}

void APIENTRY
glcltColor4usv_InRGBA ( IN const GLushort v[4] )
{
    PA_COLOR_IN_RGBA_NO_CLAMP(__GL_US_TO_FLOAT(v[0]), __GL_US_TO_FLOAT(v[1]),
	             __GL_US_TO_FLOAT(v[2]), __GL_US_TO_FLOAT(v[3]));
}

void APIENTRY
glcltColor3b_InCI ( IN GLbyte red, IN GLbyte green, IN GLbyte blue )
{
    PA_COLOR_IN_CI(__GL_B_TO_FLOAT(red), __GL_B_TO_FLOAT(green),
	             __GL_B_TO_FLOAT(blue), __glOne);
}

void APIENTRY
glcltColor3bv_InCI ( IN const GLbyte v[3] )
{
    PA_COLOR_IN_CI(__GL_B_TO_FLOAT(v[0]), __GL_B_TO_FLOAT(v[1]),
	             __GL_B_TO_FLOAT(v[2]), __glOne);
}

void APIENTRY
glcltColor3d_InCI ( IN GLdouble red, IN GLdouble green, IN GLdouble blue )
{
    PA_COLOR_IN_CI((GLfloat) red, (GLfloat) green,
		     (GLfloat) blue, __glOne);
}

void APIENTRY
glcltColor3dv_InCI ( IN const GLdouble v[3] )
{
    PA_COLOR_IN_CI((GLfloat) v[0], (GLfloat) v[1],
		     (GLfloat) v[2], __glOne);
}

void APIENTRY
glcltColor3f_InCI ( IN GLfloat red, IN GLfloat green, IN GLfloat blue )
{
    PA_COLOR_IN_CI(red, green, blue, __glOne);
}

void APIENTRY
glcltColor3fv_InCI ( IN const GLfloat v[3] )
{
    PA_COLOR_IN_CI(v[0], v[1], v[2], __glOne);
}

void APIENTRY
glcltColor3i_InCI ( IN GLint red, IN GLint green, IN GLint blue )
{
    PA_COLOR_IN_CI(__GL_I_TO_FLOAT(red), __GL_I_TO_FLOAT(green),
	             __GL_I_TO_FLOAT(blue), __glOne);
}

void APIENTRY
glcltColor3iv_InCI ( IN const GLint v[3] )
{
    PA_COLOR_IN_CI(__GL_I_TO_FLOAT(v[0]), __GL_I_TO_FLOAT(v[1]),
	             __GL_I_TO_FLOAT(v[2]), __glOne);
}

void APIENTRY
glcltColor3s_InCI ( IN GLshort red, IN GLshort green, IN GLshort blue )
{
    PA_COLOR_IN_CI(__GL_S_TO_FLOAT(red), __GL_S_TO_FLOAT(green),
	             __GL_S_TO_FLOAT(blue), __glOne);
}

void APIENTRY
glcltColor3sv_InCI ( IN const GLshort v[3] )
{
    PA_COLOR_IN_CI(__GL_S_TO_FLOAT(v[0]), __GL_S_TO_FLOAT(v[1]),
	             __GL_S_TO_FLOAT(v[2]), __glOne);
}

void APIENTRY
glcltColor3ub_InCI ( IN GLubyte red, IN GLubyte green, IN GLubyte blue )
{
    PA_COLOR_IN_CI(__GL_UB_TO_FLOAT(red), __GL_UB_TO_FLOAT(green),
	             __GL_UB_TO_FLOAT(blue), __glOne);
}

void APIENTRY
glcltColor3ubv_InCI ( IN const GLubyte v[3] )
{
    PA_COLOR_IN_CI(__GL_UB_TO_FLOAT(v[0]), __GL_UB_TO_FLOAT(v[1]),
	             __GL_UB_TO_FLOAT(v[2]), __glOne);
}

void APIENTRY
glcltColor3ui_InCI ( IN GLuint red, IN GLuint green, IN GLuint blue )
{
    PA_COLOR_IN_CI(__GL_UI_TO_FLOAT(red), __GL_UI_TO_FLOAT(green),
	             __GL_UI_TO_FLOAT(blue), __glOne);
}

void APIENTRY
glcltColor3uiv_InCI ( IN const GLuint v[3] )
{
    PA_COLOR_IN_CI(__GL_UI_TO_FLOAT(v[0]), __GL_UI_TO_FLOAT(v[1]),
	             __GL_UI_TO_FLOAT(v[2]), __glOne);
}

void APIENTRY
glcltColor3us_InCI ( IN GLushort red, IN GLushort green, IN GLushort blue )
{
    PA_COLOR_IN_CI(__GL_US_TO_FLOAT(red), __GL_US_TO_FLOAT(green),
	             __GL_US_TO_FLOAT(blue), __glOne);
}

void APIENTRY
glcltColor3usv_InCI ( IN const GLushort v[3] )
{
    PA_COLOR_IN_CI(__GL_US_TO_FLOAT(v[0]), __GL_US_TO_FLOAT(v[1]),
	             __GL_US_TO_FLOAT(v[2]), __glOne);
}

void APIENTRY
glcltColor4b_InCI ( IN GLbyte red, IN GLbyte green, IN GLbyte blue, IN GLbyte alpha )
{
    PA_COLOR_IN_CI(__GL_B_TO_FLOAT(red), __GL_B_TO_FLOAT(green),
	             __GL_B_TO_FLOAT(blue), __GL_B_TO_FLOAT(alpha));
}

void APIENTRY
glcltColor4bv_InCI ( IN const GLbyte v[4] )
{
    PA_COLOR_IN_CI(__GL_B_TO_FLOAT(v[0]), __GL_B_TO_FLOAT(v[1]),
	             __GL_B_TO_FLOAT(v[2]), __GL_B_TO_FLOAT(v[3]));
}

void APIENTRY
glcltColor4d_InCI ( IN GLdouble red, IN GLdouble green, IN GLdouble blue, IN GLdouble alpha )
{
    PA_COLOR_IN_CI((GLfloat) red, (GLfloat) green,
		     (GLfloat) blue, (GLfloat) alpha);
}

void APIENTRY
glcltColor4dv_InCI ( IN const GLdouble v[4] )
{
    PA_COLOR_IN_CI((GLfloat) v[0], (GLfloat) v[1],
		     (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
glcltColor4f_InCI ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha )
{
    PA_COLOR_IN_CI(red, green, blue, alpha);
}

void APIENTRY
glcltColor4fv_InCI ( IN const GLfloat v[4] )
{
    PA_COLOR_IN_CI(v[0], v[1], v[2], v[3]);
}

void APIENTRY
glcltColor4i_InCI ( IN GLint red, IN GLint green, IN GLint blue, IN GLint alpha )
{
    PA_COLOR_IN_CI(__GL_I_TO_FLOAT(red), __GL_I_TO_FLOAT(green),
	             __GL_I_TO_FLOAT(blue), __GL_I_TO_FLOAT(alpha));
}

void APIENTRY
glcltColor4iv_InCI ( IN const GLint v[4] )
{
    PA_COLOR_IN_CI(__GL_I_TO_FLOAT(v[0]), __GL_I_TO_FLOAT(v[1]),
	             __GL_I_TO_FLOAT(v[2]), __GL_I_TO_FLOAT(v[3]));
}

void APIENTRY
glcltColor4s_InCI ( IN GLshort red, IN GLshort green, IN GLshort blue, IN GLshort alpha )
{
    PA_COLOR_IN_CI(__GL_S_TO_FLOAT(red), __GL_S_TO_FLOAT(green),
	             __GL_S_TO_FLOAT(blue), __GL_S_TO_FLOAT(alpha));
}

void APIENTRY
glcltColor4sv_InCI ( IN const GLshort v[4] )
{
    PA_COLOR_IN_CI(__GL_S_TO_FLOAT(v[0]), __GL_S_TO_FLOAT(v[1]),
	             __GL_S_TO_FLOAT(v[2]), __GL_S_TO_FLOAT(v[3]));
}

void APIENTRY
glcltColor4ub_InCI ( IN GLubyte red, IN GLubyte green, IN GLubyte blue, IN GLubyte alpha )
{
    PA_COLOR_IN_CI(__GL_UB_TO_FLOAT(red), __GL_UB_TO_FLOAT(green),
	             __GL_UB_TO_FLOAT(blue), __GL_UB_TO_FLOAT(alpha));
}

void APIENTRY
glcltColor4ubv_InCI ( IN const GLubyte v[4] )
{
    PA_COLOR_IN_CI(__GL_UB_TO_FLOAT(v[0]), __GL_UB_TO_FLOAT(v[1]),
	             __GL_UB_TO_FLOAT(v[2]), __GL_UB_TO_FLOAT(v[3]));
}

void APIENTRY
glcltColor4ui_InCI ( IN GLuint red, IN GLuint green, IN GLuint blue, IN GLuint alpha )
{
    PA_COLOR_IN_CI(__GL_UI_TO_FLOAT(red), __GL_UI_TO_FLOAT(green),
	             __GL_UI_TO_FLOAT(blue), __GL_UI_TO_FLOAT(alpha));
}

void APIENTRY
glcltColor4uiv_InCI ( IN const GLuint v[4] )
{
    PA_COLOR_IN_CI(__GL_UI_TO_FLOAT(v[0]), __GL_UI_TO_FLOAT(v[1]),
	             __GL_UI_TO_FLOAT(v[2]), __GL_UI_TO_FLOAT(v[3]));
}

void APIENTRY
glcltColor4us_InCI ( IN GLushort red, IN GLushort green, IN GLushort blue, IN GLushort alpha )
{
    PA_COLOR_IN_CI(__GL_US_TO_FLOAT(red), __GL_US_TO_FLOAT(green),
	             __GL_US_TO_FLOAT(blue), __GL_US_TO_FLOAT(alpha));
}

void APIENTRY
glcltColor4usv_InCI ( IN const GLushort v[4] )
{
    PA_COLOR_IN_CI(__GL_US_TO_FLOAT(v[0]), __GL_US_TO_FLOAT(v[1]),
	             __GL_US_TO_FLOAT(v[2]), __GL_US_TO_FLOAT(v[3]));
}

// Allocate a __GLmatChange structure.
//
// The POLYMATERIAL structure contains pointers to __GLmatChange arrays.
// These __GLmatChange structures are used to record material changes to
// vertices in the vertex buffer.
//
// To reduce memory requirement, the POLYMATERIAL structure keeps an array
// of pointers to __GLmatChange arrays.  Each __GLmatChange array is
// allocated as needed.
//
// An iMat index is used to keep track of the next free __GLmatChange
// entry.  When the poly array buffer is flushed in glsbAttention, iMat
// is reset to 0.
//
// The POLYMATERIAL structure and its __GLmatChange arrays are part of
// a thread local storage and are freed when the thread exits.

__GLmatChange * FASTCALL PAMatAlloc()
{
    POLYMATERIAL *pm;
    GLuint iArray, iMat;
#if DBG
    __GL_SETUP();
#endif

    pm = GLTEB_CLTPOLYMATERIAL();

// Allocate a POLYMATERIAL structure for this thread if one does not exist.

    if (!pm)
    {
        GLuint nv, aMatSize;
        __GL_SETUP();

        nv       = gc->vertex.pdBufSize;
        aMatSize = nv * 2 / POLYMATERIAL_ARRAY_SIZE + 1;

	if (!(pm = (POLYMATERIAL *) ALLOCZ(
		// Base size
		sizeof(POLYMATERIAL) - sizeof(__GLmatChange *) +
		// array of pointers to __GLmatChange arrays
		aMatSize * sizeof(__GLmatChange *) +
		// the PDMATERIAL array
		nv * sizeof(PDMATERIAL))))
	{
	    GLSETERROR(GL_OUT_OF_MEMORY);
	    return NULL;
	}

        pm->aMatSize = aMatSize;
        // Initialize pointer to the PDMATERIAL array
        pm->pdMaterial0 = (PDMATERIAL *) &pm->aMat[aMatSize];

        GLTEB_SET_CLTPOLYMATERIAL(pm);
    }

// Sanity check that pdBufSize has not changed.

    ASSERTOPENGL
    (
	pm->aMatSize == gc->vertex.pdBufSize * 2 / POLYMATERIAL_ARRAY_SIZE + 1,
	"vertex buffer size has changed!\n"
    );

// Find the material array from which to allocate the material change structure.

    iMat = pm->iMat;
    iArray = iMat / POLYMATERIAL_ARRAY_SIZE;
    iMat   = iMat % POLYMATERIAL_ARRAY_SIZE;

    ASSERTOPENGL(iArray < pm->aMatSize, "iArray exceeds range!\n");

// Allocate the material array if it has not been allocated.

    if (!(pm->aMat[iArray]))
    {
	if (!(pm->aMat[iArray] = (__GLmatChange *) ALLOC(
		sizeof(__GLmatChange) * POLYMATERIAL_ARRAY_SIZE)))
	{
	    GLSETERROR(GL_OUT_OF_MEMORY);
	    return NULL;
	}
    }

// Advance next available material pointer.

    pm->iMat++;
    ASSERTOPENGL(pm->iMat <= gc->vertex.pdBufSize * 2,
	"too many material changes!\n");

// Return the material change.

    return (&pm->aMat[iArray][iMat]);
}

// Free polymaterial for current thread.
void FASTCALL FreePolyMaterial(void)
{
    POLYMATERIAL *pm = GLTEB_CLTPOLYMATERIAL();
    GLuint i;

    if (pm)
    {
	for (i = 0; i < pm->aMatSize && pm->aMat[i]; i++)
	{
	    FREE(pm->aMat[i]);
	}
	FREE(pm);

	GLTEB_SET_CLTPOLYMATERIAL(NULL);
    }
}

#if !((POLYARRAY_MATERIAL_FRONT == POLYDATA_MATERIAL_FRONT)      \
   && (POLYARRAY_MATERIAL_BACK  == POLYDATA_MATERIAL_BACK))
#error "bad material mask\n"
#endif

void APIENTRY
glcltMaterialfv ( IN GLenum face, IN GLenum pname, IN const GLfloat params[] )
{
    POLYARRAY *pa;
    POLYDATA  *pd;
    GLuint    i, pdFlags, dirtyBits, matMask;
    POLYMATERIAL *pm;

    pa = GLTEB_CLTPOLYARRAY();

    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
        switch (pname)
        {
          case GL_SHININESS:
            if (params[0] < (GLfloat) 0 || params[0] > (GLfloat) 128)
            {
                GLSETERROR(GL_INVALID_VALUE);
                return;
            }
            dirtyBits = __GL_MATERIAL_SHININESS;
            break;
          case GL_EMISSION:
            dirtyBits = __GL_MATERIAL_EMISSIVE;
            break;
          case GL_AMBIENT:
            dirtyBits = __GL_MATERIAL_AMBIENT;
            break;
          case GL_DIFFUSE:
            dirtyBits = __GL_MATERIAL_DIFFUSE;
            break;
          case GL_SPECULAR:
            dirtyBits = __GL_MATERIAL_SPECULAR;
            break;
          case GL_AMBIENT_AND_DIFFUSE:
            dirtyBits = __GL_MATERIAL_AMBIENT | __GL_MATERIAL_DIFFUSE;
            break;
          case GL_COLOR_INDEXES:
            dirtyBits = __GL_MATERIAL_COLORINDEXES;
            break;
          default:
            GLSETERROR(GL_INVALID_ENUM);
            return;
        }

        switch (face)
        {
          case GL_FRONT:
            pdFlags = POLYDATA_MATERIAL_FRONT;
            break;
          case GL_BACK:
            pdFlags = POLYDATA_MATERIAL_BACK;
            break;
          case GL_FRONT_AND_BACK:
            pdFlags = POLYDATA_MATERIAL_FRONT | POLYDATA_MATERIAL_BACK;
            break;
          default:
            GLSETERROR(GL_INVALID_ENUM);
            return;
        }

// Update pa flags POLYARRAY_MATERIAL_FRONT and POLYARRAY_MATERIAL_BACK.

        pa->flags |= pdFlags;

// Do front and back material for this vertex
// Overwrite the previous material changes for this vertex if they exist since
// only the last material changes matter.

        pd = pa->pdNextVertex;

        for (i = 0, matMask = POLYDATA_MATERIAL_FRONT;
             i < 2;
             i++,   matMask = POLYDATA_MATERIAL_BACK)
        {
            __GLmatChange *pdMat;

            if (!(pdFlags & matMask))
                continue;

            // allocate __GLmatChange structure if this vertex hasn't got one
            if (!(pd->flags & matMask))
            {
                if (!(pdMat = PAMatAlloc()))
                    return;

                // Get POLYMATERIAL pointer after PAMatAlloc!
                pm = GLTEB_CLTPOLYMATERIAL();
                if (matMask == POLYDATA_MATERIAL_FRONT)
                    pm->pdMaterial0[pd - pa->pdBuffer0].front = pdMat;
                else
                    pm->pdMaterial0[pd - pa->pdBuffer0].back  = pdMat;

                pdMat->dirtyBits = dirtyBits;
            }
            else
            {
                pm = GLTEB_CLTPOLYMATERIAL();
                if (matMask == POLYDATA_MATERIAL_FRONT)
                    pdMat = pm->pdMaterial0[pd - pa->pdBuffer0].front;
                else
                    pdMat = pm->pdMaterial0[pd - pa->pdBuffer0].back;

                pdMat->dirtyBits |= dirtyBits;
            }

            if (dirtyBits & __GL_MATERIAL_SHININESS)
            {
                pdMat->shininess = params[0];
            }
            else if (dirtyBits & __GL_MATERIAL_COLORINDEXES)
            {
                pdMat->cmapa = params[0];
                pdMat->cmapd = params[1];
                pdMat->cmaps = params[2];
            }
            else if (dirtyBits & __GL_MATERIAL_EMISSIVE)
            {
                pdMat->emissive.r = params[0];
                pdMat->emissive.g = params[1];
                pdMat->emissive.b = params[2];
                pdMat->emissive.a = params[3];
            }
            else if (dirtyBits & __GL_MATERIAL_SPECULAR)
            {
                pdMat->specular.r = params[0];
                pdMat->specular.g = params[1];
                pdMat->specular.b = params[2];
                pdMat->specular.a = params[3];
            }
            else
            {
                // ambient and/or diffuse
                if (dirtyBits & __GL_MATERIAL_AMBIENT)
                {
                    pdMat->ambient.r = params[0];
                    pdMat->ambient.g = params[1];
                    pdMat->ambient.b = params[2];
                    pdMat->ambient.a = params[3];
                }
                if (dirtyBits & __GL_MATERIAL_DIFFUSE)
                {
                    pdMat->diffuse.r = params[0];
                    pdMat->diffuse.g = params[1];
                    pdMat->diffuse.b = params[2];
                    pdMat->diffuse.a = params[3];
                }
            }
        }
        
        // Finally, update pd flags

        pd->flags |= pdFlags;
    }
    else
    {
        int cArgs;

        switch (pname)
        {
          case GL_SHININESS:
            if (params[0] < (GLfloat) 0 || params[0] > (GLfloat) 128)
            {
                GLSETERROR(GL_INVALID_VALUE);
                return;
            }
            cArgs = 1;
            break;
          case GL_EMISSION:
          case GL_AMBIENT:
          case GL_DIFFUSE:
          case GL_SPECULAR:
          case GL_AMBIENT_AND_DIFFUSE:
            cArgs = 4;
            break;
          case GL_COLOR_INDEXES:
            cArgs = 3;
            break;
          default:
            GLSETERROR(GL_INVALID_ENUM);
            return;
        }

        switch (face)
        {
          case GL_FRONT:
          case GL_BACK:
          case GL_FRONT_AND_BACK:
            break;
          default:
            GLSETERROR(GL_INVALID_ENUM);
            return;
        }
        
        GLCLIENT_BEGIN( Materialfv, MATERIALFV )
          pMsg->face      = face;
          pMsg->pname     = pname;
          while (--cArgs >= 0)
              pMsg->params[cArgs] = params[cArgs];
        GLCLIENT_END
    }
}

void APIENTRY
glcltMaterialf ( IN GLenum face, IN GLenum pname, IN GLfloat param )
{
    if (pname != GL_SHININESS)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    glcltMaterialfv(face, pname, &param);
}

void APIENTRY
glcltMateriali ( IN GLenum face, IN GLenum pname, IN GLint param )
{
    GLfloat fParams[1];

    if (pname != GL_SHININESS)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    fParams[0] = (GLfloat) param;
    glcltMaterialfv(face, pname, fParams);
}

void APIENTRY
glcltMaterialiv ( IN GLenum face, IN GLenum pname, IN const GLint params[] )
{
    GLfloat fParams[4];

    switch (pname)
    {
      case GL_EMISSION:
      case GL_AMBIENT:
      case GL_DIFFUSE:
      case GL_SPECULAR:
      case GL_AMBIENT_AND_DIFFUSE:
	fParams[0] = __GL_I_TO_FLOAT(params[0]);
	fParams[1] = __GL_I_TO_FLOAT(params[1]);
	fParams[2] = __GL_I_TO_FLOAT(params[2]);
	fParams[3] = __GL_I_TO_FLOAT(params[3]);
        break;
      case GL_COLOR_INDEXES:
	fParams[2] = (GLfloat) params[2];
	fParams[1] = (GLfloat) params[1];
      case GL_SHININESS:
	fParams[0] = (GLfloat) params[0];
        break;
    }

    glcltMaterialfv(face, pname, fParams);
}

void APIENTRY
glcltEdgeFlag ( IN GLboolean flag )
{
    PA_EDGEFLAG(flag);
}

void APIENTRY
glcltEdgeFlagv ( IN const GLboolean flag[1] )
{
    PA_EDGEFLAG(flag[0]);
}

void APIENTRY
glcltIndexd_InCI ( IN GLdouble c )
{
    PA_INDEX_IN_CI((GLfloat) c);
}

void APIENTRY
glcltIndexdv_InCI ( IN const GLdouble c[1] )
{
    PA_INDEX_IN_CI((GLfloat) c[0]);
}

void APIENTRY
glcltIndexf_InCI ( IN GLfloat c )
{
    PA_INDEX_IN_CI((GLfloat) c);
}

void APIENTRY
glcltIndexfv_InCI ( IN const GLfloat c[1] )
{
    PA_INDEX_IN_CI((GLfloat) c[0]);
}

void APIENTRY
glcltIndexi_InCI ( IN GLint c )
{
    PA_INDEX_IN_CI((GLfloat) c);
}

void APIENTRY
glcltIndexiv_InCI ( IN const GLint c[1] )
{
    PA_INDEX_IN_CI((GLfloat) c[0]);
}

void APIENTRY
glcltIndexs_InCI ( IN GLshort c )
{
    PA_INDEX_IN_CI((GLfloat) c);
}

void APIENTRY
glcltIndexsv_InCI ( IN const GLshort c[1] )
{
    PA_INDEX_IN_CI((GLfloat) c[0]);
}

void APIENTRY
glcltIndexub_InCI ( IN GLubyte c )
{
    PA_INDEX_IN_CI((GLfloat) c);
}

void APIENTRY
glcltIndexubv_InCI ( IN const GLubyte c[1] )
{
    PA_INDEX_IN_CI((GLfloat) c[0]);
}

void APIENTRY
glcltIndexd_InRGBA ( IN GLdouble c )
{
    PA_INDEX_IN_RGBA((GLfloat) c);
}

void APIENTRY
glcltIndexdv_InRGBA ( IN const GLdouble c[1] )
{
    PA_INDEX_IN_RGBA((GLfloat) c[0]);
}

void APIENTRY
glcltIndexf_InRGBA ( IN GLfloat c )
{
    PA_INDEX_IN_RGBA((GLfloat) c);
}

void APIENTRY
glcltIndexfv_InRGBA ( IN const GLfloat c[1] )
{
    PA_INDEX_IN_RGBA((GLfloat) c[0]);
}

void APIENTRY
glcltIndexi_InRGBA ( IN GLint c )
{
    PA_INDEX_IN_RGBA((GLfloat) c);
}

void APIENTRY
glcltIndexiv_InRGBA ( IN const GLint c[1] )
{
    PA_INDEX_IN_RGBA((GLfloat) c[0]);
}

void APIENTRY
glcltIndexs_InRGBA ( IN GLshort c )
{
    PA_INDEX_IN_RGBA((GLfloat) c);
}

void APIENTRY
glcltIndexsv_InRGBA ( IN const GLshort c[1] )
{
    PA_INDEX_IN_RGBA((GLfloat) c[0]);
}

void APIENTRY
glcltIndexub_InRGBA ( IN GLubyte c )
{
    PA_INDEX_IN_RGBA((GLfloat) c);
}

void APIENTRY
glcltIndexubv_InRGBA ( IN const GLubyte c[1] )
{
    PA_INDEX_IN_RGBA((GLfloat) c[0]);
}

/******************************************************************/
void APIENTRY
glcltNormal3b ( IN GLbyte nx, IN GLbyte ny, IN GLbyte nz )
{
    PA_NORMAL(__GL_B_TO_FLOAT(nx), __GL_B_TO_FLOAT(ny), __GL_B_TO_FLOAT(nz));
}

void APIENTRY
glcltNormal3bv ( IN const GLbyte v[3] )
{
    PA_NORMAL(__GL_B_TO_FLOAT(v[0]), __GL_B_TO_FLOAT(v[1]), __GL_B_TO_FLOAT(v[2]));
}

void APIENTRY
glcltNormal3d ( IN GLdouble nx, IN GLdouble ny, IN GLdouble nz )
{
    PA_NORMAL((GLfloat) nx, (GLfloat) ny, (GLfloat) nz);
}

void APIENTRY
glcltNormal3dv ( IN const GLdouble v[3] )
{
    PA_NORMAL((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

#ifndef __GL_ASM_GLCLTNORMAL3F
void APIENTRY
glcltNormal3f ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    PA_NORMAL(x, y, z);
}
#endif //__GL_ASM_GLCLTNORMAL3F

#ifndef __GL_ASM_GLCLTNORMAL3FV
void APIENTRY
glcltNormal3fv ( IN const GLfloat v[3] )
{
    GLfloat x, y, z;

    x = v[0];
    y = v[1];
    z = v[2];

    PA_NORMAL(x, y, z);
}
#endif //__GL_ASM_GLCLTNORMAL3FV

void APIENTRY
glcltNormal3i ( IN GLint nx, IN GLint ny, IN GLint nz )
{
    PA_NORMAL(__GL_I_TO_FLOAT(nx), __GL_I_TO_FLOAT(ny), __GL_I_TO_FLOAT(nz));
}

void APIENTRY
glcltNormal3iv ( IN const GLint v[3] )
{
    PA_NORMAL(__GL_I_TO_FLOAT(v[0]), __GL_I_TO_FLOAT(v[1]), __GL_I_TO_FLOAT(v[2]));
}

void APIENTRY
glcltNormal3s ( IN GLshort nx, IN GLshort ny, IN GLshort nz )
{
    PA_NORMAL(__GL_S_TO_FLOAT(nx), __GL_S_TO_FLOAT(ny), __GL_S_TO_FLOAT(nz));
}

void APIENTRY
glcltNormal3sv ( IN const GLshort v[3] )
{
    PA_NORMAL(__GL_S_TO_FLOAT(v[0]), __GL_S_TO_FLOAT(v[1]), __GL_S_TO_FLOAT(v[2]));
}

void APIENTRY
glcltRasterPos2d ( IN GLdouble x, IN GLdouble y )
{
    glcltRasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) 0.0, (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos2dv ( IN const GLdouble v[2] )
{
    glcltRasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) 0.0, (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos2f ( IN GLfloat x, IN GLfloat y )
{
    glcltRasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) 0.0, (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos2fv ( IN const GLfloat v[2] )
{
    glcltRasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) 0.0, (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos2i ( IN GLint x, IN GLint y )
{
    glcltRasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) 0.0, (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos2iv ( IN const GLint v[2] )
{
    glcltRasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) 0.0, (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos2s ( IN GLshort x, IN GLshort y )
{
    glcltRasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) 0.0, (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos2sv ( IN const GLshort v[2] )
{
    glcltRasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) 0.0, (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos3d ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    glcltRasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos3dv ( IN const GLdouble v[3] )
{
    glcltRasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos3f ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    glcltRasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos3fv ( IN const GLfloat v[3] )
{
    glcltRasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos3i ( IN GLint x, IN GLint y, IN GLint z )
{
    glcltRasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos3iv ( IN const GLint v[3] )
{
    glcltRasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos3s ( IN GLshort x, IN GLshort y, IN GLshort z )
{
    glcltRasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos3sv ( IN const GLshort v[3] )
{
    glcltRasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos4d ( IN GLdouble x, IN GLdouble y, IN GLdouble z, IN GLdouble w )
{
    glcltRasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
glcltRasterPos4dv ( IN const GLdouble v[4] )
{
    glcltRasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
glcltRasterPos4f ( IN GLfloat x, IN GLfloat y, IN GLfloat z, IN GLfloat w )
{
    GLCLIENT_BEGIN( RasterPos4fv, RASTERPOS4FV )
        pMsg->v[0] = x;
        pMsg->v[1] = y;
        pMsg->v[2] = z;
        pMsg->v[3] = w;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltRasterPos4fv ( IN const GLfloat v[4] )
{
    glcltRasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
glcltRasterPos4i ( IN GLint x, IN GLint y, IN GLint z, IN GLint w )
{
    glcltRasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
glcltRasterPos4iv ( IN const GLint v[4] )
{
    glcltRasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
glcltRasterPos4s ( IN GLshort x, IN GLshort y, IN GLshort z, IN GLshort w )
{
    glcltRasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
glcltRasterPos4sv ( IN const GLshort v[4] )
{
    glcltRasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
glcltRectd ( IN GLdouble x1, IN GLdouble y1, IN GLdouble x2, IN GLdouble y2 )
{
    glcltRectf((GLfloat) x1, (GLfloat) y1, (GLfloat) x2, (GLfloat) y2);
}

void APIENTRY
glcltRectdv ( IN const GLdouble v1[2], IN const GLdouble v2[2] )
{
    glcltRectf((GLfloat) v1[0], (GLfloat) v1[1], (GLfloat) v2[0], (GLfloat) v2[1]);
}

void APIENTRY
glcltRectf ( IN GLfloat x1, IN GLfloat y1, IN GLfloat x2, IN GLfloat y2 )
{
    POLYARRAY *pa;

// Not allowed in begin/end.

    pa = GLTEB_CLTPOLYARRAY();
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

// Call Begin/End to do polyarray correctly.  Note that by calling these
// functions, we allow poly array to be batched correctly.
// Note also that we use quad strip instead of quad to force edge flag to be on.

    //!!! Conformance fails if we use QUAD_STRIP!
    //glcltBegin(GL_QUAD_STRIP);
    glcltBegin(GL_QUADS);
    pa->flags |= POLYARRAY_SAME_POLYDATA_TYPE;
    glcltVertex2f(x1, y1);
    glcltVertex2f(x2, y1);
    glcltVertex2f(x2, y2);
    glcltVertex2f(x1, y2);
    glcltEnd();
}

void APIENTRY
glcltRectfv ( IN const GLfloat v1[2], IN const GLfloat v2[2] )
{
    glcltRectf((GLfloat) v1[0], (GLfloat) v1[1], (GLfloat) v2[0], (GLfloat) v2[1]);
}

void APIENTRY
glcltRecti ( IN GLint x1, IN GLint y1, IN GLint x2, IN GLint y2 )
{
    glcltRectf((GLfloat) x1, (GLfloat) y1, (GLfloat) x2, (GLfloat) y2);
}

void APIENTRY
glcltRectiv ( IN const GLint v1[2], IN const GLint v2[2] )
{
    glcltRectf((GLfloat) v1[0], (GLfloat) v1[1], (GLfloat) v2[0], (GLfloat) v2[1]);
}

void APIENTRY
glcltRects ( IN GLshort x1, IN GLshort y1, IN GLshort x2, IN GLshort y2 )
{
    glcltRectf((GLfloat) x1, (GLfloat) y1, (GLfloat) x2, (GLfloat) y2);
}

void APIENTRY
glcltRectsv ( IN const GLshort v1[2], IN const GLshort v2[2] )
{
    glcltRectf((GLfloat) v1[0], (GLfloat) v1[1], (GLfloat) v2[0], (GLfloat) v2[1]);
}

void APIENTRY
glcltTexCoord1d ( IN GLdouble s )
{
    PA_TEXTURE1((GLfloat) s);
}

void APIENTRY
glcltTexCoord1dv ( IN const GLdouble v[1] )
{
    PA_TEXTURE1((GLfloat) v[0]);
}

void APIENTRY
glcltTexCoord1f ( IN GLfloat s )
{
    PA_TEXTURE1((GLfloat) s);
}

void APIENTRY
glcltTexCoord1fv ( IN const GLfloat v[1] )
{
    PA_TEXTURE1((GLfloat) v[0]);
}

void APIENTRY
glcltTexCoord1i ( IN GLint s )
{
    PA_TEXTURE1((GLfloat) s);
}

void APIENTRY
glcltTexCoord1iv ( IN const GLint v[1] )
{
    PA_TEXTURE1((GLfloat) v[0]);
}

void APIENTRY
glcltTexCoord1s ( IN GLshort s )
{
    PA_TEXTURE1((GLfloat) s);
}

void APIENTRY
glcltTexCoord1sv ( IN const GLshort v[1] )
{
    PA_TEXTURE1((GLfloat) v[0]);
}

void APIENTRY
glcltTexCoord2d ( IN GLdouble s, IN GLdouble t )
{
    PA_TEXTURE2((GLfloat) s, (GLfloat) t);
}

void APIENTRY
glcltTexCoord2dv ( IN const GLdouble v[2] )
{
    PA_TEXTURE2((GLfloat) v[0], (GLfloat) v[1]);
}

#ifndef __GL_ASM_GLCLTTEXCOORD2F
void APIENTRY
glcltTexCoord2f ( IN GLfloat s, IN GLfloat t )
{
    PA_TEXTURE2((GLfloat) s, (GLfloat) t);
}
#endif //__GL_ASM_GLCLTTEXCOORD2F

#ifndef __GL_ASM_GLCLTTEXCOORD2FV
void APIENTRY
glcltTexCoord2fv ( IN const GLfloat v[2] )
{
    PA_TEXTURE2((GLfloat) v[0], (GLfloat) v[1]);
}
#endif //__GL_ASM_GLCLTTEXCOORD2FV

void APIENTRY
glcltTexCoord2i ( IN GLint s, IN GLint t )
{
    PA_TEXTURE2((GLfloat) s, (GLfloat) t);
}

void APIENTRY
glcltTexCoord2iv ( IN const GLint v[2] )
{
    PA_TEXTURE2((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
glcltTexCoord2s ( IN GLshort s, IN GLshort t )
{
    PA_TEXTURE2((GLfloat) s, (GLfloat) t);
}

void APIENTRY
glcltTexCoord2sv ( IN const GLshort v[2] )
{
    PA_TEXTURE2((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
glcltTexCoord3d ( IN GLdouble s, IN GLdouble t, IN GLdouble r )
{
    PA_TEXTURE3((GLfloat) s, (GLfloat) t, (GLfloat) r);
}

void APIENTRY
glcltTexCoord3dv ( IN const GLdouble v[3] )
{
    PA_TEXTURE3((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

#ifndef __GL_ASM_GLCLTTEXCOORD3F
void APIENTRY
glcltTexCoord3f ( IN GLfloat s, IN GLfloat t, IN GLfloat r )
{
    PA_TEXTURE3((GLfloat) s, (GLfloat) t, (GLfloat) r);
}
#endif //__GL_ASM_GLCLTTEXCOORD3F

#ifndef __GL_ASM_GLCLTTEXCOORD3FV
void APIENTRY
glcltTexCoord3fv ( IN const GLfloat v[3] )
{
    PA_TEXTURE3((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}
#endif //__GL_ASM_GLCLTTEXCOORD3FV

void APIENTRY
glcltTexCoord3i ( IN GLint s, IN GLint t, IN GLint r )
{
    PA_TEXTURE3((GLfloat) s, (GLfloat) t, (GLfloat) r);
}

void APIENTRY
glcltTexCoord3iv ( IN const GLint v[3] )
{
    PA_TEXTURE3((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
glcltTexCoord3s ( IN GLshort s, IN GLshort t, IN GLshort r )
{
    PA_TEXTURE3((GLfloat) s, (GLfloat) t, (GLfloat) r);
}

void APIENTRY
glcltTexCoord3sv ( IN const GLshort v[3] )
{
    PA_TEXTURE3((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
glcltTexCoord4d ( IN GLdouble s, IN GLdouble t, IN GLdouble r, IN GLdouble q )
{
    PA_TEXTURE4((GLfloat) s, (GLfloat) t, (GLfloat) r, (GLfloat) q);
}

void APIENTRY
glcltTexCoord4dv ( IN const GLdouble v[4] )
{
    PA_TEXTURE4((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
glcltTexCoord4f ( IN GLfloat s, IN GLfloat t, IN GLfloat r, IN GLfloat q )
{
    PA_TEXTURE4((GLfloat) s, (GLfloat) t, (GLfloat) r, (GLfloat) q);
}

void APIENTRY
glcltTexCoord4fv ( IN const GLfloat v[4] )
{
    PA_TEXTURE4((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
glcltTexCoord4i ( IN GLint s, IN GLint t, IN GLint r, IN GLint q )
{
    PA_TEXTURE4((GLfloat) s, (GLfloat) t, (GLfloat) r, (GLfloat) q);
}

void APIENTRY
glcltTexCoord4iv ( IN const GLint v[4] )
{
    PA_TEXTURE4((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
glcltTexCoord4s ( IN GLshort s, IN GLshort t, IN GLshort r, IN GLshort q )
{
    PA_TEXTURE4((GLfloat) s, (GLfloat) t, (GLfloat) r, (GLfloat) q);
}

void APIENTRY
glcltTexCoord4sv ( IN const GLshort v[4] )
{
    PA_TEXTURE4((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

#ifdef GL_WIN_multiple_textures
void APIENTRY glcltMultiTexCoord1dWIN
    (GLbitfield mask, GLdouble s)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord1dvWIN
    (GLbitfield mask, const GLdouble *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord1fWIN
    (GLbitfield mask, GLfloat s)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord1fvWIN
    (GLbitfield mask, const GLfloat *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord1iWIN
    (GLbitfield mask, GLint s)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord1ivWIN
    (GLbitfield mask, const GLint *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord1sWIN
    (GLbitfield mask, GLshort s)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord1svWIN
    (GLbitfield mask, const GLshort *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord2dWIN
    (GLbitfield mask, GLdouble s, GLdouble t)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord2dvWIN
    (GLbitfield mask, const GLdouble *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord2fWIN
    (GLbitfield mask, GLfloat s, GLfloat t)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord2fvWIN
    (GLbitfield mask, const GLfloat *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord2iWIN
    (GLbitfield mask, GLint s, GLint t)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord2ivWIN
    (GLbitfield mask, const GLint *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord2sWIN
    (GLbitfield mask, GLshort s, GLshort t)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord2svWIN
    (GLbitfield mask, const GLshort *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord3dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord3dvWIN
    (GLbitfield mask, const GLdouble *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord3fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord3fvWIN
    (GLbitfield mask, const GLfloat *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord3iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord3ivWIN
    (GLbitfield mask, const GLint *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord3sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord3svWIN
    (GLbitfield mask, const GLshort *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord4dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord4dvWIN
    (GLbitfield mask, const GLdouble *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord4fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord4fvWIN
    (GLbitfield mask, const GLfloat *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord4iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r, GLint q)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord4ivWIN
    (GLbitfield mask, const GLint *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord4sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r, GLshort q)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord4svWIN
    (GLbitfield mask, const GLshort *v)
{
    // ATTENTION
}
#endif // GL_WIN_multiple_textures

void APIENTRY
glcltVertex2d ( IN GLdouble x, IN GLdouble y )
{
    PA_VERTEX2((GLfloat) x, (GLfloat) y);
}

void APIENTRY
glcltVertex2dv ( IN const GLdouble v[2] )
{
    PA_VERTEX2((GLfloat) v[0], (GLfloat) v[1]);
}

#ifndef __GL_ASM_GLCLTVERTEX2F
void APIENTRY
glcltVertex2f ( IN GLfloat x, IN GLfloat y )
{
    PA_VERTEX2((GLfloat) x, (GLfloat) y);
}
#endif //__GL_ASM_GLCLTVERTEX2F

#ifndef __GL_ASM_GLCLTVERTEX2FV
void APIENTRY
glcltVertex2fv ( IN const GLfloat v[2] )
{
    PA_VERTEX2((GLfloat) v[0], (GLfloat) v[1]);
}
#endif //__GL_ASM_GLCLTVERTEX2FV

void APIENTRY
glcltVertex2i ( IN GLint x, IN GLint y )
{
    PA_VERTEX2((GLfloat) x, (GLfloat) y);
}

void APIENTRY
glcltVertex2iv ( IN const GLint v[2] )
{
    PA_VERTEX2((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
glcltVertex2s ( IN GLshort x, IN GLshort y )
{
    PA_VERTEX2((GLfloat) x, (GLfloat) y);
}

void APIENTRY
glcltVertex2sv ( IN const GLshort v[2] )
{
    PA_VERTEX2((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
glcltVertex3d ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    PA_VERTEX3((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

void APIENTRY
glcltVertex3dv ( IN const GLdouble v[3] )
{
    PA_VERTEX3((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

#ifndef __GL_ASM_GLCLTVERTEX3F
void APIENTRY
glcltVertex3f ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    PA_VERTEX3((GLfloat) x, (GLfloat) y, (GLfloat) z);
}
#endif //__GL_ASM_GLCLTVERTEX3F

#ifndef __GL_ASM_GLCLTVERTEX3FV
void APIENTRY
glcltVertex3fv ( IN const GLfloat v[3] )
{
    GLfloat x1, y1, z1;

    x1 = (GLfloat) v[0];
    y1 = (GLfloat) v[1];
    z1 = (GLfloat) v[2];

    PA_VERTEX3(x1, y1, z1);

}
#endif //__GL_ASM_GLCLTVERTEX3FV

void APIENTRY
glcltVertex3i ( IN GLint x, IN GLint y, IN GLint z )
{
    PA_VERTEX3((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

void APIENTRY
glcltVertex3iv ( IN const GLint v[3] )
{
    PA_VERTEX3((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
glcltVertex3s ( IN GLshort x, IN GLshort y, IN GLshort z )
{
    PA_VERTEX3((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

void APIENTRY
glcltVertex3sv ( IN const GLshort v[3] )
{
    PA_VERTEX3((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
glcltVertex4d ( IN GLdouble x, IN GLdouble y, IN GLdouble z, IN GLdouble w )
{
    PA_VERTEX4((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
glcltVertex4dv ( IN const GLdouble v[4] )
{
    PA_VERTEX4((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
glcltVertex4f ( IN GLfloat x, IN GLfloat y, IN GLfloat z, IN GLfloat w )
{
    PA_VERTEX4((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
glcltVertex4fv ( IN const GLfloat v[4] )
{
    PA_VERTEX4((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
glcltVertex4i ( IN GLint x, IN GLint y, IN GLint z, IN GLint w )
{
    PA_VERTEX4((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
glcltVertex4iv ( IN const GLint v[4] )
{
    PA_VERTEX4((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
glcltVertex4s ( IN GLshort x, IN GLshort y, IN GLshort z, IN GLshort w )
{
    PA_VERTEX4((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
glcltVertex4sv ( IN const GLshort v[4] )
{
    PA_VERTEX4((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
glcltClipPlane ( IN GLenum plane, IN const GLdouble equation[4] )
{
    GLCLIENT_BEGIN( ClipPlane, CLIPPLANE )
        pMsg->plane    = plane   ;
        pMsg->equation[ 0] = equation[ 0];
        pMsg->equation[ 1] = equation[ 1];
        pMsg->equation[ 2] = equation[ 2];
        pMsg->equation[ 3] = equation[ 3];
    return;
    GLCLIENT_END
}

void APIENTRY
glcltColorMaterial ( IN GLenum face, IN GLenum mode )
{
    GLCLIENT_BEGIN( ColorMaterial, COLORMATERIAL )
        pMsg->face     = face    ;
        pMsg->mode     = mode    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltCullFace ( IN GLenum mode )
{
    GLCLIENT_BEGIN( CullFace, CULLFACE )
        pMsg->mode     = mode    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltFrontFace ( IN GLenum mode )
{
    GLCLIENT_BEGIN( FrontFace, FRONTFACE )
        pMsg->mode     = mode    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltHint ( IN GLenum target, IN GLenum mode )
{
    GLCLIENT_BEGIN( Hint, HINT )
        pMsg->target   = target  ;
        pMsg->mode     = mode    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltLineStipple ( IN GLint factor, IN GLushort pattern )
{
    GLCLIENT_BEGIN( LineStipple, LINESTIPPLE )
        pMsg->factor   = factor  ;
        pMsg->pattern  = pattern ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltLineWidth ( IN GLfloat width )
{
    GLCLIENT_BEGIN( LineWidth, LINEWIDTH )
        pMsg->width    = width   ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPointSize ( IN GLfloat size )
{
    GLCLIENT_BEGIN( PointSize, POINTSIZE )
        pMsg->size     = size    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPolygonMode ( IN GLenum face, IN GLenum mode )
{
    GLCLIENT_BEGIN( PolygonMode, POLYGONMODE )
        pMsg->face     = face    ;
        pMsg->mode     = mode    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltScissor ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height )
{
    GLCLIENT_BEGIN( Scissor, SCISSOR )
        pMsg->x        = x       ;
        pMsg->y        = y       ;
        pMsg->width    = width   ;
        pMsg->height   = height  ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltShadeModel ( IN GLenum mode )
{
    GLCLIENT_BEGIN( ShadeModel, SHADEMODEL )
        pMsg->mode     = mode    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltInitNames ( void )
{
    GLCLIENT_BEGIN( InitNames, INITNAMES )
    return;
    GLCLIENT_END
}

void APIENTRY
glcltLoadName ( IN GLuint name )
{
    GLCLIENT_BEGIN( LoadName, LOADNAME )
        pMsg->name     = name    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPassThrough ( IN GLfloat token )
{
    GLCLIENT_BEGIN( PassThrough, PASSTHROUGH )
        pMsg->token    = token   ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPopName ( void )
{
    GLCLIENT_BEGIN( PopName, POPNAME )
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPushName ( IN GLuint name )
{
    GLCLIENT_BEGIN( PushName, PUSHNAME )
        pMsg->name     = name    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltDrawBuffer ( IN GLenum mode )
{
// We're doing something special here.  By doing a glsbAttention after
// putting a glDrawBuffer in the batch, we are guaranteeing that all
// drawing done in the batch is in the same drawing mode and that the
// drawing mode cannot change until the end of the batch.  This allows
// the server to sample the current drawing mode at the beginning of
// batch and to assume that it is constant for the entire batch.
//
// The server might be able to take advantage of the fact, for example,
// that all drawing in a batch is only to the back buffer.

    GLCLIENT_BEGIN( DrawBuffer, DRAWBUFFER )
        pMsg->mode     = mode    ;
        glsbAttention();
    return;
    GLCLIENT_END
}

void APIENTRY
glcltClear ( IN GLbitfield mask )
{
    GLCLIENT_BEGIN( Clear, CLEAR )
        pMsg->mask     = mask    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltClearAccum ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha )
{
    GLCLIENT_BEGIN( ClearAccum, CLEARACCUM )
        pMsg->red      = red     ;
        pMsg->green    = green   ;
        pMsg->blue     = blue    ;
        pMsg->alpha    = alpha   ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltClearIndex ( IN GLfloat c )
{
    GLCLIENT_BEGIN( ClearIndex, CLEARINDEX )
        pMsg->c        = c       ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltClearColor ( IN GLclampf red, IN GLclampf green, IN GLclampf blue, IN GLclampf alpha )
{
    GLCLIENT_BEGIN( ClearColor, CLEARCOLOR )
        pMsg->red      = red     ;
        pMsg->green    = green   ;
        pMsg->blue     = blue    ;
        pMsg->alpha    = alpha   ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltClearStencil ( IN GLint s )
{
    GLCLIENT_BEGIN( ClearStencil, CLEARSTENCIL )
        pMsg->s        = s       ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltClearDepth ( IN GLclampd depth )
{
    GLCLIENT_BEGIN( ClearDepth, CLEARDEPTH )
        pMsg->depth    = depth   ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltStencilMask ( IN GLuint mask )
{
    GLCLIENT_BEGIN( StencilMask, STENCILMASK )
        pMsg->mask     = mask    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltColorMask ( IN GLboolean red, IN GLboolean green, IN GLboolean blue, IN GLboolean alpha )
{
    GLCLIENT_BEGIN( ColorMask, COLORMASK )
        pMsg->red      = red     ;
        pMsg->green    = green   ;
        pMsg->blue     = blue    ;
        pMsg->alpha    = alpha   ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltDepthMask ( IN GLboolean flag )
{
    GLCLIENT_BEGIN( DepthMask, DEPTHMASK )
        pMsg->flag     = flag    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltIndexMask ( IN GLuint mask )
{
    GLCLIENT_BEGIN( IndexMask, INDEXMASK )
        pMsg->mask     = mask    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltAccum ( IN GLenum op, IN GLfloat value )
{
    GLCLIENT_BEGIN( Accum, ACCUM )
        pMsg->op       = op      ;
        pMsg->value    = value   ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltDisable ( IN GLenum cap )
{
    __GL_SETUP();

    GLCLIENT_BEGIN( Disable, DISABLE )
        pMsg->cap      = cap     ;

	    // Set the enable flags for the evaluators
	    switch (cap)
        {
        case GL_MAP1_COLOR_4:
        case GL_MAP1_INDEX:
        case GL_MAP1_NORMAL:
        case GL_MAP1_TEXTURE_COORD_1:
        case GL_MAP1_TEXTURE_COORD_2:
        case GL_MAP1_TEXTURE_COORD_3:
        case GL_MAP1_TEXTURE_COORD_4:
        case GL_MAP1_VERTEX_3:
        case GL_MAP1_VERTEX_4:
            gc->eval.evalStateFlags |= __EVALS_AFFECTS_1D_EVAL;
            break;
        case GL_MAP2_COLOR_4:
        case GL_MAP2_INDEX:
        case GL_MAP2_NORMAL:
        case GL_MAP2_TEXTURE_COORD_1:
        case GL_MAP2_TEXTURE_COORD_2:
        case GL_MAP2_TEXTURE_COORD_3:
        case GL_MAP2_TEXTURE_COORD_4:
        case GL_MAP2_VERTEX_3:
        case GL_MAP2_VERTEX_4:
        case GL_NORMALIZE:
        case GL_AUTO_NORMAL:
            gc->eval.evalStateFlags |= __EVALS_AFFECTS_2D_EVAL;
            break;
        case GL_LIGHTING:
            gc->eval.evalStateFlags |= __EVALS_AFFECTS_ALL_EVAL;
            break;
        }
    return;
    GLCLIENT_END
}

void APIENTRY
glcltEnable ( IN GLenum cap )
{
    __GL_SETUP();
  
    GLCLIENT_BEGIN( Enable, ENABLE )
        pMsg->cap      = cap     ;

    // Set the enable flags for the evaluators
    switch (cap)
    {
    case GL_MAP1_COLOR_4:
    case GL_MAP1_INDEX:
    case GL_MAP1_NORMAL:
    case GL_MAP1_TEXTURE_COORD_1:
    case GL_MAP1_TEXTURE_COORD_2:
    case GL_MAP1_TEXTURE_COORD_3:
    case GL_MAP1_TEXTURE_COORD_4:
    case GL_MAP1_VERTEX_3:
    case GL_MAP1_VERTEX_4:
        gc->eval.evalStateFlags |= __EVALS_AFFECTS_1D_EVAL;
        break;
    case GL_MAP2_COLOR_4:
    case GL_MAP2_INDEX:
    case GL_MAP2_NORMAL:
    case GL_MAP2_TEXTURE_COORD_1:
    case GL_MAP2_TEXTURE_COORD_2:
    case GL_MAP2_TEXTURE_COORD_3:
    case GL_MAP2_TEXTURE_COORD_4:
    case GL_MAP2_VERTEX_3:
    case GL_MAP2_VERTEX_4:
    case GL_NORMALIZE:
    case GL_AUTO_NORMAL:
        gc->eval.evalStateFlags |= __EVALS_AFFECTS_2D_EVAL;
        break;
    case GL_LIGHTING:
        gc->eval.evalStateFlags |= __EVALS_AFFECTS_ALL_EVAL;
        break;
    }
    return;
    GLCLIENT_END
}

void APIENTRY
glcltFinish ( void )
{
// This function is invalid between glBegin and glEnd.
// This is detected in glsbAttention.

    glsbAttention();
}

void APIENTRY
glcltFlush ( void )
{
// This function is invalid between glBegin and glEnd.
// This is detected in glsbAttention.

    glsbAttention();
}

void APIENTRY
glcltPopAttrib ( void )
{
    __GL_SETUP();

    GLCLIENT_BEGIN( PopAttrib, POPATTRIB )
    if (gc->eval.evalStackState & 0x1)
    {
        gc->eval.evalStateFlags = gc->eval.evalStateFlags |
                                  __EVALS_AFFECTS_ALL_EVAL |
                                  __EVALS_POP_EVAL_ATTRIB;
    }
    gc->eval.evalStackState = (gc->eval.evalStackState) >> 1;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPushAttrib ( IN GLbitfield mask )
{
    __GL_SETUP ();
  
    // Assert that the stack size is always less than 31 since the
    // bitfield is a DWORD. 
    ASSERTOPENGL (gc->constants.maxAttribStackDepth < 31, "Attrib state stack is greater than the size of the bitfield used to track it\n");
    
    GLCLIENT_BEGIN( PushAttrib, PUSHATTRIB )
        pMsg->mask     = mask    ;
        gc->eval.evalStackState = (gc->eval.evalStackState) << 1;
        if (mask & GL_EVAL_BIT)
    	{
    	    gc->eval.evalStateFlags = gc->eval.evalStateFlags | 
                                      __EVALS_AFFECTS_ALL_EVAL |
                                      __EVALS_PUSH_EVAL_ATTRIB;
    		gc->eval.evalStackState = (gc->eval.evalStackState) | 0x1;
        }
    return;
    GLCLIENT_END
}




void APIENTRY
glcltAlphaFunc ( IN GLenum func, IN GLclampf ref )
{
    GLCLIENT_BEGIN( AlphaFunc, ALPHAFUNC )
        pMsg->func     = func    ;
        pMsg->ref      = ref     ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltBlendFunc ( IN GLenum sfactor, IN GLenum dfactor )
{
    GLCLIENT_BEGIN( BlendFunc, BLENDFUNC )
        pMsg->sfactor  = sfactor ;
        pMsg->dfactor  = dfactor ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltLogicOp ( IN GLenum opcode )
{
    GLCLIENT_BEGIN( LogicOp, LOGICOP )
        pMsg->opcode   = opcode  ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltStencilFunc ( IN GLenum func, IN GLint ref, IN GLuint mask )
{
    GLCLIENT_BEGIN( StencilFunc, STENCILFUNC )
        pMsg->func     = func    ;
        pMsg->ref      = ref     ;
        pMsg->mask     = mask    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltStencilOp ( IN GLenum fail, IN GLenum zfail, IN GLenum zpass )
{
    GLCLIENT_BEGIN( StencilOp, STENCILOP )
        pMsg->fail     = fail    ;
        pMsg->zfail    = zfail   ;
        pMsg->zpass    = zpass   ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltDepthFunc ( IN GLenum func )
{
    GLCLIENT_BEGIN( DepthFunc, DEPTHFUNC )
        pMsg->func     = func    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPixelZoom ( IN GLfloat xfactor, IN GLfloat yfactor )
{
    GLCLIENT_BEGIN( PixelZoom, PIXELZOOM )
        pMsg->xfactor  = xfactor ;
        pMsg->yfactor  = yfactor ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPixelTransferf ( IN GLenum pname, IN GLfloat param )
{
    GLCLIENT_BEGIN( PixelTransferf, PIXELTRANSFERF )
        pMsg->pname    = pname   ;
        pMsg->param    = param   ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPixelTransferi ( IN GLenum pname, IN GLint param )
{
    GLCLIENT_BEGIN( PixelTransferi, PIXELTRANSFERI )
        pMsg->pname    = pname   ;
        pMsg->param    = param   ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPixelStoref ( IN GLenum pname, IN GLfloat param )
{
    GLCLIENT_BEGIN( PixelStoref, PIXELSTOREF )
        pMsg->pname    = pname   ;
        pMsg->param    = param   ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPixelStorei ( IN GLenum pname, IN GLint param )
{
    GLCLIENT_BEGIN( PixelStorei, PIXELSTOREI )
        pMsg->pname    = pname   ;
        pMsg->param    = param   ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPixelMapfv ( IN GLenum map, IN GLint mapsize, IN const GLfloat values[] )
{
    GLCLIENT_BEGIN_LARGE_SET( PixelMapfv, PIXELMAPFV, values, ulSize, valuesOff )
        pMsg->map      = map     ;
        pMsg->mapsize  = mapsize ;
    GLCLIENT_END_LARGE_SET
    return;
}

void APIENTRY
glcltPixelMapuiv ( IN GLenum map, IN GLint mapsize, IN const GLuint values[] )
{
    GLCLIENT_BEGIN_LARGE_SET( PixelMapuiv, PIXELMAPUIV, values, ulSize, valuesOff )
        pMsg->map      = map     ;
        pMsg->mapsize  = mapsize ;
    GLCLIENT_END_LARGE_SET
    return;
}

void APIENTRY
glcltPixelMapusv ( IN GLenum map, IN GLint mapsize, IN const GLushort values[] )
{
    GLCLIENT_BEGIN_LARGE_SET( PixelMapusv, PIXELMAPUSV, values, ulSize, valuesOff )
        pMsg->map      = map     ;
        pMsg->mapsize  = mapsize ;
    GLCLIENT_END_LARGE_SET
    return;
}

void APIENTRY
glcltReadBuffer ( IN GLenum mode )
{
    GLCLIENT_BEGIN( ReadBuffer, READBUFFER )
        pMsg->mode     = mode    ;
        glsbAttention();
    return;
    GLCLIENT_END
}

void APIENTRY
glcltCopyPixels ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height, IN GLenum type )
{
    GLCLIENT_BEGIN( CopyPixels, COPYPIXELS )
        pMsg->x        = x       ;
        pMsg->y        = y       ;
        pMsg->width    = width   ;
        pMsg->height   = height  ;
        pMsg->type     = type    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltGetClipPlane ( IN GLenum plane, OUT GLdouble equation[4] )
{
    GLCLIENT_BEGIN( GetClipPlane, GETCLIPPLANE )
        pMsg->plane    = plane   ;
        pMsg->equation = equation;
        glsbAttention();
    return;
    GLCLIENT_END
}

GLenum APIENTRY
glcltGetError ( void )
{
    GLCLIENT_BEGIN( GetError, GETERROR )
        GLTEB_RETURNVALUE()  = GL_INVALID_OPERATION;   // assume error
        glsbAttention();
    return((GLenum)GLTEB_RETURNVALUE());
    GLCLIENT_END
}

void APIENTRY
glcltGetMapdv ( IN GLenum target, IN GLenum query, OUT GLdouble v[] )
{
    GLCLIENT_BEGIN_LARGE_GET( GetMapdv, GETMAPDV, v, ulSize, vOff )
        pMsg->target   = target  ;
        pMsg->query    = query   ;
    GLCLIENT_END_LARGE_GET
    return;
}

void APIENTRY
glcltGetMapfv ( IN GLenum target, IN GLenum query, OUT GLfloat v[] )
{
    GLCLIENT_BEGIN_LARGE_GET( GetMapfv, GETMAPFV, v, ulSize, vOff )
        pMsg->target   = target  ;
        pMsg->query    = query   ;
    GLCLIENT_END_LARGE_GET
    return;
}

void APIENTRY
glcltGetMapiv ( IN GLenum target, IN GLenum query, OUT GLint v[] )
{
    GLCLIENT_BEGIN_LARGE_GET( GetMapiv, GETMAPIV, v, ulSize, vOff )
        pMsg->target   = target  ;
        pMsg->query    = query   ;
    GLCLIENT_END_LARGE_GET
    return;
}

void APIENTRY
glcltGetPixelMapfv ( IN GLenum map, OUT GLfloat values[] )
{
    GLCLIENT_BEGIN_LARGE_GET( GetPixelMapfv, GETPIXELMAPFV, values, ulSize, valuesOff )
        pMsg->map      = map     ;
    GLCLIENT_END_LARGE_GET
    return;
}

void APIENTRY
glcltGetPixelMapuiv ( IN GLenum map, OUT GLuint values[] )
{
    GLCLIENT_BEGIN_LARGE_GET( GetPixelMapuiv, GETPIXELMAPUIV, values, ulSize, valuesOff )
        pMsg->map      = map     ;
    GLCLIENT_END_LARGE_GET
    return;
}

void APIENTRY
glcltGetPixelMapusv ( IN GLenum map, OUT GLushort values[] )
{
    GLCLIENT_BEGIN_LARGE_GET( GetPixelMapusv, GETPIXELMAPUSV, values, ulSize, valuesOff )
        pMsg->map      = map     ;
    GLCLIENT_END_LARGE_GET
    return;
}

GLboolean APIENTRY
glcltIsEnabled ( IN GLenum cap )
{
    GLCLIENT_BEGIN( IsEnabled, ISENABLED )
        pMsg->cap      = cap     ;
        GLTEB_RETURNVALUE()  = 0;              // assume error
        glsbAttention();
    return((GLboolean)GLTEB_RETURNVALUE());
    GLCLIENT_END
}

void APIENTRY
glcltDepthRange ( IN GLclampd zNear, IN GLclampd zFar )
{
    GLCLIENT_BEGIN( DepthRange, DEPTHRANGE )
        pMsg->zNear    = zNear   ;
        pMsg->zFar     = zFar    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltFrustum ( IN GLdouble left, IN GLdouble right, IN GLdouble bottom, IN GLdouble top, IN GLdouble zNear, IN GLdouble zFar )
{
    GLCLIENT_BEGIN( Frustum, FRUSTUM )
        pMsg->left     = left    ;
        pMsg->right    = right   ;
        pMsg->bottom   = bottom  ;
        pMsg->top      = top     ;
        pMsg->zNear    = zNear   ;
        pMsg->zFar     = zFar    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltLoadIdentity ( void )
{
    GLCLIENT_BEGIN( LoadIdentity, LOADIDENTITY )
    return;
    GLCLIENT_END
}

void APIENTRY
glcltLoadMatrixf ( IN const GLfloat m[16] )
{
    GLCLIENT_BEGIN( LoadMatrixf, LOADMATRIXF )
        pMsg->m[ 0] = m[ 0];
        pMsg->m[ 1] = m[ 1];
        pMsg->m[ 2] = m[ 2];
        pMsg->m[ 3] = m[ 3];
        pMsg->m[ 4] = m[ 4];
        pMsg->m[ 5] = m[ 5];
        pMsg->m[ 6] = m[ 6];
        pMsg->m[ 7] = m[ 7];
        pMsg->m[ 8] = m[ 8];
        pMsg->m[ 9] = m[ 9];
        pMsg->m[10] = m[10];
        pMsg->m[11] = m[11];
        pMsg->m[12] = m[12];
        pMsg->m[13] = m[13];
        pMsg->m[14] = m[14];
        pMsg->m[15] = m[15];
    return;
    GLCLIENT_END
}

void APIENTRY
glcltLoadMatrixd ( IN const GLdouble m[16] )
{
// Call LoadMatrixf instead

    GLCLIENT_BEGIN( LoadMatrixf, LOADMATRIXF )
        pMsg->m[ 0] = (GLfloat) m[ 0];
        pMsg->m[ 1] = (GLfloat) m[ 1];
        pMsg->m[ 2] = (GLfloat) m[ 2];
        pMsg->m[ 3] = (GLfloat) m[ 3];
        pMsg->m[ 4] = (GLfloat) m[ 4];
        pMsg->m[ 5] = (GLfloat) m[ 5];
        pMsg->m[ 6] = (GLfloat) m[ 6];
        pMsg->m[ 7] = (GLfloat) m[ 7];
        pMsg->m[ 8] = (GLfloat) m[ 8];
        pMsg->m[ 9] = (GLfloat) m[ 9];
        pMsg->m[10] = (GLfloat) m[10];
        pMsg->m[11] = (GLfloat) m[11];
        pMsg->m[12] = (GLfloat) m[12];
        pMsg->m[13] = (GLfloat) m[13];
        pMsg->m[14] = (GLfloat) m[14];
        pMsg->m[15] = (GLfloat) m[15];
    return;
    GLCLIENT_END
}

void APIENTRY
glcltMatrixMode ( IN GLenum mode )
{
    GLCLIENT_BEGIN( MatrixMode, MATRIXMODE )
        pMsg->mode     = mode    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltMultMatrixf ( IN const GLfloat m[16] )
{
    GLCLIENT_BEGIN( MultMatrixf, MULTMATRIXF )
        pMsg->m[ 0] = m[ 0];
        pMsg->m[ 1] = m[ 1];
        pMsg->m[ 2] = m[ 2];
        pMsg->m[ 3] = m[ 3];
        pMsg->m[ 4] = m[ 4];
        pMsg->m[ 5] = m[ 5];
        pMsg->m[ 6] = m[ 6];
        pMsg->m[ 7] = m[ 7];
        pMsg->m[ 8] = m[ 8];
        pMsg->m[ 9] = m[ 9];
        pMsg->m[10] = m[10];
        pMsg->m[11] = m[11];
        pMsg->m[12] = m[12];
        pMsg->m[13] = m[13];
        pMsg->m[14] = m[14];
        pMsg->m[15] = m[15];
    return;
    GLCLIENT_END
}

void APIENTRY
glcltMultMatrixd ( IN const GLdouble m[16] )
{
// Call MultMatrixf instead

    GLCLIENT_BEGIN( MultMatrixf, MULTMATRIXF )
        pMsg->m[ 0] = (GLfloat) m[ 0];
        pMsg->m[ 1] = (GLfloat) m[ 1];
        pMsg->m[ 2] = (GLfloat) m[ 2];
        pMsg->m[ 3] = (GLfloat) m[ 3];
        pMsg->m[ 4] = (GLfloat) m[ 4];
        pMsg->m[ 5] = (GLfloat) m[ 5];
        pMsg->m[ 6] = (GLfloat) m[ 6];
        pMsg->m[ 7] = (GLfloat) m[ 7];
        pMsg->m[ 8] = (GLfloat) m[ 8];
        pMsg->m[ 9] = (GLfloat) m[ 9];
        pMsg->m[10] = (GLfloat) m[10];
        pMsg->m[11] = (GLfloat) m[11];
        pMsg->m[12] = (GLfloat) m[12];
        pMsg->m[13] = (GLfloat) m[13];
        pMsg->m[14] = (GLfloat) m[14];
        pMsg->m[15] = (GLfloat) m[15];
    return;
    GLCLIENT_END
}

void APIENTRY
glcltOrtho ( IN GLdouble left, IN GLdouble right, IN GLdouble bottom, IN GLdouble top, IN GLdouble zNear, IN GLdouble zFar )
{
    GLCLIENT_BEGIN( Ortho, ORTHO )
        pMsg->left     = left    ;
        pMsg->right    = right   ;
        pMsg->bottom   = bottom  ;
        pMsg->top      = top     ;
        pMsg->zNear    = zNear   ;
        pMsg->zFar     = zFar    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPopMatrix ( void )
{
    GLCLIENT_BEGIN( PopMatrix, POPMATRIX )
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPushMatrix ( void )
{
    GLCLIENT_BEGIN( PushMatrix, PUSHMATRIX )
    return;
    GLCLIENT_END
}

void APIENTRY
glcltRotated ( IN GLdouble angle, IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
// Call Rotatef instead

    glcltRotatef((GLfloat) angle, (GLfloat) x, (GLfloat) y, (GLfloat) z);
}

void APIENTRY
glcltRotatef ( IN GLfloat angle, IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    GLCLIENT_BEGIN( Rotatef, ROTATEF )
        pMsg->angle    = angle   ;
        pMsg->x        = x       ;
        pMsg->y        = y       ;
        pMsg->z        = z       ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltScaled ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
// Call Scalef instead

    glcltScalef((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

void APIENTRY
glcltScalef ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    GLCLIENT_BEGIN( Scalef, SCALEF )
        pMsg->x        = x       ;
        pMsg->y        = y       ;
        pMsg->z        = z       ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltTranslated ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
// Call Translatef instead

    glcltTranslatef((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

void APIENTRY
glcltTranslatef ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    GLCLIENT_BEGIN( Translatef, TRANSLATEF )
        pMsg->x        = x       ;
        pMsg->y        = y       ;
        pMsg->z        = z       ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltViewport ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height )
{
    GLCLIENT_BEGIN( Viewport, VIEWPORT )
        pMsg->x        = x       ;
        pMsg->y        = y       ;
        pMsg->width    = width   ;
        pMsg->height   = height  ;
    return;
    GLCLIENT_END
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\glcltpt.c ===
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/


/*
 * AUTOMATICALLY UPDATED OR GENERATED BY SGI: DO NOT EDIT
 * IF YOU MUST MODIFY THIS FILE, PLEASE CONTACT ptar@sgi.com 415-390-1483
 */

/* Client Side Procedure Table */

#include "precomp.h"
#pragma hdrstop

#include "glclt.h"
#ifdef GL_METAFILE
#include "metasup.h"
#endif

// There are now 2 tables!
// One table is used for RGBA mode and the other is for CI mode.

GLCLTPROCTABLE glCltRGBAProcTable = {

/* Number of function entries in the table */

     sizeof(GLDISPATCHTABLE) / sizeof(PROC),

/* gl Entry points */
  {
     glcltNewList                ,
     glcltEndList                ,
     glcltCallList               ,
     glcltCallLists              ,
     glcltDeleteLists            ,
     glcltGenLists               ,
     glcltListBase               ,
     glcltBegin                  ,
     glcltBitmap                 ,
     glcltColor3b_InRGBA         ,
     glcltColor3bv_InRGBA        ,
     glcltColor3d_InRGBA         ,
     glcltColor3dv_InRGBA        ,
     glcltColor3f_InRGBA         ,
     glcltColor3fv_InRGBA        ,
     glcltColor3i_InRGBA         ,
     glcltColor3iv_InRGBA        ,
     glcltColor3s_InRGBA         ,
     glcltColor3sv_InRGBA        ,
     glcltColor3ub_InRGBA        ,
     glcltColor3ubv_InRGBA       ,
     glcltColor3ui_InRGBA        ,
     glcltColor3uiv_InRGBA       ,
     glcltColor3us_InRGBA        ,
     glcltColor3usv_InRGBA       ,
     glcltColor4b_InRGBA         ,
     glcltColor4bv_InRGBA        ,
     glcltColor4d_InRGBA         ,
     glcltColor4dv_InRGBA        ,
     glcltColor4f_InRGBA         ,
     glcltColor4fv_InRGBA        ,
     glcltColor4i_InRGBA         ,
     glcltColor4iv_InRGBA        ,
     glcltColor4s_InRGBA         ,
     glcltColor4sv_InRGBA        ,
     glcltColor4ub_InRGBA        ,
     glcltColor4ubv_InRGBA       ,
     glcltColor4ui_InRGBA        ,
     glcltColor4uiv_InRGBA       ,
     glcltColor4us_InRGBA        ,
     glcltColor4usv_InRGBA       ,
     glcltEdgeFlag               ,
     glcltEdgeFlagv              ,
     glcltEnd                    ,
     glcltIndexd_InRGBA          ,
     glcltIndexdv_InRGBA         ,
     glcltIndexf_InRGBA          ,
     glcltIndexfv_InRGBA         ,
     glcltIndexi_InRGBA          ,
     glcltIndexiv_InRGBA         ,
     glcltIndexs_InRGBA          ,
     glcltIndexsv_InRGBA         ,
     glcltNormal3b               ,
     glcltNormal3bv              ,
     glcltNormal3d               ,
     glcltNormal3dv              ,
     glcltNormal3f               ,
     glcltNormal3fv              ,
     glcltNormal3i               ,
     glcltNormal3iv              ,
     glcltNormal3s               ,
     glcltNormal3sv              ,
     glcltRasterPos2d            ,
     glcltRasterPos2dv           ,
     glcltRasterPos2f            ,
     glcltRasterPos2fv           ,
     glcltRasterPos2i            ,
     glcltRasterPos2iv           ,
     glcltRasterPos2s            ,
     glcltRasterPos2sv           ,
     glcltRasterPos3d            ,
     glcltRasterPos3dv           ,
     glcltRasterPos3f            ,
     glcltRasterPos3fv           ,
     glcltRasterPos3i            ,
     glcltRasterPos3iv           ,
     glcltRasterPos3s            ,
     glcltRasterPos3sv           ,
     glcltRasterPos4d            ,
     glcltRasterPos4dv           ,
     glcltRasterPos4f            ,
     glcltRasterPos4fv           ,
     glcltRasterPos4i            ,
     glcltRasterPos4iv           ,
     glcltRasterPos4s            ,
     glcltRasterPos4sv           ,
     glcltRectd                  ,
     glcltRectdv                 ,
     glcltRectf                  ,
     glcltRectfv                 ,
     glcltRecti                  ,
     glcltRectiv                 ,
     glcltRects                  ,
     glcltRectsv                 ,
     glcltTexCoord1d             ,
     glcltTexCoord1dv            ,
     glcltTexCoord1f             ,
     glcltTexCoord1fv            ,
     glcltTexCoord1i             ,
     glcltTexCoord1iv            ,
     glcltTexCoord1s             ,
     glcltTexCoord1sv            ,
     glcltTexCoord2d             ,
     glcltTexCoord2dv            ,
     glcltTexCoord2f             ,
     glcltTexCoord2fv            ,
     glcltTexCoord2i             ,
     glcltTexCoord2iv            ,
     glcltTexCoord2s             ,
     glcltTexCoord2sv            ,
     glcltTexCoord3d             ,
     glcltTexCoord3dv            ,
     glcltTexCoord3f             ,
     glcltTexCoord3fv            ,
     glcltTexCoord3i             ,
     glcltTexCoord3iv            ,
     glcltTexCoord3s             ,
     glcltTexCoord3sv            ,
     glcltTexCoord4d             ,
     glcltTexCoord4dv            ,
     glcltTexCoord4f             ,
     glcltTexCoord4fv            ,
     glcltTexCoord4i             ,
     glcltTexCoord4iv            ,
     glcltTexCoord4s             ,
     glcltTexCoord4sv            ,
     glcltVertex2d               ,
     glcltVertex2dv              ,
     glcltVertex2f               ,
     glcltVertex2fv              ,
     glcltVertex2i               ,
     glcltVertex2iv              ,
     glcltVertex2s               ,
     glcltVertex2sv              ,
     glcltVertex3d               ,
     glcltVertex3dv              ,
     glcltVertex3f               ,
     glcltVertex3fv              ,
     glcltVertex3i               ,
     glcltVertex3iv              ,
     glcltVertex3s               ,
     glcltVertex3sv              ,
     glcltVertex4d               ,
     glcltVertex4dv              ,
     glcltVertex4f               ,
     glcltVertex4fv              ,
     glcltVertex4i               ,
     glcltVertex4iv              ,
     glcltVertex4s               ,
     glcltVertex4sv              ,
     glcltClipPlane              ,
     glcltColorMaterial          ,
     glcltCullFace               ,
     glcltFogf                   ,
     glcltFogfv                  ,
     glcltFogi                   ,
     glcltFogiv                  ,
     glcltFrontFace              ,
     glcltHint                   ,
     glcltLightf                 ,
     glcltLightfv                ,
     glcltLighti                 ,
     glcltLightiv                ,
     glcltLightModelf            ,
     glcltLightModelfv           ,
     glcltLightModeli            ,
     glcltLightModeliv           ,
     glcltLineStipple            ,
     glcltLineWidth              ,
     glcltMaterialf              ,
     glcltMaterialfv             ,
     glcltMateriali              ,
     glcltMaterialiv             ,
     glcltPointSize              ,
     glcltPolygonMode            ,
     glcltPolygonStipple         ,
     glcltScissor                ,
     glcltShadeModel             ,
     glcltTexParameterf          ,
     glcltTexParameterfv         ,
     glcltTexParameteri          ,
     glcltTexParameteriv         ,
     glcltTexImage1D             ,
     glcltTexImage2D             ,
     glcltTexEnvf                ,
     glcltTexEnvfv               ,
     glcltTexEnvi                ,
     glcltTexEnviv               ,
     glcltTexGend                ,
     glcltTexGendv               ,
     glcltTexGenf                ,
     glcltTexGenfv               ,
     glcltTexGeni                ,
     glcltTexGeniv               ,
     glcltFeedbackBuffer         ,
     glcltSelectBuffer           ,
     glcltRenderMode             ,
     glcltInitNames              ,
     glcltLoadName               ,
     glcltPassThrough            ,
     glcltPopName                ,
     glcltPushName               ,
     glcltDrawBuffer             ,
     glcltClear                  ,
     glcltClearAccum             ,
     glcltClearIndex             ,
     glcltClearColor             ,
     glcltClearStencil           ,
     glcltClearDepth             ,
     glcltStencilMask            ,
     glcltColorMask              ,
     glcltDepthMask              ,
     glcltIndexMask              ,
     glcltAccum                  ,
     glcltDisable                ,
     glcltEnable                 ,
     glcltFinish                 ,
     glcltFlush                  ,
     glcltPopAttrib              ,
     glcltPushAttrib             ,
     glcltMap1d                  ,
     glcltMap1f                  ,
     glcltMap2d                  ,
     glcltMap2f                  ,
     glcltMapGrid1d              ,
     glcltMapGrid1f              ,
     glcltMapGrid2d              ,
     glcltMapGrid2f              ,
     glcltEvalCoord1d            ,
     glcltEvalCoord1dv           ,
     glcltEvalCoord1f            ,
     glcltEvalCoord1fv           ,
     glcltEvalCoord2d            ,
     glcltEvalCoord2dv           ,
     glcltEvalCoord2f            ,
     glcltEvalCoord2fv           ,
     glcltEvalMesh1              ,
     glcltEvalPoint1             ,
     glcltEvalMesh2              ,
     glcltEvalPoint2             ,
     glcltAlphaFunc              ,
     glcltBlendFunc              ,
     glcltLogicOp                ,
     glcltStencilFunc            ,
     glcltStencilOp              ,
     glcltDepthFunc              ,
     glcltPixelZoom              ,
     glcltPixelTransferf         ,
     glcltPixelTransferi         ,
     glcltPixelStoref            ,
     glcltPixelStorei            ,
     glcltPixelMapfv             ,
     glcltPixelMapuiv            ,
     glcltPixelMapusv            ,
     glcltReadBuffer             ,
     glcltCopyPixels             ,
     glcltReadPixels             ,
     glcltDrawPixels             ,
     glcltGetBooleanv            ,
     glcltGetClipPlane           ,
     glcltGetDoublev             ,
     glcltGetError               ,
     glcltGetFloatv              ,
     glcltGetIntegerv            ,
     glcltGetLightfv             ,
     glcltGetLightiv             ,
     glcltGetMapdv               ,
     glcltGetMapfv               ,
     glcltGetMapiv               ,
     glcltGetMaterialfv          ,
     glcltGetMaterialiv          ,
     glcltGetPixelMapfv          ,
     glcltGetPixelMapuiv         ,
     glcltGetPixelMapusv         ,
     glcltGetPolygonStipple      ,
     glcltGetString              ,
     glcltGetTexEnvfv            ,
     glcltGetTexEnviv            ,
     glcltGetTexGendv            ,
     glcltGetTexGenfv            ,
     glcltGetTexGeniv            ,
     glcltGetTexImage            ,
     glcltGetTexParameterfv      ,
     glcltGetTexParameteriv      ,
     glcltGetTexLevelParameterfv ,
     glcltGetTexLevelParameteriv ,
     glcltIsEnabled              ,
     glcltIsList                 ,
     glcltDepthRange             ,
     glcltFrustum                ,
     glcltLoadIdentity           ,
     glcltLoadMatrixf            ,
     glcltLoadMatrixd            ,
     glcltMatrixMode             ,
     glcltMultMatrixf            ,
     glcltMultMatrixd            ,
     glcltOrtho                  ,
     glcltPopMatrix              ,
     glcltPushMatrix             ,
     glcltRotated                ,
     glcltRotatef                ,
     glcltScaled                 ,
     glcltScalef                 ,
     glcltTranslated             ,
     glcltTranslatef             ,
     glcltViewport               ,
     glcltArrayElement           ,
     glcltBindTexture            ,
     glcltColorPointer           ,
     glcltDisableClientState     ,
     glcltDrawArrays             ,
     glcltDrawElements           ,
     glcltEdgeFlagPointer        ,
     glcltEnableClientState      ,
     glcltIndexPointer           ,
     glcltIndexub_InRGBA         ,
     glcltIndexubv_InRGBA        ,
     glcltInterleavedArrays      ,
     glcltNormalPointer          ,
     glcltPolygonOffset          ,
     glcltTexCoordPointer        ,
     glcltVertexPointer          ,
     glcltAreTexturesResident    ,
     glcltCopyTexImage1D         ,
     glcltCopyTexImage2D         ,
     glcltCopyTexSubImage1D      ,
     glcltCopyTexSubImage2D      ,
     glcltDeleteTextures         ,
     glcltGenTextures            ,
     glcltGetPointerv            ,
     glcltIsTexture              ,
     glcltPrioritizeTextures     ,
     glcltTexSubImage1D          ,
     glcltTexSubImage2D          ,
     glcltPopClientAttrib        ,
     glcltPushClientAttrib       ,
  }

};

GLCLTPROCTABLE glCltCIProcTable = {

/* Number of function entries in the table */

     sizeof(GLDISPATCHTABLE) / sizeof(PROC),

/* gl Entry points */
  {
     glcltNewList                ,
     glcltEndList                ,
     glcltCallList               ,
     glcltCallLists              ,
     glcltDeleteLists            ,
     glcltGenLists               ,
     glcltListBase               ,
     glcltBegin                  ,
     glcltBitmap                 ,
     glcltColor3b_InCI           ,
     glcltColor3bv_InCI          ,
     glcltColor3d_InCI           ,
     glcltColor3dv_InCI          ,
     glcltColor3f_InCI           ,
     glcltColor3fv_InCI          ,
     glcltColor3i_InCI           ,
     glcltColor3iv_InCI          ,
     glcltColor3s_InCI           ,
     glcltColor3sv_InCI          ,
     glcltColor3ub_InCI          ,
     glcltColor3ubv_InCI         ,
     glcltColor3ui_InCI          ,
     glcltColor3uiv_InCI         ,
     glcltColor3us_InCI          ,
     glcltColor3usv_InCI         ,
     glcltColor4b_InCI           ,
     glcltColor4bv_InCI          ,
     glcltColor4d_InCI           ,
     glcltColor4dv_InCI          ,
     glcltColor4f_InCI           ,
     glcltColor4fv_InCI          ,
     glcltColor4i_InCI           ,
     glcltColor4iv_InCI          ,
     glcltColor4s_InCI           ,
     glcltColor4sv_InCI          ,
     glcltColor4ub_InCI          ,
     glcltColor4ubv_InCI         ,
     glcltColor4ui_InCI          ,
     glcltColor4uiv_InCI         ,
     glcltColor4us_InCI          ,
     glcltColor4usv_InCI         ,
     glcltEdgeFlag               ,
     glcltEdgeFlagv              ,
     glcltEnd                    ,
     glcltIndexd_InCI            ,
     glcltIndexdv_InCI           ,
     glcltIndexf_InCI            ,
     glcltIndexfv_InCI           ,
     glcltIndexi_InCI            ,
     glcltIndexiv_InCI           ,
     glcltIndexs_InCI            ,
     glcltIndexsv_InCI           ,
     glcltNormal3b               ,
     glcltNormal3bv              ,
     glcltNormal3d               ,
     glcltNormal3dv              ,
     glcltNormal3f               ,
     glcltNormal3fv              ,
     glcltNormal3i               ,
     glcltNormal3iv              ,
     glcltNormal3s               ,
     glcltNormal3sv              ,
     glcltRasterPos2d            ,
     glcltRasterPos2dv           ,
     glcltRasterPos2f            ,
     glcltRasterPos2fv           ,
     glcltRasterPos2i            ,
     glcltRasterPos2iv           ,
     glcltRasterPos2s            ,
     glcltRasterPos2sv           ,
     glcltRasterPos3d            ,
     glcltRasterPos3dv           ,
     glcltRasterPos3f            ,
     glcltRasterPos3fv           ,
     glcltRasterPos3i            ,
     glcltRasterPos3iv           ,
     glcltRasterPos3s            ,
     glcltRasterPos3sv           ,
     glcltRasterPos4d            ,
     glcltRasterPos4dv           ,
     glcltRasterPos4f            ,
     glcltRasterPos4fv           ,
     glcltRasterPos4i            ,
     glcltRasterPos4iv           ,
     glcltRasterPos4s            ,
     glcltRasterPos4sv           ,
     glcltRectd                  ,
     glcltRectdv                 ,
     glcltRectf                  ,
     glcltRectfv                 ,
     glcltRecti                  ,
     glcltRectiv                 ,
     glcltRects                  ,
     glcltRectsv                 ,
     glcltTexCoord1d             ,
     glcltTexCoord1dv            ,
     glcltTexCoord1f             ,
     glcltTexCoord1fv            ,
     glcltTexCoord1i             ,
     glcltTexCoord1iv            ,
     glcltTexCoord1s             ,
     glcltTexCoord1sv            ,
     glcltTexCoord2d             ,
     glcltTexCoord2dv            ,
     glcltTexCoord2f             ,
     glcltTexCoord2fv            ,
     glcltTexCoord2i             ,
     glcltTexCoord2iv            ,
     glcltTexCoord2s             ,
     glcltTexCoord2sv            ,
     glcltTexCoord3d             ,
     glcltTexCoord3dv            ,
     glcltTexCoord3f             ,
     glcltTexCoord3fv            ,
     glcltTexCoord3i             ,
     glcltTexCoord3iv            ,
     glcltTexCoord3s             ,
     glcltTexCoord3sv            ,
     glcltTexCoord4d             ,
     glcltTexCoord4dv            ,
     glcltTexCoord4f             ,
     glcltTexCoord4fv            ,
     glcltTexCoord4i             ,
     glcltTexCoord4iv            ,
     glcltTexCoord4s             ,
     glcltTexCoord4sv            ,
     glcltVertex2d               ,
     glcltVertex2dv              ,
     glcltVertex2f               ,
     glcltVertex2fv              ,
     glcltVertex2i               ,
     glcltVertex2iv              ,
     glcltVertex2s               ,
     glcltVertex2sv              ,
     glcltVertex3d               ,
     glcltVertex3dv              ,
     glcltVertex3f               ,
     glcltVertex3fv              ,
     glcltVertex3i               ,
     glcltVertex3iv              ,
     glcltVertex3s               ,
     glcltVertex3sv              ,
     glcltVertex4d               ,
     glcltVertex4dv              ,
     glcltVertex4f               ,
     glcltVertex4fv              ,
     glcltVertex4i               ,
     glcltVertex4iv              ,
     glcltVertex4s               ,
     glcltVertex4sv              ,
     glcltClipPlane              ,
     glcltColorMaterial          ,
     glcltCullFace               ,
     glcltFogf                   ,
     glcltFogfv                  ,
     glcltFogi                   ,
     glcltFogiv                  ,
     glcltFrontFace              ,
     glcltHint                   ,
     glcltLightf                 ,
     glcltLightfv                ,
     glcltLighti                 ,
     glcltLightiv                ,
     glcltLightModelf            ,
     glcltLightModelfv           ,
     glcltLightModeli            ,
     glcltLightModeliv           ,
     glcltLineStipple            ,
     glcltLineWidth              ,
     glcltMaterialf              ,
     glcltMaterialfv             ,
     glcltMateriali              ,
     glcltMaterialiv             ,
     glcltPointSize              ,
     glcltPolygonMode            ,
     glcltPolygonStipple         ,
     glcltScissor                ,
     glcltShadeModel             ,
     glcltTexParameterf          ,
     glcltTexParameterfv         ,
     glcltTexParameteri          ,
     glcltTexParameteriv         ,
     glcltTexImage1D             ,
     glcltTexImage2D             ,
     glcltTexEnvf                ,
     glcltTexEnvfv               ,
     glcltTexEnvi                ,
     glcltTexEnviv               ,
     glcltTexGend                ,
     glcltTexGendv               ,
     glcltTexGenf                ,
     glcltTexGenfv               ,
     glcltTexGeni                ,
     glcltTexGeniv               ,
     glcltFeedbackBuffer         ,
     glcltSelectBuffer           ,
     glcltRenderMode             ,
     glcltInitNames              ,
     glcltLoadName               ,
     glcltPassThrough            ,
     glcltPopName                ,
     glcltPushName               ,
     glcltDrawBuffer             ,
     glcltClear                  ,
     glcltClearAccum             ,
     glcltClearIndex             ,
     glcltClearColor             ,
     glcltClearStencil           ,
     glcltClearDepth             ,
     glcltStencilMask            ,
     glcltColorMask              ,
     glcltDepthMask              ,
     glcltIndexMask              ,
     glcltAccum                  ,
     glcltDisable                ,
     glcltEnable                 ,
     glcltFinish                 ,
     glcltFlush                  ,
     glcltPopAttrib              ,
     glcltPushAttrib             ,
     glcltMap1d                  ,
     glcltMap1f                  ,
     glcltMap2d                  ,
     glcltMap2f                  ,
     glcltMapGrid1d              ,
     glcltMapGrid1f              ,
     glcltMapGrid2d              ,
     glcltMapGrid2f              ,
     glcltEvalCoord1d            ,
     glcltEvalCoord1dv           ,
     glcltEvalCoord1f            ,
     glcltEvalCoord1fv           ,
     glcltEvalCoord2d            ,
     glcltEvalCoord2dv           ,
     glcltEvalCoord2f            ,
     glcltEvalCoord2fv           ,
     glcltEvalMesh1              ,
     glcltEvalPoint1             ,
     glcltEvalMesh2              ,
     glcltEvalPoint2             ,
     glcltAlphaFunc              ,
     glcltBlendFunc              ,
     glcltLogicOp                ,
     glcltStencilFunc            ,
     glcltStencilOp              ,
     glcltDepthFunc              ,
     glcltPixelZoom              ,
     glcltPixelTransferf         ,
     glcltPixelTransferi         ,
     glcltPixelStoref            ,
     glcltPixelStorei            ,
     glcltPixelMapfv             ,
     glcltPixelMapuiv            ,
     glcltPixelMapusv            ,
     glcltReadBuffer             ,
     glcltCopyPixels             ,
     glcltReadPixels             ,
     glcltDrawPixels             ,
     glcltGetBooleanv            ,
     glcltGetClipPlane           ,
     glcltGetDoublev             ,
     glcltGetError               ,
     glcltGetFloatv              ,
     glcltGetIntegerv            ,
     glcltGetLightfv             ,
     glcltGetLightiv             ,
     glcltGetMapdv               ,
     glcltGetMapfv               ,
     glcltGetMapiv               ,
     glcltGetMaterialfv          ,
     glcltGetMaterialiv          ,
     glcltGetPixelMapfv          ,
     glcltGetPixelMapuiv         ,
     glcltGetPixelMapusv         ,
     glcltGetPolygonStipple      ,
     glcltGetString              ,
     glcltGetTexEnvfv            ,
     glcltGetTexEnviv            ,
     glcltGetTexGendv            ,
     glcltGetTexGenfv            ,
     glcltGetTexGeniv            ,
     glcltGetTexImage            ,
     glcltGetTexParameterfv      ,
     glcltGetTexParameteriv      ,
     glcltGetTexLevelParameterfv ,
     glcltGetTexLevelParameteriv ,
     glcltIsEnabled              ,
     glcltIsList                 ,
     glcltDepthRange             ,
     glcltFrustum                ,
     glcltLoadIdentity           ,
     glcltLoadMatrixf            ,
     glcltLoadMatrixd            ,
     glcltMatrixMode             ,
     glcltMultMatrixf            ,
     glcltMultMatrixd            ,
     glcltOrtho                  ,
     glcltPopMatrix              ,
     glcltPushMatrix             ,
     glcltRotated                ,
     glcltRotatef                ,
     glcltScaled                 ,
     glcltScalef                 ,
     glcltTranslated             ,
     glcltTranslatef             ,
     glcltViewport               ,
     glcltArrayElement           ,
     glcltBindTexture            ,
     glcltColorPointer           ,
     glcltDisableClientState     ,
     glcltDrawArrays             ,
     glcltDrawElements           ,
     glcltEdgeFlagPointer        ,
     glcltEnableClientState      ,
     glcltIndexPointer           ,
     glcltIndexub_InCI           ,
     glcltIndexubv_InCI          ,
     glcltInterleavedArrays      ,
     glcltNormalPointer          ,
     glcltPolygonOffset          ,
     glcltTexCoordPointer        ,
     glcltVertexPointer          ,
     glcltAreTexturesResident    ,
     glcltCopyTexImage1D         ,
     glcltCopyTexImage2D         ,
     glcltCopyTexSubImage1D      ,
     glcltCopyTexSubImage2D      ,
     glcltDeleteTextures         ,
     glcltGenTextures            ,
     glcltGetPointerv            ,
     glcltIsTexture              ,
     glcltPrioritizeTextures     ,
     glcltTexSubImage1D          ,
     glcltTexSubImage2D          ,
     glcltPopClientAttrib        ,
     glcltPushClientAttrib       ,
  }

};

GLEXTPROCTABLE glExtProcTable =
{
    /* Number of function entries in the table */
    sizeof(GLEXTDISPATCHTABLE) / sizeof(PROC),

    /* gl EXT Entry points */
    {
        glcltDrawRangeElementsWIN,
        glcltColorTableEXT,
        glcltColorSubTableEXT,
        glcltGetColorTableEXT,
        glcltGetColorTableParameterivEXT,
        glcltGetColorTableParameterfvEXT,
#ifdef GL_WIN_multiple_textures
        glcltCurrentTextureIndexWIN,
        glcltMultiTexCoord1dWIN,
        glcltMultiTexCoord1dvWIN,
        glcltMultiTexCoord1fWIN,
        glcltMultiTexCoord1fvWIN,
        glcltMultiTexCoord1iWIN,
        glcltMultiTexCoord1ivWIN,
        glcltMultiTexCoord1sWIN,
        glcltMultiTexCoord1svWIN,
        glcltMultiTexCoord2dWIN,
        glcltMultiTexCoord2dvWIN,
        glcltMultiTexCoord2fWIN,
        glcltMultiTexCoord2fvWIN,
        glcltMultiTexCoord2iWIN,
        glcltMultiTexCoord2ivWIN,
        glcltMultiTexCoord2sWIN,
        glcltMultiTexCoord2svWIN,
        glcltMultiTexCoord3dWIN,
        glcltMultiTexCoord3dvWIN,
        glcltMultiTexCoord3fWIN,
        glcltMultiTexCoord3fvWIN,
        glcltMultiTexCoord3iWIN,
        glcltMultiTexCoord3ivWIN,
        glcltMultiTexCoord3sWIN,
        glcltMultiTexCoord3svWIN,
        glcltMultiTexCoord4dWIN,
        glcltMultiTexCoord4dvWIN,
        glcltMultiTexCoord4fWIN,
        glcltMultiTexCoord4fvWIN,
        glcltMultiTexCoord4iWIN,
        glcltMultiTexCoord4ivWIN,
        glcltMultiTexCoord4sWIN,
        glcltMultiTexCoord4svWIN,
        glcltBindNthTextureWIN,
        glcltNthTexCombineFuncWIN,
#endif // GL_WIN_multiple_textures
    }
};

/******************************Public*Routine******************************\
* vInitTebCache
*
* Within the NT TEB, there is a table where OpenGL can cache OpenGL API
* function pointers.  In this area we can cache frequently used portions
* of the dispatch table.  Functions cached in this area can save a level
* of indirection by avoiding deferencing the dispatch table pointer.
*
* History:
*  06-Nov-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

// The following table defines the ranges of the dispatch table that should
// be cached in the TEB.  Each pair of indices defines the start and end of
// each range.

int static gaiCacheFuncs[] = {
    INDEX_glCallList    ,     INDEX_glCallLists   ,
    INDEX_glBegin       ,     INDEX_glBegin       ,
    INDEX_glColor3b     ,     INDEX_glNormal3sv   ,
    INDEX_glTexCoord1d  ,     INDEX_glVertex4sv   ,
    INDEX_glMaterialf   ,     INDEX_glMaterialiv  ,
    INDEX_glDisable     ,     INDEX_glEnable      ,
    INDEX_glPopAttrib   ,     INDEX_glPushAttrib  ,
    INDEX_glEvalCoord1d ,     INDEX_glEvalCoord2fv,
    INDEX_glEvalPoint1  ,     INDEX_glEvalPoint1  ,
    INDEX_glEvalPoint2  ,     INDEX_glEvalPoint2  ,
    INDEX_glLoadIdentity,     INDEX_glMultMatrixd ,
    INDEX_glPopMatrix   ,     INDEX_glTranslatef  ,
    INDEX_glArrayElement,     INDEX_glVertexPointer,
    INDEX_glGetPointerv,      INDEX_glGetPointerv ,
    INDEX_glPopClientAttrib,  INDEX_glPushClientAttrib,
    INDEX_glDrawRangeElementsWIN,    INDEX_glColorSubTableEXT,
#ifdef GL_WIN_multiple_textures
    INDEX_glCurrentTextureIndexWIN, INDEX_glCurrentTextureIndexWIN,
    INDEX_glBindNthTextureWIN, INDEX_glNthTexCombineFuncWIN,
    INDEX_glMultiTexCoord1fWIN, INDEX_glMultiTexCoord1ivWIN,
    INDEX_glMultiTexCoord2fWIN, INDEX_glMultiTexCoord2ivWIN,
#endif // GL_WIN_multiple_textures
};

void vInitTebCache(PVOID glTable)
{
    int iRange, iCache;
    PROC *pfnCltDispatchTableFast;

    pfnCltDispatchTableFast = (PROC *)GLTEB_CLTDISPATCHTABLE_FAST();

// Copy each range of FPs, defined by the table gaiCacheFuncs, from the
// dispatch table to the TEB FP cache.

    for ( iRange = 0, iCache = 0;
          iRange < (sizeof(gaiCacheFuncs) / sizeof(int));
          iRange+=2 )
    {
        PVOID pvCache;      // ptr into FP cache within TEB
        PVOID pvDispatch;   // ptr to current range within dispatch table
        int iNum;           // number of FPs in current range to cache

        pvCache = (PVOID)&pfnCltDispatchTableFast[iCache];
        pvDispatch = (PVOID)&((PROC *)glTable)[gaiCacheFuncs[iRange]];
        iNum = gaiCacheFuncs[iRange+1] - gaiCacheFuncs[iRange] + 1;

        ASSERTOPENGL((BYTE *)pvCache >= (BYTE *)pfnCltDispatchTableFast &&
		     (BYTE *)pvCache < (BYTE *)GLTEB_CLTPOLYARRAY() &&
		     ((PROC *)pvCache)+iNum <= (PROC *)GLTEB_CLTPOLYARRAY(),
                     "Fast dispatch area overflow\n");

        memcpy(pvCache, pvDispatch, iNum * sizeof(PROC));

        iCache += iNum;
    }

    ASSERTOPENGL(iCache == sizeof(GLDISPATCHTABLE_FAST) / sizeof(PROC),
		 "fast dispatch table not initialized properly\n");
}

/******************************Public*Routine******************************\
*
* SetCltProcTable
*
* Sets the client-side dispatch table or update the metafiling
* dispatch table if capturing
*
* History:
*  Fri Jan 05 16:37:40 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void SetCltProcTable(GLCLTPROCTABLE *pgcpt, GLEXTPROCTABLE *pgept,
                     BOOL fForce)
{
#ifdef GL_METAFILE
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();
    if (!fForce && plrc != NULL && plrc->fCapturing)
    {
        MetaSetCltProcTable(pgcpt, pgept);
    }
    else
#endif
    {
        // Copy base proc table
        memcpy((PVOID) CURRENT_GLTEBINFO()->glCltDispatchTable,
               &pgcpt->glDispatchTable,
               pgcpt->cEntries * sizeof(PROC));
        // If the given proc table doesn't have a complete set of entries,
        // pad it out with noops
        if (pgcpt->cEntries < OPENGL_VERSION_110_ENTRIES)
        {
            memcpy(((PROC *)CURRENT_GLTEBINFO()->glCltDispatchTable)+
                   pgcpt->cEntries,
                   ((PROC *)&glNullCltProcTable.glDispatchTable)+
                   pgcpt->cEntries,
                   (OPENGL_VERSION_110_ENTRIES-pgcpt->cEntries)*sizeof(PROC));
        }

        // Copy extension proc table
        // This is a purely internal table so it should always have the
        // right number of entries
        ASSERTOPENGL(pgept->cEntries == glNullExtProcTable.cEntries,
                     "Bad extension proc table\n");
        memcpy(CURRENT_GLTEBINFO()->glCltDispatchTable+
               GL_EXT_PROC_TABLE_OFFSET,
               &pgept->glDispatchTable,
               pgept->cEntries * sizeof(PROC));
        vInitTebCache(CURRENT_GLTEBINFO()->glCltDispatchTable);
    }
}

/******************************Public*Routine******************************\
*
* GetCltProcTable
*
* Gets the client-side dispatch table or the metafile capture
* exec table depending on the metafile capture state
*
* History:
*  Fri Jan 05 19:11:26 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void GetCltProcTable(GLCLTPROCTABLE *pgcpt, GLEXTPROCTABLE *pgept,
                     BOOL fForce)
{
#ifdef GL_METAFILE
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();
    if (!fForce && plrc != NULL && plrc->fCapturing)
    {
        MetaGetCltProcTable(pgcpt, pgept);
    }
    else
#endif
    {
	memcpy(&pgcpt->glDispatchTable,
	       (PVOID) CURRENT_GLTEBINFO()->glCltDispatchTable,
               pgcpt->cEntries * sizeof(PROC));
	memcpy(&pgept->glDispatchTable,
               CURRENT_GLTEBINFO()->glCltDispatchTable+GL_EXT_PROC_TABLE_OFFSET,
               pgept->cEntries * sizeof(PROC));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\glcltgsh.c ===
/******************************Module*Header*******************************\
* Module Name: glcltgsh.c
*
* OpenGL client side generic functions.
*
* Created: 11-7-1993
* Author: Hock San Lee [hockl]
*
* 08-Nov-1993   Added functions Pixel, Evaluators, GetString,
*               Feedback and Selection functions
*               Pierre Tardif, ptar@sgi.com
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

/* Generic OpenGL Client using subbatching. Hand coded functions */

#include "precomp.h"
#pragma hdrstop

#include "types.h"

#include "glsbmsg.h"
#include "glsbmsgh.h"
#include "glsrvspt.h"

#include "subbatch.h"
#include "batchinf.h"
#include "glsbcltu.h"
#include "glclt.h"
#include "compsize.h"

#include "glsize.h"

#include "context.h"
#include "global.h"
#include "lighting.h"

void APIENTRY
glcltFogf ( IN GLenum pname, IN GLfloat param )
{
// FOG_ASSERT

    if (!RANGE(pname,GL_FOG_INDEX,GL_FOG_MODE))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    glcltFogfv(pname, &param);
}

void APIENTRY
glcltFogfv ( IN GLenum pname, IN const GLfloat params[] )
{
// FOG_ASSERT

    if (!RANGE(pname,GL_FOG_INDEX,GL_FOG_COLOR))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( Fogfv, FOGFV )
        pMsg->pname     = pname;
        pMsg->params[0] = params[0];
        if (pname == GL_FOG_COLOR)
        {
            pMsg->params[1] = params[1];
            pMsg->params[2] = params[2];
            pMsg->params[3] = params[3];
        }
    GLCLIENT_END
    return;
}

void APIENTRY
glcltFogi ( IN GLenum pname, IN GLint param )
{
    GLfloat fParam;

// FOG_ASSERT

    if (!RANGE(pname,GL_FOG_INDEX,GL_FOG_MODE))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    fParam = (GLfloat) param;
    glcltFogfv(pname, &fParam);
}

void APIENTRY
glcltFogiv ( IN GLenum pname, IN const GLint params[] )
{
    GLfloat fParams[4];

    switch (pname)
    {
      case GL_FOG_INDEX:
      case GL_FOG_DENSITY:
      case GL_FOG_START:
      case GL_FOG_END:
      case GL_FOG_MODE:
	fParams[0] = (GLfloat) params[0];
        break;
      case GL_FOG_COLOR:
	fParams[0] = __GL_I_TO_FLOAT(params[0]);
	fParams[1] = __GL_I_TO_FLOAT(params[1]);
	fParams[2] = __GL_I_TO_FLOAT(params[2]);
	fParams[3] = __GL_I_TO_FLOAT(params[3]);
        break;
    }

    glcltFogfv(pname, fParams);
}

void APIENTRY
glcltLightf ( IN GLenum light, IN GLenum pname, IN GLfloat param )
{
// LIGHT_SOURCE_ASSERT

    if (!RANGE(pname,GL_SPOT_EXPONENT,GL_QUADRATIC_ATTENUATION))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    glcltLightfv(light, pname, &param);
}

void APIENTRY
glcltLightfv ( IN GLenum light, IN GLenum pname, IN const GLfloat params[] )
{
// LIGHT_SOURCE_ASSERT

    if (!RANGE(pname,GL_AMBIENT,GL_QUADRATIC_ATTENUATION))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( Lightfv, LIGHTFV )
        pMsg->light     = light;
        pMsg->pname     = pname;
        switch (pname)
        {
        case GL_AMBIENT:
        case GL_DIFFUSE:
        case GL_SPECULAR:
        case GL_POSITION:
            pMsg->params[3] = params[3];
        case GL_SPOT_DIRECTION:
            pMsg->params[2] = params[2];
            pMsg->params[1] = params[1];
        default:
            pMsg->params[0] = params[0];
        }
    GLCLIENT_END
    return;
}

void APIENTRY
glcltLighti ( IN GLenum light, IN GLenum pname, IN GLint param )
{
    GLfloat fParam;

// LIGHT_SOURCE_ASSERT

    if (!RANGE(pname,GL_SPOT_EXPONENT,GL_QUADRATIC_ATTENUATION))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    fParam = (GLfloat) param;
    glcltLightfv(light, pname, &fParam);
}

void APIENTRY
glcltLightiv ( IN GLenum light, IN GLenum pname, IN const GLint params[] )
{
    GLfloat fParams[4];

    switch (pname)
    {
      case GL_AMBIENT:
      case GL_DIFFUSE:
      case GL_SPECULAR:
	fParams[0] = __GL_I_TO_FLOAT(params[0]);
	fParams[1] = __GL_I_TO_FLOAT(params[1]);
	fParams[2] = __GL_I_TO_FLOAT(params[2]);
	fParams[3] = __GL_I_TO_FLOAT(params[3]);
        break;
      case GL_POSITION:
	fParams[3] = (GLfloat) params[3];
      case GL_SPOT_DIRECTION:
	fParams[2] = (GLfloat) params[2];
	fParams[1] = (GLfloat) params[1];
      case GL_SPOT_EXPONENT:
      case GL_SPOT_CUTOFF:
      case GL_CONSTANT_ATTENUATION:
      case GL_LINEAR_ATTENUATION:
      case GL_QUADRATIC_ATTENUATION:
	fParams[0] = (GLfloat) params[0];
        break;
    }

    glcltLightfv(light, pname, fParams);
}

void APIENTRY
glcltLightModelf ( IN GLenum pname, IN GLfloat param )
{
// LIGHT_MODEL_ASSERT

    if (!RANGE(pname,GL_LIGHT_MODEL_LOCAL_VIEWER,GL_LIGHT_MODEL_TWO_SIDE))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    glcltLightModelfv(pname, &param);
}

void APIENTRY
glcltLightModelfv ( IN GLenum pname, IN const GLfloat params[] )
{
// LIGHT_MODEL_ASSERT

    if (!RANGE(pname,GL_LIGHT_MODEL_LOCAL_VIEWER,GL_LIGHT_MODEL_AMBIENT))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( LightModelfv, LIGHTMODELFV )
        pMsg->pname     = pname;
        pMsg->params[0] = params[0];
        if (pname == GL_LIGHT_MODEL_AMBIENT)
        {
            pMsg->params[1] = params[1];
            pMsg->params[2] = params[2];
            pMsg->params[3] = params[3];
        }
    GLCLIENT_END
    return;
}

void APIENTRY
glcltLightModeli ( IN GLenum pname, IN GLint param )
{
    GLfloat fParam;

// LIGHT_MODEL_ASSERT

    if (!RANGE(pname,GL_LIGHT_MODEL_LOCAL_VIEWER,GL_LIGHT_MODEL_TWO_SIDE))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    fParam = (GLfloat) param;
    glcltLightModelfv(pname, &fParam);
}

void APIENTRY
glcltLightModeliv ( IN GLenum pname, IN const GLint params[] )
{
    GLfloat fParams[4];

    switch (pname)
    {
      case GL_LIGHT_MODEL_AMBIENT:
	fParams[0] = __GL_I_TO_FLOAT(params[0]);
	fParams[1] = __GL_I_TO_FLOAT(params[1]);
	fParams[2] = __GL_I_TO_FLOAT(params[2]);
	fParams[3] = __GL_I_TO_FLOAT(params[3]);
        break;
      case GL_LIGHT_MODEL_LOCAL_VIEWER:
      case GL_LIGHT_MODEL_TWO_SIDE:
	fParams[0] = (GLfloat) params[0];
        break;
    }

    glcltLightModelfv(pname, fParams);
}

void APIENTRY
glcltTexParameterf ( IN GLenum target, IN GLenum pname, IN GLfloat param )
{
// TEX_PARAMETER_ASSERT

    if (!RANGE(pname,GL_TEXTURE_MAG_FILTER,GL_TEXTURE_WRAP_T) &&
        pname != GL_TEXTURE_PRIORITY)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    glcltTexParameterfv(target, pname, &param);
}

void APIENTRY
glcltTexParameterfv ( IN GLenum target, IN GLenum pname, IN const GLfloat params[] )
{
    switch (pname) {
      case GL_TEXTURE_WRAP_S:
      case GL_TEXTURE_WRAP_T:
      case GL_TEXTURE_MIN_FILTER:
      case GL_TEXTURE_MAG_FILTER:
      case GL_TEXTURE_BORDER_COLOR:
      case GL_TEXTURE_PRIORITY:
        break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( TexParameterfv, TEXPARAMETERFV )
        pMsg->target = target;
        pMsg->pname  = pname;
        pMsg->params[0] = params[0];
        if (pname == GL_TEXTURE_BORDER_COLOR)
        {
            pMsg->params[1] = params[1];
            pMsg->params[2] = params[2];
            pMsg->params[3] = params[3];
        }
    GLCLIENT_END
    return;
}

void APIENTRY
glcltTexParameteri ( IN GLenum target, IN GLenum pname, IN GLint param )
{
// TEX_PARAMETER_ASSERT

    if (!RANGE(pname,GL_TEXTURE_MAG_FILTER,GL_TEXTURE_WRAP_T) &&
        pname != GL_TEXTURE_PRIORITY)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    glcltTexParameteriv(target, pname, &param);
}

void APIENTRY
glcltTexParameteriv ( IN GLenum target, IN GLenum pname, IN const GLint params[] )
{
    switch (pname) {
      case GL_TEXTURE_WRAP_S:
      case GL_TEXTURE_WRAP_T:
      case GL_TEXTURE_MIN_FILTER:
      case GL_TEXTURE_MAG_FILTER:
      case GL_TEXTURE_BORDER_COLOR:
      case GL_TEXTURE_PRIORITY:
        break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( TexParameteriv, TEXPARAMETERIV )
        pMsg->target = target;
        pMsg->pname  = pname;
        pMsg->params[0] = params[0];
        if (pname == GL_TEXTURE_BORDER_COLOR)
        {
            pMsg->params[1] = params[1];
            pMsg->params[2] = params[2];
            pMsg->params[3] = params[3];
        }
    GLCLIENT_END
    return;
}

void APIENTRY
glcltTexEnvf ( IN GLenum target, IN GLenum pname, IN GLfloat param )
{
    if (pname != GL_TEXTURE_ENV_MODE)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    glcltTexEnvfv(target, pname, &param);
}

void APIENTRY
glcltTexEnvfv ( IN GLenum target, IN GLenum pname, IN const GLfloat params[] )
{
    if (pname != GL_TEXTURE_ENV_MODE && pname != GL_TEXTURE_ENV_COLOR)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( TexEnvfv, TEXENVFV )
        pMsg->target    = target;
        pMsg->pname     = pname;
        pMsg->params[0] = params[0];
        if (pname == GL_TEXTURE_ENV_COLOR)
        {
            pMsg->params[1] = params[1];
            pMsg->params[2] = params[2];
            pMsg->params[3] = params[3];
        }
    GLCLIENT_END
    return;
}

void APIENTRY
glcltTexEnvi ( IN GLenum target, IN GLenum pname, IN GLint param )
{
    if (pname != GL_TEXTURE_ENV_MODE)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    glcltTexEnviv(target, pname, &param);
}

void APIENTRY
glcltTexEnviv ( IN GLenum target, IN GLenum pname, IN const GLint params[] )
{
    if (pname != GL_TEXTURE_ENV_MODE && pname != GL_TEXTURE_ENV_COLOR)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( TexEnviv, TEXENVIV )
        pMsg->target    = target;
        pMsg->pname     = pname;
        pMsg->params[0] = params[0];
        if (pname == GL_TEXTURE_ENV_COLOR)
        {
            pMsg->params[1] = params[1];
            pMsg->params[2] = params[2];
            pMsg->params[3] = params[3];
        }
    GLCLIENT_END
    return;
}

void APIENTRY
glcltTexGend ( IN GLenum coord, IN GLenum pname, IN GLdouble param )
{
    GLfloat fParam;

    if (pname != GL_TEXTURE_GEN_MODE)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    fParam = (GLfloat) param;
    glcltTexGenfv(coord, pname, &fParam);
}

void APIENTRY
glcltTexGendv ( IN GLenum coord, IN GLenum pname, IN const GLdouble params[] )
{
    GLfloat fParams[4];

    switch (pname)
    {
      case GL_OBJECT_PLANE:
      case GL_EYE_PLANE:
	fParams[3] = (GLfloat) params[3];
	fParams[2] = (GLfloat) params[2];
	fParams[1] = (GLfloat) params[1];
	// fall through
      case GL_TEXTURE_GEN_MODE:
	fParams[0] = (GLfloat) params[0];
        break;
    }

    glcltTexGenfv(coord, pname, fParams);
}

void APIENTRY
glcltTexGenf ( IN GLenum coord, IN GLenum pname, IN GLfloat param )
{
    if (pname != GL_TEXTURE_GEN_MODE)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    glcltTexGenfv(coord, pname, &param);
}

void APIENTRY
glcltTexGenfv ( IN GLenum coord, IN GLenum pname, IN const GLfloat params[] )
{
// TEX_GEN_ASSERT

    if (!RANGE(pname,GL_TEXTURE_GEN_MODE,GL_EYE_PLANE))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( TexGenfv, TEXGENFV )
        pMsg->coord     = coord;
        pMsg->pname     = pname;
        pMsg->params[0] = params[0];
        if (pname != GL_TEXTURE_GEN_MODE)
        {
            pMsg->params[1] = params[1];
            pMsg->params[2] = params[2];
            pMsg->params[3] = params[3];
        }
    GLCLIENT_END
    return;
}

void APIENTRY
glcltTexGeni ( IN GLenum coord, IN GLenum pname, IN GLint param )
{
    GLfloat fParam;

    if (pname != GL_TEXTURE_GEN_MODE)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    fParam = (GLfloat) param;
    glcltTexGenfv(coord, pname, &fParam);
}

void APIENTRY
glcltTexGeniv ( IN GLenum coord, IN GLenum pname, IN const GLint params[] )
{
    GLfloat fParams[4];

    switch (pname)
    {
      case GL_OBJECT_PLANE:
      case GL_EYE_PLANE:
	fParams[3] = (GLfloat) params[3];
	fParams[2] = (GLfloat) params[2];
	fParams[1] = (GLfloat) params[1];
	// fall through
      case GL_TEXTURE_GEN_MODE:
	fParams[0] = (GLfloat) params[0];
        break;
    }

    glcltTexGenfv(coord, pname, fParams);
}

void APIENTRY
glcltGetBooleanv ( IN GLenum pname, OUT GLboolean params[] )
{
#ifndef _CLIENTSIDE_
    int cArgs;

    cArgs = __glGet_size(pname);
    if (cArgs == 0)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }
    ASSERTOPENGL(cArgs <= 16, "bad get size");

    GLCLIENT_BEGIN( GetBooleanv, GETBOOLEANV )
        pMsg->pname = pname;
        glsbAttention();
        while (--cArgs >= 0)
            params[cArgs] = pMsg->params[cArgs];
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetBooleanv, GETBOOLEANV )
        pMsg->pname  = pname;
        pMsg->params = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetDoublev ( IN GLenum pname, OUT GLdouble params[] )
{
#ifndef _CLIENTSIDE_
    int cArgs;

    cArgs = __glGet_size(pname);
    if (cArgs == 0)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }
    ASSERTOPENGL(cArgs <= 16, "bad get size");

    GLCLIENT_BEGIN( GetDoublev, GETDOUBLEV )
        pMsg->pname = pname;
        glsbAttention();
        while (--cArgs >= 0)
            params[cArgs] = pMsg->params[cArgs];
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetDoublev, GETDOUBLEV )
        pMsg->pname  = pname;
        pMsg->params = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetFloatv ( IN GLenum pname, OUT GLfloat params[] )
{
#ifndef _CLIENTSIDE_
    int cArgs;

    cArgs = __glGet_size(pname);
    if (cArgs == 0)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }
    ASSERTOPENGL(cArgs <= 16, "bad get size");

    GLCLIENT_BEGIN( GetFloatv, GETFLOATV )
        pMsg->pname = pname;
        glsbAttention();
        while (--cArgs >= 0)
            params[cArgs] = pMsg->params[cArgs];
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetFloatv, GETFLOATV )
        pMsg->pname  = pname;
        pMsg->params = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetIntegerv ( IN GLenum pname, OUT GLint params[] )
{
#ifndef _CLIENTSIDE_
    int cArgs;

    cArgs = __glGet_size(pname);
    if (cArgs == 0)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }
    ASSERTOPENGL(cArgs <= 16, "bad get size");

    GLCLIENT_BEGIN( GetIntegerv, GETINTEGERV )
        pMsg->pname = pname;
        glsbAttention();
        while (--cArgs >= 0)
            params[cArgs] = pMsg->params[cArgs];
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetIntegerv, GETINTEGERV )
        pMsg->pname  = pname;
        pMsg->params = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetLightfv ( IN GLenum light, IN GLenum pname, OUT GLfloat params[] )
{
#ifndef _CLIENTSIDE_
// LIGHT_SOURCE_ASSERT

    if (!RANGE(pname,GL_AMBIENT,GL_QUADRATIC_ATTENUATION))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetLightfv, GETLIGHTFV )
        pMsg->light     = light;
        pMsg->pname     = pname;
        glsbAttention();
        switch (pname)
        {
        case GL_AMBIENT:
        case GL_DIFFUSE:
        case GL_SPECULAR:
        case GL_POSITION:
            params[3] = pMsg->params[3];
        case GL_SPOT_DIRECTION:
            params[2] = pMsg->params[2];
            params[1] = pMsg->params[1];
        default:
            params[0] = pMsg->params[0];
        }
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetLightfv, GETLIGHTFV )
        pMsg->light     = light;
        pMsg->pname     = pname;
        pMsg->params    = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetLightiv ( IN GLenum light, IN GLenum pname, OUT GLint params[] )
{
#ifndef _CLIENTSIDE_
// LIGHT_SOURCE_ASSERT

    if (!RANGE(pname,GL_AMBIENT,GL_QUADRATIC_ATTENUATION))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetLightiv, GETLIGHTIV )
        pMsg->light     = light;
        pMsg->pname     = pname;
        glsbAttention();
        switch (pname)
        {
        case GL_AMBIENT:
        case GL_DIFFUSE:
        case GL_SPECULAR:
        case GL_POSITION:
            params[3] = pMsg->params[3];
        case GL_SPOT_DIRECTION:
            params[2] = pMsg->params[2];
            params[1] = pMsg->params[1];
        default:
            params[0] = pMsg->params[0];
        }
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetLightiv, GETLIGHTIV )
        pMsg->light     = light;
        pMsg->pname     = pname;
        pMsg->params    = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetMaterialfv ( IN GLenum face, IN GLenum pname, OUT GLfloat params[] )
{
#ifndef _CLIENTSIDE_
    int cArgs;

    switch (pname) {
      case GL_SHININESS:
        cArgs = 1;
        break;
      case GL_EMISSION:
      case GL_AMBIENT:
      case GL_DIFFUSE:
      case GL_SPECULAR:
        cArgs = 4;
        break;
      case GL_COLOR_INDEXES:
        cArgs = 3;
        break;
      case GL_AMBIENT_AND_DIFFUSE:
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetMaterialfv, GETMATERIALFV )
        pMsg->face      = face;
        pMsg->pname     = pname;
        glsbAttention();
        while (--cArgs >= 0)
            params[cArgs] = pMsg->params[cArgs];
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetMaterialfv, GETMATERIALFV )
        pMsg->face      = face;
        pMsg->pname     = pname;
        pMsg->params    = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetMaterialiv ( IN GLenum face, IN GLenum pname, OUT GLint params[] )
{
#ifndef _CLIENTSIDE_
    int cArgs;

    switch (pname) {
      case GL_SHININESS:
        cArgs = 1;
        break;
      case GL_EMISSION:
      case GL_AMBIENT:
      case GL_DIFFUSE:
      case GL_SPECULAR:
        cArgs = 4;
        break;
      case GL_COLOR_INDEXES:
        cArgs = 3;
        break;
      case GL_AMBIENT_AND_DIFFUSE:
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetMaterialiv, GETMATERIALIV )
        pMsg->face      = face;
        pMsg->pname     = pname;
        glsbAttention();
        while (--cArgs >= 0)
            params[cArgs] = pMsg->params[cArgs];
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetMaterialiv, GETMATERIALIV )
        pMsg->face      = face;
        pMsg->pname     = pname;
        pMsg->params    = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetTexEnvfv ( IN GLenum target, IN GLenum pname, OUT GLfloat params[] )
{
#ifndef _CLIENTSIDE_
    if (pname != GL_TEXTURE_ENV_MODE && pname != GL_TEXTURE_ENV_COLOR)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetTexEnvfv, GETTEXENVFV )
        pMsg->target    = target;
        pMsg->pname     = pname;
        glsbAttention();
        params[0] = pMsg->params[0];
        if (pname == GL_TEXTURE_ENV_COLOR)
        {
            params[1] = pMsg->params[1];
            params[2] = pMsg->params[2];
            params[3] = pMsg->params[3];
        }
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetTexEnvfv, GETTEXENVFV )
        pMsg->target    = target;
        pMsg->pname     = pname;
        pMsg->params    = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetTexEnviv ( IN GLenum target, IN GLenum pname, OUT GLint params[] )
{
#ifndef _CLIENTSIDE_
    if (pname != GL_TEXTURE_ENV_MODE && pname != GL_TEXTURE_ENV_COLOR)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetTexEnviv, GETTEXENVIV )
        pMsg->target    = target;
        pMsg->pname     = pname;
        glsbAttention();
        params[0] = pMsg->params[0];
        if (pname == GL_TEXTURE_ENV_COLOR)
        {
            params[1] = pMsg->params[1];
            params[2] = pMsg->params[2];
            params[3] = pMsg->params[3];
        }
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetTexEnviv, GETTEXENVIV )
        pMsg->target    = target;
        pMsg->pname     = pname;
        pMsg->params    = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetTexGendv ( IN GLenum coord, IN GLenum pname, OUT GLdouble params[] )
{
#ifndef _CLIENTSIDE_
// TEX_GEN_ASSERT

    if (!RANGE(pname,GL_TEXTURE_GEN_MODE,GL_EYE_PLANE))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetTexGendv, GETTEXGENDV )
        pMsg->coord     = coord;
        pMsg->pname     = pname;
        glsbAttention();
        params[0] = pMsg->params[0];
        if (pname != GL_TEXTURE_GEN_MODE)
        {
            params[1] = pMsg->params[1];
            params[2] = pMsg->params[2];
            params[3] = pMsg->params[3];
        }
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetTexGendv, GETTEXGENDV )
        pMsg->coord     = coord;
        pMsg->pname     = pname;
        pMsg->params    = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetTexGenfv ( IN GLenum coord, IN GLenum pname, OUT GLfloat params[] )
{
#ifndef _CLIENTSIDE_
// TEX_GEN_ASSERT

    if (!RANGE(pname,GL_TEXTURE_GEN_MODE,GL_EYE_PLANE))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetTexGenfv, GETTEXGENFV )
        pMsg->coord     = coord;
        pMsg->pname     = pname;
        glsbAttention();
        params[0] = pMsg->params[0];
        if (pname != GL_TEXTURE_GEN_MODE)
        {
            params[1] = pMsg->params[1];
            params[2] = pMsg->params[2];
            params[3] = pMsg->params[3];
        }
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetTexGenfv, GETTEXGENFV )
        pMsg->coord     = coord;
        pMsg->pname     = pname;
        pMsg->params    = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetTexGeniv ( IN GLenum coord, IN GLenum pname, OUT GLint params[] )
{
#ifndef _CLIENTSIDE_
// TEX_GEN_ASSERT

    if (!RANGE(pname,GL_TEXTURE_GEN_MODE,GL_EYE_PLANE))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetTexGeniv, GETTEXGENIV )
        pMsg->coord     = coord;
        pMsg->pname     = pname;
        glsbAttention();
        params[0] = pMsg->params[0];
        if (pname != GL_TEXTURE_GEN_MODE)
        {
            params[1] = pMsg->params[1];
            params[2] = pMsg->params[2];
            params[3] = pMsg->params[3];
        }
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetTexGeniv, GETTEXGENIV )
        pMsg->coord     = coord;
        pMsg->pname     = pname;
        pMsg->params    = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetTexParameterfv ( IN GLenum target, IN GLenum pname, OUT GLfloat params[] )
{
#ifndef _CLIENTSIDE_
    switch (pname) {
      case GL_TEXTURE_WRAP_S:
      case GL_TEXTURE_WRAP_T:
      case GL_TEXTURE_MIN_FILTER:
      case GL_TEXTURE_MAG_FILTER:
      case GL_TEXTURE_BORDER_COLOR:
      case GL_TEXTURE_PRIORITY:
      case GL_TEXTURE_RESIDENT:
        break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetTexParameterfv, GETTEXPARAMETERFV )
        pMsg->target = target;
        pMsg->pname  = pname;
        glsbAttention();
        params[0] = pMsg->params[0];
        if (pname == GL_TEXTURE_BORDER_COLOR)
        {
            params[1] = pMsg->params[1];
            params[2] = pMsg->params[2];
            params[3] = pMsg->params[3];
        }
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetTexParameterfv, GETTEXPARAMETERFV )
        pMsg->target = target;
        pMsg->pname  = pname;
        pMsg->params = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetTexParameteriv ( IN GLenum target, IN GLenum pname, OUT GLint params[] )
{
#ifndef _CLIENTSIDE_
    switch (pname) {
      case GL_TEXTURE_WRAP_S:
      case GL_TEXTURE_WRAP_T:
      case GL_TEXTURE_MIN_FILTER:
      case GL_TEXTURE_MAG_FILTER:
      case GL_TEXTURE_BORDER_COLOR:
      case GL_TEXTURE_PRIORITY:
      case GL_TEXTURE_RESIDENT:
        break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetTexParameteriv, GETTEXPARAMETERIV )
        pMsg->target = target;
        pMsg->pname  = pname;
        glsbAttention();
        params[0] = pMsg->params[0];
        if (pname == GL_TEXTURE_BORDER_COLOR)
        {
            params[1] = pMsg->params[1];
            params[2] = pMsg->params[2];
            params[3] = pMsg->params[3];
        }
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetTexParameteriv, GETTEXPARAMETERIV )
        pMsg->target = target;
        pMsg->pname  = pname;
        pMsg->params = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetTexLevelParameterfv ( IN GLenum target, IN GLint level, IN GLenum pname, OUT GLfloat params[] )
{
#ifndef _CLIENTSIDE_
    switch (pname) {
      case GL_TEXTURE_WIDTH:
      case GL_TEXTURE_HEIGHT:
      case GL_TEXTURE_COMPONENTS:
      case GL_TEXTURE_BORDER:
        break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetTexLevelParameterfv, GETTEXLEVELPARAMETERFV )
        pMsg->target = target;
        pMsg->level  = level;
        pMsg->pname  = pname;
        glsbAttention();
        params[0] = pMsg->params[0];
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetTexLevelParameterfv, GETTEXLEVELPARAMETERFV )
        pMsg->target = target;
        pMsg->level  = level;
        pMsg->pname  = pname;
        pMsg->params = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetTexLevelParameteriv ( IN GLenum target, IN GLint level, IN GLenum pname, OUT GLint params[] )
{
#ifndef _CLIENTSIDE_
    switch (pname) {
      case GL_TEXTURE_WIDTH:
      case GL_TEXTURE_HEIGHT:
      case GL_TEXTURE_COMPONENTS:
      case GL_TEXTURE_BORDER:
        break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetTexLevelParameteriv, GETTEXLEVELPARAMETERIV )
        pMsg->target = target;
        pMsg->level  = level;
        pMsg->pname  = pname;
        glsbAttention();
        params[0] = pMsg->params[0];
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetTexLevelParameteriv, GETTEXLEVELPARAMETERIV )
        pMsg->target = target;
        pMsg->level  = level;
        pMsg->pname  = pname;
        pMsg->params = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

/******* Select and Feedback functions ******************************/

/*
 *  Note:
 *
 *      The size of the data is not required on the client side.
 *      Since calculating the size of the data requires
 *      knowledge of the visual type (RGBA/ColorIndex) it is
 *      appropriate to let the server calculate it.
 */

void APIENTRY
glcltFeedbackBuffer( IN GLsizei size, IN GLenum type, OUT GLfloat buffer[] )
{
#ifndef _CLIENTSIDE_
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_FEEDBACKBUFFER *pMsg;
    ULONG NextOffset;

    /* Set a pointer to the batch information structure */

    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();

    /* This is the first available byte after the message */

    NextOffset = pMsgBatchInfo->NextOffset +
            GLMSG_ALIGN(sizeof(GLMSG_FEEDBACKBUFFER));

    if ( NextOffset > pMsgBatchInfo->MaximumOffset )
    {
        /* No room for the message, flush the batch */

        glsbAttention();

        /* Reset NextOffset */

        NextOffset = pMsgBatchInfo->NextOffset +
                GLMSG_ALIGN(sizeof(GLMSG_FEEDBACKBUFFER));
    }

    /* This is where we will store our message */

    pMsg = (GLMSG_FEEDBACKBUFFER *)( ((BYTE *)pMsgBatchInfo) +
                pMsgBatchInfo->NextOffset);

    /* Set the ProcOffset for this function */

    pMsg->ProcOffset = offsetof(GLSRVSBPROCTABLE, glsrvFeedbackBuffer);

    /* Assign the members in the message */

    pMsg->size      = size;
    pMsg->type      = type;
    pMsg->bufferOff = (ULONG_PTR)buffer;

    pMsgBatchInfo->NextOffset = NextOffset;

    return;
#else
    GLCLIENT_BEGIN_LARGE_SET( FeedbackBuffer, FEEDBACKBUFFER, buffer, size, bufferOff )
        pMsg->size      = size;
        pMsg->type      = type;
    GLCLIENT_END_LARGE_SET
    return;
#endif // _CLIENTSIDE_
}

void APIENTRY
glcltSelectBuffer( IN GLsizei size, OUT GLuint buffer[] )
{
#ifndef _CLIENTSIDE_
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_SELECTBUFFER *pMsg;
    ULONG NextOffset;

    /* Set a pointer to the batch information structure */

    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();

    /* This is the first available byte after the message */

    NextOffset = pMsgBatchInfo->NextOffset +
            GLMSG_ALIGN(sizeof(GLMSG_SELECTBUFFER));

    if ( NextOffset > pMsgBatchInfo->MaximumOffset )
    {
        /* No room for the message, flush the batch */

        glsbAttention();

        /* Reset NextOffset */

        NextOffset = pMsgBatchInfo->NextOffset +
                GLMSG_ALIGN(sizeof(GLMSG_SELECTBUFFER));
    }

    /* This is where we will store our message */

    pMsg = (GLMSG_SELECTBUFFER *)( ((BYTE *)pMsgBatchInfo) +
                pMsgBatchInfo->NextOffset);

    /* Set the ProcOffset for this function */

    pMsg->ProcOffset = offsetof(GLSRVSBPROCTABLE, glsrvSelectBuffer);

    /* Assign the members in the message */

    pMsg->size      = size;
    pMsg->bufferOff = (ULONG_PTR)buffer;

    pMsgBatchInfo->NextOffset = NextOffset;

    return;
#else
    GLCLIENT_BEGIN_LARGE_SET( SelectBuffer, SELECTBUFFER, buffer, size, bufferOff )
        pMsg->size      = size;
    GLCLIENT_END_LARGE_SET
    return;
#endif // _CLIENTSIDE_
}

GLint APIENTRY
glcltRenderMode( IN GLenum mode )
{
    GLCLIENT_BEGIN( RenderMode, RENDERMODE )
        pMsg->mode     = mode    ;
        GLTEB_RETURNVALUE()  = 0;              // assume error
        glsbAttention();
    return( (GLint)GLTEB_RETURNVALUE() );
    GLCLIENT_END
}

const GLubyte * APIENTRY
glcltGetString( IN GLenum name )
{
    switch (name)
    {
        case GL_VENDOR:
            return("Microsoft Corporation");
        case GL_RENDERER:
            return("GDI Generic");
        case GL_VERSION:
// Version numbers
//   WinNT 3.5:     1.0
//   WinNT 3.51:    1.01
//   Win95 beta:    1.015
//   Win95:         1.02
//   WinNT 4.0:     1.1.0
            return("1.1.0");
        case GL_EXTENSIONS:
#ifdef GL_WIN_swap_hint
            return "GL_WIN_swap_hint"
#endif
#ifdef GL_EXT_bgra
                   " GL_EXT_bgra"
#endif
#ifdef GL_EXT_paletted_texture
		   " GL_EXT_paletted_texture"
#endif
#ifdef GL_WIN_phong_shading
		   " GL_WIN_phong_shading"
#endif
#ifdef GL_EXT_flat_paletted_lighting
                   " GL_EXT_flat_paletted_lighting"
#endif
#ifdef GL_WIN_specular_fog
		   " GL_WIN_specular_fog"
#endif //GL_WIN_specular_fog
#ifdef GL_WIN_multiple_textures
                   " GL_WIN_multiple_textures"
#endif
		   ;
    }
    GLSETERROR(GL_INVALID_ENUM);
    return((const GLubyte *)0);
}

/*********** Evaluator functions ************************************/
// Look in eval.c


/*********** Pixel Functions ****************************************/

void APIENTRY
glcltReadPixels (   IN GLint x,
                    IN GLint y,
                    IN GLsizei width,
                    IN GLsizei height,
                    IN GLenum format,
                    IN GLenum type,
                    OUT GLvoid *pixels
                )
{
#ifndef _CLIENTSIDE_
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_READPIXELS *pMsg;
    ULONG NextOffset;

    /* Set a pointer to the batch information structure */

    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();

    /* Tentative offset, where we may want to place our data   */
    /* This is also the first available byte after the message */

    NextOffset = pMsgBatchInfo->NextOffset +
            GLMSG_ALIGN(sizeof(*pMsg));

    if ( NextOffset > pMsgBatchInfo->MaximumOffset )
    {
        /* No room for the message, flush the batch */

        glsbAttention();

        /* Reset NextOffset */

        NextOffset = pMsgBatchInfo->NextOffset +
                GLMSG_ALIGN(sizeof(*pMsg));
    }

    /* This is where we will store our message */

    pMsg = (GLMSG_READPIXELS *)( ((BYTE *)pMsgBatchInfo) +
                pMsgBatchInfo->NextOffset);

    /* Set the ProcOffset for this function */

    pMsg->ProcOffset = offsetof(GLSRVSBPROCTABLE, glsrvReadPixels);

    /* Assign the members in the message as required */

    pMsg->x         = x             ;
    pMsg->y         = y             ;
    pMsg->width     = width         ;
    pMsg->height    = height        ;
    pMsg->format    = format        ;
    pMsg->type      = type          ;
    pMsg->pixelsOff = (ULONG_PTR)pixels ;

    /* Get the batch ready for the next message */

    pMsgBatchInfo->NextOffset = NextOffset;
    glsbAttention();
    return;
#else
    GLCLIENT_BEGIN_LARGE_GET( ReadPixels, READPIXELS, pixels, width*height, pixelsOff )
        pMsg->x         = x             ;
        pMsg->y         = y             ;
        pMsg->width     = width         ;
        pMsg->height    = height        ;
        pMsg->format    = format        ;
        pMsg->type      = type          ;
    GLCLIENT_END_LARGE_GET
    return;
#endif // _CLIENTSIDE_
}


void APIENTRY
glcltGetTexImage (  IN GLenum target,
                    IN GLint level,
                    IN GLenum format,
                    IN GLenum type,
                    OUT GLvoid *pixels
                 )
{
#ifndef _CLIENTSIDE_
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_GETTEXIMAGE *pMsg;
    ULONG NextOffset;

    /* Set a pointer to the batch information structure */

    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();

    /* Tentative offset, where we may want to place our data   */
    /* This is also the first available byte after the message */

    NextOffset = pMsgBatchInfo->NextOffset +
            GLMSG_ALIGN(sizeof(*pMsg));

    if ( NextOffset > pMsgBatchInfo->MaximumOffset )
    {
        /* No room for the message, flush the batch */

        glsbAttention();

        /* Reset NextOffset */

        NextOffset = pMsgBatchInfo->NextOffset +
                GLMSG_ALIGN(sizeof(*pMsg));
    }

    /* This is where we will store our message */

    pMsg = (GLMSG_GETTEXIMAGE *)( ((BYTE *)pMsgBatchInfo) +
                pMsgBatchInfo->NextOffset);

    /* Set the ProcOffset for this function */

    pMsg->ProcOffset = offsetof(GLSRVSBPROCTABLE, glsrvGetTexImage);

    /* Assign the members in the message as required */

    pMsg->target    = target        ;
    pMsg->level     = level         ;
    pMsg->format    = format        ;
    pMsg->type      = type          ;
    pMsg->pixelsOff = (ULONG_PTR)pixels ;

    /* Get the batch ready for the next message */

    pMsgBatchInfo->NextOffset = NextOffset;
    glsbAttention();
    return;
#else
    GLCLIENT_BEGIN_LARGE_GET( GetTexImage, GETTEXIMAGE, pixels, -1, pixelsOff )
        pMsg->target    = target        ;
        pMsg->level     = level         ;
        pMsg->format    = format        ;
        pMsg->type      = type          ;
    GLCLIENT_END_LARGE_GET
    return;
#endif // _CLIENTSIDE_
}


void APIENTRY
glcltDrawPixels (   IN GLsizei width,
                    IN GLsizei height,
                    IN GLenum format,
                    IN GLenum type,
                    IN const GLvoid *pixels
                )
{
#ifndef _CLIENTSIDE_
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_DRAWPIXELS *pMsg;
    ULONG NextOffset;

    /* Set a pointer to the batch information structure */

    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();

    /* Tentative offset, where we may want to place our data   */
    /* This is also the first available byte after the message */

    NextOffset = pMsgBatchInfo->NextOffset +
            GLMSG_ALIGN(sizeof(*pMsg));

    if ( NextOffset > pMsgBatchInfo->MaximumOffset )
    {
        /* No room for the message, flush the batch */

        glsbAttention();

        /* Reset NextOffset */

        NextOffset = pMsgBatchInfo->NextOffset +
                GLMSG_ALIGN(sizeof(*pMsg));
    }

    /* This is where we will store our message */

    pMsg = (GLMSG_DRAWPIXELS *)( ((BYTE *)pMsgBatchInfo) +
                pMsgBatchInfo->NextOffset);

    /* Set the ProcOffset for this function */

    pMsg->ProcOffset = offsetof(GLSRVSBPROCTABLE, glsrvDrawPixels);

    /* Assign the members in the message as required */

    pMsg->width     = width         ;
    pMsg->height    = height        ;
    pMsg->format    = format        ;
    pMsg->type      = type          ;
    pMsg->pixelsOff = (ULONG_PTR)pixels ;

    /* Get the batch ready for the next message */

    pMsgBatchInfo->NextOffset = NextOffset;
    glsbAttention();
    return;
#else
    GLCLIENT_BEGIN_LARGE_SET( DrawPixels, DRAWPIXELS, pixels, width*height, pixelsOff )
        pMsg->width     = width         ;
        pMsg->height    = height        ;
        pMsg->format    = format        ;
        pMsg->type      = type          ;
        pMsg->_IsDlist  = GL_FALSE      ;
    GLCLIENT_END_LARGE_SET
    return;
#endif // _CLIENTSIDE_
}

void APIENTRY
glcltBitmap (   IN GLsizei width,
                IN GLsizei height,
                IN GLfloat xorig,
                IN GLfloat yorig,
                IN GLfloat xmove,
                IN GLfloat ymove,
                IN const GLubyte bitmap[]
            )
{
#ifndef _CLIENTSIDE_
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_BITMAP *pMsg;
    ULONG NextOffset;

    /* Set a pointer to the batch information structure */

    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();

    /* Tentative offset, where we may want to place our data   */
    /* This is also the first available byte after the message */

    NextOffset = pMsgBatchInfo->NextOffset +
            GLMSG_ALIGN(sizeof(*pMsg));

    if ( NextOffset > pMsgBatchInfo->MaximumOffset )
    {
        /* No room for the message, flush the batch */

        glsbAttention();

        /* Reset NextOffset */

        NextOffset = pMsgBatchInfo->NextOffset +
                GLMSG_ALIGN(sizeof(*pMsg));
    }

    /* This is where we will store our message */

    pMsg = (GLMSG_BITMAP *)( ((BYTE *)pMsgBatchInfo) +
                pMsgBatchInfo->NextOffset);

    /* Set the ProcOffset for this function */

    pMsg->ProcOffset = offsetof(GLSRVSBPROCTABLE, glsrvBitmap);

    /* Assign the members in the message as required */

    pMsg->width     = width         ;
    pMsg->height    = height        ;
    pMsg->xorig     = xorig         ;
    pMsg->yorig     = yorig         ;
    pMsg->xmove     = xmove         ;
    pMsg->ymove     = ymove         ;
    pMsg->bitmapOff = (ULONG)bitmap ;

    /* Get the batch ready for the next message */

    pMsgBatchInfo->NextOffset = NextOffset;
    glsbAttention();
    return;
#else
    GLCLIENT_BEGIN_LARGE_SET( Bitmap, BITMAP, bitmap, width*height, bitmapOff )
        pMsg->width     = width         ;
        pMsg->height    = height        ;
        pMsg->xorig     = xorig         ;
        pMsg->yorig     = yorig         ;
        pMsg->xmove     = xmove         ;
        pMsg->ymove     = ymove         ;
        pMsg->_IsDlist  = GL_FALSE      ;
    GLCLIENT_END_LARGE_SET
    return;
#endif // _CLIENTSIDE_
}

void APIENTRY
glcltPolygonStipple ( const GLubyte *mask )
{
#ifndef _CLIENTSIDE_
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_POLYGONSTIPPLE *pMsg;
    ULONG NextOffset;

    /* Set a pointer to the batch information structure */

    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();

    /* Tentative offset, where we may want to place our data   */
    /* This is also the first available byte after the message */

    NextOffset = pMsgBatchInfo->NextOffset +
            GLMSG_ALIGN(sizeof(*pMsg));

    if ( NextOffset > pMsgBatchInfo->MaximumOffset )
    {
        /* No room for the message, flush the batch */

        glsbAttention();

        /* Reset NextOffset */

        NextOffset = pMsgBatchInfo->NextOffset +
                GLMSG_ALIGN(sizeof(*pMsg));
    }

    /* This is where we will store our message */

    pMsg = (GLMSG_POLYGONSTIPPLE *)( ((BYTE *)pMsgBatchInfo) +
                pMsgBatchInfo->NextOffset);

    /* Set the ProcOffset for this function */

    pMsg->ProcOffset = offsetof(GLSRVSBPROCTABLE, glsrvPolygonStipple);

    /* Assign the members in the message as required */

    pMsg->maskOff = (ULONG)mask;

    /* Get the batch ready for the next message */

    pMsgBatchInfo->NextOffset = NextOffset;
    glsbAttention();
    return;
#else
    GLCLIENT_BEGIN_LARGE_SET( PolygonStipple, POLYGONSTIPPLE, mask, -1, maskOff )
        pMsg->_IsDlist = GL_FALSE;
    GLCLIENT_END_LARGE_SET
    return;
#endif // _CLIENTSIDE_
}

void APIENTRY
glcltGetPolygonStipple ( GLubyte mask[] )
{
#ifndef _CLIENTSIDE_
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_GETPOLYGONSTIPPLE *pMsg;
    ULONG NextOffset;

    /* Set a pointer to the batch information structure */

    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();

    /* Tentative offset, where we may want to place our data   */
    /* This is also the first available byte after the message */

    NextOffset = pMsgBatchInfo->NextOffset +
            GLMSG_ALIGN(sizeof(*pMsg));

    if ( NextOffset > pMsgBatchInfo->MaximumOffset )
    {
        /* No room for the message, flush the batch */

        glsbAttention();

        /* Reset NextOffset */

        NextOffset = pMsgBatchInfo->NextOffset +
                GLMSG_ALIGN(sizeof(*pMsg));
    }

    /* This is where we will store our message */

    pMsg = (GLMSG_GETPOLYGONSTIPPLE *)( ((BYTE *)pMsgBatchInfo) +
                pMsgBatchInfo->NextOffset);

    /* Set the ProcOffset for this function */

    pMsg->ProcOffset = offsetof(GLSRVSBPROCTABLE, glsrvGetPolygonStipple);

    /* Assign the members in the message as required */

    pMsg->maskOff = (ULONG)mask;

    /* Get the batch ready for the next message */

    pMsgBatchInfo->NextOffset = NextOffset;
    glsbAttention();
    return;
#else
    GLCLIENT_BEGIN_LARGE_GET( GetPolygonStipple, GETPOLYGONSTIPPLE, mask, -1, maskOff )
    GLCLIENT_END_LARGE_GET
    return;
#endif // _CLIENTSIDE_
}



void APIENTRY
glcltTexImage1D (   IN GLenum target,
                    IN GLint level,
                    IN GLint components,
                    IN GLsizei width,
                    IN GLint border,
                    IN GLenum format,
                    IN GLenum type,
                    IN const GLvoid *pixels
                )
{
#ifndef _CLIENTSIDE_
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_TEXIMAGE1D *pMsg;
    ULONG NextOffset;

    /* Set a pointer to the batch information structure */

    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();

    /* Tentative offset, where we may want to place our data   */
    /* This is also the first available byte after the message */

    NextOffset = pMsgBatchInfo->NextOffset +
            GLMSG_ALIGN(sizeof(*pMsg));

    if ( NextOffset > pMsgBatchInfo->MaximumOffset )
    {
        /* No room for the message, flush the batch */

        glsbAttention();

        /* Reset NextOffset */

        NextOffset = pMsgBatchInfo->NextOffset +
                GLMSG_ALIGN(sizeof(*pMsg));
    }

    /* This is where we will store our message */

    pMsg = (GLMSG_TEXIMAGE1D *)( ((BYTE *)pMsgBatchInfo) +
                pMsgBatchInfo->NextOffset);

    /* Set the ProcOffset for this function */

    pMsg->ProcOffset = offsetof(GLSRVSBPROCTABLE, glsrvTexImage1D);

    /* Assign the members in the message as required */

    pMsg->target        = target        ;
    pMsg->level         = level         ;
    pMsg->components    = components    ;
    pMsg->width         = width         ;
    pMsg->border        = border        ;
    pMsg->format        = format        ;
    pMsg->type          = type          ;
    pMsg->pixelsOff     = (ULONG_PTR)pixels ;

    /* Get the batch ready for the next message */

    pMsgBatchInfo->NextOffset = NextOffset;

    glsbAttention();
    return;
#else
    GLCLIENT_BEGIN_LARGE_SET( TexImage1D, TEXIMAGE1D, pixels, width, pixelsOff )
        pMsg->target        = target        ;
        pMsg->level         = level         ;
        pMsg->components    = components    ;
        pMsg->width         = width         ;
        pMsg->border        = border        ;
        pMsg->format        = format        ;
        pMsg->type          = type          ;
        pMsg->_IsDlist      = GL_FALSE      ;
    GLCLIENT_END_LARGE_SET
    return;
#endif // _CLIENTSIDE_
}

void APIENTRY
glcltTexImage2D (   IN GLenum target,
                    IN GLint level,
                    IN GLint components,
                    IN GLsizei width,
                    IN GLsizei height,
                    IN GLint border,
                    IN GLenum format,
                    IN GLenum type,
                    IN const GLvoid *pixels
                )
{
#ifndef _CLIENTSIDE_
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_TEXIMAGE2D *pMsg;
    ULONG NextOffset;

    /* Set a pointer to the batch information structure */

    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();

    /* Tentative offset, where we may want to place our data   */
    /* This is also the first available byte after the message */

    NextOffset = pMsgBatchInfo->NextOffset +
            GLMSG_ALIGN(sizeof(*pMsg));

    if ( NextOffset > pMsgBatchInfo->MaximumOffset )
    {
        /* No room for the message, flush the batch */

        glsbAttention();

        /* Reset NextOffset */

        NextOffset = pMsgBatchInfo->NextOffset +
                GLMSG_ALIGN(sizeof(*pMsg));
    }

    /* This is where we will store our message */

    pMsg = (GLMSG_TEXIMAGE2D *)( ((BYTE *)pMsgBatchInfo) +
                pMsgBatchInfo->NextOffset);

    /* Set the ProcOffset for this function */

    pMsg->ProcOffset = offsetof(GLSRVSBPROCTABLE, glsrvTexImage2D);

    /* Assign the members in the message as required */

    pMsg->target        = target        ;
    pMsg->level         = level         ;
    pMsg->components    = components    ;
    pMsg->width         = width         ;
    pMsg->height        = height        ;
    pMsg->border        = border        ;
    pMsg->format        = format        ;
    pMsg->type          = type          ;
    pMsg->pixelsOff     = (ULONG_PTR)pixels ;

    /* Get the batch ready for the next message */

    pMsgBatchInfo->NextOffset = NextOffset;
    glsbAttention();
    return;
#else
    GLCLIENT_BEGIN_LARGE_SET( TexImage2D, TEXIMAGE2D, pixels, width*height, pixelsOff )
        pMsg->target        = target        ;
        pMsg->level         = level         ;
        pMsg->components    = components    ;
        pMsg->width         = width         ;
        pMsg->height        = height        ;
        pMsg->border        = border        ;
        pMsg->format        = format        ;
        pMsg->type          = type          ;
        pMsg->_IsDlist      = GL_FALSE      ;
    GLCLIENT_END_LARGE_SET
    return;
#endif // _CLIENTSIDE_
}

GLboolean APIENTRY glcltAreTexturesResident(GLsizei n, const GLuint *textures,
                                            GLboolean *residences)
{
    GLCLIENT_BEGIN(AreTexturesResident, ARETEXTURESRESIDENT)
        pMsg->n = n;
        pMsg->textures = textures;
        pMsg->residences = residences;
        GLTEB_RETURNVALUE() = 0;
        glsbAttention();
    return (GLboolean)GLTEB_RETURNVALUE();
    GLCLIENT_END
}
        
void APIENTRY glcltBindTexture(GLenum target, GLuint texture)
{
    GLCLIENT_BEGIN(BindTexture, BINDTEXTURE)
        pMsg->target = target;
        pMsg->texture = texture;
    return;
    GLCLIENT_END
}

void APIENTRY glcltCopyTexImage1D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLint border)
{
    GLCLIENT_BEGIN(CopyTexImage1D, COPYTEXIMAGE1D)
        pMsg->target = target;
        pMsg->level = level;
        pMsg->internalformat = internalformat;
        pMsg->x = x;
        pMsg->y = y;
        pMsg->width = width;
        pMsg->border = border;
    return;
    GLCLIENT_END
}

void APIENTRY glcltCopyTexImage2D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLsizei height, GLint border)
{
    GLCLIENT_BEGIN(CopyTexImage2D, COPYTEXIMAGE2D)
        pMsg->target = target;
        pMsg->level = level;
        pMsg->internalformat = internalformat;
        pMsg->x = x;
        pMsg->y = y;
        pMsg->width = width;
        pMsg->height = height;
        pMsg->border = border;
    return;
    GLCLIENT_END
}

void APIENTRY glcltCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                     GLint x, GLint y, GLsizei width)
{
    GLCLIENT_BEGIN(CopyTexSubImage1D, COPYTEXSUBIMAGE1D)
        pMsg->target = target;
        pMsg->level = level;
        pMsg->xoffset = xoffset;
        pMsg->x = x;
        pMsg->y = y;
        pMsg->width = width;
    return;
    GLCLIENT_END
}

void APIENTRY glcltCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                     GLint yoffset, GLint x, GLint y,
                                     GLsizei width, GLsizei height)
{
    GLCLIENT_BEGIN(CopyTexSubImage2D, COPYTEXSUBIMAGE2D)
        pMsg->target = target;
        pMsg->level = level;
        pMsg->xoffset = xoffset;
        pMsg->yoffset = yoffset;
        pMsg->x = x;
        pMsg->y = y;
        pMsg->width = width;
        pMsg->height = height;
    return;
    GLCLIENT_END
}

void APIENTRY glcltDeleteTextures(GLsizei n, const GLuint *textures)
{
    GLCLIENT_BEGIN(DeleteTextures, DELETETEXTURES)
        pMsg->n = n;
        pMsg->textures = textures;
        // Flush pointer
        glsbAttention();
    return;
    GLCLIENT_END
}

void APIENTRY glcltGenTextures(GLsizei n, GLuint *textures)
{
    GLCLIENT_BEGIN(GenTextures, GENTEXTURES)
        pMsg->n = n;
        pMsg->textures = textures;
        glsbAttention();
    return;
    GLCLIENT_END
}

GLboolean APIENTRY glcltIsTexture(GLuint texture)
{
    GLCLIENT_BEGIN(IsTexture, ISTEXTURE)
        pMsg->texture = texture;
        GLTEB_RETURNVALUE() = 0;
        glsbAttention();
    return (GLboolean)GLTEB_RETURNVALUE();
    GLCLIENT_END
}

void APIENTRY glcltPrioritizeTextures(GLsizei n, const GLuint *textures,
                                      const GLclampf *priorities)
{
    GLCLIENT_BEGIN(PrioritizeTextures, PRIORITIZETEXTURES)
        pMsg->n = n;
        pMsg->textures = textures;
        pMsg->priorities = priorities;
        // Flush pointer
        glsbAttention();
    return;
    GLCLIENT_END
}

void APIENTRY glcltTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                 GLsizei width, GLenum format, GLenum type,
                                 const GLvoid *pixels)
{
    GLCLIENT_BEGIN_LARGE_SET(TexSubImage1D, TEXSUBIMAGE1D, pixels, width,
                             pixelsOff )
        pMsg->target        = target        ;
        pMsg->level         = level         ;
        pMsg->xoffset       = xoffset       ;
        pMsg->width         = width         ;
        pMsg->format        = format        ;
        pMsg->type          = type          ;
        pMsg->_IsDlist      = GL_FALSE      ;
    GLCLIENT_END_LARGE_SET
    return;
}

void APIENTRY glcltTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                 GLint yoffset, GLsizei width, GLsizei height,
                                 GLenum format, GLenum type,
                                 const GLvoid *pixels)
{
    GLCLIENT_BEGIN_LARGE_SET(TexSubImage2D, TEXSUBIMAGE2D, pixels,
                             width*height, pixelsOff )
        pMsg->target        = target        ;
        pMsg->level         = level         ;
        pMsg->xoffset       = xoffset       ;
        pMsg->yoffset       = yoffset       ;
        pMsg->width         = width         ;
        pMsg->height        = height        ;
        pMsg->format        = format        ;
        pMsg->type          = type          ;
        pMsg->_IsDlist      = GL_FALSE      ;
    GLCLIENT_END_LARGE_SET
    return;
}

void APIENTRY glcltColorTableEXT(GLenum target, GLenum internalFormat,
                                 GLsizei width, GLenum format, GLenum type,
                                 const GLvoid *data)
{
    GLCLIENT_BEGIN(ColorTableEXT, COLORTABLEEXT)
        pMsg->target = target;
        pMsg->internalFormat = internalFormat;
        pMsg->width = width;
        pMsg->format = format;
        pMsg->type = type;
        pMsg->data = data;
        pMsg->_IsDlist = GL_FALSE;
        // Flush pointer
        glsbAttention();
    return;
    GLCLIENT_END
}

void APIENTRY glcltColorSubTableEXT(GLenum target, GLsizei start,
                                    GLsizei count,
                                    GLenum format, GLenum type,
                                    const GLvoid *data)
{
    GLCLIENT_BEGIN(ColorSubTableEXT, COLORSUBTABLEEXT)
        pMsg->target = target;
        pMsg->start = start;
        pMsg->count = count;
        pMsg->format = format;
        pMsg->type = type;
        pMsg->data = data;
        pMsg->_IsDlist = GL_FALSE;
        // Flush pointer
        glsbAttention();
    return;
    GLCLIENT_END
}

void APIENTRY glcltGetColorTableEXT(GLenum target,
                                    GLenum format, GLenum type, GLvoid *data)
{
    GLCLIENT_BEGIN(GetColorTableEXT, GETCOLORTABLEEXT)
        pMsg->target = target;
        pMsg->format = format;
        pMsg->type = type;
        pMsg->data = data;
        glsbAttention();
    return;
    GLCLIENT_END
}

void APIENTRY glcltGetColorTableParameterivEXT( GLenum target, GLenum pname, GLint *params)
{
    GLCLIENT_BEGIN(GetColorTableParameterivEXT, GETCOLORTABLEPARAMETERIVEXT)
        pMsg->target = target;
        pMsg->pname = pname;
        pMsg->params = params;
        glsbAttention();
        return;
    GLCLIENT_END
}

void APIENTRY glcltGetColorTableParameterfvEXT( GLenum target, GLenum pname, GLfloat *params)
{
    GLCLIENT_BEGIN(GetColorTableParameterfvEXT, GETCOLORTABLEPARAMETERFVEXT)
        pMsg->target = target;
        pMsg->pname = pname;
        pMsg->params = params;
        glsbAttention();
        return;
    GLCLIENT_END
}

void APIENTRY glcltPolygonOffset(GLfloat factor, GLfloat units)
{
    GLCLIENT_BEGIN(PolygonOffset, POLYGONOFFSET)
        pMsg->factor = factor;
        pMsg->units = units;
    return;
    GLCLIENT_END
}

void APIENTRY glcltPushClientAttrib (IN GLbitfield mask)
{
    __GLclientAttribute **spp;
    __GLclientAttribute *sp;
    __GL_SETUP();

// Not allowed in begin/end.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

// The pixel store states are currently kept in the server, flush the
// command buffer to keep client and server in ssync.

    if (mask & GL_CLIENT_PIXEL_STORE_BIT)
	glsbAttention();

    spp = gc->clientAttributes.stackPointer;
    if (spp < &gc->clientAttributes.stack[gc->constants.maxClientAttribStackDepth])
    {
	if (!(sp = *spp))
	{
	    sp = (__GLclientAttribute*)
		GCALLOCZ(gc, sizeof(__GLclientAttribute));
	    if (NULL == sp)
	        return;
	    *spp = sp;
	}
	sp->mask = mask;
	gc->clientAttributes.stackPointer = spp + 1;

	if (mask & GL_CLIENT_PIXEL_STORE_BIT)
	{
	    sp->pixelPackModes = gc->state.pixel.packModes;
	    sp->pixelUnpackModes = gc->state.pixel.unpackModes;
	}
	if (mask & GL_CLIENT_VERTEX_ARRAY_BIT)
	{
	    sp->vertexArray = gc->vertexArray;
	}
    }
    else
    {
        GLSETERROR(GL_STACK_OVERFLOW);
    }
}

GLuint FASTCALL __glInternalPopClientAttrib(__GLcontext *gc, GLboolean bSync,
                                            GLboolean destroy)
{
    __GLclientAttribute **spp;
    __GLclientAttribute *sp;
    GLbitfield mask;
    GLuint dirtyMask = 0;

    spp = gc->clientAttributes.stackPointer;
    if (spp > &gc->clientAttributes.stack[0])
    {
	--spp;
	sp = *spp;
	ASSERTOPENGL(sp != 0, "corrupted client stack");
	mask = sp->mask;
	gc->clientAttributes.stackPointer = spp;

// If this function is called by client side, flush the command buffer
// to keep client and server pixel store states in ssync.
// If it is called by the server side __glDestroyContext() function,
// do not flush the command buffer!

	if ((mask & GL_CLIENT_PIXEL_STORE_BIT) && bSync)
	    glsbAttention();

	if (mask & GL_CLIENT_PIXEL_STORE_BIT)
	{
	    gc->state.pixel.packModes   = sp->pixelPackModes;
	    gc->state.pixel.unpackModes = sp->pixelUnpackModes;
	    dirtyMask |= __GL_DIRTY_PIXEL;
	}
	if (mask & GL_CLIENT_VERTEX_ARRAY_BIT)
	{
	    gc->vertexArray = sp->vertexArray;
	}

	/*
	** Clear out mask so that any memory frees done above won't get
	** re-done when the context is destroyed
	*/
	sp->mask = 0;
    }
    else
    {
        GLSETERROR(GL_STACK_UNDERFLOW);
    }

    return dirtyMask;
}

void APIENTRY glcltPopClientAttrib (void)
{
    GLuint dirtyMask;

    __GL_SETUP();

// Not allowed in begin/end.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

    dirtyMask = __glInternalPopClientAttrib(gc, GL_TRUE, GL_FALSE);
    if (dirtyMask)
    {
	// __GL_DELAY_VALIDATE_MASK(gc, dirtyMask);
	gc->beginMode = __GL_NEED_VALIDATE;
	gc->dirtyMask |= dirtyMask;
    }
}

#ifdef GL_EXT_flat_paletted_lighting
void APIPRIVATE __glim_ColorTableParameterivEXT(GLenum target,
                                                GLenum pname,
                                                const GLint *params);
void APIENTRY glColorTableParameterivEXT(GLenum target,
                                         GLenum pname,
                                         const GLint *params)
{
    glsbAttention();
    __glim_ColorTableParameterivEXT(target, pname, params);
}

void APIPRIVATE __glim_ColorTableParameterfvEXT(GLenum target,
                                                GLenum pname,
                                                const GLfloat *params);
void APIENTRY glColorTableParameterfvEXT(GLenum target,
                                         GLenum pname,
                                         const GLfloat *params)
{
    glsbAttention();
    __glim_ColorTableParameterfvEXT(target, pname, params);
}
#endif // GL_EXT_flat_paletted_lighting

#ifdef GL_WIN_multiple_textures
void APIENTRY glcltCurrentTextureIndexWIN
    (GLuint index)
{
    GLCLIENT_BEGIN(CurrentTextureIndexWIN, CURRENTTEXTUREINDEXWIN)
        pMsg->index = index;
    return;
    GLCLIENT_END
}

void APIENTRY glcltBindNthTextureWIN
    (GLuint index, GLenum target, GLuint texture)
{
    GLCLIENT_BEGIN(BindNthTextureWIN, BINDNTHTEXTUREWIN)
        pMsg->index = index;
        pMsg->target = target;
        pMsg->texture = texture;
    return;
    GLCLIENT_END
}

void APIENTRY glcltNthTexCombineFuncWIN
    (GLuint index,
     GLenum leftColorFactor, GLenum colorOp, GLenum rightColorFactor,
     GLenum leftAlphaFactor, GLenum alphaOp, GLenum rightAlphaFactor)
{
    GLCLIENT_BEGIN(NthTexCombineFuncWIN, NTHTEXCOMBINEFUNCWIN)
        pMsg->index = index;
        pMsg->leftColorFactor = leftColorFactor;
        pMsg->colorOp = colorOp;
        pMsg->rightColorFactor = rightColorFactor;
        pMsg->leftAlphaFactor = leftAlphaFactor;
        pMsg->alphaOp = alphaOp;
        pMsg->rightAlphaFactor = rightAlphaFactor;
    return;
    GLCLIENT_END
}
#endif // GL_WIN_multiple_textures
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\layer.c ===
/******************************Module*Header*******************************\
* Module Name: layer.c
*
* OpenGL layer planes support
*
* History:
*  Fri Mar 16 13:27:47 1995	-by-	Drew Bliss [drewb]
*   Created
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <glp.h>
#include <glscreen.h>
#include <glgenwin.h>

#include "gencx.h"
#include "context.h"

// Macro to call glFlush or glFinish only if a RC is current.

#define GLFLUSH()          if (GLTEB_CLTCURRENTRC()) glFlush()
#define GLFINISH()         if (GLTEB_CLTCURRENTRC()) glFinish()

/*****************************Private*Routine******************************\
*
* ValidateLayerIndex
*
* Checks to see whether the given layer index is legal for the given
* pixel format
*
* History:
*  Fri Mar 17 14:35:27 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY ValidateLayerIndex(int iLayerPlane, PIXELFORMATDESCRIPTOR *ppfd)
{
    if (iLayerPlane < 0)
    {
        if (-iLayerPlane > ((ppfd->bReserved >> 4) & 15))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }
    else if (iLayerPlane > 0)
    {
        if (iLayerPlane > (ppfd->bReserved & 15))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }
    else
        return FALSE;

    return TRUE;
}

/*****************************Private*Routine******************************\
*
* ValidateLayerIndexForDc
*
* Checks to see whether the given layer index is valid for the
* pixel format currently selected in the DC
*
* Returns the current pixel format
*
* History:
*  Fri Mar 17 14:35:55 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

static BOOL ValidateLayerIndexForDc(int iLayerPlane,
                                    HDC hdc,
                                    PIXELFORMATDESCRIPTOR *ppfd)
{
    int ipfd;

    if (IsDirectDrawDevice(hdc))
    {
        SetLastError(ERROR_INVALID_FUNCTION);
        return FALSE;
    }
    
    ipfd = GetPixelFormat(hdc);
    if (ipfd == 0)
    {
        return FALSE;
    }

    if (DescribePixelFormat(hdc, ipfd,
                            sizeof(PIXELFORMATDESCRIPTOR), ppfd) == 0)
    {
        return FALSE;
    }

    return ValidateLayerIndex(iLayerPlane, ppfd);
}

/******************************Public*Routine******************************\
*
* wglDescribeLayerPlane
*
* Describes the given layer plane
*
* History:
*  Fri Mar 17 13:16:23 1995	-by-	Drew Bliss [drewb]
*   Created
\**************************************************************************/

BOOL WINAPI wglDescribeLayerPlane(HDC hdc,
                                  int iPixelFormat,
                                  int iLayerPlane,
                                  UINT nBytes,
                                  LPLAYERPLANEDESCRIPTOR plpd)
{
    PIXELFORMATDESCRIPTOR pfd;
    BOOL bRet;

    if (IsDirectDrawDevice(hdc))
    {
        SetLastError(ERROR_INVALID_FUNCTION);
        return FALSE;
    }
    
    // Retrieve the pixel format information
    // Validates the HDC and pixel format
    if (DescribePixelFormat(hdc, iPixelFormat, sizeof(pfd), &pfd) == 0)
    {
        return FALSE;
    }

    // Check for correct size of return buffer
    if (nBytes < sizeof(LAYERPLANEDESCRIPTOR))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    // Make sure the given layer plane is valid
    if (!ValidateLayerIndex(iLayerPlane, &pfd))
    {
        return FALSE;
    }

    // Generic implementations don't currently support layers
    ASSERTOPENGL(!(pfd.dwFlags & PFD_GENERIC_FORMAT)
                 || (pfd.dwFlags & PFD_GENERIC_ACCELERATED), "bad generic pfd");

    if (!(pfd.dwFlags & PFD_GENERIC_ACCELERATED))
    {
        PGLDRIVER pgldrv;
        
        // Pass request on to the driver if it supports it
        pgldrv = pgldrvLoadInstalledDriver(hdc);
        if (pgldrv != NULL &&
            pgldrv->pfnDrvDescribeLayerPlane != NULL)
        {
            bRet = pgldrv->pfnDrvDescribeLayerPlane(hdc, iPixelFormat,
                                                    iLayerPlane, nBytes, plpd);
        }
        else
        {
            bRet = FALSE;
        }
    }
    else
    {
        bRet = GenMcdDescribeLayerPlane(hdc, iPixelFormat, iLayerPlane,
                                        nBytes, plpd);
    }
    
    return bRet;
}

/******************************Public*Routine******************************\
*
* wglSetLayerPaletteEntries
*
* Sets palette entries for the given layer plane
*
* History:
*  Fri Mar 17 13:17:11 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

int WINAPI wglSetLayerPaletteEntries(HDC hdc,
                                     int iLayerPlane,
                                     int iStart,
                                     int cEntries,
                                     CONST COLORREF *pcr)
{
    PIXELFORMATDESCRIPTOR pfd;
    int iRet;

    // Validate the layer and retrieve the current pixel format
    if (!ValidateLayerIndexForDc(iLayerPlane, hdc, &pfd))
    {
        return 0;
    }

    // Flush OpenGL calls.

    GLFLUSH();

    // Generic implementations don't currently support layers
    ASSERTOPENGL(!(pfd.dwFlags & PFD_GENERIC_FORMAT)
                 || (pfd.dwFlags & PFD_GENERIC_ACCELERATED), "bad generic pfd");

    if (!(pfd.dwFlags & PFD_GENERIC_ACCELERATED))
    {
        PGLDRIVER pgldrv;
        
        // Pass request on to the driver if it supports it
        pgldrv = pgldrvLoadInstalledDriver(hdc);
        if (pgldrv != NULL &&
            pgldrv->pfnDrvSetLayerPaletteEntries != NULL)
        {
            iRet = pgldrv->pfnDrvSetLayerPaletteEntries(hdc, iLayerPlane,
                                                        iStart, cEntries, pcr);
        }
        else
        {
            iRet = 0;
        }
    }
    else
    {
        iRet = GenMcdSetLayerPaletteEntries(hdc, iLayerPlane,
                                            iStart, cEntries, pcr);
    }
    
    return iRet;
}

/******************************Public*Routine******************************\
*
* wglGetLayerPaletteEntries
*
* Retrieves palette information for the given layer plane
*
* History:
*  Fri Mar 17 13:18:00 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

int WINAPI wglGetLayerPaletteEntries(HDC hdc,
                                     int iLayerPlane,
                                     int iStart,
                                     int cEntries,
                                     COLORREF *pcr)
{
    PIXELFORMATDESCRIPTOR pfd;
    int iRet;

    // Validate the layer and retrieve the current pixel format
    if (!ValidateLayerIndexForDc(iLayerPlane, hdc, &pfd))
    {
        return 0;
    }

    // Generic implementations don't currently support layers
    ASSERTOPENGL(!(pfd.dwFlags & PFD_GENERIC_FORMAT)
                 || (pfd.dwFlags & PFD_GENERIC_ACCELERATED), "bad generic pfd");

    if (!(pfd.dwFlags & PFD_GENERIC_ACCELERATED))
    {
        PGLDRIVER pgldrv;
        
        // Pass request on to the driver if it supports it
        pgldrv = pgldrvLoadInstalledDriver(hdc);
        if (pgldrv != NULL &&
            pgldrv->pfnDrvGetLayerPaletteEntries != NULL)
        {
            iRet = pgldrv->pfnDrvGetLayerPaletteEntries(hdc, iLayerPlane,
                                                        iStart, cEntries, pcr);
        }
        else
        {
            iRet = 0;
        }
    }
    else
    {
        iRet = GenMcdGetLayerPaletteEntries(hdc, iLayerPlane,
                                            iStart, cEntries, pcr);
    }
    
    return iRet;
}

/******************************Public*Routine******************************\
*
* wglRealizeLayerPalette
*
* Realizes the current palette for the given layer plane
*
* History:
*  Fri Mar 17 13:18:54 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL WINAPI wglRealizeLayerPalette(HDC hdc,
                                   int iLayerPlane,
                                   BOOL bRealize)
{
    PIXELFORMATDESCRIPTOR pfd;
    BOOL bRet;

    // Validate the layer and retrieve the current pixel format
    if (!ValidateLayerIndexForDc(iLayerPlane, hdc, &pfd))
    {
        return FALSE;
    }

    // Flush OpenGL calls.

    GLFLUSH();

    // Generic implementations don't currently support layers
    ASSERTOPENGL(!(pfd.dwFlags & PFD_GENERIC_FORMAT)
                 || (pfd.dwFlags & PFD_GENERIC_ACCELERATED), "bad generic pfd");

    if (!(pfd.dwFlags & PFD_GENERIC_ACCELERATED))
    {
        PGLDRIVER pgldrv;
        
        // Pass request on to the driver if it supports it
        pgldrv = pgldrvLoadInstalledDriver(hdc);
        if (pgldrv != NULL &&
            pgldrv->pfnDrvRealizeLayerPalette != NULL)
        {
            bRet = pgldrv->pfnDrvRealizeLayerPalette(hdc, iLayerPlane,
                                                     bRealize);
        }
        else
        {
            bRet = FALSE;
        }
    }
    else
    {
        bRet = GenMcdRealizeLayerPalette(hdc, iLayerPlane, bRealize);
    }
    
    return bRet;
}

/******************************Public*Routine******************************\
*
* wglSwapLayerBuffers
*
* Swaps the buffers indicated by fuFlags
*
* History:
*  Fri Mar 17 13:19:20 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL WINAPI wglSwapLayerBuffers(HDC hdc,
                                UINT fuFlags)
{
    GLGENwindow *pwnd;
    int ipfd;
    BOOL bRet;
    GLWINDOWID gwid;

#if 0
    // If fuFlags == -1, it is a SwapBuffers call.
    if (fuFlags & 0x80000000)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
#endif

    if (IsDirectDrawDevice(hdc))
    {
        SetLastError(ERROR_INVALID_FUNCTION);
        return FALSE;
    }
    
    // Finish OpenGL calls.

    GLFINISH();

    ipfd = GetPixelFormat(hdc);
    if (ipfd == 0)
    {
        return FALSE;
    }

    WindowIdFromHdc(hdc, &gwid);
    pwnd = pwndGetFromID(&gwid);
    if (!pwnd)
    {
        return FALSE;
    }

    if (ipfd > pwnd->ipfdDevMax)
    {
        PIXELFORMATDESCRIPTOR pfd;

        if (DescribePixelFormat(hdc, ipfd,
                                sizeof(PIXELFORMATDESCRIPTOR), &pfd) == 0)
        {
            return FALSE;
        }

        // Generic implementations only support the main plane unless MCD
        // has overlay support.

        if (pfd.dwFlags & PFD_GENERIC_ACCELERATED)
        {
            // MCD always support this (whether or not there are layers).

            bRet = GenMcdSwapLayerBuffers(hdc, fuFlags);
        }
        else if (fuFlags & WGL_SWAP_MAIN_PLANE)
        {
            // We are generic, so substituting SwapBuffers is OK as long
            // as the main plane is being swapped.  We ignore the bits for
            // the layer planes (they don't exist!).

            bRet = SwapBuffers(hdc);
        }
        else
        {
            // We are generic and the request is to swap only layer planes
            // (none of which exist).  Since we ignore unsupported planes
            // there is nothing to do, but we can return success.

            bRet = TRUE;
        }
    }
    else
    {
        PGLDRIVER pgldrv;
        
        // Pass request on to the driver if it supports it
        pgldrv = pgldrvLoadInstalledDriver(hdc);
        if (pgldrv != NULL &&
            pgldrv->pfnDrvSwapLayerBuffers != NULL)
        {
            bRet = pgldrv->pfnDrvSwapLayerBuffers(hdc, fuFlags);
        }
        else if (fuFlags & WGL_SWAP_MAIN_PLANE)
        {
            // If the driver doesn't have DrvSwapLayerBuffers, we
            // can still try and swap the main plane via
            // SwapBuffers.  The bit flags for unsupported planes
            // are ignored
            // We're assuming that the fact that the driver doesn't
            // expose DrvSwapLayerBuffers means that it doesn't support
            // layers at all, possibly not a valid assumption but
            // a reasonably safe one.  If the driver did support layers,
            // this call will cause swapping of all layer planes and
            // problems will result
            bRet = SwapBuffers(hdc);
        }
        else
        {
            // Nothing to swap.
            //
            // Again, we are assuming that if the driver doesn't support
            // DrvSwapLayerBuffers, there are no layer planes at all.
            // However, since we ignore the bits for layers that do not
            // exist, this is not an error case.
            bRet = TRUE;
        }
    }

    pwndRelease(pwnd);
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\local.c ===
/*****************************Module*Header*******************************\
* Module Name: local.c                                                     *
*                                                                          *
* Support routines for client side objects.                                *
*                                                                          *
* Created: 30-May-1991 21:55:57                                            *
* Author: Charles Whitmer [chuckwh]                                        *
*                                                                          *
* Copyright (c) 1991,1993 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <ntcsrdll.h>

LHE             *pLocalTable;              // Points to handle table.
ULONG            iFreeLhe = INVALID_INDEX; // Identifies a free handle index.
ULONG            cLheCommitted = 0;        // Count of LHEs with committed RAM.
CRITICAL_SECTION semLocal;                 // Semaphore for handle allocation.


//XXX Useless but needed by csrgdi.h

#if DBG
ULONG gcHits  = 0;
ULONG gcBatch = 0;
ULONG gcCache = 0;
ULONG gcUser  = 0;
#endif

/******************************Private*Routine*****************************\
* bMakeMoreHandles ()                                                      *
*                                                                          *
* Commits more RAM to the local handle table and links the new free        *
* handles together.  Returns TRUE on success, FALSE on error.              *
*                                                                          *
* History:                                                                 *
*  Sat 01-Jun-1991 17:06:45 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL bMakeMoreHandles()
{
    UINT ii;

// Commit more RAM for the handle table.

    if (
        (cLheCommitted >= MAX_HANDLES) ||
        (VirtualAlloc(
            (LPVOID) &pLocalTable[cLheCommitted],
            COMMIT_COUNT * sizeof(LHE),
            MEM_COMMIT,
            PAGE_READWRITE
            ) == (LPVOID) NULL)
       )
    {
        WARNING("bMakeMoreHandles(): failed to commit more memory\n");
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

// Initialize the new handles.

    ii = iFreeLhe = cLheCommitted;
    cLheCommitted += COMMIT_COUNT;

    for (; ii<cLheCommitted; ii++)
    {
        pLocalTable[ii].metalink = ii+1;
        pLocalTable[ii].iUniq    = 1;
        pLocalTable[ii].iType    = LO_NULL;
    }
    pLocalTable[ii-1].metalink = INVALID_INDEX;

    return(TRUE);
}

/******************************Public*Routine******************************\
* iAllocHandle (iType,hgre,pv)                                             *
*                                                                          *
* Allocates a handle from the local handle table, initializes fields in    *
* the handle entry.  Returns the handle index or INVALID_INDEX on error.   *
*                                                                          *
* History:                                                                 *
*  Sat 01-Jun-1991 17:08:54 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

ULONG iAllocHandle(ULONG iType,ULONG hgre,PVOID pv)
{
    ULONG ii = INVALID_INDEX;
    PLHE  plhe;

// Get critical for handle allocation.

    ENTERCRITICALSECTION(&semLocal);

// Make sure a handle is available.

    if (iFreeLhe != INVALID_INDEX || bMakeMoreHandles())
    {
        ii = iFreeLhe;
        plhe = pLocalTable + ii;
        iFreeLhe = plhe->metalink;
        plhe->hgre     = hgre;
        plhe->cRef     = 0;
        plhe->iType    = (BYTE) iType;
        plhe->pv       = pv;
        plhe->metalink = 0;
        plhe->tidOwner = 0;
        plhe->cLock    = 0;
    }

// Leave the critical section.

    LEAVECRITICALSECTION(&semLocal);
    return(ii);
}

/******************************Public*Routine******************************\
* vFreeHandle (h)                                                          *
*                                                                          *
* Frees up a local handle.  The handle is added to the free list.  This    *
* may be called with either an index or handle.  The iUniq count is        *
* updated so the next user of this handle slot will have a different       *
* handle.                                                                  *
*                                                                          *
* Note for client side implementation:                                     *
*   Caller should have handle locked before calling this.                  *
*                                                                          *
* History:                                                                 *
*  Sat 01-Jun-1991 17:11:23 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

VOID vFreeHandle(ULONG_PTR h)
{
// Extract the index from the handle.

    UINT ii = MASKINDEX(h);

// Get critical for handle deallocation.

    ENTERCRITICALSECTION(&semLocal);

// Caller should lock handle before freeing.

    ASSERTOPENGL(pLocalTable[ii].cLock == 1,
                 "vFreeHandle(): cLock != 1\n");
    ASSERTOPENGL(pLocalTable[ii].tidOwner == GetCurrentThreadId(),
                 "vFreeHandle(): thread not owner\n");

// Add the handle to the free list.

    pLocalTable[ii].metalink = iFreeLhe;
    iFreeLhe = ii;

// Increment the iUniq count.

    pLocalTable[ii].iUniq++;
    if (pLocalTable[ii].iUniq == 0)
        pLocalTable[ii].iUniq = 1;
    pLocalTable[ii].iType = LO_NULL;

// Leave the critical section.

    LEAVECRITICALSECTION(&semLocal);
}

/******************************Public*Routine******************************\
* cLockHandle (h)
*
* Lock handle for access by a thread.  If another thread possesses the lock,
* this will fail.
*
* Returns:
*   Lock count.  Returns -1 if failure.
*
* History:
*  31-Jan-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

LONG cLockHandle(ULONG_PTR h)
{
    LONG lRet = -1;

// Extract the index from the handle.

    UINT ii = MASKINDEX(h);
    PLHE plhe = pLocalTable + ii;

// Get critical for handle locking.

    ENTERCRITICALSECTION(&semLocal);

    if ((ii >= cLheCommitted) ||
        (!MATCHUNIQ(plhe,h))  ||
        ((plhe->iType != LO_RC))
       )
    {
        DBGLEVEL1(LEVEL_ERROR, "cLockHandle: invalid handle 0x%lx\n", h);
        SetLastError(ERROR_INVALID_HANDLE);
        goto cLockHandle_exit;
    }

// If not currently locked or if current owning thread is the same,
// do the lock.

    if ( (pLocalTable[ii].cLock == 0) ||
         (pLocalTable[ii].tidOwner == GetCurrentThreadId()) )
    {
        pLocalTable[ii].cLock++;
        pLocalTable[ii].tidOwner = GetCurrentThreadId();

        lRet = (LONG) pLocalTable[ii].cLock;
    }
    else
    {
        WARNING("cLockHandle(): current thread not owner\n");
        SetLastError(ERROR_BUSY);
    }

// Leave the critical section.

cLockHandle_exit:
    LEAVECRITICALSECTION(&semLocal);
    return lRet;
}

/******************************Public*Routine******************************\
* vUnlockHandle (h)
*
* Removes a lock from the handle.  Must be owned by current thread.
*
* Note:
*   Caller should possess the lock before this is called.  This implies
*   that cLockHandle must be called and its return code must be heeded.
*
* History:
*  31-Jan-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vUnlockHandle(ULONG_PTR h)
{
// Extract the index from the handle.

    UINT ii = MASKINDEX(h);

// Get critical for handle deallocation.

    ENTERCRITICALSECTION(&semLocal);

// If not currently locked or if current owning thread is the same,
// do the lock.

    ASSERTOPENGL(pLocalTable[ii].cLock > 0,
                 "vUnlockHandle(): not locked\n");
    ASSERTOPENGL(pLocalTable[ii].tidOwner == GetCurrentThreadId(),
                 "vUnlockHandle(): thread not owner\n");

    if ( (pLocalTable[ii].cLock > 0) &&
         (pLocalTable[ii].tidOwner == GetCurrentThreadId()) )
    {
        pLocalTable[ii].cLock--;
    }

// Leave the critical section.

    LEAVECRITICALSECTION(&semLocal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\metasup.h ===
/******************************Module*Header*******************************\
* Module Name: metasup.h
*
* OpenGL metafile support
*
* History:
*  Thu Feb 23 15:27:47 1995	-by-	Drew Bliss [drewb]
*   Created
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

#ifndef __METASUP_H__
#define __METASUP_H__

BOOL CreateMetaRc(HDC hdc, PLRC plrc);
void DeleteMetaRc(PLRC plrc);
void ActivateMetaRc(PLRC plrc, HDC hdc);
void DeactivateMetaRc(PLRC plrc);
void MetaRcEnd(PLRC plrc);

void MetaGlProcTables(PGLCLTPROCTABLE *ppgcpt, PGLEXTPROCTABLE *ppgept);
void MetaSetCltProcTable(GLCLTPROCTABLE *pgcpt, GLEXTPROCTABLE *pgept);
void MetaGetCltProcTable(GLCLTPROCTABLE *pgcpt, GLEXTPROCTABLE *pgept);

#endif /* __METASUP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\makecur.c ===
/******************************Module*Header*******************************\
* Module Name: makecur.c
*
* wglMakeCurrent implementation
*
* Created: 02-10-1997
*
* Copyright (c) 1993-1997 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <context.h>
#include <global.h>

#include "metasup.h"
#include "wgldef.h"

/******************************Public*Routine******************************\
*
* __wglSetProcTable
*
* Callback function given to ICDs to set a proc table
*
\**************************************************************************/

void APIENTRY
__wglSetProcTable(PGLCLTPROCTABLE pglCltProcTable)
{
    if (pglCltProcTable == (PGLCLTPROCTABLE) NULL)
        return;

// It must have either 306 entries for version 1.0 or 336 entries for 1.1

    if (pglCltProcTable->cEntries != OPENGL_VERSION_100_ENTRIES &&
        pglCltProcTable->cEntries != OPENGL_VERSION_110_ENTRIES)
    {
        return;
    }

    // This function is called by client drivers which do not use
    // the EXT procs provided by opengl32.  Use the null EXT proc
    // table to disable those stubs since they should never be
    // called anyway
    SetCltProcTable(pglCltProcTable, &glNullExtProcTable, TRUE);
}

/******************************Public*Routine******************************\
*
* CheckDeviceModes
*
* Ensures that the HDC doesn't have any disallowed state
*
* History:
*  Mon Aug 26 15:03:28 1996	-by-	Drew Bliss [drewb]
*   Split from wglMakeCurrent
*
\**************************************************************************/

BOOL CheckDeviceModes(HDC hdc)
{
    SIZE szW, szV;
    XFORM xform;
    POINT pt;
    HRGN  hrgnTmp;
    int   iRgn;

// For release 1, GDI transforms must be identity.
// This is to allow GDI transform binding in future.

    switch (GetMapMode(hdc))
    {
    case MM_TEXT:
        break;
    case MM_ANISOTROPIC:
        if (!GetWindowExtEx(hdc, &szW)
         || !GetViewportExtEx(hdc, &szV)
         || szW.cx != szV.cx
         || szW.cy != szV.cy)
            goto wglMakeCurrent_xform_error;
        break;
    default:
        goto wglMakeCurrent_xform_error;
    }

    if (!GetViewportOrgEx(hdc, &pt) || pt.x != 0 || pt.y != 0)
        goto wglMakeCurrent_xform_error;

    if (!GetWindowOrgEx(hdc, &pt) || pt.x != 0 || pt.y != 0)
        goto wglMakeCurrent_xform_error;

    if (!GetWorldTransform(hdc, &xform))
    {
// Win95 does not support GetWorldTransform.

        if (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
            goto wglMakeCurrent_xform_error;
    }
    else if (xform.eDx  != 0.0f   || xform.eDy  != 0.0f
          || xform.eM12 != 0.0f   || xform.eM21 != 0.0f
          || xform.eM11 <  0.999f || xform.eM11 >  1.001f // allow rounding errors
          || xform.eM22 <  0.999f || xform.eM22 >  1.001f)
    {
wglMakeCurrent_xform_error:
        DBGERROR("wglMakeCurrent: GDI transforms not identity\n");
        SetLastError(ERROR_TRANSFORM_NOT_SUPPORTED);
        return FALSE;
    }

// For release 1, GDI clip region is not allowed.
// This is to allow GDI clip region binding in future.

    if (!(hrgnTmp = CreateRectRgn(0, 0, 0, 0)))
        return FALSE;

    iRgn = GetClipRgn(hdc, hrgnTmp);

    if (!DeleteObject(hrgnTmp))
        ASSERTOPENGL(FALSE, "DeleteObject failed");

    switch (iRgn)
    {
    case -1:    // error
        WARNING("wglMakeCurrent: GetClipRgn failed\n");
        return FALSE;

    case 0:     // no initial clip region
        break;

    case 1:     // has initial clip region
        DBGERROR("wglMakeCurrent: GDI clip region not allowed\n");
        SetLastError(ERROR_CLIPPING_NOT_SUPPORTED);
        return FALSE;
    }

    return TRUE;
}

/******************************Public*Routine******************************\
*
* MakeAnyCurrent
*
* Makes any type of context current
*
* History:
*  Mon Aug 26 15:00:44 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL MakeAnyCurrent(HGLRC hrc, int ipfd, DWORD dwObjectType,
                    GLWINDOWID *pgwid)
{
    HGLRC hrcSrv;
    PLRC  plrc;
    DWORD tidCurrent;
    ULONG irc;
    PLHE  plheRC;
    PGLCLTPROCTABLE pglProcTable;
    PGLEXTPROCTABLE pglExtProcTable;
    POLYARRAY *pa;

    DBGENTRY("wglMakeCurrent\n");

    // If this is a new, uninitialized thread, try to initialize it
    if (CURRENT_GLTEBINFO() == NULL)
    {
        GLInitializeThread(DLL_THREAD_ATTACH);
    
// If the teb was not set up at thread initialization, return failure.

	if (!CURRENT_GLTEBINFO())
	{
	    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
	    return(FALSE);
	}
    }

// There are four cases:
//
// 1. hrc is NULL and there is no current RC.
// 2. hrc is NULL and there is a current RC.
// 3. hrc is not NULL and there is a current RC.
// 4. hrc is not NULL and there is no current RC.

// Case 1: hrc is NULL and there is no current RC.
// This is a noop, return success.

    if (hrc == (HGLRC) 0 && (GLTEB_CLTCURRENTRC() == (PLRC) NULL))
        return(TRUE);

// Case 2: hrc is NULL and there is a current RC.
// Make the current RC inactive.

    if (hrc == (HGLRC) 0 && (GLTEB_CLTCURRENTRC() != (PLRC) NULL))
        return(bMakeNoCurrent());

// Get the current thread id.

    tidCurrent = GetCurrentThreadId();
    ASSERTOPENGL(tidCurrent != INVALID_THREAD_ID,
        "wglMakeCurrent: GetCurrentThreadId returned a bad value\n");

// Validate the handles.  hrc is not NULL here.

    ASSERTOPENGL(hrc != (HGLRC) NULL, "wglMakeCurrent: hrc is NULL\n");

// Validate the RC.

    if (cLockHandle((ULONG_PTR)hrc) <= 0)
    {
        DBGLEVEL1(LEVEL_ERROR, "wglMakeCurrent: can't lock hrc 0x%lx\n", hrc);
        goto wglMakeCurrent_error_nolock;
    }
    irc = MASKINDEX(hrc);
    plheRC = pLocalTable + irc;
    plrc   = (PLRC) plheRC->pv;
    hrcSrv = (HGLRC) plheRC->hgre;
    ASSERTOPENGL(plrc->ident == LRC_IDENTIFIER, "wglMakeCurrent: Bad plrc\n");

#ifdef GL_METAFILE
    // Ensure that metafile RC's are made current only to
    // metafile DC's
    if (plrc->uiGlsCaptureContext != 0 && dwObjectType != OBJ_ENHMETADC)
    {
        DBGLEVEL(LEVEL_ERROR,
                 "wglMakeCurrent: attempt to make meta RC current "
                 "to non-meta DC\n");
        SetLastError(ERROR_INVALID_HANDLE);
        vUnlockHandle((ULONG_PTR)hrc);
        return FALSE;
    }

    // Ensure that non-metafile RC's are made current only to
    // non-metafile DC's
    if (plrc->uiGlsCaptureContext == 0 && dwObjectType == OBJ_ENHMETADC)
    {
        DBGLEVEL(LEVEL_ERROR,
                 "wglMakeCurrent: attempt to make non-meta RC current "
                 "to meta DC\n");
        SetLastError(ERROR_METAFILE_NOT_SUPPORTED);
        vUnlockHandle((ULONG_PTR)hrc);
        return FALSE;
    }
#endif
    
// If the RC is current, it must be current to this thread because 
// makecurrent locks down the handle.
// If the given RC is already current to this thread, we will release it first,
// then make it current again.  This is to support DC/RC attribute bindings in
// this function.

    ASSERTOPENGL(plrc->tidCurrent == INVALID_THREAD_ID ||
                 plrc->tidCurrent == tidCurrent,
                 "wglMakeCurrent: hrc is current to another thread\n");

// Case 3: hrc is not NULL and there is a current RC.
// This is case 2 followed by case 4.

    if (GLTEB_CLTCURRENTRC())
    {
// First, make the current RC inactive.

        if (!bMakeNoCurrent())
        {
            DBGERROR("wglMakeCurrent: bMakeNoCurrent failed\n");
            vUnlockHandle((ULONG_PTR)hrc);
            return(FALSE);
        }

// Second, make hrc current.  Fall through to case 4.
    }

// Case 4: hrc is not NULL and there is no current RC.

    ASSERTOPENGL(GLTEB_CLTCURRENTRC() == (PLRC) NULL,
        "wglMakeCurrent: There is a current RC!\n");

// If the pixel format of the window or surface is different from that of
// the RC, return error.

    if (ipfd != plrc->iPixelFormat)
    {
        DBGERROR("wglMakeCurrent: different hdc and hrc pixel formats\n");
        SetLastError(ERROR_INVALID_PIXEL_FORMAT);
        goto wglMakeCurrent_error;
    }

// Since the client code manages the function table, we will make
// either the server or the driver current.

    if (!plrc->dhrc)
    {
// If this is a generic format, tell the server to make it current.

#ifndef _CLIENTSIDE_
// If the subbatch data has not been set up for this thread, set it up now.

        if (GLTEB_CLTSHAREDSECTIONINFO() == NULL)
        {
            if (!glsbCreateAndDuplicateSection(SHARED_SECTION_SIZE))
            {
                WARNING("wglMakeCurrent: unable to create section\n");
                goto wglMakeCurrent_error;
            }
        }
#endif // !_CLIENTSIDE_

        if (!__wglMakeCurrent(pgwid, hrcSrv, plrc->uiGlsCaptureContext != 0))
        {
            DBGERROR("wglMakeCurrent: server failed\n");
            goto wglMakeCurrent_error;
        }

// Get the generic function table or metafile function table

#ifdef GL_METAFILE
        if (plrc->fCapturing)
        {
            MetaGlProcTables(&pglProcTable, &pglExtProcTable);
        }
        else
#endif
        {
// Use RGBA or CI proc table depending on the color mode.

	    // The gc should be available by now.
	    __GL_SETUP();

	    if (gc->modes.colorIndexMode)
		pglProcTable = &glCltCIProcTable;
	    else
		pglProcTable = &glCltRGBAProcTable;
            pglExtProcTable = &glExtProcTable;
        }
    }
    else
    {
// If this is a device format, tell the driver to make it current.
// Get the driver function table from the driver.
// pfnDrvSetContext returns the address of the driver OpenGL function
// table if successful; NULL otherwise.

        ASSERTOPENGL(plrc->pGLDriver, "wglMakeCurrent: No GLDriver\n");

        pglProcTable = plrc->pGLDriver->pfnDrvSetContext(pgwid->hdc,
                                                         plrc->dhrc,
                                                         __wglSetProcTable);
        if (pglProcTable == (PGLCLTPROCTABLE) NULL)
        {
            DBGERROR("wglMakeCurrent: pfnDrvSetContext failed\n");
            goto wglMakeCurrent_error;
        }

// It must have either 306 entries for version 1.0 or 336 entries for 1.1

        if (pglProcTable->cEntries != OPENGL_VERSION_100_ENTRIES &&
            pglProcTable->cEntries != OPENGL_VERSION_110_ENTRIES)
        {
            DBGERROR("wglMakeCurrent: pfnDrvSetContext returned bad table\n");
            plrc->pGLDriver->pfnDrvReleaseContext(plrc->dhrc);
            SetLastError(ERROR_BAD_DRIVER);
            goto wglMakeCurrent_error;
        }

        DBGLEVEL1(LEVEL_INFO, "wglMakeCurrent: driver function table 0x%lx\n",
            pglProcTable);

        // Always use the null EXT proc table since client drivers don't
        // use opengl32's stubs for EXT procs
        pglExtProcTable = &glNullExtProcTable;
    }

// Make hrc current.

    plrc->tidCurrent = tidCurrent;
    plrc->gwidCurrent = *pgwid;
    GLTEB_SET_CLTCURRENTRC(plrc);
    SetCltProcTable(pglProcTable, pglExtProcTable, TRUE);

#ifdef GL_METAFILE
    // Set up metafile context if necessary
    if (plrc->fCapturing)
    {
        __GL_SETUP();
            
        ActivateMetaRc(plrc, pgwid->hdc);

        // Set the metafile's base dispatch table by resetting
        // the proc table.  Since we know we're capturing, this
        // will cause the GLS capture exec table to be updated
        // with the RGBA or CI proc table, preparing the
        // GLS context for correct passthrough
        
        if (gc->modes.colorIndexMode)
            pglProcTable = &glCltCIProcTable;
        else
            pglProcTable = &glCltRGBAProcTable;
        pglExtProcTable = &glExtProcTable;
        SetCltProcTable(pglProcTable, pglExtProcTable, FALSE);
    }
#endif

// Initialize polyarray structure in the TEB.

    pa = GLTEB_CLTPOLYARRAY();
    pa->flags = 0;		// not in begin mode
    if (!plrc->dhrc)
    {
	POLYMATERIAL *pm;
	__GL_SETUP();

	pa->pdBufferNext = &gc->vertex.pdBuf[0];
	pa->pdBuffer0    = &gc->vertex.pdBuf[0];
	pa->pdBufferMax  = &gc->vertex.pdBuf[gc->vertex.pdBufSize - 1];
	// reset next DPA message offset
        pa->nextMsgOffset = PA_nextMsgOffset_RESET_VALUE;

// Vertex buffer size may have changed.  For example, a generic gc's
// vertex buffer may be of a different size than a MCD vertex buffer.
// If it has changed, free the polymaterial array and realloc it later.

	pm = GLTEB_CLTPOLYMATERIAL();
	if (pm)
	{
	    if (pm->aMatSize !=
                gc->vertex.pdBufSize * 2 / POLYMATERIAL_ARRAY_SIZE + 1)
		FreePolyMaterial();
	}
    }

// Keep the handle locked while it is current.

    return(TRUE);

// An error has occured, release the current RC.

wglMakeCurrent_error:
    vUnlockHandle((ULONG_PTR)hrc);
wglMakeCurrent_error_nolock:
    if (GLTEB_CLTCURRENTRC() != (PLRC) NULL)
        (void) bMakeNoCurrent();
    return(FALSE);
}

/******************************Public*Routine******************************\
*
* WindowIdFromHdc
*
* Fills out a GLWINDOWID for an HDC
*
* History:
*  Wed Aug 28 18:33:19 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void APIENTRY WindowIdFromHdc(HDC hdc, GLWINDOWID *pgwid)
{
    LPDIRECTDRAWSURFACE pdds;
    HDC hdcDriver;

    if (pfnGetSurfaceFromDC != NULL &&
        pfnGetSurfaceFromDC(hdc, &pdds, &hdcDriver) == DD_OK)
    {
        // Release reference on the surface since this surface value
        // is only used as an identifier.
        pdds->lpVtbl->Release(pdds);
        
        pgwid->iType = GLWID_DDRAW;
        pgwid->hwnd = NULL;
        pgwid->hdc = hdcDriver;
        pgwid->pdds = pdds;
    }
    else
    {
        pgwid->hdc = hdc;
        pgwid->hwnd = WindowFromDC(hdc);
        if (pgwid->hwnd == NULL)
        {
            pgwid->iType = GLWID_HDC;
        }
        else
        {
            pgwid->iType = GLWID_HWND;
        }
        pgwid->pdds = NULL;
    }
}
    
/******************************Public*Routine******************************\
* wglMakeCurrent(HDC hdc, HGLRC hrc)
*
* Make the hrc current.
* Both hrc and hdc must have the same pixel format.
*
* If an error occurs, the current RC, if any, is made not current!
*
* Arguments:
*   hdc        - Device context.
*   hrc        - Rendering context.
*
* History:
*  Tue Oct 26 10:25:26 1993     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL WINAPI wglMakeCurrent(HDC hdc, HGLRC hrc)
{
    int   iPixelFormat;
    DWORD dwObjectType;
    GLWINDOWID gwid;

    DBGENTRY("wglMakeCurrent\n");

    if (GLTEB_CLTCURRENTRC() != NULL)
    {
        // Flush OpenGL calls.
        glFlush();

        // Avoid HDC validation for simple make-non-current cases
        if (hrc == NULL)
        {
            return bMakeNoCurrent();
        }
    }
    
// Validate the DC.

    dwObjectType = wglObjectType(hdc);
    switch (dwObjectType)
    {
    case OBJ_DC:
    case OBJ_MEMDC:
        break;

    case OBJ_ENHMETADC:
#ifdef GL_METAFILE
        if (pfnGdiAddGlsRecord == NULL)
        {
            DBGLEVEL1(LEVEL_ERROR, "wglMakeCurrent: metafile hdc: 0x%lx\n",
                      hdc);
            SetLastError(ERROR_INVALID_HANDLE);
            return FALSE;
        }
        break;
#else
        DBGLEVEL1(LEVEL_ERROR, "wglMakeCurrent: metafile hdc: 0x%lx\n", hdc);
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
#endif
        
    case OBJ_METADC:
    default:
        // 16-bit metafiles are not supported
        DBGLEVEL1(LEVEL_ERROR, "wglMakeCurrent: bad hdc: 0x%lx\n", hdc);
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (!CheckDeviceModes(hdc))
    {
        return FALSE;
    }
    
#ifdef GL_METAFILE
    // For metafile RC's, use the reference HDC rather than the
    // metafile DC
    // Skip pixel format checks
    if (dwObjectType == OBJ_ENHMETADC)
    {
        iPixelFormat = 0;
        goto NoPixelFormat;
    }
#endif
    
// Get the current pixel format of the window or surface.
// If no pixel format has been set, return error.

    if (!(iPixelFormat = GetPixelFormat(hdc)))
    {
        WARNING("wglMakeCurrent: No pixel format set in hdc\n");
        return FALSE;
    }

#ifdef GL_METAFILE
 NoPixelFormat:
#endif

    WindowIdFromHdc(hdc, &gwid);
    return MakeAnyCurrent(hrc, iPixelFormat, dwObjectType, &gwid);
}

/******************************Public*Routine******************************\
* bMakeNoCurrent
*
* Make the current RC inactive.
*
* History:
*  Tue Oct 26 10:25:26 1993     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL bMakeNoCurrent(void)
{
    BOOL bRet = FALSE;      // assume error
    PLRC plrc = GLTEB_CLTCURRENTRC();

    DBGENTRY("bMakeNoCurrent\n");

    ASSERTOPENGL(plrc != (PLRC) NULL, "bMakeNoCurrent: No current RC!\n");
    ASSERTOPENGL(plrc->tidCurrent == GetCurrentThreadId(),
        "bMakeNoCurrent: Current RC does not belong to this thread!\n");
    ASSERTOPENGL(plrc->gwidCurrent.iType != GLWID_ERROR,
                 "bMakeNoCurrent: Current surface is NULL!\n");

    if (!plrc->dhrc)
    {
#ifdef GL_METAFILE
        // Reset metafile context if necessary
        if (plrc->uiGlsCaptureContext != 0)
        {
            DeactivateMetaRc(plrc);
        }
#endif
        
// If this is a generic format, tell the server to make the current RC inactive.

        bRet = __wglMakeCurrent(NULL, NULL, FALSE);
        if (!bRet)
        {
            DBGERROR("bMakeNoCurrent: server failed\n");
        }
    }
    else
    {
// If this is a device format, tell the driver to make the current RC inactive.

        ASSERTOPENGL(plrc->pGLDriver, "wglMakeCurrent: No GLDriver\n");

        bRet = plrc->pGLDriver->pfnDrvReleaseContext(plrc->dhrc);
        if (!bRet)
        {
            DBGERROR("bMakeNoCurrent: pfnDrvReleaseContext failed\n");
        }
    }

// Always make the current RC inactive.
// The handle is also unlocked when the RC becomes inactive.

    plrc->tidCurrent = INVALID_THREAD_ID;
    plrc->gwidCurrent.iType = GLWID_ERROR;
    GLTEB_SET_CLTCURRENTRC(NULL);
    SetCltProcTable(&glNullCltProcTable, &glNullExtProcTable, TRUE);
    vUnlockHandle((ULONG_PTR)(plrc->hrc));
    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\local.h ===
/******************************Module*Header*******************************\
* Module Name: local.h                                                     *
*                                                                          *
* Definitions needed for client side objects and attribute caching.        *
*                                                                          *
* Modified: 3-Aug-1992 22:35:30 by Gerrit van Wingerden [gerritv]          *
*   Added client side transform support.                                   *
*                                                                          *
* Created: 30-May-1991 21:55:01                                            *
* Author: Charles Whitmer [chuckwh]                                        *
*                                                                          *
* Copyright (c) 1993 Microsoft Corporation                                 *
\**************************************************************************/

/**************************************************************************\
 *
 * Local handle macros
 *
\**************************************************************************/

// Handle uniqueness is nice to check but an unnecesary performance cost in
// a free build.

// To match the uniqness field:  If the handle uniqness == 0, let it through
// anyway.  This is a method for WOW to only keep track of the low 16 bits but
// still get reasonable performance.  Even if a 32 bit app does this, all it
// can do is hose it self, not the system or another app.

#define INDEX_MASK  0xFFFF
#define UNIQ_SHIFT  16
#define UNIQ_MASK   0xFFFF
#define HIPART(x) *(((USHORT *) &(x))+1)
#define MATCHUNIQ(plhe,h) ((USHORT) plhe->iUniq == HIPART(h))
#define MASKINDEX(h) ((UINT)((UINT_PTR)h & INDEX_MASK))
#define LHANDLE(i)  (i+((ULONG)pLocalTable[i].iUniq<<UNIQ_SHIFT))

//!!!XXX -- Do we really need typing?  Not really, but we may add more
//!!!XXX    later.  So eventually we might take it out, but its nice for now.

// Define the types of local objects.

enum LO_TYPE
{
    LO_NULL,
    LO_RC,
    LO_LAST
};

#define INVALID_INDEX 0xFFFFFFFFL
#define COMMIT_COUNT  (4096/sizeof(LHE))
#define MAX_HANDLES (16384/COMMIT_COUNT)*COMMIT_COUNT

// Define a Local Handle Entry.  Our Local Handle Table, pLocalTable, is an
// array of these.

typedef struct _LHE
{
    ULONG_PTR hgre;     // GRE Handle.
    USHORT cRef;        // Reference count of the object.
    BYTE   iType;       // Object type.
    BYTE   iUniq;       // Handle uniqueness field.  Always non-zero.
    PVOID  pv;          // Pointer to local object.
    ULONG  metalink;    // Non-zero if object is a "metafile friend".
                        // Points to a metafile DC object if it's a metafile.
                        // Also links the free list.
    DWORD  tidOwner;    // Per-thread lock owner.
    LONG   cLock;       // Lock count.
} LHE,*PLHE;

extern LHE                  *pLocalTable;   // Points to handle table.
extern ULONG                 iFreeLhe;      // Identifies a free handle index.
extern ULONG                 cLheCommitted; // Count of LHEs with committed RAM.
extern CRITICAL_SECTION      semLocal;      // Semaphore for handle allocation.
extern CRITICAL_SECTION      wfo_cs;        // Semaphore for wglUseFontOutlines


// Semaphore utilities

#define INITIALIZECRITICALSECTION(psem) InitializeCriticalSection((psem))
#define ENTERCRITICALSECTION(hsem)      EnterCriticalSection((hsem))
#define LEAVECRITICALSECTION(hsem)      LeaveCriticalSection((hsem))
#define DELETECRITICALSECTION(psem)     DeleteCriticalSection((psem))

// Local data structures

// Maximum OpenGL driver name

#define MAX_GLDRIVER_NAME   MAX_PATH

// GetCurrentThreadID will never return this value

#define INVALID_THREAD_ID   0

// Driver context function prototypes

typedef BOOL            (APIENTRY *PFN_DRVVALIDATEVERSION) (ULONG);
typedef VOID            (APIENTRY *PFN_DRVSETCALLBACKPROCS)(INT, PROC *);

// Driver flags.

// Driver wants buffer calls sent to ICD DLL rather than the display
// driver.  This is required on Win95.
#define GLDRIVER_CLIENT_BUFFER_CALLS    0x00000001

// Driver does not want glFinish called during swap.  Only
// applies to client swap calls.
#define GLDRIVER_NO_FINISH_ON_SWAP      0x00000002

// Driver had registry key rather than just registry value.
// This provides a way to check for new-style registry information.
#define GLDRIVER_FULL_REGISTRY          0x80000000

// Driver data

typedef struct _GLDRIVER {
    HINSTANCE             hModule;             // Module handle
    DWORD                 dwFlags;

    // Driver function pointers

    // Required
    DHGLRC          (APIENTRY *pfnDrvCreateContext)(HDC);
    BOOL            (APIENTRY *pfnDrvDeleteContext)(DHGLRC);
    PGLCLTPROCTABLE (APIENTRY *pfnDrvSetContext)(HDC, DHGLRC,
                                                 PFN_SETPROCTABLE);
    BOOL            (APIENTRY *pfnDrvReleaseContext)(DHGLRC);

    // Optional
    BOOL            (APIENTRY *pfnDrvCopyContext)(DHGLRC, DHGLRC, UINT);
    DHGLRC          (APIENTRY *pfnDrvCreateLayerContext)(HDC, int);
    BOOL            (APIENTRY *pfnDrvShareLists)(DHGLRC, DHGLRC);
    PROC            (APIENTRY *pfnDrvGetProcAddress)(LPCSTR);
    BOOL            (APIENTRY *pfnDrvDescribeLayerPlane)(HDC, INT, INT, UINT,
                                                      LPLAYERPLANEDESCRIPTOR);
    INT             (APIENTRY *pfnDrvSetLayerPaletteEntries)(HDC, INT, INT,
                                                             INT,
                                                             CONST COLORREF *);
    INT             (APIENTRY *pfnDrvGetLayerPaletteEntries)(HDC, INT, INT,
                                                             INT, COLORREF *);
    BOOL            (APIENTRY *pfnDrvRealizeLayerPalette)(HDC, INT, BOOL);
    BOOL            (APIENTRY *pfnDrvSwapLayerBuffers)(HDC, UINT);
    DHGLRC          (APIENTRY *pfnDrvCreateDirectDrawContext)
        (HDC, LPDIRECTDRAWSURFACE, int);
    int             (APIENTRY *pfnDrvEnumTextureFormats)(int, DDSURFACEDESC *);
    BOOL            (APIENTRY *pfnDrvBindDirectDrawTexture)
        (LPDIRECTDRAWSURFACE);
    DWORD           (APIENTRY *pfnDrvSwapMultipleBuffers)(UINT,
                                                          CONST WGLSWAP *);
    
    // The following functions are only called if driver asks for them.
    // This is required on Win95.
    LONG            (APIENTRY *pfnDrvDescribePixelFormat)(HDC, LONG, ULONG,
                                                      PIXELFORMATDESCRIPTOR *);
    BOOL            (APIENTRY *pfnDrvSetPixelFormat)(HDC, LONG);
    BOOL            (APIENTRY *pfnDrvSwapBuffers)(HDC);

    struct _GLDRIVER    *pGLDriver;            // Next loaded GL driver
    TCHAR tszDllName[MAX_GLDRIVER_NAME+1];     // Null terminated DLL name
} GLDRIVER, *PGLDRIVER;

extern PGLDRIVER APIENTRY pgldrvLoadInstalledDriver(HDC hdc);


/****************************************************************************/

void APIENTRY glDrawRangeElementsWIN( GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);

void APIENTRY glAddSwapHintRectWIN(IN GLint, IN GLint, IN GLint, IN GLint);

void glColorTableEXT( GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *data);
void glColorSubTableEXT( GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
void glGetColorTableEXT( GLenum target, GLenum format, GLenum type, GLvoid *data);
void glGetColorTableParameterivEXT( GLenum target, GLenum pname, GLint *params);
void glGetColorTableParameterfvEXT( GLenum target, GLenum pname, GLfloat *params);
void APIENTRY glColorTableParameterivEXT(GLenum target,
                                         GLenum pname,
                                         const GLint *params);
void APIENTRY glColorTableParameterfvEXT(GLenum target,
                                         GLenum pname,
                                         const GLfloat *params);

#ifdef GL_WIN_multiple_textures
void APIENTRY glCurrentTextureIndexWIN
    (GLuint index);
void APIENTRY glMultiTexCoord1dWIN
    (GLbitfield mask, GLdouble s);
void APIENTRY glMultiTexCoord1dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY glMultiTexCoord1fWIN
    (GLbitfield mask, GLfloat s);
void APIENTRY glMultiTexCoord1fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY glMultiTexCoord1iWIN
    (GLbitfield mask, GLint s);
void APIENTRY glMultiTexCoord1ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY glMultiTexCoord1sWIN
    (GLbitfield mask, GLshort s);
void APIENTRY glMultiTexCoord1svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY glMultiTexCoord2dWIN
    (GLbitfield mask, GLdouble s, GLdouble t);
void APIENTRY glMultiTexCoord2dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY glMultiTexCoord2fWIN
    (GLbitfield mask, GLfloat s, GLfloat t);
void APIENTRY glMultiTexCoord2fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY glMultiTexCoord2iWIN
    (GLbitfield mask, GLint s, GLint t);
void APIENTRY glMultiTexCoord2ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY glMultiTexCoord2sWIN
    (GLbitfield mask, GLshort s, GLshort t);
void APIENTRY glMultiTexCoord2svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY glMultiTexCoord3dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r);
void APIENTRY glMultiTexCoord3dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY glMultiTexCoord3fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r);
void APIENTRY glMultiTexCoord3fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY glMultiTexCoord3iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r);
void APIENTRY glMultiTexCoord3ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY glMultiTexCoord3sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r);
void APIENTRY glMultiTexCoord3svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY glMultiTexCoord4dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
void APIENTRY glMultiTexCoord4dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY glMultiTexCoord4fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
void APIENTRY glMultiTexCoord4fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY glMultiTexCoord4iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r, GLint q);
void APIENTRY glMultiTexCoord4ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY glMultiTexCoord4sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r, GLshort q);
void APIENTRY glMultiTexCoord4svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY glBindNthTextureWIN
    (GLuint index, GLenum target, GLuint texture);
void APIENTRY glNthTexCombineFuncWIN
    (GLuint index,
     GLenum leftColorFactor, GLenum colorOp, GLenum rightColorFactor,
     GLenum leftAlphaFactor, GLenum alphaOp, GLenum rightAlphaFactor);
#endif // GL_WIN_multiple_textures

/****************************************************************************/

// Local RC object

#define LRC_IDENTIFIER    0x2043524C    /* 'LRC ' */

typedef struct _LRC {
    DHGLRC    dhrc;             // Driver handle
    HGLRC     hrc;              // Client handle
    int       iPixelFormat;     // Pixel format index
    DWORD     ident;            // LRC_IDENTIFIER
    DWORD     tidCurrent;       // Thread id if the DC is current,
                                //   INVALID_THREAD_ID otherwise
    PGLDRIVER pGLDriver;        // Driver data
    GLWINDOWID gwidCurrent;     // Current surface ID
    GLWINDOWID gwidCreate;      // Creation surface ID

#ifdef GL_METAFILE
    GLuint    uiGlsCaptureContext;  // GLS capturing context for metafile RC's
    GLuint    uiGlsPlaybackContext; // GLS context for playback
    BOOL      fCapturing;       // GLS is in BeginCapture
    
    // GLS playback scaling factors
    int iGlsSubtractX;
    int iGlsSubtractY;
    int iGlsNumeratorX;
    int iGlsNumeratorY;
    int iGlsDenominatorX;
    int iGlsDenominatorY;
    int iGlsAddX;
    int iGlsAddY;
    GLfloat fGlsScaleX;
    GLfloat fGlsScaleY;
#endif

    GLubyte *pszExtensions;

#ifdef GL_METAFILE
    XFORM xformMeta;            // World transform storage during GLS blocks
    LPRECTL prclGlsBounds;      // Bounds during GLS recording
#endif
    
    struct _DDSURFACEDESC *pddsdTexFormats;
    int nDdTexFormats;
} LRC, *PLRC;

// Various dispatch tables available
extern GLCLTPROCTABLE glNullCltProcTable;
extern GLCLTPROCTABLE glCltRGBAProcTable;
extern GLCLTPROCTABLE glCltCIProcTable;
extern GLEXTPROCTABLE glNullExtProcTable;
extern GLEXTPROCTABLE glExtProcTable;
#ifdef GL_METAFILE
extern GLCLTPROCTABLE gcptGlsProcTable;
extern GLEXTPROCTABLE geptGlsExtProcTable;
#endif

// Declare support functions.

ULONG   iAllocHandle(ULONG iType,ULONG hgre,PVOID pv);
VOID    vFreeHandle(ULONG_PTR h);
LONG    cLockHandle(ULONG_PTR h);
VOID    vUnlockHandle(ULONG_PTR h);
VOID    vCleanupAllLRC(VOID);
VOID    vFreeLRC(PLRC plrc);

BOOL    bMakeNoCurrent(void);

VOID GLInitializeThread(ULONG ulReason);

// Macro to call glFlush only if a RC is current.
#define GLFLUSH()          if (GLTEB_CLTCURRENTRC()) glFlush()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\metasup.c ===
/******************************Module*Header*******************************\
* Module Name: metasup.c
*
* OpenGL metafile support
*
* History:
*  Thu Feb 23 15:27:47 1995	-by-	Drew Bliss [drewb]
*   Created
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <ntpsapi.h>
#include <wingdip.h>

#include "global.h"
#include <glgenwin.h>

#include "metasup.h"

#if defined(GL_METAFILE)

#include <glmf.h>
#include <encoding.h>

GLCLTPROCTABLE gcptGlsProcTable;
GLEXTPROCTABLE geptGlsExtProcTable;

// Functions in GL which we will do device coordinate translation for
typedef struct _GLDEVICEPROCS
{
    void (APIENTRY *glBitmap)(GLsizei width, GLsizei height,
                              GLfloat xorig, GLfloat yorig,
                              GLfloat xmove, GLfloat ymove,
                              const GLubyte *bitmap);
    void (APIENTRY *glCopyPixels)(GLint x, GLint y,
                                  GLsizei width, GLsizei height,
                                  GLenum type);
    void (APIENTRY *glCopyTexImage1D)(GLenum target, GLint level,
                                      GLenum internalformat,
                                      GLint x, GLint y,
                                      GLsizei width, GLint border);
    void (APIENTRY *glCopyTexImage2D)(GLenum target, GLint level,
                                      GLenum internalformat,
                                      GLint x, GLint y,
                                      GLsizei width, GLsizei height,
                                      GLint border);
    void (APIENTRY *glCopyTexSubImage1D)(GLenum target, GLint level,
                                         GLint xoffset, GLint x, GLint y,
                                         GLsizei width);
    void (APIENTRY *glCopyTexSubImage2D)(GLenum target, GLint level,
                                         GLint xoffset, GLint yoffset,
                                         GLint x, GLint y,
                                         GLsizei width, GLsizei height);
    void (APIENTRY *glDrawPixels)(GLsizei width, GLsizei height,
                                  GLenum format, GLenum type,
                                  const GLvoid *pixels);
    void (APIENTRY *glLineWidth)(GLfloat width);
    void (APIENTRY *glPointSize)(GLfloat size);
    void (APIENTRY *glScissor)(GLint x, GLint y,
                               GLsizei width, GLsizei height);
    void (APIENTRY *glViewport)(GLint x, GLint y,
                                GLsizei w, GLsizei h);
} GLDEVICEPROCS;
#define GL_DEVICE_PROCS (sizeof(GLDEVICEPROCS)/sizeof(PROC))

// Opcode for device procs
static GLSopcode glsopDeviceProcs[GL_DEVICE_PROCS] =
{
    GLS_OP_glBitmap,
    GLS_OP_glCopyPixels,
    GLS_OP_glCopyTexImage1D,
    GLS_OP_glCopyTexImage2D,
    GLS_OP_glCopyTexSubImage1D,
    GLS_OP_glCopyTexSubImage2D,
    GLS_OP_glDrawPixels,
    GLS_OP_glLineWidth,
    GLS_OP_glPointSize,
    GLS_OP_glScissor,
    GLS_OP_glViewport
};

static GLDEVICEPROCS gdpGlsActual;

/*****************************Private*Routine******************************\
*
* GLS recording callbacks
*
* Perfoms any necessary work when capturing a call
*
* History:
*  Mon Mar 27 14:21:09 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void GlsBitmapIn(GLsizei width, GLsizei height,
                 GLfloat xorig, GLfloat yorig,
                 GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
{
    PLRC plrc;
    RECTL rcl;

    plrc = GLTEB_CLTCURRENTRC();
    ASSERTOPENGL(plrc != NULL, "GlsBitmapIn: No current RC!\n");

    // Record bounds for the bitmap
    rcl.left = 0;
    rcl.top = 0;
    rcl.right = width;
    rcl.bottom = height;
    plrc->prclGlsBounds = &rcl;

    gdpGlsActual.glBitmap(width, height, xorig, yorig, xmove, ymove, bitmap);

    plrc->prclGlsBounds = NULL;
}

void GlsDrawPixelsIn(GLsizei width, GLsizei height,
                     GLenum format, GLenum type,
                     const GLvoid *pixels)
{
    PLRC plrc;
    RECTL rcl;

    plrc = GLTEB_CLTCURRENTRC();
    ASSERTOPENGL(plrc != NULL, "GlsBitmapIn: No current RC!\n");

    // Record bounds for the bitmap
    rcl.left = 0;
    rcl.top = 0;
    rcl.right = width;
    rcl.bottom = height;
    plrc->prclGlsBounds = &rcl;

    gdpGlsActual.glDrawPixels(width, height, format, type, pixels);

    plrc->prclGlsBounds = NULL;
}

void GlsViewportIn(GLint x, GLint y, GLsizei width, GLsizei height)
{
    RECTL rcl;
    PLRC plrc;
    
    plrc = GLTEB_CLTCURRENTRC();
    ASSERTOPENGL(plrc != NULL, "GlsViewportIn: No current RC!\n");
    
    // Send the bounds on
    // The rect is inclusive-exclusive while the incoming parameters
    // are inclusive-inclusive
    rcl.left = x;
    rcl.right = x+width+1;
    rcl.top = y;
    rcl.bottom = y+height+1;
    if (!GlGdiAddGlsBounds(plrc->gwidCreate.hdc, &rcl))
    {
        ASSERTOPENGL(FALSE, "GdiAddGlsBounds failed");
    }

    gdpGlsActual.glViewport(x, y, width, height);
}

// glViewport is the only device-dependent function that we need to
// do work for on input
static GLDEVICEPROCS gdpInput =
{
    GlsBitmapIn,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    GlsDrawPixelsIn,
    NULL,
    NULL,
    NULL,
    GlsViewportIn
};

/*****************************Private*Routine******************************\
*
* MetaLoadGls
*
* Loads glmf32.dll for metafile use
*
* History:
*  Thu Feb 23 17:40:59 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

static char *pszGlsEntryPoints[] =
{
    "glsBeginCapture",
    "glsBinary",
    "glsCallArrayInContext",
    "glsCaptureFlags",
    "glsCaptureFunc",
    "glsCommandFunc",
    "glsContext",
    "glsDeleteContext",
    "glsEndCapture",
    "glsFlush",
    "glsGenContext",
    "glsGetCaptureDispatchTable",
    "glsGetCaptureExecTable",
    "glsGetCommandAlignment",
    "glsGetCurrentContext",
    "glsUpdateCaptureExecTable",
    "glsWriteFunc",
    "glsBeginGLS",
    "glsBlock",
    "glsCallStream",
    "glsEndGLS",
    "glsError",
    "glsGLRC",
    "glsGLRCLayer",
    "glsHeaderGLRCi",
    "glsHeaderLayerf",
    "glsHeaderLayeri",
    "glsHeaderf",
    "glsHeaderfv",
    "glsHeaderi",
    "glsHeaderiv",
    "glsHeaderubz",
    "glsRequireExtension",
    "glsUnsupportedCommand",
    "glsAppRef",
    "glsBeginObj",
    "glsCharubz",
    "glsComment",
    "glsDisplayMapfv",
    "glsEndObj",
    "glsNumb",
    "glsNumbv",
    "glsNumd",
    "glsNumdv",
    "glsNumf",
    "glsNumfv",
    "glsNumi",
    "glsNumiv",
    "glsNuml",
    "glsNumlv",
    "glsNums",
    "glsNumsv",
    "glsNumub",
    "glsNumubv",
    "glsNumui",
    "glsNumuiv",
    "glsNumul",
    "glsNumulv",
    "glsNumus",
    "glsNumusv",
    "glsPad",
    "glsSwapBuffers"
};
#define GLS_ENTRY_POINT_STRINGS (sizeof(pszGlsEntryPoints)/sizeof(char *))

typedef struct _GLSENTRYPOINTS
{
    GLboolean (APIENTRY *glsBeginCapture)(const GLubyte *, GLSenum,
                                          GLbitfield);
    GLSenum   (APIENTRY *glsBinary)(GLboolean);
    void      (APIENTRY *glsCallArrayInContext)(GLuint, GLSenum, size_t,
                                                const GLubyte *);
    void      (APIENTRY *glsCaptureFlags)(GLSopcode, GLbitfield);
    void      (APIENTRY *glsCaptureFunc)(GLSenum, GLScaptureFunc);
    void      (APIENTRY *glsCommandFunc)(GLSopcode, GLSfunc);
    void      (APIENTRY *glsContext)(GLuint);
    void      (APIENTRY *glsDeleteContext)(GLuint);
    void      (APIENTRY *glsEndCapture)(void);
    void      (APIENTRY *glsFlush)(GLSenum);
    GLuint    (APIENTRY *glsGenContext)(void);
    void      (APIENTRY *glsGetCaptureDispatchTable)(GLCLTPROCTABLE *,
                                                     GLEXTPROCTABLE *);
    void      (APIENTRY *glsGetCaptureExecTable)(GLCLTPROCTABLE *,
                                                 GLEXTPROCTABLE *);
    GLScommandAlignment *
              (APIENTRY *glsGetCommandAlignment)(GLSopcode, GLSenum,
                                                 GLScommandAlignment *);
    GLuint    (APIENTRY *glsGetCurrentContext)(void);
    void      (APIENTRY *glsUpdateCaptureExecTable)(GLCLTPROCTABLE *,
                                                    GLEXTPROCTABLE *);
    void      (APIENTRY *glsWriteFunc)(GLSwriteFunc);

    // The following are only used in glsCommandFunc and so don't
    // require real prototypes
    GLSfunc glsBeginGLS;
    GLSfunc glsBlock;
    GLSfunc glsCallStream;
    GLSfunc glsEndGLS;
    GLSfunc glsError;
    GLSfunc glsGLRC;
    GLSfunc glsGLRCLayer;
    GLSfunc glsHeaderGLRCi;
    GLSfunc glsHeaderLayerf;
    GLSfunc glsHeaderLayeri;
    GLSfunc glsHeaderf;
    GLSfunc glsHeaderfv;
    GLSfunc glsHeaderi;
    GLSfunc glsHeaderiv;
    GLSfunc glsHeaderubz;
    GLSfunc glsRequireExtension;
    GLSfunc glsUnsupportedCommand;
    GLSfunc glsAppRef;
    GLSfunc glsBeginObj;
    GLSfunc glsCharubz;
    GLSfunc glsComment;
    GLSfunc glsDisplayMapfv;
    GLSfunc glsEndObj;
    GLSfunc glsNumb;
    GLSfunc glsNumbv;
    GLSfunc glsNumd;
    GLSfunc glsNumdv;
    GLSfunc glsNumf;
    GLSfunc glsNumfv;
    GLSfunc glsNumi;
    GLSfunc glsNumiv;
    GLSfunc glsNuml;
    GLSfunc glsNumlv;
    GLSfunc glsNums;
    GLSfunc glsNumsv;
    GLSfunc glsNumub;
    GLSfunc glsNumubv;
    GLSfunc glsNumui;
    GLSfunc glsNumuiv;
    GLSfunc glsNumul;
    GLSfunc glsNumulv;
    GLSfunc glsNumus;
    GLSfunc glsNumusv;
    GLSfunc glsPad;
    GLSfunc glsSwapBuffers;
} GLSENTRYPOINTS;
#define GLS_ENTRY_POINTS (sizeof(GLSENTRYPOINTS)/sizeof(void *))

static GLSENTRYPOINTS gepGlsFuncs = {NULL};
static HMODULE hGlsDll = NULL;

BOOL MetaLoadGls(void)
{
    HMODULE hdll;
    BOOL bRet = FALSE;
    GLSENTRYPOINTS gep;
    PROC *ppfn, *ppfnActual, *ppfnInput;
    GLSfunc *pgfnNormal, *pgfnExt;
    int i;
    
    ASSERTOPENGL(GLS_ENTRY_POINT_STRINGS == GLS_ENTRY_POINTS,
                 "GLS entry point strings/pointers mismatch\n");
    
    ENTERCRITICALSECTION(&semLocal);

    if (hGlsDll != NULL)
    {
        bRet = TRUE;
        goto Exit;
    }

    hdll = LoadLibrary(__TEXT("glmf32.dll"));
    if (hdll == NULL)
    {
        WARNING1("Unable to load glmf32.dll, %d\n", GetLastError());
        goto Exit;
    }
    
    ppfn = (PROC *)&gep;
    for (i = 0; i < GLS_ENTRY_POINTS; i++)
    {
        if (!(*ppfn = GetProcAddress(hdll, pszGlsEntryPoints[i])))
        {
            WARNING1("glmf32.dll is missing '%s'\n", pszGlsEntryPoints[i]);
            FreeLibrary(hdll);
            goto Exit;
        }
        
        ppfn++;
    }

    // The table copied out is constant as long as the DLL is loaded
    gep.glsGetCaptureDispatchTable(&gcptGlsProcTable, &geptGlsExtProcTable);
    
    // Patch the table for certain functions to allow us to
    // do some coordinate conversion and bounds accumlation
    ppfnActual = (PROC *)&gdpGlsActual;
    ppfnInput = (PROC *)&gdpInput;
    for (i = 0; i < GL_DEVICE_PROCS; i++)
    {
        if (*ppfnInput != NULL)
        {
            ppfn = ((PROC *)&gcptGlsProcTable.glDispatchTable)+
                glsopDeviceProcs[i]-GLS_OP_glNewList;
            *ppfnActual = *ppfn;
            *ppfn = *ppfnInput;
        }

        ppfnActual++;
        ppfnInput++;
    }
    
    gepGlsFuncs = gep;
    hGlsDll = hdll;
    bRet = TRUE;
    
 Exit:
    LEAVECRITICALSECTION(&semLocal);
    return bRet;
}

/*****************************Private*Routine******************************\
*
* MetaGlProcTables
*
* Returns the GL dispatch tables to use for metafile RC's
*
* History:
*  Thu Feb 23 17:40:25 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void MetaGlProcTables(PGLCLTPROCTABLE *ppgcpt, PGLEXTPROCTABLE *ppgept)
{
    ASSERTOPENGL(hGlsDll != NULL, "MetaGlProcTables: GLS not loaded\n");
    *ppgcpt = &gcptGlsProcTable;
    *ppgept = &geptGlsExtProcTable;
}

/******************************Public*Routine******************************\
*
* MetaSetCltProcTable
*
* Update GLS's generic dispatch tables
*
* History:
*  Fri Jan 05 16:40:31 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void MetaSetCltProcTable(GLCLTPROCTABLE *pgcpt, GLEXTPROCTABLE *pgept)
{
    gepGlsFuncs.glsUpdateCaptureExecTable(pgcpt, pgept);
}

/******************************Public*Routine******************************\
*
* MetaGetCltProcTable
*
* Retrieves GLS's generic dispatch tables
*
* History:
*  Fri Jan 05 19:14:18 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void MetaGetCltProcTable(GLCLTPROCTABLE *pgcpt, GLEXTPROCTABLE *pgept)
{
    gepGlsFuncs.glsGetCaptureExecTable(pgcpt, pgept);
}

/*****************************Private*Routine******************************\
*
* GlsWriter
*
* GLS write function for metafile support
*
* History:
*  Thu Feb 23 15:49:03 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

size_t GlsWriter(size_t cb, CONST BYTE *pb)
{
    PLRC plrc;

#if 0
    DbgPrint("GlsWriter(%d)\n", cb);
#endif
    
    plrc = GLTEB_CLTCURRENTRC();
    if( plrc == NULL ) 
    {
        DBGERROR( "GlsWriter: No current RC!\n");
        return 0;
    }
    
    ASSERTOPENGL(plrc->gwidCreate.hdc != NULL,
                 "GlsWriter: hdcCreate is NULL\n");
    ASSERTOPENGL(gepGlsFuncs.glsGetCurrentContext() ==
                 plrc->uiGlsCaptureContext,
                 "GlsWriter: Wrong GLS context\n");
    ASSERTOPENGL(plrc->fCapturing == TRUE,
                 "GlsWriter: Not capturing\n");

    if (GlGdiAddGlsRecord(plrc->gwidCreate.hdc,
                          cb, (BYTE *)pb, plrc->prclGlsBounds))
    {
        return cb;
    }
    else
    {
        return 0;
    }
}

/*****************************Private*Routine******************************\
*
* GlsFlush
*
* Post-command GLS callback to flush the GLS stream
*
* History:
*  Fri Feb 24 10:12:49 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void GlsFlush(GLSopcode op)
{
    gepGlsFuncs.glsFlush(GLS_LAST);
}

/*****************************Private*Routine******************************\
*
* MetaRcBegin
*
* Start capturing on a metafile
*
* History:
*  Thu Feb 23 18:35:32 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL MetaRcBegin(PLRC plrc, HDC hdc)
{
    PLRC plrcOld;

    // The GLS commands here will cause data to be written, which
    // requires a current RC.  The RC is only used for data storage
    // so we don't need to set the proc table
    plrcOld = GLTEB_CLTCURRENTRC();
    GLTEB_SET_CLTCURRENTRC(plrc);
    
    // Set capturing first because the block commands will cause
    // GlsWriter calls
    plrc->fCapturing = TRUE;

    // Start recording
    if (!gepGlsFuncs.glsBeginCapture("", gepGlsFuncs.glsBinary(GL_FALSE),
                                     GLS_NONE))
    {
        plrc->fCapturing = FALSE;
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        GLTEB_SET_CLTCURRENTRC(plrcOld);
        return FALSE;
    }

    GLTEB_SET_CLTCURRENTRC(plrcOld);
    
    return TRUE;
}

/*****************************Private*Routine******************************\
*
* MetaRcEnd
*
* Stop capturing on a metafile RC
*
* History:
*  Thu Feb 23 17:13:48 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void MetaRcEnd(PLRC plrc)
{
    PLRC plrcOld;
    
    // The GLS commands here will cause data to be written, which
    // requires a current RC.  The RC is only used for data storage
    // so we don't need to set the proc table
    plrcOld = GLTEB_CLTCURRENTRC();
    GLTEB_SET_CLTCURRENTRC(plrc);
    
    gepGlsFuncs.glsEndCapture();
    
    plrc->fCapturing = FALSE;
    
    GLTEB_SET_CLTCURRENTRC(plrcOld);
}

// Table of operations which GLS should execute when capturing
// in order to return information
// Currently all of them are in the list
//          Should we attempt to do only the critical calls?
static GLSopcode opExecuteBits[] =
{
    GLS_OP_glAccum,
    GLS_OP_glAlphaFunc,
    GLS_OP_glAreTexturesResidentEXT,
    GLS_OP_glArrayElementEXT,
    GLS_OP_glBegin,
    GLS_OP_glBindTextureEXT,
    GLS_OP_glBitmap,
    GLS_OP_glBlendColorEXT,
    GLS_OP_glBlendEquationEXT,
    GLS_OP_glBlendFunc,
    GLS_OP_glCallList,
    GLS_OP_glCallLists,
    GLS_OP_glClear,
    GLS_OP_glClearAccum,
    GLS_OP_glClearColor,
    GLS_OP_glClearDepth,
    GLS_OP_glClearIndex,
    GLS_OP_glClearStencil,
    GLS_OP_glClipPlane,
    GLS_OP_glColor3b,
    GLS_OP_glColor3bv,
    GLS_OP_glColor3d,
    GLS_OP_glColor3dv,
    GLS_OP_glColor3f,
    GLS_OP_glColor3fv,
    GLS_OP_glColor3i,
    GLS_OP_glColor3iv,
    GLS_OP_glColor3s,
    GLS_OP_glColor3sv,
    GLS_OP_glColor3ub,
    GLS_OP_glColor3ubv,
    GLS_OP_glColor3ui,
    GLS_OP_glColor3uiv,
    GLS_OP_glColor3us,
    GLS_OP_glColor3usv,
    GLS_OP_glColor4b,
    GLS_OP_glColor4bv,
    GLS_OP_glColor4d,
    GLS_OP_glColor4dv,
    GLS_OP_glColor4f,
    GLS_OP_glColor4fv,
    GLS_OP_glColor4i,
    GLS_OP_glColor4iv,
    GLS_OP_glColor4s,
    GLS_OP_glColor4sv,
    GLS_OP_glColor4ub,
    GLS_OP_glColor4ubv,
    GLS_OP_glColor4ui,
    GLS_OP_glColor4uiv,
    GLS_OP_glColor4us,
    GLS_OP_glColor4usv,
    GLS_OP_glColorMask,
    GLS_OP_glColorMaterial,
    GLS_OP_glColorPointerEXT,
    GLS_OP_glColorSubTableEXT,
    GLS_OP_glDrawRangeElementsWIN,
    GLS_OP_glColorTableParameterfvSGI,
    GLS_OP_glColorTableParameterivSGI,
    GLS_OP_glColorTableEXT,
    GLS_OP_glConvolutionFilter1DEXT,
    GLS_OP_glConvolutionFilter2DEXT,
    GLS_OP_glConvolutionParameterfEXT,
    GLS_OP_glConvolutionParameterfvEXT,
    GLS_OP_glConvolutionParameteriEXT,
    GLS_OP_glConvolutionParameterivEXT,
    GLS_OP_glCopyColorTableSGI,
    GLS_OP_glCopyConvolutionFilter1DEXT,
    GLS_OP_glCopyConvolutionFilter2DEXT,
    GLS_OP_glCopyPixels,
    GLS_OP_glCopyTexImage1DEXT,
    GLS_OP_glCopyTexImage2DEXT,
    GLS_OP_glCopyTexSubImage1DEXT,
    GLS_OP_glCopyTexSubImage2DEXT,
    GLS_OP_glCopyTexSubImage3DEXT,
    GLS_OP_glCullFace,
    GLS_OP_glDeleteLists,
    GLS_OP_glDeleteTexturesEXT,
    GLS_OP_glDepthFunc,
    GLS_OP_glDepthMask,
    GLS_OP_glDepthRange,
    GLS_OP_glDetailTexFuncSGIS,
    GLS_OP_glDisable,
    GLS_OP_glDrawArraysEXT,
    GLS_OP_glDrawBuffer,
    GLS_OP_glDrawPixels,
    GLS_OP_glEdgeFlag,
    GLS_OP_glEdgeFlagPointerEXT,
    GLS_OP_glEdgeFlagv,
    GLS_OP_glEnable,
    GLS_OP_glEnd,
    GLS_OP_glEndList,
    GLS_OP_glEvalCoord1d,
    GLS_OP_glEvalCoord1dv,
    GLS_OP_glEvalCoord1f,
    GLS_OP_glEvalCoord1fv,
    GLS_OP_glEvalCoord2d,
    GLS_OP_glEvalCoord2dv,
    GLS_OP_glEvalCoord2f,
    GLS_OP_glEvalCoord2fv,
    GLS_OP_glEvalMesh1,
    GLS_OP_glEvalMesh2,
    GLS_OP_glEvalPoint1,
    GLS_OP_glEvalPoint2,
    GLS_OP_glFeedbackBuffer,
    GLS_OP_glFinish,
    GLS_OP_glFlush,
    GLS_OP_glFogf,
    GLS_OP_glFogfv,
    GLS_OP_glFogi,
    GLS_OP_glFogiv,
    GLS_OP_glFrontFace,
    GLS_OP_glFrustum,
    GLS_OP_glGenLists,
    GLS_OP_glGenTexturesEXT,
    GLS_OP_glGetBooleanv,
    GLS_OP_glGetClipPlane,
    GLS_OP_glGetColorTableParameterfvEXT,
    GLS_OP_glGetColorTableParameterivEXT,
    GLS_OP_glGetColorTableEXT,
    GLS_OP_glGetConvolutionFilterEXT,
    GLS_OP_glGetConvolutionParameterfvEXT,
    GLS_OP_glGetConvolutionParameterivEXT,
    GLS_OP_glGetDetailTexFuncSGIS,
    GLS_OP_glGetDoublev,
    GLS_OP_glGetError,
    GLS_OP_glGetFloatv,
    GLS_OP_glGetHistogramEXT,
    GLS_OP_glGetHistogramParameterfvEXT,
    GLS_OP_glGetHistogramParameterivEXT,
    GLS_OP_glGetIntegerv,
    GLS_OP_glGetLightfv,
    GLS_OP_glGetLightiv,
    GLS_OP_glGetMapdv,
    GLS_OP_glGetMapfv,
    GLS_OP_glGetMapiv,
    GLS_OP_glGetMaterialfv,
    GLS_OP_glGetMaterialiv,
    GLS_OP_glGetMinmaxEXT,
    GLS_OP_glGetMinmaxParameterfvEXT,
    GLS_OP_glGetMinmaxParameterivEXT,
    GLS_OP_glGetPixelMapfv,
    GLS_OP_glGetPixelMapuiv,
    GLS_OP_glGetPixelMapusv,
    GLS_OP_glGetPointervEXT,
    GLS_OP_glGetPolygonStipple,
    GLS_OP_glGetSeparableFilterEXT,
    GLS_OP_glGetSharpenTexFuncSGIS,
    GLS_OP_glGetString,
    GLS_OP_glGetTexColorTableParameterfvSGI,
    GLS_OP_glGetTexColorTableParameterivSGI,
    GLS_OP_glGetTexEnvfv,
    GLS_OP_glGetTexEnviv,
    GLS_OP_glGetTexGendv,
    GLS_OP_glGetTexGenfv,
    GLS_OP_glGetTexGeniv,
    GLS_OP_glGetTexImage,
    GLS_OP_glGetTexLevelParameterfv,
    GLS_OP_glGetTexLevelParameteriv,
    GLS_OP_glGetTexParameterfv,
    GLS_OP_glGetTexParameteriv,
    GLS_OP_glHint,
    GLS_OP_glHistogramEXT,
    GLS_OP_glIndexMask,
    GLS_OP_glIndexPointerEXT,
    GLS_OP_glIndexd,
    GLS_OP_glIndexdv,
    GLS_OP_glIndexf,
    GLS_OP_glIndexfv,
    GLS_OP_glIndexi,
    GLS_OP_glIndexiv,
    GLS_OP_glIndexs,
    GLS_OP_glIndexsv,
    GLS_OP_glInitNames,
    GLS_OP_glIsEnabled,
    GLS_OP_glIsList,
    GLS_OP_glIsTextureEXT,
    GLS_OP_glLightModelf,
    GLS_OP_glLightModelfv,
    GLS_OP_glLightModeli,
    GLS_OP_glLightModeliv,
    GLS_OP_glLightf,
    GLS_OP_glLightfv,
    GLS_OP_glLighti,
    GLS_OP_glLightiv,
    GLS_OP_glLineStipple,
    GLS_OP_glLineWidth,
    GLS_OP_glListBase,
    GLS_OP_glLoadIdentity,
    GLS_OP_glLoadMatrixd,
    GLS_OP_glLoadMatrixf,
    GLS_OP_glLoadName,
    GLS_OP_glLogicOp,
    GLS_OP_glMap1d,
    GLS_OP_glMap1f,
    GLS_OP_glMap2d,
    GLS_OP_glMap2f,
    GLS_OP_glMapGrid1d,
    GLS_OP_glMapGrid1f,
    GLS_OP_glMapGrid2d,
    GLS_OP_glMapGrid2f,
    GLS_OP_glMaterialf,
    GLS_OP_glMaterialfv,
    GLS_OP_glMateriali,
    GLS_OP_glMaterialiv,
    GLS_OP_glMatrixMode,
    GLS_OP_glMinmaxEXT,
    GLS_OP_glMultMatrixd,
    GLS_OP_glMultMatrixf,
    GLS_OP_glNewList,
    GLS_OP_glNormal3b,
    GLS_OP_glNormal3bv,
    GLS_OP_glNormal3d,
    GLS_OP_glNormal3dv,
    GLS_OP_glNormal3f,
    GLS_OP_glNormal3fv,
    GLS_OP_glNormal3i,
    GLS_OP_glNormal3iv,
    GLS_OP_glNormal3s,
    GLS_OP_glNormal3sv,
    GLS_OP_glNormalPointerEXT,
    GLS_OP_glOrtho,
    GLS_OP_glPassThrough,
    GLS_OP_glPixelMapfv,
    GLS_OP_glPixelMapuiv,
    GLS_OP_glPixelMapusv,
    GLS_OP_glPixelStoref,
    GLS_OP_glPixelStorei,
    GLS_OP_glPixelTexGenSGIX,
    GLS_OP_glPixelTransferf,
    GLS_OP_glPixelTransferi,
    GLS_OP_glPixelZoom,
    GLS_OP_glPointSize,
    GLS_OP_glPolygonMode,
    GLS_OP_glPolygonOffsetEXT,
    GLS_OP_glPolygonStipple,
    GLS_OP_glPopAttrib,
    GLS_OP_glPopMatrix,
    GLS_OP_glPopName,
    GLS_OP_glPrioritizeTexturesEXT,
    GLS_OP_glPushAttrib,
    GLS_OP_glPushMatrix,
    GLS_OP_glPushName,
    GLS_OP_glRasterPos2d,
    GLS_OP_glRasterPos2dv,
    GLS_OP_glRasterPos2f,
    GLS_OP_glRasterPos2fv,
    GLS_OP_glRasterPos2i,
    GLS_OP_glRasterPos2iv,
    GLS_OP_glRasterPos2s,
    GLS_OP_glRasterPos2sv,
    GLS_OP_glRasterPos3d,
    GLS_OP_glRasterPos3dv,
    GLS_OP_glRasterPos3f,
    GLS_OP_glRasterPos3fv,
    GLS_OP_glRasterPos3i,
    GLS_OP_glRasterPos3iv,
    GLS_OP_glRasterPos3s,
    GLS_OP_glRasterPos3sv,
    GLS_OP_glRasterPos4d,
    GLS_OP_glRasterPos4dv,
    GLS_OP_glRasterPos4f,
    GLS_OP_glRasterPos4fv,
    GLS_OP_glRasterPos4i,
    GLS_OP_glRasterPos4iv,
    GLS_OP_glRasterPos4s,
    GLS_OP_glRasterPos4sv,
    GLS_OP_glReadBuffer,
    GLS_OP_glReadPixels,
    GLS_OP_glRectd,
    GLS_OP_glRectdv,
    GLS_OP_glRectf,
    GLS_OP_glRectfv,
    GLS_OP_glRecti,
    GLS_OP_glRectiv,
    GLS_OP_glRects,
    GLS_OP_glRectsv,
    GLS_OP_glRenderMode,
    GLS_OP_glResetHistogramEXT,
    GLS_OP_glResetMinmaxEXT,
    GLS_OP_glRotated,
    GLS_OP_glRotatef,
    GLS_OP_glSampleMaskSGIS,
    GLS_OP_glSamplePatternSGIS,
    GLS_OP_glScaled,
    GLS_OP_glScalef,
    GLS_OP_glScissor,
    GLS_OP_glSelectBuffer,
    GLS_OP_glSeparableFilter2DEXT,
    GLS_OP_glShadeModel,
    GLS_OP_glSharpenTexFuncSGIS,
    GLS_OP_glStencilFunc,
    GLS_OP_glStencilMask,
    GLS_OP_glStencilOp,
    GLS_OP_glTagSampleBufferSGIX,
    GLS_OP_glTexColorTableParameterfvSGI,
    GLS_OP_glTexColorTableParameterivSGI,
    GLS_OP_glTexCoord1d,
    GLS_OP_glTexCoord1dv,
    GLS_OP_glTexCoord1f,
    GLS_OP_glTexCoord1fv,
    GLS_OP_glTexCoord1i,
    GLS_OP_glTexCoord1iv,
    GLS_OP_glTexCoord1s,
    GLS_OP_glTexCoord1sv,
    GLS_OP_glTexCoord2d,
    GLS_OP_glTexCoord2dv,
    GLS_OP_glTexCoord2f,
    GLS_OP_glTexCoord2fv,
    GLS_OP_glTexCoord2i,
    GLS_OP_glTexCoord2iv,
    GLS_OP_glTexCoord2s,
    GLS_OP_glTexCoord2sv,
    GLS_OP_glTexCoord3d,
    GLS_OP_glTexCoord3dv,
    GLS_OP_glTexCoord3f,
    GLS_OP_glTexCoord3fv,
    GLS_OP_glTexCoord3i,
    GLS_OP_glTexCoord3iv,
    GLS_OP_glTexCoord3s,
    GLS_OP_glTexCoord3sv,
    GLS_OP_glTexCoord4d,
    GLS_OP_glTexCoord4dv,
    GLS_OP_glTexCoord4f,
    GLS_OP_glTexCoord4fv,
    GLS_OP_glTexCoord4i,
    GLS_OP_glTexCoord4iv,
    GLS_OP_glTexCoord4s,
    GLS_OP_glTexCoord4sv,
    GLS_OP_glTexCoordPointerEXT,
    GLS_OP_glTexEnvf,
    GLS_OP_glTexEnvfv,
    GLS_OP_glTexEnvi,
    GLS_OP_glTexEnviv,
    GLS_OP_glTexGend,
    GLS_OP_glTexGendv,
    GLS_OP_glTexGenf,
    GLS_OP_glTexGenfv,
    GLS_OP_glTexGeni,
    GLS_OP_glTexGeniv,
    GLS_OP_glTexImage1D,
    GLS_OP_glTexImage2D,
    GLS_OP_glTexImage3DEXT,
    GLS_OP_glTexImage4DSGIS,
    GLS_OP_glTexParameterf,
    GLS_OP_glTexParameterfv,
    GLS_OP_glTexParameteri,
    GLS_OP_glTexParameteriv,
    GLS_OP_glTexSubImage1DEXT,
    GLS_OP_glTexSubImage2DEXT,
    GLS_OP_glTexSubImage3DEXT,
    GLS_OP_glTexSubImage4DSGIS,
    GLS_OP_glTranslated,
    GLS_OP_glTranslatef,
    GLS_OP_glVertex2d,
    GLS_OP_glVertex2dv,
    GLS_OP_glVertex2f,
    GLS_OP_glVertex2fv,
    GLS_OP_glVertex2i,
    GLS_OP_glVertex2iv,
    GLS_OP_glVertex2s,
    GLS_OP_glVertex2sv,
    GLS_OP_glVertex3d,
    GLS_OP_glVertex3dv,
    GLS_OP_glVertex3f,
    GLS_OP_glVertex3fv,
    GLS_OP_glVertex3i,
    GLS_OP_glVertex3iv,
    GLS_OP_glVertex3s,
    GLS_OP_glVertex3sv,
    GLS_OP_glVertex4d,
    GLS_OP_glVertex4dv,
    GLS_OP_glVertex4f,
    GLS_OP_glVertex4fv,
    GLS_OP_glVertex4i,
    GLS_OP_glVertex4iv,
    GLS_OP_glVertex4s,
    GLS_OP_glVertex4sv,
    GLS_OP_glVertexPointerEXT,
    GLS_OP_glViewport,
    GLS_OP_glArrayElement,
    GLS_OP_glBindTexture,
    GLS_OP_glColorPointer,
    GLS_OP_glDisableClientState,
    GLS_OP_glDrawArrays,
    GLS_OP_glDrawElements,
    GLS_OP_glEdgeFlagPointer,
    GLS_OP_glEnableClientState,
    GLS_OP_glIndexPointer,
    GLS_OP_glIndexub,
    GLS_OP_glIndexubv,
    GLS_OP_glInterleavedArrays,
    GLS_OP_glNormalPointer,
    GLS_OP_glPolygonOffset,
    GLS_OP_glTexCoordPointer,
    GLS_OP_glVertexPointer,
    GLS_OP_glAreTexturesResident,
    GLS_OP_glCopyTexImage1D,
    GLS_OP_glCopyTexImage2D,
    GLS_OP_glCopyTexSubImage1D,
    GLS_OP_glCopyTexSubImage2D,
    GLS_OP_glDeleteTextures,
    GLS_OP_glGenTextures,
    GLS_OP_glGetPointerv,
    GLS_OP_glIsTexture,
    GLS_OP_glPrioritizeTextures,
    GLS_OP_glTexSubImage1D,
    GLS_OP_glTexSubImage2D,
    GLS_OP_glPushClientAttrib,
    GLS_OP_glPopClientAttrib,
};
#define EXECUTE_BITS (sizeof(opExecuteBits)/sizeof(opExecuteBits[0]))

/*****************************Private*Routine******************************\
*
* CreateMetaRc
*
* Creates a rendering context for a metafile DC
*
* History:
*  Thu Feb 23 15:27:47 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL CreateMetaRc(HDC hdc, PLRC plrc)
{
    int i;
    BOOL fSuccess;
    
    if (!MetaLoadGls())
    {
        return FALSE;
    }
    
    // If there's currently a GLS context active we can't record
    // because we require our own context to be current for recording
    if (gepGlsFuncs.glsGetCurrentContext() != 0)
    {
        SetLastError(ERROR_BUSY);
        return FALSE;
    }
    
    // Create a GLS context to record into
    plrc->uiGlsCaptureContext = gepGlsFuncs.glsGenContext();
    if (plrc->uiGlsCaptureContext == 0)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto EH_NoContext;
    }

    // No bounds by default
    plrc->prclGlsBounds = NULL;
    
    // Set current GLS context
    gepGlsFuncs.glsContext(plrc->uiGlsCaptureContext);

    // Point to our writer function
    gepGlsFuncs.glsWriteFunc(GlsWriter);

    // Set up a callback to flush after every command
    // This lets every GL command form its own separate record in the
    // metafile
    gepGlsFuncs.glsCaptureFunc(GLS_CAPTURE_EXIT_FUNC, GlsFlush);

    // Set execute bits on commands which retrieve state
    // This allows accurate results to come back for retrieval functions
    for (i = 0; i < EXECUTE_BITS; i++)
    {
        gepGlsFuncs.glsCaptureFlags(opExecuteBits[i],
                                    GLS_CAPTURE_EXECUTE_BIT |
                                    GLS_CAPTURE_WRITE_BIT);
    }
    
    fSuccess = MetaRcBegin(plrc, hdc);
    
    // Remove context to avoid inadvertent GLS calls
    // Also needed in failure case
    gepGlsFuncs.glsContext(0);

    if (fSuccess)
    {
        return TRUE;
    }

    gepGlsFuncs.glsDeleteContext(plrc->uiGlsCaptureContext);
    plrc->uiGlsCaptureContext = 0;
 EH_NoContext:
    DBGERROR("CreateMetaRc failed\n");
    return FALSE;
}

/*****************************Private*Routine******************************\
*
* DeleteMetaRc
*
* Cleans up a metafile RC
*
* History:
*  Thu Feb 23 16:35:19 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void DeleteMetaRc(PLRC plrc)
{
    GLuint uiGlsCurrent;
    
    if (plrc->uiGlsCaptureContext != 0)
    {
        // Make the GLS context current just in case
        // A different GLS context can be active at this time, though,
        // because a different metafile RC could be current to this
        // thread at the time of the delete, so we have to preserve
        // any current context
        uiGlsCurrent = gepGlsFuncs.glsGetCurrentContext();
    
        gepGlsFuncs.glsContext(plrc->uiGlsCaptureContext);

        // If we're still capturing, stop
        if (plrc->fCapturing)
        {
            MetaRcEnd(plrc);
        }

        // Restore old context
        gepGlsFuncs.glsContext(uiGlsCurrent);
    
        // Clean up dying context
        gepGlsFuncs.glsDeleteContext(plrc->uiGlsCaptureContext);
        plrc->uiGlsCaptureContext = 0;
    }

    // Clean up playback context if necessary
    // This can happen when metafile playback crashes or an
    // application crashes while enumerating
    if (plrc->uiGlsPlaybackContext != 0)
    {
        gepGlsFuncs.glsDeleteContext(plrc->uiGlsPlaybackContext);
        plrc->uiGlsPlaybackContext = 0;
    }
    
    // LRC and handle will be cleaned up elsewhere
}

/*****************************Private*Routine******************************\
*
* ActivateMetaRc
*
* Make a metafile RC current
*
* History:
*  Thu Feb 23 16:50:31 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void ActivateMetaRc(PLRC plrc, HDC hdc)
{
    ASSERTOPENGL(plrc->uiGlsCaptureContext != 0,
                 "ActivateMetaRc: No GLS context\n");
    ASSERTOPENGL(gepGlsFuncs.glsGetCurrentContext() == 0,
                 "ActivateMetaRc: Already a current GLS context\n");
    
    gepGlsFuncs.glsContext(plrc->uiGlsCaptureContext);
}

/*****************************Private*Routine******************************\
*
* DeactivateMetaRc
*
* Make a metafile RC non-current
*
* History:
*  Thu Feb 23 16:49:51 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void DeactivateMetaRc(PLRC plrc)
{
    // The current GLS context may not be this RC's capturing context
    // in the case where the RC has been made current after a
    // CloseEnhMetaFile has stopped capturing
    if (gepGlsFuncs.glsGetCurrentContext() == plrc->uiGlsCaptureContext)
    {
        gepGlsFuncs.glsContext(0);
    }
}

/*****************************Private*Routine******************************\
*
* GlmfSave
*
* Save all current GL state
*
* History:
*  Fri Feb 24 15:15:50 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void GlmfSave(void)
{
    // What is the exact list of state to be saved?
    // What about overflowing the projection and textures stacks?
    // They're small
    
    glPushAttrib(GL_ALL_ATTRIB_BITS);
    
    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();

    glMatrixMode(GL_PROJECTION);
    glPushMatrix();

    glMatrixMode(GL_TEXTURE);
    glPushMatrix();
}

/*****************************Private*Routine******************************\
*
* GlmfRestore
*
* Restores saved state
*
* History:
*  Fri Feb 24 15:16:14 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void GlmfRestore(void)
{
    glMatrixMode(GL_TEXTURE);
    glPopMatrix();

    glMatrixMode(GL_PROJECTION);
    glPopMatrix();

    glMatrixMode(GL_MODELVIEW);
    glPopMatrix();

    glPopAttrib();
}

#define ScaleLongX(plrc, l) \
    MulDiv(l, plrc->iGlsNumeratorX, plrc->iGlsDenominatorX)
#define ScaleLongY(plrc, l) \
    MulDiv(l, plrc->iGlsNumeratorY, plrc->iGlsDenominatorY)
#define ScaleFloatX(plrc, f) ((f)*(plrc)->fGlsScaleX)
#define ScaleFloatY(plrc, f) ((f)*(plrc)->fGlsScaleY)

/*****************************Private*Routine******************************\
*
* TransformLongPt
*
* Transform an integer point
*
* History:
*  Fri Feb 24 15:27:37 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void TransformLongPt(PLRC plrc, POINT *ppt)
{
    ppt->x = MulDiv(ppt->x-plrc->iGlsSubtractX, plrc->iGlsNumeratorX,
                    plrc->iGlsDenominatorX)+plrc->iGlsAddX;
    ppt->y = MulDiv(ppt->y-plrc->iGlsSubtractY, plrc->iGlsNumeratorY,
                    plrc->iGlsDenominatorY)+plrc->iGlsAddY;
}

/*****************************Private*Routine******************************\
*
* ScaleLongPt
*
* Scale an integer point, no translation, for values rather than coordinates
*
* History:
*  Fri Feb 24 15:27:52 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void ScaleLongPt(PLRC plrc, POINT *ppt)
{
    ppt->x = MulDiv(ppt->x, plrc->iGlsNumeratorX, plrc->iGlsDenominatorX);
    ppt->y = MulDiv(ppt->y, plrc->iGlsNumeratorY, plrc->iGlsDenominatorY);
}

/*****************************Private*Routine******************************\
*
* TransformFloatPt
*
* Transform a float point
*
* History:
*  Fri Feb 24 15:27:37 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void TransformFloatPt(PLRC plrc, POINTFLOAT *pptf)
{
    pptf->x = (pptf->x-plrc->iGlsSubtractX)*plrc->iGlsNumeratorX/
        plrc->iGlsDenominatorX+plrc->iGlsAddX;
    pptf->y = (pptf->y-plrc->iGlsSubtractY)*plrc->iGlsNumeratorY/
        plrc->iGlsDenominatorY+plrc->iGlsAddY;
}

/*****************************Private*Routine******************************\
*
* ScaleFloatPt
*
* Scale a float point
*
* History:
*  Fri Feb 24 15:27:37 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void ScaleFloatPt(PLRC plrc, POINTFLOAT *pptf)
{
    pptf->x = pptf->x*plrc->iGlsNumeratorX/plrc->iGlsDenominatorX;
    pptf->y = pptf->y*plrc->iGlsNumeratorY/plrc->iGlsDenominatorY;
}

/*****************************Private*Routine******************************\
*
* GLS output scaling callbacks
*
* The following functions are used as GLS command functions for
* intercepting device coordinates and scaling them appropriately
*
* Bitmap contents are not scaled, but the current raster position is
* correctly maintained so that they are positioned appropriately
*
* Stipples are not scaled
*
* History:
*  Fri Feb 24 15:28:23 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void GlsBitmapOut(GLsizei width, GLsizei height,
                  GLfloat xorig, GLfloat yorig,
                  GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
{
    PLRC plrc;
    POINTFLOAT ptf;

    plrc = GLTEB_CLTCURRENTRC();
    
    ptf.x = xmove;
    ptf.y = ymove;
    ScaleFloatPt(plrc, &ptf);
    
    glBitmap(width, height, xorig, yorig, ptf.x, ptf.y, bitmap);
}

void GlsCopyPixelsOut(GLint x, GLint y, GLsizei width, GLsizei height,
                      GLenum type)
{
    POINT ptXY, ptWH;
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();
    
    ptXY.x = x;
    ptXY.y = y;
    TransformLongPt(plrc, &ptXY);
    
    ptWH.x = (LONG)width;
    ptWH.y = (LONG)height;
    ScaleLongPt(plrc, &ptWH);

    glCopyPixels(ptXY.x, ptXY.y, ptWH.x, ptWH.y, type);
}

void GlsCopyTexImage1DOut(GLenum target, GLint level,
                          GLenum internalformat,
                          GLint x, GLint y,
                          GLsizei width, GLint border)
{
    POINT ptXY;
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();

    ptXY.x = x;
    ptXY.y = y;
    TransformLongPt(plrc, &ptXY);
    
    glCopyTexImage1D(target, level, internalformat,
                     ptXY.x, ptXY.y, ScaleLongX(plrc, width), border);
}

    
void GlsCopyTexImage2DOut(GLenum target, GLint level,
                          GLenum internalformat,
                          GLint x, GLint y,
                          GLsizei width, GLsizei height,
                          GLint border)
{
    POINT ptXY, ptWH;
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();

    ptXY.x = x;
    ptXY.y = y;
    TransformLongPt(plrc, &ptXY);
    
    ptWH.x = (LONG)width;
    ptWH.y = (LONG)height;
    ScaleLongPt(plrc, &ptWH);
    
    glCopyTexImage2D(target, level, internalformat,
                     ptXY.x, ptXY.y, ptWH.x, ptWH.y, border);
}

void GlsCopyTexSubImage1DOut(GLenum target, GLint level,
                             GLint xoffset, GLint x, GLint y,
                             GLsizei width)
{
    POINT ptXY;
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();

    ptXY.x = x;
    ptXY.y = y;
    TransformLongPt(plrc, &ptXY);
    
    glCopyTexSubImage1D(target, level, xoffset,
                        ptXY.x, ptXY.y, ScaleLongX(plrc, width));
}

void GlsCopyTexSubImage2DOut(GLenum target, GLint level,
                             GLint xoffset, GLint yoffset,
                             GLint x, GLint y,
                             GLsizei width, GLsizei height)
{
    POINT ptXY, ptWH;
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();

    ptXY.x = x;
    ptXY.y = y;
    TransformLongPt(plrc, &ptXY);
    
    ptWH.x = (LONG)width;
    ptWH.y = (LONG)height;
    ScaleLongPt(plrc, &ptWH);
    
    glCopyTexSubImage2D(target, level, xoffset, yoffset,
                        ptXY.x, ptXY.y, ptWH.x, ptWH.y);
}

void GlsLineWidthOut(GLfloat width)
{
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();

    // Use X scaling here
    glLineWidth(ScaleFloatX(plrc, width));
}

void GlsPointSizeOut(GLfloat size)
{
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();
    
    // Use X scaling here
    glPointSize(ScaleFloatX(plrc, size));
}

void GlsScissorOut(GLint x, GLint y, GLsizei width, GLsizei height)
{
    POINT ptXY, ptWH;
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();

    ptXY.x = x;
    ptXY.y = y;
    TransformLongPt(plrc, &ptXY);
    
    ptWH.x = (LONG)width;
    ptWH.y = (LONG)height;
    ScaleLongPt(plrc, &ptWH);

    glScissor(ptXY.x, ptXY.y, ptWH.x, ptWH.y);
}

void GlsViewportOut(GLint x, GLint y, GLsizei width, GLsizei height)
{
    POINT ptXY, ptWH;
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();

    ptXY.x = x;
    ptXY.y = y;
    TransformLongPt(plrc, &ptXY);
    
    ptWH.x = (LONG)width;
    ptWH.y = (LONG)height;
    ScaleLongPt(plrc, &ptWH);

#if 0
    DbgPrint("glViewport(%d, %d, %d, %d)\n", ptXY.x, ptXY.y,
             ptWH.x, ptWH.y);
#endif

    glViewport(ptXY.x, ptXY.y, ptWH.x, ptWH.y);
}

static GLDEVICEPROCS gdpOutput =
{
    GlsBitmapOut,
    GlsCopyPixelsOut,
    GlsCopyTexImage1DOut,
    GlsCopyTexImage2DOut,
    GlsCopyTexSubImage1DOut,
    GlsCopyTexSubImage2DOut,
    NULL, // glDrawPixels
    GlsLineWidthOut,
    GlsPointSizeOut,
    GlsScissorOut,
    GlsViewportOut
};

/*****************************Private*Routine******************************\
*
* GlmfHookDeviceFns
*
* Hook all functions that deal with device units
*
* History:
*  Fri Feb 24 15:30:45 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void GlmfHookDeviceFns(void)
{
    int i;
    PROC *ppfn;

    ppfn = (PROC *)&gdpOutput;
    for (i = 0; i < GL_DEVICE_PROCS; i++)
    {
        if (*ppfn != NULL)
        {
            gepGlsFuncs.glsCommandFunc(glsopDeviceProcs[i], *ppfn);
        }
        
        ppfn++;
    }
}

/*****************************Private*Routine******************************\
*
* GlmfInitTransform
*
* Compute 2D playback transform from source and destination rectangles
* Hook GLS with scaling functions
*
* History:
*  Fri Feb 24 15:31:24 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void GlmfInitTransform(LPRECTL prclFrom, LPRECTL prclTo)
{
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();
    
    // Rectangles are inclusive-inclusive
    
    plrc->iGlsSubtractX = prclFrom->left;
    plrc->iGlsSubtractY = prclFrom->top;
    plrc->iGlsNumeratorX = prclTo->right-prclTo->left+1;
    plrc->iGlsNumeratorY = prclTo->bottom-prclTo->top+1;
    plrc->iGlsDenominatorX = prclFrom->right-prclFrom->left+1;
    plrc->iGlsDenominatorY = prclFrom->bottom-prclFrom->top+1;
    plrc->iGlsAddX = prclTo->left;
    plrc->iGlsAddY = prclTo->top;

#if 0
    DbgPrint("- %d,%d * %d,%d / %d,%d + %d,%d\n",
             plrc->iGlsSubtractX, plrc->iGlsSubtractY,
             plrc->iGlsNumeratorX, plrc->iGlsNumeratorY,
             plrc->iGlsDenominatorX, plrc->iGlsDenominatorY,
             plrc->iGlsAddX, plrc->iGlsAddY);
#endif
    
    // Only install hooks if the transform is not identity
    if (plrc->iGlsSubtractX != plrc->iGlsAddX ||
        plrc->iGlsSubtractY != plrc->iGlsAddY ||
        plrc->iGlsNumeratorX != plrc->iGlsDenominatorX ||
        plrc->iGlsNumeratorY != plrc->iGlsDenominatorY)
    {
        plrc->fGlsScaleX = (GLfloat)plrc->iGlsNumeratorX/
            plrc->iGlsDenominatorX;
        plrc->fGlsScaleY = (GLfloat)plrc->iGlsNumeratorY/
            plrc->iGlsDenominatorY;

        GlmfHookDeviceFns();
    }
}

// Table of functions which need to have their command funcs
// reset for playback virtualization
static GLSopcode opRecirculate[] =
{
    GLS_OP_glsBeginGLS,
    GLS_OP_glsBlock,
    GLS_OP_glsCallStream,
    GLS_OP_glsEndGLS,
    GLS_OP_glsError,
    GLS_OP_glsGLRC,
    GLS_OP_glsGLRCLayer,
    GLS_OP_glsHeaderGLRCi,
    GLS_OP_glsHeaderLayerf,
    GLS_OP_glsHeaderLayeri,
    GLS_OP_glsHeaderf,
    GLS_OP_glsHeaderfv,
    GLS_OP_glsHeaderi,
    GLS_OP_glsHeaderiv,
    GLS_OP_glsHeaderubz,
    GLS_OP_glsRequireExtension,
    GLS_OP_glsUnsupportedCommand,
    GLS_OP_glsAppRef,
    GLS_OP_glsBeginObj,
    GLS_OP_glsCharubz,
    GLS_OP_glsComment,
    GLS_OP_glsDisplayMapfv,
    GLS_OP_glsEndObj,
    GLS_OP_glsNumb,
    GLS_OP_glsNumbv,
    GLS_OP_glsNumd,
    GLS_OP_glsNumdv,
    GLS_OP_glsNumf,
    GLS_OP_glsNumfv,
    GLS_OP_glsNumi,
    GLS_OP_glsNumiv,
    GLS_OP_glsNuml,
    GLS_OP_glsNumlv,
    GLS_OP_glsNums,
    GLS_OP_glsNumsv,
    GLS_OP_glsNumub,
    GLS_OP_glsNumubv,
    GLS_OP_glsNumui,
    GLS_OP_glsNumuiv,
    GLS_OP_glsNumul,
    GLS_OP_glsNumulv,
    GLS_OP_glsNumus,
    GLS_OP_glsNumusv,
    GLS_OP_glsPad,
    GLS_OP_glsSwapBuffers
};
#define RECIRCULATE_OPS (sizeof(opRecirculate)/sizeof(opRecirculate[0]))

/******************************Public*Routine******************************\
*
* GlmfInitPlayback
*
* Initialize GL metafile playback, called from PlayEnhMetaFile for
* metafiles with GL information in them
*
* History:
*  Fri Feb 24 10:32:29 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY GlmfInitPlayback(HDC hdc, ENHMETAHEADER *pemh, LPRECTL prclDest)
{
    GLuint uiCurrentCtx;
    PLRC plrc;
    RECTL rclSourceDevice;
    int i;

    // If we don't have the appropriate GL context set up,
    // do nothing.  This allows applications to play metafiles containing
    // GL information even if they don't know anything about GL
    plrc = GLTEB_CLTCURRENTRC();
    if (plrc == NULL)
    {
        return TRUE;
    }
    
    if (!MetaLoadGls())
    {
        return FALSE;
    }

    plrc->uiGlsPlaybackContext = gepGlsFuncs.glsGenContext();
    if (plrc->uiGlsPlaybackContext == 0)
    {
        return FALSE;
    }

    GlmfSave();

    // Set an initial viewport just as a default
    glViewport(prclDest->left, prclDest->top,
               prclDest->right-prclDest->left,
               prclDest->bottom-prclDest->top);

    // The frame is in .01mm units.  Convert it to reference
    // device units using the information in the metafile header
    rclSourceDevice.left = MulDiv(pemh->rclFrame.left, pemh->szlDevice.cx,
                                  pemh->szlMillimeters.cx*100);
    rclSourceDevice.right = MulDiv(pemh->rclFrame.right, pemh->szlDevice.cx,
                                   pemh->szlMillimeters.cx*100);
    rclSourceDevice.top = MulDiv(pemh->rclFrame.top, pemh->szlDevice.cy,
                                 pemh->szlMillimeters.cy*100);
    rclSourceDevice.bottom = MulDiv(pemh->rclFrame.bottom, pemh->szlDevice.cy,
                                    pemh->szlMillimeters.cy*100);

    // We are resetting command funcs so we need our playback context
    // to be current.  Another context could be current now, though,
    // so preserve it
    uiCurrentCtx = gepGlsFuncs.glsGetCurrentContext();
    gepGlsFuncs.glsContext(plrc->uiGlsPlaybackContext);
    
    GlmfInitTransform(&rclSourceDevice, prclDest);

    // Reset all GLS command funcs to point to the actual exported
    // routines.  This means that playback on this context will
    // be exactly the same as if all the routines were being called
    // directly, so embedding a metafile into another one works
    // as expected
    //
    // NOTE: This context should not be made current because any
    // GLS commands executed on it when it is current will now
    // cause infinite loops
    for (i = 0; i < RECIRCULATE_OPS; i++)
    {
        gepGlsFuncs.glsCommandFunc(opRecirculate[i],
                                   (&gepGlsFuncs.glsBeginGLS)[i]);
    }

    // Restore preserved context
    gepGlsFuncs.glsContext(uiCurrentCtx);
    
    return TRUE;
}

/******************************Public*Routine******************************\
*
* GlmfBeginGlsBlock
*
* Sets up things for GLS record playback which can only be active during
* GLS records
* Currently this only sets the world transform to identity to avoid
* it interacting with GL drawing
*
* History:
*  Mon Apr 10 11:20:19 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY GlmfBeginGlsBlock(HDC hdc)
{
    PLRC plrc;
    BOOL bRet;
    
    // If we don't have the appropriate GL context set up,
    // do nothing.  This allows applications to play metafiles containing
    // GL information even if they don't know anything about GL
    plrc = GLTEB_CLTCURRENTRC();
    if (plrc == NULL)
    {
        return TRUE;
    }
    
    bRet = GetWorldTransform(hdc, &plrc->xformMeta);
    if (bRet)
    {
        bRet = ModifyWorldTransform(hdc, NULL, MWT_IDENTITY);
    }

    return bRet;
}
    
/******************************Public*Routine******************************\
*
* GlmfPlayGlsRecord
*
* Play a GL metafile record
*
* History:
*  Fri Feb 24 10:33:38 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#define PLAY_STACK_BUFFER 256

BOOL APIENTRY GlmfPlayGlsRecord(HDC hdc, DWORD cb, BYTE *pb,
                                LPRECTL prclBounds)
{
    PLRC plrc;
    LARGE_INTEGER liBuffer[(PLAY_STACK_BUFFER+sizeof(LARGE_INTEGER)-1)/
                           sizeof(LARGE_INTEGER)+1];
    BYTE *pbPlay, *pbAlloc = NULL;
    __GLSbinCommandHead_large *gbch;
    GLSopcode op;
    GLScommandAlignment gca;

#if 0
    DbgPrint("GlmfPlayGlsRecord(%d)\n", cb);
#endif
    
    // If we don't have the appropriate GL and GLS contexts set up,
    // do nothing.  This allows applications to play metafiles containing
    // GL information even if they don't know anything about GL
    plrc = GLTEB_CLTCURRENTRC();
    if (plrc == NULL || plrc->uiGlsPlaybackContext == 0)
    {
        return TRUE;
    }
    
    ASSERTOPENGL(hGlsDll != NULL, "GlmfPlayGlsRecord: GLS not loaded\n");
    
    ASSERTOPENGL(plrc->tidCurrent == GetCurrentThreadId(),
                 "GlmfPlayGlsRecord: "
                 "Current RC does not belong to this thread!\n");
    ASSERTOPENGL(plrc->gwidCurrent.hdc != 0,
                 "GlmfPlayGlsRecord: Current HDC is NULL!\n");

    // pb points to some arbitrary block of memory
    // GLS requires that this block be appropriately aligned for
    // any commands that are executed out of it, so we need to
    // determine which command is in the buffer and then query
    // GLS for its alignment.
    // This is trickier than you would think since GLS doesn't
    // always add padding to commands relative to their beginning; it
    // sometimes adds padding to the end of the previous command.
    // We need to detect the case where padding is added.
    // 
    // NOTE: This definitely works when there is only one command
    // in the buffer.  It should work when there are multiple commands
    // because the following commands are padded according to the 
    // alignment of the initial command.  However, this assumption
    // should probably be validated if blocks start containing
    // multiple commands.

    // Check for an initial pad and skip it if necessary
    gbch = (__GLSbinCommandHead_large *)pb;
    if (gbch->opSmall == GLS_OP_glsPad &&
        gbch->countSmall == 1)
    {
        pb += sizeof(__GLSbinCommandHead_small);
        cb -= sizeof(__GLSbinCommandHead_small);
        gbch = (__GLSbinCommandHead_large *)pb;
    }

    ASSERTOPENGL(gbch->countSmall == 0 ||
                 gbch->opSmall != GLS_OP_glsPad,
                 "Unexpected glsPad in command buffer\n");

    op = gbch->countSmall == 0 ? gbch->opLarge : gbch->opSmall;

    gepGlsFuncs.glsGetCommandAlignment(op, gepGlsFuncs.glsBinary(GL_FALSE),
                                       &gca);
    ASSERTOPENGL(gca.mask <= 7, "Unhandled GLS playback alignment\n");

    if (((ULONG_PTR)pb & gca.mask) != gca.value)
    {
        if (cb <= PLAY_STACK_BUFFER)
        {
            pbPlay = (BYTE *)liBuffer+gca.value;
        }
        else
        {
            pbAlloc = (BYTE *)ALLOC(cb+gca.value);
            if (pbAlloc == NULL)
            {
                return FALSE;
            }

            pbPlay = pbAlloc+gca.value;
        }
        
        RtlCopyMemory(pbPlay, pb, cb);
    }
    else
    {
        pbPlay = pb;
    }
    
    gepGlsFuncs.glsCallArrayInContext(plrc->uiGlsPlaybackContext,
                                      gepGlsFuncs.glsBinary(GL_FALSE),
                                      cb, pbPlay);

    if (pbAlloc != NULL)
    {
        FREE(pbAlloc);
    }
    
    return TRUE;
}

/******************************Public*Routine******************************\
*
* GlmfEndGlsBlock
*
* Resets state changed for GLS record playback
* Currently restores the world transform
*
* History:
*  Mon Apr 10 11:23:06 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY GlmfEndGlsBlock(HDC hdc)
{
    PLRC plrc;
    
    // If we don't have the appropriate GL context set up,
    // do nothing.  This allows applications to play metafiles containing
    // GL information even if they don't know anything about GL
    plrc = GLTEB_CLTCURRENTRC();
    if (plrc == NULL)
    {
        return TRUE;
    }

    // Doesn't matter which side we multiply by since the transform
    // should be identity
    return ModifyWorldTransform(hdc, &plrc->xformMeta, MWT_LEFTMULTIPLY);
}
    
/******************************Public*Routine******************************\
*
* GlmfEndPlayback
*
* End GL metafile playback, called at the end of metafile playback
* Only called if GlmfInitPlayback was successful
*
* History:
*  Fri Feb 24 10:36:36 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY GlmfEndPlayback(HDC hdc)
{
    PLRC plrc;

    // If we don't have the appropriate GL and GLS contexts set up,
    // do nothing.  This allows applications to play metafiles containing
    // GL information even if they don't know anything about GL
    plrc = GLTEB_CLTCURRENTRC();
    if (plrc == NULL || plrc->uiGlsPlaybackContext == 0)
    {
        return TRUE;
    }

    ASSERTOPENGL(hGlsDll != NULL, "GlmfEndPlayback: GLS not loaded\n");

    // Since GlmfInitPlayback completed, we must have saved state
    GlmfRestore();

    ASSERTOPENGL(plrc->uiGlsPlaybackContext != 0,
                 "GlmfEndPlayback: No playback context\n");
    gepGlsFuncs.glsDeleteContext(plrc->uiGlsPlaybackContext);
    plrc->uiGlsPlaybackContext = 0;

    // Request cleanup of windows on the theory that most orphaned
    // windows are produced by DCs created for metafiles and memory
    // DCs used by printing.  Cleaning up during playback will mean
    // that orphaned windows are only around for one extra playback
    wglValidateWindows();

    return TRUE;
}

/******************************Public*Routine******************************\
*
* GlmfCloseMetaFile
*
* Called in CloseEnhMetaFile if GL records are present in the metafile
*
* History:
*  Fri Mar 03 18:05:50 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY GlmfCloseMetaFile(HDC hdc)
{
    PLRC plrc;
    GLGENwindow *pwnd;
    GLWINDOWID gwid;

    // This DC has just gone away so clean up its WNDOBJ if necessary
    WindowIdFromHdc(hdc, &gwid);
    pwnd = pwndGetFromID(&gwid);
    if (pwnd != NULL)
    {
        pwndCleanup(pwnd);
    }
    
    // The app could have called wglDeleteContext before CloseEnhMetaFile,
    // so we're not guaranteed to have a context
    plrc = GLTEB_CLTCURRENTRC();
    if (plrc == NULL ||
        !plrc->fCapturing)
    {
        return TRUE;
    }

    ASSERTOPENGL(hGlsDll != NULL, "GlmfCloseMetaFile: GLS not loaded\n");

    ASSERTOPENGL(plrc->uiGlsCaptureContext != 0,
                 "GlmfCloseMetaFile: GLS context is invalid");
    MetaRcEnd(plrc);

    // Set the proc table to the generic routines because capturing
    // is over.  Metafiling always uses the generic routines because
    // the underlying surface is always faked on top of an info DC.
    {
    // Use RGBA or CI proc table depending on the color mode.

	GLCLTPROCTABLE *pglProcTable;
	__GL_SETUP();

	if (gc->modes.colorIndexMode)
	    pglProcTable = &glCltCIProcTable;
	else
	    pglProcTable = &glCltRGBAProcTable;

	SetCltProcTable(pglProcTable, &glExtProcTable, TRUE);
    }

    return TRUE;
}

/******************************Public*Routine******************************\
*
* GlGdi routines
*
* Thunks to allow the same binary to run on both NT with metafile support
* and Win95 without it
*
* History:
*  Thu Aug 31 15:46:37 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#if DBG
BOOL APIENTRY GlGdiAddGlsRecord(HDC hdc, DWORD cb, BYTE *pb,
                                LPRECTL prclBounds)
{
    ASSERTOPENGL(pfnGdiAddGlsRecord != NULL,
                 "GdiAddGlsRecord called without support\n");
    return pfnGdiAddGlsRecord(hdc, cb, pb, prclBounds);
}

BOOL APIENTRY GlGdiAddGlsBounds(HDC hdc, LPRECTL prclBounds)
{
    ASSERTOPENGL(pfnGdiAddGlsBounds != NULL,
                 "GdiAddGlsBounds called without support\n");
    return pfnGdiAddGlsBounds(hdc, prclBounds);
}

BOOL APIENTRY GlGdiIsMetaPrintDC(HDC hdc)
{
    ASSERTOPENGL(pfnGdiIsMetaPrintDC != NULL,
                 "GdiIsMetaPrintDC called without support\n");
    return pfnGdiIsMetaPrintDC(hdc);
}
#endif

#else

PROC * APIENTRY wglGetDefaultDispatchTable(void)
{
    return NULL;
}

BOOL APIENTRY GlmfInitPlayback(HDC hdc, ENHMETAHEADER *pemh, LPRECTL prclDest)
{
    return FALSE;
}

BOOL APIENTRY GlmfBeginGlsBlock(HDC hdc)
{
    return FALSE;
}

BOOL APIENTRY GlmfPlayGlsRecord(HDC hdc, DWORD cb, BYTE *pb,
                                LPRECTL prclBounds)
{
    return FALSE;
}

BOOL APIENTRY GlmfEndGlsBlock(HDC hdc)
{
    return FALSE;
}

BOOL APIENTRY GlmfEndPlayback(HDC hdc)
{
    return FALSE;
}

BOOL APIENTRY GlmfCloseMetaFile(HDC hdc)
{
    return FALSE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <ddrawp.h>
#include <GL/gl.h>

#include <stddef.h>

#define _NO_DDRAWINT_NO_COM
#include <winddi.h>
#include <glapi.h>
#include <glteb.h>
// temporay workaround for NT 3.51
// typedef ULONG FLONG;
#include <gldrv.h>
#include <glp.h>
#include <glgenwin.h>

#include "local.h"
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\noopapir.c ===
/*
** Copyright 1991, 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* AUTOMATICALLY UPDATED OR GENERATED BY SGI: DO NOT EDIT */

// Noop api dispatch for risc

#include "precomp.h"
#pragma hdrstop

#if DBG
// The WARNING_NOOP macro will output the debug message once only.
// If we have output a warning before, the new warnings are ignored.

int cWarningNoop = 0;

#define WARNING_NOOP(str)                                       \
        {                                                       \
            if (!cWarningNoop++)                                \
                DbgPrint("%s(%d): " str,__FILE__,__LINE__);     \
        }
#else
#define WARNING_NOOP(str)
#endif // DBG

// Some functions have return values!
GLint APIENTRY
glnoop(void)
{
    WARNING_NOOP("GL Noop\n");
    return 0;
}

const VOID * APIENTRY
glnoopptr(void)
{
    WARNING_NOOP("GL Noop\n");
    return 0;
}

GLenum APIENTRY
glnoopGetError ( void )
{
    WARNING_NOOP("GL Noop:glGetError\n");
    return(GL_INVALID_OPERATION);
}

#pragma warning(disable : 4113)
#pragma warning(disable : 4133)
#pragma warning(disable : 4047)
#pragma warning(disable : 4028)

/* Client Side Procedure Table */
/* WARNING:  If size of table changes, this file must be changed */

GLCLTPROCTABLE glNullCltProcTable = {

/* Number of function entries in the table */

     sizeof(GLDISPATCHTABLE) / sizeof(PROC),

/* gl Entry points */
  {
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoopGetError,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoopptr,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
  }
};

GLEXTPROCTABLE glNullExtProcTable =
{
    /* Number of function entries in the table */
     sizeof(GLEXTDISPATCHTABLE) / sizeof(PROC),

    /* EXT Entry points */
    {
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
	glnoop,
#ifdef GL_WIN_multiple_textures
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
#endif // GL_WIN_multiple_textures
    }
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\noopapi.c ===
/*
** Copyright 1991, 1992, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* AUTOMATICALLY UPDATED OR GENERATED BY SGI: DO NOT EDIT */

#include "precomp.h"
#pragma hdrstop

#if DBG
// The WARNING_NOOP macro will output the debug message once only.
// If we have output a warning before, the new warnings are ignored.

int cWarningNoop = 0;

#define WARNING_NOOP(str)                                       \
        {                                                       \
            if (!cWarningNoop++)                                \
                DbgPrint("%s(%d): " str,__FILE__,__LINE__);     \
        }
#else
#define WARNING_NOOP(str)
#endif // DBG

void APIENTRY
glnoopNewList ( IN GLuint list, IN GLenum mode )
{
    WARNING_NOOP("GL Noop:glNewList\n");
}

void APIENTRY
glnoopEndList ( void )
{
    WARNING_NOOP("GL Noop:glEndList\n");
}

void APIENTRY
glnoopCallList ( IN GLuint list )
{
    WARNING_NOOP("GL Noop:glCallList\n");
}

void APIENTRY
glnoopCallLists ( IN GLsizei n, IN GLenum type, IN const GLvoid *lists )
{
    WARNING_NOOP("GL Noop:glCallLists\n");
}

void APIENTRY
glnoopDeleteLists ( IN GLuint list, IN GLsizei range )
{
    WARNING_NOOP("GL Noop:glDeleteLists\n");
}

GLuint APIENTRY
glnoopGenLists ( IN GLsizei range )
{
    WARNING_NOOP("GL Noop:glGenLists\n");
    return ((GLuint) 0);
}

void APIENTRY
glnoopListBase ( IN GLuint base )
{
    WARNING_NOOP("GL Noop:glListBase\n");
}

void APIENTRY
glnoopBegin ( IN GLenum mode )
{
    WARNING_NOOP("GL Noop:glBegin\n");
}

void APIENTRY
glnoopBitmap ( IN GLsizei width, IN GLsizei height, IN GLfloat xorig, IN GLfloat yorig, IN GLfloat xmove, IN GLfloat ymove, IN const GLubyte bitmap[] )
{
    WARNING_NOOP("GL Noop:glBitmap\n");
}

void APIENTRY
glnoopColor3b ( IN GLbyte red, IN GLbyte green, IN GLbyte blue )
{
    WARNING_NOOP("GL Noop:glColor3b\n");
}

void APIENTRY
glnoopColor3bv ( IN const GLbyte v[3] )
{
    WARNING_NOOP("GL Noop:glColor3bv\n");
}

void APIENTRY
glnoopColor3d ( IN GLdouble red, IN GLdouble green, IN GLdouble blue )
{
    WARNING_NOOP("GL Noop:glColor3d\n");
}

void APIENTRY
glnoopColor3dv ( IN const GLdouble v[3] )
{
    WARNING_NOOP("GL Noop:glColor3dv\n");
}

void APIENTRY
glnoopColor3f ( IN GLfloat red, IN GLfloat green, IN GLfloat blue )
{
    WARNING_NOOP("GL Noop:glColor3f\n");
}

void APIENTRY
glnoopColor3fv ( IN const GLfloat v[3] )
{
    WARNING_NOOP("GL Noop:glColor3fv\n");
}

void APIENTRY
glnoopColor3i ( IN GLint red, IN GLint green, IN GLint blue )
{
    WARNING_NOOP("GL Noop:glColor3i\n");
}

void APIENTRY
glnoopColor3iv ( IN const GLint v[3] )
{
    WARNING_NOOP("GL Noop:glColor3iv\n");
}

void APIENTRY
glnoopColor3s ( IN GLshort red, IN GLshort green, IN GLshort blue )
{
    WARNING_NOOP("GL Noop:glColor3s\n");
}

void APIENTRY
glnoopColor3sv ( IN const GLshort v[3] )
{
    WARNING_NOOP("GL Noop:glColor3sv\n");
}

void APIENTRY
glnoopColor3ub ( IN GLubyte red, IN GLubyte green, IN GLubyte blue )
{
    WARNING_NOOP("GL Noop:glColor3ub\n");
}

void APIENTRY
glnoopColor3ubv ( IN const GLubyte v[3] )
{
    WARNING_NOOP("GL Noop:glColor3ubv\n");
}

void APIENTRY
glnoopColor3ui ( IN GLuint red, IN GLuint green, IN GLuint blue )
{
    WARNING_NOOP("GL Noop:glColor3ui\n");
}

void APIENTRY
glnoopColor3uiv ( IN const GLuint v[3] )
{
    WARNING_NOOP("GL Noop:glColor3uiv\n");
}

void APIENTRY
glnoopColor3us ( IN GLushort red, IN GLushort green, IN GLushort blue )
{
    WARNING_NOOP("GL Noop:glColor3us\n");
}

void APIENTRY
glnoopColor3usv ( IN const GLushort v[3] )
{
    WARNING_NOOP("GL Noop:glColor3usv\n");
}

void APIENTRY
glnoopColor4b ( IN GLbyte red, IN GLbyte green, IN GLbyte blue, IN GLbyte alpha )
{
    WARNING_NOOP("GL Noop:glColor4b\n");
}

void APIENTRY
glnoopColor4bv ( IN const GLbyte v[4] )
{
    WARNING_NOOP("GL Noop:glColor4bv\n");
}

void APIENTRY
glnoopColor4d ( IN GLdouble red, IN GLdouble green, IN GLdouble blue, IN GLdouble alpha )
{
    WARNING_NOOP("GL Noop:glColor4d\n");
}

void APIENTRY
glnoopColor4dv ( IN const GLdouble v[4] )
{
    WARNING_NOOP("GL Noop:glColor4dv\n");
}

void APIENTRY
glnoopColor4f ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha )
{
    WARNING_NOOP("GL Noop:glColor4f\n");
}

void APIENTRY
glnoopColor4fv ( IN const GLfloat v[4] )
{
    WARNING_NOOP("GL Noop:glColor4fv\n");
}

void APIENTRY
glnoopColor4i ( IN GLint red, IN GLint green, IN GLint blue, IN GLint alpha )
{
    WARNING_NOOP("GL Noop:glColor4i\n");
}

void APIENTRY
glnoopColor4iv ( IN const GLint v[4] )
{
    WARNING_NOOP("GL Noop:glColor4iv\n");
}

void APIENTRY
glnoopColor4s ( IN GLshort red, IN GLshort green, IN GLshort blue, IN GLshort alpha )
{
    WARNING_NOOP("GL Noop:glColor4s\n");
}

void APIENTRY
glnoopColor4sv ( IN const GLshort v[4] )
{
    WARNING_NOOP("GL Noop:glColor4sv\n");
}

void APIENTRY
glnoopColor4ub ( IN GLubyte red, IN GLubyte green, IN GLubyte blue, IN GLubyte alpha )
{
    WARNING_NOOP("GL Noop:glColor4ub\n");
}

void APIENTRY
glnoopColor4ubv ( IN const GLubyte v[4] )
{
    WARNING_NOOP("GL Noop:glColor4ubv\n");
}

void APIENTRY
glnoopColor4ui ( IN GLuint red, IN GLuint green, IN GLuint blue, IN GLuint alpha )
{
    WARNING_NOOP("GL Noop:glColor4ui\n");
}

void APIENTRY
glnoopColor4uiv ( IN const GLuint v[4] )
{
    WARNING_NOOP("GL Noop:glColor4uiv\n");
}

void APIENTRY
glnoopColor4us ( IN GLushort red, IN GLushort green, IN GLushort blue, IN GLushort alpha )
{
    WARNING_NOOP("GL Noop:glColor4us\n");
}

void APIENTRY
glnoopColor4usv ( IN const GLushort v[4] )
{
    WARNING_NOOP("GL Noop:glColor4usv\n");
}

void APIENTRY
glnoopEdgeFlag ( IN GLboolean flag )
{
    WARNING_NOOP("GL Noop:glEdgeFlag\n");
}

void APIENTRY
glnoopEdgeFlagv ( IN const GLboolean flag[1] )
{
    WARNING_NOOP("GL Noop:glEdgeFlagv\n");
}

void APIENTRY
glnoopEnd ( void )
{
    WARNING_NOOP("GL Noop:glEnd\n");
}

void APIENTRY
glnoopIndexd ( IN GLdouble c )
{
    WARNING_NOOP("GL Noop:glIndexd\n");
}

void APIENTRY
glnoopIndexdv ( IN const GLdouble c[1] )
{
    WARNING_NOOP("GL Noop:glIndexdv\n");
}

void APIENTRY
glnoopIndexf ( IN GLfloat c )
{
    WARNING_NOOP("GL Noop:glIndexf\n");
}

void APIENTRY
glnoopIndexfv ( IN const GLfloat c[1] )
{
    WARNING_NOOP("GL Noop:glIndexfv\n");
}

void APIENTRY
glnoopIndexi ( IN GLint c )
{
    WARNING_NOOP("GL Noop:glIndexi\n");
}

void APIENTRY
glnoopIndexiv ( IN const GLint c[1] )
{
    WARNING_NOOP("GL Noop:glIndexiv\n");
}

void APIENTRY
glnoopIndexs ( IN GLshort c )
{
    WARNING_NOOP("GL Noop:glIndexs\n");
}

void APIENTRY
glnoopIndexsv ( IN const GLshort c[1] )
{
    WARNING_NOOP("GL Noop:glIndexsv\n");
}

void APIENTRY
glnoopNormal3b ( IN GLbyte nx, IN GLbyte ny, IN GLbyte nz )
{
    WARNING_NOOP("GL Noop:glNormal3b\n");
}

void APIENTRY
glnoopNormal3bv ( IN const GLbyte v[3] )
{
    WARNING_NOOP("GL Noop:glNormal3bv\n");
}

void APIENTRY
glnoopNormal3d ( IN GLdouble nx, IN GLdouble ny, IN GLdouble nz )
{
    WARNING_NOOP("GL Noop:glNormal3d\n");
}

void APIENTRY
glnoopNormal3dv ( IN const GLdouble v[3] )
{
    WARNING_NOOP("GL Noop:glNormal3dv\n");
}

void APIENTRY
glnoopNormal3f ( IN GLfloat nx, IN GLfloat ny, IN GLfloat nz )
{
    WARNING_NOOP("GL Noop:glNormal3f\n");
}

void APIENTRY
glnoopNormal3fv ( IN const GLfloat v[3] )
{
    WARNING_NOOP("GL Noop:glNormal3fv\n");
}

void APIENTRY
glnoopNormal3i ( IN GLint nx, IN GLint ny, IN GLint nz )
{
    WARNING_NOOP("GL Noop:glNormal3i\n");
}

void APIENTRY
glnoopNormal3iv ( IN const GLint v[3] )
{
    WARNING_NOOP("GL Noop:glNormal3iv\n");
}

void APIENTRY
glnoopNormal3s ( IN GLshort nx, IN GLshort ny, IN GLshort nz )
{
    WARNING_NOOP("GL Noop:glNormal3s\n");
}

void APIENTRY
glnoopNormal3sv ( IN const GLshort v[3] )
{
    WARNING_NOOP("GL Noop:glNormal3sv\n");
}

void APIENTRY
glnoopRasterPos2d ( IN GLdouble x, IN GLdouble y )
{
    WARNING_NOOP("GL Noop:glRasterPos2d\n");
}

void APIENTRY
glnoopRasterPos2dv ( IN const GLdouble v[2] )
{
    WARNING_NOOP("GL Noop:glRasterPos2dv\n");
}

void APIENTRY
glnoopRasterPos2f ( IN GLfloat x, IN GLfloat y )
{
    WARNING_NOOP("GL Noop:glRasterPos2f\n");
}

void APIENTRY
glnoopRasterPos2fv ( IN const GLfloat v[2] )
{
    WARNING_NOOP("GL Noop:glRasterPos2fv\n");
}

void APIENTRY
glnoopRasterPos2i ( IN GLint x, IN GLint y )
{
    WARNING_NOOP("GL Noop:glRasterPos2i\n");
}

void APIENTRY
glnoopRasterPos2iv ( IN const GLint v[2] )
{
    WARNING_NOOP("GL Noop:glRasterPos2iv\n");
}

void APIENTRY
glnoopRasterPos2s ( IN GLshort x, IN GLshort y )
{
    WARNING_NOOP("GL Noop:glRasterPos2s\n");
}

void APIENTRY
glnoopRasterPos2sv ( IN const GLshort v[2] )
{
    WARNING_NOOP("GL Noop:glRasterPos2sv\n");
}

void APIENTRY
glnoopRasterPos3d ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    WARNING_NOOP("GL Noop:glRasterPos3d\n");
}

void APIENTRY
glnoopRasterPos3dv ( IN const GLdouble v[3] )
{
    WARNING_NOOP("GL Noop:glRasterPos3dv\n");
}

void APIENTRY
glnoopRasterPos3f ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    WARNING_NOOP("GL Noop:glRasterPos3f\n");
}

void APIENTRY
glnoopRasterPos3fv ( IN const GLfloat v[3] )
{
    WARNING_NOOP("GL Noop:glRasterPos3fv\n");
}

void APIENTRY
glnoopRasterPos3i ( IN GLint x, IN GLint y, IN GLint z )
{
    WARNING_NOOP("GL Noop:glRasterPos3i\n");
}

void APIENTRY
glnoopRasterPos3iv ( IN const GLint v[3] )
{
    WARNING_NOOP("GL Noop:glRasterPos3iv\n");
}

void APIENTRY
glnoopRasterPos3s ( IN GLshort x, IN GLshort y, IN GLshort z )
{
    WARNING_NOOP("GL Noop:glRasterPos3s\n");
}

void APIENTRY
glnoopRasterPos3sv ( IN const GLshort v[3] )
{
    WARNING_NOOP("GL Noop:glRasterPos3sv\n");
}

void APIENTRY
glnoopRasterPos4d ( IN GLdouble x, IN GLdouble y, IN GLdouble z, IN GLdouble w )
{
    WARNING_NOOP("GL Noop:glRasterPos4d\n");
}

void APIENTRY
glnoopRasterPos4dv ( IN const GLdouble v[4] )
{
    WARNING_NOOP("GL Noop:glRasterPos4dv\n");
}

void APIENTRY
glnoopRasterPos4f ( IN GLfloat x, IN GLfloat y, IN GLfloat z, IN GLfloat w )
{
    WARNING_NOOP("GL Noop:glRasterPos4f\n");
}

void APIENTRY
glnoopRasterPos4fv ( IN const GLfloat v[4] )
{
    WARNING_NOOP("GL Noop:glRasterPos4fv\n");
}

void APIENTRY
glnoopRasterPos4i ( IN GLint x, IN GLint y, IN GLint z, IN GLint w )
{
    WARNING_NOOP("GL Noop:glRasterPos4i\n");
}

void APIENTRY
glnoopRasterPos4iv ( IN const GLint v[4] )
{
    WARNING_NOOP("GL Noop:glRasterPos4iv\n");
}

void APIENTRY
glnoopRasterPos4s ( IN GLshort x, IN GLshort y, IN GLshort z, IN GLshort w )
{
    WARNING_NOOP("GL Noop:glRasterPos4s\n");
}

void APIENTRY
glnoopRasterPos4sv ( IN const GLshort v[4] )
{
    WARNING_NOOP("GL Noop:glRasterPos4sv\n");
}

void APIENTRY
glnoopRectd ( IN GLdouble x1, IN GLdouble y1, IN GLdouble x2, IN GLdouble y2 )
{
    WARNING_NOOP("GL Noop:glRectd\n");
}

void APIENTRY
glnoopRectdv ( IN const GLdouble v1[2], IN const GLdouble v2[2] )
{
    WARNING_NOOP("GL Noop:glRectdv\n");
}

void APIENTRY
glnoopRectf ( IN GLfloat x1, IN GLfloat y1, IN GLfloat x2, IN GLfloat y2 )
{
    WARNING_NOOP("GL Noop:glRectf\n");
}

void APIENTRY
glnoopRectfv ( IN const GLfloat v1[2], IN const GLfloat v2[2] )
{
    WARNING_NOOP("GL Noop:glRectfv\n");
}

void APIENTRY
glnoopRecti ( IN GLint x1, IN GLint y1, IN GLint x2, IN GLint y2 )
{
    WARNING_NOOP("GL Noop:glRecti\n");
}

void APIENTRY
glnoopRectiv ( IN const GLint v1[2], IN const GLint v2[2] )
{
    WARNING_NOOP("GL Noop:glRectiv\n");
}

void APIENTRY
glnoopRects ( IN GLshort x1, IN GLshort y1, IN GLshort x2, IN GLshort y2 )
{
    WARNING_NOOP("GL Noop:glRects\n");
}

void APIENTRY
glnoopRectsv ( IN const GLshort v1[2], IN const GLshort v2[2] )
{
    WARNING_NOOP("GL Noop:glRectsv\n");
}

void APIENTRY
glnoopTexCoord1d ( IN GLdouble s )
{
    WARNING_NOOP("GL Noop:glTexCoord1d\n");
}

void APIENTRY
glnoopTexCoord1dv ( IN const GLdouble v[1] )
{
    WARNING_NOOP("GL Noop:glTexCoord1dv\n");
}

void APIENTRY
glnoopTexCoord1f ( IN GLfloat s )
{
    WARNING_NOOP("GL Noop:glTexCoord1f\n");
}

void APIENTRY
glnoopTexCoord1fv ( IN const GLfloat v[1] )
{
    WARNING_NOOP("GL Noop:glTexCoord1fv\n");
}

void APIENTRY
glnoopTexCoord1i ( IN GLint s )
{
    WARNING_NOOP("GL Noop:glTexCoord1i\n");
}

void APIENTRY
glnoopTexCoord1iv ( IN const GLint v[1] )
{
    WARNING_NOOP("GL Noop:glTexCoord1iv\n");
}

void APIENTRY
glnoopTexCoord1s ( IN GLshort s )
{
    WARNING_NOOP("GL Noop:glTexCoord1s\n");
}

void APIENTRY
glnoopTexCoord1sv ( IN const GLshort v[1] )
{
    WARNING_NOOP("GL Noop:glTexCoord1sv\n");
}

void APIENTRY
glnoopTexCoord2d ( IN GLdouble s, IN GLdouble t )
{
    WARNING_NOOP("GL Noop:glTexCoord2d\n");
}

void APIENTRY
glnoopTexCoord2dv ( IN const GLdouble v[2] )
{
    WARNING_NOOP("GL Noop:glTexCoord2dv\n");
}

void APIENTRY
glnoopTexCoord2f ( IN GLfloat s, IN GLfloat t )
{
    WARNING_NOOP("GL Noop:glTexCoord2f\n");
}

void APIENTRY
glnoopTexCoord2fv ( IN const GLfloat v[2] )
{
    WARNING_NOOP("GL Noop:glTexCoord2fv\n");
}

void APIENTRY
glnoopTexCoord2i ( IN GLint s, IN GLint t )
{
    WARNING_NOOP("GL Noop:glTexCoord2i\n");
}

void APIENTRY
glnoopTexCoord2iv ( IN const GLint v[2] )
{
    WARNING_NOOP("GL Noop:glTexCoord2iv\n");
}

void APIENTRY
glnoopTexCoord2s ( IN GLshort s, IN GLshort t )
{
    WARNING_NOOP("GL Noop:glTexCoord2s\n");
}

void APIENTRY
glnoopTexCoord2sv ( IN const GLshort v[2] )
{
    WARNING_NOOP("GL Noop:glTexCoord2sv\n");
}

void APIENTRY
glnoopTexCoord3d ( IN GLdouble s, IN GLdouble t, IN GLdouble r )
{
    WARNING_NOOP("GL Noop:glTexCoord3d\n");
}

void APIENTRY
glnoopTexCoord3dv ( IN const GLdouble v[3] )
{
    WARNING_NOOP("GL Noop:glTexCoord3dv\n");
}

void APIENTRY
glnoopTexCoord3f ( IN GLfloat s, IN GLfloat t, IN GLfloat r )
{
    WARNING_NOOP("GL Noop:glTexCoord3f\n");
}

void APIENTRY
glnoopTexCoord3fv ( IN const GLfloat v[3] )
{
    WARNING_NOOP("GL Noop:glTexCoord3fv\n");
}

void APIENTRY
glnoopTexCoord3i ( IN GLint s, IN GLint t, IN GLint r )
{
    WARNING_NOOP("GL Noop:glTexCoord3i\n");
}

void APIENTRY
glnoopTexCoord3iv ( IN const GLint v[3] )
{
    WARNING_NOOP("GL Noop:glTexCoord3iv\n");
}

void APIENTRY
glnoopTexCoord3s ( IN GLshort s, IN GLshort t, IN GLshort r )
{
    WARNING_NOOP("GL Noop:glTexCoord3s\n");
}

void APIENTRY
glnoopTexCoord3sv ( IN const GLshort v[3] )
{
    WARNING_NOOP("GL Noop:glTexCoord3sv\n");
}

void APIENTRY
glnoopTexCoord4d ( IN GLdouble s, IN GLdouble t, IN GLdouble r, IN GLdouble q )
{
    WARNING_NOOP("GL Noop:glTexCoord4d\n");
}

void APIENTRY
glnoopTexCoord4dv ( IN const GLdouble v[4] )
{
    WARNING_NOOP("GL Noop:glTexCoord4dv\n");
}

void APIENTRY
glnoopTexCoord4f ( IN GLfloat s, IN GLfloat t, IN GLfloat r, IN GLfloat q )
{
    WARNING_NOOP("GL Noop:glTexCoord4f\n");
}

void APIENTRY
glnoopTexCoord4fv ( IN const GLfloat v[4] )
{
    WARNING_NOOP("GL Noop:glTexCoord4fv\n");
}

void APIENTRY
glnoopTexCoord4i ( IN GLint s, IN GLint t, IN GLint r, IN GLint q )
{
    WARNING_NOOP("GL Noop:glTexCoord4i\n");
}

void APIENTRY
glnoopTexCoord4iv ( IN const GLint v[4] )
{
    WARNING_NOOP("GL Noop:glTexCoord4iv\n");
}

void APIENTRY
glnoopTexCoord4s ( IN GLshort s, IN GLshort t, IN GLshort r, IN GLshort q )
{
    WARNING_NOOP("GL Noop:glTexCoord4s\n");
}

void APIENTRY
glnoopTexCoord4sv ( IN const GLshort v[4] )
{
    WARNING_NOOP("GL Noop:glTexCoord4sv\n");
}

void APIENTRY
glnoopVertex2d ( IN GLdouble x, IN GLdouble y )
{
    WARNING_NOOP("GL Noop:glVertex2d\n");
}

void APIENTRY
glnoopVertex2dv ( IN const GLdouble v[2] )
{
    WARNING_NOOP("GL Noop:glVertex2dv\n");
}

void APIENTRY
glnoopVertex2f ( IN GLfloat x, IN GLfloat y )
{
    WARNING_NOOP("GL Noop:glVertex2f\n");
}

void APIENTRY
glnoopVertex2fv ( IN const GLfloat v[2] )
{
    WARNING_NOOP("GL Noop:glVertex2fv\n");
}

void APIENTRY
glnoopVertex2i ( IN GLint x, IN GLint y )
{
    WARNING_NOOP("GL Noop:glVertex2i\n");
}

void APIENTRY
glnoopVertex2iv ( IN const GLint v[2] )
{
    WARNING_NOOP("GL Noop:glVertex2iv\n");
}

void APIENTRY
glnoopVertex2s ( IN GLshort x, IN GLshort y )
{
    WARNING_NOOP("GL Noop:glVertex2s\n");
}

void APIENTRY
glnoopVertex2sv ( IN const GLshort v[2] )
{
    WARNING_NOOP("GL Noop:glVertex2sv\n");
}

void APIENTRY
glnoopVertex3d ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    WARNING_NOOP("GL Noop:glVertex3d\n");
}

void APIENTRY
glnoopVertex3dv ( IN const GLdouble v[3] )
{
    WARNING_NOOP("GL Noop:glVertex3dv\n");
}

void APIENTRY
glnoopVertex3f ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    WARNING_NOOP("GL Noop:glVertex3f\n");
}

void APIENTRY
glnoopVertex3fv ( IN const GLfloat v[3] )
{
    WARNING_NOOP("GL Noop:glVertex3fv\n");
}

void APIENTRY
glnoopVertex3i ( IN GLint x, IN GLint y, IN GLint z )
{
    WARNING_NOOP("GL Noop:glVertex3i\n");
}

void APIENTRY
glnoopVertex3iv ( IN const GLint v[3] )
{
    WARNING_NOOP("GL Noop:glVertex3iv\n");
}

void APIENTRY
glnoopVertex3s ( IN GLshort x, IN GLshort y, IN GLshort z )
{
    WARNING_NOOP("GL Noop:glVertex3s\n");
}

void APIENTRY
glnoopVertex3sv ( IN const GLshort v[3] )
{
    WARNING_NOOP("GL Noop:glVertex3sv\n");
}

void APIENTRY
glnoopVertex4d ( IN GLdouble x, IN GLdouble y, IN GLdouble z, IN GLdouble w )
{
    WARNING_NOOP("GL Noop:glVertex4d\n");
}

void APIENTRY
glnoopVertex4dv ( IN const GLdouble v[4] )
{
    WARNING_NOOP("GL Noop:glVertex4dv\n");
}

void APIENTRY
glnoopVertex4f ( IN GLfloat x, IN GLfloat y, IN GLfloat z, IN GLfloat w )
{
    WARNING_NOOP("GL Noop:glVertex4f\n");
}

void APIENTRY
glnoopVertex4fv ( IN const GLfloat v[4] )
{
    WARNING_NOOP("GL Noop:glVertex4fv\n");
}

void APIENTRY
glnoopVertex4i ( IN GLint x, IN GLint y, IN GLint z, IN GLint w )
{
    WARNING_NOOP("GL Noop:glVertex4i\n");
}

void APIENTRY
glnoopVertex4iv ( IN const GLint v[4] )
{
    WARNING_NOOP("GL Noop:glVertex4iv\n");
}

void APIENTRY
glnoopVertex4s ( IN GLshort x, IN GLshort y, IN GLshort z, IN GLshort w )
{
    WARNING_NOOP("GL Noop:glVertex4s\n");
}

void APIENTRY
glnoopVertex4sv ( IN const GLshort v[4] )
{
    WARNING_NOOP("GL Noop:glVertex4sv\n");
}

void APIENTRY
glnoopClipPlane ( IN GLenum plane, IN const GLdouble equation[4] )
{
    WARNING_NOOP("GL Noop:glClipPlane\n");
}

void APIENTRY
glnoopColorMaterial ( IN GLenum face, IN GLenum mode )
{
    WARNING_NOOP("GL Noop:glColorMaterial\n");
}

void APIENTRY
glnoopCullFace ( IN GLenum mode )
{
    WARNING_NOOP("GL Noop:glCullFace\n");
}

void APIENTRY
glnoopFogf ( IN GLenum pname, IN GLfloat param )
{
    WARNING_NOOP("GL Noop:glFogf\n");
}

void APIENTRY
glnoopFogfv ( IN GLenum pname, IN const GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glFogfv\n");
}

void APIENTRY
glnoopFogi ( IN GLenum pname, IN GLint param )
{
    WARNING_NOOP("GL Noop:glFogi\n");
}

void APIENTRY
glnoopFogiv ( IN GLenum pname, IN const GLint params[] )
{
    WARNING_NOOP("GL Noop:glFogiv\n");
}

void APIENTRY
glnoopFrontFace ( IN GLenum mode )
{
    WARNING_NOOP("GL Noop:glFrontFace\n");
}

void APIENTRY
glnoopHint ( IN GLenum target, IN GLenum mode )
{
    WARNING_NOOP("GL Noop:glHint\n");
}

void APIENTRY
glnoopLightf ( IN GLenum light, IN GLenum pname, IN GLfloat param )
{
    WARNING_NOOP("GL Noop:glLightf\n");
}

void APIENTRY
glnoopLightfv ( IN GLenum light, IN GLenum pname, IN const GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glLightfv\n");
}

void APIENTRY
glnoopLighti ( IN GLenum light, IN GLenum pname, IN GLint param )
{
    WARNING_NOOP("GL Noop:glLighti\n");
}

void APIENTRY
glnoopLightiv ( IN GLenum light, IN GLenum pname, IN const GLint params[] )
{
    WARNING_NOOP("GL Noop:glLightiv\n");
}

void APIENTRY
glnoopLightModelf ( IN GLenum pname, IN GLfloat param )
{
    WARNING_NOOP("GL Noop:glLightModelf\n");
}

void APIENTRY
glnoopLightModelfv ( IN GLenum pname, IN const GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glLightModelfv\n");
}

void APIENTRY
glnoopLightModeli ( IN GLenum pname, IN GLint param )
{
    WARNING_NOOP("GL Noop:glLightModeli\n");
}

void APIENTRY
glnoopLightModeliv ( IN GLenum pname, IN const GLint params[] )
{
    WARNING_NOOP("GL Noop:glLightModeliv\n");
}

void APIENTRY
glnoopLineStipple ( IN GLint factor, IN GLushort pattern )
{
    WARNING_NOOP("GL Noop:glLineStipple\n");
}

void APIENTRY
glnoopLineWidth ( IN GLfloat width )
{
    WARNING_NOOP("GL Noop:glLineWidth\n");
}

void APIENTRY
glnoopMaterialf ( IN GLenum face, IN GLenum pname, IN GLfloat param )
{
    WARNING_NOOP("GL Noop:glMaterialf\n");
}

void APIENTRY
glnoopMaterialfv ( IN GLenum face, IN GLenum pname, IN const GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glMaterialfv\n");
}

void APIENTRY
glnoopMateriali ( IN GLenum face, IN GLenum pname, IN GLint param )
{
    WARNING_NOOP("GL Noop:glMateriali\n");
}

void APIENTRY
glnoopMaterialiv ( IN GLenum face, IN GLenum pname, IN const GLint params[] )
{
    WARNING_NOOP("GL Noop:glMaterialiv\n");
}

void APIENTRY
glnoopPointSize ( IN GLfloat size )
{
    WARNING_NOOP("GL Noop:glPointSize\n");
}

void APIENTRY
glnoopPolygonMode ( IN GLenum face, IN GLenum mode )
{
    WARNING_NOOP("GL Noop:glPolygonMode\n");
}

void APIENTRY
glnoopPolygonStipple ( IN const GLubyte mask[128] )
{
    WARNING_NOOP("GL Noop:glPolygonStipple\n");
}

void APIENTRY
glnoopScissor ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height )
{
    WARNING_NOOP("GL Noop:glScissor\n");
}

void APIENTRY
glnoopShadeModel ( IN GLenum mode )
{
    WARNING_NOOP("GL Noop:glShadeModel\n");
}

void APIENTRY
glnoopTexParameterf ( IN GLenum target, IN GLenum pname, IN GLfloat param )
{
    WARNING_NOOP("GL Noop:glTexParameterf\n");
}

void APIENTRY
glnoopTexParameterfv ( IN GLenum target, IN GLenum pname, IN const GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glTexParameterfv\n");
}

void APIENTRY
glnoopTexParameteri ( IN GLenum target, IN GLenum pname, IN GLint param )
{
    WARNING_NOOP("GL Noop:glTexParameteri\n");
}

void APIENTRY
glnoopTexParameteriv ( IN GLenum target, IN GLenum pname, IN const GLint params[] )
{
    WARNING_NOOP("GL Noop:glTexParameteriv\n");
}

void APIENTRY
glnoopTexImage1D ( IN GLenum target, IN GLint level, IN GLint components, IN GLsizei width, IN GLint border, IN GLenum format, IN GLenum type, IN const GLvoid *pixels )
{
    WARNING_NOOP("GL Noop:glTexImage1D\n");
}

void APIENTRY
glnoopTexImage2D ( IN GLenum target, IN GLint level, IN GLint components, IN GLsizei width, IN GLsizei height, IN GLint border, IN GLenum format, IN GLenum type, IN const GLvoid *pixels )
{
    WARNING_NOOP("GL Noop:glTexImage2D\n");
}

void APIENTRY
glnoopTexEnvf ( IN GLenum target, IN GLenum pname, IN GLfloat param )
{
    WARNING_NOOP("GL Noop:glTexEnvf\n");
}

void APIENTRY
glnoopTexEnvfv ( IN GLenum target, IN GLenum pname, IN const GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glTexEnvfv\n");
}

void APIENTRY
glnoopTexEnvi ( IN GLenum target, IN GLenum pname, IN GLint param )
{
    WARNING_NOOP("GL Noop:glTexEnvi\n");
}

void APIENTRY
glnoopTexEnviv ( IN GLenum target, IN GLenum pname, IN const GLint params[] )
{
    WARNING_NOOP("GL Noop:glTexEnviv\n");
}

void APIENTRY
glnoopTexGend ( IN GLenum coord, IN GLenum pname, IN GLdouble param )
{
    WARNING_NOOP("GL Noop:glTexGend\n");
}

void APIENTRY
glnoopTexGendv ( IN GLenum coord, IN GLenum pname, IN const GLdouble params[] )
{
    WARNING_NOOP("GL Noop:glTexGendv\n");
}

void APIENTRY
glnoopTexGenf ( IN GLenum coord, IN GLenum pname, IN GLfloat param )
{
    WARNING_NOOP("GL Noop:glTexGenf\n");
}

void APIENTRY
glnoopTexGenfv ( IN GLenum coord, IN GLenum pname, IN const GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glTexGenfv\n");
}

void APIENTRY
glnoopTexGeni ( IN GLenum coord, IN GLenum pname, IN GLint param )
{
    WARNING_NOOP("GL Noop:glTexGeni\n");
}

void APIENTRY
glnoopTexGeniv ( IN GLenum coord, IN GLenum pname, IN const GLint params[] )
{
    WARNING_NOOP("GL Noop:glTexGeniv\n");
}

void APIENTRY
glnoopFeedbackBuffer ( IN GLsizei size, IN GLenum type, OUT GLfloat buffer[] )
{
    WARNING_NOOP("GL Noop:glFeedbackBuffer\n");
}

void APIENTRY
glnoopSelectBuffer ( IN GLsizei size, OUT GLuint buffer[] )
{
    WARNING_NOOP("GL Noop:glSelectBuffer\n");
}

GLint APIENTRY
glnoopRenderMode ( IN GLenum mode )
{
    WARNING_NOOP("GL Noop:glRenderMode\n");
    return((GLint) 0);
}

void APIENTRY
glnoopInitNames ( void )
{
    WARNING_NOOP("GL Noop:glInitNames\n");
}

void APIENTRY
glnoopLoadName ( IN GLuint name )
{
    WARNING_NOOP("GL Noop:glLoadName\n");
}

void APIENTRY
glnoopPassThrough ( IN GLfloat token )
{
    WARNING_NOOP("GL Noop:glPassThrough\n");
}

void APIENTRY
glnoopPopName ( void )
{
    WARNING_NOOP("GL Noop:glPopName\n");
}

void APIENTRY
glnoopPushName ( IN GLuint name )
{
    WARNING_NOOP("GL Noop:glPushName\n");
}

void APIENTRY
glnoopDrawBuffer ( IN GLenum mode )
{
    WARNING_NOOP("GL Noop:glDrawBuffer\n");
}

void APIENTRY
glnoopClear ( IN GLbitfield mask )
{
    WARNING_NOOP("GL Noop:glClear\n");
}

void APIENTRY
glnoopClearAccum ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha )
{
    WARNING_NOOP("GL Noop:glClearAccum\n");
}

void APIENTRY
glnoopClearIndex ( IN GLfloat c )
{
    WARNING_NOOP("GL Noop:glClearIndex\n");
}

void APIENTRY
glnoopClearColor ( IN GLclampf red, IN GLclampf green, IN GLclampf blue, IN GLclampf alpha )
{
    WARNING_NOOP("GL Noop:glClearColor\n");
}

void APIENTRY
glnoopClearStencil ( IN GLint s )
{
    WARNING_NOOP("GL Noop:glClearStencil\n");
}

void APIENTRY
glnoopClearDepth ( IN GLclampd depth )
{
    WARNING_NOOP("GL Noop:glClearDepth\n");
}

void APIENTRY
glnoopStencilMask ( IN GLuint mask )
{
    WARNING_NOOP("GL Noop:glStencilMask\n");
}

void APIENTRY
glnoopColorMask ( IN GLboolean red, IN GLboolean green, IN GLboolean blue, IN GLboolean alpha )
{
    WARNING_NOOP("GL Noop:glColorMask\n");
}

void APIENTRY
glnoopDepthMask ( IN GLboolean flag )
{
    WARNING_NOOP("GL Noop:glDepthMask\n");
}

void APIENTRY
glnoopIndexMask ( IN GLuint mask )
{
    WARNING_NOOP("GL Noop:glIndexMask\n");
}

void APIENTRY
glnoopAccum ( IN GLenum op, IN GLfloat value )
{
    WARNING_NOOP("GL Noop:glAccum\n");
}

void APIENTRY
glnoopDisable ( IN GLenum cap )
{
    WARNING_NOOP("GL Noop:glDisable\n");
}

void APIENTRY
glnoopEnable ( IN GLenum cap )
{
    WARNING_NOOP("GL Noop:glEnable\n");
}

void APIENTRY
glnoopFinish ( void )
{
    WARNING_NOOP("GL Noop:glFinish\n");
}

void APIENTRY
glnoopFlush ( void )
{
    WARNING_NOOP("GL Noop:glFlush\n");
}

void APIENTRY
glnoopPopAttrib ( void )
{
    WARNING_NOOP("GL Noop:glPopAttrib\n");
}

void APIENTRY
glnoopPushAttrib ( IN GLbitfield mask )
{
    WARNING_NOOP("GL Noop:glPushAttrib\n");
}

void APIENTRY
glnoopMap1d ( IN GLenum target, IN GLdouble u1, IN GLdouble u2, IN GLint stride, IN GLint order, IN const GLdouble points[] )
{
    WARNING_NOOP("GL Noop:glMap1d\n");
}

void APIENTRY
glnoopMap1f ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint stride, IN GLint order, IN const GLfloat points[] )
{
    WARNING_NOOP("GL Noop:glMap1f\n");
}

void APIENTRY
glnoopMap2d ( IN GLenum target, IN GLdouble u1, IN GLdouble u2, IN GLint ustride, IN GLint uorder, IN GLdouble v1, IN GLdouble v2, IN GLint vstride, IN GLint vorder, IN const GLdouble points[] )
{
    WARNING_NOOP("GL Noop:glMap2d\n");
}

void APIENTRY
glnoopMap2f ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint ustride, IN GLint uorder, IN GLfloat v1, IN GLfloat v2, IN GLint vstride, IN GLint vorder, IN const GLfloat points[] )
{
    WARNING_NOOP("GL Noop:glMap2f\n");
}

void APIENTRY
glnoopMapGrid1d ( IN GLint un, IN GLdouble u1, IN GLdouble u2 )
{
    WARNING_NOOP("GL Noop:glMapGrid1d\n");
}

void APIENTRY
glnoopMapGrid1f ( IN GLint un, IN GLfloat u1, IN GLfloat u2 )
{
    WARNING_NOOP("GL Noop:glMapGrid1f\n");
}

void APIENTRY
glnoopMapGrid2d ( IN GLint un, IN GLdouble u1, IN GLdouble u2, IN GLint vn, IN GLdouble v1, IN GLdouble v2 )
{
    WARNING_NOOP("GL Noop:glMapGrid2d\n");
}

void APIENTRY
glnoopMapGrid2f ( IN GLint un, IN GLfloat u1, IN GLfloat u2, IN GLint vn, IN GLfloat v1, IN GLfloat v2 )
{
    WARNING_NOOP("GL Noop:glMapGrid2f\n");
}

void APIENTRY
glnoopEvalCoord1d ( IN GLdouble u )
{
    WARNING_NOOP("GL Noop:glEvalCoord1d\n");
}

void APIENTRY
glnoopEvalCoord1dv ( IN const GLdouble u[1] )
{
    WARNING_NOOP("GL Noop:glEvalCoord1dv\n");
}

void APIENTRY
glnoopEvalCoord1f ( IN GLfloat u )
{
    WARNING_NOOP("GL Noop:glEvalCoord1f\n");
}

void APIENTRY
glnoopEvalCoord1fv ( IN const GLfloat u[1] )
{
    WARNING_NOOP("GL Noop:glEvalCoord1fv\n");
}

void APIENTRY
glnoopEvalCoord2d ( IN GLdouble u, IN GLdouble v )
{
    WARNING_NOOP("GL Noop:glEvalCoord2d\n");
}

void APIENTRY
glnoopEvalCoord2dv ( IN const GLdouble u[2] )
{
    WARNING_NOOP("GL Noop:glEvalCoord2dv\n");
}

void APIENTRY
glnoopEvalCoord2f ( IN GLfloat u, IN GLfloat v )
{
    WARNING_NOOP("GL Noop:glEvalCoord2f\n");
}

void APIENTRY
glnoopEvalCoord2fv ( IN const GLfloat u[2] )
{
    WARNING_NOOP("GL Noop:glEvalCoord2fv\n");
}

void APIENTRY
glnoopEvalMesh1 ( IN GLenum mode, IN GLint i1, IN GLint i2 )
{
    WARNING_NOOP("GL Noop:glEvalMesh1\n");
}

void APIENTRY
glnoopEvalPoint1 ( IN GLint i )
{
    WARNING_NOOP("GL Noop:glEvalPoint1\n");
}

void APIENTRY
glnoopEvalMesh2 ( IN GLenum mode, IN GLint i1, IN GLint i2, IN GLint j1, IN GLint j2 )
{
    WARNING_NOOP("GL Noop:glEvalMesh2\n");
}

void APIENTRY
glnoopEvalPoint2 ( IN GLint i, IN GLint j )
{
    WARNING_NOOP("GL Noop:glEvalPoint2\n");
}

void APIENTRY
glnoopAlphaFunc ( IN GLenum func, IN GLclampf ref )
{
    WARNING_NOOP("GL Noop:glAlphaFunc\n");
}

void APIENTRY
glnoopBlendFunc ( IN GLenum sfactor, IN GLenum dfactor )
{
    WARNING_NOOP("GL Noop:glBlendFunc\n");
}

void APIENTRY
glnoopLogicOp ( IN GLenum opcode )
{
    WARNING_NOOP("GL Noop:glLogicOp\n");
}

void APIENTRY
glnoopStencilFunc ( IN GLenum func, IN GLint ref, IN GLuint mask )
{
    WARNING_NOOP("GL Noop:glStencilFunc\n");
}

void APIENTRY
glnoopStencilOp ( IN GLenum fail, IN GLenum zfail, IN GLenum zpass )
{
    WARNING_NOOP("GL Noop:glStencilOp\n");
}

void APIENTRY
glnoopDepthFunc ( IN GLenum func )
{
    WARNING_NOOP("GL Noop:glDepthFunc\n");
}

void APIENTRY
glnoopPixelZoom ( IN GLfloat xfactor, IN GLfloat yfactor )
{
    WARNING_NOOP("GL Noop:glPixelZoom\n");
}

void APIENTRY
glnoopPixelTransferf ( IN GLenum pname, IN GLfloat param )
{
    WARNING_NOOP("GL Noop:glPixelTransferf\n");
}

void APIENTRY
glnoopPixelTransferi ( IN GLenum pname, IN GLint param )
{
    WARNING_NOOP("GL Noop:glPixelTransferi\n");
}

void APIENTRY
glnoopPixelStoref ( IN GLenum pname, IN GLfloat param )
{
    WARNING_NOOP("GL Noop:glPixelStoref\n");
}

void APIENTRY
glnoopPixelStorei ( IN GLenum pname, IN GLint param )
{
    WARNING_NOOP("GL Noop:glPixelStorei\n");
}

void APIENTRY
glnoopPixelMapfv ( IN GLenum map, IN GLint mapsize, IN const GLfloat values[] )
{
    WARNING_NOOP("GL Noop:glPixelMapfv\n");
}

void APIENTRY
glnoopPixelMapuiv ( IN GLenum map, IN GLint mapsize, IN const GLuint values[] )
{
    WARNING_NOOP("GL Noop:glPixelMapuiv\n");
}

void APIENTRY
glnoopPixelMapusv ( IN GLenum map, IN GLint mapsize, IN const GLushort values[] )
{
    WARNING_NOOP("GL Noop:glPixelMapusv\n");
}

void APIENTRY
glnoopReadBuffer ( IN GLenum mode )
{
    WARNING_NOOP("GL Noop:glReadBuffer\n");
}

void APIENTRY
glnoopCopyPixels ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height, IN GLenum type )
{
    WARNING_NOOP("GL Noop:glCopyPixels\n");
}

void APIENTRY
glnoopReadPixels ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height, IN GLenum format, IN GLenum type, OUT GLvoid *pixels )
{
    WARNING_NOOP("GL Noop:glReadPixels\n");
}

void APIENTRY
glnoopDrawPixels ( IN GLsizei width, IN GLsizei height, IN GLenum format, IN GLenum type, IN const GLvoid *pixels )
{
    WARNING_NOOP("GL Noop:glDrawPixels\n");
}

void APIENTRY
glnoopGetBooleanv ( IN GLenum pname, OUT GLboolean params[] )
{
    WARNING_NOOP("GL Noop:glGetBooleanv\n");
}

void APIENTRY
glnoopGetClipPlane ( IN GLenum plane, OUT GLdouble equation[4] )
{
    WARNING_NOOP("GL Noop:glGetClipPlane\n");
}

void APIENTRY
glnoopGetDoublev ( IN GLenum pname, OUT GLdouble params[] )
{
    WARNING_NOOP("GL Noop:glGetDoublev\n");
}

GLenum APIENTRY
glnoopGetError ( void )
{
    WARNING_NOOP("GL Noop:glGetError\n");
    return(GL_INVALID_OPERATION);
}

void APIENTRY
glnoopGetFloatv ( IN GLenum pname, OUT GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glGetFloatv\n");
}

void APIENTRY
glnoopGetIntegerv ( IN GLenum pname, OUT GLint params[] )
{
    WARNING_NOOP("GL Noop:glGetIntegerv\n");
}

void APIENTRY
glnoopGetLightfv ( IN GLenum light, IN GLenum pname, OUT GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glGetLightfv\n");
}

void APIENTRY
glnoopGetLightiv ( IN GLenum light, IN GLenum pname, OUT GLint params[] )
{
    WARNING_NOOP("GL Noop:glGetLightiv\n");
}

void APIENTRY
glnoopGetMapdv ( IN GLenum target, IN GLenum query, OUT GLdouble v[] )
{
    WARNING_NOOP("GL Noop:glGetMapdv\n");
}

void APIENTRY
glnoopGetMapfv ( IN GLenum target, IN GLenum query, OUT GLfloat v[] )
{
    WARNING_NOOP("GL Noop:glGetMapfv\n");
}

void APIENTRY
glnoopGetMapiv ( IN GLenum target, IN GLenum query, OUT GLint v[] )
{
    WARNING_NOOP("GL Noop:glGetMapiv\n");
}

void APIENTRY
glnoopGetMaterialfv ( IN GLenum face, IN GLenum pname, OUT GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glGetMaterialfv\n");
}

void APIENTRY
glnoopGetMaterialiv ( IN GLenum face, IN GLenum pname, OUT GLint params[] )
{
    WARNING_NOOP("GL Noop:glGetMaterialiv\n");
}

void APIENTRY
glnoopGetPixelMapfv ( IN GLenum map, OUT GLfloat values[] )
{
    WARNING_NOOP("GL Noop:glGetPixelMapfv\n");
}

void APIENTRY
glnoopGetPixelMapuiv ( IN GLenum map, OUT GLuint values[] )
{
    WARNING_NOOP("GL Noop:glGetPixelMapuiv\n");
}

void APIENTRY
glnoopGetPixelMapusv ( IN GLenum map, OUT GLushort values[] )
{
    WARNING_NOOP("GL Noop:glGetPixelMapusv\n");
}

void APIENTRY
glnoopGetPolygonStipple ( OUT GLubyte mask[128] )
{
    WARNING_NOOP("GL Noop:glGetPolygonStipple\n");
}

const GLubyte * APIENTRY
glnoopGetString ( IN GLenum name )
{
    WARNING_NOOP("GL Noop:glGetString\n");
    return((const GLubyte *) NULL);
}

void APIENTRY
glnoopGetTexEnvfv ( IN GLenum target, IN GLenum pname, OUT GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glGetTexEnvfv\n");
}

void APIENTRY
glnoopGetTexEnviv ( IN GLenum target, IN GLenum pname, OUT GLint params[] )
{
    WARNING_NOOP("GL Noop:glGetTexEnviv\n");
}

void APIENTRY
glnoopGetTexGendv ( IN GLenum coord, IN GLenum pname, OUT GLdouble params[] )
{
    WARNING_NOOP("GL Noop:glGetTexGendv\n");
}

void APIENTRY
glnoopGetTexGenfv ( IN GLenum coord, IN GLenum pname, OUT GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glGetTexGenfv\n");
}

void APIENTRY
glnoopGetTexGeniv ( IN GLenum coord, IN GLenum pname, OUT GLint params[] )
{
    WARNING_NOOP("GL Noop:glGetTexGeniv\n");
}

void APIENTRY
glnoopGetTexImage ( IN GLenum target, IN GLint level, IN GLenum format, IN GLenum type, OUT GLvoid *pixels )
{
    WARNING_NOOP("GL Noop:glGetTexImage\n");
}

void APIENTRY
glnoopGetTexParameterfv ( IN GLenum target, IN GLenum pname, OUT GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glGetTexParameterfv\n");
}

void APIENTRY
glnoopGetTexParameteriv ( IN GLenum target, IN GLenum pname, OUT GLint params[] )
{
    WARNING_NOOP("GL Noop:glGetTexParameteriv\n");
}

void APIENTRY
glnoopGetTexLevelParameterfv ( IN GLenum target, IN GLint level, IN GLenum pname, OUT GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glGetTexLevelParameterfv\n");
}

void APIENTRY
glnoopGetTexLevelParameteriv ( IN GLenum target, IN GLint level, IN GLenum pname, OUT GLint params[] )
{
    WARNING_NOOP("GL Noop:glGetTexLevelParameteriv\n");
}

GLboolean APIENTRY
glnoopIsEnabled ( IN GLenum cap )
{
    WARNING_NOOP("GL Noop:glIsEnabled\n");
    return((GLboolean) FALSE);
}

GLboolean APIENTRY
glnoopIsList ( IN GLuint list )
{
    WARNING_NOOP("GL Noop:glIsList\n");
    return((GLboolean) FALSE);
}

void APIENTRY
glnoopDepthRange ( IN GLclampd zNear, IN GLclampd zFar )
{
    WARNING_NOOP("GL Noop:glDepthRange\n");
}

void APIENTRY
glnoopFrustum ( IN GLdouble left, IN GLdouble right, IN GLdouble bottom, IN GLdouble top, IN GLdouble zNear, IN GLdouble zFar )
{
    WARNING_NOOP("GL Noop:glFrustum\n");
}

void APIENTRY
glnoopLoadIdentity ( void )
{
    WARNING_NOOP("GL Noop:glLoadIdentity\n");
}

void APIENTRY
glnoopLoadMatrixf ( IN const GLfloat m[16] )
{
    WARNING_NOOP("GL Noop:glLoadMatrixf\n");
}

void APIENTRY
glnoopLoadMatrixd ( IN const GLdouble m[16] )
{
    WARNING_NOOP("GL Noop:glLoadMatrixd\n");
}

void APIENTRY
glnoopMatrixMode ( IN GLenum mode )
{
    WARNING_NOOP("GL Noop:glMatrixMode\n");
}

void APIENTRY
glnoopMultMatrixf ( IN const GLfloat m[16] )
{
    WARNING_NOOP("GL Noop:glMultMatrixf\n");
}

void APIENTRY
glnoopMultMatrixd ( IN const GLdouble m[16] )
{
    WARNING_NOOP("GL Noop:glMultMatrixd\n");
}

void APIENTRY
glnoopOrtho ( IN GLdouble left, IN GLdouble right, IN GLdouble bottom, IN GLdouble top, IN GLdouble zNear, IN GLdouble zFar )
{
    WARNING_NOOP("GL Noop:glOrtho\n");
}

void APIENTRY
glnoopPopMatrix ( void )
{
    WARNING_NOOP("GL Noop:glPopMatrix\n");
}

void APIENTRY
glnoopPushMatrix ( void )
{
    WARNING_NOOP("GL Noop:glPushMatrix\n");
}

void APIENTRY
glnoopRotated ( IN GLdouble angle, IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    WARNING_NOOP("GL Noop:glRotated\n");
}

void APIENTRY
glnoopRotatef ( IN GLfloat angle, IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    WARNING_NOOP("GL Noop:glRotatef\n");
}

void APIENTRY
glnoopScaled ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    WARNING_NOOP("GL Noop:glScaled\n");
}

void APIENTRY
glnoopScalef ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    WARNING_NOOP("GL Noop:glScalef\n");
}

void APIENTRY
glnoopTranslated ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    WARNING_NOOP("GL Noop:glTranslated\n");
}

void APIENTRY
glnoopTranslatef ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    WARNING_NOOP("GL Noop:glTranslatef\n");
}

void APIENTRY
glnoopViewport ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height )
{
    WARNING_NOOP("GL Noop:glViewport\n");
}

GLboolean APIENTRY
glnoopAreTexturesResident(GLsizei n, const GLuint *textures,
                                            GLboolean *residences)
{
    WARNING_NOOP("GL Noop:glAreTexturesResident\n");
    return GL_FALSE;
}

void APIENTRY
glnoopBindTexture(GLenum target, GLuint texture)
{
    WARNING_NOOP("GL Noop:glBindTexture\n");
}

void APIENTRY
glnoopCopyTexImage1D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLint border)
{
    WARNING_NOOP("GL Noop:glCopyTexImage1D\n");
}

void APIENTRY
glnoopCopyTexImage2D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLsizei height, GLint border)
{
    WARNING_NOOP("GL Noop:glCopyTexImage2D\n");
}

void APIENTRY
glnoopCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                     GLint x, GLint y, GLsizei width)
{
    WARNING_NOOP("GL Noop:glCopyTexSubImage1D\n");
}

void APIENTRY
glnoopCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                     GLint yoffset, GLint x, GLint y,
                                     GLsizei width, GLsizei height)
{
    WARNING_NOOP("GL Noop:glCopyTexSubImage2D\n");
}

void APIENTRY
glnoopDeleteTextures(GLsizei n, const GLuint *textures)
{
    WARNING_NOOP("GL Noop:glDeleteTextures\n");
}

void APIENTRY
glnoopGenTextures(GLsizei n, GLuint *textures)
{
    WARNING_NOOP("GL Noop:glGenTextures\n");
}

GLboolean APIENTRY
glnoopIsTexture(GLuint texture)
{
    WARNING_NOOP("GL Noop:glIsTexture\n");
    return GL_FALSE;
}

void APIENTRY
glnoopPrioritizeTextures(GLsizei n, const GLuint *textures,
                                      const GLclampf *priorities)
{
    WARNING_NOOP("GL Noop:glPrioritizeTextures\n");
}

void APIENTRY
glnoopTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                 GLsizei width, GLenum format, GLenum type,
                                 const GLvoid *pixels)
{
    WARNING_NOOP("GL Noop:glTexSubImage1D\n");
}

void APIENTRY
glnoopTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                 GLint yoffset, GLsizei width, GLsizei height,
                                 GLenum format, GLenum type,
                                 const GLvoid *pixels)
{
    WARNING_NOOP("GL Noop:glTexSubImage2D\n");
}

void APIENTRY
glnoopArrayElement(GLint i)
{
    WARNING_NOOP("GL Noop:glArrayElement\n");
}

void APIENTRY
glnoopColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    WARNING_NOOP("GL Noop:glColorPointer\n");
}

void APIENTRY
glnoopDisableClientState(GLenum array)
{
    WARNING_NOOP("GL Noop:glDisableClientState\n");
}

void APIENTRY
glnoopDrawArrays(GLenum mode, GLint first, GLsizei count)
{
    WARNING_NOOP("GL Noop:glDrawArrays\n");
}

void APIENTRY
glnoopDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
{
    WARNING_NOOP("GL Noop:glDrawElements\n");
}

void APIENTRY
glnoopEdgeFlagPointer(GLsizei stride, const GLvoid *pointer)
{
    WARNING_NOOP("GL Noop:glEdgeFlagPointer\n");
}

void APIENTRY
glnoopEnableClientState(GLenum array)
{
    WARNING_NOOP("GL Noop:glEnableClientState\n");
}

void APIENTRY
glnoopIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
    WARNING_NOOP("GL Noop:glIndexPointer\n");
}

void APIENTRY
glnoopIndexub(GLubyte c)
{
    WARNING_NOOP("GL Noop:glIndexub\n");
}

void APIENTRY
glnoopIndexubv(const GLubyte *c)
{
    WARNING_NOOP("GL Noop:glIndexubv\n");
}

void APIENTRY
glnoopInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
{
    WARNING_NOOP("GL Noop:glInterleavedArrays\n");
}

void APIENTRY
glnoopNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
    WARNING_NOOP("GL Noop:glNormalPointer\n");
}

void APIENTRY
glnoopPolygonOffset(GLfloat factor, GLfloat units)
{
    WARNING_NOOP("GL Noop:glPolygonOffset\n");
}

void APIENTRY
glnoopTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    WARNING_NOOP("GL Noop:glTexCoordPointer\n");
}

void APIENTRY
glnoopVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    WARNING_NOOP("GL Noop:glVertexPointer\n");
}

void APIENTRY
glnoopGetPointerv(GLenum pname, GLvoid* *params)
{
    WARNING_NOOP("GL Noop:glGetPointerv\n");
}

void APIENTRY
glnoopPopClientAttrib(void)
{
    WARNING_NOOP("GL Noop:glPopClientAttrib\n");
}

void APIENTRY
glnoopPushClientAttrib(IN GLbitfield mask)
{
    WARNING_NOOP("GL Noop:glPushClientAttrib\n");
}


/* Client Side Procedure Table */

GLCLTPROCTABLE glNullCltProcTable = {

/* Number of function entries in the table */

     sizeof(GLDISPATCHTABLE) / sizeof(PROC),

/* gl Entry points */
  {
     glnoopNewList                ,
     glnoopEndList                ,
     glnoopCallList               ,
     glnoopCallLists              ,
     glnoopDeleteLists            ,
     glnoopGenLists               ,
     glnoopListBase               ,
     glnoopBegin                  ,
     glnoopBitmap                 ,
     glnoopColor3b                ,
     glnoopColor3bv               ,
     glnoopColor3d                ,
     glnoopColor3dv               ,
     glnoopColor3f                ,
     glnoopColor3fv               ,
     glnoopColor3i                ,
     glnoopColor3iv               ,
     glnoopColor3s                ,
     glnoopColor3sv               ,
     glnoopColor3ub               ,
     glnoopColor3ubv              ,
     glnoopColor3ui               ,
     glnoopColor3uiv              ,
     glnoopColor3us               ,
     glnoopColor3usv              ,
     glnoopColor4b                ,
     glnoopColor4bv               ,
     glnoopColor4d                ,
     glnoopColor4dv               ,
     glnoopColor4f                ,
     glnoopColor4fv               ,
     glnoopColor4i                ,
     glnoopColor4iv               ,
     glnoopColor4s                ,
     glnoopColor4sv               ,
     glnoopColor4ub               ,
     glnoopColor4ubv              ,
     glnoopColor4ui               ,
     glnoopColor4uiv              ,
     glnoopColor4us               ,
     glnoopColor4usv              ,
     glnoopEdgeFlag               ,
     glnoopEdgeFlagv              ,
     glnoopEnd                    ,
     glnoopIndexd                 ,
     glnoopIndexdv                ,
     glnoopIndexf                 ,
     glnoopIndexfv                ,
     glnoopIndexi                 ,
     glnoopIndexiv                ,
     glnoopIndexs                 ,
     glnoopIndexsv                ,
     glnoopNormal3b               ,
     glnoopNormal3bv              ,
     glnoopNormal3d               ,
     glnoopNormal3dv              ,
     glnoopNormal3f               ,
     glnoopNormal3fv              ,
     glnoopNormal3i               ,
     glnoopNormal3iv              ,
     glnoopNormal3s               ,
     glnoopNormal3sv              ,
     glnoopRasterPos2d            ,
     glnoopRasterPos2dv           ,
     glnoopRasterPos2f            ,
     glnoopRasterPos2fv           ,
     glnoopRasterPos2i            ,
     glnoopRasterPos2iv           ,
     glnoopRasterPos2s            ,
     glnoopRasterPos2sv           ,
     glnoopRasterPos3d            ,
     glnoopRasterPos3dv           ,
     glnoopRasterPos3f            ,
     glnoopRasterPos3fv           ,
     glnoopRasterPos3i            ,
     glnoopRasterPos3iv           ,
     glnoopRasterPos3s            ,
     glnoopRasterPos3sv           ,
     glnoopRasterPos4d            ,
     glnoopRasterPos4dv           ,
     glnoopRasterPos4f            ,
     glnoopRasterPos4fv           ,
     glnoopRasterPos4i            ,
     glnoopRasterPos4iv           ,
     glnoopRasterPos4s            ,
     glnoopRasterPos4sv           ,
     glnoopRectd                  ,
     glnoopRectdv                 ,
     glnoopRectf                  ,
     glnoopRectfv                 ,
     glnoopRecti                  ,
     glnoopRectiv                 ,
     glnoopRects                  ,
     glnoopRectsv                 ,
     glnoopTexCoord1d             ,
     glnoopTexCoord1dv            ,
     glnoopTexCoord1f             ,
     glnoopTexCoord1fv            ,
     glnoopTexCoord1i             ,
     glnoopTexCoord1iv            ,
     glnoopTexCoord1s             ,
     glnoopTexCoord1sv            ,
     glnoopTexCoord2d             ,
     glnoopTexCoord2dv            ,
     glnoopTexCoord2f             ,
     glnoopTexCoord2fv            ,
     glnoopTexCoord2i             ,
     glnoopTexCoord2iv            ,
     glnoopTexCoord2s             ,
     glnoopTexCoord2sv            ,
     glnoopTexCoord3d             ,
     glnoopTexCoord3dv            ,
     glnoopTexCoord3f             ,
     glnoopTexCoord3fv            ,
     glnoopTexCoord3i             ,
     glnoopTexCoord3iv            ,
     glnoopTexCoord3s             ,
     glnoopTexCoord3sv            ,
     glnoopTexCoord4d             ,
     glnoopTexCoord4dv            ,
     glnoopTexCoord4f             ,
     glnoopTexCoord4fv            ,
     glnoopTexCoord4i             ,
     glnoopTexCoord4iv            ,
     glnoopTexCoord4s             ,
     glnoopTexCoord4sv            ,
     glnoopVertex2d               ,
     glnoopVertex2dv              ,
     glnoopVertex2f               ,
     glnoopVertex2fv              ,
     glnoopVertex2i               ,
     glnoopVertex2iv              ,
     glnoopVertex2s               ,
     glnoopVertex2sv              ,
     glnoopVertex3d               ,
     glnoopVertex3dv              ,
     glnoopVertex3f               ,
     glnoopVertex3fv              ,
     glnoopVertex3i               ,
     glnoopVertex3iv              ,
     glnoopVertex3s               ,
     glnoopVertex3sv              ,
     glnoopVertex4d               ,
     glnoopVertex4dv              ,
     glnoopVertex4f               ,
     glnoopVertex4fv              ,
     glnoopVertex4i               ,
     glnoopVertex4iv              ,
     glnoopVertex4s               ,
     glnoopVertex4sv              ,
     glnoopClipPlane              ,
     glnoopColorMaterial          ,
     glnoopCullFace               ,
     glnoopFogf                   ,
     glnoopFogfv                  ,
     glnoopFogi                   ,
     glnoopFogiv                  ,
     glnoopFrontFace              ,
     glnoopHint                   ,
     glnoopLightf                 ,
     glnoopLightfv                ,
     glnoopLighti                 ,
     glnoopLightiv                ,
     glnoopLightModelf            ,
     glnoopLightModelfv           ,
     glnoopLightModeli            ,
     glnoopLightModeliv           ,
     glnoopLineStipple            ,
     glnoopLineWidth              ,
     glnoopMaterialf              ,
     glnoopMaterialfv             ,
     glnoopMateriali              ,
     glnoopMaterialiv             ,
     glnoopPointSize              ,
     glnoopPolygonMode            ,
     glnoopPolygonStipple         ,
     glnoopScissor                ,
     glnoopShadeModel             ,
     glnoopTexParameterf          ,
     glnoopTexParameterfv         ,
     glnoopTexParameteri          ,
     glnoopTexParameteriv         ,
     glnoopTexImage1D             ,
     glnoopTexImage2D             ,
     glnoopTexEnvf                ,
     glnoopTexEnvfv               ,
     glnoopTexEnvi                ,
     glnoopTexEnviv               ,
     glnoopTexGend                ,
     glnoopTexGendv               ,
     glnoopTexGenf                ,
     glnoopTexGenfv               ,
     glnoopTexGeni                ,
     glnoopTexGeniv               ,
     glnoopFeedbackBuffer         ,
     glnoopSelectBuffer           ,
     glnoopRenderMode             ,
     glnoopInitNames              ,
     glnoopLoadName               ,
     glnoopPassThrough            ,
     glnoopPopName                ,
     glnoopPushName               ,
     glnoopDrawBuffer             ,
     glnoopClear                  ,
     glnoopClearAccum             ,
     glnoopClearIndex             ,
     glnoopClearColor             ,
     glnoopClearStencil           ,
     glnoopClearDepth             ,
     glnoopStencilMask            ,
     glnoopColorMask              ,
     glnoopDepthMask              ,
     glnoopIndexMask              ,
     glnoopAccum                  ,
     glnoopDisable                ,
     glnoopEnable                 ,
     glnoopFinish                 ,
     glnoopFlush                  ,
     glnoopPopAttrib              ,
     glnoopPushAttrib             ,
     glnoopMap1d                  ,
     glnoopMap1f                  ,
     glnoopMap2d                  ,
     glnoopMap2f                  ,
     glnoopMapGrid1d              ,
     glnoopMapGrid1f              ,
     glnoopMapGrid2d              ,
     glnoopMapGrid2f              ,
     glnoopEvalCoord1d            ,
     glnoopEvalCoord1dv           ,
     glnoopEvalCoord1f            ,
     glnoopEvalCoord1fv           ,
     glnoopEvalCoord2d            ,
     glnoopEvalCoord2dv           ,
     glnoopEvalCoord2f            ,
     glnoopEvalCoord2fv           ,
     glnoopEvalMesh1              ,
     glnoopEvalPoint1             ,
     glnoopEvalMesh2              ,
     glnoopEvalPoint2             ,
     glnoopAlphaFunc              ,
     glnoopBlendFunc              ,
     glnoopLogicOp                ,
     glnoopStencilFunc            ,
     glnoopStencilOp              ,
     glnoopDepthFunc              ,
     glnoopPixelZoom              ,
     glnoopPixelTransferf         ,
     glnoopPixelTransferi         ,
     glnoopPixelStoref            ,
     glnoopPixelStorei            ,
     glnoopPixelMapfv             ,
     glnoopPixelMapuiv            ,
     glnoopPixelMapusv            ,
     glnoopReadBuffer             ,
     glnoopCopyPixels             ,
     glnoopReadPixels             ,
     glnoopDrawPixels             ,
     glnoopGetBooleanv            ,
     glnoopGetClipPlane           ,
     glnoopGetDoublev             ,
     glnoopGetError               ,