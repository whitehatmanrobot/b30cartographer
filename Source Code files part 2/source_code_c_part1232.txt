
       endx *= 2;
       dstxe = endx & ~mtile;
    }

    CALL_DIR_DRV_STR_MBLTY(&bltr); // load the invariant sections of the engine

    // step to the next tile
    xext = 0;
    while ((dstx & mtile) && (dstx < endx))
    {
      dstx += 2;
      xext += 2;
      accx += axis[0].min;
      if (accx < 0)
      {
        accx += axis[0].maj;
        srcx += 2;
        src_ext += 2;
      }
    }  // endwhile ((dstx & mtile) && (dstx < endx))

    // do the odd pixels we stepped over
    if (xext)
    {
       bltr.BLTEXT.PT.X    = (USHORT)xext;
       CALL_DIR_DRV_STR_MBLTX(&bltr);
    }

    // do all the whole tiles but the last
    bltr.SRCX  -= (USHORT)src_ext;

    while (dstx < dstxe)
    {
      bltr.OP0_opRDRAM.PT.X = (USHORT)dstx;
      bltr.OP1_opRDRAM.PT.X = (USHORT)srcx;
      bltr.ACCUM_X = accx;
      xext = 0;
      src_ext = 0;

      do
      {
        dstx += 2;
        xext += 2;
        accx += axis[0].min;
        if (accx < 0)
        {
          accx += axis[0].maj;
          srcx += 2;
          src_ext += 2;
        }
      } while (dstx & mtile);

      bltr.BLTEXT.PT.X = (USHORT)xext;

      CALL_DIR_DRV_STR_MBLTX(&bltr);

      bltr.SRCX -= (USHORT)src_ext;
    }  // endwhile (dstx < dstxe)

    // do the last tile
    if (dstx < endx)
    {
       bltr.OP0_opRDRAM.PT.X = (USHORT)dstx;
       bltr.OP1_opRDRAM.PT.X = (USHORT)srcx;
       bltr.ACCUM_X  = accx;

       bltr.BLTEXT.PT.X = endx - dstx;

       CALL_DIR_DRV_STR_MBLTX(&bltr);
    }

    if ( (SrcType == LN_YUV422) || (SrcType == LN_RGB565 && nBytesPixel == 1) )
    {
       // This is to ensure that the last packet of stretch blt does no go out
       // with 9th bit clear. It is cheaper than waiting, especially on single
       // stripe BLTs

       CALL_DIR_DELAY_9BIT_BLT(TRUE);
    }
  }
#else
  {
    // HWBUG !!! -- Break into Double aligned vertical stripes
    // based on src and dest alignment
    // dword and tile masks

    const int mdwrd =   4 ;
    const int tile = 128 ; /* sram is 128 bytes */
    const int mtile = 128 - 1 ; /* sram is 128 bytes */

    int endx  = xDst + cxClip;  // last x, exclusive
    int dstxe = endx & ~mtile;  // start of last tile

    DDAX accx = axis[0].accum;
    int  dstx = xDst;
    int  srcx = xSrc;
    int  src_ext = 0;
    int  xext;

#ifndef WINNT_VER40
    ASSERT( BITSPERPIXEL != 24 ); // HWBUG !!!
#endif

    if ( nBytesPixel == 2 )
    {
      cxSrc *= 2;   /* convert size to Bytes from pixels */
      cxDst *= 2;
      srcx = (xSrc *= 2);
      dstx = (xDst *= 2);
      bltr.OP0_opRDRAM.pt.X *= 2;
      bltr.OP1_opRDRAM.pt.X *= 2;
      endx *= 2;
      dstxe = endx & ~mtile;
    }

    // step to the next tile
    xext = 0;
    while ((dstx & mtile) && (dstx < endx))
    {
      dstx += 2;
      xext += 2;
      accx += axis[0].min;
      if (accx < 0)
      {
        accx += axis[0].maj;
        srcx += 2;
        src_ext += 2;
      }
    }

    // do the odd pixels we stepped over

    if (xext)
    {
      bltr.BLTEXT.PT.X    = xext;
      CALL_DIR_DRV_STR_MBLT(&bltr);
    }

    // do all the whole tiles but the last

    bltr.SRCX         -= src_ext;

    while (dstx < dstxe)
    {
      bltr.OP0_opRDRAM.PT.X = dstx;
      bltr.OP1_opRDRAM.PT.X = srcx;
      bltr.ACCUM_X      = accx;
      xext = 0;
      src_ext = 0;
      do
      {
        dstx += 2;
        xext += 2;
        accx += axis[0].min;
        if (accx < 0)
        {
          accx += axis[0].maj;
          srcx += 2;
          src_ext += 2;
        }
      } while (dstx & mtile);

      bltr.BLTEXT.PT.X    = xext;

      CALL_DIR_DRV_STR_MBLT(&bltr);
    }

    // do the last tile
    if (dstx < endx)
    {
      bltr.OP0_opRDRAM.PT.X = dstx;
      bltr.OP1_opRDRAM.PT.X = srcx;
      bltr.ACCUM_X      = accx;

      bltr.BLTEXT.PT.X    = endx - dstx;

      CALL_DIR_DRV_STR_MBLT(&bltr);
    }
    if ( (SrcType == LN_YUV422) || (SrcType == LN_RGB565 && nBytesPixel == 1) )
    {
      /* This is to ensure that the last packet of stretch blt does no go out with 9th bit clear */
      /* It is cheaper than waiting, especially on single stripe BLTs */

      CALL_DIR_DELAY_9BIT_BLT(TRUE);
    }
  }
#endif
  else
  {
    // HWBUG !!! -- Break into sram-aligned vertical tiles
    // based on source alignment
    // tile mask
    const int mtile = 128; /* sram is 128 bytes */
    const int mtile_mask = mtile - 1;
    const short maj_x = bltr.MAJ_X;
    const short min_x = bltr.MIN_X;
    int endx  = xDst + cxClip;  // last x, exclusive, in pixels

    short  xaccum;
    int  dstx = xDst;
    int  srcx = xSrc;
    int  dst_ext;
    int  src_ext;
    int  copy_src_ext;

#ifndef WINNT_VER40
    ASSERT( BITSPERPIXEL != 24 ); // HWBUG !!!
#endif

    if ( nBytesPixel == 2 )
    {
       cxSrc *= 2;   /* convert size to Bytes from pixels */
       cxDst *= 2;
       srcx = (xSrc *= 2);
       dstx = (xDst *= 2);
       bltr.OP0_opRDRAM.pt.X *= 2;
       bltr.OP1_opRDRAM.pt.X *= 2;
       endx *= 2;    /* convert end marker to bytes */
    }

#ifdef TRACE_STRETCH
#ifdef TRACE_ALL
    DBG_MESSAGE((" mtile = %d  maj = %d min = %d accum = %d shrinkinc = %04x",
                 mtile, maj_x, min_x, bltr.ACCUM_X, bltr.SHRINKINC));
#endif
#endif

    CALL_DIR_DRV_STR_MBLTY(&bltr);   // Load the invariant registers

    do
    {
      // get alignment to first src tile / sram break;
      if ( srcx & mtile_mask ) // initial alignment
      {
         src_ext = mtile  - (srcx & mtile_mask);
         if ( src_ext > cxSrc )
            src_ext = cxSrc;
      }
      else
      {
         if ( cxSrc < mtile )
            src_ext = cxSrc; // last partial tile
        else
            src_ext = mtile; // complete tile
      }

      srcx  += src_ext;    // account for amount of src consumed
      cxSrc -= src_ext;

      // calculate how many destination pixels == src_ext
      xaccum  = bltr.ACCUM_X;
      dst_ext = 0;
      copy_src_ext = src_ext;
      do
      {
        dst_ext += 2;
        copy_src_ext -= 2 * bltr.SHRINKINC.pt.X;
        xaccum += min_x;
        if ( xaccum < 0 )
        {
          xaccum += maj_x;
          copy_src_ext -= 2;
        }
      } while ( copy_src_ext > 0 && (dstx + dst_ext <= endx) );

      dst_ext &= ~3;    /* force destination extent to DWORDs */

      dstx += dst_ext;

#ifdef TRACE_STRETCH
#ifdef TRACE_ALL
      DBG_MESSAGE((" srcx = %d src_ext = %d cxSrc = %d dstx = %d dst_ext = %d end = %d",
                   srcx, src_ext, cxSrc, dstx, dst_ext, endx ));
#endif
#endif

      bltr.BLTEXT.pt.X = (USHORT)dst_ext;

      if ( dst_ext > 0 )
         CALL_DIR_DRV_STR_MBLTX(&bltr);

      bltr.ACCUM_X      = xaccum;
      bltr.OP0_opRDRAM.pt.X += (USHORT)dst_ext;
      bltr.OP1_opRDRAM.pt.X += (USHORT)src_ext;
      bltr.SRCX         -= (USHORT)src_ext;
    } while ( (dstx < endx) && ( cxSrc > 0));

    xFill = bltr.OP0_opRDRAM.pt.X;

    cxFill  = (xDst + cxDst) - xFill;

#ifdef TRACE_STRETCH
    DBG_MESSAGE((" srcx=%d src_ext=%d cxSrc=%d  dstx=%d dst_ext=%d end=%d xFill=%d cxFill=%d",
                 srcx, src_ext, cxSrc, dstx, dst_ext, endx, xFill, cxFill ));
#endif

    // Edge Fill for trailing edge was deferred. Calculate correct amount
    // Taking into account pixels skipped above for alignment.

    if ((cxFill > 0) && (cxClip = (xFill & 7)) && ((SrcType == LN_YUV422)||((nBytesPixel == 1) &&(SrcType == LN_RGB565))))
    {// these must be extra pixels.  They must be filled using
     //  the same 9th bit and in the same format as the stretch

      cxClip = 8 - cxClip;

      if ( SrcType == LN_YUV422 )
      {
        CALL_DIR_MEDGE_FILL_BLT(xFill,yFill,cxClip,cyFill,
                                MAKELONG(BOGUS_YUV-1,BOGUS_YUV-1),TRUE);
      }
      else
      {
        CALL_DIR_MEDGE_FILL_BLT(xFill,yFill,cxClip,cyFill,0,TRUE);
      }

#ifdef TRACE_STRETCH
      DBG_MESSAGE((" Edge Fill 9th bit set %d,%d %d x %d", xFill, yFill, cxFill, cyFill));
#endif

      xFill = bltr.OP0_opRDRAM.pt.X + cxClip;
      cxFill -= cxClip;
    }

    if ( (SrcType == LN_YUV422) || (SrcType == LN_RGB565 && nBytesPixel == 1) )
    {
      /* This is to ensure that the last packet of stretch blt does no go out with 9th bit clear */
      /* It is cheaper than waiting, especially on single stripe BLTs */

      CALL_DIR_DELAY_9BIT_BLT(TRUE);
    }

    if ( cxFill > 0 )
    {
      /* perform edge fill Blt */
#ifdef BOGUS_8BIT
      CALL_DIR_MEDGE_FILL_BLT(xFill,yFill,cxFill,cyFill,
                              MAKELONG(BOGUS_YUV,BOGUS_YUV),FALSE);
#else
      if ( nBytesPixel == 2 )
        CALL_DIR_MEDGE_FILL_BLT(xFill,yFill,cxFill,cyFill,
                                MAKELONG(BOGUS_YUV,BOGUS_YUV),FALSE);
      else
        CALL_DIR_MEDGE_FILL_BLT(xFill,yFill,cxFill,cyFill,0,FALSE);
#endif

#ifdef TRACE_STRETCH
      DBG_MESSAGE((" Edge Fill(5) %d,%d %d x %d", xFill, yFill, cxFill, cyFill));
#endif
    }
  }
} /* DrvStretch62 */

/***************************************************************************
*
* FUNCTION:     StretchColor
*
* DESCRIPTION:  This is a software solution for both the 5462 and 5464
*               to perform a stretch or shrink while there is a source
*               color key specified.
*
****************************************************************************/

void STRETCHCOLOR
#ifndef WINNT_VER40
  LPGLOBALDATA lpDDHALData,
#endif
  int xDst, int yDst, int cxDst, int cyDst,
  int xSrc, int ySrc, int cxSrc, int cySrc,
  DWORD ColorKey)
{
  PVGAR pREG = (PVGAR) lpDDHALData->RegsAddress;
  int   xError, yError;
  int   xRun, yRun;


  DD_LOG(("StretchColor - dst=%08lX dstext= %08lX src=%08lX srcext=%08lX colorkey=%08lX\r\n",
          MAKELONG(xDst,yDst),MAKELONG(cxDst,cyDst),
          MAKELONG(xSrc,ySrc),MAKELONG(cxSrc,cxSrc),
          ColorKey));
//  DD_LOG(("  Beer break! - we're gonna blt every pixel one at a time\r\n"));

  // Setup the hardware.
  //LL32(grDRAWBLTDEF.DW,   0x101101CC);
  //LL32(grOP_opBGCOLOR.DW, ColorKey);

  // Initialize the error terms.
  xError = ((cxSrc << 16) - 1) / cxDst + 1;
  yError = ((cySrc << 16) - 1) / cyDst + 1;

  // Y loop.
  for (yRun = 0; cyDst--;)
  {
    int dst = xDst;
    int src = xSrc;
    int cx  = cxDst;

    // X loop.
    for (xRun = 0; cx--;)
    {
      // Copy one pixel with color keying
      //LL32(grOP0_opRDRAM.DW, MAKELONG(dst, yDst));
      //LL32(grOP1_opRDRAM.DW, MAKELONG(src, ySrc));
      //LL32(grOP2_opRDRAM.DW, MAKELONG(src, ySrc));
      //LL32(grBLTEXT_EX.DW,   MAKELONG(1, 1));

      // this is bad but is needed for compatibility with display list
      CALL_DRV_SRC_BLT(0x101101CC,          // drawbltdef
                       MAKELONG(dst,yDst),  // dst coord
                       MAKELONG(src,ySrc),  // src coord
                       MAKELONG(src,ySrc),  // colorkey coord
                       ColorKey,            // colorkey
                       MAKELONG(1,1));      // extent

      // Advance destination x.
      dst++;

      // Adjust x error term.
      xRun += xError;
      while (HIWORD(xRun))
      {
        // Advance source x.
        src++;
        xRun -= MAKELONG(0, 1);
      }
    }

    // Advance destination y.
    yDst++;

    // Adjust y error term.
    yRun += yError;
    while (HIWORD(yRun))
    {
      // Advance source y.
      ySrc++;
      yRun -= MAKELONG(0, 1);
    }
  }
} /* StretchColor */

/***************************************************************************
*
* FUNCTION:     TransparentStretch
*
* DESCRIPTION:
*
****************************************************************************/

void TRANSPARENTSTRETCH
#ifndef WINNT_VER40
  LPGLOBALDATA  lpDDHALData,
#endif
  int xDst, int yDst, int cxDst, int cyDst,
  int xSrc, int ySrc, int cxSrc, int cySrc,
  DWORD ColorKey)
{
  const int nBytesPixel = BYTESPERPIXEL;
  const int nSRAMPixels = (SRAM_SIZE / nBytesPixel) / 2;
  const int nSRAMMask   = nSRAMPixels - 1;

  autoblt_regs  SrcToScratch;

  int   xScratch, yScratch;
  int   cxScratch, cyScratch;

  AXIS  axis[2];
  int   nDst[2];
  int   nSrc[2];
  int   i;

  DDAX  accx;
  int   srcx;
  int   xext;

  int   cxTemp;
  int   xTemp;


#ifndef WINNT_VER40
  ASSERT(cxDst >= cxSrc);
#endif

  xScratch = LOWORD(lpDDHALData->ScratchBufferOrg);
  yScratch = HIWORD(lpDDHALData->ScratchBufferOrg);
  cxScratch = cxDst;
  cyScratch = cyDst;

  // initialize auto blt struct for src to scratch buffer
  SrcToScratch.DRAWBLTDEF.DW  = MAKELONG(ROP_OP1_copy, (BD_RES+BD_OP1)*IS_VRAM);

  SrcToScratch.OP0_opRDRAM.DW = MAKELONG(LOWORD(xScratch),LOWORD(yScratch));
  SrcToScratch.OP1_opRDRAM.DW = MAKELONG(LOWORD(xSrc),LOWORD(ySrc));

  SrcToScratch.LNCNTL.W       = lncntl[nBytesPixel-1] << LN_YUV_SHIFT;

  SrcToScratch.SRCX           = cxSrc * nBytesPixel;

#if ENABLE_INTERPOLATED_BLTS
  // Enable interpolation unless we have a palette (8bpp)
  if (1 < nBytesPixel)
    SrcToScratch.LNCNTL.W |= (LN_XINTP_EN | LN_YINTP_EN);
#endif

  SrcToScratch.SHRINKINC.W = 0x0000;

  if (cxDst < cxSrc)
  {
    SrcToScratch.LNCNTL.W |= LN_XSHRINK;
    SrcToScratch.LNCNTL.W &= ~LN_XINTP_EN;
    SrcToScratch.SHRINKINC.pt.X = (cxSrc / cxDst);
  }

  if ( cyDst < cySrc )
  {
    SrcToScratch.LNCNTL.W |= LN_YSHRINK;
    SrcToScratch.LNCNTL.W &= ~LN_YINTP_EN;
    SrcToScratch.SHRINKINC.pt.Y = (cySrc / cyDst);
  }

  SrcToScratch.BLTEXT.DW = MAKELONG(LOWORD(cxScratch),1);

  // Compute DDA terms

  nDst[0] = cxScratch;
  nDst[1] = cyScratch;
  nSrc[0] = cxSrc;
  nSrc[1] = cySrc;

  for (i = 0; i < 2; i++)
  {
    int kDst = 1;

#if ENABLE_INTERPOLATED_BLTS
    if (SrcToScratch.LNCNTL.W & ((i==0) ? LN_XINTP_EN : LN_YINTP_EN))
    {
      nDst[i] *= 4;
      nSrc[i] *= 4;
      nSrc[i] -= 3;

      kDst = 0x8000 / nDst[i];
    }
#endif

    if (SrcToScratch.LNCNTL.W & ((i==0) ? LN_XSHRINK : LN_YSHRINK))
    { /* Shrink Terms */
      axis[i].maj   =  (short)nDst[i];
      axis[i].min   = - (nSrc[i] % nDst[i]);
      axis[i].accum = axis[i].maj - 1
                      - ((nSrc[i] % nDst[i]) / (nSrc[i]/nDst[i] + 1));
    }
    else
    { /* Stretch Terms */
      axis[i].maj   =  kDst * nDst[i];
      axis[i].min   = -kDst * nSrc[i];
      axis[i].accum = axis[i].maj - 1
                      - ((axis[i].maj % -axis[i].min) / (nDst[i]/nSrc[i] + 1));
    }
  }

  SrcToScratch.MAJ_X   = axis[0].maj;
  SrcToScratch.MIN_X   = axis[0].min;
  SrcToScratch.ACCUM_X = axis[0].accum;

  SrcToScratch.MAJ_Y   = axis[1].maj;
  SrcToScratch.MIN_Y   = axis[1].min;
  SrcToScratch.ACCUM_Y = axis[1].accum;



  // loop over scanlines in dst
  // do two blts for each, one from src to scratch buffer
  //   then one from scratch buffer to dst
  while (0 < cyDst)
  {
    // blt one scanline high from src to scratch buffer

    // set values for initial stripe
    xext = nSRAMPixels;
    accx = SrcToScratch.ACCUM_X;
    srcx = xSrc;

    // write settings that don't vary over stripes to the chip
    CALL_DRV_STR_BLTY(&SrcToScratch);

    cxTemp = cxScratch;
    xTemp = xScratch;

    while (cxTemp > xext)
    {
      // update auto blt struct settings
      SrcToScratch.OP0_opRDRAM.pt.X = (USHORT)xTemp;
      SrcToScratch.OP1_opRDRAM.pt.X = (USHORT)srcx;
      SrcToScratch.BLTEXT.pt.X      = (USHORT)xext;

      // blt current stripe
      CALL_DRV_STR_BLTX(&SrcToScratch);

      // increment xDst and decrement remaining dst extent
      xTemp  += xext;
      cxTemp -= xext;

      // walk DDA to compute error term (accx) and xSrc for next stripe
      for (i = 0; i < xext; i++)
      {
        SrcToScratch.ACCUM_X += SrcToScratch.MIN_X;
        if (0 > (short)SrcToScratch.ACCUM_X)
        {
          SrcToScratch.ACCUM_X += SrcToScratch.MAJ_X;
          srcx++;
        }
      }
    }
    // if there's some area left to blt, then do it
    if (0 < cxTemp)
    {
      // update auto blt struct settings
      SrcToScratch.OP0_opRDRAM.pt.X = (USHORT)xTemp;
      SrcToScratch.OP1_opRDRAM.pt.X = (USHORT)srcx;
      SrcToScratch.BLTEXT.pt.X      = (USHORT)cxTemp;

      // blt final stripe
      CALL_DRV_STR_BLTX(&SrcToScratch);
    }
    // reset ACCUM_X for beginning of next scanline
    SrcToScratch.ACCUM_X = accx;

    // walk Y DDA for src to scratch buffer blt
    SrcToScratch.ACCUM_Y += SrcToScratch.MIN_Y;
    SrcToScratch.OP1_opRDRAM.pt.Y += SrcToScratch.SHRINKINC.pt.Y;
    if (0 > (short)SrcToScratch.ACCUM_Y)
    {
      SrcToScratch.ACCUM_Y += SrcToScratch.MAJ_Y;
      SrcToScratch.OP1_opRDRAM.pt.Y++;
    }


    // blt from scratch buffer to dst
    // 1:1 in X, 1:1 in Y, uses colorkey

    CALL_DRV_SRC_BLT(MAKELONG((DD_TRANS | ROP_OP1_copy),
                              ((BD_RES+BD_OP1+BD_OP2)*IS_VRAM)),
                     MAKELONG(xDst,yDst),
                     MAKELONG(xScratch,yScratch),
                     MAKELONG(xScratch,yScratch),
                     ColorKey,
                     MAKELONG(cxDst,1));
    yDst++;
    cyDst--;
  }
}

/****************************************************************************
* FUNCTION NAME: DdBlt (NT) or Blt32 (Win95)
*
* DESCRIPTION:
****************************************************************************/
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40
DWORD DdBlt(PDD_BLTDATA pbd)
{
  DRIVERDATA* lpDDHALData;
  PDEV*    ppdev;
  PVGAR    pREG;

#else   // ----- #elseif WINNT_VER40 -----
DWORD __stdcall Blt32(LPDDHAL_BLTDATA pbd)
{
  LPGLOBALDATA lpDDHALData = GetDDHALContext( pbd->lpDD);
#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

  HRESULT  ddrval;
  DWORD    dwFlags;

  DWORD  dwDstCoord;
  DWORD  dwDstWidth;
  DWORD  dwDstHeight;

  DWORD  dwSrcCoord;
  DWORD  dwSrcWidth;
  DWORD  dwSrcHeight;
  int    BaseOffset;

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

  PDD_SURFACE_LOCAL   dstx;
  PDD_SURFACE_LOCAL   srcx;
  PDD_SURFACE_GLOBAL  dst;
  PDD_SURFACE_GLOBAL  src;

  DISPDBG((DBGLVL, "DDraw - DdBlt\n"));

  ppdev = (PDEV*) pbd->lpDD->dhpdev;
  lpDDHALData = (DRIVERDATA*) &ppdev->DriverData;
  pREG = (PVGAR) lpDDHALData->RegsAddress;

#else   // ----- #elseif WINNT_VER40 -----

  LPDDRAWI_DDRAWSURFACE_LCL  dstx;
  LPDDRAWI_DDRAWSURFACE_LCL  srcx;
  LPDDRAWI_DDRAWSURFACE_GBL  dst;
  LPDDRAWI_DDRAWSURFACE_GBL  src;

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

  DD_LOG(("Blt32 Entry\r\n"));

#ifdef WINNT_VER40
  SYNC_W_3D(ppdev); // if 3D context(s) active, make sure 3D engine idle before continuing...
#endif

  // NOTES:
  //   Everything you need is in lpBlt->bltFX .
  //   Look at lpBlt->dwFlags to determine what kind of blt you are doing,
  //   DDBLT_xxxx are the flags.
  //
  // COLORKEY NOTES:
  //   ColorKey ALWAYS comes in BLTFX. You don't have to look it up in
  //   the surface.

#ifdef WINNT_VER40      // WINNT_VER40

#else   // ----- #elseif WINNT_VER40 -----
  // if direct draw is NOT using display list, it must sync here
  // updateFlipStatus may access the hardware!
  if (!lpDDHALData->DisplayListDDraw && ((lpDDHALData->DrvSemaphore & DRVSEM_3D_BUSY) || (lpDDHALData->DrvSemaphore & DRVSEM_DISPLAY_LIST)))
  {
     qmRequestDirectAccess();
  }
#endif // WINNT_VER40

    // is a flip in progress?
#ifdef WINNT_VER40
    ddrval = vUpdateFlipStatus(
        &ppdev->flipRecord,
        pbd->lpDDDestSurface->lpGbl->fpVidMem);
#else
#if defined(DDRAW_COMPAT_10)
    ddrval = pfnUpdateFlipStatus(
        pbd->lpDDDestSurface->lpData->fpVidMem
        lpDDHALData);
#else
    ddrval = pfnUpdateFlipStatus(
        pbd->lpDDDestSurface->lpGbl->fpVidMem,
        lpDDHALData);
#endif
#endif

  if (ddrval != DD_OK)
  {
     pbd->ddRVal = ddrval;
     DD_LOG(("Blt32 Exit - flip in progress, returning %08lX\r\n", ddrval));
     return (DDHAL_DRIVER_HANDLED);
  }

#ifndef WINNT_VER40
  // if the destination surface of this blt is a texture
  if (DDSCAPS_TEXTURE & pbd->lpDDDestSurface->ddsCaps.dwCaps)
  {
    LP_SURFACE_DATA lpSurfaceData;

    lpSurfaceData = (LP_SURFACE_DATA)(pbd->lpDDDestSurface->dwReserved1);

    // if the texture is a non-agp host texture (i.e. pci memory)
    if (lpSurfaceData->dwFlags & SURF_HOST_BASED_TEXTURE)
    {
        // punt the blt to direct draw hel
        pbd->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_NOTHANDLED;
    }
  }

  // if the source surface of this blt is non-null and is a texture
  if ((NULL != pbd->lpDDSrcSurface) &&
      (DDSCAPS_TEXTURE & pbd->lpDDSrcSurface->ddsCaps.dwCaps))
  {
    LP_SURFACE_DATA lpSurfaceData;

    lpSurfaceData = (LP_SURFACE_DATA)(pbd->lpDDSrcSurface->dwReserved1);

    // if the texture is a non-agp host texture (i.e. pci memory)
    if (lpSurfaceData->dwFlags & SURF_HOST_BASED_TEXTURE)
    {
        // punt the blt to direct draw hel
        pbd->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_NOTHANDLED;
    }
  }
#endif

  // If async, then only work if blter isn't busy.
  // This should probably be a little more specific to each call !!!
  dwFlags = pbd->dwFlags;

//#if 0
//  if( dwFlags & DDBLT_ASYNC )
//  {
//    if( !ENOUGH_FIFO_FOR_BLT )
//    {
//#if 0 // diagnostics for ASYNC BLT lockup
//      DWORD dwROP = pbd->bltFX.dwROP;
//      WORD rop = (WORD) LOBYTE( HIWORD( dwROP ) );
//      PVGAR pREG = (PVGAR) lpDDHALData->RegsAddress;
//      DBG_MESSAGE(("Status = %02x QFREE = %2d", pREG->grSTATUS, pREG->grQFREE));
//      dstx = pbd->lpDDDestSurface;
//      dst  = dstx->lpData;
//      dwDstCoord  = cvlxy( dst->fpVidMem - lpDDHALData->ScreenAddress, BYTESPERPIXEL );
//      dwDstCoord += MAKELONG( pbd->rDest.left, pbd->rDest.top );
//      dwDstWidth  = pbd->rDest.right  - pbd->rDest.left;
//      dwDstHeight = pbd->rDest.bottom - pbd->rDest.top;
//      srcx = pbd->lpDDSrcSurface;
//      src  = srcx->lpData;
//      dwSrcCoord  = cvlxy( src->fpVidMem - lpDDHALData->ScreenAddress, BYTESPERPIXEL );
//      dwSrcCoord += MAKELONG( pbd->rSrc.left, pbd->rSrc.top );
//      dwSrcWidth  = pbd->rSrc.right  - pbd->rSrc.left;
//      dwSrcHeight = pbd->rSrc.bottom - pbd->rSrc.top;
//
//        DBG_MESSAGE(("Failed Blt32: Blt from %08X %dx%d -> %08X %dx%d  rop %X",
//          dwSrcCoord, dwSrcWidth, dwSrcHeight,
//          dwDstCoord, dwDstWidth, dwDstHeight,
//          rop));
//#endif
//      DBG_MESSAGE(("ASYNC FAILED"));
//      pbd->ddRVal = DDERR_WASSTILLDRAWING;
//      return DDHAL_DRIVER_HANDLED;
//    }
//  }
//#endif

  // get offset, width, and height for destination
  dstx = pbd->lpDDDestSurface;

#if DDRAW_COMPAT == 10
  dst  = dstx->lpData;
#else
  dst  = dstx->lpGbl;
#endif

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

  dwDstCoord = cvlxy(ppdev->lDeltaScreen,
                     dst->fpVidMem,
                     BYTESPERPIXEL);

#else   // ----- #elseif WINNT_VER40 -----

  dwDstCoord  = cvlxy( lpDDHALData,dst->fpVidMem - lpDDHALData->ScreenAddress, BYTESPERPIXEL );

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

  dwDstCoord += MAKELONG(pbd->rDest.left, pbd->rDest.top);
  dwDstWidth  = pbd->rDest.right  - pbd->rDest.left;
  dwDstHeight = pbd->rDest.bottom - pbd->rDest.top;

  /* Check for a zero extent stretchblt */

  if ((dwDstWidth == 0) || (dwDstHeight == 0))
  {
     pbd->ddRVal = DD_OK;
     return (DDHAL_DRIVER_HANDLED);
  }
  // If someone is running a full-screen exclusive app it is the
  // responsibility of the app to take care of the cursor. We don't
  // call BeginAccess or EndAccess for them.
  //
  // However, if someone is running a windowed app and they have
  // attached a clipper object to the destination surface then they
  // are more like a normal windows app and we call BeginAccess and
  // EndAccess for them around a blt. That is the only circumstance
  // where we currently do cursor exclusion.
  //
  // We do intend to add calls to BeginAccess and EndAccess around
  // a rectangle lock of the primary surface. In this case, we
  // would only do cursor exclusion if a lock rect is specified.
  // This will be implemented with DirectDraw 2.0.
  //
  // I believe that you should not do automatic cursor exclusion in
  // the driver because you will penalize all blts and locks.

  // Grab the hardware - disable HW cursor updates.
  LOCK_HW_SEMAPHORE();

  // Decipher the flags.
  if (dwFlags & DDBLT_ROP)
  {
    static const WORD mix2blt[] =
    {  // all ops color vram
      BD_RES                  ,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES          | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0         ,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0         ,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES          | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES
    };  // all ops color vram

    DWORD dwROP = pbd->bltFX.dwROP;
    WORD  rop = (WORD) LOBYTE( HIWORD( dwROP ) );
    WORD  mix = rop & 0x0f;
    WORD  bdf = mix2blt[mix];

    if (bdf & BD_OP1) // SRC rops
    {
      srcx = pbd->lpDDSrcSurface;

#if DDRAW_COMPAT == 10
      src  = srcx->lpData;
#else
      src  = srcx->lpGbl;
#endif


#ifdef WINNT_VER40    // YUV movement code
#else
  if ((srcx->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
    (src->ddpfSurface.dwFlags & DDPF_FOURCC)    &&
    (lpDDHALData->DrvSemaphore & DRVSEM_YUV_MOVED) )
  {
    BOOL fMoved = FALSE;
    RECT rYUV;
		LONG lDeltaX, lDeltaY, Scale;
		LONG SrcWidth, SrcHeight, DstWidth, DstHeight;

		SrcWidth = src->wWidth;
		SrcHeight = src->wHeight;

		if (lpDDHALData->DrvSemaphore & DRVSEM_YUV_RECT_VALID)
		{
			rYUV.left	= min(lpDDHALData->YUVLeft,
							  pbd->rDest.left);
			rYUV.top	= min(lpDDHALData->YUVTop,
							  pbd->rDest.top);
			rYUV.right	= max(lpDDHALData->YUVLeft + lpDDHALData->YUVXExt,
							  pbd->rDest.right);
			rYUV.bottom	= max(lpDDHALData->YUVTop + lpDDHALData->YUVYExt,
							  pbd->rDest.bottom);
			DstWidth  = rYUV.right  - rYUV.left;
			DstHeight = rYUV.bottom - rYUV.top;

			if (pbd->rDest.left > rYUV.left)
			{
				// YUV has moved to left.
				lDeltaX = pbd->rDest.left - rYUV.left;
				Scale   = (SrcWidth - pbd->rSrc.right) * DstWidth / SrcWidth;
				lDeltaX = min(lDeltaX, Scale);
				pbd->rSrc.right += lDeltaX * SrcWidth / DstWidth;
				pbd->rDest.left -= lDeltaX;
				fMoved = TRUE;
			}
			if (pbd->rSrc.left > 0)
			{
				// YUV has moved to right.
				lDeltaX = rYUV.right - pbd->rDest.right;
				Scale   = pbd->rSrc.left * DstWidth / SrcWidth;
				lDeltaX = min(lDeltaX, Scale);
				pbd->rSrc.left   -= lDeltaX * SrcWidth / DstWidth;
				pbd->rDest.right += lDeltaX;
				fMoved = TRUE;
			}

			if (pbd->rDest.top > rYUV.top)
			{
				// YUV has moved up.
				lDeltaY = pbd->rDest.top - rYUV.top;
				Scale   = (SrcHeight - pbd->rSrc.bottom) * DstHeight / SrcHeight;
				lDeltaY = min(lDeltaY, Scale);
				pbd->rSrc.bottom += lDeltaY * SrcHeight / DstHeight;
				pbd->rDest.top   -= lDeltaY;
				fMoved = TRUE;
			}
			if (pbd->rSrc.top > 0)
			{
				// YUV has moved down.
				lDeltaY = rYUV.bottom - pbd->rDest.bottom;
				Scale   = pbd->rSrc.top * DstHeight / SrcHeight;
				lDeltaY = min(lDeltaY, Scale);
				pbd->rSrc.top     -= lDeltaY * SrcHeight / DstHeight;
				pbd->rDest.bottom += lDeltaY;
				fMoved = TRUE;
			}
		}

		if (fMoved)
		{
			// Recalculate the destination parameters since they might have
			// changed.
			dwDstCoord  = cvlxy(lpDDHALData,dst->fpVidMem - lpDDHALData->ScreenAddress,
								BYTESPERPIXEL);
			dwDstCoord += MAKELONG(pbd->rDest.left, pbd->rDest.top);
			dwDstWidth  = pbd->rDest.right  - pbd->rDest.left;
			dwDstHeight = pbd->rDest.bottom - pbd->rDest.top;
		}
		else
		{
			// Clear the YUV movement flag.
			lpDDHALData->DrvSemaphore &= ~DRVSEM_YUV_MOVED;
		}
	}

#endif // YUV movement code

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

      dwSrcCoord  = cvlxy(ppdev->lDeltaScreen,
                          src->fpVidMem,
                          BYTESPERPIXEL);

#else   // ----- #elseif WINNT_VER40 -----

      dwSrcCoord  = cvlxy( lpDDHALData,src->fpVidMem - lpDDHALData->ScreenAddress, BYTESPERPIXEL );

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

      dwSrcCoord += MAKELONG( pbd->rSrc.left, pbd->rSrc.top );
      dwSrcWidth  = pbd->rSrc.right  - pbd->rSrc.left;
      dwSrcHeight = pbd->rSrc.bottom - pbd->rSrc.top;

      if (dwFlags & DDBLT_KEYSRCOVERRIDE) // Source Color Key
      {
        DWORD dwColor = CALL_DUP_COLOR(pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue);

        DD_LOG(("Src Color Key Blt\r\n"));

        if ( (dwSrcWidth != dwDstWidth) || (dwSrcHeight != dwDstHeight) )
        {
          if ( !(srcx->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
               (rop == 0x00CC) )
          {
            if (dwSrcWidth < dwDstWidth)
            {
              CALL_TRANSPARENTSTRETCH(LOWORD(dwDstCoord), HIWORD(dwDstCoord),
                                      dwDstWidth, dwDstHeight,
                                      LOWORD(dwSrcCoord), HIWORD(dwSrcCoord),
                                      dwSrcWidth, dwSrcHeight,
                                      dwColor);
              goto blt_exit;
            }
            else
            {
              CALL_STRETCHCOLOR(LOWORD(dwDstCoord), HIWORD(dwDstCoord),
                               dwDstWidth, dwDstHeight,
                               LOWORD(dwSrcCoord), HIWORD(dwSrcCoord),
                               dwSrcWidth, dwSrcHeight,
                               dwColor);
              goto blt_exit;
            }
          }
          else
          {
            DD_LOG(("Unsupported SrcColorKey Blt -> punt\r\n"));
            ddrval = DDERR_UNSUPPORTED;
            goto blt_exit;
          }
        }

//        // PATCOPY is faster if that's all we're doing.
//        if (rop == 0xCC)
//        {
//           rop = 0xF0;
//           bdf = BD_RES | BD_OP2;
//        }

        CALL_DRV_SRC_BLT(MAKELONG(rop|DD_TRANS, bdf | BD_OP2),
                         dwDstCoord,
                         dwSrcCoord,
                         dwSrcCoord,  // Src transparency
                         dwColor,     //
                         MAKELONG(dwDstWidth, dwDstHeight) );

      } // (dwFlags & DDBLT_KEYSRCOVERRIDE) // Source Color Key
      else if (dwFlags & DDBLT_KEYDESTOVERRIDE) // Destination Color Key
      {
        #if _WIN32_WINNT >= 0x500
        // For some reason on NT 5.0 ddckDestColorkey does not work,
        // but ddckSrcColorkey does...
        DWORD dwColor = CALL_DUP_COLOR(pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue);
        #else
        DWORD dwColor = CALL_DUP_COLOR(pbd->bltFX.ddckDestColorkey.dwColorSpaceLowValue);
        #endif

        DD_LOG(("Dst Color Key Blt\r\n"));

        // Punt if stretch or shrink requested.
        if ((dwSrcWidth != dwDstWidth) || (dwSrcHeight != dwDstHeight))
        {
          DD_LOG(("Unsupported DstColorKey Blt -> punt\r\n"));
          ddrval = DDERR_UNSUPPORTED;
          goto blt_exit;
        }

        CALL_DRV_SRC_BLT(MAKELONG(rop|DD_TRANS|DD_TRANSOP, bdf | BD_OP2),
                         dwDstCoord,
                         dwSrcCoord,
                         dwDstCoord,  // Dst transparency
                         dwColor,     //
                         MAKELONG(dwDstWidth, dwDstHeight) );

      } // (dwFlags & DDBLT_KEYDESTOVERRIDE) // Destination Color Key
      else
      {
#ifdef TRACE_STRETCH
        DBG_MESSAGE(("Blt32: Blt from %08X %dx%d -> %08X %dx%d  rop %X",
                     dwSrcCoord, dwSrcWidth, dwSrcHeight,
                     dwDstCoord, dwDstWidth, dwDstHeight,
                     rop));
#endif
#ifdef TRACE_STRETCH
        DBG_MESSAGE(("Blt32: BaseOffset  %08X  %08X",
                     src->fpVidMem - lpDDHALData->ScreenAddress, PITCH));
        DBG_MESSAGE(("Blt32: src->w %04d  %04d (%04x)",
                     src->wWidth, src->wHeight,
                     (src->fpVidMem - lpDDHALData->ScreenAddress) / PITCH ));

#endif

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40
        BaseOffset = src->fpVidMem % ppdev->lDeltaScreen;
#else   // ----- #elseif WINNT_VER40 -----
        BaseOffset = (src->fpVidMem - lpDDHALData->ScreenAddress) % PITCH;
#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

        if ((dwSrcWidth != dwDstWidth) || (dwSrcHeight != dwDstHeight) ||
            (srcx->dwFlags & DDRAWISURF_HASPIXELFORMAT))
        {
          int  nBytesPixel = BYTESPERPIXEL;
          int  SrcType = lncntl[nBytesPixel - 1];
          int  SrcSize = nBytesPixel;

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

          int  ySrcAddr = src->fpVidMem / ppdev->lDeltaScreen;

#else   // ----- #elseif WINNT_VER40 -----

          int ySrcAddr    =  (src->fpVidMem - lpDDHALData->ScreenAddress) / PITCH;

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

          // Punt if 32bpp. The '62 and '64 don't do 32bpp stretches at all...
          // KENTL - 10/4/96
          if (nBytesPixel == 4)
          {
            DD_LOG(("Unsupported 32bpp resize blt -> punt\r\n"));
            ddrval = DDERR_UNSUPPORTED;
            goto blt_exit;
          }

          // Punt if not SRCCPY.
          if (rop != 0x00CC)
          {
            DD_LOG(("Unsupport rop in resize blt -> punt\r\n"));
            ddrval = DDERR_UNSUPPORTED;
            goto blt_exit;
          }

          // This should only be RGB565 in 8Bit FB or YUV422 in 8 or 16.
          if ( srcx->dwFlags & DDRAWISURF_HASPIXELFORMAT )
          {
            if ( src->ddpfSurface.dwFlags & DDPF_FOURCC )
               SrcType = LN_YUV422;
            else
               SrcType = LN_RGB565;

            SrcSize = 2;
          }

          if (LGDEVID == CL_GD5464)
          {
            if ( ! lpDDHALData->EdgeTrim )
              lpDDHALData->EdgeTrim = 15;  // Assign minimum trim percentage

            if ((SrcType == LN_YUV422))
            {
              // Check for 5464 shrink workaround
              if ((dwDstWidth * nBytesPixel) <=
                  ((dwSrcWidth * SrcSize) * (100 - lpDDHALData->EdgeTrim)/100))
              {
                DWORD  dwTDst_X;
                int    iratio;
                int    ratio_1, ratio_2;
                unsigned int  excess;

                if ( nBytesPixel == 1 )
                   dwSrcWidth *= SrcSize;

                iratio = dwSrcWidth / dwDstWidth;
                excess = dwSrcWidth % dwDstWidth;

                ratio_1 = iratio;

                // get power of 2 greater than current number
                ratio_2    = 1;
                do
                {
                   ratio_2 <<= 1;
                } while ( ratio_1 >>= 1 );

                // Check for special cases of ratio already a perfect
                // power of 2 or could be trimmed to a power of two.
                if ((!excess || ((100 * excess) <= (dwSrcWidth * (100 - lpDDHALData->EdgeTrim)/100)))
                    && ( (ratio_2 / iratio) == 2 ) )
                   ratio_2 >>= 1;

                if ( nBytesPixel == 1 )
                { // Mixed mode frame buffer so adjust coords / sizes
                  // to match
//#if 0
//                  if ( !( OFFSCR_YUV_VAR.ratio == ratio_2 ) )
//                  {
//                     OFFSCR_YUV_VAR.ratio = ratio_2;
//
//                     ratio_2 /= 2;
//
//                     // Perform offscreen shrink to adjacent src buffer
//                     CALL_DRVSTRETCH64(
//                       OFFSCR_YUV_VAR.SrcRect.right * SrcSize,
//                       OFFSCR_YUV_VAR.SrcRect.top,
//                       (OFFSCR_YUV_VAR.SrcRect.right - OFFSCR_YUV_VAR.SrcRect.left)/ratio_2,
//                       OFFSCR_YUV_VAR.SrcRect.bottom - OFFSCR_YUV_VAR.SrcRect.top,
//                       OFFSCR_YUV_VAR.SrcRect.left,
//                       OFFSCR_YUV_VAR.SrcRect.top,
//                       OFFSCR_YUV_VAR.SrcRect.right  - OFFSCR_YUV_VAR.SrcRect.left,
//                       OFFSCR_YUV_VAR.SrcRect.bottom - OFFSCR_YUV_VAR.SrcRect.top,
//                       nBytesPixel,
//                       SrcType,
//                       BaseOffset,
//                       FALSE);
//
//                     ratio_2 *= 2;
//                  }  // endif ( !( offscr_YUV.ratio == ratio_2 ) )
//
//                  // Perform stretch from adjacent src buffer to
//                  // onscreen dst
//                  dwTDst_X = LOWORD(dwSrcCoord) +
//                    (OFFSCR_YUV_VAR.SrcRect.right - OFFSCR_YUV_VAR.SrcRect.left) *
//                    SrcSize;
//#else
                  if (!( src->dwReserved1 == (DWORD)ratio_2))
                  {
                     src->dwReserved1 = ratio_2;

                     ratio_2 /= 2;

                     DD_LOG(("YUV shrink to extra buffer (8bpp)\r\n"));

                     // Perform offscreen shrink to adjacent src buffer
                     CALL_DRVSTRETCH64(
                        BaseOffset+(src->wWidth * SrcSize), // X Address of DST buffer
                        ySrcAddr,               // Y Address of DST buffer
                        src->wWidth / ratio_2,  // Width in PIXELS of DST
                        src->wHeight,           // Height
                        BaseOffset,             // X Address of SRC buffer
                        ySrcAddr,               // Y Address of SRC buffer
                        src->wWidth,            // Width in PIXELS of SRC
                        src->wHeight,           // Height
                        nBytesPixel,
                        SrcType,
                        BaseOffset,
                        FALSE);

                        ratio_2 *= 2;
                  }

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40
                  // Perform stretch from adjacent src buffer to onscreen dst
                  dwTDst_X = LOWORD(dwSrcCoord) / ratio_2 + (src->wWidth * SrcSize);
#else   // ----- #elseif WINNT_VER40 -----
                  // Perform stretch from adjacent src buffer   to onscreen dst
                  // Russ/Kent 10/4/96 - This fails for unknown reasons as code. The alternate coding
                  // seems to work better. Fixes PDR#6799
                  //  dwTDst_X  =  LOWORD(dwSrcCoord) / ratio_2 + (src->wWidth * SrcSize);
                  dwTDst_X  = BaseOffset + (LOWORD(dwSrcCoord) - BaseOffset)/ratio_2 + (src->wWidth*SrcSize);
#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

//#endif

//                  dwTDst_X   /= SrcSize;    // Modify src X address
                  dwSrcWidth /= SrcSize;

                  DD_LOG(("YUV stretch from extra buffer (8bpp)\r\n"));

                  CALL_DRVSTRETCH64(
                               LOWORD(dwDstCoord),
                               HIWORD(dwDstCoord),
                               dwDstWidth,
                               dwDstHeight,
                               dwTDst_X,
                               HIWORD(dwSrcCoord),
                               dwSrcWidth / ratio_2,
                               dwSrcHeight,
                               nBytesPixel,
                               SrcType,
                               BaseOffset + (src->wWidth * SrcSize),
                               TRUE);

                } // if ( nBytesPixel == 1 )
                else
                {
//#if 0
//                  if (!( OFFSCR_YUV_VAR.ratio == ratio_2))
//                  {
//                     OFFSCR_YUV_VAR.ratio = ratio_2;
//
//                     CALL_DRVSTRETCH64(
//                       lpDDHALData,
//                       OFFSCR_YUV_VAR.SrcRect.right,
//                       OFFSCR_YUV_VAR.SrcRect.top,
//                       (OFFSCR_YUV_VAR.SrcRect.right - OFFSCR_YUV_VAR.SrcRect.left)/ratio_2,
//                       OFFSCR_YUV_VAR.SrcRect.bottom - OFFSCR_YUV_VAR.SrcRect.top,
//                       OFFSCR_YUV_VAR.SrcRect.left,
//                       OFFSCR_YUV_VAR.SrcRect.top,
//                       OFFSCR_YUV_VAR.SrcRect.right  - OFFSCR_YUV_VAR.SrcRect.left,
//                       OFFSCR_YUV_VAR.SrcRect.bottom - OFFSCR_YUV_VAR.SrcRect.top,
//                       nBytesPixel, SrcType, BaseOffset,
//                       FALSE);
//
//                  }; // endif (!(offscr_YUV.ratio == ratio_2))
//
//                  // Perform stretch from adjacent src buffer to onscreen dst
//                  dwTDst_X = (LOWORD(dwSrcCoord) / ratio_2) +
//                    (OFFSCR_YUV_VAR.SrcRect.right - OFFSCR_YUV_VAR.SrcRect.left);
//
//#else
                  if ( !( src->dwReserved1 == (DWORD)ratio_2 ) )
                  {
                     src->dwReserved1 = ratio_2;

                     DD_LOG(("YUV shrink to extra buffer (16bpp)\r\n"));

                     // Perform offscreen shrink to adjacent src buffer
                     CALL_DRVSTRETCH64(
                       BaseOffset + (src->wWidth) , // X Address of DST buffer
                       ySrcAddr,               // Y Address of DST buffer
                       src->wWidth / ratio_2,  // Width in PIXELS of DST
                       src->wHeight,           // Height
                       BaseOffset,             // X Address of SRC buffer
                       ySrcAddr,               // Y Address of SRC buffer
                       src->wWidth,            // Width in PIXELS of SRC
                       src->wHeight,           // Height
                       nBytesPixel,
                       SrcType,
                       BaseOffset,
                       FALSE);
                  }

                  // Perform stretch from adjacent src buffer to onscreen dst
                  dwTDst_X = (LOWORD(dwSrcCoord) - BaseOffset) / ratio_2 + BaseOffset + (src->wWidth);
//#endif

                  DD_LOG(("YUV stretch from extra buffer (16bpp)\r\n"));

                  CALL_DRVSTRETCH64(
                               LOWORD(dwDstCoord),
                               HIWORD(dwDstCoord),
                               dwDstWidth,
                               dwDstHeight,
                               dwTDst_X,
                               HIWORD(dwSrcCoord),
                               dwSrcWidth / ratio_2,
                               dwSrcHeight,
                               nBytesPixel,
                               SrcType,
                               BaseOffset,
                               TRUE);

                } // endif ( nBytesPixel == 1 )
              }
              else
              {
                DD_LOG(("YUV stretch\r\n"));

                CALL_DRVSTRETCH64(
                             LOWORD(dwDstCoord),
                             HIWORD(dwDstCoord),
                             dwDstWidth,
                             dwDstHeight,
                             LOWORD(dwSrcCoord),
                             HIWORD(dwSrcCoord),
                             dwSrcWidth,
                             dwSrcHeight,
                             nBytesPixel,
                             SrcType,
                             BaseOffset,
                             TRUE);
              }
            }  // if ((SrcType == LN_YUV422))
            else
            {
              DD_LOG(("RGB resize blt\r\n"));

              // handle shrinks & stretches
              if ((2 == nBytesPixel) && (dwSrcWidth > dwDstWidth))
              {
                // handles 16bpp RGB shrinks
                CALL_RGB_16SHRINKBOF64(LOWORD(dwDstCoord), HIWORD(dwDstCoord),
                                       dwDstWidth, dwDstHeight,
                                       LOWORD(dwSrcCoord), HIWORD(dwSrcCoord),
                                       dwSrcWidth, dwSrcHeight);
              }
              else
              {
                // handles 16bpp RGB stretches, 8bpp stretches & 8bpp shrinks
                CALL_RGB_RESIZEBOF64(LOWORD(dwDstCoord), HIWORD(dwDstCoord),
                                     dwDstWidth, dwDstHeight,
                                     LOWORD(dwSrcCoord), HIWORD(dwSrcCoord),
                                     dwSrcWidth, dwSrcHeight);
              }
            } // endif ((SrcType == LN_YUV422))
          }  // if (LGDEVID == CL_GD5464)
          else
          {
            DD_LOG(("calling DrvStretch62\r\n"));

            CALL_DRVSTRETCH62(
                          LOWORD(dwDstCoord),
                          HIWORD(dwDstCoord),
                          dwDstWidth,
                          dwDstHeight,
                          LOWORD(dwSrcCoord),
                          HIWORD(dwSrcCoord),
                          dwSrcWidth,
                          dwSrcHeight,
                          nBytesPixel,
                          SrcType,
                          BaseOffset,
                          TRUE);

          }  // endif (LGDEVID == CL_GD5464)
        }
        else
        {
          DD_LOG(("1:1 two operand blt\r\n"));

          CALL_DRV_SRC_BLT(MAKELONG(rop, bdf),
                           dwDstCoord,
                           dwSrcCoord,
                           0UL,     // don't care
                           0UL,     //
                           MAKELONG(dwDstWidth, dwDstHeight));
        }
      } // endif (dwFlags & DDBLT_KEYSRCOVERRIDE) // Source Color Key
    }
    else // DST ONLY rops
    {
      DD_LOG(("Dst Only Blt\r\n"));

      CALL_DRV_DST_BLT(MAKELONG(rop, bdf),
                       dwDstCoord,
                       0UL,  // don't care
                       MAKELONG(dwDstWidth, dwDstHeight) );
    }  // endif (bdf & BD_OP1) // SRC rops
  } // (dwFlags & DDBLT_ROP)
  else if (dwFlags & DDBLT_COLORFILL)
  {
    DWORD dwColor = CALL_DUP_COLOR(pbd->bltFX.dwFillColor);

    DD_LOG(("Solid Color Fill\r\n"));

    CALL_DRV_DST_BLT(MAKELONG(0x00CC, BD_RES | (BD_OP1 * IS_SOLID)),
                     dwDstCoord,
                     dwColor,  // fill color
                     MAKELONG(dwDstWidth, dwDstHeight));
  }
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifndef WINNT_VER40     // Not WINNT_VER40
  else if (bD3DInit && dwFlags & DDBLT_DEPTHFILL)
  {
    //JGO changed for Laguna3D integration
    DWORD dwFillDepth = CALL_DUPZFILL(pbd->bltFX.dwFillDepth,
                                      dstx->lpGbl->ddpfSurface.dwZBufferBitDepth);

    DD_LOG(("Depth Fill Blt\r\n"));

    // convert to byte blt
    // 16 bit zbuffer in 32 bit frame buffer trashes everything to right
    // of zbuffer
    // Fixes PDR #9152
    ((PT *)(&dwDstCoord))->X *= (WORD)(dst->ddpfSurface.dwZBufferBitDepth / 8);
    dwDstWidth *= (dst->ddpfSurface.dwZBufferBitDepth / 8);

    CALL_DRV_DST_MBLT(MAKELONG(0x00CC, BD_RES | (BD_OP1 * IS_SOLID)),
                     dwDstCoord,
                     dwFillDepth,
                     MAKELONG(dwDstWidth, dwDstHeight));
  }
#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>
  else
  {
    DD_LOG(("Unsupported blt - dwFlags = %08lX\r\n", dwFlags));
    ddrval = DDERR_UNSUPPORTED;
    goto blt_exit;
  } // endif (dwFlags & DDBLT_ROP)

blt_exit:

  // Release the hardware - enable HW cursor updates.
  UNLOCK_HW_SEMAPHORE();

  if (ddrval != DD_OK)
     return DDHAL_DRIVER_NOTHANDLED;

  pbd->ddRVal = DD_OK;

  DD_LOG(("Blt32 Exit\r\n"));

  return DDHAL_DRIVER_HANDLED;

} /* DdBlt */

/***************************************************************************
*
* FUNCTION:     BltInit
*
* DESCRIPTION:
*
****************************************************************************/

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40
void BltInit (PDEV* ppdev,  BOOL bEnableDisplayListBlts )
#else   // ----- #elseif WINNT_VER40-----
void BltInit ( BOOL bEnableDisplayListBlts ,LPGLOBALDATA lpDDHALData)
#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>
{
  if ((CL_GD5462 == LGDEVID) || (FALSE == bEnableDisplayListBlts))
  {
#ifdef WINNT_VER40
    ppdev->pfnDelay9BitBlt = DIR_Delay9BitBlt;
    ppdev->pfnEdgeFillBlt  = DIR_EdgeFillBlt;
    ppdev->pfnMEdgeFillBlt = DIR_MEdgeFillBlt;
    ppdev->pfnDrvDstBlt    = DIR_DrvDstBlt;
    ppdev->pfnDrvDstMBlt   = DIR_DrvDstMBlt;
    ppdev->pfnDrvSrcBlt    = DIR_DrvSrcBlt;
    ppdev->pfnDrvSrcMBlt   = DIR_DrvSrcMBlt;
    ppdev->pfnDrvStrBlt    = DIR_DrvStrBlt;
    ppdev->pfnDrvStrMBlt   = DIR_DrvStrMBlt;
    ppdev->pfnDrvStrMBltY  = DIR_DrvStrMBltY;
    ppdev->pfnDrvStrMBltX  = DIR_DrvStrMBltX;
    ppdev->pfnDrvStrBltY   = DIR_DrvStrBltY;
    ppdev->pfnDrvStrBltX   = DIR_DrvStrBltX;
#else
    pfnDelay9BitBlt = DIR_Delay9BitBlt;
    pfnEdgeFillBlt  = DIR_EdgeFillBlt;
    pfnMEdgeFillBlt = DIR_MEdgeFillBlt;
    pfnDrvDstBlt    = DIR_DrvDstBlt;
    pfnDrvDstMBlt   = DIR_DrvDstMBlt;
    pfnDrvSrcBlt    = DIR_DrvSrcBlt;
    pfnDrvSrcMBlt   = DIR_DrvSrcMBlt;
    if (REVID_PRE65 & lpDDHALData->bRevInfoBits)
      pfnDrvStrBlt  = DIR_DrvStrBlt;
    else
      pfnDrvStrBlt  = DIR_DrvStrBlt65;
    pfnDrvStrMBlt   = DIR_DrvStrMBlt;
    pfnDrvStrMBltY  = DIR_DrvStrMBltY;
    pfnDrvStrMBltX  = DIR_DrvStrMBltX;
    pfnDrvStrBltY   = DIR_DrvStrBltY;
    pfnDrvStrBltX   = DIR_DrvStrBltX;
#if ENABLE_CLIPPEDBLTS
    if (! (REVID_PRE65 & lpDDHALData->bRevInfoBits))
    {
      if (CL_GD5465 == LGDEVID)
      {
        pfnClippedDrvDstBlt  = DIR_SWClippedDrvDstBlt;
        pfnClippedDrvDstMBlt = DIR_SWClippedDrvDstMBlt;
        pfnClippedDrvSrcBlt  = DIR_SWClippedDrvSrcBlt;
      }
      else
      {
        pfnClippedDrvDstBlt  = DIR_HWClippedDrvDstBlt;
        pfnClippedDrvDstMBlt = DIR_HWClippedDrvDstMBlt;
        pfnClippedDrvSrcBlt  = DIR_HWClippedDrvSrcBlt;
      }
    }
#endif
#endif
  }
  else
  {
#ifdef WINNT_VER40
    ppdev->pfnDelay9BitBlt = DL_Delay9BitBlt;
    ppdev->pfnEdgeFillBlt  = DL_EdgeFillBlt;
    ppdev->pfnMEdgeFillBlt = DL_MEdgeFillBlt;
    ppdev->pfnDrvDstBlt    = DL_DrvDstBlt;
    ppdev->pfnDrvDstMBlt   = DL_DrvDstMBlt;
    ppdev->pfnDrvSrcBlt    = DL_DrvSrcBlt;
    ppdev->pfnDrvSrcMBlt   = DL_DrvSrcMBlt;
    ppdev->pfnDrvStrBlt    = DL_DrvStrBlt;
    ppdev->pfnDrvStrMBlt   = DL_DrvStrMBlt;
    ppdev->pfnDrvStrMBltY  = DL_DrvStrMBltY;
    ppdev->pfnDrvStrMBltX  = DL_DrvStrMBltX;
    ppdev->pfnDrvStrBltY   = DL_DrvStrBltY;
    ppdev->pfnDrvStrBltX   = DL_DrvStrBltX;
#else
    pfnDelay9BitBlt = DL_Delay9BitBlt;
    pfnEdgeFillBlt  = DL_EdgeFillBlt;
    pfnMEdgeFillBlt = DL_MEdgeFillBlt;
    pfnDrvDstBlt    = DL_DrvDstBlt;
    pfnDrvDstMBlt   = DL_DrvDstMBlt;
    pfnDrvSrcBlt    = DL_DrvSrcBlt;
    pfnDrvSrcMBlt   = DL_DrvSrcMBlt;
    if (REVID_PRE65 & lpDDHALData->bRevInfoBits)
      pfnDrvStrBlt  = DL_DrvStrBlt;
    else
      pfnDrvStrBlt  = DL_DrvStrBlt65;
    pfnDrvStrMBlt   = DL_DrvStrMBlt;
    pfnDrvStrMBltY  = DL_DrvStrMBltY;
    pfnDrvStrMBltX  = DL_DrvStrMBltX;
    pfnDrvStrBltY   = DL_DrvStrBltY;
    pfnDrvStrBltX   = DL_DrvStrBltX;
#if ENABLE_CLIPPEDBLTS
    if (! (REVID_PRE65 & lpDDHALData->bRevInfoBits))
    {
      if (CL_GD5465 == LGDEVID)
      {
        pfnClippedDrvDstBlt  = DL_SWClippedDrvDstBlt;
        pfnClippedDrvDstMBlt = DL_SWClippedDrvDstMBlt;
        pfnClippedDrvSrcBlt  = DL_SWClippedDrvSrcBlt;
      }
      else
      {
        pfnClippedDrvDstBlt  = DL_HWClippedDrvDstBlt;
        pfnClippedDrvDstMBlt = DL_HWClippedDrvDstMBlt;
        pfnClippedDrvSrcBlt  = DL_HWClippedDrvSrcBlt;
      }
    }
#endif
#endif
  }
}
#endif // WINNT_VER35
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\ddflip.c ===
/***************************************************************************
*
*                ******************************************
*                * Copyright (c) 1996, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:  Laguna I (CL-GD546x) -
*
* FILE:     ddflip.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module implements the DirectDraw FLIP components
*           for the Laguna NT driver.
*
* MODULES:
*           vGetDisplayDuration()
*           vUpdateFlipStatus()
*           DdFlip()
*           DdWaitForVerticalBlank()
*           DdGetFlipStatus()
*
* REVISION HISTORY:
*   7/12/96     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/ddflip.c  $
* 
*    Rev 1.10   16 Sep 1997 15:04:06   bennyn
* 
* Modified for NT DD overlay
* 
*    Rev 1.9   29 Aug 1997 17:42:20   RUSSL
* Added 65 overlay support
*
*    Rev 1.8   11 Aug 1997 14:07:58   bennyn
*
* Enabled GetScanLine() (for PDR 10254)
*
****************************************************************************
****************************************************************************/
/*----------------------------- INCLUDES ----------------------------------*/
#include "precomp.h"

//
// This file isn't used in NT 3.51
//
#ifndef WINNT_VER35

/*----------------------------- DEFINES -----------------------------------*/
//#define DBGBRK
#define DBGLVL        1

#define CSL           0x00C4
#define CSL_5464      0x0140

/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/

/*-------------------------- STATIC VARIABLES -----------------------------*/

/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/

#if DRIVER_5465 && defined(OVERLAY)
// CurrentVLine is in ddinline.h for overlay
#else
/***************************************************************************
*
* FUNCTION:     CurrentVLine
*
* DESCRIPTION:
*
****************************************************************************/
static __inline int CurrentVLine (PDEV* ppdev)
{
  WORD   cline;
  PBYTE  pMMReg = (PBYTE) ppdev->pLgREGS_real;
  PWORD  pCSL;
  BYTE   tmpb;


  // on 5462 there is no CurrentScanLine register
  // on RevAA of 5465 it's busted
  if ((CL_GD5462 == ppdev->dwLgDevID) ||
     ((CL_GD5465 == ppdev->dwLgDevID) && (0 == ppdev->dwLgDevRev)))
     return 0;

  if (IN_VBLANK)
     return 0;

  // read current scanline
  if (ppdev->dwLgDevID == CL_GD5464)
     pCSL = (PWORD) (pMMReg + CSL_5464);
  else
     pCSL = (PWORD) (pMMReg + CSL);

  cline = *pCSL & 0x0FFF;

  // if scanline doubling is enabled, divide current scanline by 2
  tmpb = (BYTE) LLDR_SZ (grCR9);
  if (0x80 & tmpb)
     cline /= 2;

  // if current scanline is past end of visible screen return 0
  if (cline >= ppdev->cyScreen)
    return 0;
  else
    return cline;
}
#endif

/****************************************************************************
* FUNCTION NAME: vGetDisplayDuration
*
* DESCRIPTION:   Get the length, in EngQueryPerformanceCounter() ticks,
*                of a refresh cycle.
*                (Based on S3 DirectDraw code)
****************************************************************************/
#define NUM_VBLANKS_TO_MEASURE      1
#define NUM_MEASUREMENTS_TO_TAKE    8

VOID vGetDisplayDuration(PFLIPRECORD pflipRecord)
{
  LONG        i,  j;
  LONGLONG    li, liMin;
  LONGLONG    aliMeasurement[NUM_MEASUREMENTS_TO_TAKE + 1];

  DISPDBG((DBGLVL, "DDraw - vGetDisplayDuration\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  memset(pflipRecord, 0, sizeof(FLIPRECORD));

  // Warm up EngQUeryPerformanceCounter to make sure it's in the working set
  EngQueryPerformanceCounter(&li);

  // Unfortunately, since NT is a proper multitasking system, we can't
  // just disable interrupts to take an accurate reading.  We also can't
  // do anything so goofy as dynamically change our thread's priority to
  // real-time.
  //
  // So we just do a bunch of short measurements and take the minimum.
  //
  // It would be 'okay' if we got a result that's longer than the actual
  // VBlank cycle time -- nothing bad would happen except that the app
  // would run a little slower.  We don't want to get a result that's
  // shorter than the actual VBlank cycle time -- that could cause us
  // to start drawing over a frame before the Flip has occured.
  while(IN_VBLANK);
  while(IN_DISPLAY);

  for (i = 0; i < NUM_MEASUREMENTS_TO_TAKE; i++)
  {
    // We're at the start of the VBlank active cycle!
    EngQueryPerformanceCounter(&aliMeasurement[i]);

    // Okay, so life in a multi-tasking environment isn't all that
    // simple.  What if we had taken a context switch just before
    // the above EngQueryPerformanceCounter call, and now were half
    // way through the VBlank inactive cycle?  Then we would measure
    // only half a VBlank cycle, which is obviously bad.  The worst
    // thing we can do is get a time shorter than the actual VBlank
    // cycle time.
    //
    // So we solve this by making sure we're in the VBlank active
    // time before and after we query the time.  If it's not, we'll
    // sync up to the next VBlank (it's okay to measure this period --
    // it will be guaranteed to be longer than the VBlank cycle and
    // will likely be thrown out when we select the minimum sample).
    // There's a chance that we'll take a context switch and return
    // just before the end of the active VBlank time -- meaning that
    // the actual measured time would be less than the true amount --
    // but since the VBlank is active less than 1% of the time, this
    // means that we would have a maximum of 1% error approximately
    // 1% of the times we take a context switch.  An acceptable risk.
    //
    // This next line will cause us wait if we're no longer in the
    // VBlank active cycle as we should be at this point:
    while(IN_DISPLAY);

    for (j = 0; j < NUM_VBLANKS_TO_MEASURE; j++)
    {
      while(IN_VBLANK);
      while(IN_DISPLAY);
    };
  };

  EngQueryPerformanceCounter(&aliMeasurement[NUM_MEASUREMENTS_TO_TAKE]);

  // Use the minimum:
  liMin = aliMeasurement[1] - aliMeasurement[0];

  for (i = 2; i <= NUM_MEASUREMENTS_TO_TAKE; i++)
  {
    li = aliMeasurement[i] - aliMeasurement[i - 1];

    if (li < liMin)
       liMin = li;
  };

  // Round the result:
  pflipRecord->liFlipDuration
      = (DWORD) (liMin + (NUM_VBLANKS_TO_MEASURE / 2)) / NUM_VBLANKS_TO_MEASURE;

  pflipRecord->liFlipTime = aliMeasurement[NUM_MEASUREMENTS_TO_TAKE];
  pflipRecord->bFlipFlag  = FALSE;
  pflipRecord->fpFlipFrom = 0;
} // getDisplayDuration


/****************************************************************************
* FUNCTION NAME: vUpdateFlipStatus
*
* DESCRIPTION:   Checks and sees if the most recent flip has occurred.
*                (Based on S3 DirectDraw code)
****************************************************************************/
HRESULT vUpdateFlipStatus(PFLIPRECORD pflipRecord, FLATPTR fpVidMem)
{
  LONGLONG liTime;

  DISPDBG((DBGLVL, "DDraw - vUpdateFlipStatus\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  // see if a flip has happened recently
  if ((pflipRecord->bFlipFlag) &&
      ((fpVidMem == 0xFFFFFFFF) || (fpVidMem == pflipRecord->fpFlipFrom)))
  {
    if ((IN_VBLANK))
    {
       if (pflipRecord->bWasEverInDisplay)
          pflipRecord->bHaveEverCrossedVBlank = TRUE;
    }
    else if (!(IN_DISPLAYENABLE))
    {
       if (pflipRecord->bHaveEverCrossedVBlank)
       {
          pflipRecord->bFlipFlag = FALSE;

          return(DD_OK);
       };
       pflipRecord->bWasEverInDisplay = TRUE;
    };

    EngQueryPerformanceCounter(&liTime);

    if (liTime - pflipRecord->liFlipTime <= pflipRecord->liFlipDuration)
    {
        return(DDERR_WASSTILLDRAWING);
    };

    pflipRecord->bFlipFlag = FALSE;
  };

  return(DD_OK);
} // updateFlipStatus


/****************************************************************************
* FUNCTION NAME: DdFlip
*
* DESCRIPTION:
*                (Based on S3 DirectDraw code)
****************************************************************************/
DWORD DdFlip(PDD_FLIPDATA lpFlip)
{
  DRIVERDATA* pDriverData;
  PDEV*       ppdev;
  HRESULT     ddrval;

  ULONG       ulMemoryOffset;
  ULONG       ulLowOffset;
  ULONG       ulMiddleOffset;
  ULONG       ulHighOffset;
  BYTE        tmpb;

  DISPDBG((DBGLVL, "DDraw - DdFlip\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  ppdev = (PDEV*) lpFlip->lpDD->dhpdev;
  pDriverData = (DRIVERDATA*) &ppdev->DriverData;

  SYNC_W_3D(ppdev);

#if DRIVER_5465 && defined(OVERLAY)
  if (DDSCAPS_OVERLAY & lpFlip->lpSurfCurr->ddsCaps.dwCaps)
    return pDriverData->OverlayTable.pfnFlip(ppdev,lpFlip);
#endif

  // Is the current flip still in progress?
  // Don't want a flip to work until after the last flip is done,
  // so we ask for the general flip status.
  ddrval = vUpdateFlipStatus(&ppdev->flipRecord, 0xFFFFFFFF);

  if ((ddrval != DD_OK) || (DrawEngineBusy(pDriverData)))
  {
     lpFlip->ddRVal = DDERR_WASSTILLDRAWING;
     return(DDHAL_DRIVER_HANDLED);
  };

  // everything is OK, do the flip here
  {
    DWORD dwOffset;

    // Determine the offset to the new area.
    dwOffset = lpFlip->lpSurfTarg->lpGbl->fpVidMem >> 2;

    // Make sure that the border/blanking period isn't active; wait if
    // it is.  We could return DDERR_WASSTILLDRAWING in this case, but
    // that will increase the odds that we can't flip the next time:
    while (IN_DISPLAYENABLE)
        ;

    // Flip the primary surface by changing CRD, CRC, CR1B and CR1D
    // Do CRD last because the start address is double buffered and
    // will take effect after CRD is updated.

    // need bits 19 & 20 of address in bits 3 & 4 of CR1D
    tmpb = (BYTE) LLDR_SZ (grCR1D);
    tmpb = (tmpb & ~0x18) | (BYTE3FROMDWORD(dwOffset) & 0x18);
    LL8(grCR1D, tmpb);

    // need bits 16, 17 & 18 of address in bits 0, 2 & 3 of CR1B
	 tmpb = (BYTE) LLDR_SZ (grCR1B);
    tmpb = (tmpb & ~0x0D) |
           ((((BYTE3FROMDWORD(dwOffset) & 0x06) << 1) |
              (BYTE3FROMDWORD(dwOffset) & 0x01)));
    LL8(grCR1B, tmpb);

    // bits 8-15 of address go in CRC
    LL8(grCRC, BYTE2FROMDWORD(dwOffset));
    // bits 0-7 of address go in CRD
    LL8(grCRD, BYTE1FROMDWORD(dwOffset));
  };

  // remember where/when we were when we did the flip
  EngQueryPerformanceCounter(&ppdev->flipRecord.liFlipTime);

  ppdev->flipRecord.bFlipFlag              = TRUE;
  ppdev->flipRecord.bHaveEverCrossedVBlank = FALSE;
  ppdev->flipRecord.bWasEverInDisplay      = FALSE;

  ppdev->flipRecord.fpFlipFrom = lpFlip->lpSurfCurr->lpGbl->fpVidMem;

  lpFlip->ddRVal = DD_OK;

  return(DDHAL_DRIVER_HANDLED);
} // Flip


/****************************************************************************
* FUNCTION NAME: DdWaitForVerticalBlank
*
* DESCRIPTION:
****************************************************************************/
DWORD DdWaitForVerticalBlank(PDD_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank)
{
  PDEV*  ppdev;

  DISPDBG((DBGLVL, "DDraw - DdWaitForVerticalBlank\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  ppdev = (PDEV*) lpWaitForVerticalBlank->lpDD->dhpdev;

  lpWaitForVerticalBlank->ddRVal = DD_OK;

  switch (lpWaitForVerticalBlank->dwFlags)
  {
    case DDWAITVB_I_TESTVB:
      // If TESTVB, it's just a request for the current vertical blank
      // status:
      lpWaitForVerticalBlank->bIsInVB = IN_VBLANK;
      return(DDHAL_DRIVER_HANDLED);

    case DDWAITVB_BLOCKBEGIN:
      // If BLOCKBEGIN is requested, we wait until the vertical blank
      // is over, and then wait for the display period to end:
      while(IN_VBLANK);
      while(IN_DISPLAY);
      return(DDHAL_DRIVER_HANDLED);

    case DDWAITVB_BLOCKEND:
      // If BLOCKEND is requested, we wait for the vblank interval to end:
      while(IN_DISPLAY);
      while(IN_VBLANK);
      return(DDHAL_DRIVER_HANDLED);

    default:
      return DDHAL_DRIVER_NOTHANDLED;
  };  // end switch

  return(DDHAL_DRIVER_NOTHANDLED);
} // WaitForVerticalBlank


/****************************************************************************
* FUNCTION NAME: DdGetFlipStatus
*
* DESCRIPTION:   If the display has gone through one refresh cycle since
*                the flip occurred, we return DD_OK.  If it has not gone
*                through one refresh cycle we return DDERR_WASSTILLDRAWING
*                to indicate that this surface is still busy "drawing" the
*                flipped page. We also return DDERR_WASSTILLDRAWING if the
*                bltter is busy and the caller wanted to know if they could
*                flip yet.
****************************************************************************/
DWORD DdGetFlipStatus(PDD_GETFLIPSTATUSDATA lpGetFlipStatus)
{
  DRIVERDATA* pDriverData;
  PDEV*  ppdev;

  ppdev = (PDEV*) lpGetFlipStatus->lpDD->dhpdev;
  pDriverData = (DRIVERDATA*) &ppdev->DriverData;

  DISPDBG((DBGLVL, "DDraw - DdGetFlipStatus\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  SYNC_W_3D(ppdev);

#if DRIVER_5465 && defined(OVERLAY)
  if (DDSCAPS_OVERLAY & lpGetFlipStatus->lpDDSurface->ddsCaps.dwCaps)
  {
    DWORD   dwVWIndex;
    LP_SURFACE_DATA  pSurfaceData = (LP_SURFACE_DATA) lpGetFlipStatus->lpDDSurface->dwReserved1;

    dwVWIndex = GetVideoWindowIndex(pSurfaceData->dwOverlayFlags);

    lpGetFlipStatus->ddRVal =
        pDriverData->OverlayTable.pfnGetFlipStatus(ppdev,
                                                   lpGetFlipStatus->lpDDSurface->lpGbl->fpVidMem,
                                                   dwVWIndex);
  }
  else
#endif
  {
    // We don't want a flip to work until after the last flip is done,
    // so we ask for the general flip status.
    lpGetFlipStatus->ddRVal = vUpdateFlipStatus(&ppdev->flipRecord, 0xFFFFFFFF);
  }

  // Check if the bltter is busy if someone wants to know if they can flip
  if (lpGetFlipStatus->dwFlags == DDGFS_CANFLIP)
  {
     if ((lpGetFlipStatus->ddRVal == DD_OK) && DrawEngineBusy(pDriverData))
        lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
  }

  return(DDHAL_DRIVER_HANDLED);

} // GetFlipStatus


// #ifdef  DDDRV_GETSCANLINE  /************/
/****************************************************************************
* FUNCTION NAME: GetScanLine
*
* DESCRIPTION:
*                (Based on Laguna Win95 DirectDraw code)
****************************************************************************/
DWORD GetScanLine(PDD_GETSCANLINEDATA lpGetScanLine)
{
  PDEV*   ppdev;

  ppdev  = (PDEV*) lpGetScanLine->lpDD->dhpdev;

  // If a vertical blank is in progress the scan line is in
  // indeterminant. If the scan line is indeterminant we return
  // the error code DDERR_VERTICALBLANKINPROGRESS.
  // Otherwise we return the scan line and a success code

  SYNC_W_3D(ppdev);   // if 3D context(s) active, make sure 3D engine idle before continuing...

  if (IN_VBLANK)
  {
     lpGetScanLine->ddRVal = DDERR_VERTICALBLANKINPROGRESS;
  }
  else
  {
     lpGetScanLine->dwScanLine = CurrentVLine(ppdev);
     lpGetScanLine->ddRVal = DD_OK;
  };

  return DDHAL_DRIVER_HANDLED;

} // GetScanLine

// #endif // DDDRV_GETSCANLINE ************

#endif // ! ver 3.51



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\ddsurf.c ===
/***************************************************************************
*
*                ******************************************
*                * Copyright (c) 1996, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:  Laguna I (CL-GD546x) -
*
* FILE:     ddsurf.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module implements the DirectDraw SURFACE
*           components for the Laguna NT driver.
*
* MODULES:
*           DdLock()
*           DdUnlock()
*           CanCreateSurface()
*           CreateSurface()
*           DestroySurface()
*
* REVISION HISTORY:
*   7/12/96     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/ddsurf.c  $
* 
*    Rev 1.25   May 01 1998 11:33:02   frido
* Added one more check for PC98.
* 
*    Rev 1.24   May 01 1998 11:07:24   frido
* Finally the programmable blitter stride works.
* 
*    Rev 1.23   Mar 30 1998 13:04:38   frido
* Added one more call to Set256ByteFetch if an overlay failed to be created.
* 
*    Rev 1.22   Mar 25 1998 18:09:44   frido
* PDR#11184. Finally. When overlays are turned on, 256-byte fetch
* should be turned off. And when overlays are turned off again, 256-byte
* fetch should be restored.
* 
*    Rev 1.21   17 Oct 1997 11:29:48   bennyn
* Clear dwReserved1 after DestroySurface.
* 
*    Rev 1.20   16 Oct 1997 09:52:56   bennyn
* 
* Fixed the FlipCube FPS exceed refresh rate problem
* 
*    Rev 1.19   08 Oct 1997 11:29:38   RUSSL
* Fix so this file can be compiled without OVERLAY defined
* 
*    Rev 1.18   26 Sep 1997 11:01:14   bennyn
* Fixed PDR 10563
* 
*    Rev 1.17   16 Sep 1997 15:13:46   bennyn
* Added DD overlay support.
* 
*    Rev 1.16   03 Sep 1997 17:00:48   bennyn
* In CreateSurface() punts the request if at 320x240x8 or 320x200x8
*
****************************************************************************
****************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/
#include "precomp.h"
#include <clioctl.h>

//
// This file isn't used in NT 3.51
//
#ifndef WINNT_VER35


/*----------------------------- DEFINES -----------------------------------*/
//#define DBGBRK
#define DBGLVL        1

/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/

#if DRIVER_5465 && defined(OVERLAY)
VOID GetFormatInfo (LPDDPIXELFORMAT lpFormat, LPDWORD lpFourcc, LPDWORD lpBitCount);
#endif

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/

/*-------------------------- STATIC VARIABLES -----------------------------*/

/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/

#if DRIVER_5465 // PDR#11184
VOID Set256ByteFetch(PPDEV ppdev, BOOL fEnable)
{
	ULONG ulStall = 50 * 1000;
	ULONG ulReturn;

	while (LLDR_SZ(grSTATUS) != 0) ;	// Wait for idle chip.
	while (LLDR_SZ(grQFREE) != 25) ;	// Wait for empty FIFO queue.
	DEVICE_IO_CTRL(ppdev->hDriver,		// Wait for 50 ms.
				   IOCTL_STALL,
				   &ulStall, sizeof(ulStall),
				   NULL, 0,
				   &ulReturn,
				   NULL);

	if (fEnable)
	{
		// Restore the CONTROL2 register value.
		LL16(grCONTROL2, ppdev->DriverData.dwCONTROL2Save);
	}
	else
	{
		// Disable 256-byte fetch after storing the current value.
		ppdev->DriverData.dwCONTROL2Save = LLDR_SZ(grCONTROL2);
		LL16(grCONTROL2, ppdev->DriverData.dwCONTROL2Save & ~0x0010);
	}
}
#endif

/****************************************************************************
* FUNCTION NAME: DdLock
*
* DESCRIPTION:   This callback is invoked whenever a surface is about
*                to be directly accessed by the user. This is where you
*                need to make sure that a surface can be safely accessed
*                by the user.
*                If your memory cannot be accessed while in accelerator
*                mode, you should take either take the card out of
*                accelerator mode or else return DDERR_SURFACEBUSY
*                If someone is accessing a surface that was just flipped
*                away from, make sure that the old surface (what was the
*                primary) has finished being displayed.
*                (Based on Laguna Win95 DirectDraw code)
****************************************************************************/
DWORD DdLock(PDD_LOCKDATA lpLock)
{
#ifdef RDRAM_8BIT
  RECTL SrcRectl;
#endif

  DRIVERDATA* pDriverData;
  PDEV*       ppdev;
  HRESULT     ddrval;
  DWORD       tmp;


  DISPDBG((DBGLVL, "DDraw - DdLock\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  ppdev = (PDEV*) lpLock->lpDD->dhpdev;
  pDriverData = (DRIVERDATA*) &ppdev->DriverData;

  SYNC_W_3D(ppdev);

#if DRIVER_5465 && defined(OVERLAY)
  if (DDSCAPS_OVERLAY & lpLock->lpDDSurface->ddsCaps.dwCaps)
  {
    ppdev->dwDDLinearCnt++;
    return pDriverData->OverlayTable.pfnLock(ppdev, lpLock);
  }
#endif

#ifdef RDRAM_8BIT
  if (lpLock->lpDDSurface->lpGbl->ddpfSurface.dwFlags & DDPF_FOURCC)
  {
     if (lpLock->bHasRect)
        SrcRectl = lpLock->rArea;
     else
     {
        tmp = lpLock->lpDDSurface->lpGbl->fpVidMem;
        SrcRectl.top  = cvlxy(ppdev->lDeltaScreen, tmp, BYTESPERPIXEL);

        SrcRectl.left = SrcRectl.top & 0xFFFF;
        SrcRectl.top = (SrcRectl.top >> 16) & 0xFFFF;
        SrcRectl.bottom = SrcRectl.top + lpLock->lpDDSurface->lpGbl->wHeight;
        SrcRectl.right = SrcRectl.left + lpLock->lpDDSurface->lpGbl->wWidth;
     };

    ppdev->offscr_YUV.nInUse = TRUE;
    ppdev->offscr_YUV.SrcRect = SrcRectl;

	 ppdev->offscr_YUV.ratio = 0;
	 lpLock->lpDDSurface->lpGbl->dwReserved1 = 0;
  };
#endif

  // get the monitor frequency after a mode reset
  if (pDriverData->fReset)
  {
     vGetDisplayDuration(&ppdev->flipRecord);
     pDriverData->fReset = FALSE;
  };

  // Check to see if any pending physical flip has occurred.
  // Don't allow a lock if a blt is in progress:
  ddrval = vUpdateFlipStatus(&ppdev->flipRecord,
                             lpLock->lpDDSurface->lpGbl->fpVidMem);

  if (ddrval != DD_OK)
  {
     lpLock->ddRVal = DDERR_WASSTILLDRAWING;
     return(DDHAL_DRIVER_HANDLED);
  };

  // don't allow a lock if a blt is in progress
  // (only do this if your hardware requires it)
  // Note: GD5462 requires it. Blitter and screen
  // access are not otherwise synchronized.
  if ((ppdev->dwDDLinearCnt == 0) && (DrawEngineBusy(pDriverData)))
  {
     lpLock->ddRVal = DDERR_WASSTILLDRAWING;
     return DDHAL_DRIVER_HANDLED;
  };

  // Reference count it, just for the heck of it:
  ppdev->dwDDLinearCnt++;

  return(DDHAL_DRIVER_NOTHANDLED);

} // Lock


/****************************************************************************
* FUNCTION NAME: DdUnlock
*
* DESCRIPTION:
****************************************************************************/
DWORD DdUnlock(PDD_UNLOCKDATA lpUnlock)
{
  PDEV* ppdev = (PDEV*) lpUnlock->lpDD->dhpdev;

  DISPDBG((DBGLVL, "DDraw - DdUnlock\n"));

#if DRIVER_5465 && defined(OVERLAY)
  if (DDSCAPS_OVERLAY & lpUnlock->lpDDSurface->ddsCaps.dwCaps)
    ppdev->DriverData.OverlayTable.pfnUnlock(ppdev,lpUnlock);
#endif

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  ppdev->dwDDLinearCnt--;

  return DDHAL_DRIVER_NOTHANDLED;

} // Unlock


/****************************************************************************
* FUNCTION NAME: CanCreateSurface
*
* DESCRIPTION:
*                (Based on Laguna Win95 DirectDraw code)
****************************************************************************/
DWORD CanCreateSurface (PDD_CANCREATESURFACEDATA lpInput)
{
  DRIVERDATA* pDriverData;
  PDEV*       ppdev;

  DISPDBG((DBGLVL, "DDraw - CanCreateSurface\n"));

  #ifdef DBGBRK
    DBGBREAKPOINT();
  #endif

  ppdev = (PDEV*) lpInput->lpDD->dhpdev;
  pDriverData = (DRIVERDATA*) &ppdev->DriverData;

  // First check for overlay surfaces
  if (lpInput->lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
  {
    #if DRIVER_5465 && defined(OVERLAY)
        if (DDSCAPS_OVERLAY & lpInput->lpDDSurfaceDesc->ddsCaps.dwCaps)
        {
            DWORD   dwFourCC;
            DWORD   dwBitCount;
            HRESULT hr;

            if (lpInput->bIsDifferentPixelFormat)
            {
                GetFormatInfo(&(lpInput->lpDDSurfaceDesc->ddpfPixelFormat),
                            &dwFourCC, &dwBitCount);
            }
            else
            {
                dwBitCount = BITSPERPIXEL;
                if (16 == dwBitCount)
                dwFourCC = BI_BITFIELDS;
                else
                dwFourCC = BI_RGB;
            }

            hr = pDriverData->OverlayTable.pfnCanCreateSurface(ppdev,dwFourCC,dwBitCount);
            if (DD_OK != hr)
            {
                lpInput->ddRVal = hr;
                return DDHAL_DRIVER_HANDLED;
            }
        }
    #else
        lpInput->ddRVal = DDERR_NOOVERLAYHW;;
        return (DDHAL_DRIVER_HANDLED);
    #endif
  }
  else if (lpInput->bIsDifferentPixelFormat)
  {
    // Next check for formats that don't match the primary surface.
    LPDDPIXELFORMAT lpFormat = &lpInput->lpDDSurfaceDesc->ddpfPixelFormat;

    if (lpFormat->dwFlags & DDPF_FOURCC)
    {
        // YUV422 surface
        if (lpFormat->dwFourCC == FOURCC_UYVY)
        {
            #if DRIVER_5465
                if (ppdev->iBitmapFormat == BMF_8BPP)
                    lpInput->ddRVal = DDERR_INVALIDPIXELFORMAT;
                else
                    lpInput->ddRVal = DD_OK;

                return (DDHAL_DRIVER_HANDLED);
                
            #else // 5462 and 5464 driver
                #if _WIN32_WINNT >= 0x0500
                    // For NT5 do not allow any YUV surfaces that are not
                    // overlays.
                    ;
                #else // NT4
                    // if we have nine bit RDRAMs then surface creation is okay
                    if (TRUE == pDriverData->fNineBitRDRAMS)
                    {
                        lpInput->ddRVal = DD_OK;
                        return (DDHAL_DRIVER_HANDLED);
                    }

                    // if we have eight bit RDRAMs then see if already
                    // have a YUV422 surface
                    else if (FALSE == ppdev->offscr_YUV.nInUse)
                    {
                        lpInput->ddRVal = DD_OK;
                        return (DDHAL_DRIVER_HANDLED);
                    };
                #endif
            #endif  // DRIVER_5465
        }; // endif (lpFormat->dwFourCC == FOURCC_UYVY)
    }
    else
    {
        // support RGB565 with RGB8 primary surface !!!
    };  // endif (lpFormat->dwFlags & DDPF_FOURCC)

    lpInput->ddRVal = DDERR_INVALIDPIXELFORMAT;

    return (DDHAL_DRIVER_HANDLED);
  }; // endif (lpInput->lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_OVERLAY)

  lpInput->ddRVal = DD_OK;

  return (DDHAL_DRIVER_HANDLED);
} // CanCreateSurface


/****************************************************************************
* FUNCTION NAME: InsertInDDOFSQ()
*
* DESCRIPTION:   Insert the handle into the DD Offscreen memory queue.
****************************************************************************/
void InsertInDDOFSQ(PPDEV  ppdev, DDOFM *hdl)
{
  hdl->prevhdl = NULL;

  if (ppdev->DDOffScnMemQ == NULL)
  {
    hdl->nexthdl = NULL;
    ppdev->DDOffScnMemQ = hdl;
  }
  else
  {
    ppdev->DDOffScnMemQ->prevhdl = hdl;
    hdl->nexthdl = ppdev->DDOffScnMemQ;
    ppdev->DDOffScnMemQ = hdl;
  };

} // InsertInDDOFSQ()



/****************************************************************************
* FUNCTION NAME: RemoveFrmDDOFSQ()
*
* DESCRIPTION:   Remove the handle from the DD Offscreen memory queue.
****************************************************************************/
BOOL RemoveFrmDDOFSQ(PPDEV  ppdev, DDOFM *hdl)
{
  DDOFM  *prvpds, *nxtpds;
  DDOFM  *pds;
  BOOL   fndflg;


  // Validate the release block
  fndflg = FALSE;
  pds = ppdev->DDOffScnMemQ;
  while (pds != 0)
  {
    if (hdl == pds)
    {
       fndflg = TRUE;
       break;
    };

    // Next free block
    pds = pds->nexthdl;
  }; // end while

  // Return if it is an invalid handle
  if (!fndflg)
     return (FALSE);

  prvpds = hdl->prevhdl;
  nxtpds = hdl->nexthdl;

  if (hdl == ppdev->DDOffScnMemQ)
  {
    ppdev->DDOffScnMemQ = nxtpds;

    if (nxtpds != 0)
       nxtpds->prevhdl = NULL;
  }
  else
  {
    if (nxtpds != NULL)
       nxtpds->prevhdl = prvpds;

    if (prvpds != NULL)
       prvpds->nexthdl = nxtpds;
  };

  // Free allocated DDOFM structure from host memory
  MEMORY_FREE(hdl);

  return (TRUE);
} // RemoveFrmDDOFSQ()



/****************************************************************************
* FUNCTION NAME: CreateSurface
*
* DESCRIPTION:
*                (Based on Laguna Win95 DirectDraw code)
****************************************************************************/
DWORD CreateSurface (PDD_CREATESURFACEDATA lpInput)
{
  BOOL        puntflag;
  BOOL        bYUVsurf;
#if DRIVER_5465 && defined(OVERLAY)
  BOOL        bOverlaySurf;
#endif  // #if DRIVER_5465 && defined(OVERLAY)
  DRIVERDATA* pDriverData;
  PDEV*       ppdev;
  LPDDSURFACEDESC lpDDSurfaceDesc = lpInput->lpDDSurfaceDesc;
  LPDDPIXELFORMAT lpFormat = &lpInput->lpDDSurfaceDesc->ddpfPixelFormat;
  DWORD		  dwPitch = 0;

  DISPDBG((DBGLVL, "DDraw - CreateSurface\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  ppdev = (PDEV*) lpInput->lpDD->dhpdev;
  pDriverData = (DRIVERDATA*) &ppdev->DriverData;

  bYUVsurf = FALSE;
#if DRIVER_5465 && defined(OVERLAY)
  bOverlaySurf = FALSE;
#endif  // #if DRIVER_5465 && defined(OVERLAY)

#if DRIVER_5465

#ifdef ALLOC_IN_CREATESURFACE
{ // Support for 5465

  PDD_SURFACE_LOCAL  *lplpSurface;
  SIZEL   sizl;
  OFMHDL  *hdl;
  DDOFM   *pds;
  DWORD   i;

#if DRIVER_5465 && defined(OVERLAY)
  DWORD             dwBitCount;
  DWORD             dwFourCC;

  // check for overlay surface
  if (lpDDSurfaceDesc->ddsCaps.dwCaps & (  DDSCAPS_OVERLAY
#if DDRAW_COMPAT >= 50
                                         | DDSCAPS_VIDEOPORT
#endif
                                        ))
  {
    if (lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT)
    {
      GetFormatInfo(&(lpInput->lpDDSurfaceDesc->ddpfPixelFormat),
                    &dwFourCC, &dwBitCount);
    }
    else
    {
      dwFourCC = 0;
      dwBitCount = BITSPERPIXEL;
    }

#if DDRAW_COMPAT >= 50
    if((CL_GD5465 == pDriverData->dwLgVenDevID)
       && (DDSCAPS_VIDEOPORT & lpDDSurfaceDesc->ddsCaps.dwCaps))
    {
      if((lpDDSurfaceDesc->dwWidth * dwBitCount >> 3) >= 2048 )
      {
        //Surface is too wide for video port
        lpInput->ddRVal = DDERR_TOOBIGWIDTH;
        return DDHAL_DRIVER_HANDLED;
      }
    }
#endif

    bOverlaySurf = TRUE;

  } // end overlay surface handler
  else
#endif  // #if DRIVER_5465 && defined(OVERLAY)

  if (lpInput->lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT)
  {
     // Specify the block size for non-RGB surfaces
     if (lpFormat->dwFlags & DDPF_FOURCC)
     {
        // YUV422 surface
        if (lpFormat->dwFourCC == FOURCC_UYVY)
        {
           bYUVsurf = TRUE;
        }; // endif (lpFormat->dwFourCC == FOURCC_UYVY)
     };  // endif (lpFormat->dwFlags & DDPF_FOURCC)
  }  // endif (lpInput->lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT)

  // Not support 8BPP YUV surface
  if (
#if DRIVER_5465 && defined(OVERLAY)
      (!bOverlaySurf) &&
#endif  // #if DRIVER_5465 && defined(OVERLAY)
      ((bYUVsurf) && (8 == BITSPERPIXEL)))
  {
     lpInput->ddRVal = DDERR_INVALIDPIXELFORMAT;
     return DDHAL_DRIVER_HANDLED;
  };  // endif (8 == BITSPERPIXEL)

  lplpSurface = lpInput->lplpSList;
  for (i = 0; i < lpInput->dwSCnt; i++)
  {
    PDD_SURFACE_LOCAL lpSurface = *lplpSurface;

    sizl.cx = lpSurface->lpGbl->wWidth;
    sizl.cy = lpSurface->lpGbl->wHeight;

#if 1 // PC98
	if (   (lpDDSurfaceDesc->dwFlags == (DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH))
		&& (lpDDSurfaceDesc->ddsCaps.dwCaps == DDSCAPS_VIDEOMEMORY)
		&& (lpDDSurfaceDesc->dwHeight == 32 && lpDDSurfaceDesc->dwWidth == 32)
		&& (sizl.cx == 32 && sizl.cy == 32)
		&& (lpInput->dwSCnt == 1)
	)
	{
		sizl.cx = min(32 * 32, ppdev->lDeltaScreen / ppdev->iBytesPerPixel);
		sizl.cy = (32 * 32) / sizl.cx;
		if ( (sizl.cx * sizl.cy) < (32 * 32) )
		{
			sizl.cy++;
		}
		dwPitch = 32 * ppdev->iBytesPerPixel;
	}
#endif

#if DRIVER_5465 && defined(OVERLAY)
    // Adjust the overlay surface request size with pixel format 
    if (bOverlaySurf)
    {
       unsigned long  OvlyBPP;

       if (bYUVsurf)
          OvlyBPP = lpSurface->lpGbl->ddpfSurface.dwYUVBitCount/8;
       else
          OvlyBPP = lpSurface->lpGbl->ddpfSurface.dwRGBBitCount/8;

       if (OvlyBPP > BYTESPERPIXEL)
          sizl.cx = (sizl.cx * OvlyBPP) / BYTESPERPIXEL;
    };
#endif  // #if DRIVER_5465 && defined(OVERLAY)

    // At certain modes (eg 1280x1024x24), When you runs MOV or AVI from
    // desktop, the DD CreateSurface has to punt the request back to DD 
    // due to no offscreen memmory available. When you hit ALT-ENTER to
    // go full screen, the appl swithces to mode (320x240x8 or 320x200x8),
    // create DD surfaces and then directly write to the DD surfaces.
    // Unfortunely, in those modes the pitch is 640 but the appl assumes
    // the pitch is 320 and we got half screen of the imagine.
    //
    // To fix the problem, just fails the create surface for those 
    // particule request.
    //
    puntflag = FALSE;
    if (ppdev->iBytesPerPixel == 1)
    {
       if ((ppdev->cxScreen == 320) && (sizl.cx == 320))
       {
          if (((ppdev->cyScreen == 240) && (sizl.cy == 240)) ||
              ((ppdev->cyScreen == 200) && (sizl.cy == 200)))
          {
             // Punt the create surface cause FlipCube FPS exceeds the
             // refresh rate.
             // So in order to bypass the above problem, it is looking for
             // bPrevModeDDOutOfVideoMem to be set when create surface fails
             // due to out of video memory in the previous mode before
             // punting the request.
             if (ppdev->bPrevModeDDOutOfVideoMem)
                puntflag = TRUE;
          };
       };
    };

    if (!puntflag)
    {
#if DRIVER_5465 && defined(OVERLAY)
		if (bOverlaySurf)
		{
			hdl = AllocOffScnMem(ppdev, &sizl, EIGHT_BYTES_ALIGN, NULL);
		}
		else
#endif  // #if DRIVER_5465 && defined(OVERLAY)
			hdl = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);

#if 1 // PC98
		if (!bOverlaySurf)
#endif
       // Somehow when allocate the bottom of the offscreen memory to
       // DirectDraw, it hangs the DirectDraw.
       // The following is temporary patch fix for the problem
       {
         BOOL   gotit;
         ULONG  val;
         ULONG  fpvidmem;

         val = ppdev->lTotalMem - 0x20000;
         gotit = FALSE;
         while ((!gotit) && (hdl != NULL))
         {
            fpvidmem  = (hdl->aligned_y * ppdev->lDeltaScreen) + hdl->aligned_x;

            if (fpvidmem > val)
            {
               pds = (DDOFM *) MEM_ALLOC (FL_ZERO_MEMORY, sizeof(DDOFM), ALLOC_TAG);
               if (pds==NULL) 
               {
                    FreeOffScnMem(ppdev, hdl);
                    lpInput->ddRVal = DDERR_OUTOFMEMORY;
                    return DDHAL_DRIVER_NOTHANDLED;
               }
               pds->prevhdl = 0;
               pds->nexthdl = 0;
               pds->phdl = hdl;

               InsertInDDOFSQ(ppdev, pds);
               hdl = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);
            }
            else
            {
               gotit = TRUE;
            };
         };  // endwhile
       }

       lpSurface->dwReserved1 = 0;

       if (hdl != NULL)
       {
#ifdef WINNT_VER40
          if ((pds = (DDOFM *) MEM_ALLOC (FL_ZERO_MEMORY, sizeof(DDOFM), ALLOC_TAG)) != NULL)
#else
          if ((pds = (DDOFM *) MEM_ALLOC (LPTR, sizeof(DDOFM))) != NULL)
#endif
          {
             ppdev->bPrevModeDDOutOfVideoMem = FALSE;

             // If pixel format is difference from FB, set the flag
             if (lpInput->lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT)
             {
                lpSurface->dwFlags |= DDRAWISURF_HASPIXELFORMAT;
             };

//           lpSurface->lpGbl->fpVidMem = DDHAL_PLEASEALLOC_BLOCKSIZE;
             if (bYUVsurf)
             {
                lpSurface->lpGbl->ddpfSurface.dwYUVBitCount = 16;
                lpSurface->lpGbl->ddpfSurface.dwYBitMask = (DWORD) -1;
                lpSurface->lpGbl->ddpfSurface.dwUBitMask = (DWORD) -1;
                lpSurface->lpGbl->ddpfSurface.dwVBitMask = (DWORD) -1;
                lpSurface->lpGbl->dwBlockSizeX = lpSurface->lpGbl->wWidth;
                lpSurface->lpGbl->dwBlockSizeY = lpSurface->lpGbl->wHeight;
                lpSurface->dwFlags |= DDRAWISURF_HASPIXELFORMAT;
             }; // endif (bYUVsurf)

#if DRIVER_5465 && defined(OVERLAY)
             if (bOverlaySurf)
             {
#if DDRAW_COMPAT >= 50
               if (lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
#endif
               {
                 HRESULT hResult;

#if 1 // PDR#11184
// Finally... When overlays are turned on, 256-byte fetch should be turned off.
					if (pDriverData->dwOverlayCount++ == 0)
					{
						Set256ByteFetch(ppdev, FALSE);
					}
#endif

                 lpSurface->dwReserved1 = (DWORD) pds;
                 hResult = pDriverData->OverlayTable.pfnCreateSurface(ppdev,
                                                                      lpSurface,
                                                                      dwFourCC);

                 if (DD_OK != hResult)
                 {
					#if 1 // PDR#11184
					// Decrement overlay counter and maybe turn 256-byte fetch
					// back on.
					if (--pDriverData->dwOverlayCount == 0)
					{
						Set256ByteFetch(ppdev, TRUE);
					}
					#endif

                   // Free the allocated offscreen memory
                   FreeOffScnMem(ppdev, hdl);

                   // Free allocated DDOFM structure from host memory
            	    MEMORY_FREE(pds);

                   lpSurface->dwReserved1 = 0;

                   lpInput->ddRVal = hResult;
                   return DDHAL_DRIVER_HANDLED;
                 }
               }

// don't need this for NT yet
#if 0
               // if the surface width is larger than the display pitch, or
               // its a 5465, and a videoport surface wider than 2048 bytes or
               // its a CLPL surface
               // then convert to a linear allocation
               //
               // prior to DX5 we never even get called for surfaces wider than 
               // the display pitch

               if (   (FOURCC_YUVPLANAR == dwFourCC)
#if DDRAW_COMPAT >= 50
                   || (lpSurface->lpGbl->dwBlockSizeX > pDriverData->ScreenPitch)
                   || (   (CL_GD5465 == pDriverData->dwLgVenDevID)
                       && (DDSCAPS_VIDEOPORT & lpDDSurfaceDesc->ddsCaps.dwCaps)
                       && (2048 <= pDriverData->ScreenPitch)
                      )
#endif
                  )
               {
                 // fake a linear space in rectangular memory
                 LP_SURFACE_DATA   lpSurfaceData = (LP_SURFACE_DATA)(lpSurface->dwReserved1);
                 DWORD             dwTotalBytes;
                 DWORD             dwNumScanLines;

                 lpSurfaceData->dwOverlayFlags |= FLG_LINEAR;

                 // CLPL surfaces need 3/4 of the space an equivalent size
                 // YUV422 surface would need, the space allocated for the
                 // Y values is the width * height and the space for the UV
                 // interleaved values is half again as much.  Pad the Y
                 // region so the UV interleaved data is on a qword boundary
                 // in aperture 0
                 if (FOURCC_YUVPLANAR == dwFourCC)
                 {
                   // compute space needed for Y values
                   dwTotalBytes = ((lpSurface->lpGbl->wHeight * lpSurface->lpGbl->wWidth) + 7) & ~7;

                   // add on space for UV interleaved values
                   dwTotalBytes += dwTotalBytes / 2;

                   // CLPL surfaces have pitch same as width
                   lpSurface->lpGbl->lPitch = lpSurface->lpGbl->wWidth;
                 }
                 // the normal case
                 else
                 {
                   dwTotalBytes = lpSurface->lpGbl->dwBlockSizeY *
                                  lpSurface->lpGbl->dwBlockSizeX;

                   lpSurface->lpGbl->lPitch = lpSurface->lpGbl->dwBlockSizeX;
                 }

                 dwNumScanLines = (dwTotalBytes + pDriverData->ScreenPitch - 1) /
                                  pDriverData->ScreenPitch;

                 lpSurface->lpGbl->dwBlockSizeY = dwNumScanLines;
                 lpSurface->lpGbl->dwBlockSizeX = pDriverData->ScreenPitch;

                 if (! pDriverData->fWeAllocDDSurfaces)
                 {
                   LOAD_THE_STILL(lpSurface->lpGbl->dwBlockSizeX,
                                  lpSurface->lpGbl->dwBlockSizeY);
                 }
                 lpSurface->lpGbl->fpVidMem = DDHAL_PLEASEALLOC_BLOCKSIZE;
               }
#endif  // if 0
             };  // endif (bOverlaySurf)
#endif  // #if DRIVER_5465 && defined(OVERLAY)

             pds->prevhdl = 0;
             pds->nexthdl = 0;
             pds->phdl = hdl;

             InsertInDDOFSQ(ppdev, pds);

             lpSurface->lpGbl->fpVidMem  = (hdl->aligned_y * ppdev->lDeltaScreen) +
                                           hdl->aligned_x;

             lpSurface->dwReserved1 = (DWORD) pds ;
             lpSurface->lpGbl->xHint = hdl->aligned_x/ppdev->iBytesPerPixel;
             lpSurface->lpGbl->yHint = hdl->aligned_y;
#if 1 // PC98
			if (dwPitch)
			{
				lpSurface->lpGbl->lPitch = dwPitch;
			}
			else
#endif
             lpSurface->lpGbl->lPitch = ppdev->lDeltaScreen;

#if 1 // PC98
			if (dwPitch)
			{
				lpDDSurfaceDesc->lPitch = dwPitch;
			}
			else
#endif
             lpDDSurfaceDesc->lPitch   = ppdev->lDeltaScreen;
             lpDDSurfaceDesc->dwFlags |= DDSD_PITCH;

             // We handled the creation entirely ourselves, so we have to
             // set the return code and return DDHAL_DRIVER_HANDLED:
             lpInput->ddRVal = DD_OK;
          }
          else
          {
             FreeOffScnMem(ppdev, hdl);
             lpInput->ddRVal = DDERR_OUTOFMEMORY;
             return DDHAL_DRIVER_NOTHANDLED;
          };
       }
       else
       {
          ppdev->bPrevModeDDOutOfVideoMem = TRUE;

          lpInput->ddRVal = DDERR_OUTOFVIDEOMEMORY;
          return DDHAL_DRIVER_NOTHANDLED;

//          lpSurface->lpGbl->lPitch = (ppdev->iBytesPerPixel * sizl.cx + 3) & ~3;
//          lpSurface->lpGbl->dwUserMemSize = lpSurface->lpGbl->lPitch * sizl.cy;

//          if (bYUVsurf)
//             lpSurface->lpGbl->fpVidMem |= DDHAL_PLEASEALLOC_USERMEM;
       };  // if (hdl != NULL)
    }  // endif (puntflag)

    lplpSurface++;
  };  // endfor

  if (puntflag)
  {
     lpInput->ddRVal = DDERR_GENERIC;
     return DDHAL_DRIVER_HANDLED;
  };

  if (hdl != NULL)
  {
     lpInput->ddRVal = DD_OK;
     return DDHAL_DRIVER_HANDLED;
  }
  else
  {
     return DDHAL_DRIVER_NOTHANDLED;
  };
};  //  // Support for 5465

#endif // ALLOC_IN_CREATESURFACE

#else
{ // Support for 5462 or 5464

  // Do nothing except fill in the block size for YUV surfaces.
  // We tag and count the video surfaces in Blt32.
  if (lpInput->lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT)
  {
     // only support alternate pixel format in 8 & 16 bpp frame buffers
     if ((8 != BITSPERPIXEL) && (16 != BITSPERPIXEL))
     {
        lpInput->ddRVal = DDERR_INVALIDPIXELFORMAT;
        return DDHAL_DRIVER_HANDLED;
     };

     // Specify the block size for non-RGB surfaces
     if (lpFormat->dwFlags & DDPF_FOURCC)
     {
        #if _WIN32_WINNT >= 0x0500
           // For NT5, do not allow any YUV surfaces for 5462 and 5464
           lpInput->ddRVal = DDERR_INVALIDPIXELFORMAT;
           return DDHAL_DRIVER_HANDLED;
        #endif

        // YUV422 surface
        if (lpFormat->dwFourCC == FOURCC_UYVY)
        {
           PDD_SURFACE_LOCAL  *lplpSurface;
           unsigned int i;

           GRAB_VIDEO_FORMAT_SEMAPHORE(&(pDriverData->VideoSemaphore));
           if (0 == pDriverData->NumVideoSurfaces)
           {
              // no video surfaces so we can create anu format we want
              pDriverData->NumVideoSurfaces += (WORD)lpInput->dwSCnt;
              pDriverData->CurrentVideoFormat &= 0xFF00;

              pDriverData->CurrentVideoFormat |= FMT_VID_16BPP | FMT_VID_YUV422;

              if (2 == BYTESPERPIXEL)
              {
                 pDriverData->CurrentVideoFormat |= FMT_VID_GAMMA;
                 SetGamma(ppdev, pDriverData);
              };

              ppdev->grFORMAT = (ppdev->grFORMAT & 0xFF00) |
                                (pDriverData->CurrentVideoFormat & 0x00FF);

              LL16(grFormat, ppdev->grFORMAT);

              if (TRUE == pDriverData->fNineBitRDRAMS)
              {
                 LL8(grStop_BLT_2, ENABLE_VIDEO_FORMAT);
                 LL8(grExternal_Overlay, ENABLE_RAMBUS_9TH_BIT);
              }
              else // 8 bit RDRAMs
              {
                 LL8(grStart_BLT_2, ENABLE_VIDEO_FORMAT | ENABLE_VIDEO_WINDOW);
                 LL8(grStop_BLT_2,  ENABLE_VIDEO_FORMAT | ENABLE_VIDEO_WINDOW);
              };
           }
           else
           {
              if ((FMT_VID_16BPP | FMT_VID_YUV422) == pDriverData->CurrentVideoFormat)
              {
                 pDriverData->NumVideoSurfaces += (WORD)lpInput->dwSCnt;
              }
              else
              {
                 UNGRAB_VIDEO_FORMAT_SEMAPHORE(&(pDriverData->VideoSemaphore));
                 lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
                 return DDHAL_DRIVER_HANDLED;
              };
           };  // endif (0 == pDriverData->NumVideoSurfaces)

           UNGRAB_VIDEO_FORMAT_SEMAPHORE(&(pDriverData->VideoSemaphore));

           SET_DRVSEM_YUV();
           ppdev->bYUVSurfaceOn = TRUE;

           bYUVsurf = TRUE;

           // They may have specified multiple surfaces
           lplpSurface = lpInput->lplpSList;
           for (i = 0; i < lpInput->dwSCnt; i++)
           {
             PDD_SURFACE_LOCAL lpSurface = *lplpSurface;

             lpSurface->lpGbl->ddpfSurface.dwYUVBitCount = 16;
             lpSurface->lpGbl->ddpfSurface.dwYBitMask = (DWORD) -1;
             lpSurface->lpGbl->ddpfSurface.dwUBitMask = (DWORD) -1;
             lpSurface->lpGbl->ddpfSurface.dwVBitMask = (DWORD) -1;
             lpSurface->lpGbl->lPitch = ppdev->lDeltaScreen;

             if (CL_GD5462 == ppdev->dwLgDevID)
                lpSurface->lpGbl->dwBlockSizeX = lpSurface->lpGbl->wWidth << 1;
             else
                lpSurface->lpGbl->dwBlockSizeX = lpSurface->lpGbl->wWidth * 3;

             lpSurface->lpGbl->dwBlockSizeY = lpSurface->lpGbl->wHeight;

             lpSurface->lpGbl->fpVidMem = DDHAL_PLEASEALLOC_BLOCKSIZE;

             lplpSurface++;
           };  // endfor
        }; // endif (lpFormat->dwFourCC == FOURCC_UYVY)
     };  // endif (lpFormat->dwFlags & DDPF_FOURCC)
  }  // endif (lpInput->lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT)

#ifdef ALLOC_IN_CREATESURFACE
  {
    PDD_SURFACE_LOCAL  *lplpSurface;
    SIZEL   sizl;
    OFMHDL  *hdl;
    DDOFM   *pds;
    DWORD   i;

    lplpSurface = lpInput->lplpSList;
    for (i = 0; i < lpInput->dwSCnt; i++)
    {
      PDD_SURFACE_LOCAL lpSurface = *lplpSurface;

      if (bYUVsurf)
      {
         sizl.cx = lpSurface->lpGbl->dwBlockSizeX/ppdev->iBytesPerPixel;
         sizl.cy = lpSurface->lpGbl->dwBlockSizeY;
         lpSurface->dwFlags |= DDRAWISURF_HASPIXELFORMAT;
      }
      else
      {
         sizl.cx = lpSurface->lpGbl->wWidth;
         sizl.cy = lpSurface->lpGbl->wHeight;
      };

      hdl = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);

      // Somehow when allocate the bottom of the offscreen memory to
      // DirectDraw, it hangs the DirectDraw.
      // The following is temporary patch fix for the problem
      {
        BOOL   gotit;
        ULONG  val;
        ULONG  fpvidmem;

        val = ppdev->lTotalMem - 0x20000;
        gotit = FALSE;
        while ((!gotit) && (hdl != NULL))
        {
           fpvidmem  = (hdl->aligned_y * ppdev->lDeltaScreen) + hdl->aligned_x;

           if (fpvidmem > val)
           {
              pds = (DDOFM *) MEM_ALLOC (FL_ZERO_MEMORY, sizeof(DDOFM), ALLOC_TAG);
              if (pds==NULL) 
              {
                  FreeOffScnMem(ppdev, hdl);
                  lpInput->ddRVal = DDERR_OUTOFMEMORY;
                  return DDHAL_DRIVER_NOTHANDLED;
              }
              pds->prevhdl = 0;
              pds->nexthdl = 0;
              pds->phdl = hdl;

              InsertInDDOFSQ(ppdev, pds);
              hdl = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);
           }
           else
           {
              gotit = TRUE;
           };
        };  // endwhile
      }

      lpSurface->dwReserved1 = 0;

      if (hdl != NULL)
      {
#ifdef WINNT_VER40
         if ((pds = (DDOFM *) MEM_ALLOC (FL_ZERO_MEMORY, sizeof(DDOFM), ALLOC_TAG)) != NULL)
#else
         if ((pds = (DDOFM *) MEM_ALLOC (LPTR, sizeof(DDOFM))) != NULL)
#endif
         {
            pds->prevhdl = 0;
            pds->nexthdl = 0;
            pds->phdl = hdl;

            InsertInDDOFSQ(ppdev, pds);

            lpSurface->lpGbl->fpVidMem  = (hdl->aligned_y * ppdev->lDeltaScreen) +
                                          hdl->aligned_x;

            lpSurface->dwReserved1 = (DWORD) pds ;
            lpSurface->lpGbl->xHint = hdl->aligned_x/ppdev->iBytesPerPixel;
            lpSurface->lpGbl->yHint = hdl->aligned_y;
            lpSurface->lpGbl->lPitch = ppdev->lDeltaScreen;

            lpDDSurfaceDesc->lPitch   = ppdev->lDeltaScreen;
            lpDDSurfaceDesc->dwFlags |= DDSD_PITCH;

            // We handled the creation entirely ourselves, so we have to
            // set the return code and return DDHAL_DRIVER_HANDLED:
            lpInput->ddRVal = DD_OK;
         }
         else
         {
            FreeOffScnMem(ppdev, hdl);
         };
      };  // if (hdl != NULL)

      lplpSurface++;
    };  // endfor

    if (hdl != NULL)
       return DDHAL_DRIVER_HANDLED;
    else
       return DDHAL_DRIVER_NOTHANDLED;
  };
#endif // ALLOC_IN_CREATESURFACE
} // Support for 5462 or 5464

#endif  // DRIVER_5465

  return DDHAL_DRIVER_NOTHANDLED;
} // CreateSurface


/****************************************************************************
* FUNCTION NAME: DestroySurface
*
* DESCRIPTION:
*                (Based on Laguna Win95 DirectDraw code)
****************************************************************************/
DWORD DestroySurface (PDD_DESTROYSURFACEDATA lpInput)
{
  PDD_SURFACE_LOCAL  lpLocalSurface;
  DRIVERDATA* pDriverData;
  PDEV*       ppdev;
  DDOFM       *hdl;

  DISPDBG((DBGLVL, "DDraw - DestroySurface\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  ppdev = (PDEV*) lpInput->lpDD->dhpdev;
  pDriverData = (DRIVERDATA*) &ppdev->DriverData;
  lpLocalSurface = lpInput->lpDDSurface;

#if DRIVER_5465
{ // Support for 5465
#if DRIVER_5465 && defined(OVERLAY)
	// check for overlay surface
	if (lpInput->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
	{
		pDriverData->OverlayTable.pfnDestroySurface(ppdev,lpInput);
#if 1 // PDR#11184
		// Enable 256-byte fetch if the last overlay surface has been destroyed.
		if (--pDriverData->dwOverlayCount == 0)
		{
			Set256ByteFetch(ppdev, TRUE);
		}
#endif
	}

#endif
} // Support for 5465

#else
{ // Support for 5462 or 5464

  if (DDRAWISURF_HASPIXELFORMAT & lpInput->lpDDSurface->dwFlags)
  {
     LPDDPIXELFORMAT lpFormat = &lpInput->lpDDSurface->lpGbl->ddpfSurface;

     if (DDPF_FOURCC & lpFormat->dwFlags)
     {
        if (FOURCC_UYVY == lpFormat->dwFourCC)
        {
           GRAB_VIDEO_FORMAT_SEMAPHORE(&(pDriverData->VideoSemaphore));

           if (0 == --pDriverData->NumVideoSurfaces)
           {
              CLR_DRVSEM_YUV();

              // disable stuff if there's no more video windows
              pDriverData->CurrentVideoFormat = pDriverData->CurrentVideoFormat & 0xFF00;

              // These trash the video window left on screen
              //pDriverData->grFormat = pREG->grFormat & 0xFF00;
              //pDriverData->grStop_BLT_2 &= ~ENABLE_VIDEO_FORMAT;
              //pDriverData->grExternal_Overlay &= ~ENABLE_RAMBUS_9TH_BIT;
           }; // endif (0 == --pDriverData->NumVideoSurfaces)

           UNGRAB_VIDEO_FORMAT_SEMAPHORE(&(pDriverData->VideoSemaphore));

#ifdef RDRAM_8BIT
           if (FALSE == pDriverData->fNineBitRDRAMS)
           {
              // Need to Delete Rectangle and Clear Window
              ppdev->offscr_YUV.nInUse = FALSE;
              LL16(grX_Start_2, 0);
              LL16(grY_Start_2, 0);
              LL16(grX_End_2, 0);
              LL16(grY_End_2, 0);
           };
#endif
        }; // endif (FOURCC_UYVY == lpFormat->dwFourCC)
     };  // endif (DDPF_FOURCC & lpFormat->dwFlags)
  };  // endif (DDRAWISURF_HASPIXELFORMAT & lpInput->lpDDSurface->dwFlags)

} // Support for 5462 or 5464
#endif  // #endif DRIVER_5465


#ifdef ALLOC_IN_CREATESURFACE
  if (lpLocalSurface->dwReserved1 != 0)
  {
     hdl = (DDOFM *) lpLocalSurface->dwReserved1;
     FreeOffScnMem(ppdev, hdl->phdl);
     RemoveFrmDDOFSQ(ppdev, hdl);
     lpLocalSurface->dwReserved1 = 0;
  };

  lpInput->ddRVal = DD_OK;

  return DDHAL_DRIVER_HANDLED;
#endif // ALLOC_IN_CREATESURFACE

  return DDHAL_DRIVER_NOTHANDLED;

} // DestroySurface

#if DRIVER_5465 && defined(OVERLAY)
/***************************************************************************
*
* FUNCTION:     GetFormatInfo()
*
* DESCRIPTION:  This returns the FOURCC and the bit depth of the specified
*               format.  This is useful since DirectDraw has so many
*               different ways to determine the format.
*
****************************************************************************/

VOID
GetFormatInfo (LPDDPIXELFORMAT lpFormat, LPDWORD lpFourcc, LPDWORD lpBitCount)
{
  if (lpFormat->dwFlags & DDPF_FOURCC)
  {
    *lpFourcc = lpFormat->dwFourCC;
    if (lpFormat->dwFourCC == BI_RGB)
    {
      *lpBitCount = lpFormat->dwRGBBitCount;
#ifdef DEBUG
      if (lpFormat->dwRGBBitCount == 8)
      {
        DBG_MESSAGE(("Format: RGB 8"));
      }
      else if (lpFormat->dwRGBBitCount == 16)
      {
        DBG_MESSAGE(("Format: RGB 5:5:5"));
      }
#endif
    }
    else if (lpFormat->dwFourCC == BI_BITFIELDS)
    {
      if ((lpFormat->dwRGBBitCount != 16) ||
          (lpFormat->dwRBitMask != 0xf800) ||
          (lpFormat->dwGBitMask != 0x07e0) ||
          (lpFormat->dwBBitMask != 0x001f))
      {
        *lpFourcc = (DWORD) -1;
      }
      else
      {
        *lpBitCount = 16;
        DBG_MESSAGE(("Format: RGB 5:6:5"));
      }
    }
    else
    {
      lpFormat->dwRBitMask = (DWORD) -1;
      lpFormat->dwGBitMask = (DWORD) -1;
      lpFormat->dwBBitMask = (DWORD) -1;
      if (FOURCC_YUVPLANAR == lpFormat->dwFourCC)
      {
        *lpBitCount = 8;
        DBG_MESSAGE(("Format: CLPL"));
      }
      else
      {
        *lpBitCount = 16;
        DBG_MESSAGE(("Format: UYVY"));
      }
    }
  }
  else if (lpFormat->dwFlags & DDPF_RGB)
  {
    if (lpFormat->dwRGBBitCount == 8)
    {
      *lpFourcc = BI_RGB;
      DBG_MESSAGE(("Format: RGB 8"));
    }
    else if ((lpFormat->dwRGBBitCount == 16)  &&
             (lpFormat->dwRBitMask == 0xf800) &&
             (lpFormat->dwGBitMask == 0x07e0) &&
             (lpFormat->dwBBitMask == 0x001f))
    {
      *lpFourcc = BI_BITFIELDS;
      DBG_MESSAGE(("Format: RGB 5:6:5"));
    }
    else if ((lpFormat->dwRGBBitCount == 16)  &&
             (lpFormat->dwRBitMask == 0x7C00) &&
             (lpFormat->dwGBitMask == 0x03e0) &&
             (lpFormat->dwBBitMask == 0x001f))
    {
      *lpFourcc = BI_RGB;
      DBG_MESSAGE(("Format: RGB 5:5:5"));
    }
    else if (((lpFormat->dwRGBBitCount == 24) ||
              (lpFormat->dwRGBBitCount == 32))  &&
             (lpFormat->dwRBitMask == 0xff0000) &&
             (lpFormat->dwGBitMask == 0x00ff00) &&
             (lpFormat->dwBBitMask == 0x0000ff))
    {
      *lpFourcc = BI_RGB;
      DBG_MESSAGE(("Format: RGB 8:8:8"));
    }
    else
    {
      *lpFourcc = (DWORD) -1;
    }
    *lpBitCount = lpFormat->dwRGBBitCount;
  }
  else if (DDPF_PALETTEINDEXED4 & lpFormat->dwFlags)
  {
    *lpFourcc = (DWORD)-1;
    *lpBitCount = 4;
  }
  else if (DDPF_PALETTEINDEXED8 & lpFormat->dwFlags)
  {
    *lpFourcc = (DWORD)-1;
    *lpBitCount = 8;
  }
  else if (lpFormat->dwRGBBitCount == 16)
  {
    *lpFourcc = BI_RGB;
    *lpBitCount = lpFormat->dwRGBBitCount;    // always 16 for now.
  }
  else
  {
    *lpFourcc = (DWORD) -1;
    *lpBitCount = 0;
  }
}
#endif // DRIVER_5465 && OVERLAY

#endif // ! ver 3.51




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\dev2dev.c ===
/******************************Module*Header*******************************\
* Module Name: DEV2DEV.c
*
* Author: Noel VanHook
* 
* Purpose: Handle device to device BLTs. 
*
* Copyright (c) 1997 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/dev2dev.c  $
* 
*    Rev 1.11   Mar 04 1998 15:13:52   frido
* Added new shadow macros.
* 
*    Rev 1.10   Jan 22 1998 16:20:10   frido
* Added 16-bit striping code.
* 
*    Rev 1.9   Jan 21 1998 13:46:52   frido
* Fixed the striping code since this is really the first time we check it.
* 
*    Rev 1.8   Jan 20 1998 11:43:26   frido
* Guess what? Striping was not turned on!
* 
*    Rev 1.7   Dec 10 1997 13:32:12   frido
* Merged from 1.62 branch.
* 
*    Rev 1.6.1.2   Dec 05 1997 13:34:26   frido
* PDR#11043. When using a brush, striping should use pixels instead of
* bytes, so now there is an intelligent switcher in place.
* 
*    Rev 1.6.1.1   Nov 18 1997 15:14:56   frido
* Added striping for 24-bpp.
* 
*    Rev 1.6.1.0   Nov 10 1997 13:39:26   frido
* PDR#10893: Inside DoDeviceToDeviceWithXlate the source pointer
* was not updated after each access.
* 
*    Rev 1.6   Nov 04 1997 13:40:56   frido
* I removed a little too much code in DoDeviceToDevice. The result was
* a very slow screen-to-screen blits since everything was punted back to
* GDI.
* 
*    Rev 1.5   Nov 04 1997 09:49:18   frido
* Added COLOR_TRANSLATE switches around hardware color translation code.
* 
*    Rev 1.4   Nov 03 1997 15:20:06   frido
* Added REQUIRE macros.
* 
*    Rev 1.3   15 Oct 1997 12:03:00   noelv
* Pass rop code to CacheXlateTable().
* 
*    Rev 1.2   02 Oct 1997 09:48:22   noelv
* 
* Hardwre color translation only works with CC rop code.
* 
*    Rev 1.1   19 Feb 1997 13:14:22   noelv
* 
* Fixed LL_BLTEXT_XLATE()
* 
*    Rev 1.0   06 Feb 1997 10:35:48   noelv
* Initial revision.
*
\**************************************************************************/

#include "precomp.h"

#define DEV2DEV_DBG_LEVEL 0

//
// Set to 1 to stripe screen to screen operations along tile boundries.
// Set to 0 to do screen to screen operations in a few BLTs as possible.
//
// on the 62, 64 and 65 striping is faster than not striping.
//
#define STRIPE_SCR2SCR 1

//
// internal prototypes.
//
BOOL DoDeviceToDeviceWithXlate(
    SURFOBJ  *psoTrg,
    SURFOBJ  *psoSrc,
    ULONG    *pulXlate,
    RECTL    *prclTrg,
    POINTL   *pptlSrc,
    ULONG    ulDRAWBLTDEF
);





/*****************************************************************************\
 * DoDeviceToDevice
 *
 * This routine performs a ScreenToScreen, DeviceToScreen or ScreenToDevice
 * blit.  If there is a color translation table, we will attempt to use
 * the hardware color translator.  If we can't (or don't have one) we will
 * pass the call to DoDeviceToDeviceWithXlate, which will do the color
 * translation is software.
 *
 * On entry:    psoTrg          Pointer to target surface object.
 *              psoSrc          Pointer to source surface object.
 *              pxlo            Pointer to translation object.
 *              prclTrg         Destination rectangle.
 *              pptlSrc         Source offset.
 *              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                              The ROP and the brush flags.
\*****************************************************************************/
BOOL DoDeviceToDevice(
    SURFOBJ  *psoTrg,
    SURFOBJ  *psoSrc,
    XLATEOBJ *pxlo,
    RECTL    *prclTrg,
    POINTL   *pptlSrc,
    ULONG    ulDRAWBLTDEF
)
{
    POINTL ptlSrc, ptlDest;
    SIZEL  sizl;
    PPDEV  ppdev;
    LONG   tileSize, maxStripeWidth;
    ULONG* pulXlate;
	BOOL   fStripePixels;
	BOOL   fFirst = TRUE;

    //
    // Determine the source type and adjust the source offset.
    //
    if (psoSrc->iType == STYPE_DEVBITMAP)
    {
        // Source is a device bitmap.
        PDSURF pdsurf = (PDSURF) psoSrc->dhsurf;
        ptlSrc.x = pptlSrc->x + pdsurf->ptl.x;
        ptlSrc.y = pptlSrc->y + pdsurf->ptl.y;
        ppdev = pdsurf->ppdev;
    }
    else
    {
        // Source is the screen.
        ptlSrc.x = pptlSrc->x;
        ptlSrc.y = pptlSrc->y;
        ppdev = (PPDEV) psoSrc->dhpdev;
    }


    //
    // Determine the destination type and adjust the destination offset.
    //
    if (psoTrg->iType == STYPE_DEVBITMAP)
    {
        PDSURF pdsurf = (PDSURF) psoTrg->dhsurf;
        ptlDest.x = prclTrg->left + pdsurf->ptl.x;
        ptlDest.y = prclTrg->top + pdsurf->ptl.y;
    }
    else
    {
        ptlDest.x = prclTrg->left;
        ptlDest.y = prclTrg->top;
    }


    //
    // Is there a translation table?
    // If so, we will attempt to load it into the chip.  This also
    // points pulXlate at the color translation table, if there is one.
    //
	#if COLOR_TRANSLATE
    if (! bCacheXlateTable(ppdev, &pulXlate, psoTrg, psoSrc, pxlo,
						   (BYTE)(ulDRAWBLTDEF&0xCC)) )
	#else
	if ( (pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL) )
	{
		pulXlate = NULL;
	}
	else if (pxlo->flXlate & XO_TABLE)
	{
		pulXlate = pxlo->pulXlate;
	}
	else
	{
		pulXlate = XLATEOBJ_piVector(pxlo);
	}

	if (pulXlate != NULL)
	#endif
    {
        // We must do software color translation.
        return DoDeviceToDeviceWithXlate(psoTrg, psoSrc, pulXlate, prclTrg,
										 pptlSrc, ulDRAWBLTDEF);
    }

    //
    // if pulXlate == NULL, there is no color translation required.
    // if pulXlate != NULL, we will do hardware translation.
    //

    //
    // We only do screen to screen color translation in 8 bpp.
    //
    ASSERTMSG( ((pulXlate == NULL) || (ppdev->iBitmapFormat == BMF_8BPP)),
            "DoDeviceToDevice: Xlate with non-8bpp.\n");
    if ((pulXlate) && (ppdev->iBitmapFormat != BMF_8BPP))
    {
        return FALSE;
    }


    // Calculate the size of the blit.
    sizl.cx = prclTrg->right - prclTrg->left;
    sizl.cy = prclTrg->bottom - prclTrg->top;

	fStripePixels = (ulDRAWBLTDEF & 0x000F0000) | (pulXlate != NULL);

	if (fStripePixels)
	{
	    // Calculate the number of pixels per tile and per SRAM line.
	    switch (ppdev->iBitmapFormat)
	    {
	        case BMF_8BPP:
	            tileSize = ppdev->lTileSize;
	            maxStripeWidth = 120;
	            break;

	        case BMF_16BPP:
	            tileSize = ppdev->lTileSize / 2;
	            maxStripeWidth = 120 / 2;
	            break;

	        case BMF_24BPP:
	            tileSize = ppdev->cxScreen;
	            maxStripeWidth = max(ptlDest.x - ptlSrc.x, 120 / 3);
	            break;

	        case BMF_32BPP:
	            tileSize = ppdev->lTileSize / 4;
	            maxStripeWidth = 120 / 4;
	            break;
	    }
	}
	else
	{
		// Convert everything to bytes.
		ptlSrc.x *= ppdev->iBytesPerPixel;
		ptlDest.x *= ppdev->iBytesPerPixel;
		sizl.cx *= ppdev->iBytesPerPixel;
		tileSize = ppdev->lTileSize;
		maxStripeWidth = 120;
	}

    // Test vertical direction of blitting and set grDRAWBLTDEF register
    // accordingly.
    if (ptlSrc.y < ptlDest.y)
    {
        ptlSrc.y += sizl.cy - 1;
        ptlDest.y += sizl.cy - 1;
		ulDRAWBLTDEF |= 0x90100000;
    }
    else
    {
        ulDRAWBLTDEF |= 0x10100000;
    }

    // Test horizontal direction of blitting.
    if ( (ptlSrc.x >= ptlDest.x) || (ptlSrc.y != ptlDest.y) )
    {
		if (ptlSrc.x >= ptlDest.x)
		{
	        // Blit to left.
	        while (sizl.cx > 0)
	        {
	            // Calculate the width of this blit.
	            LONG cx = sizl.cx;

	            // Calculate how many pixels it is to the next source tile
	            // boundary. Use lesser value.
	            cx = min(cx, tileSize - (ptlSrc.x % tileSize));

	            // Calculate how many pixels it is to the next destination tile
	            // boundary. Use lesser value.
	            cx = min(cx, tileSize - (ptlDest.x % tileSize));

	            // Perform the blit.
				if (fFirst)
				{
					fFirst = FALSE;

					REQUIRE(9);
					LL_DRAWBLTDEF(ulDRAWBLTDEF, 0);

					if (fStripePixels)
					{
			            LL_OP1(ptlSrc.x, ptlSrc.y);
			            LL_OP0(ptlDest.x, ptlDest.y);

			            if (pulXlate) // launch a color xlate BLT
			                LL_BLTEXT_XLATE(8, cx, sizl.cy);
			            else // Launch a regular BLT
			                LL_BLTEXT(cx, sizl.cy);
					}
					else
					{
						LL_OP1_MONO(ptlSrc.x, ptlSrc.y);
						LL_OP0_MONO(ptlDest.x, ptlDest.y);
						LL_MBLTEXT(cx, sizl.cy);
					}
				}
				else if (pulXlate)
				{
					REQUIRE(7);
		            LL_OP1(ptlSrc.x, ptlSrc.y);
		            LL_OP0(ptlDest.x, ptlDest.y);
					LL_BLTEXT_XLATE(8, cx, sizl.cy);
				}
				else
				{
					REQUIRE(4);
					if (fStripePixels)
					{
						LL16(grOP1_opRDRAM.PT.X, ptlSrc.x);
						LL16(grOP0_opRDRAM.PT.X, ptlDest.x);
						LL16(grBLTEXT_XEX.PT.X, cx);
					}
					else
					{
						LL16(grOP1_opMRDRAM.PT.X, ptlSrc.x);
						LL16(grOP0_opMRDRAM.PT.X, ptlDest.x);
						LL16(grMBLTEXT_XEX.PT.X, cx);
					}
				}

	            // Adjust the coordinates.
	            ptlSrc.x += cx;
	            ptlDest.x += cx;
	            sizl.cx -= cx;
	        }
		}
		else
		{
	        // Blit to right.
			ptlSrc.x += sizl.cx;
			ptlDest.x += sizl.cx;
	        while (sizl.cx > 0)
	        {
	            // Calculate the width of this blit.
	            LONG cx = sizl.cx;

	            // Calculate how many pixels it is to the next source tile
	            // boundary. Use lesser value.
				if ((ptlSrc.x % tileSize) == 0)
				{
					cx = min(cx, tileSize);
				}
				else
				{
	            	cx = min(cx, ptlSrc.x % tileSize);
				}

	            // Calculate how many pixels it is to the next destination tile
	            // boundary. Use lesser value.
				if ((ptlDest.x % tileSize) == 0)
				{
					cx = min(cx, tileSize);
				}
				else
				{
	            	cx = min(cx, ptlDest.x % tileSize);
				}

	            // Perform the blit.
				if (fFirst)
				{
					fFirst = FALSE;

					REQUIRE(9);
					LL_DRAWBLTDEF(ulDRAWBLTDEF, 0);

					if (fStripePixels)
					{
		    	        LL_OP1(ptlSrc.x - cx, ptlSrc.y);
		        	    LL_OP0(ptlDest.x - cx, ptlDest.y);

			            if (pulXlate) // launch a color xlate BLT
			                LL_BLTEXT_XLATE(8, cx, sizl.cy);
			            else // Launch a regular BLT
		    	            LL_BLTEXT(cx, sizl.cy);
					}
					else
					{
						LL_OP1_MONO(ptlSrc.x - cx, ptlSrc.y);
						LL_OP0_MONO(ptlDest.x - cx, ptlDest.y);
						LL_MBLTEXT(cx, sizl.cy);
					}
				}
				else if (pulXlate)
				{
					REQUIRE(7);
		            LL_OP1(ptlSrc.x - cx, ptlSrc.y);
		            LL_OP0(ptlDest.x - cx, ptlDest.y);
					LL_BLTEXT_XLATE(8, cx, sizl.cy);
				}
				else
				{
					REQUIRE(4);
					if (fStripePixels)
					{
						LL16(grOP1_opRDRAM.PT.X, ptlSrc.x - cx);
						LL16(grOP0_opRDRAM.PT.X, ptlDest.x - cx);
						LL16(grBLTEXT_XEX.PT.X, cx);
					}
					else
					{
						LL16(grOP1_opMRDRAM.PT.X, ptlSrc.x - cx);
						LL16(grOP0_opMRDRAM.PT.X, ptlDest.x - cx);
						LL16(grMBLTEXT_XEX.PT.X, cx);
					}
				}

	            // Adjust the coordinates.
	            ptlSrc.x -= cx;
	            ptlDest.x -= cx;
	            sizl.cx -= cx;
	        }
		}
    }

    else
    {
        // Blit using SRAM.
        ptlSrc.x += sizl.cx;
        ptlDest.x += sizl.cx;

        while (sizl.cx > 0)
        {
            // Calculate the width of this blit. We must never overrun a single
            // SRAM cache line.
            LONG cx = min(sizl.cx, maxStripeWidth);

            // Calculate how many pixels it is to the next source tile
            // boundary. Use lesser value.
            cx = min(cx, ((ptlSrc.x - 1) % tileSize) + 1);

            // Calculate how many pixels it is to the next destination tile
            // boundary. Use lesser value.
            cx = min(cx, ((ptlDest.x - 1) % tileSize) + 1);

            // Do the blit.
			if (fFirst)
			{
				REQUIRE(9);
				LL_DRAWBLTDEF(ulDRAWBLTDEF, 0);
				if (fStripePixels)
				{
	        	    LL_OP1(ptlSrc.x - cx, ptlSrc.y);
	            	LL_OP0(ptlDest.x - cx, ptlDest.y);

					if (pulXlate) // Launch a color xlate BLT
	    	            LL_BLTEXT_XLATE(8, cx, sizl.cy);
		            else // Launch a regular BLT
		                LL_BLTEXT(cx, sizl.cy);
				}
				else
				{
					LL_OP1_MONO(ptlSrc.x - cx, ptlSrc.y);
					LL_OP0_MONO(ptlDest.x - cx, ptlDest.y);
					LL_MBLTEXT(cx, sizl.cy);
				}
			}
			else if (pulXlate)
			{
				REQUIRE(7);
	            LL_OP1(ptlSrc.x - cx, ptlSrc.y);
	            LL_OP0(ptlDest.x - cx, ptlDest.y);
				LL_BLTEXT_XLATE(8, cx, sizl.cy);
			}
			else
			{
				REQUIRE(4);
				if (fStripePixels)
				{
					LL16(grOP1_opRDRAM.PT.X, ptlSrc.x - cx);
					LL16(grOP0_opRDRAM.PT.X, ptlDest.x - cx);
					LL16(grBLTEXT_XEX.PT.X, cx);
				}
				else
				{
					LL16(grOP1_opMRDRAM.PT.X, ptlSrc.x - cx);
					LL16(grOP0_opMRDRAM.PT.X, ptlDest.x - cx);
					LL16(grMBLTEXT_XEX.PT.X, cx);
				}
			}

            // Adjust the coordinates.
            ptlSrc.x -= cx;
            ptlDest.x -= cx;
            sizl.cx -= cx;
        }
    }

    return(TRUE);
}







/*****************************************************************************\
 * DoDeviceToDeviceWithXlate
 *
 * This routine performs a ScreenToScreen, DeviceToScreen or ScreenToDevice
 * blit when there is a color translation table.
 * Color translation is done in software.
 *
 *
 * On entry:    psoTrg          Pointer to target surface object.
 *              psoSrc          Pointer to source surface object.
 *              pulXlate        Translation table.
 *              prclTrg         Destination rectangle.
 *              pptlSrc         Source offset.
 *              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoDeviceToDeviceWithXlate(
    SURFOBJ  *psoTrg,
    SURFOBJ  *psoSrc,
    ULONG    *pulXlate,
    RECTL    *prclTrg,
    POINTL   *pptlSrc,
    ULONG    ulDRAWBLTDEF
)
{
    POINTL ptlSrc, ptlDest;
    SIZEL  sizl;
    PPDEV  ppdev;
    BYTE*  pjSrc;
    DWORD* pjHostData;
    LONG   lDelta, lExtra, lLeadIn, i, n, tileSize, maxStripeWidth;


    // Determine the source type and adjust the source offset.
    if (psoSrc->iType == STYPE_DEVBITMAP)
    {
        // Source is a device bitmap.
        PDSURF pdsurf = (PDSURF) psoSrc->dhsurf;
        ptlSrc.x = pptlSrc->x + pdsurf->ptl.x;
        ptlSrc.y = pptlSrc->y + pdsurf->ptl.y;
        ppdev = pdsurf->ppdev;
    }
    else
    {
        // Source is the screen.
        ptlSrc.x = pptlSrc->x;
        ptlSrc.y = pptlSrc->y;
        ppdev = (PPDEV) psoSrc->dhpdev;
    }

    // Determine the destination type and adjust the destination offset.
    if (psoTrg->iType == STYPE_DEVBITMAP)
    {
        PDSURF pdsurf = (PDSURF) psoTrg->dhsurf;
        ptlDest.x = prclTrg->left + pdsurf->ptl.x;
        ptlDest.y = prclTrg->top + pdsurf->ptl.y;
    }
    else
    {
        ptlDest.x = prclTrg->left;
        ptlDest.y = prclTrg->top;
    }

    // We only support color translations in 8-bpp.
    if (ppdev->iBitmapFormat != BMF_8BPP)
    {
        return FALSE;
    }

    // Calculate the size of the blit.
    sizl.cx = prclTrg->right - prclTrg->left;
    sizl.cy = prclTrg->bottom - prclTrg->top;


    // Calculate the screen address.
    pjSrc = ppdev->pjScreen + ptlSrc.x + ptlSrc.y * ppdev->lDeltaScreen;
    lDelta = ppdev->lDeltaScreen;
    pjHostData = (DWORD*) ppdev->pLgREGS->grHOSTDATA;

    // Wait for the hardware to become idle.
    while (LLDR_SZ(grSTATUS) != 0) ;

    // DWORD align the source.
    lLeadIn = (DWORD)pjSrc & 3;
    pjSrc -= lLeadIn;
    n = (sizl.cx + lLeadIn + 3) >> 2;

    // Test for overlapping.
    if (ptlSrc.y < ptlDest.y)
    {
        // Negative direction.
        pjSrc += (sizl.cy - 1) * lDelta;
        ptlDest.y += sizl.cy - 1;
        lDelta = -lDelta;
		REQUIRE(9);
        LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x90200000, 0);
    }
    else if (ptlSrc.y > ptlDest.y)
    {
        // Positive direction.
		REQUIRE(9);
        LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
    }
    else
    {
        // Maybe horizontal overlap, punt call to GDI anyway.
        return(FALSE);
    }

    #if ! DRIVER_5465
        // Get the number of extra DWORDS per line for the HOSTDATA hardware
        // bug.
        if (ppdev->dwLgDevID == CL_GD5462)
        {
            if (MAKE_HD_INDEX(sizl.cx, lLeadIn, ptlDest.x) == 3788)
            {
                // We have a problem with the HOSTDATA TABLE. 
                // Punt till we can figure it out.
                return FALSE; 
            }
            lExtra =
                ExtraDwordTable[MAKE_HD_INDEX(sizl.cx, lLeadIn, ptlDest.x)];
        }
        else
            lExtra = 0;
    #endif

    // Start the blit.
    LL_OP1_MONO(lLeadIn, 0);
    LL_OP0(ptlDest.x, ptlDest.y);
    LL_BLTEXT(sizl.cx, sizl.cy);

    while (sizl.cy--)
    {
		BYTE *p = pjSrc;
		BYTE pixel[4];

        for (i = 0; i < n; i++)
        {
            pixel[0] = (BYTE) pulXlate[p[0]];
            pixel[1] = (BYTE) pulXlate[p[1]];
            pixel[2] = (BYTE) pulXlate[p[2]];
            pixel[3] = (BYTE) pulXlate[p[3]];
			p += 4;
			REQUIRE(1);
            *pjHostData = *(DWORD*) pixel;
        }

        #if !DRIVER_5465
            // Now, write the extra DWORDS.
			REQUIRE(lExtra);
            for (i = 0; i < lExtra; i++)
            {
                LL32(grHOSTDATA[i], 0);
            }
        #endif

        // Next line.
        pjSrc += lDelta;
    }

    // Return okay.
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\escape.c ===
/****************************************************************************
*****************************************************************************
*
*                ******************************************
*                * Copyright (c) 1995, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:	Laguna I (CL-GD5462) - 
*
* FILE:		escape.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module Handles escapes
*
* MODULES:
*           DrvEscape()
*
* REVISION HISTORY:
*   11/16/95     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/ESCAPE.C  $
* 
*    Rev 1.14   Dec 10 1997 13:32:12   frido
* Merged from 1.62 branch.
* 
*    Rev 1.13.1.0   Nov 10 1997 11:34:08   phyang
* Added 5 escape functions for utilities to update registry values.
* 
*    Rev 1.13   10 Sep 1997 10:40:36   noelv
* Modified QUERYESCSUPPORT to only return TRUE for escapes we actually suppor
* It was returning TRUE all the time.
* 
*    Rev 1.12   20 Aug 1997 15:49:42   bennyn
* 
* Added IS_CIRRUS_DRIVER escape support
*
****************************************************************************
****************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/
#include "precomp.h"
#include "clioctl.h"

/*----------------------------- DEFINES -----------------------------------*/
//#define DBGBRK

#define ESC_DBG_LVL 1


#if 0   // MCD not working good
#if ( DRIVER_5465 && !defined(WINNT_VER35) )
    #define CLMCD_ESCAPE_SUPPORTED
#endif
#endif// 0 MCD not working good



#ifdef CLMCD_ESCAPE_SUPPORTED
//    #define CLMCDDLLNAME	    "CLMCD.DLL"
//    #define CLMCDINITFUNCNAME   "CLMCDInit"

MCDRVGETENTRYPOINTSFUNC CLMCDInit(PPDEV ppdev);

#endif // def CLMCD_ESCAPE_SUPPORTED


/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/

#ifdef CLMCD_ESCAPE_SUPPORTED

typedef BOOL (*MCDRVGETENTRYPOINTSFUNC)(MCDSURFACE *pMCDSurface, MCDDRIVER *pMCDDriver);
typedef POFMHDL (*ALLOCOFFSCNMEMFUNC)(PPDEV ppdev, PSIZEL surf, ULONG alignflag, POFM_CALLBACK pcallback);
typedef BOOL    (*FREEOFFSCNMEMFUNC)(PPDEV ppdev, OFMHDL *hdl);
//typedef MCDRVGETENTRYPOINTSFUNC (*CLMCDINITFUNC)(PPDEV);

#endif // def CLMCD_ESCAPE_SUPPORTED


/*-------------------------- STATIC VARIABLES -----------------------------*/


/****************************************************************************
* FUNCTION NAME: DrvEscape()
*
* DESCRIPTION:   Driver escape entry point.
*
* REVISION HISTORY:
*   11/16/95     Benny Ng      Initial version
****************************************************************************/
ULONG APIENTRY DrvEscape(SURFOBJ *pso,
                         ULONG   iEsc,
                         ULONG   cjIn,
                         PVOID   pvIn,
                         ULONG   cjOut,
                         PVOID   pvOut)

{
  PPDEV ppdev = (PPDEV) pso->dhpdev;
  DWORD returnedDataLength = 0;
  ULONG retval = FALSE;

  PMMREG_ACCESS pInMRAccess;
  PMMREG_ACCESS pMRAccess;
  BYTE  *pbAddr;
  WORD  *pwAddr;
  DWORD *pdwAddr;

  DISPDBG((ESC_DBG_LVL, "DrvEscape-Entry.\n"));   

  switch (iEsc)
  {


    //
    // Prior to using an Escape, an application will ask us 
    // if we support it first.  Return TRUE if we can handle 
    // the requested escape.
    //
    case QUERYESCSUPPORT:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: QUERY_ESCAPE_SUPPORTED. "
          "Requested escape is 0x%X.\n", *((ULONG *)pvIn) ));   

      switch ( *((ULONG *)pvIn) )
      {
        case QUERYESCSUPPORT:
        case IS_CIRRUS_DRIVER:
        case GET_VIDEO_MEM_SIZE:
        case CRTC_READ:
        case GET_BIOS_VERSION:
        case GET_PCI_VEN_DEV_ID:
        case GET_EDID_DATA:
        #ifdef CLMCD_ESCAPE_SUPPORTED // OpenGL MCD Interface
            case MCDFUNCS:
        #endif
        case CIRRUS_ESCAPE_FUNCTION:
        #if (!(WINNT_VER35)) && DRIVER_5465 // NT 4.0+ and 5465+
            case ID_LGPM_SETHWMODULESTATE:
            case ID_LGPM_GETHWMODULESTATE:
        #endif
        case BIOS_CALL_REQUEST:
        case GET_CL_MMAP_ADDR:
            DISPDBG((ESC_DBG_LVL, 
              "DrvEscape: We support the requested escape.\n"));   
            retval = TRUE;

        default:
            DISPDBG((ESC_DBG_LVL, 
              "DrvEscape: We DO NOT support the requested escape.\n"));   
            retval = FALSE;
      }
      break;

    };  // case QUERYESCSUPPORT


    case SET_AGPDATASTREAMING:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: SET_AGPDATASTREAMING.\n"));   
      retval = FALSE;
      if (cjIn == sizeof(BYTE))
      {
         if (DEVICE_IO_CTRL(ppdev->hDriver,
                             IOCTL_SET_AGPDATASTREAMING,
                             pvIn,
                             sizeof(BYTE),
                             NULL,
                             0,
                             &returnedDataLength,
                             NULL))
         {
            retval = TRUE;
         };
      };
      break;
    }  // end case SET_AGPDATASTREAMING


    case SET_DDCCONTROLFLAG:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: SET_DDCCONTROLFLAG.\n"));   
      retval = FALSE;
      if (cjIn == sizeof(DWORD))
      {
         if (DEVICE_IO_CTRL(ppdev->hDriver,
                             IOCTL_SET_DDCCONTROLFLAG,
                             pvIn,
                             sizeof(DWORD),
                             NULL,
                             0,
                             &returnedDataLength,
                             NULL))
         {
            retval = TRUE;
         };
      };
      break;
    }  // end case SET_DDCCONTROLFLAG


    case SET_NONDDCMONITOR_DATA:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: SET_NONDDCMONITOR_DATA.\n"));   
      retval = FALSE;
      if (cjIn == 128)
      {
         if (DEVICE_IO_CTRL(ppdev->hDriver,
                             IOCTL_SET_NONDDCMONITOR_DATA,
                             pvIn,
                             128,
                             NULL,
                             0,
                             &returnedDataLength,
                             NULL))
         {
            retval = TRUE;
         };
      };
      break;
    }  // end case SET_NONDDCMONITOR_DATA


    case SET_NONDDCMONITOR_BRAND:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: SET_NONDDCMONITOR_BRAND.\n"));   
      retval = FALSE;
      if (cjIn > 0)
      {
         if (DEVICE_IO_CTRL(ppdev->hDriver,
                             IOCTL_SET_NONDDCMONITOR_BRAND,
                             pvIn,
                             cjIn,
                             NULL,
                             0,
                             &returnedDataLength,
                             NULL))
         {
            retval = TRUE;
         };
      };
      break;
    }  // end case SET_NONDDCMONITOR_BRAND


    case SET_NONDDCMONITOR_MODEL:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: SET_NONDDCMONITOR_MODEL.\n"));   
      retval = FALSE;
      if (cjIn > 0)
      {
         if (DEVICE_IO_CTRL(ppdev->hDriver,
                             IOCTL_SET_NONDDCMONITOR_MODEL,
                             pvIn,
                             cjIn,
                             NULL,
                             0,
                             &returnedDataLength,
                             NULL))
         {
            retval = TRUE;
         };
      };
      break;
    }  // end case SET_NONDDCMONITOR_MODEL


    case IS_CIRRUS_DRIVER:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: IS_CIRRUS_DRIVER.\n"));   
      retval = TRUE;
      break;
    }  // end case IS_CIRRUS_DRIVER



    case GET_VIDEO_MEM_SIZE:
    {
      BYTE  btmp;
      PBYTE pOut = (PBYTE) pvOut;

      DISPDBG((ESC_DBG_LVL, "DrvEscape: GET_VIDEO_MEM_SIZE.\n"));   
      if (cjOut == sizeof(BYTE))
      {
         btmp = ppdev->lTotalMem/0x10000;
         *pOut = btmp;
         retval = TRUE;
      };
      break;
    }  // end case GET_VIDEO_MEM_SIZE



    case CRTC_READ:
    {
      BYTE  bindex;
      PBYTE pMMReg = (PBYTE) ppdev->pLgREGS_real;
      PBYTE pIn  = (PBYTE) pvIn;
      PBYTE pOut = (PBYTE) pvOut;

      DISPDBG((ESC_DBG_LVL, "DrvEscape: CRTC_READ.\n"));   
      if ((cjIn  == sizeof(BYTE)) &&
          (cjOut == sizeof(BYTE)))
      {
         bindex = (*pIn) * 4;
         pMMReg = pMMReg + bindex;
         *pOut = *pMMReg;
         retval = TRUE;
      };
      break;
    }  // end case CRTC_READ


    case GET_BIOS_VERSION:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: GET_BIOS_VERSION.\n"));   
      if (cjOut == sizeof(WORD))
      {
         if (DEVICE_IO_CTRL(ppdev->hDriver,
                             IOCTL_GET_BIOS_VERSION,
                             NULL,
                             0,
                             pvOut,
                             sizeof(WORD),
                             &returnedDataLength,
                             NULL))
         {
            retval = TRUE;
         };
      };
      break;
    }  // end case GET_BIOS_VERSION



    case GET_PCI_VEN_DEV_ID:
    {
      ULONG  ultmp;
      PULONG pOut = (PULONG) pvOut;

      DISPDBG((ESC_DBG_LVL, "DrvEscape: GET_PCI_VEN_DEV_ID.\n"));   
      if (cjOut == sizeof(DWORD))
      {
         ultmp = ppdev->dwLgVenID;
         ultmp = (ultmp << 16) | (ppdev->dwLgDevID & 0xFFFF);
         *pOut = ultmp;
         retval = TRUE;
      };
      break;
    }  // end case GET_PCI_VEN_DEV_ID



    case GET_EDID_DATA:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: GET_EDID_DATA.\n"));   
      if (cjOut == 132)
      {
         if (DEVICE_IO_CTRL(ppdev->hDriver,
                            IOCTL_GET_EDID_DATA,
                            NULL,
                            0,
                            pvOut,
                            132,
                            &returnedDataLength,
                            NULL))
         {
            retval = TRUE;
         };
      };
      break;
    }  // end case GET_EDID_DATA



    #ifdef CLMCD_ESCAPE_SUPPORTED
	// OpenGL Mini-Client Driver Interface
    case MCDFUNCS:
    {
	 	DISPDBG((ESC_DBG_LVL, "DrvEscape-MCDFUNC start\n"));   
        if (!ppdev->hMCD) {
            WCHAR uDllName[50];
            UCHAR dllName[50];
            ULONG nameSize;

            {
                HANDLE      hCLMCD;

//                // load and initialize the dll containing MCD support for display driver
//                EngMultiByteToUnicodeN(uDllName, sizeof(uDllName), &nameSize,
//                                       CLMCDDLLNAME, sizeof(CLMCDDLLNAME));
//
//                if (hCLMCD = EngLoadImage(uDllName))

                  {

//                    CLMCDINITFUNC pCLMCDInit =  EngFindImageProcAddress(hCLMCD,
//                                                     (LPSTR)CLMCDINITFUNCNAME);

//                    if (pCLMCDInit)

                      {

                        // Enable 3D engine - if enable fails, don't continue loading MCD dll
                        if (LgPM_SetHwModuleState(ppdev, MOD_3D, ENABLE))
                        {

                            DRVENABLEDATA temp;

                            // MCD dispdriver dll init returns ptr to MCDrvGetEntryPoints,
                            //  which is passed to init proc for MCD helper lib a few lines down...
//                            MCDRVGETENTRYPOINTSFUNC pMCDGetEntryPoints = (*pCLMCDInit)(ppdev);
                            MCDRVGETENTRYPOINTSFUNC pMCDGetEntryPoints = CLMCDInit(ppdev);


                            ppdev->pAllocOffScnMem = AllocOffScnMem;
                            ppdev->pFreeOffScnMem = FreeOffScnMem;

                            // after MCD display driver dll loaded, load MCD helper lib (MSFT supplied)
                
                            EngMultiByteToUnicodeN(uDllName, sizeof(uDllName), &nameSize,
                                                   MCDENGDLLNAME, sizeof(MCDENGDLLNAME));

                            if (ppdev->hMCD = EngLoadImage(uDllName)) {
                                MCDENGINITFUNC pMCDEngInit =  EngFindImageProcAddress(ppdev->hMCD,
                                                                 (LPSTR)MCDENGINITFUNCNAME);

                                if (pMCDEngInit) {
                                    (*pMCDEngInit)(pso, pMCDGetEntryPoints);
                                    ppdev->pMCDFilterFunc = EngFindImageProcAddress(ppdev->hMCD,
                                                                (LPSTR)MCDENGESCFILTERNAME);

                                }
                            }

                            
                        }
                        
                    }
                }
            }


        }

        if (ppdev->pMCDFilterFunc) {
        #ifdef DBGBRK                           
            DBGBREAKPOINT();
        #endif
            if ((*ppdev->pMCDFilterFunc)(pso, iEsc, cjIn, pvIn,			   
                                         cjOut, pvOut, &retval))
			{
        	 	DISPDBG((ESC_DBG_LVL, "DrvEscape-MCDFilterFunc SUCCESS, retval=%x\n",retval));   
                return retval;
			}
      	 	DISPDBG((ESC_DBG_LVL, "DrvEscape-MCDFilterFunc FAILED\n"));   
        }
    }
    break;
    #endif // def CLMCD_ESCAPE_SUPPORTED



    case CIRRUS_ESCAPE_FUNCTION:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: CIRRUS_ESCAPE_FUNCTION.\n"));   
      if ((cjIn  == sizeof(VIDEO_X86_BIOS_ARGUMENTS)) &&
          (cjOut == sizeof(VIDEO_X86_BIOS_ARGUMENTS)))
      {
         VIDEO_POWER_MANAGEMENT  inPM;
         BOOL bCallFail = FALSE;

         VIDEO_X86_BIOS_ARGUMENTS *pinregs  = (VIDEO_X86_BIOS_ARGUMENTS *) pvIn;
         VIDEO_X86_BIOS_ARGUMENTS *poutregs = (VIDEO_X86_BIOS_ARGUMENTS *) pvOut;

         poutregs->Eax = 0x014F;
         poutregs->Ebx = pinregs->Ebx;
         poutregs->Ecx = pinregs->Ecx;
 
         if (pinregs->Eax == 0x4F10)
         {
            if (pinregs->Ebx == 0x0001)
               inPM.PowerState = VideoPowerOn;
            else if (pinregs->Ebx == 0x0101)
               inPM.PowerState = VideoPowerStandBy;
            else if (pinregs->Ebx == 0x0201)
               inPM.PowerState = VideoPowerSuspend;
             else if (pinregs->Ebx == 0x0401)
               inPM.PowerState = VideoPowerOff;
             else
               bCallFail = TRUE;


             if (!bCallFail)
             {
                if (DEVICE_IO_CTRL(ppdev->hDriver,
                                   IOCTL_VIDEO_SET_POWER_MANAGEMENT,
                                   &inPM,
                                   sizeof(VIDEO_POWER_MANAGEMENT),
                                   NULL,
                                   0,
                                   &returnedDataLength,
                                   NULL))
                {
                   poutregs->Eax = 0x004F;
                   retval = TRUE;
                };
             };  // endif (!bCallFail)
         };  // endif (pinregs->Eax == 0x4F10)
      };

      break;
    };  // case CIRRUS_ESCAPE_FUNCTION



    #if (!(WINNT_VER35)) && DRIVER_5465 // NT 4.0+ and 5465+
    case ID_LGPM_SETHWMODULESTATE:
    {
       ULONG state;
       DISPDBG((ESC_DBG_LVL, "DrvEscape: ID_LGPM_SETHWMODULESTATE.\n"));   

       if (ppdev->dwLgDevID >= CL_GD5465)
       {
          if ((cjIn  == sizeof(LGPM_IN_STRUCT)) &&
              (cjOut == sizeof(LGPM_OUT_STRUCT)))
          {
             LGPM_IN_STRUCT  *pIn  = (LGPM_IN_STRUCT *) pvIn;
             LGPM_OUT_STRUCT *pOut = (LGPM_OUT_STRUCT *) pvOut;

             retval = TRUE;

             pOut->status = FALSE;
             pOut->retval = 0;

             pOut->status = LgPM_SetHwModuleState(ppdev, pIn->arg1, pIn->arg2);
          };
       }; // endif (ppdev->dwLgDevID >= CL_GD5465)
      break;
    };  // case ID_LGPM_SETHWMODULESTATE
    #endif



    #if (!(WINNT_VER35)) && DRIVER_5465 // NT 4.0+ and 5465+
    case ID_LGPM_GETHWMODULESTATE:
    {
        ULONG state;
        DISPDBG((ESC_DBG_LVL, "DrvEscape: ID_LGPM_GETHWMODULESTATE.\n"));   

        if (ppdev->dwLgDevID >= CL_GD5465)
        {
          if ((cjIn  == sizeof(LGPM_IN_STRUCT)) &&
              (cjOut == sizeof(LGPM_OUT_STRUCT)))
          {
             LGPM_IN_STRUCT  *pIn  = (LGPM_IN_STRUCT *) pvIn;
             LGPM_OUT_STRUCT *pOut = (LGPM_OUT_STRUCT *) pvOut;

             retval = TRUE;

             pOut->status = FALSE;
             pOut->retval = 0;

             pOut->status = LgPM_GetHwModuleState(ppdev, pIn->arg1, &state);
             pOut->retval = state;
          };

        }; // endif (ppdev->dwLgDevID >= CL_GD5465)
        break;
    };  // case ID_LGPM_GETHWMODULESTATE
    #endif



    case BIOS_CALL_REQUEST:
    {
        if ((cjIn  == sizeof(VIDEO_X86_BIOS_ARGUMENTS)) &&
            (cjOut == sizeof(VIDEO_X86_BIOS_ARGUMENTS)))
        {
         if (DEVICE_IO_CTRL(ppdev->hDriver,
                             IOCTL_CL_BIOS,
                             pvIn,
                             cjIn,
                             pvOut,
                             cjOut,
                             &returnedDataLength,
                             NULL))
            retval = TRUE;
        };

        DISPDBG((ESC_DBG_LVL, "DrvEscape-BIOS_CALL_REQUEST\n"));

        #ifdef DBGBRK
          DbgBreakPoint();
        #endif

      break;
    }; // end case BIOS_CALL_REQUEST



    case GET_CL_MMAP_ADDR:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: GET_CL_MMAP_ADDR.\n"));   
      if ((cjIn != sizeof(MMREG_ACCESS)) || (cjOut != sizeof(MMREG_ACCESS)))
         break;

      pInMRAccess = (MMREG_ACCESS *) pvIn;
      pMRAccess   = (MMREG_ACCESS *) pvOut;

      pMRAccess->Offset = pInMRAccess->Offset;
      pMRAccess->ReadVal = pInMRAccess->ReadVal;
      pMRAccess->WriteVal = pInMRAccess->WriteVal;
      pMRAccess->RdWrFlag = pInMRAccess->RdWrFlag;
      pMRAccess->AccessType = pInMRAccess->AccessType;

      pbAddr = (BYTE *) ppdev->pLgREGS;
      pbAddr = pbAddr + pMRAccess->Offset;

      if (pMRAccess->RdWrFlag == READ_OPR)  // Read operation
      {
         pMRAccess->WriteVal = 0;
         retval = TRUE;

         if (pMRAccess->AccessType == BYTE_ACCESS)
         {
            pMRAccess->ReadVal = (*pbAddr) & 0xFF;
         }
         else if (pMRAccess->AccessType == WORD_ACCESS)
         {
            pwAddr = (WORD *)pbAddr;
            pMRAccess->ReadVal = (*pwAddr) & 0xFFFF;
         }
         else if (pMRAccess->AccessType == DWORD_ACCESS)
         {
            pdwAddr = (DWORD *)pbAddr;
            pMRAccess->ReadVal = *pdwAddr;
         }
         else
         {
            pMRAccess->ReadVal = 0;
            retval = FALSE;
         };
      }
      else if (pMRAccess->RdWrFlag == WRITE_OPR)  // Write operation
      {
         retval = TRUE;

         if (pMRAccess->AccessType == BYTE_ACCESS)
         {
            pMRAccess->ReadVal = (*pbAddr) & 0xFF;
            *pbAddr = (BYTE) (pMRAccess->WriteVal & 0xFF);
         }
         else if (pMRAccess->AccessType == WORD_ACCESS)
         {
            pwAddr = (WORD *)pbAddr;
            pMRAccess->ReadVal = (*pwAddr) & 0xFFFF;
            *pwAddr = (WORD) (pMRAccess->WriteVal & 0xFFFF);
         }
         else if (pMRAccess->AccessType == DWORD_ACCESS)
         {
            pdwAddr = (DWORD *)pbAddr;
            pMRAccess->ReadVal = *pdwAddr;
            *pdwAddr = pMRAccess->WriteVal;
         }
         else
         {
            pMRAccess->ReadVal = 0;
            pMRAccess->WriteVal = 0;
            retval = FALSE;
         };
      };

        DISPDBG((ESC_DBG_LVL, "DrvEscape-GET_CL_MMAP_ADDR\n"));
        DISPDBG((ESC_DBG_LVL, "DrvEscape-rd=%x, wr=%x\n",
                        pMRAccess->ReadVal, pMRAccess->WriteVal));
        #ifdef DBGBRK
          DbgBreakPoint();
        #endif

        break;
    }; // IOCTL_CL_GET_MMAP_ADDR



    default:

        DISPDBG((ESC_DBG_LVL, 
            "DrvEscape:  default - Escape not handled.\n"));   
        DISPDBG((ESC_DBG_LVL, 
            "DrvEscape: Requested escape is 0x%X.\n",iEsc ));   
        DISPDBG((ESC_DBG_LVL, "DrvEscape:  Returning FALSE.\n"));   

        retval = FALSE;
        break;

  };  // end switch


  DISPDBG((ESC_DBG_LVL, "DrvEscape-Exit.\n"));   

  return (retval);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\fastfill.c ===
/******************************Module*Header*******************************\
* Module Name: fastfill.c
*
* Draws fast solid-coloured, unclipped, non-complex rectangles.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#define RIGHT 0
#define LEFT  1

#define FASTFILL_DBG_LEVEL 1

typedef struct _EDGEDATA {
    LONG      x;                // Current x position
    LONG      dx;               // # pixels to advance x on each scan
    LONG      lError;           // Current DDA error
    LONG      lErrorUp;         // DDA error increment on each scan
    LONG      lErrorDown;       // DDA error adjustment
    POINTFIX* pptfx;            // Points to start of current edge
    LONG      dptfx;            // Delta (in bytes) from pptfx to next point
    LONG      cy;               // Number of scans to go for this edge
} EDGEDATA;                         /* ed, ped */

/******************************Public*Routine******************************\
* BOOL bMmFastFill
*
* Draws a non-complex, unclipped polygon.  'Non-complex' is defined as
* having only two edges that are monotonic increasing in 'y'.  That is,
* the polygon cannot have more than one disconnected segment on any given
* scan.  Note that the edges of the polygon can self-intersect, so hourglass
* shapes are permissible.  This restriction permits this routine to run two
* simultaneous DDAs, and no sorting of the edges is required.
*
* Note that NT's fill convention is different from that of Win 3.1 or 4.0.
* With the additional complication of fractional end-points, our convention
* is the same as in 'X-Windows'.  But a DDA is a DDA is a DDA, so once you
* figure out how we compute the DDA terms for NT, you're golden.
*
* This routine handles patterns only when the S3 hardware patterns can be
* used.  The reason for this is that once the S3 pattern initialization is
* done, pattern fills appear to the programmer exactly the same as solid
* fills (with the slight difference that different registers and commands
* are used).  Handling 'vIoFillPatSlow' style patterns in this routine
* would be non-trivial...
*
* We take advantage of the fact that the S3 automatically advances the
* current 'y' to the following scan whenever a rectangle is output so that
* we have to write to the accelerator three times for every scan: one for
* the new 'x', one for the new 'width', and one for the drawing command.
*
* This routine is in no way the ultimate convex polygon drawing routine
* (what can I say, I was pressed for time when I wrote this :-).  Some
* obvious things that would make it faster:
*
*    1) Write it in Asm and amortize the FIFO checking costs (check out
*       i386\fastfill.asm for a version that does this).
*
*    2) Take advantage of any hardware such as the ATI's SCAN_TO_X
*       command, or any built-in trapezoid support (note that with NT
*       you may get non-integer end-points, so you must be able to
*       program the trapezoid DDA terms directly).
*
*    3) Do some rectangle coalescing when both edges are y-major.  This
*       could permit removal of my vertical-edges special case.  I
*       was also thinking of special casing y-major left edges on the
*       S3, because the S3 leaves the current 'x' unchanged on every blt,
*       so a scan that starts on the same 'x' as the one above it
*       would require only two commands to the accelerator (obviously,
*       this only helps when we're not overdriving the accelerator).
*
*    4) Make the non-complex polygon detection faster.  If I could have
*       modified memory before the start of after the end of the buffer,
*       I could have simplified the detection code.  But since I expect
*       this buffer to come from GDI, I can't do that.  Another thing
*       would be to have GDI give a flag on calls that are guaranteed
*       to be convex, such as 'Ellipses' and 'RoundRects'.  Note that
*       the buffer would still have to be scanned to find the top-most
*       point.
*
*    5) Special case integer points.  Unfortunately, for this to be
*       worth-while would require GDI to give us a flag when all the
*       end-points of a path are integers, which it doesn't do.
*
*    6) Add rectangular clipping support.
*
*    7) Implement support for a single sub-path that spans multiple
*       path data records, so that we don't have to copy all the points
*       to a single buffer like we do in 'fillpath.c'.
*
*    8) Use 'ebp' and/or 'esp' as a general register in the inner loops
*       of the Asm loops, and also Pentium-optimize the code.  It's safe
*       to use 'esp' on NT because it's guaranteed that no interrupts
*       will be taken in our thread context, and nobody else looks at the
*       stack pointer from our context.
*
*    9) Do the fill bottom-up instead of top-down.  With the S3, we have
*       to only set 'cur_y' once because each drawing command automatically
*       advances 'cur_y' (unless the polygon has zero pels lit on a scan),
*       so we set this right at the beginning.  But for an integer end-point
*       polygon, unless the top edge is horizontal, no pixels are lit on
*       that first scan (so at the beginning of almost every integer
*       polygon, we go through the 'zero width' logic and again set
*       'cur_y').  We could avoid this extra work by building the polygon
*       from bottom to top: for the bottom-most point B in a polygon, it
*       is guaranteed that any scan with lit pixels will be no lower than
*       'ceiling(B.y) - 1'.  Unfortunately, building bottom-up makes the
*       fractional-DDA calculations a little more complex, so I didn't do it.
*
*       Building bottom-up would also improve the polygon score in version
*       3.11 of a certain benchmark, because it has a big rectangle at the
*       top of every polygon -- we would get better processing overlap
*       because we wouldn't have to wait around for the accelerator to
*       finish drawing the big rectangle.
*
*   10) Make a better guess in the initialization as to which edge is the
*       'left' edge, and which is the 'right'.  As it is, we immediately
*       go through the swap-edges logic for half of all polygons when we
*       start to run the DDA.  The reason why I didn't implement better-guess
*       code is because it would have to look at the end-point of the top
*       edges, and to get at the end-points we have to watch that we don't
*       wrap around the ends of the points buffer.
*
*   11) Lots of other things I haven't thought of.
*
* NOTE: Unlike the x86 Asm version, this routine does NOT assume that it
*       has 16 FIFO entries available.
*
* Returns TRUE if the polygon was drawn; FALSE if the polygon was complex.
*
\**************************************************************************/

BOOL bMmFastFill(
PDEV*       ppdev,
LONG        cEdges,         // Includes close figure edge
POINTFIX*   pptfxFirst,
ULONG       ulHwForeMix,
ULONG       ulHwBackMix,
ULONG       iSolidColor,
BRUSHOBJ*  pbo)
{
    LONG      yTrapezoid;   // Top scan for next trapezoid
    LONG      cyTrapezoid;  // Number of scans in current trapezoid
    LONG      y;            // Current Y Location
    LONG      yStart;       // y-position of start point in current edge
    LONG      dM;           // Edge delta in FIX units in x direction
    LONG      dN;           // Edge delta in FIX units in y direction
    LONG      i;
    POINTFIX* pptfxLast;    // Points to the last point in the polygon array
    POINTFIX* pptfxTop;     // Points to the top-most point in the polygon
    POINTFIX* pptfxOld;     // Start point in current edge
    POINTFIX* pptfxScan;    // Current edge pointer for finding pptfxTop
    LONG      cScanEdges;   // Number of edges scanned to find pptfxTop
                            //  (doesn't include the closefigure edge)
    LONG      iEdge;
    LONG      lQuotient;
    LONG      lRemainder;

    EDGEDATA  aed[2];       // DDA terms and stuff
    EDGEDATA* ped;

    DISPDBG((FASTFILL_DBG_LEVEL,"bMmFastFill %x %x %x\n", ulHwForeMix, ulHwBackMix, ppdev->uBLTDEF << 16 | ulHwForeMix,
       ppdev->uBLTDEF << 16 | ulHwForeMix));

    REQUIRE(5);

    // Set up BltDef and DrawDef
    LL_DRAWBLTDEF(ppdev->uBLTDEF << 16 | ulHwForeMix, 2);

    /////////////////////////////////////////////////////////////////
    // See if the polygon is 'non-complex'

    pptfxScan = pptfxFirst;
    pptfxTop  = pptfxFirst;                 // Assume for now that the first
                                            //  point in path is the topmost
    pptfxLast = pptfxFirst + cEdges - 1;

    // 'pptfxScan' will always point to the first point in the current
    // edge, and 'cScanEdges' will the number of edges remaining, including
    // the current one:

    cScanEdges = cEdges - 1;     // The number of edges, not counting close figure

    if ((pptfxScan + 1)->y > pptfxScan->y)
    {
        // Collect all downs:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFillingCheck;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        // Collect all downs:

        pptfxTop = pptfxScan;

        do {
            if ((pptfxScan + 1)->y > pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        DISPDBG((FASTFILL_DBG_LEVEL,"False Exit %s %d\n", __FILE__, __LINE__));
        return(FALSE);
    }
    else
    {
        // Collect all ups:

        do {
            pptfxTop++;                 // We increment this now because we
                                        //  want it to point to the very last
                                        //  point if we early out in the next
                                        //  statement...
            if (--cScanEdges == 0)
                goto SetUpForFilling;
        } while ((pptfxTop + 1)->y <= pptfxTop->y);

        // Collect all downs:

        pptfxScan = pptfxTop;
        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if ((pptfxScan + 1)->y < pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        DISPDBG((FASTFILL_DBG_LEVEL,"False Exit %s %d\n", __FILE__, __LINE__));
        return(FALSE);
    }

SetUpForFillingCheck:

    // We check to see if the end of the current edge is higher
    // than the top edge we've found so far:

    if ((pptfxScan + 1)->y < pptfxTop->y)
        pptfxTop = pptfxScan + 1;

SetUpForFilling:

    /////////////////////////////////////////////////////////////////
    // Some Initialization

    yTrapezoid = (pptfxTop->y + 15) >> 4;
    DISPDBG((FASTFILL_DBG_LEVEL, "%d yTrapezoid init %x\n", __LINE__, yTrapezoid));

    // Make sure we initialize the DDAs appropriately:

    aed[LEFT].cy  = 0;
    aed[RIGHT].cy = 0;

    // For now, guess as to which is the left and which is the right edge:

    aed[LEFT].dptfx  = -(LONG) sizeof(POINTFIX);
    aed[RIGHT].dptfx = sizeof(POINTFIX);
    aed[LEFT].pptfx  = pptfxTop;
    aed[RIGHT].pptfx = pptfxTop;

    if (iSolidColor != -1)
    {
        /////////////////////////////////////////////////////////////////
        // Setup the hardware for solid colours

        // Let's set the Foreground Register here since they are
        switch (ppdev->ulBitCount)
        {
                case 8: // For 8 bpp duplicate byte 0 into bytes 1,2,3.
                        iSolidColor = (iSolidColor & 0xFF) | (iSolidColor << 8);

                case 16: // For 16 bpp, duplicate the low word into the high word.
                        iSolidColor = (iSolidColor & 0xFFFF) | (iSolidColor << 16);
        }

        DISPDBG((FASTFILL_DBG_LEVEL,"FASTFILL: Set Color %x.\n", iSolidColor));
        LL_BGCOLOR(iSolidColor, 2);
    }
    else
    {
        /////////////////////////////////////////////////////////////////
        // Setup for patterns
    }
        y = yTrapezoid;
        DISPDBG((FASTFILL_DBG_LEVEL, "%d New y %x\n", __LINE__, y));
// done above   REQUIRE(1);
        LL16(grOP0_opRDRAM.pt.Y, y + ppdev->ptlOffset.y);

NewTrapezoid:

    /////////////////////////////////////////////////////////////////
    // DDA initialization

    for (iEdge = 1; iEdge >= 0; iEdge--)
    {
        ped = &aed[iEdge];
        if (ped->cy == 0)
        {
            // Need a new DDA:

            do {
                cEdges--;
                if (cEdges < 0)
                {
                    DISPDBG((FASTFILL_DBG_LEVEL,"True Exit %s %d\n", __FILE__, __LINE__));
                    return(TRUE);
                }
                // Find the next left edge, accounting for wrapping:

                pptfxOld = ped->pptfx;
                ped->pptfx = (POINTFIX*) ((BYTE*) ped->pptfx + ped->dptfx);

                if (ped->pptfx < pptfxFirst)
                    ped->pptfx = pptfxLast;
                else if (ped->pptfx > pptfxLast)
                    ped->pptfx = pptfxFirst;

                // Have to find the edge that spans yTrapezoid:

                ped->cy = ((ped->pptfx->y + 15) >> 4) - yTrapezoid;

                // With fractional coordinate end points, we may get edges
                // that don't cross any scans, in which case we try the
                // next one:

            } while (ped->cy <= 0);

            // 'pptfx' now points to the end point of the edge spanning
            // the scan 'yTrapezoid'.

            dN = ped->pptfx->y - pptfxOld->y;
            dM = ped->pptfx->x - pptfxOld->x;

            ASSERTDD(dN > 0, "Should be going down only");

            // Compute the DDA increment terms:

            if (dM < 0)
            {
                dM = -dM;
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = -1;
                    ped->lErrorUp = dN - dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = -lQuotient;     // - dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                    if (ped->lErrorUp > 0)
                    {
                        ped->dx--;
                        ped->lErrorUp = dN - ped->lErrorUp;
                    }
                }
            }
            else
            {
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = 0;
                    ped->lErrorUp = dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = lQuotient;      // dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                }
            }

            ped->lErrorDown = dN; // DDA limit
            ped->lError     = -1; // Error is initially zero (add dN - 1 for
                                  //  the ceiling, but subtract off dN so that
                                  //  we can check the sign instead of comparing
                                  //  to dN)

            ped->x = pptfxOld->x;
            yStart = pptfxOld->y;

            if ((yStart & 15) != 0)
            {
                // Advance to the next integer y coordinate

                for (i = 16 - (yStart & 15); i != 0; i--)
                {
                    ped->x      += ped->dx;
                    ped->lError += ped->lErrorUp;
                    if (ped->lError >= 0)
                    {
                        ped->lError -= ped->lErrorDown;
                        ped->x++;
                    }
                }
            }

            if ((ped->x & 15) != 0)
            {
                ped->lError -= ped->lErrorDown * (16 - (ped->x & 15));
                ped->x += 15;       // We'll want the ceiling in just a bit...
            }

            // Chop off those fractional bits:

            ped->x      >>= 4;
            ped->lError >>= 4;
        }
    }

    cyTrapezoid = min(aed[LEFT].cy, aed[RIGHT].cy); // # of scans in this trap
    DISPDBG((FASTFILL_DBG_LEVEL, "%d cyTrapezoid =  %d\n",
                        __LINE__, cyTrapezoid));

    aed[LEFT].cy  -= cyTrapezoid;
    aed[RIGHT].cy -= cyTrapezoid;
    yTrapezoid    += cyTrapezoid;                   // Top scan in next trap

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((aed[LEFT].lErrorUp | aed[RIGHT].lErrorUp) == 0) &&
        ((aed[LEFT].dx       | aed[RIGHT].dx) == 0) &&
        (cyTrapezoid > 1))
    {
        LONG lWidth;

        /////////////////////////////////////////////////////////////////
        // Vertical-edge special case

    ContinueVertical:

        lWidth = aed[RIGHT].x - aed[LEFT].x - 1;
                DISPDBG((FASTFILL_DBG_LEVEL, "%d lWidth %x %x %x cyTrapezoid %x \n",
                                __LINE__, lWidth, aed[RIGHT].x, aed[LEFT].x, cyTrapezoid));
        if (lWidth >= 0)
        {
                DISPDBG((FASTFILL_DBG_LEVEL,"%d New x %x\n",__LINE__, aed[LEFT].x));
                REQUIRE(5);
//              REQUIRE(4);
                LL16(grOP0_opRDRAM.pt.X, aed[LEFT].x + ppdev->ptlOffset.x);
                LL_BLTEXT(lWidth + 1, cyTrapezoid);
                DISPDBG((FASTFILL_DBG_LEVEL, "DO a Blt %x\n",(cyTrapezoid << 16) | (lWidth + 1)));
                y += cyTrapezoid;
                DISPDBG((FASTFILL_DBG_LEVEL,"%d New y %x\n", __LINE__, y));
                LL16(grOP0_opRDRAM.pt.Y, y + ppdev->ptlOffset.y);
        }
        else if (lWidth == -1)
        {
            // If the rectangle was too thin to light any pels, we still
            // have to advance the y current position:
            y = yTrapezoid - cyTrapezoid + 1;
            DISPDBG((FASTFILL_DBG_LEVEL, "%d New y %x yTrap %x cyTrap %x\n",
                                __LINE__, y, yTrapezoid, cyTrapezoid));
            REQUIRE(1);
            LL16(grOP0_opRDRAM.pt.Y, y + ppdev->ptlOffset.y);
        }
        else
        {
            LONG      lTmp;
            POINTFIX* pptfxTmp;

            SWAP(aed[LEFT].x,          aed[RIGHT].x,          lTmp);
            SWAP(aed[LEFT].cy,         aed[RIGHT].cy,         lTmp);
            SWAP(aed[LEFT].dptfx,      aed[RIGHT].dptfx,      lTmp);
            SWAP(aed[LEFT].pptfx,      aed[RIGHT].pptfx,      pptfxTmp);
            goto ContinueVertical;
        }

        goto NewTrapezoid;
    }

    while (TRUE)
    {
        LONG lWidth;

        /////////////////////////////////////////////////////////////////
        // Run the DDAs

        // The very first time through, make sure we set x:

        lWidth = aed[RIGHT].x - aed[LEFT].x - 1;
        if (lWidth >= 0)
        {
            DISPDBG((FASTFILL_DBG_LEVEL,"%d New x %x\n", __LINE__, aed[LEFT].x));
            REQUIRE(5);
//          REQUIRE(4);
            LL16(grOP0_opRDRAM.pt.X, aed[LEFT].x + ppdev->ptlOffset.x);
            LL_BLTEXT(lWidth + 1, 1);
            DISPDBG((FASTFILL_DBG_LEVEL,"%d New y %x\n", __LINE__, y+1));
            LL16(grOP0_opRDRAM.pt.Y, ++y + ppdev->ptlOffset.y);

    ContinueAfterZero:

            // Advance the right wall:

            aed[RIGHT].x      += aed[RIGHT].dx;
            aed[RIGHT].lError += aed[RIGHT].lErrorUp;

            if (aed[RIGHT].lError >= 0)
            {
                aed[RIGHT].lError -= aed[RIGHT].lErrorDown;
                aed[RIGHT].x++;
            }

            // Advance the left wall:

            aed[LEFT].x      += aed[LEFT].dx;
            aed[LEFT].lError += aed[LEFT].lErrorUp;

            if (aed[LEFT].lError >= 0)
            {
                aed[LEFT].lError -= aed[LEFT].lErrorDown;
                aed[LEFT].x++;
            }

            cyTrapezoid--;
            if (cyTrapezoid == 0)
                goto NewTrapezoid;
        }
        else if (lWidth == -1)
        {
            y = yTrapezoid - cyTrapezoid + 1;
            DISPDBG((FASTFILL_DBG_LEVEL, "%d New y %x yTrap %x cyTrap %x\n",
                                __LINE__, y, yTrapezoid, cyTrapezoid));
            REQUIRE(1);
            LL16(grOP0_opRDRAM.pt.Y, (y + ppdev->ptlOffset.y) );
            goto ContinueAfterZero;
        }
        else
        {
            // We certainly don't want to optimize for this case because we
            // should rarely get self-intersecting polygons (if we're slow,
            // the app gets what it deserves):

            LONG      lTmp;
            POINTFIX* pptfxTmp;

            SWAP(aed[LEFT].x,          aed[RIGHT].x,          lTmp);
            SWAP(aed[LEFT].dx,         aed[RIGHT].dx,         lTmp);
            SWAP(aed[LEFT].lError,     aed[RIGHT].lError,     lTmp);
            SWAP(aed[LEFT].lErrorUp,   aed[RIGHT].lErrorUp,   lTmp);
            SWAP(aed[LEFT].lErrorDown, aed[RIGHT].lErrorDown, lTmp);
            SWAP(aed[LEFT].cy,         aed[RIGHT].cy,         lTmp);
            SWAP(aed[LEFT].dptfx,      aed[RIGHT].dptfx,      lTmp);
            SWAP(aed[LEFT].pptfx,      aed[RIGHT].pptfx,      pptfxTmp);

            continue;
        }
    }
    DISPDBG((FASTFILL_DBG_LEVEL,"Eof Exit %s %d\n", __FILE__, __LINE__));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\enable.c ===
/******************************Module*Header*******************************\
 *
 * Module Name: enable.c
 *
 * This module contains the functions that enable and disable the
 * driver, the pdev, and the surface.
 *
 * Copyright (c) 1995,1996 Cirrus Logic, Inc.
 *
 * $Log:   X:/log/laguna/nt35/displays/cl546x/ENABLE.C  $
* 
*    Rev 1.46   Jan 20 1998 11:44:38   frido
* The fDataStreaming flag has changed its value from 1 into 0x80000000.
* 
*    Rev 1.45   Nov 04 1997 10:12:24   frido
* Added IOCtl call to Miniport to get the AGPDataStreaming value.
* 
*    Rev 1.44   Nov 03 1997 15:21:46   frido
* Added REQUIRE macros.
* 
*    Rev 1.43   16 Oct 1997 09:55:04   bennyn
* 
* Added bPrevModeDDOutOfVideoMem to DrvResetPDEV
* 
*    Rev 1.42   08 Aug 1997 17:24:00   FRIDO
* Added support for new memory manager.
* 
*    Rev 1.41   02 Jul 1997 15:56:00   noelv
* Added LgMatchDriverToChip() function.  Moved driver/chip match from bin
* from binitSurface to DrvEnablePdev()
* 
*    Rev 1.40   29 Apr 1997 16:28:40   noelv
* 
* Merged in new SWAT code.
* SWAT: 
* SWAT:    Rev 1.3   24 Apr 1997 11:37:28   frido
* SWAT: NT140b09 merge.
* SWAT: 
* SWAT:    Rev 1.2   18 Apr 1997 00:15:02   frido
* SWAT: NT140b07 merge.
* SWAT: 
* SWAT:    Rev 1.1   09 Apr 1997 17:32:34   frido
* SWAT: Called vAssertModeText in DrvAssertMode.
* 
*    Rev 1.39   09 Apr 1997 10:50:40   SueS
* Changed sw_test_flag to pointer_switch.
* 
*    Rev 1.38   09 Apr 1997 07:52:38   noelv
* Disabled the MCD code for NT 3.51
* 
*    Rev 1.37   08 Apr 1997 12:21:24   einkauf
* 
* new hooks for MCD when reset; add SYNC/IDLE for MCD/2D coordination
* 
*    Rev 1.36   21 Mar 1997 10:59:12   noelv
* 
* Combined the loggong flags into one ENABLE_LOGFILE flag.
* Removed PROFILE_DRIVER flag
* Added code to initialize QfreeData
* 
*    Rev 1.35   26 Feb 1997 13:19:42   noelv
* 
* Disable MCD code for NT 3.5x
* 
*    Rev 1.34   26 Feb 1997 09:22:10   noelv
* 
* Changed initial debugging message for 5465
* Added init code for MCD
* 
*    Rev 1.33   19 Feb 1997 13:15:32   noelv
* 
* Added translation table cache
* 
*    Rev 1.32   28 Jan 1997 16:18:42   bennyn
* Commented out "DrvEnableSurface failed bInitSurf" message
* 
*    Rev 1.31   06 Jan 1997 11:04:28   SueS
* Enabled DrvLineTo, since it's been fixed.
* 
*    Rev 1.30   18 Dec 1996 11:38:22   noelv
* 
* Unhooked DrvLineTo, 'cause it's broken.
* 
*    Rev 1.29   17 Dec 1996 16:53:24   SueS
* Added test for writing to log file based on cursor at (0,0).
* 
*    Rev 1.28   27 Nov 1996 11:32:44   noelv
* Disabled Magic Bitmap.  Yeah!!!
* 
*    Rev 1.27   26 Nov 1996 10:16:58   SueS
* Changed WriteLogFile parameters for buffering.
* 
*    Rev 1.26   13 Nov 1996 16:58:14   SueS
* Changed WriteFile calls to WriteLogFile.
* 
*    Rev 1.25   13 Nov 1996 08:17:18   noelv
* 
* Disabled test blt.
* 
*    Rev 1.24   07 Nov 1996 16:11:54   bennyn
* 
* Restore lost version (add drvresetPDEV support)
* 
*    Rev 1.23   31 Oct 1996 11:15:40   noelv
* 
* Split common buffer into two buffers.
* 
*    Rev 1.22   24 Oct 1996 14:40:38   noelv
* Demo bus master capabilities of 5464
* 
*    Rev 1.20   06 Sep 1996 08:55:02   noelv
* Hooked DrvStrokeAndFillPath and DrvStretchBlt when doinng analysis.
* 
*    Rev 1.19   20 Aug 1996 11:03:24   noelv
* Bugfix release from Frido 8-19-96
* 
*    Rev 1.3   18 Aug 1996 22:48:36   frido
* #lineto - Added DrvLineTo.
* 
*    Rev 1.2   15 Aug 1996 12:09:34   frido
* Fixed NT 3.51/4.0 in DrvEnablePDEV.
* 
*    Rev 1.1   15 Aug 1996 11:42:40   frido
* Added precompiled header.
* 
*    Rev 1.0   14 Aug 1996 17:16:20   frido
* Initial revision.
* 
*    Rev 1.18   07 Aug 1996 09:34:04   noelv
* 
* re-hooked textout
* 
*    Rev 1.17   25 Jul 1996 15:57:44   bennyn
* 
* Modified for DirectDraw
* 
*    Rev 1.16   12 Jul 1996 09:38:22   bennyn
* Added getdisplayduration call for DirectDraw
* 
*    Rev 1.15   11 Jul 1996 15:53:50   bennyn
* 
* Added DirectDraw support
* 
*    Rev 1.14   17 May 1996 12:55:34   bennyn
* Fixed the problem NT40 allocate 400x90 twice
* 
*    Rev 1.13   16 May 1996 14:54:22   noelv
* Added logging code.
* 
*    Rev 1.12   01 May 1996 12:06:44   bennyn
* 
* Fixed resolution change bug for NT 4.0
* 
*    Rev 1.11   01 May 1996 10:59:10   bennyn
* 
* Modified for NT4.0
* 
*    Rev 1.10   25 Apr 1996 22:39:50   noelv
* Cleaned up data logging.
 * 
 *    Rev 1.9   04 Apr 1996 13:20:14   noelv
 * Frido release 26
 * 
 *    Rev 1.13   02 Apr 1996 09:08:36   frido
 * Bellevue lg102b04 release.
 * 
 *    Rev 1.12   28 Mar 1996 20:02:18   frido
 * Added new comments.
 * 
 *    Rev 1.11   28 Mar 1996 20:01:00   frido
 * Fixed bouncing screeen when cursor is disabled.
 * 
 *    Rev 1.10   25 Mar 1996 12:05:34   frido
 * Changed #ifdef LOG_CALLS into #if LOG_CALLS.
 * Removed warning message.
 * 
 *    Rev 1.9   25 Mar 1996 11:52:46   frido
 * Bellevue 102B03.
 * 
 *    Rev 1.5   12 Mar 1996 15:45:28   noelv
 * Added support for data logging and stroke and fill.
 * 
 *    Rev 1.8   12 Mar 1996 16:50:14   frido
 * Added stroke and fill stuff.
 * 
 *    Rev 1.7   29 Feb 1996 20:23:24   frido
 * Added bEnable flag in PPDEV.
 * 
 *    Rev 1.6   29 Feb 1996 19:25:08   frido
 * Turned HOOK_TEXTOUT flags back on for 16-bpp modes and higher.
 * 
 *    Rev 1.5   27 Feb 1996 16:38:10   frido
 * Added device bitmap store/restore.
 * 
 *    Rev 1.4   24 Feb 1996 01:24:18   frido
 * Added device bitmaps.
 * 
 *    Rev 1.3   03 Feb 1996 13:40:24   frido
 * Use the compile switch "-Dfrido=0" to disable my extensions.
 * 
 *    Rev 1.2   23 Jan 1996 15:14:26   frido
 * Added call to DrvDestroyFont.
 *
\**************************************************************************/

#include "precomp.h"
#include "SWAT.h"
#include "CLIOCtl.h"

// The driver function table with all function index/address pairs

static DRVFN gadrvfn[] =
{
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode         },
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette         },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor        },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes           },

//
//  Laguna Functions:
//
   {   INDEX_DrvMovePointer,           (PFN) DrvMovePointer        },
   {   INDEX_DrvSetPointerShape,       (PFN) DrvSetPointerShape    },
   {   INDEX_DrvSynchronize,           (PFN) DrvSynchronize        },
   {   INDEX_DrvStretchBlt,            (PFN) DrvStretchBlt         },
   {   INDEX_DrvSaveScreenBits,        (PFN) DrvSaveScreenBits     },
   {   INDEX_DrvRealizeBrush,          (PFN) DrvRealizeBrush       },
   {   INDEX_DrvPaint,                 (PFN) DrvPaint              },
   {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt             },
   {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits           },
   {   INDEX_DrvTextOut,               (PFN) DrvTextOut            },
   {   INDEX_DrvDestroyFont,           (PFN) DrvDestroyFont	       },
   {   INDEX_DrvCreateDeviceBitmap,    (PFN) DrvCreateDeviceBitmap },
   {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DrvDeleteDeviceBitmap },
   {   INDEX_DrvFillPath,              (PFN) DrvFillPath           },
   {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath         },
#ifdef WINNT_VER40
   {   INDEX_DrvGetDirectDrawInfo,     (PFN) DrvGetDirectDrawInfo  },
   {   INDEX_DrvEnableDirectDraw,      (PFN) DrvEnableDirectDraw   },
   {   INDEX_DrvDisableDirectDraw,     (PFN) DrvDisableDirectDraw  },
   {   INDEX_DrvLineTo,                (PFN) DrvLineTo             },
   {   INDEX_DrvResetPDEV,             (PFN) DrvResetPDEV          },
   #define LGHOOK_LINETO HOOK_LINETO
#else
   #define LGHOOK_LINETO 0
#endif


//
// We don't accelerate DrvStrokeAndFillPath or DrvStrethcBlt.  
// But we do want to hook them if we're doing driver analysis.
//
#if NULL_STROKEFILL 
   {   INDEX_DrvStrokeAndFillPath,     (PFN) DrvStrokeAndFillPath  },
   #define LGHOOK_STROKEANDFILLPATH HOOK_STROKEANDFILLPATH
#else
   #define LGHOOK_STROKEANDFILLPATH 0
#endif

#if NULL_STRETCH 
   {   INDEX_DrvStretchBlt,            (PFN) DrvStretchBlt         },
   #define LGHOOK_STRETCHBLT HOOK_STRETCHBLT
#else
   #define LGHOOK_STRETCHBLT 0
#endif    
};


//
// Define the functions you want to hook for 8/16/24/32 pel formats
// We do not need to set HOOK_SYNCHRONIZEACCESS because we only support a
// single surface at the moment.  GDI only permits one thread to draw to
// a surface at a time.
// When we impliment device bitmaps, we may need to set this.
//
#define HOOKS_BMF8BPP (HOOK_BITBLT | HOOK_PAINT | HOOK_COPYBITS | HOOK_TEXTOUT \
		      | HOOK_STROKEPATH | LGHOOK_LINETO | HOOK_FILLPATH \
		      | LGHOOK_STROKEANDFILLPATH | LGHOOK_STRETCHBLT \
		      | HOOK_SYNCHRONIZE | HOOK_SYNCHRONIZEACCESS )

#define HOOKS_BMF16BPP  HOOKS_BMF8BPP
#define HOOKS_BMF24BPP  HOOKS_BMF8BPP
#define HOOKS_BMF32BPP  HOOKS_BMF8BPP


#if DRIVER_5465
    #define _DISP_ "CL5465.DLL"
#else
    #define _DISP_ "CL546x.DLL"
#endif

/******************************Public*Routine******************************\
* DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

BOOL DrvEnableDriver(
ULONG iEngineVersion,
ULONG cj,
PDRVENABLEDATA pded)
{
// Engine Version is passed down so future drivers can support previous
// engine versions.  A next generation driver can support both the old
// and new engine conventions if told what version of engine it is
// working with.  For the first version the driver does nothing with it.

    iEngineVersion;

// Fill in as much as we can.

#ifdef WINNT_VER40
    #if DRIVER_5465
        DISPDBG((1, " ==> Cirrus Logic 5465 DISPLAY DRIVER for NT 4.0.\n"));
    #else // if DRIVER_5465
        DISPDBG((1, " ==> Cirrus Logic 546x DISPLAY DRIVER for NT 4.0.\n"));
    #endif // if DRIVER_5465
#else
    #if DRIVER_5465
        DISPDBG((1, " ==> Cirrus Logic 5465 DISPLAY DRIVER for NT 3.5x.\n"));
    #else // if DRIVER_5465
        DISPDBG((1, " ==> Cirrus Logic 546x DISPLAY DRIVER for NT 3.5x.\n"));
    #endif // if DRIVER_5465
#endif

    if (cj >= sizeof(DRVENABLEDATA))
	pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
	pded->c = sizeof(gadrvfn) / sizeof(DRVFN);

// DDI version this driver was targeted for is passed back to engine.
// Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
	pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;

    return(TRUE);
}

/******************************Public*Routine******************************\
* DrvDisableDriver
*
* Tells the driver it is being disabled. Release any resources allocated in
* DrvEnableDriver.
*
\**************************************************************************/

VOID DrvDisableDriver(VOID)
{
    DISPDBG((1, _DISP_ " DrvDisableDriver\n"));
    return;
}

/******************************Public*Routine******************************\
* DrvEnablePDEV
*
* DDI function, Enables the Physical Device.
*
* Return Value: device handle to pdev.
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
DEVMODEW   *pDevmode,       // Pointer to DEVMODE
PWSTR       pwszLogAddress, // Logical address
ULONG       cPatterns,      // number of patterns
HSURF      *ahsurfPatterns, // return standard patterns
ULONG       cjGdiInfo,      // Length of memory pointed to by pGdiInfo
ULONG      *pGdiInfo,       // Pointer to GdiInfo structure
ULONG       cjDevInfo,      // Length of following PDEVINFO structure
DEVINFO    *pDevInfo,       // physical device information structure
#ifdef WINNT_VER40
HDEV		hdev,
#else
PWSTR       pwszDataFile,   // DataFile - not used
#endif
PWSTR       pwszDeviceName, // DeviceName - not used
HANDLE      hDriver)        // Handle to base driver
{
    GDIINFO GdiInfo;
    DEVINFO DevInfo;
    PPDEV   ppdev = (PPDEV) NULL;

    DISPDBG((1, _DISP_ " DrvEnablePDEV: Entry.\n"));

    // Allocate a physical device structure.
    #ifdef WINNT_VER40
        ppdev = (PPDEV) MEM_ALLOC(FL_ZERO_MEMORY, sizeof(PDEV), ALLOC_TAG);
    #else
        ppdev = (PPDEV) MEM_ALLOC(LMEM_FIXED | LMEM_ZEROINIT, sizeof(PDEV));
    #endif

    if (ppdev == (PPDEV) NULL)
    {
        RIP(_DISP_ " DrvEnablePDEV failed MEM_ALLOC\n");
        return((DHPDEV) 0);
    }

    // Save the screen handle in the PDEV.
    ppdev->hDriver = hDriver;
    ppdev->pjScreen = 0;

   	//
    // Verify the driver matches the chip.
    //
    if (!LgMatchDriverToChip(ppdev))
    {
        #if DRIVER_5465
            DISPDBG((1," Chip doesn't match CL5465 driver.  Failing.\n"));
        #else
            DISPDBG((1," Chip doesn't match CL546x driver.  Failing.\n"));
        #endif
        goto error_free;
    }

    // Init MCD.
    #ifndef WINNT_VER35
        ppdev->hMCD = NULL;
        ppdev->NumMCDContexts = 0;
    #endif

    // Initialize the offscreen manager initial flag to FALSE
    ppdev->OFM_init = FALSE;

    // Initialize the color translation caches to NULL
    ppdev->XlateCache = NULL;

    // Initialize the pofmMagic to NULL
    #if WINBENCH96
        ppdev->pofmMagic = NULL;
    #endif

	#if DATASTREAMING
	{
		ULONG	ulReturn;
		BOOL	fDataStreaming = FALSE;

		if (! DEVICE_IO_CTRL(ppdev->hDriver,
							 IOCTL_GET_AGPDATASTREAMING,
							 NULL,
							 0,
							 (PVOID) &fDataStreaming,
							 sizeof(fDataStreaming),
							 &ulReturn,
							 NULL) )
		{
                        DISPDBG( (1, _DISP_ " DrvEnablePDEV: failed to get "
					  "AGPDataStreaming flag\n") );
			fDataStreaming = FALSE;	// default to OFF
		}
		ppdev->dwDataStreaming = fDataStreaming ? 0x80000000 : 0;
	}
	#endif

    // Get the current screen mode information.  Set up device caps and devinfo.
    if (!bInitPDEV(ppdev, pDevmode, &GdiInfo, &DevInfo))
    {
        DISPDBG((1,_DISP_ " DrvEnablePDEV: bInitPDEV failed\n"));
        goto error_free;
    }

    // Initialize palette information.
    if (!bInitPaletteInfo(ppdev, &DevInfo))
    {
        RIP(_DISP_ " DrvEnablePDEV: failed bInitPalette\n");
        goto error_free;
    }

    // Initialize device standard patterns.
    if (!bInitPatterns(ppdev, min(cPatterns, HS_DDI_MAX)))
    {
        RIP(_DISP_ " DrvEnablePDEV: failed bInitPatterns\n");
        vDisablePatterns(ppdev);
        vDisablePalette(ppdev);
        goto error_free;
    }

    // Copy the devinfo into the engine buffer.
    memcpy(pDevInfo, &DevInfo, min(sizeof(DEVINFO), cjDevInfo));

    // Set the ahsurfPatterns array to handles each of the standard
    // patterns that were just created.
    memcpy((PVOID)ahsurfPatterns, ppdev->ahbmPat, ppdev->cPatterns*sizeof(HBITMAP));

    // Set the pdevCaps with GdiInfo we have prepared to the list of caps for this
    // pdev.
    memcpy(pGdiInfo, &GdiInfo, min(cjGdiInfo, sizeof(GDIINFO)));

    #if ENABLE_LOG_FILE
    {
        char buf[256];
        int i1;

        #if ENABLE_LOG_SWITCH
            if (pointer_switch == 1)
        #endif
        {
           DISPDBG((1, _DISP_ " Creating log file.\n"));
           CreateLogFile(ppdev->hDriver, &ppdev->TxtBuffIndex);
           ppdev->pmfile = ppdev->hDriver;   // handle to the miniport

           if (ppdev->pmfile == (HANDLE)-1)  // INVALID_HANDLE_VALUE
 	       RIP( _DISP_ " Couldn't create log file!\n");

           i1 = sprintf(buf, _DISP_ " Log file opened.\r\n");
           WriteLogFile(ppdev->pmfile, buf, i1, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
        }

    }
    #endif
    #if LOG_QFREE
    {
        int i;
        for (i=0; i<32; ++i)
            QfreeData[i] = 0;
    }
    #endif

    DISPDBG((1, _DISP_ " DrvEnablePDEV: Succeeded.\n"));
    return((DHPDEV) ppdev);

    // Error case for failure.
error_free:
    MEMORY_FREE(ppdev);
    DISPDBG((1, _DISP_ " DrvEnablePDEV: Failed.\n"));
    return((DHPDEV) 0);
}

/******************************Public*Routine******************************\
* DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV  hdev)
{
    DISPDBG((1, _DISP_ " DrvCompletePDEV\n"));
    ((PPDEV) dhpdev)->hdevEng = hdev;
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
\**************************************************************************/

VOID DrvDisablePDEV(
DHPDEV dhpdev)
{
    PPDEV ppdev;

    DISPDBG((1, _DISP_ " DrvDisablePDEV\n"));

    ppdev = (PPDEV) dhpdev;

    vDisablePalette((PPDEV) dhpdev);
    vDisablePatterns((PPDEV) dhpdev);

    MEMORY_FREE(dhpdev);
}

/******************************Public*Routine******************************\
* DrvEnableSurface
*
* Enable the surface for the device.  Hook the calls this driver supports.
*
* Return: Handle to the surface if successful, 0 for failure.
*
\**************************************************************************/

HSURF DrvEnableSurface(
DHPDEV dhpdev)
{
    PPDEV ppdev;
    HSURF hsurf;
    SIZEL sizl;
    ULONG ulBitmapType;
    FLONG flHooks;

    DISPDBG((1, _DISP_ " DrvEnableSurface Entry.\n"));

    // Create engine bitmap around frame buffer.

    ppdev = (PPDEV) dhpdev;


    if (!bInitSURF(ppdev, TRUE))
    {
        // Comments out this message because new two drivers model will break
        // here every time from power-up.
        //	RIP(_DISP_ " DrvEnableSurface failed bInitSURF\n");
        goto ReturnFailure;
    }

#ifdef WINNT_VER40
	ppdev->pvTmpBuffer = MEM_ALLOC(0, TMP_BUFFER_SIZE, ALLOC_TAG);
#else
	ppdev->pvTmpBuffer = VirtualAlloc(NULL, TMP_BUFFER_SIZE, MEM_RESERVE |
									  MEM_COMMIT, PAGE_READWRITE);
#endif

	if (ppdev->pvTmpBuffer == NULL)
	{
                DISPDBG((1, _DISP_ " DrvEnableSurface - Failed VirtualAlloc"));
		goto ReturnFailure;
	}

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    if (ppdev->ulBitCount == 8)
    {
	if (!bInit256ColorPalette(ppdev)) {
	    RIP(_DISP_ " DrvEnableSurface failed to init the 8bpp palette\n");
		goto ReturnFailure;
	}
	ulBitmapType = BMF_8BPP;
	flHooks = HOOKS_BMF8BPP;
    }
    else if (ppdev->ulBitCount == 16)
    {
	ulBitmapType = BMF_16BPP;
	flHooks = HOOKS_BMF16BPP;
    }
    else if (ppdev->ulBitCount == 24)
    {
	ulBitmapType = BMF_24BPP;
	flHooks = HOOKS_BMF24BPP;
    }
    else
    {
	ulBitmapType = BMF_32BPP;
	flHooks = HOOKS_BMF32BPP;
    }

    hsurf = (HSURF) EngCreateBitmap(sizl,
				    ppdev->lDeltaScreen,
				    ulBitmapType,
				    (ppdev->lDeltaScreen > 0) ? BMF_TOPDOWN : 0,
					(PVOID) (ppdev->pjScreen));

    if (hsurf == (HSURF) 0)
    {
	RIP(_DISP_ " DrvEnableSurface failed EngCreateBitmap\n");
		goto ReturnFailure;
    }

	ppdev->bEnable = TRUE;

    if (!EngAssociateSurface(hsurf, ppdev->hdevEng, flHooks))
    {
	RIP(_DISP_ " DrvEnableSurface failed EngAssociateSurface\n");
	EngDeleteSurface(hsurf);
		goto ReturnFailure;
    }

    ppdev->hsurfEng = hsurf;
    ppdev->iBitmapFormat = ulBitmapType;

    if (!bEnableText(ppdev))
	goto ReturnFailure;

#ifdef WINNT_VER40
   // Accurately measure the refresh rate for DirectDraw use
   vGetDisplayDuration(&ppdev->flipRecord);
#endif


    //
    // Demo HostToScreen BLT
    //
    #if BUS_MASTER
    if (ppdev->BufLength)
    {
        unsigned long i;
        unsigned long temp;
        DWORD *bufD = (DWORD *)ppdev->Buf1VirtAddr;


        //
        // init the buffer.
        //
        for (i=0; i<ppdev->BufLength/4; ++i)
            bufD[i] = 0x87654321;

        DISPDBG((1, _DISP_ " bInitSurf: \n\n **** TestBLT **** \n"));

        // Enable the HOST XY unit.
        LL32(grHXY_HOST_CRTL_3D, 1);

        // Write host address.
        LL32(grHXY_BASE1_ADDRESS_PTR_3D, ppdev->Buf1PhysAddr);

        // Offset into host buffer is 0
        LL32(grHXY_BASE1_OFFSET0_3D, 0);
        LL32(grHXY_BASE1_OFFSET1_3D, 0);

        // Setup 2D engine.
		REQUIRE(8);
        LL16 (grBLTDEF, 0x1020);  // OP1 is host, RES is screen 
        LL16 (grDRAWDEF, 0xCC);   // SRCCPY

        // Source and destination XY address.
        LL16 (grOP1_opRDRAM.pt.X, 0); // source phase
        LL16 (grOP0_opRDRAM.pt.X, 0); // Destination x = 0;
        LL16 (grOP0_opRDRAM.pt.Y, 0); // Destination y = 0;

        // Size of destination rectangle.
        // This starts the 2D engine.
        LL16 (grMBLTEXT_EX.pt.X, 128);  // Width
        LL16 (grBLTEXT_EX.pt.Y, 16);    // Height

        // Write the length of the host data (in bytes)
        // This starts the Host XY unit.
        LL32(grHXY_BASE1_LENGTH_3D, ppdev->BufLength);


        //
        // Wait until HOST XY unit goes idle.
        //
        do {
            temp = LLDR_SZ (grPF_STATUS_3D);
        } while (temp & 0x80);

        DISPDBG((1, _DISP_ "        PF_STATUS: 0x%08X\n", temp));

    }
    #endif

    DISPDBG((1, _DISP_ " DrvEnableSurface Exit.\n"));
    return(hsurf);

ReturnFailure:
    DrvDisableSurface((DHPDEV) ppdev);

    DISPDBG((1, _DISP_ " Failed DrvEnableSurface"));

    return(0);
}

/******************************Public*Routine******************************\
* DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
\**************************************************************************/

VOID DrvDisableSurface(
DHPDEV dhpdev)
{
    PPDEV ppdev;

    DISPDBG((1, _DISP_ " DrvDisableSurface Entry.\n"));

    ppdev = (PPDEV) dhpdev;

    ENSURE_3D_IDLE(ppdev);  

#ifdef WINNT_VER40
	MEMORY_FREE(((PPDEV) dhpdev)->pvTmpBuffer);
#else
	VirtualFree(((PPDEV) dhpdev)->pvTmpBuffer, 0, MEM_RELEASE);
#endif

    // Close the offscreen manager
    CloseOffScnMem((PPDEV) dhpdev);

#ifdef WINNT_VER40
   if (ppdev->CShsem != NULL)
   	EngDeleteSemaphore(ppdev->CShsem);
#else
    DeleteCriticalSection(&ppdev->PtrCritSec);
#endif

    EngDeleteSurface(((PPDEV) dhpdev)->hsurfEng);
    vDisableSURF((PPDEV) dhpdev);
    ((PPDEV) dhpdev)->hsurfEng = (HSURF) 0;
}

/******************************Public*Routine******************************\
* DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

#ifdef WINNT_VER40
BOOL APIENTRY DrvAssertMode(
#else
VOID DrvAssertMode(
#endif

DHPDEV dhpdev,
BOOL bEnable)
{
    PPDEV   ppdev = (PPDEV) dhpdev;
    ULONG   ulReturn;

    DISPDBG((1, _DISP_ " DrvAssertMode, en=%d\n",bEnable));

    ENSURE_3D_IDLE(ppdev);

    #ifndef WINNT_VER35
    if (ppdev->hMCD)
    {
        ppdev->pAssertModeMCD(ppdev,bEnable);
    }
    #endif

	ppdev->bEnable = bEnable;
    if (bEnable)
    {
    // The screen must be reenabled, reinitialize the device to clean state.

	    bInitSURF(ppdev, FALSE);

		#if SWAT3
		// Enable font cache.
		vAssertModeText(ppdev, TRUE);
		#endif
    }
    else
    {
	POFMHDL pofm, pofmNext;

	#if (HW_PRESET_BUG)
	    //
	    // Disable the HW cursor for real, since we are leaving graphics mode.
	    //
	    ULONG ultmp = LLDR_SZ (grCursor_Control);
	    ultmp &= 0xFFFE;
	    LL16 (grCursor_Control, ultmp);
	#endif

	#if 1 // SWAT3 - font cache removal is now in vAssertMoveText.
	// Disable font cache.
	vAssertModeText(ppdev, FALSE);
	#endif

	#if MEMMGR
	{
		// Hostify all device bitmaps.
		extern void HostifyAllBitmaps(PPDEV ppdev);
		HostifyAllBitmaps(ppdev);
	}
	#else
	// We have to move all off-screen device bitmaps to memory.
	for (pofm = ppdev->OFM_UsedQ; pofm; pofm = pofmNext)
	{
	    pofmNext = pofm->nexthdl;

	    if ( (pofm->pdsurf) && (pofm->pdsurf->pofm) )
	    {
	    	if (!bCreateDibFromScreen(ppdev, pofm->pdsurf))
	    	{
	    	    RIP("Error moving off-screen bitmap to DIB");
	    	    break;
	    	}
	    }
	}
	#endif
        // We must give up the display.
        // Call the kernel driver to reset the device to a known state.

	if (!DEVICE_IO_CTRL(ppdev->hDriver,
			     IOCTL_VIDEO_RESET_DEVICE,
			     NULL,
			     0,
			     NULL,
			     0,
			     &ulReturn,
			     NULL))
	{
	    RIP(_DISP_ " DrvAssertMode failed IOCTL");
	}
    }

#ifdef WINNT_VER40
    return TRUE;
#else
    return;
#endif
}

/******************************Public*Routine******************************\
* DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE hDriver,
ULONG cjSize,
DEVMODEW *pdm)

{

    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation, pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    DISPDBG((1, _DISP_ " DrvGetModes: Entry.\n"));

    cModes = getAvailableModes(hDriver,
			       (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
			       &cbModeSize);

    if (cModes == 0)
    {
            DISPDBG((1, _DISP_ " DrvGetModes failed to get mode information"));
        return 0;
    }

    if (pdm == NULL)
    {
	cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
	//
	// Now copy the information for the supported modes back into the output
	// buffer
	//

	cbOutputSize = 0;

	pVideoTemp = pVideoModeInformation;

	do
	{
	    if (pVideoTemp->Length != 0)
	    {
		if (cOutputModes == 0)
		{
		    break;
		}

		//
		// Zero the entire structure to start off with.
		//

		memset(pdm, 0, sizeof(DEVMODEW));

		//
		// Set the name of the device to the name of the DLL.
		//

		memcpy(&(pdm->dmDeviceName), L"cl546x", sizeof(L"cl546x"));

		pdm->dmSpecVersion = DM_SPECVERSION;
		pdm->dmDriverVersion = DM_SPECVERSION;

		//
		// We currently do not support Extra information in the driver
		//

		pdm->dmDriverExtra = DRIVER_EXTRA_SIZE;

		pdm->dmSize = sizeof(DEVMODEW);
		pdm->dmBitsPerPel = pVideoTemp->NumberOfPlanes *
				    pVideoTemp->BitsPerPlane;
		pdm->dmPelsWidth = pVideoTemp->VisScreenWidth;
		pdm->dmPelsHeight = pVideoTemp->VisScreenHeight;
		pdm->dmDisplayFrequency = pVideoTemp->Frequency;

#ifdef WINNT_VER40
	   pdm->dmDisplayFlags = 0;
	   pdm->dmFields = DM_BITSPERPEL       |
                      DM_PELSWIDTH        |
                      DM_PELSHEIGHT       |
                      DM_DISPLAYFREQUENCY |
                      DM_DISPLAYFLAGS     ;
#else
		if (pVideoTemp->AttributeFlags & VIDEO_MODE_INTERLACED)
		{
		    pdm->dmDisplayFlags |= DM_INTERLACED;
		}
#endif

		//
		// Go to the next DEVMODE entry in the buffer.
		//

		cOutputModes--;

		pdm = (LPDEVMODEW) ( ((ULONG)pdm) + sizeof(DEVMODEW) +
						   DRIVER_EXTRA_SIZE);

		cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

	    }

	    pVideoTemp = (PVIDEO_MODE_INFORMATION)
		(((PUCHAR)pVideoTemp) + cbModeSize);

	} while (--cModes);
    }

    MEMORY_FREE(pVideoModeInformation);

    DISPDBG((1, _DISP_ " DrvGetModes: Exit.\n"));
    return cbOutputSize;

}


/**************************************************************************\
* DrvResetPDEV
*
\**************************************************************************/

BOOL DrvResetPDEV(DHPDEV dhpdevOld, DHPDEV dhpdevNew)
{
    PPDEV ppdevOld, ppdevNew;

    DISPDBG((1, _DISP_ " DrvResetPDEV:\n"));

    ppdevOld = (PPDEV) dhpdevOld;
    ppdevNew = (PPDEV) dhpdevNew;

#ifndef WINNT_VER35

    ENSURE_3D_IDLE(ppdevOld);

    ppdevNew->iUniqueness = ppdevOld->iUniqueness + 1;
    ppdevNew->pAllocOffScnMem = AllocOffScnMem;
    ppdevNew->pFreeOffScnMem = FreeOffScnMem;

    ppdevNew->bPrevModeDDOutOfVideoMem = ppdevOld->bPrevModeDDOutOfVideoMem;

#endif // ndef WINNT_VER35

    return (TRUE);
};


/* ===========================================================================
*	LgMatchDriverToChip()                                                 
*
*	This driver code base compiles into several different DLLs, based on
*	what C Preprocessor symbols are defined at compile time.  This allows us
*	to build several different chip specific drivers from a single code base.
*
*	This function checks the Laguna chip ID and returns TRUE if the chip is
*	one supported by this DLL.
*
* ========================================================================== */
BOOL LgMatchDriverToChip(
    PPDEV ppdev
)
{
 	DWORD returnedDataLength;
	WORD DeviceID;
	VIDEO_PUBLIC_ACCESS_RANGES   VideoAccessRanges[2];
	BYTE *pLgREGS_PCI_ID;

	// Get a pointer to the HW registers.
	if (!DEVICE_IO_CTRL(ppdev->hDriver,
					 IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
					 NULL,                      // input buffer
					 0,
					 (PVOID) VideoAccessRanges, // output buffer
					 sizeof (VideoAccessRanges),
					 &returnedDataLength,
					 NULL))
	{
		RIP(_DISP_  "LgMatchDriverToChip - QUERY_PUBLIC_ACCESS_RANGES ioctl failed!\n");
		return (FALSE);
	}
	pLgREGS_PCI_ID = ((BYTE *)VideoAccessRanges[0].VirtualAddress) + 0x302;

    //Get the chip id.
    DeviceID =  *(WORD *)pLgREGS_PCI_ID;
        DISPDBG((1,_DISP_ " MatchDriverToChip: Chip ID is 0x%08X.\n",DeviceID));

	// Does this driver instance support this chip?
    #if DRIVER_5465
        // This is the 5465 driver.  Fail if not a 5465 or later.
        if (DeviceID < CL_GD5465)
        {
            return FALSE;
        }
    #else
        // This is the 546x driver.  Fail if a 5465 or later.
        if (DeviceID >= CL_GD5465)
        {
            return FALSE;
        }
	#endif

	return TRUE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\ddraw.c ===
/***************************************************************************
*
*                ******************************************
*                * Copyright (c) 1996, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:  Laguna I (CL-GD546x) -
*
* FILE:     ddraw.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module implements the DirectDraw components for the
*           Laguna NT driver.
*
* MODULES:
*           DdMapMemory()
*           DrvGetDirectDrawInfo()
*           DrvEnableDirectDraw()
*           DrvDisableDirectDraw()
*
* REVISION HISTORY:
*   7/12/96     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/ddraw.c  $
* 
*    Rev 1.25   Apr 16 1998 15:19:50   frido
* PDR#11160. The hardware is broken converting 16-bit YUV to 24-bit RGB.
* 
*    Rev 1.24   16 Sep 1997 15:01:24   bennyn
* 
* Modified for NT DD overlay
* 
*    Rev 1.23   29 Aug 1997 17:11:54   RUSSL
* Added overlay support
*
*    Rev 1.22   12 Aug 1997 16:57:10   bennyn
*
* Moved the DD scratch buffer allocation to bInitSurf()
*
*    Rev 1.21   11 Aug 1997 14:06:10   bennyn
* Added DDCAPS_READSCANLINE support (For PDR 10254)
*
****************************************************************************
****************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/
#include "precomp.h"
#include "clioctl.h"
//#include <driver.h>
//#include "laguna.h"

//
// This file isn't used in NT 3.51
//
#ifndef WINNT_VER35

/*----------------------------- DEFINES -----------------------------------*/
//#define DBGBRK
#define DBGLVL        1

// FourCC formats are encoded in reverse because we're little endian:
#define FOURCC_YUY2  '2YUY'  // Encoded in reverse because we're little endian

#define SQXINDEX (0x3c4)
#define RDRAM_INDEX (0x0a)
#define BIT_9 (0x80)

/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/

/*-------------------------- STATIC VARIABLES -----------------------------*/

/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/

/****************************************************************************
* FUNCTION NAME: DdMapMemory
*
* DESCRIPTION:   This is a new DDI call specific to Windows NT that is
*                used to map or unmap all the application modifiable
*                portions of the frame buffer into the specified process's
*                address space.
****************************************************************************/
DWORD DdMapMemory(PDD_MAPMEMORYDATA lpMapMemory)
{
  PDEV*                           ppdev;
  VIDEO_SHARE_MEMORY              ShareMemory;
  VIDEO_SHARE_MEMORY_INFORMATION  ShareMemoryInformation;
  DWORD                           ReturnedDataLength;

  ppdev = (PDEV*) lpMapMemory->lpDD->dhpdev;

  DISPDBG((DBGLVL, "DDraw - DdMapMemory\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  ShareMemory.ProcessHandle = lpMapMemory->hProcess;

  if (lpMapMemory->bMap)
  {
     // 'RequestedVirtualAddress' isn't actually used for the SHARE IOCTL:
     ShareMemory.RequestedVirtualAddress = 0;

     // We map in starting at the top of the frame buffer:
     ShareMemory.ViewOffset = 0;

     // We map down to the end of the frame buffer.
     //
     // Note: There is a 64k granularity on the mapping (meaning that
     //       we have to round up to 64k).
     //
     // Note: If there is any portion of the frame buffer that must
     //       not be modified by an application, that portion of memory
     //       MUST NOT be mapped in by this call.  This would include
     //       any data that, if modified by a malicious application,
     //       would cause the driver to crash.  This could include, for
     //       example, any DSP code that is kept in off-screen memory.

// v-normmi
// ShareMemory.ViewSize = ROUND_UP_TO_64K(ppdev->cyMemory * ppdev->lDeltaScreen);
   ShareMemory.ViewSize = ROUND_UP_TO_64K(ppdev->cyMemoryReal * ppdev->lDeltaScreen);

     if (EngDeviceIoControl(ppdev->hDriver,
                            IOCTL_VIDEO_SHARE_VIDEO_MEMORY,
                            &ShareMemory,
                            sizeof(VIDEO_SHARE_MEMORY),
                            &ShareMemoryInformation,
                            sizeof(VIDEO_SHARE_MEMORY_INFORMATION),
                            &ReturnedDataLength))
     {
         DISPDBG((0, "DDraw - Failed IOCTL_VIDEO_SHARE_MEMORY"));

         lpMapMemory->ddRVal = DDERR_GENERIC;
         return(DDHAL_DRIVER_HANDLED);
     };

     lpMapMemory->fpProcess = (DWORD) ShareMemoryInformation.VirtualAddress;
  }
  else
  {
     ShareMemory.ViewOffset    = 0;
     ShareMemory.ViewSize      = 0;
     ShareMemory.RequestedVirtualAddress = (VOID*) lpMapMemory->fpProcess;

     if (EngDeviceIoControl(ppdev->hDriver,
                            IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY,
                            &ShareMemory,
                            sizeof(VIDEO_SHARE_MEMORY),
                            NULL,
                            0,
                            &ReturnedDataLength))
     {
         DISPDBG((0, "DDraw - Failed IOCTL_VIDEO_SHARE_MEMORY"));
     };
  };

  lpMapMemory->ddRVal = DD_OK;

  return(DDHAL_DRIVER_HANDLED);
}


/****************************************************************************
* FUNCTION NAME: DrvGetDirectDrawInfo
*
* DESCRIPTION:   Will be called before DrvEnableDirectDraw is called.
****************************************************************************/
BOOL DrvGetDirectDrawInfo(DHPDEV       dhpdev,
                          DD_HALINFO*  pHalInfo,
                          DWORD*       pdwNumHeaps,
                          VIDEOMEMORY* pvmList,   // Will be NULL on 1st call
                          DWORD*       pdwNumFourCC,
                          DWORD*       pdwFourCC) // Will be NULL on 1st call
{
  BOOL        bCanFlip;
  PDEV*       ppdev = (PDEV*) dhpdev;
  DRIVERDATA* pDriverData = (DRIVERDATA*) &ppdev->DriverData;
  POFMHDL     pds = NULL;

  DISPDBG((DBGLVL, "DDraw - DrvGetDirectDrawInfo\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  pHalInfo->dwSize = sizeof(DD_HALINFO);

  // Current primary surface attributes. Since HalInfo is zero-initialized
  // by GDI, we only have to fill in the fields which should be non-zero:
  pHalInfo->vmiData.pvPrimary       = ppdev->pjScreen;
  pHalInfo->vmiData.dwDisplayWidth  = ppdev->cxScreen;
  pHalInfo->vmiData.dwDisplayHeight = ppdev->cyScreen;
  pHalInfo->vmiData.lDisplayPitch   = ppdev->lDeltaScreen;

  pHalInfo->vmiData.ddpfDisplay.dwSize  = sizeof(DDPIXELFORMAT);
  pHalInfo->vmiData.ddpfDisplay.dwFlags = DDPF_RGB;

  pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount = ppdev->ulBitCount;

  if (ppdev->iBitmapFormat == BMF_8BPP)
     pHalInfo->vmiData.ddpfDisplay.dwFlags |= DDPF_PALETTEINDEXED8;

  // These masks will be zero at 8bpp:
  pHalInfo->vmiData.ddpfDisplay.dwRBitMask = ppdev->flRed;
  pHalInfo->vmiData.ddpfDisplay.dwGBitMask = ppdev->flGreen;
  pHalInfo->vmiData.ddpfDisplay.dwBBitMask = ppdev->flBlue;

  // Set up the pointer to the first available video memory after
  // the primary surface:
  bCanFlip     = FALSE;
  *pdwNumHeaps = 0;

  // Free up as much off-screen memory as possible:
  // Now simply reserve the biggest chunk for use by DirectDraw:
  if ((pds = ppdev->DirectDrawHandle) == NULL)
  {
#if DRIVER_5465
    pds = DDOffScnMemAlloc(ppdev);
    ppdev->DirectDrawHandle = pds;
#else
     // Because the 24 BPP transparent BLT is broken, punt it
     if (ppdev->iBitmapFormat != BMF_24BPP)
     {
        pds = DDOffScnMemAlloc(ppdev);
        ppdev->DirectDrawHandle = pds;
     };
#endif  // DRIVER_5465
  };

  if (pds != NULL)
  {
     *pdwNumHeaps = 1;

     // Fill in the list of off-screen rectangles if we've been asked
     // to do so:
     if (pvmList != NULL)
     {
        DISPDBG((0, "DirectDraw gets %li x %li surface at (%li, %li)\n",
                     pds->sizex,
                     pds->sizey,
                     pds->x,
                     pds->y));

        pvmList->dwFlags  = VIDMEM_ISRECTANGULAR;
        pvmList->fpStart  = (pds->y * ppdev->lDeltaScreen) + pds->x;

        pvmList->dwWidth  = pds->sizex;
        pvmList->dwHeight = pds->sizey;
        pvmList->ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;

        if ((DWORD) ppdev->cyScreen <= pvmList->dwHeight)
           bCanFlip = TRUE;

     }; // if (pvmList != NULL)
//#ifdef ALLOC_IN_CREATESURFACE
//  }
//  else
//  {
//     *pdwNumHeaps = 1;
//
//     // Fill in the list of off-screen rectangles if we've been asked
//     // to do so:
//     if (pvmList != NULL)
//     {
//        pvmList->dwFlags  = VIDMEM_ISRECTANGULAR;
//        pvmList->fpStart  = (FLATPTR) ppdev->pjScreen;
//
//        pvmList->dwWidth  = 1;
//        pvmList->dwHeight = ppdev->lTotalMem;
//        pvmList->ddsCaps.dwCaps = 0;
//        pvmList->ddsCapsAlt.dwCaps = 0;
//     }; // if (pvmList != NULL)
//#endif
  }; // if (pds != NULL)

  // Capabilities supported:
  pHalInfo->ddCaps.dwCaps = 0
                          | DDCAPS_BLT
                          | DDCAPS_BLTCOLORFILL
						  ;

#if 1 // PDR#11160
  if (ppdev->iBitmapFormat != BMF_24BPP)
		pHalInfo->ddCaps.dwCaps |= DDCAPS_BLTFOURCC;
#endif

  // ReadScanLine only support in 5464 & 5465
  if (ppdev->dwLgDevID >= CL_GD5464)
     pHalInfo->ddCaps.dwCaps |= DDCAPS_READSCANLINE;

  #if DRIVER_5465
      pHalInfo->ddCaps.dwCaps = pHalInfo->ddCaps.dwCaps
                                  | DDCAPS_BLTSTRETCH
                                  ;

      if (ppdev->iBitmapFormat != BMF_24BPP)
      {
          pHalInfo->ddCaps.dwCaps = pHalInfo->ddCaps.dwCaps
                                  | DDCAPS_COLORKEY // NVH turned off for 24bpp  PDR #10142
                                  | DDCAPS_COLORKEYHWASSIST // NVH turned off for 24bpp PDR #10142
                                  ;
      }
  #else
      if (ppdev->iBitmapFormat != BMF_24BPP)
      {
         pHalInfo->ddCaps.dwCaps = pHalInfo->ddCaps.dwCaps
                                 | DDCAPS_COLORKEY
                                 | DDCAPS_COLORKEYHWASSIST;

         if (ppdev->iBitmapFormat != BMF_32BPP)
         {
            pHalInfo->ddCaps.dwCaps |= DDCAPS_BLTSTRETCH;
         };
      };
  #endif  // DRIVER_5465

  pHalInfo->ddCaps.dwCKeyCaps = 0;
  if (ppdev->iBitmapFormat != BMF_24BPP)
  {
      pHalInfo->ddCaps.dwCKeyCaps = pHalInfo->ddCaps.dwCKeyCaps
                                  | DDCKEYCAPS_SRCBLT   // NVH Turn off for 24bpp. PDR #10142
                                  | DDCKEYCAPS_DESTBLT  // NVH Turn off for 24bpp. PDR #10142
                                  ;
  }

  pHalInfo->ddCaps.ddsCaps.dwCaps = 0
                                  | DDSCAPS_OFFSCREENPLAIN
                                  | DDSCAPS_PRIMARYSURFACE
                                  ;
#ifndef ALLOC_IN_CREATESURFACE
  if (bCanFlip)
#endif
     pHalInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_FLIP;

#ifdef ALLOC_IN_CREATESURFACE
  // Since we do our own memory allocation, we have to set dwVidMemTotal
  // ourselves.  Note that this represents the amount of available off-
  // screen memory, not all of video memory:
  pHalInfo->ddCaps.dwVidMemFree = ppdev->lTotalMem -
                 (ppdev->cxScreen * ppdev->cyScreen * ppdev->iBytesPerPixel);

  pHalInfo->ddCaps.dwVidMemTotal = pHalInfo->ddCaps.dwVidMemFree;
#endif

#if DRIVER_5465
  pHalInfo->ddCaps.dwFXCaps = 0
                            | DDFXCAPS_BLTARITHSTRETCHY
                            | DDFXCAPS_BLTSTRETCHX
                            | DDFXCAPS_BLTSTRETCHXN
                            | DDFXCAPS_BLTSTRETCHY
                            | DDFXCAPS_BLTSTRETCHYN
                            | DDFXCAPS_BLTSHRINKX
                            | DDFXCAPS_BLTSHRINKY
                            ;
#else
  if ((ppdev->iBitmapFormat != BMF_24BPP) &&
      (ppdev->iBitmapFormat != BMF_32BPP))
  {
     pHalInfo->ddCaps.dwFXCaps = 0
                               | DDFXCAPS_BLTARITHSTRETCHY
                               | DDFXCAPS_BLTSTRETCHX
                               | DDFXCAPS_BLTSTRETCHXN
                               | DDFXCAPS_BLTSTRETCHY
                               | DDFXCAPS_BLTSTRETCHYN
                               | DDFXCAPS_BLTSHRINKX
                               | DDFXCAPS_BLTSHRINKY
                               ;
  };
#endif  // DRIVER_5465

  // FOURCCs supported
#if DRIVER_5465 && defined(OVERLAY)
  if (! QueryOverlaySupport(ppdev, ppdev->dwLgDevID))
#endif
  {
    *pdwNumFourCC = 1;
#if DRIVER_5465 && defined(OVERLAY)
    pDriverData->dwFourCC[0] = FOURCC_UYVY;
#else
    pDriverData->dwFourCC = FOURCC_UYVY;
#endif

    if (pdwFourCC != NULL)
    {
       *pdwFourCC = FOURCC_YUY2;
    }
  }

  // We have to tell DirectDraw our preferred off-screen alignment, even
  // if we're doing our own off-screen memory management:
  pHalInfo->vmiData.dwOffscreenAlign = 4;

  pHalInfo->vmiData.dwOverlayAlign = 0;
  pHalInfo->vmiData.dwTextureAlign = 0;
  pHalInfo->vmiData.dwZBufferAlign = 0;
  pHalInfo->vmiData.dwAlphaAlign = 0;

  pDriverData->RegsAddress = ppdev->pLgREGS;

#if DRIVER_5465 && defined(OVERLAY)
  if (QueryOverlaySupport(ppdev, ppdev->dwLgDevID))
  {
    // fill in overlay caps
    OverlayInit(ppdev, ppdev->dwLgDevID, NULL, pHalInfo);
  }
#endif

  return(TRUE);
} // DrvGetDirectDrawInfo


/****************************************************************************
* FUNCTION NAME: DrvEnableDirectDraw
*
* DESCRIPTION:   GDI calls this function to obtain pointers to the
*                DirectDraw callbacks that the driver supports.
****************************************************************************/
BOOL DrvEnableDirectDraw(DHPDEV               dhpdev,
                         DD_CALLBACKS*        pCallBacks,
                         DD_SURFACECALLBACKS* pSurfaceCallBacks,
                         DD_PALETTECALLBACKS* pPaletteCallBacks)
{
  SIZEL  sizl;
  PDEV*  ppdev = (PDEV*) dhpdev;
  DRIVERDATA* pDriverData = (DRIVERDATA*) &ppdev->DriverData;

  DISPDBG((DBGLVL, "DDraw - DrvEnableDirectDraw\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  #if (VS_CONTROL_HACK && DRIVER_5465)
  {
    DWORD ReturnedDataLength;

    DISPDBG((0,"DrvEnableDirectDraw: Enable MMIO for PCI config regs.\n"));
    // Send message to miniport to enable MMIO access of PCI registers
    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_ENABLE_PCI_MMIO,
                           NULL,
                           0,
                           NULL,
                           0,
                           &ReturnedDataLength))
    {
      RIP("DrvEnableDirectDraw failed IOCTL_VIDEO_ENABLE_PCI_MMIO");
    }
  }
  #endif

  pDriverData->ScreenAddress = ppdev->pjScreen;
  pDriverData->VideoBase = ppdev->pjScreen;

#if DRIVER_5465
#else  // for 5462 or 5464
  // Initialize the DRIVERDATA structure in PDEV
  pDriverData->PTAGFooPixel = 0;

  _outp(SQXINDEX, RDRAM_INDEX);
  pDriverData->fNineBitRDRAMS = _inp(SQXINDEX+1) & BIT_9 ? TRUE : FALSE;

  pDriverData->fReset = FALSE;
  pDriverData->DrvSemaphore = 0;
  pDriverData->EdgeTrim = 0;

  pDriverData->VideoSemaphore = 0;
  pDriverData->CurrentVideoFormat = 0;
  pDriverData->NumVideoSurfaces = 0;

  pDriverData->YUVTop  = 0;
  pDriverData->YUVLeft = 0;
  pDriverData->YUVXExt = 0;
  pDriverData->YUVYExt = 0;

  ppdev->offscr_YUV.SrcRect.left   = 0;
  ppdev->offscr_YUV.SrcRect.top    = 0;
  ppdev->offscr_YUV.SrcRect.right  = 0;
  ppdev->offscr_YUV.SrcRect.bottom = 0;
  ppdev->offscr_YUV.nInUse = 0;
  ppdev->offscr_YUV.ratio = 0;

  ppdev->bYUVuseSWPtr = TRUE;
#endif  // DRIVER_5465

  ppdev->bDirectDrawInUse = TRUE;

  // Setup DD Display list pointers
  BltInit (ppdev, FALSE);


  // Fill out the driver callback
  pCallBacks->dwFlags              = 0;

  pCallBacks->MapMemory            = DdMapMemory;
  pCallBacks->dwFlags              |= DDHAL_CB32_MAPMEMORY;

  pCallBacks->WaitForVerticalBlank = DdWaitForVerticalBlank;
  pCallBacks->dwFlags              |= DDHAL_CB32_WAITFORVERTICALBLANK;


  pCallBacks->CanCreateSurface     = CanCreateSurface;
  pCallBacks->dwFlags              |= DDHAL_CB32_CANCREATESURFACE;

  pCallBacks->CreateSurface        = CreateSurface;
  pCallBacks->dwFlags              |= DDHAL_CB32_CREATESURFACE;

// #ifdef  DDDRV_GETSCANLINE    //***********
  // ReadScanLine only support in 5464 & 5465
  if (ppdev->dwLgDevID >= CL_GD5464)
  {
     pCallBacks->GetScanLine       = GetScanLine;
     pCallBacks->dwFlags           |= DDHAL_CB32_GETSCANLINE;
  }
// #endif // DDDRV_GETSCANLINE   ************

  // Fill out the surface callback
  pSurfaceCallBacks->dwFlags       = 0;

#if DRIVER_5465
  pSurfaceCallBacks->Blt        = Blt65;
#else
  pSurfaceCallBacks->Blt        = DdBlt;
#endif  // DRIVER_5465

  pSurfaceCallBacks->dwFlags       |= DDHAL_SURFCB32_BLT;

  pSurfaceCallBacks->GetBltStatus  = DdGetBltStatus;
  pSurfaceCallBacks->dwFlags       |= DDHAL_SURFCB32_GETBLTSTATUS;

  pSurfaceCallBacks->Flip          = DdFlip;
  pSurfaceCallBacks->dwFlags       |= DDHAL_SURFCB32_FLIP;

  pSurfaceCallBacks->GetFlipStatus = DdGetFlipStatus;
  pSurfaceCallBacks->dwFlags       |= DDHAL_SURFCB32_GETFLIPSTATUS;

  pSurfaceCallBacks->Lock          = DdLock;
  pSurfaceCallBacks->dwFlags       |= DDHAL_SURFCB32_LOCK;

  pSurfaceCallBacks->Unlock        = DdUnlock;
  pSurfaceCallBacks->dwFlags       |= DDHAL_SURFCB32_UNLOCK;

  pSurfaceCallBacks->DestroySurface = DestroySurface;
  pSurfaceCallBacks->dwFlags       |= DDHAL_SURFCB32_DESTROYSURFACE;

#if DRIVER_5465 && defined(OVERLAY)
  if (QueryOverlaySupport(ppdev, ppdev->dwLgDevID))
  {
    // fill in overlay caps
    OverlayInit(ppdev, ppdev->dwLgDevID, pSurfaceCallBacks, NULL);
  }
#endif

  // Note that we don't call 'vGetDisplayDuration' here, for a couple of
  // reasons:
  //  o Because the system is already running, it would be disconcerting
  //    to pause the graphics for a good portion of a second just to read
  //    the refresh rate;
  //  o More importantly, we may not be in graphics mode right now.
  //
  // For both reasons, we always measure the refresh rate when we switch
  // to a new mode.

  return(TRUE);
}  // DrvEnableDirectDraw


/****************************************************************************
* FUNCTION NAME: DrvDisableDirectDraw
*
* DESCRIPTION:   GDI call this function when the last DirectDraw application
*                has finished running.
****************************************************************************/
VOID DrvDisableDirectDraw(DHPDEV dhpdev)
{
  DRIVERDATA* pDriverData;
  ULONG ultmp;

  PDEV* ppdev = (PDEV*) dhpdev;
  pDriverData = (DRIVERDATA*) &ppdev->DriverData;

  DISPDBG((DBGLVL, "DDraw - DrvDisableDirectDraw\n"));

#if 0
  #if (VS_CONTROL_HACK && DRIVER_5465)
  {
    // Clear bit 0 to disable PCI register MMIO access
    DISPDBG((0,"DrvDisableDirectDraw: Disable MMIO for PCI config regs.\n"));
    ppdev->grVS_CONTROL &= 0xFFFFFFFE;
    LL32 (grVS_Control, ppdev->grVS_CONTROL);
  }
  #endif
#endif

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

#if DRIVER_5465
#else  // for 5462 or 5464
  if (ppdev->bYUVuseSWPtr)
  {
     // Disable the Hw cursor by clearing the hw cursor enable
     // bit in CURSOR_CONTROL reg
     ultmp = LLDR_SZ (grCursor_Control);
     if (ultmp & 1)
     {
        ultmp &= 0xFFFE;
        LL16 (grCursor_Control, ultmp);
     };
  };
#endif  // DRIVER_5465

  // DirectDraw is done with the display, so we can go back to using
  // all of off-screen memory ourselves:
  DDOffScnMemRestore(ppdev);

  ppdev->bYUVSurfaceOn = FALSE;
  ppdev->bDirectDrawInUse = FALSE;

} // DrvDisableDirectDraw

#endif // ! ver3.51



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\logfile.c ===
/*****************************************************************************
******************************************************************************
*
*                ******************************************
*                * Copyright (c) 1996, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:  Laguna I (CL-GD546x) - 
*
* FILE:     logfile.c
*
* AUTHOR:   Sue Schell
*
* DESCRIPTION:
*           This file contains routines that create and write to 
*           the log file, used for debugging and testing purposes
*           only.
*
* MODULES:
*           CreateLogFile()
*           WriteLogFile()
*           CloseLogFile()
*
* REVISION HISTORY:
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/logfile.c  $
* 
*    Rev 1.5   21 Mar 1997 11:43:58   noelv
* 
* Combined LOG_WRITES LOG_CALLS and LOG_QFREE together into ENABLE_LOG_FILE
* 
*    Rev 1.4   17 Dec 1996 16:43:32   SueS
* On a CloseLogFile call, dump the current buffer to the file.
* 
*    Rev 1.3   05 Dec 1996 08:49:24   SueS
* Added function to help with formatting strings for DirectDraw logging.
* 
*    Rev 1.2   03 Dec 1996 11:37:36   SueS
* Removed extraneous semicolon left over from testing.
* 
*    Rev 1.1   26 Nov 1996 10:50:42   SueS
* Instead of sending a single string of text at a time, buffer up the
* requests to the miniport.  The buffer is currently 4K.  Added a
* CloseLogFile function.
* 
*    Rev 1.0   13 Nov 1996 17:03:36   SueS
* Initial revision.
* 
****************************************************************************
****************************************************************************/

/////////////////////
//  Include Files  //
/////////////////////
#include "precomp.h"
#include "clioctl.h"

///////////////
//  Defines  //
///////////////
#define BUFFER_SIZE 0x1000

///////////////////////////
//  Function Prototypes  //
///////////////////////////
#if ENABLE_LOG_FILE

    HANDLE CreateLogFile(
        HANDLE hDriver,
        PDWORD Index);

    BOOL WriteLogFile(
        HANDLE hDriver,
        LPVOID lpBuffer,
        DWORD BytesToWrite,
        PCHAR TextBuffer,
        PDWORD Index);

    BOOL CloseLogFile(
        HANDLE hDriver,
        PCHAR TextBuffer,
        PDWORD Index);

    void DDFormatLogFile(
        LPSTR szFormat, ...);


//
// Used by sprintf to build strings.
//
char lg_buf[256];
long lg_i;

///////////////////////////////////////////////////////////////////////////////
//
//  HANDLE CreateLogFile(HANDLE hDriver, PDWORD Index)
//
//  Parameters:
//      hDriver - the handle to the miniport driver
//      Index - pointer to the index into the text buffer sent to the miniport
//
//  Return:
//      the handle of the just-opened log file
//
//  Notes:
//
//      This function posts a message to the miniport driver to 
//      tell it to open the log file.
//
///////////////////////////////////////////////////////////////////////////////
HANDLE CreateLogFile(
    HANDLE hDriver,        // handle to miniport driver
    PDWORD Index           // size of text buffer
)
{
DWORD BytesReturned;

    // Initialize the buffer pointer
    *Index = 0;

    // Tell the miniport driver to open the log file
    if (DEVICE_IO_CTRL(hDriver,
                       IOCTL_CL_CREATE_LOG_FILE,
                       NULL,
                       0,
                       NULL,
                       0,
                       &BytesReturned,
                       NULL))
        return((HANDLE)-1);
    else
        return((HANDLE)0);

}

                                

///////////////////////////////////////////////////////////////////////////////
//
//  BOOL WriteLogFile(HANDLE hDriver, LPVOID lpBuffer, DWORD BytesToWrite,
//                    PCHAR TextBuffer, PDWORD Index)
//
//  Parameters:
//      hDriver - the handle to the miniport driver
//      lpBuffer - pointer to data to write to file
//      BytesToWrite - number of bytes to write
//      TextBuffer - the buffer eventually sent to the miniport
//      Index - size of TextBuffer
//
//  Return:
//      TRUE - the DeviceIoControl call succeeded
//      FALSE - the DeviceIoControl call failed
//
//  Notes:
//
//      This function posts a message to the miniport driver to 
//      tell it to write the input buffer to the log file.  It waits
//      until it has a full text buffer before doing so.
//
///////////////////////////////////////////////////////////////////////////////
BOOL WriteLogFile(
    HANDLE hDriver,        // handle to miniport driver
    LPVOID lpBuffer,       // pointer to data to write to file
    DWORD BytesToWrite,    // number of bytes to write
    PCHAR TextBuffer,      // buffer sent to miniport
    PDWORD Index           // size of buffer
)
{
DWORD BytesReturned;
BOOLEAN Status = TRUE;

   // Do we have room in the buffer?
   if (BytesToWrite + *Index >= BUFFER_SIZE - 1)
   {

      // No, we're full - it's time to send the message
      // Tell the miniport driver to write to the log file

      Status = DEVICE_IO_CTRL(hDriver,
                       IOCTL_CL_WRITE_LOG_FILE,
                       TextBuffer,
                       *Index,
                       NULL,
                       0,
                       &BytesReturned,
                       NULL);

      // Reset the buffer
      *TextBuffer = 0;
      *Index = 0;

   }

   // Add to the buffer and bump the count
   RtlMoveMemory(TextBuffer+*Index, lpBuffer, BytesToWrite);
   *Index += BytesToWrite;
   *(TextBuffer+*Index) = 0;

   return(Status);

}


///////////////////////////////////////////////////////////////////////////////
//
//  HANDLE CloseLogFile(HANDLE hDriver)
//
//  Parameters:
//      hDriver - the handle to the miniport driver
//
//  Return:
//      TRUE - the DeviceIoControl call succeeded
//      FALSE - the DeviceIoControl call failed
//
//  Notes:
//
//      This function sends the current buffer to the miniport driver
//      to tell it to write to the logfile immediately.
//
///////////////////////////////////////////////////////////////////////////////
BOOL CloseLogFile(
    HANDLE hDriver,        // handle to miniport driver
    PCHAR TextBuffer,      // buffer sent to miniport
    PDWORD Index           // size of buffer
)
{
DWORD BytesReturned;
BOOLEAN Status;

   // Dump the buffer contents
   // Tell the miniport driver to write to the log file

   Status = DEVICE_IO_CTRL(hDriver,
                       IOCTL_CL_WRITE_LOG_FILE,
                       TextBuffer,
                       *Index,
                       NULL,
                       0,
                       &BytesReturned,
                       NULL);

   // Reset the buffer
   *TextBuffer = 0;
   *Index = 0;

   return(Status);

}


///////////////////////////////////////////////////////////////////////////////
//
//  void DDFormatLogFile(LPSTR szFormat, ...)
//
//  Parameters:
//      szFormat - format and string to be printed to log file
//
//  Return:
//      none
//
//  Notes:
//
//      This function formats a string according to the specified format
//      into the global string variable used to write to the log file.
//
///////////////////////////////////////////////////////////////////////////////
void DDFormatLogFile(
   LPSTR szFormat, ...)
{

   lg_i = vsprintf(lg_buf, szFormat, (LPVOID)(&szFormat+1));
   return;
   
}

#endif    // ENABLE_LOG_FILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\hdtable.c ===
/*
* HDTABLE.C
* This table helps us get around the Hostdata bug in the Laguna chip.
*
* Copyright (c) 1995 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/HDTABLE.C  $
* 
*    Rev 1.4   Dec 17 1997 11:03:14   frido
* Added logging information.
* Fixed "last line incomplete" error.
*
*/

#include "precomp.h"

#if !DRIVER_5465
/* the ExtraDwodTable is indexed by as follows (verilog notation)
*       index[15:00] =    bltext [10:0] dst_phase [2:0] src_phase [1:0] 
*
*       index[15:05] =    bltext [10:00]
*       index[04:02] = dst_phase [02:00]
*       index[01:00] = src_phase [01:00]
*/

unsigned char ExtraDwordTable[0x10000] = 
{
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,
0,0,0,0,0,0,0,0,2,2,0,1,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,
0,0,0,0,2,0,1,1,2,0,0,1,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\fillpath.c ===
/******************************************************************************\
*
* $Workfile:   FILLPATH.C  $
*
* Contains the DrvFillPath routine.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/FILLPATH.C  $
*
*    Rev 1.14   Mar 04 1998 15:24:00   frido
* Added new shadow macros.
*
*    Rev 1.13   Nov 03 1997 15:26:36   frido
* Added REQUIRE macros.
*
*    Rev 1.12   08 Apr 1997 12:24:28   einkauf
*
* add SYNC_W_3D to coordinate MCD/2D HW access
*
*    Rev 1.11   21 Mar 1997 11:41:44   noelv
*
* Combined do_flag and sw_test_flag into point_switch
*
*    Rev 1.10   17 Dec 1996 17:04:26   SueS
* Added test for writing to log file based on cursor at (0,0).  Added
* more information to the log file.
*
*    Rev 1.9   26 Nov 1996 10:46:10   noelv
* Changed DBG LEVEL.
*
*    Rev 1.8   26 Nov 1996 10:24:10   SueS
* Changed WriteLogFile parameters for buffering.
*
*    Rev 1.7   13 Nov 1996 15:58:52   SueS
* Changed WriteFile calls to WriteLogFile.
*
*    Rev 1.6   06 Sep 1996 14:46:24   noelv
*
* Updated NULL driver code for 4.0
*
*    Rev 1.5   20 Aug 1996 11:03:32   noelv
* Bugfix release from Frido 8-19-96
*
*    Rev 1.2   17 Aug 1996 15:32:30   frido
* #1244 - Fixed brush rotation for off-screen bitmaps.
* Added new comment header.
* Cleaned up some code.
*
\******************************************************************************/

#include "precomp.h"

BOOL CacheMono(PPDEV ppdev, PRBRUSH pRbrush);
BOOL Cache4BPP(PPDEV ppdev, PRBRUSH pRbrush);
BOOL CacheDither(PPDEV ppdev, PRBRUSH pRbrush);
BOOL CacheBrush(PPDEV ppdev, PRBRUSH pRbrush);

// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit signed
// LONGLONGs and 64-bit unsigned DWORDLONGs.
//
// Int32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies two
// 32-bit LONGs to produce a 64-bit LONGLONG result.  I use it because it is
// much faster than 64x64 multiplies.

#define UInt64Div32To32(a, b)                                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define TAKING_ALLOC_STATS  0

#define NUM_BUFFER_POINTS   96      // Maximum number of points in a path for
                                    // which we'll attempt to join all the path
                                    // records so that the path may still be
                                    // drawn by FastFill

#if TAKING_ALLOC_STATS
    ULONG BufferHitInFillpath  = 0;
    ULONG BufferMissInFillpath = 0;
#endif

#if LOG_CALLS
    VOID LogFillPath(ULONG acc, PPDEV ppdev, SURFOBJ* pso);
#else
    #define LogFillPath(acc, ppdev, pso)
#endif

// Describe a single non-horizontal edge of a path to fill.
typedef struct _EDGE {
    PVOID pNext;
    INT   iScansLeft;
    INT   X;
    INT   Y;
    INT   iErrorTerm;
    INT   iErrorAdjustUp;
    INT   iErrorAdjustDown;
    INT   iXWhole;
    INT   iXDirection;
    INT   iWindingDirection;
} EDGE, *PEDGE;

// Maximum number of rects we'll fill per call to the fill code.
#define MAX_PATH_RECTS  50
#define RECT_BYTES      (MAX_PATH_RECTS * sizeof(RECTL))
#define EDGE_BYTES      (TMP_BUFFER_SIZE - RECT_BYTES)
#define MAX_EDGES       (EDGE_BYTES/sizeof(EDGE))

#define FILLPATH_DBG_LEVEL 1

// MIX translation table. Translates a mix 1-16, into an old style ROP 0-255.
extern BYTE gaMix[];

VOID  AdvanceAETEdges(EDGE* pAETHead);
VOID  XSortAETEdges(EDGE* pAETHead);
VOID  MoveNewEdges(EDGE* pGETHead, EDGE* pAETHead, INT iCurrentY);
EDGE* AddEdgeToGET(EDGE* pGETHead, EDGE* pFreeEdge, POINTFIX* ppfxEdgeStart,
                                   POINTFIX* ppfxEdgeEnd, RECTL* pClipRect);
BOOL  ConstructGET(EDGE* pGETHead, EDGE* pFreeEdges, PATHOBJ* ppo,
                                   PATHDATA* pd, BOOL bMore, RECTL* pClipRect);
VOID  AdjustErrorTerm(INT* pErrorTerm, INT iErrorAdjustUp,
                                          INT iErrorAdjustDown, INT yJump, INT* pXStart,
                                          INT iXDirection);

extern BYTE Rop2ToRop3[];

BYTE gajRop[] =
{
    0x00, 0xff, 0xb2, 0x4d, 0xd4, 0x2b, 0x66, 0x99,
    0x90, 0x6f, 0x22, 0xdd, 0x44, 0xbb, 0xf6, 0x09,
    0xe8, 0x17, 0x5a, 0xa5, 0x3c, 0xc3, 0x8e, 0x71,
    0x78, 0x87, 0xca, 0x35, 0xac, 0x53, 0x1e, 0xe1,
    0xa0, 0x5f, 0x12, 0xed, 0x74, 0x8b, 0xc6, 0x39,
    0x30, 0xcf, 0x82, 0x7d, 0xe4, 0x1b, 0x56, 0xa9,
    0x48, 0xb7, 0xfa, 0x05, 0x9c, 0x63, 0x2e, 0xd1,
    0xd8, 0x27, 0x6a, 0x95, 0x0c, 0xf3, 0xbe, 0x41,
    0xc0, 0x3f, 0x72, 0x8d, 0x14, 0xeb, 0xa6, 0x59,
    0x50, 0xaf, 0xe2, 0x1d, 0x84, 0x7b, 0x36, 0xc9,
    0x28, 0xd7, 0x9a, 0x65, 0xfc, 0x03, 0x4e, 0xb1,
    0xb8, 0x47, 0x0a, 0xf5, 0x6c, 0x93, 0xde, 0x21,
    0x60, 0x9f, 0xd2, 0x2d, 0xb4, 0x4b, 0x06, 0xf9,
    0xf0, 0x0f, 0x42, 0xbd, 0x24, 0xdb, 0x96, 0x69,
    0x88, 0x77, 0x3a, 0xc5, 0x5c, 0xa3, 0xee, 0x11,
    0x18, 0xe7, 0xaa, 0x55, 0xcc, 0x33, 0x7e, 0x81,
    0x80, 0x7f, 0x32, 0xcd, 0x54, 0xab, 0xe6, 0x19,
    0x10, 0xef, 0xa2, 0x5d, 0xc4, 0x3b, 0x76, 0x89,
    0x68, 0x97, 0xda, 0x25, 0xbc, 0x43, 0x0e, 0xf1,
    0xf8, 0x07, 0x4a, 0xb5, 0x2c, 0xd3, 0x9e, 0x61,
    0x20, 0xdf, 0x92, 0x6d, 0xf4, 0x0b, 0x46, 0xb9,
    0xb0, 0x4f, 0x02, 0xfd, 0x64, 0x9b, 0xd6, 0x29,
    0xc8, 0x37, 0x7a, 0x85, 0x1c, 0xe3, 0xae, 0x51,
    0x58, 0xa7, 0xea, 0x15, 0x8c, 0x73, 0x3e, 0xc1,
    0x40, 0xbf, 0xf2, 0x0d, 0x94, 0x6b, 0x26, 0xd9,
    0xd0, 0x2f, 0x62, 0x9d, 0x04, 0xfb, 0xb6, 0x49,
    0xa8, 0x57, 0x1a, 0xe5, 0x7c, 0x83, 0xce, 0x31,
    0x38, 0xc7, 0x8a, 0x75, 0xec, 0x13, 0x5e, 0xa1,
    0xe0, 0x1f, 0x52, 0xad, 0x34, 0xcb, 0x86, 0x79,
    0x70, 0x8f, 0xc2, 0x3d, 0xa4, 0x5b, 0x16, 0xe9,
    0x08, 0xf7, 0xba, 0x45, 0xdc, 0x23, 0x6e, 0x91,
    0x98, 0x67, 0x2a, 0xd5, 0x4c, 0xb3, 0xfe, 0x01
};


/******************************Public*Routine******************************\
* DrvFillPath
*
* Fill the specified path with the specified brush and ROP.  This routine
* detects single convex polygons, and will call to separate faster convex
* polygon code for those cases.  This routine also detects polygons that
* are really rectangles, and handles those separately as well.
*
* Note: Multiple polygons in a path cannot be treated as being disjoint;
*       the fill must consider all the points in the path.  That is, if the
*       path contains multiple polygons, you cannot simply draw one polygon
*       after the other (unless they don't overlap).
*
* Note: This function is optional, but is recommended for good performance.
*       To get GDI to call this function, not only do you have to
*       HOOK_FILLPATH, you have to set GCAPS_ALTERNATEFILL and/or
*       GCAPS_WINDINGFILL.
*
\**************************************************************************/

BOOL DrvFillPath(
SURFOBJ*    pso,
PATHOBJ*    ppo,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
MIX         mix,
FLONG       flOptions)
{
    BYTE jClipping;     // clipping type
    EDGE *pCurrentEdge;
    EDGE AETHead;       // dummy head/tail node & sentinel for Active Edge Table
    EDGE *pAETHead;     // pointer to AETHead
    EDGE GETHead;       // dummy head/tail node & sentinel for Global Edge Table
    EDGE *pGETHead;     // pointer to GETHead
    EDGE *pFreeEdges;   // pointer to memory free for use to store edges
    ULONG ulNumRects;   // # of rectangles to draw currently in rectangle list
    RECTL *prclRects;   // pointer to start of rectangle draw list
    INT iCurrentY;      // scan line for which we're currently scanning out the
                        //  fill

    ULONG        uRop;       // Hardware foreground mix value
    ULONG        uRopb;       // Hardware background mix value
    ULONG        avec;                  // A-vector notation for ternary rop
    ULONG        iSolidColor;       // Copy of pbo->iSolidColor
    FNFILL      *pfnFill;           // Points to appropriate fill routine
    BOOL         bRealizeTransparent; // Need a transparent realization for Rop

    BOOL         bSolid;
    BOOL         bMore;
    PATHDATA     pd;
    RECTL        ClipRect;
    PDEV        *ppdev;

    BOOL         bRetVal=FALSE;     // FALSE until proven TRUE
    BOOL         bMemAlloced=FALSE; // FALSE until proven TRUE

    FLONG        flFirstRecord;
    POINTFIX*    pptfxTmp;
    ULONG        cptfxTmp;
    POINTFIX     aptfxBuf[NUM_BUFFER_POINTS];
    ULONG        ulBltDef = 0x1000;


    #if NULL_PATH
    {
            if (pointer_switch)    return(TRUE);
    }
    #endif

    DISPDBG((FILLPATH_DBG_LEVEL,"DrvFillPath\n"));

    // Set up the clipping
    if (pco == (CLIPOBJ *) NULL) {
        // No CLIPOBJ provided, so we don't have to worry about clipping
        jClipping = DC_TRIVIAL;
    } else {
        // Use the CLIPOBJ-provided clipping
        jClipping = pco->iDComplexity;
    }

    if (jClipping != DC_TRIVIAL) {
        if (jClipping != DC_RECT) {
            DISPDBG((FILLPATH_DBG_LEVEL,"Complex Clipping Early Out\n"));
            #if LOG_CALLS
                ppdev = (PDEV*) pso->dhpdev;
                LogFillPath(2,  ppdev, NULL);
            #endif
            goto ReturnFalse;  // there is complex clipping; let GDI fill the path
        }
        // Clip to the clip rectangle
        ClipRect = pco->rclBounds;
    } else {
        // So the y-clipping code doesn't do any clipping
        // /16 so we don't blow the values out when we scale up to GIQ
        ClipRect.top = (LONG_MIN + 1) / 16; // +1 to avoid compiler problem
        ClipRect.bottom = LONG_MAX / 16;
    }

    // There's nothing to do if there are only one or two points
    if (ppo->cCurves <= 2) {
        DISPDBG((FILLPATH_DBG_LEVEL,"Nothing to do out\n"));
        #if LOG_CALLS
            ppdev = (PDEV*) pso->dhpdev;
            LogFillPath(0,  ppdev, pso);
        #endif
        goto ReturnTrue;
    }

    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:
         // This is where to put device bit maps
    ppdev = (PDEV*) pso->dhpdev;

    SYNC_W_3D(ppdev);

    if (pso->iType == STYPE_DEVBITMAP)
    {
        PDSURF pdsurf = (PDSURF) pso->dhsurf;

        if ( pdsurf->pso && !bCreateScreenFromDib(ppdev, pdsurf) )
        {
                LogFillPath(4,  ppdev, NULL);
                return(EngFillPath(pdsurf->pso, ppo, pco, pbo, pptlBrush, mix,
                                                           flOptions));
        }
        ppdev->ptlOffset = pdsurf->ptl;
    }
    else
    {
        ppdev->ptlOffset.x = ppdev->ptlOffset.y = 0;
    }

    pfnFill = vMmFillSolid;
    uRop = Rop2ToRop3[mix & 0xF];
    uRopb = Rop2ToRop3[(mix >> 8) & 0xF];
    bSolid = ((pbo == NULL) || (pbo->iSolidColor != -1));

    //
    // Make it simple and punt this one until later
    //
    avec = gajRop[uRop];
    if ((uRop != uRopb) && !bSolid)
    {
           DISPDBG((FILLPATH_DBG_LEVEL, "ROPs it Fore=%x Back=%x ROP3=%x\n", uRop, uRopb, ROP3MIX(uRop, uRopb)));
                uRop = ROP3MIX(uRop, uRopb);
                avec = gajRop[uRop];
                if (avec & AVEC_NEED_SOURCE)
              {
              // Use the implicit mask in the brush object.
              // Note pre-align mask (as if "anchored")

              if (!bSetMask(ppdev, pbo, pptlBrush, &ulBltDef))
              {
                  DISPDBG((FILLPATH_DBG_LEVEL, "Set Mask Failed"));
                  LogFillPath(5,  ppdev, NULL);
                  return FALSE;
              }
                  }


    }

    iSolidColor = 0;                    // Assume we won't need a pattern
    bRealizeTransparent = FALSE;
    if (avec & AVEC_NEED_PATTERN)
    {
                  iSolidColor = pbo->iSolidColor;
        if (pbo->iSolidColor == -1)
        {
            bRealizeTransparent = (uRop != uRopb);
            if (pbo->pvRbrush == NULL)
            {
                pbo->pvRbrush = BRUSHOBJ_pvGetRbrush(pbo);
                if (pbo->pvRbrush == NULL)
                {
                    DISPDBG((FILLPATH_DBG_LEVEL,"Could Not Get Brush\n"));
                    LogFillPath(6,  ppdev, NULL);
                    return(FALSE);
                }
            }
            pfnFill = vMmFillPatFast;
        }
                else
                        ulBltDef |= (BD_OP2 * IS_SOLID);         // Or in 0x0007
    }

    if (avec & AVEC_NEED_DEST)
                ulBltDef |= (BD_OP0 * IS_VRAM);  // Or in 0x0100

    // Enumerate path here first time to check for special
    // cases (rectangles and monotone polygons)

    // It is too difficult to determine interaction between
    // multiple paths, if there is more than one, skip this

    bMore = PATHOBJ_bEnum(ppo, &pd);

    if (jClipping == DC_TRIVIAL)
    {
        // Try going through the fast non-complex fill code.  We'll have
        // to realize the brush first if we're going to handle a pattern:

        if (iSolidColor == -1)
        {
#ifdef S3
        #if !FASTFILL_PATTERNS
            goto SkipFastFill;
        #else
            // We handle patterns in 'pfnFastFill' only if we can use the S3
            // hardware patterns.
            if (!(ppdev->flCaps & CAPS_HW_PATTERNS))
                goto SkipFastFill;

            // Note: prb->pbe will be NULL and prb->ptlBrushOrg.x will be -1 the
            //       first time an RBRUSH is used.  So we have to check the
            //       alignment *before* dereferencing prb->pbe...

            if ((rbc.prb->ptlBrushOrg.x != pptlBrush->x + ppdev->xOffset) ||
                (rbc.prb->ptlBrushOrg.y != pptlBrush->y + ppdev->yOffset) ||
                (rbc.prb->apbe[IBOARD(ppdev)]->prbVerify != rbc.prb)      ||
                (rbc.prb->bTransparent != bRealizeTransparent))
            {
                vMmFastPatRealize(ppdev, pbo, pptlBrush,
                                         bRealizeTransparent);

            }
        #endif
#endif

            // Realize the brush
            if (!SetBrush(ppdev, &ulBltDef, pbo, pptlBrush))
            {
                 DISPDBG((FILLPATH_DBG_LEVEL,"Could Not Set Brush\n"));
                 LogFillPath(6,  ppdev, NULL);
                 return FALSE;
            }
        }

        if (bMore)
        {
            // FastFill only knows how to take a single contiguous buffer
            // of points.  Unfortunately, GDI sometimes hands us paths
            // that are split over multiple path data records.  Convex
            // figures such as Ellipses, Pies and RoundRects are almost
            // always given in multiple records.  Since probably 90% of
            // multiple record paths could still be done by FastFill, for
            // those cases we simply copy the points into a contiguous
            // buffer...

            // First make sure that the entire path would fit in the
            // temporary buffer, and make sure the path isn't comprised
            // of more than one subpath:

            if ((ppo->cCurves >= NUM_BUFFER_POINTS) ||
                (pd.flags & PD_ENDSUBPATH))
                goto SkipFastFill;

            pptfxTmp = &aptfxBuf[0];

            RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);

            pptfxTmp     += pd.count;
            cptfxTmp      = pd.count;
            flFirstRecord = pd.flags;       // Remember PD_BEGINSUBPATH flag

            do {
                bMore = PATHOBJ_bEnum(ppo, &pd);

                RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);
                cptfxTmp += pd.count;
                pptfxTmp += pd.count;
            } while (!(pd.flags & PD_ENDSUBPATH));

            // Fake up the path data record:

            pd.pptfx  = &aptfxBuf[0];
            pd.count  = cptfxTmp;
            pd.flags |= flFirstRecord;

            // If there's more than one subpath, we can't call FastFill:

            if (bMore)
                goto SkipFastFill;
        }

                  ppdev->uBLTDEF = ulBltDef;
        if (bMmFastFill(ppdev, pd.count, pd.pptfx, uRop,
                                 uRopb, iSolidColor, pbo))
        {
            LogFillPath(0,  ppdev, pso);
            return(TRUE);
        }
    }

SkipFastFill:

    // Set up working storage in the temporary buffer

    prclRects = (RECTL*) ppdev->pvTmpBuffer; // storage for list of rectangles to draw

    if (!bMore) {

        RECTL *rectangle;
        INT cPoints = pd.count;

        // The count can't be less than three, because we got all the edges
        // in this subpath, and above we checked that there were at least
        // three edges

        // If the count is four, check to see if the polygon is really a
        // rectangle since we can really speed that up. We'll also check for
        // five with the first and last points the same, because under Win 3.1,
        // it was required to close polygons

        if ((cPoints == 4) ||
           ((cPoints == 5) &&
            (pd.pptfx[0].x == pd.pptfx[4].x) &&
            (pd.pptfx[0].y == pd.pptfx[4].y))) {

            rectangle = prclRects;

      /* we have to start somewhere so assume that most
         applications specify the top left point  first

         we want to check that the first two points are
         either vertically or horizontally aligned.  if
         they are then we check that the last point [3]
         is either horizontally or  vertically  aligned,
         and finally that the 3rd point [2] is  aligned
         with both the first point and the  last  point */

#define FIX_SHIFT 4L
#define FIX_MASK (- (1 << FIX_SHIFT))

         rectangle->top   = pd.pptfx[0].y - 1 & FIX_MASK;
         rectangle->left  = pd.pptfx[0].x - 1 & FIX_MASK;
         rectangle->right = pd.pptfx[1].x - 1 & FIX_MASK;

         if (rectangle->left ^ rectangle->right) {
            if (rectangle->top  ^ (pd.pptfx[1].y - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->left ^ (pd.pptfx[3].x - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->right ^ (pd.pptfx[2].x - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[2].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;
         }
         else {
            if (rectangle->top ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[1].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[2].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->right = pd.pptfx[2].x - 1 & FIX_MASK;
            if (rectangle->right ^ (pd.pptfx[3].x - 1 & FIX_MASK))
                goto not_rectangle;
         }

      /* if the left is greater than the right then
         swap them so the blt code doesn't wig  out */

         if (rectangle->left > rectangle->right) {
            FIX temp;

            temp = rectangle->left;
            rectangle->left = rectangle->right;
            rectangle->right = temp;
         }
         else {

         /* if left == right there's nothing to draw */

            if (rectangle->left == rectangle->right)
            {
               LogFillPath(0,  ppdev, pso);
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->left  = (rectangle->left  >> FIX_SHIFT) + 1;
         rectangle->right = (rectangle->right >> FIX_SHIFT) + 1;

         if (rectangle->top > rectangle->bottom) {
            FIX temp;

            temp = rectangle->top;
            rectangle->top = rectangle->bottom;
            rectangle->bottom = temp;
         }
         else {
            if (rectangle->top == rectangle->bottom)
            {
               LogFillPath(0,  ppdev, pso);
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->top    = (rectangle->top    >> FIX_SHIFT) + 1;
         rectangle->bottom = (rectangle->bottom >> FIX_SHIFT) + 1;

         // Finally, check for clipping
         if (jClipping == DC_RECT) {
            // Clip to the clip rectangle
            if (!bIntersect(rectangle, &ClipRect, rectangle))
            {
                // Totally clipped, nothing to do
                LogFillPath(0,  ppdev, pso);
                goto ReturnTrue;
            }
         }

      /* if we get here then the polygon is a rectangle,
         set count to 1 and  goto  bottom  to  draw  it */

         ulNumRects = 1;
         goto draw_remaining_rectangles;
      }

not_rectangle:

        ;

    }

    // Do we have enough memory for all the edges?
    // LATER does cCurves include closure?
    if (ppo->cCurves > MAX_EDGES) {
#if TAKING_ALLOC_STATS
            BufferMissInFillpath++;
#endif
        //
        // try to allocate enough memory
        //
#ifdef WINNT_VER40
        pFreeEdges = (EDGE *) MEM_ALLOC(0, (ppo->cCurves * sizeof(EDGE)), ALLOC_TAG);
#else
        pFreeEdges = (EDGE *) MEM_ALLOC(LMEM_FIXED, (ppo->cCurves * sizeof(EDGE)));
#endif

        if (pFreeEdges == NULL)
        {
            LogFillPath(1,  ppdev, NULL);
            goto ReturnFalse;  // too many edges; let GDI fill the path
        }
        else
        {
            bMemAlloced = TRUE;
        }
    }
    else {
#if TAKING_ALLOC_STATS
            BufferHitInFillpath++;
#endif
        pFreeEdges = (EDGE*) ((BYTE*) ppdev->pvTmpBuffer + RECT_BYTES);
            // use our handy temporary buffer (it's big enough)
    }

    // Initialize an empty list of rectangles to fill
    ulNumRects = 0;

    // Enumerate the path edges and build a Global Edge Table (GET) from them
    // in YX-sorted order.
    pGETHead = &GETHead;
    if (!ConstructGET(pGETHead, pFreeEdges, ppo, &pd, bMore, &ClipRect))
    {
        LogFillPath(7,  ppdev, NULL);
        goto ReturnFalse;  // outside GDI's 2**27 range
    }

    // Create an empty AET with the head node also a tail sentinel
    pAETHead = &AETHead;
    AETHead.pNext = pAETHead;  // mark that the AET is empty
    AETHead.X = 0x7FFFFFFF;    // this is greater than any valid X value, so
                               //  searches will always terminate

    // Top scan of polygon is the top of the first edge we come to
    iCurrentY = ((EDGE *)GETHead.pNext)->Y;

    // Loop through all the scans in the polygon, adding edges from the GET to
    // the Active Edge Table (AET) as we come to their starts, and scanning out
    // the AET at each scan into a rectangle list. Each time it fills up, the
    // rectangle list is passed to the filling routine, and then once again at
    // the end if any rectangles remain undrawn. We continue so long as there
    // are edges to be scanned out
    while (1) {

        // Advance the edges in the AET one scan, discarding any that have
        // reached the end (if there are any edges in the AET)
        if (AETHead.pNext != pAETHead) {
            AdvanceAETEdges(pAETHead);
        }

        // If the AET is empty, done if the GET is empty, else jump ahead to
        // the next edge in the GET; if the AET isn't empty, re-sort the AET
        if (AETHead.pNext == pAETHead) {
            if (GETHead.pNext == pGETHead) {
                // Done if there are no edges in either the AET or the GET
                break;
            }
            // There are no edges in the AET, so jump ahead to the next edge in
            // the GET
            iCurrentY = ((EDGE *)GETHead.pNext)->Y;
        } else {
            // Re-sort the edges in the AET by X coordinate, if there are at
            // least two edges in the AET (there could be one edge if the
            // balancing edge hasn't yet been added from the GET)
            if (((EDGE *)AETHead.pNext)->pNext != pAETHead) {
                XSortAETEdges(pAETHead);
            }
        }

        // Move any new edges that start on this scan from the GET to the AET;
        // bother calling only if there's at least one edge to add
        if (((EDGE *)GETHead.pNext)->Y == iCurrentY) {
            MoveNewEdges(pGETHead, pAETHead, iCurrentY);
        }

        // Scan the AET into rectangles to fill (there's always at least one
        // edge pair in the AET)
        pCurrentEdge = AETHead.pNext;   // point to the first edge
        do {

            INT iLeftEdge;

            // The left edge of any given edge pair is easy to find; it's just
            // wherever we happen to be currently
            iLeftEdge = pCurrentEdge->X;

            // Find the matching right edge according to the current fill rule
            if ((flOptions & FP_WINDINGMODE) != 0) {

                INT iWindingCount;

                // Do winding fill; scan across until we've found equal numbers
                // of up and down edges
                iWindingCount = pCurrentEdge->iWindingDirection;
                do {
                    pCurrentEdge = pCurrentEdge->pNext;
                    iWindingCount += pCurrentEdge->iWindingDirection;
                } while (iWindingCount != 0);
            } else {
                // Odd-even fill; the next edge is the matching right edge
                pCurrentEdge = pCurrentEdge->pNext;
            }

            // See if the resulting span encompasses at least one pixel, and
            // add it to the list of rectangles to draw if so
            if (iLeftEdge < pCurrentEdge->X) {

                // We've got an edge pair to add to the list to be filled; see
                // if there's room for one more rectangle
                if (ulNumRects >= MAX_PATH_RECTS) {
                    // No more room; draw the rectangles in the list and reset
                    // it to empty

                                                        ppdev->uBLTDEF = ulBltDef;
                    (*pfnFill)(ppdev, ulNumRects, prclRects, uRop,
                               uRopb, pbo, pptlBrush);

                    // Reset the list to empty
                    ulNumRects = 0;
                }

                // Add the rectangle representing the current edge pair
                if (jClipping == DC_RECT) {
                    // Clipped
                    // Clip to left
                    prclRects[ulNumRects].left = max(iLeftEdge, ClipRect.left);
                    // Clip to right
                    prclRects[ulNumRects].right =
                            min(pCurrentEdge->X, ClipRect.right);
                    // Draw only if not fully clipped
                    if (prclRects[ulNumRects].left <
                            prclRects[ulNumRects].right) {
                        prclRects[ulNumRects].top = iCurrentY;
                        prclRects[ulNumRects].bottom = iCurrentY+1;
                        ulNumRects++;
                    }
                }
                else
                {
                    // Unclipped
                    prclRects[ulNumRects].top = iCurrentY;
                    prclRects[ulNumRects].bottom = iCurrentY+1;
                    prclRects[ulNumRects].left = iLeftEdge;
                    prclRects[ulNumRects].right = pCurrentEdge->X;
                    ulNumRects++;
                }
            }
        } while ((pCurrentEdge = pCurrentEdge->pNext) != pAETHead);

        iCurrentY++;    // next scan
    }

/* draw the remaining rectangles,  if there are any */

draw_remaining_rectangles:

    if (ulNumRects > 0) {
                  ppdev->uBLTDEF = ulBltDef;
        (*pfnFill)(ppdev, ulNumRects, prclRects, uRop, uRopb,
                   pbo, pptlBrush);
    }

    LogFillPath(0,  ppdev, pso);

ReturnTrue:
    bRetVal = TRUE; // done successfully

ReturnFalse:

    // bRetVal is originally false.  If you jumped to ReturnFalse from somewhere,
    // then it will remain false, and be returned.

    if (bMemAlloced)
    {
        //
        // we did allocate memory, so release it
        //
        MEMORY_FREE (pFreeEdges);
    }

    return(bRetVal);
}

// Advance the edges in the AET to the next scan, dropping any for which we've
// done all scans. Assumes there is at least one edge in the AET.
VOID AdvanceAETEdges(EDGE *pAETHead)
{
    EDGE *pLastEdge, *pCurrentEdge;

    pLastEdge = pAETHead;
    pCurrentEdge = pLastEdge->pNext;
    do {

        // Count down this edge's remaining scans
        if (--pCurrentEdge->iScansLeft == 0) {
            // We've done all scans for this edge; drop this edge from the AET
            pLastEdge->pNext = pCurrentEdge->pNext;
        } else {
            // Advance the edge's X coordinate for a 1-scan Y advance
            // Advance by the minimum amount
            pCurrentEdge->X += pCurrentEdge->iXWhole;
            // Advance the error term and see if we got one extra pixel this
            // time
            pCurrentEdge->iErrorTerm += pCurrentEdge->iErrorAdjustUp;
            if (pCurrentEdge->iErrorTerm >= 0) {
                // The error term turned over, so adjust the error term and
                // advance the extra pixel
                pCurrentEdge->iErrorTerm -= pCurrentEdge->iErrorAdjustDown;
                pCurrentEdge->X += pCurrentEdge->iXDirection;
            }

            pLastEdge = pCurrentEdge;
        }
    } while ((pCurrentEdge = pLastEdge->pNext) != pAETHead);
}

// X-sort the AET, because the edges may have moved around relative to
// one another when we advanced them. We'll use a multipass bubble
// sort, which is actually okay for this application because edges
// rarely move relative to one another, so we usually do just one pass.
// Also, this makes it easy to keep just a singly-linked list. Assumes there
// are at least two edges in the AET.
VOID XSortAETEdges(EDGE *pAETHead)
{
    BOOL bEdgesSwapped;
    EDGE *pLastEdge, *pCurrentEdge, *pNextEdge;

    do {

        bEdgesSwapped = FALSE;
        pLastEdge = pAETHead;
        pCurrentEdge = pLastEdge->pNext;
        pNextEdge = pCurrentEdge->pNext;

        do {
            if (pNextEdge->X < pCurrentEdge->X) {

                // Next edge is to the left of the current edge; swap them
                pLastEdge->pNext = pNextEdge;
                pCurrentEdge->pNext = pNextEdge->pNext;
                pNextEdge->pNext = pCurrentEdge;
                bEdgesSwapped = TRUE;
                pCurrentEdge = pNextEdge;   // continue sorting before the edge
                                            //  we just swapped; it might move
                                            //  farther yet
            }
            pLastEdge = pCurrentEdge;
            pCurrentEdge = pLastEdge->pNext;
        } while ((pNextEdge = pCurrentEdge->pNext) != pAETHead);
    } while (bEdgesSwapped);
}

// Moves all edges that start on the current scan from the GET to the AET in
// X-sorted order. Parameters are pointer to head of GET and pointer to dummy
// edge at head of AET, plus current scan line. Assumes there's at least one
// edge to be moved.
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY)
{
    EDGE *pCurrentEdge = pAETHead;
    EDGE *pGETNext = pGETHead->pNext;

    do {

        // Scan through the AET until the X-sorted insertion point for this
        // edge is found. We can continue from where the last search left
        // off because the edges in the GET are in X sorted order, as is
        // the AET. The search always terminates because the AET sentinel
        // is greater than any valid X
        while (pGETNext->X > ((EDGE *)pCurrentEdge->pNext)->X) {
            pCurrentEdge = pCurrentEdge->pNext;
        }

        // We've found the insertion point; add the GET edge to the AET, and
        // remove it from the GET
        pGETHead->pNext = pGETNext->pNext;
        pGETNext->pNext = pCurrentEdge->pNext;
        pCurrentEdge->pNext = pGETNext;
        pCurrentEdge = pGETNext;    // continue insertion search for the next
                                    //  GET edge after the edge we just added
        pGETNext = pGETHead->pNext;

    } while (pGETNext->Y == iCurrentY);
}





// Build the Global Edge Table from the path. There must be enough memory in
// the free edge area to hold all edges. The GET is constructed in Y-X order,
// and has a head/tail/sentinel node at pGETHead.

BOOL ConstructGET(
   EDGE     *pGETHead,
   EDGE     *pFreeEdges,
   PATHOBJ  *ppo,
   PATHDATA *pd,
   BOOL      bMore,
   RECTL    *pClipRect)
{
   POINTFIX pfxPathStart;    // point that started the current subpath
   POINTFIX pfxPathPrevious; // point before the current point in a subpath;
                              //  starts the current edge

/* Create an empty GET with the head node also a tail sentinel */

   pGETHead->pNext = pGETHead; // mark that the GET is empty
   pGETHead->Y = 0x7FFFFFFF;   // this is greater than any valid Y value, so
                                //  searches will always terminate

/* PATHOBJ_vEnumStart is implicitly  performed  by  engine
   already and first path  is  enumerated  by  the  caller */

next_subpath:

/* Make sure the PATHDATA is not empty (is this necessary) */

   if (pd->count != 0) {

   /* If first point starts a subpath, remember it as such
      and go on to the next point,   so we can get an edge */

      if (pd->flags & PD_BEGINSUBPATH) {

      /* the first point starts the subpath;   remember it */


         pfxPathStart    = *pd->pptfx; /* the subpath starts here          */
         pfxPathPrevious = *pd->pptfx; /* this points starts the next edge */
         pd->pptfx++;                  /* advance to the next point        */
         pd->count--;                  /* count off this point             */
      }


   /* add edges in PATHDATA to GET,  in Y-X  sorted  order */

      while (pd->count--) {
        if ((pFreeEdges =
            AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious, pd->pptfx,
                         pClipRect)) == NULL) {
            goto ReturnFalse;
        }
        pfxPathPrevious = *pd->pptfx; /* current point becomes previous   */
        pd->pptfx++;                  /* advance to the next point        */
      }


   /* If last point ends the subpath, insert the edge that
      connects to first point  (is this built in already?) */

      if (pd->flags & PD_ENDSUBPATH) {
         if ((pFreeEdges = AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious,
                                   &pfxPathStart, pClipRect)) == NULL) {
            goto ReturnFalse;
        }
      }
   }

/* the initial loop conditions preclude a do, while or for */

   if (bMore) {
       bMore = PATHOBJ_bEnum(ppo, pd);
       goto next_subpath;
   }

    return(TRUE);   // done successfully

ReturnFalse:
    return(FALSE);  // failed
}

// Adds the edge described by the two passed-in points to the Global Edge
// Table, if the edge spans at least one pixel vertically.
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge,
        POINTFIX *ppfxEdgeStart, POINTFIX *ppfxEdgeEnd, RECTL *pClipRect)
{
    INT iYStart, iYEnd, iXStart, iXEnd, iYHeight, iXWidth;
    INT yJump, yTop;

    // Set the winding-rule direction of the edge, and put the endpoints in
    // top-to-bottom order
    iYHeight = ppfxEdgeEnd->y - ppfxEdgeStart->y;
    if (iYHeight == 0) {
        return(pFreeEdge);  // zero height; ignore this edge
    } else if (iYHeight >= 0) {
        iXStart = ppfxEdgeStart->x;
        iYStart = ppfxEdgeStart->y;
        iXEnd = ppfxEdgeEnd->x;
        iYEnd = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = 1;
    } else {
        iYHeight = -iYHeight;
        iXEnd = ppfxEdgeStart->x;
        iYEnd = ppfxEdgeStart->y;
        iXStart = ppfxEdgeEnd->x;
        iYStart = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = -1;
    }

    if (iYHeight & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    // Set the error term and adjustment factors, all in GIQ coordinates for
    // now
    iXWidth = iXEnd - iXStart;
    if (iXWidth >= 0) {
        // Left to right, so we change X as soon as we move at all
        pFreeEdge->iXDirection = 1;
        pFreeEdge->iErrorTerm = -1;
    } else {
        // Right to left, so we don't change X until we've moved a full GIQ
        // coordinate
        iXWidth = -iXWidth;
        pFreeEdge->iXDirection = -1;
        pFreeEdge->iErrorTerm = -iYHeight;
    }

    if (iXWidth & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    if (iXWidth >= iYHeight) {
        // Calculate base run length (minimum distance advanced in X for a 1-
        // scan advance in Y)
        pFreeEdge->iXWhole = iXWidth / iYHeight;
        // Add sign back into base run length if going right to left
        if (pFreeEdge->iXDirection == -1) {
            pFreeEdge->iXWhole = -pFreeEdge->iXWhole;
        }
        pFreeEdge->iErrorAdjustUp = iXWidth % iYHeight;
    } else {
        // Base run length is 0, because line is closer to vertical than
        // horizontal
        pFreeEdge->iXWhole = 0;
        pFreeEdge->iErrorAdjustUp = iXWidth;
    }
    pFreeEdge->iErrorAdjustDown = iYHeight;

    // Calculate the number of pixels spanned by this edge, accounting for
    // clipping

    // Top true pixel scan in GIQ coordinates
    // Shifting to divide and multiply by 16 is okay because the clip rect
    // always contains positive numbers
    yTop = max(pClipRect->top << 4, (iYStart + 15) & ~0x0F);
    pFreeEdge->Y = yTop >> 4;    // initial scan line on which to fill edge

    // Calculate # of scans to actually fill, accounting for clipping
    if ((pFreeEdge->iScansLeft = min(pClipRect->bottom, ((iYEnd + 15) >> 4))
            - pFreeEdge->Y) <= 0) {

        return(pFreeEdge);  // no pixels at all are spanned, so we can
                            // ignore this edge
    }

    // If the edge doesn't start on a pixel scan (that is, it starts at a
    // fractional GIQ coordinate), advance it to the first pixel scan it
    // intersects. Ditto if there's top clipping. Also clip to the bottom if
    // needed

    if (iYStart != yTop) {
        // Jump ahead by the Y distance in GIQ coordinates to the first pixel
        // to draw
        yJump = yTop - iYStart;

        // Advance x the minimum amount for the number of scans traversed
        iXStart += pFreeEdge->iXWhole * yJump;

        AdjustErrorTerm(&pFreeEdge->iErrorTerm, pFreeEdge->iErrorAdjustUp,
                        pFreeEdge->iErrorAdjustDown, yJump, &iXStart,
                        pFreeEdge->iXDirection);
    }
    // Turn the calculations into pixel rather than GIQ calculations

    // Move the X coordinate to the nearest pixel, and adjust the error term
    // accordingly
    // Dividing by 16 with a shift is okay because X is always positive
    pFreeEdge->X = (iXStart + 15) >> 4; // convert from GIQ to pixel coordinates

    // LATER adjust only if needed (if prestepped above)?
    if (pFreeEdge->iXDirection == 1) {
        // Left to right
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                (((iXStart + 15) & ~0x0F) - iXStart);
    } else {
        // Right to left
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                ((iXStart - 1) & 0x0F);
    }

    // Scale the error term down 16 times to switch from GIQ to pixels.
    // Shifts work to do the multiplying because these values are always
    // non-negative
    pFreeEdge->iErrorTerm >>= 4;

    // Insert the edge into the GET in YX-sorted order. The search always ends
    // because the GET has a sentinel with a greater-than-possible Y value
    while ((pFreeEdge->Y > ((EDGE *)pGETHead->pNext)->Y) ||
            ((pFreeEdge->Y == ((EDGE *)pGETHead->pNext)->Y) &&
            (pFreeEdge->X > ((EDGE *)pGETHead->pNext)->X))) {
        pGETHead = pGETHead->pNext;
    }

    pFreeEdge->pNext = pGETHead->pNext; // link the edge into the GET
    pGETHead->pNext = pFreeEdge;

    return(++pFreeEdge);    // point to the next edge storage location for next
                            //  time
}

// Adjust the error term for a skip ahead in y. This is in ASM because there's
// a multiply/divide that may involve a larger than 32-bit value.

void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection)
{
#if defined(_X86_) || defined(i386)
    // Adjust the error term up by the number of y coordinates we'll skip
    //*pErrorTerm += iErrorAdjustUp * yJump;
    _asm    mov ebx,pErrorTerm
    _asm    mov eax,iErrorAdjustUp
    _asm    mul yJump
    _asm    add eax,[ebx]
    _asm    adc edx,-1      // the error term starts out negative

    // See if the error term turned over even once while skipping
    //if (*pErrorTerm >= 0) {
    _asm    js  short NoErrorTurnover

        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        // NumAdjustDowns = (*pErrorTerm / iErrorAdjustDown) + 1;
        _asm    div iErrorAdjustDown
        _asm    inc eax
        // Note that EDX is the remainder; (EDX - iErrorAdjustDown) is where
        // the error term ends up ultimately

        // Advance x appropriately for the # of times the error term
        // turned over
        // if (iXDirection == 1) {
        //     *pXStart += NumAdjustDowns;
        // } else {
        //     *pXStart -= NumAdjustDowns;
        // }
        _asm    mov ecx,pXStart
        _asm    cmp iXDirection,1
        _asm    jz  short GoingRight
        _asm    neg eax
GoingRight:
        _asm    add [ecx],eax

        // Adjust the error term down to its proper post-skip value
        // *pErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
        _asm    sub edx,iErrorAdjustDown
        _asm    mov eax,edx     // put into EAX for storing to pErrorTerm next
        // }
NoErrorTurnover:
        _asm    mov [ebx],eax
#else
    LONGLONG llErrorTerm;
    INT NumAdjustDowns;

    llErrorTerm = *pErrorTerm;

    // Adjust the error term up by the number of y coordinates we'll skip
    llErrorTerm += Int32x32To64(iErrorAdjustUp,yJump);

    // See if the error term turned over even once while skipping
    if (llErrorTerm >= 0) {
        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        NumAdjustDowns = (UInt64Div32To32(llErrorTerm,iErrorAdjustDown)) + 1;

        // Advance x appropriately for the # of times the error term
        // turned over
        if (iXDirection == 1) {
            *pXStart += NumAdjustDowns;
        } else {
            *pXStart -= NumAdjustDowns;
        }

        // Adjust the error term down to its proper post-skip value
        llErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
    }

    *pErrorTerm = (INT) llErrorTerm;
#endif
}

//--------------------------------------------------------------------------//
//                                                                          //
//  bSetMask()                                                              //
//  Used by DrvFillPath //
//  to setup the chip to use the current mask.                      //
//  We don't set the BLTDEF register directly here.  We set a local copy,   //
//  which the calling routine will further modify befor writing it to       //
//  the chip.                                                               //
//                                                                          //
//--------------------------------------------------------------------------//
BOOL bSetMask(
         PPDEV  ppdev,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    ULONG  *bltdef)
{
    PRBRUSH pRbrush = 0;
    USHORT patoff_x, patoff_y;

    DISPDBG((FILLPATH_DBG_LEVEL, "bSetMask - Entry\n"));

         // Guard against a solid brush (pen) in case the caller didn't
         if ((pbo ==NULL) || (pbo->iSolidColor != -1))
                 {
                 RIP("bSetMask - solid mask!\n");
                 *bltdef |= BD_OP1_IS_SRAM_MONO;
                 REQUIRE(4);
                 LL_FGCOLOR(0xFFFFFFFF, 2);  // totally
                 LL_BGCOLOR(0xFFFFFFFF, 2);      // foreground
                 return (TRUE);
                 }
    else if (pbo->pvRbrush != NULL)
            {
                pRbrush = pbo->pvRbrush;
        }
    else
    {
                pRbrush = BRUSHOBJ_pvGetRbrush(pbo);
                // Fail if we do not handle the brush.

                if (pRbrush == NULL)
                                {
                           DISPDBG((FILLPATH_DBG_LEVEL, "pRbrush is NULL\n"));
            return (FALSE);
                           }
    }

    //
    // Set pattern offset.
    // NT specifies patttern offset as which pixel on the screen to align
    // with pattern(0,0).  Laguna specifies pattern offset as which pixel
    // of the pattern to align with screen(0,0).  Only the lowest three
    // bits are significant, so we can ignore any overflow when converting.
    // Also, even though PATOFF is a reg_16, we can't do byte wide writes
    // to it.  We have to write both PATOFF.pt.X and PATOFF.pt.Y in a single
    // 16 bit write.
    //
#if 1 //#1244
        patoff_x = (USHORT)(-(pptlBrush->x + ppdev->ptlOffset.x) & 7);
        patoff_y = (USHORT)(-(pptlBrush->y + ppdev->ptlOffset.y) & 7);
#else
    patoff_x = 8 - (BYTE)(pptlBrush->x & 0x07);
    patoff_y = 8 - (BYTE)(pptlBrush->y & 0x07);
#endif
        REQUIRE(1);
    LL16 (grPATOFF.w, ((patoff_y << 8) | patoff_x ));

        //
        // What kind of brush is it?
        //
        if (pRbrush->iType == BRUSH_MONO) // Monochrome brush.
        {
                DISPDBG((FILLPATH_DBG_LEVEL, "bSetMask: Using monochrome brush.\n"));
                #define mb ((MC_ENTRY*)(((BYTE*)ppdev->Mtable) + pRbrush->cache_slot))
                if (mb->iUniq != pRbrush->iUniq)
                {
                        CacheMono(ppdev, pRbrush);
                }

                // Load the fg and bg color registers.
                REQUIRE(6);
                LL_FGCOLOR(0xFFFFFFFF, 0);
                LL_BGCOLOR(0x00000000, 0);

                LL32(grOP2_opMRDRAM, pRbrush->cache_xy);
                *bltdef |= 0x00D0;
                return(TRUE);
        }
        else if (pRbrush->iType == BRUSH_4BPP) // 4-bpp brush.
        {
                DISPDBG((FILLPATH_DBG_LEVEL, "bSetMask: Using 4-bpp brush.\n"));
                #define xb ((XC_ENTRY*)(((BYTE*)ppdev->Xtable) + pRbrush->cache_slot))
                if (xb->iUniq != pRbrush->iUniq)
                {
                        Cache4BPP(ppdev, pRbrush);
                }
                REQUIRE(2);
                LL32(grOP2_opMRDRAM, pRbrush->cache_xy);
                *bltdef |= 0x0090;
                return(TRUE);
        }
        else if (pRbrush->iType == BRUSH_DITHER) // Dither brush.
        {
                DISPDBG((FILLPATH_DBG_LEVEL, "bSetMask: Using dither brush.\n"));
                #define db ((DC_ENTRY*)(((BYTE*)ppdev->Dtable) + pRbrush->cache_slot))
                if (db->ulColor != pRbrush->iUniq)
                {
                        CacheDither(ppdev, pRbrush);
                }
                REQUIRE(2);
                LL32(grOP2_opMRDRAM, pRbrush->cache_xy);
                *bltdef |= 0x0090;
                return(TRUE);
        }
        else // Color brush.
        {
                DISPDBG((FILLPATH_DBG_LEVEL, "bSetMask: Using color brush.\n"));
                #define cb ((BC_ENTRY*)(((BYTE*)ppdev->Ctable) + pRbrush->cache_slot))
                if (cb->brushID != pRbrush)
                {
                        CacheBrush(ppdev, pRbrush);
                }
                REQUIRE(2);
                LL32(grOP2_opMRDRAM, pRbrush->cache_xy);
                *bltdef |= 0x0090;
                return(TRUE);
        }

        DISPDBG((FILLPATH_DBG_LEVEL, "SetMask Ret False\n"));
    return FALSE;
}

#if LOG_CALLS

extern long lg_i;
extern char lg_buf[256];

void LogFillPath(
ULONG     acc,
PPDEV     ppdev,
SURFOBJ *pso
)
{

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    lg_i = sprintf(lg_buf,"DrvFillPath: ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    // Did we realize it?  If not, why?
    switch (acc)
    {
        case  0: lg_i = sprintf(lg_buf,"(ACCL) Id=%p", pso);             break;
        case  1: lg_i = sprintf(lg_buf,"(Punted - Too many edges) ");    break;
        case  2: lg_i = sprintf(lg_buf,"(Punted - Complex clipping) ");  break;
        case  3: lg_i = sprintf(lg_buf,"(Punted - S3) ");                break;
        case  4: lg_i = sprintf(lg_buf,"(Punted - DevBmp on host) ");    break;
        case  5: lg_i = sprintf(lg_buf,"(Punted - Failed mask) ");       break;
        case  6: lg_i = sprintf(lg_buf,"(Punted - Failed brush) ");      break;
        case  7: lg_i = sprintf(lg_buf,"(Punted - Edge table failed) "); break;
        default: lg_i = sprintf(lg_buf,"(STATUS UNKNOWN) ");             break;
    }
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    lg_i = sprintf(lg_buf,"\r\n");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\lineto.c ===
/******************************************************************************\
*
* $Workfile:   lineto.c  $
*
* Contents:
* This file contains the DrvLineTo function and line drawing code for the
* CL-GD546x chips.
*
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/lineto.c  $
*
*    Rev 1.19   Mar 04 1998 15:27:54   frido
* Added new shadow macros.
*
*    Rev 1.18   Feb 27 1998 15:43:14   frido
* Roll back of 1.16.
* Removed sloped lines.
*
*    Rev 1.17   Feb 26 1998 17:16:32   frido
* Removed diagonal line drawing.
* Optimized horizontal and vertical line drawing.
*
*    Rev 1.16   Jan 26 1998 09:59:12   frido
* A complete rewrite. Ported most code from Alpine NT driver (I already did
* most of the work for that driver) and fixed all bugs in it.
*
*    Rev 1.15   Nov 03 1997 15:46:04   frido
* Added REQUIRE macros.
*
*    Rev 1.14   08 Apr 1997 12:25:36   einkauf
*
* add SYNC_W_3D to coordinat MCD/2D hw access
*
*
*    Rev 1.13   21 Mar 1997 11:43:20   noelv
*
* Combined 'do_flag' and 'sw_test_flag' together into 'pointer_switch'
*
*    Rev 1.12   04 Feb 1997 10:38:34   SueS
* Added another ifdef to the punt condition, because there's a hardware
* bug in the 2D clip engine.
*
*    Rev 1.11   27 Jan 1997 13:08:36   noelv
* Don't compile hardware clipping for 5464 chip.
*
*    Rev 1.10   27 Jan 1997 07:58:06   SueS
* Punt for the 5462/64.  There was a problem with clipping on the 62.
*
*    Rev 1.9   23 Jan 1997 15:25:34   SueS
* Added support for hardware clipping in the 5465.  For all 546x family,
* punt on complex clipping.
*
*    Rev 1.8   10 Jan 1997 17:23:48   SueS
* Reenabled DrvLineTo.  Modified clipping function.  Added boundary
* condition tests.
*
*    Rev 1.7   08 Jan 1997 14:40:48   SueS
* Temporarily punt on all DrvLineTo calls.
*
*    Rev 1.6   08 Jan 1997 09:33:24   SueS
* Punt in DrvLineTo for complex clipping.
*
*    Rev 1.5   06 Jan 1997 10:32:06   SueS
* Modified line drawing functions so that clipping is applied properly, and
* so that pixels for lines with y as the driving axis drawn from top to
* bottom will now be calculated correctly.  Changed debug statements to hex.
*
*    Rev 1.4   26 Nov 1996 10:43:02   noelv
* Changed debug level.
*
*    Rev 1.3   26 Nov 1996 10:01:22   noelv
*
* Changed Debug prints.
*
*    Rev 1.2   06 Sep 1996 15:16:26   noelv
* Updated NULL driver for 4.0
*
*    Rev 1.1   28 Aug 1996 17:25:04   noelv
* Added #IFDEF to prevent this file from being compiled into 3.51 driver.
*
*    Rev 1.0   20 Aug 1996 11:38:46   noelv
* Initial revision.
*
*    Rev 1.0   18 Aug 1996 22:52:18   frido
* Ported from CL-GD5446 code.
*
\******************************************************************************/

#include "PreComp.h"
#define LINETO_DBG_LEVEL        1

#define LEFT    0x01
#define RIGHT   0x02
#define TOP             0x04
#define BOTTOM  0x08

extern BYTE Rop2ToRop3[];
extern USHORT mixToBLTDEF[];

//
// This file isn't used in NT 3.51
//
#ifndef WINNT_VER35

/******************************************************************************\
*
* Function:     DrvLineTo
*
* This function draws a line between any two points.  This function only draws
* lines in solid colors and are just 1 pixel wide.  The end-point is not drawn.
*
* Parameters:   pso                     Pointer to surface.
*                               pco                     Pointer to CLIPOBJ.
*                               pbo                     Pointer to BRUSHOBJ.
*                               x1                      Starting x-coordinate.
*                               y1                      Starting y-coordinate.
*                               x2                      Ending x-coordinate.
*                               y2                      Ending y-coordinate.
*                               prclBounds      Pointer to an unclipped bounding rectangle.
*                               mix                     Mix to perform on the destination.
*
* Returns:      TRUE if the line has been drawn, FALSE otherwise.
*
\******************************************************************************/
BOOL DrvLineTo(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
LONG      x1,
LONG      y1,
LONG      x2,
LONG      y2,
RECTL*    prclBounds,
MIX       mix)
{
        PDEV*   ppdev;
        ULONG   ulColor;
        BYTE    iDComplexity;
        LONG    dx, dy;
        BYTE    bCode1 = 0, bCode2 = 0;
        RECTL   rclClip1, rclClip2;

        #if NULL_LINETO
        {
                if (pointer_switch)
                {
                        return(TRUE);
                }
        }
        #endif

        DISPDBG((LINETO_DBG_LEVEL, "DrvLineTo: %x,%x - %x,%x\n", x1, y1, x2, y2));
        ppdev = (PDEV*) pso->dhpdev;

        SYNC_W_3D(ppdev);

        if (pso->iType == STYPE_DEVBITMAP)
        {
                DSURF* pdsurf = (DSURF*) pso->dhsurf;
                // If the device bitmap is located in memory, try copying it back to
                // off-screen.
                if ( pdsurf->pso && !bCreateScreenFromDib(ppdev, pdsurf) )
                {
                        return(EngLineTo(pdsurf->pso, pco, pbo, x1, y1, x2, y2, prclBounds,
                                        mix));
                }
                ppdev->ptlOffset = pdsurf->ptl;
        }
        else
        {
                ppdev->ptlOffset.x = ppdev->ptlOffset.y = 0;
        }

        // Punt complex clipping.
        iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;
        if (iDComplexity == DC_COMPLEX)
        {
                DISPDBG((LINETO_DBG_LEVEL, "  Complex clipping: punt\n"));
                return(FALSE);
        }

        // Set line deltas.
        dx = x2 - x1;
        dy = y2 - y1;

        // We only handle horizontal and vertical lines.
        if ( (dx != 0) && (dy != 0) )
        {
                return(FALSE);
        }

        // Test for zero deltas.
        if ( (dx == 0) && (dy == 0) )
        {
                return(TRUE);
        }

        // Clip the coordinates.
        if (iDComplexity == DC_RECT)
        {
                // Set clipping rectangles.
                rclClip1.left   = pco->rclBounds.left;
                rclClip1.top    = pco->rclBounds.top;
                rclClip1.right  = pco->rclBounds.right - 1;
                rclClip1.bottom = pco->rclBounds.bottom - 1;

                rclClip2.left   = pco->rclBounds.left - 1;
                rclClip2.top    = pco->rclBounds.top - 1;
                rclClip2.right  = pco->rclBounds.right;
                rclClip2.bottom = pco->rclBounds.bottom;

                // Set line flags.
                if (x1 < rclClip1.left)   bCode1 |= LEFT;
                if (y1 < rclClip1.top)    bCode1 |= TOP;
                if (x1 > rclClip1.right)  bCode1 |= RIGHT;
                if (y1 > rclClip1.bottom) bCode1 |= BOTTOM;

                if (x2 < rclClip2.left)   bCode2 |= LEFT;
                if (y2 < rclClip2.top)    bCode2 |= TOP;
                if (x2 > rclClip2.right)  bCode2 |= RIGHT;
                if (y2 > rclClip2.bottom) bCode2 |= BOTTOM;

                if ((bCode1 & bCode2) != 0)
                {
                        // The line is completely clipped.
                        return(TRUE);
                }

                // Vertical line.
                if (dx == 0)
                {
                        if (bCode1 & TOP)
                        {
                                y1 = rclClip1.top;
                        }
                        else if (bCode1 & BOTTOM)
                        {
                                y1 = rclClip1.bottom;
                        }

                        if (bCode2 & TOP)
                        {
                                y2 = rclClip2.top;
                        }
                        else if (bCode2 & BOTTOM)
                        {
                                y2 = rclClip2.bottom;
                        }
                }

                // Horizontal line.
                else
                {
                        if (bCode1 & LEFT)
                        {
                                x1 = rclClip1.left;
                        }
                        else if (bCode1 & RIGHT)
                        {
                                x1 = rclClip1.right;
                        }

                        if (bCode2 & LEFT)
                        {
                                x2 = rclClip2.left;
                        }
                        else if (bCode2 & RIGHT)
                        {
                                x2 = rclClip2.right;
                        }
                }

                if (bCode1 | bCode2)
                {
                        // Recalculate line deltas.
                        dx = x2 - x1;
                        dy = y2 - y1;
                }
        }

        // Get the color from the brush.
        ASSERTMSG(pbo, "Null brush in DrvLineTo!\n");
        ulColor = pbo->iSolidColor;

        REQUIRE(9);

        // If we have a color here we need to setup the hardware.
        if (ulColor != 0xFFFFFFFF)
        {
                // Expand the color.
                switch (ppdev->ulBitCount)
                {
                        case 8:
                                ulColor |= ulColor << 8;
                        case 16:
                                ulColor |= ulColor << 16;
                }
                LL_BGCOLOR(ulColor, 2);

                // Convert mix to ternary ROP.
                ppdev->uRop    = Rop2ToRop3[mix & 0xF];
                ppdev->uBLTDEF = mixToBLTDEF[mix & 0xF];
        }
        LL_DRAWBLTDEF((ppdev->uBLTDEF << 16) | ppdev->uRop, 2);

        // Horizontal line.
        if (dy == 0)
        {
                if (dx > 0)
                {
                        // From left to right.
//above                 REQUIRE(5);
                        LL_OP0(x1 + ppdev->ptlOffset.x, y1 + ppdev->ptlOffset.y);
                        LL_BLTEXT(dx, 1);
                }
                else
                {
                        // From right to left.
//above                 REQUIRE(5);
                        LL_OP0(x2 + 1 + ppdev->ptlOffset.x, y2 + ppdev->ptlOffset.y);
                        LL_BLTEXT(-dx, 1);
                }
        }

        // Vertical line.
        else
        {
                if (dy > 0)
                {
                        // From top to bottom.
//above                 REQUIRE(5);
                        LL_OP0(x1 + ppdev->ptlOffset.x, y1 + ppdev->ptlOffset.y);
                        LL_BLTEXT(1, dy);
                }
                else
                {
                        // From bottom to top.
//above                 REQUIRE(5);
                        LL_OP0(x2 + ppdev->ptlOffset.x, y2 + 1 + ppdev->ptlOffset.y);
                        LL_BLTEXT(1, -dy);
                }
        }

        return(TRUE);
}

#endif // !WINNT_VER35
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\memmgr.c ===
/****************************************************************************
*****************************************************************************
*
*                ******************************************
*                * Copyright (c) 1995, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:      Laguna I (CL-GD5462) - 
*
* FILE:         memmgr.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*                This program provides the off screen memory management
*           using (X,Y) coordinate as memory reference instead of
*           linear memory.
*
* MODULES:
*           SaveOffscnToHost()
*           RestoreHostToOffscn()
*           DDOffScnMemAlloc()
*           DDOffScnMemRestore()
*           InitOffScnMem()
*           AllocOffScnMem()
*           FreeOffScnMem()
*           CloseOffScnMem()
*           ConvertToVideoBufferAddr()
*           OFS_AllocHdl()
*           OFS_InitMem()
*           OFS_PackMem()
*           OFS_InsertInFreeQ()
*           OFS_RemoveFrmFreeQ()
*           OFS_InsertInUsedQ()
*           OFS_RemoveFrmUsedQ()
*
* REVISION HISTORY:
*   6/12/95     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/MEMMGR.C  $
* 
*    Rev 1.48   Mar 04 1998 15:28:50   frido
* Added new shadow macros.
* 
*    Rev 1.47   Jan 22 1998 16:21:16   frido
* PDR#11132. The CopyBitmaps function is using byte aligned striping
* but was using the normal BLTEXT register instead of MBLTEXT.
* 
*    Rev 1.46   Dec 10 1997 13:32:16   frido
* Merged from 1.62 branch.
* 
*    Rev 1.45.1.2   Dec 04 1997 13:40:22   frido
* PDR#11039: Removed memory mover in 24-bpp as well.
* 
*    Rev 1.45.1.1   Dec 03 1997 18:11:10   frido
* PDR#11039. Disabled the memory mover in 32-bpp. It seems to cause
* corruption. This needs to be investigated after WHQL!
* 
*    Rev 1.45.1.0   Nov 13 1997 16:40:52   frido
* Added striping code inside the CopyBitmap routine which is used by the
* memory manager mmMove routine. This fixes the drop in speed in the
* High-End Graphics.
* 
*    Rev 1.45   Nov 03 1997 15:48:10   frido
* Added REQUIRE macros.
* 
*    Rev 1.44   Oct 28 1997 09:44:00   frido
* Fixed a compile problem with the updated mmCore.c
* 
*    Rev 1.43   02 Oct 1997 17:13:36   frido
* I have removed the extra rectangle in 1280x1024x8.
* 
*    Rev 1.42   24 Sep 1997 13:46:14   frido
* PDR#10526: Immortal Klowns needs its surfaces to be DWORD aligned in size.
* 
*    Rev 1.41   16 Sep 1997 15:07:28   bennyn
* 
* Added eight bytes alignment option
* 
*    Rev 1.40   29 Aug 1997 14:05:12   noelv
* Added MINSZY define.
* 
*    Rev 1.39   29 Aug 1997 08:54:58   FRIDO
* The old AllocOffScnMem routine had various bugs in there causing
* overlapping rectangles. The entire algoritm has been changed.
* 
*    Rev 1.38   25 Aug 1997 16:05:46   FRIDO
* 
* Added invalidation of brush cache in DDOffScnMemRestore.
* 
*    Rev 1.37   18 Aug 1997 09:21:22   FRIDO
* 
* Added initialization of bitmap filter.
* 
*    Rev 1.36   13 Aug 1997 12:16:24   bennyn
* Changed the PREALLOC_Y to 17 & Fixed the free rectange initialization bug
* 
*    Rev 1.35   08 Aug 1997 17:24:16   FRIDO
* Added support for new memory manager.
* 
*    Rev 1.34   07 Aug 1997 12:31:30   bennyn
* Undo Shuhua's fix and eliminated the extra rectangle for 1600x1200x16 and x
* 
*    Rev 1.33   06 Aug 1997 12:47:52   noelv
* Shuhua's fix for DXView no-memory bug. # 10227
* 
*    Rev 1.32   01 Jul 1997 09:53:30   einkauf
* init pdsurf to NULL in OFS_InsertInFreeQ (fix PDR 9385)
* change x tile size to 64 instead of 32 for 3D draw buffers
* 
*    Rev 1.31   29 Apr 1997 16:28:46   noelv
* 
* Merged in new SWAT code.
* SWAT: 
* SWAT:    Rev 1.6   24 Apr 1997 11:56:40   frido
* SWAT: NT140b09 merge.
* SWAT: 
* SWAT:    Rev 1.5   24 Apr 1997 11:49:56   frido
* SWAT: Removed all memory manager changes.
* SWAT: 
* SWAT:    Rev 1.4   19 Apr 1997 16:41:56   frido
* SWAT: Fixed minor bugs.
* SWAT: Added SWAT.h include file.
* SWAT: 
* SWAT:    Rev 1.3   15 Apr 1997 19:12:56   frido
* SWAT: Added more SWAT5 code (still disabled).
* SWAT: 
* SWAT:    Rev 1.2   10 Apr 1997 17:36:56   frido
* SWAT: Started work on SWAT5 optmizations.
* SWAT: 
* SWAT:    Rev 1.1   09 Apr 1997 17:33:16   frido
* SWAT: Called vAssertModeText to enable/disable font cache for DirectDraw.
* 
*    Rev 1.30   17 Apr 1997 15:31:28   noelv
* Dont' use the extra rectangle on an 8 meg board.
* 
*    Rev 1.29   17 Apr 1997 12:03:44   bennyn
* Fixed init offscn mem allocation problem for 1280x1024x24.
* 
*    Rev 1.28   26 Feb 1997 09:23:40   noelv
* 
* Added MCD support from ADC
* 
*    Rev 1.27   23 Jan 1997 10:57:32   noelv
* Added debugging option to erase memory blocks when freed.
* 
*    Rev 1.26   27 Nov 1996 11:32:42   noelv
* Disabled Magic Bitmap.  Yeah!!!
* 
*    Rev 1.25   26 Nov 1996 09:58:52   noelv
* 
* Added DBG prints.
* 
*    Rev 1.24   12 Nov 1996 15:21:58   bennyn
* 
* Fixed ALT-ENTER problem with DD appl
* 
*    Rev 1.23   07 Nov 1996 16:01:38   bennyn
* Alloc offscn mem in DD createsurface
* 
*    Rev 1.22   23 Oct 1996 14:42:42   BENNYN
* 
* CLeanup not use code for DirectDraw cursor
* 
*    Rev 1.21   18 Sep 1996 13:58:48   bennyn
* 
* Put the cursor mask and brush cache at the bottom of offscn mem
* 
*    Rev 1.20   27 Aug 1996 09:41:48   bennyn
* Restore the changes from the missing version
* 
*    Rev 1.19   26 Aug 1996 17:33:40   bennyn
* Restore the changes for the losed version
* 
*    Rev 1.18   23 Aug 1996 09:10:28   noelv
* Save unders are now discardable.
* 
*    Rev 1.7   22 Aug 1996 18:09:30   frido
* #ss -Added removing of DrvSaveScreenBits areas when DirectDraw gets
* initialized.
* 
*    Rev 1.6   20 Aug 1996 11:07:56   frido
* #ddl - Fixed DirectDraw lockup problem (compiler optimization bug).
* 
*    Rev 1.5   17 Aug 1996 19:39:16   frido
* Fixed DirectDraw cursor problem.
* 
*    Rev 1.4   17 Aug 1996 14:03:42   frido
* Added pre-compiled header.
* 
*    Rev 1.3   17 Aug 1996 13:25:28   frido
* New release from Bellevue.
* 
*    Rev 1.14   16 Aug 1996 09:04:22   bennyn
* 
* Modified to fix DirectDraw cursor problem
* 
*    Rev 1.13   07 Aug 1996 13:52:32   noelv
* 
* Cleaned up my hack job init code.
* 
*    Rev 1.12   25 Jul 1996 15:59:14   bennyn
* 
* Free more offscreen mem for DirectDraw
* 
*    Rev 1.11   11 Jul 1996 15:54:18   bennyn
* 
* Added DirectDraw support
* 
*    Rev 1.10   05 Jun 1996 09:03:10   noelv
* 
* Added the "extra rectangle".
* 
*    Rev 1.9   27 May 1996 14:53:12   BENNYN
* Use 2 free queues search instead of one
* 
*    Rev 1.8   21 May 1996 14:43:24   BENNYN
* Cleanup and code optimize.
* 
*    Rev 1.7   01 May 1996 11:00:06   bennyn
* 
* Modified for NT4.0
* 
*    Rev 1.6   25 Apr 1996 22:40:34   noelv
* Cleaned up frame buffer initialization some.  All of main rectangle is mana
* 
*    Rev 1.5   10 Apr 1996 14:14:34   NOELV
* 
* Hacked to ignore the 'extra' rectangle.
* 
*    Rev 1.4   04 Apr 1996 13:20:18   noelv
* Frido release 26
* 
*    Rev 1.2   28 Mar 1996 20:03:16   frido
* Added comments around changes.
* 
*    Rev 1.1   25 Mar 1996 11:56:26   frido
* Removed warning message.
* 
*    Rev 1.0   17 Jan 1996 12:53:26   frido
* Checked in from initial workfile by PVCS Version Manager Project Assistant.
* 
*    Rev 1.0   25 Jul 1995 11:23:18   NOELV
* Initial revision.
* 
*    Rev 1.4   20 Jun 1995 16:09:46   BENNYN
* 
* 
*    Rev 1.3   09 Jun 1995 16:03:38   BENNYN
* 
*    Rev 1.2   09 Jun 1995 09:48:54   BENNYN
* Modified the linear address offset calculation
* 
*    Rev 1.1   08 Jun 1995 15:20:08   BENNYN
* 
*    Rev 1.0   08 Jun 1995 14:54:16   BENNYN
* Initial revision.
*
****************************************************************************
****************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/
#include "precomp.h"
#include "SWAT.h"               // SWAT optimizations.

#define DISPLVL         1 

#if !MEMMGR
/******************************************************************************\
*																			   *
*					   O L D   M E M O R Y   M A N A G E R					   *
*																			   *
\******************************************************************************/

/*----------------------------- DEFINES -----------------------------------*/
// Definition of FLAG in OFMHDL structure
#define  IN_USE         1
#define  FREE           2
#define  UNKNOWN        3

#define  MEMSZY         64

#define  MINSZX         16
#define  MINSZY         1

//#define DBGBRK

#define  PREALLOC_Y     17

//
// This is a debugging option.
// We will erase (paint white) offscreen memory when it is freed.
//
#define CLEAR_WHEN_FREE 0

/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/
typedef union _HOST_DATA {
    BYTE    bData[8];
    DWORD   dwData[2];
} HOST_DATA;


/*-------------------------- STATIC VARIABLES -----------------------------*/

/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/

// Function prototypes
POFMHDL OFS_AllocHdl();
BOOL OFS_InitMem (PPDEV ppdev, PRECTL surf);
POFMHDL OFS_FindBestFitFreeBlock(PPDEV ppdev, OFMHDL *pFreeQ, 
                                 PLONG reqszx, PLONG reqszy,
                                 ULONG alignflag);
void OFS_PackMem (PPDEV ppdev, OFMHDL *hdl);
void OFS_InsertInFreeQ  (PPDEV ppdev, OFMHDL *hdl);
void OFS_RemoveFrmFreeQ (PPDEV ppdev, OFMHDL *hdl);
void OFS_InsertInUsedQ  (PPDEV ppdev, OFMHDL *hdl);
void OFS_RemoveFrmUsedQ (PPDEV ppdev, OFMHDL *hdl);
BOOL OFS_DiscardMem(PPDEV ppdev, LONG reqszx, LONG reqszy);



#ifndef WINNT_VER35
#if 0  // Save the code as sample screen to host and host to screen BLT
// ppdev->pPtrMaskHost = SaveOffscnToHost(ppdev, ppdev->PtrMaskHandle);
// RestoreHostToOffscn(ppdev, ppdev->PtrMaskHandle, ppdev->pPtrMaskHost);
/****************************************************************************
* FUNCTION NAME: SaveOffscnToHost
*
* DESCRIPTION:   Save the off-screen memory to host.
*
* Output:        Pointer to host address
*                NULL = failed.
****************************************************************************/
PBYTE SaveOffscnToHost(PPDEV ppdev, POFMHDL pdh)
{
  BYTE       *pvHost = NULL;
  BYTE       *pvHostScan0;
  HOST_DATA  rddata;
  ULONG      ultmp;
  LONG       i, j, k;
  LONG       xsize, ysize, tsize;

  if (pdh == NULL)
     return NULL;

  // Calculate the host size
  tsize = pdh->sizex * pdh->sizey;
  pvHostScan0 = (BYTE *) MEM_ALLOC (FL_ZERO_MEMORY, tsize, ALLOC_TAG);
  if (pvHostScan0  == NULL)
     return NULL;

  DISPDBG((DISPLVL, "SaveOffscnToHost\n"));

  // Do a Screen to Host BLT
  // Wait for BLT engine not busy    
  while (((ultmp = LLDR_SZ (grSTATUS)) & 0x7) != 0)
    ;

  // Save the host address in PDEV
  pvHost = pvHostScan0;

  // Setup the laguna registers for byte to byte BLT extents
  REQUIRE(9);
  LL_DRAWBLTDEF(0x201000CC, 0);

  // LL16 (grOP1_opRDRAM.pt.X, 0);
  LL_OP1_MONO (pdh->x, pdh->y);
  LL32 (grOP0_opMRDRAM.dw, 0);

  // LL16 (grMBLTEXT_EX.pt.X, (WORD)lSrcDelta);
  // LL16 (grMBLTEXT_EX.pt.Y, cy);
  xsize = pdh->sizex;
  ysize = pdh->sizey;
  LL_MBLTEXT (xsize, ysize);

  // Copy the offscreen memory data to host space
  for (i=0; i < ysize; i++)
  {
    // Copy one screen line data from source to destination
    k = 8;
    for (j=0; j < xsize; j++)
    {
      if (k > 7)
      {
         k = 0;

         // Read the offscreen data
         rddata.dwData[0] = LLDR_SZ(grHOSTDATA[0]);
         rddata.dwData[1] = LLDR_SZ(grHOSTDATA[1]);
      };
      
      *pvHostScan0 = rddata.bData[k++];
      pvHostScan0++;
    }; // end for j
  }; // end for i

  return (pvHost);
}


/****************************************************************************
* FUNCTION NAME: RestoreHostToOffscn
*
* DESCRIPTION:   Restore host data to the off-screen memory.
*
* Output:        TRUE  = success,
*                FALSE = failed.
****************************************************************************/
BOOL RestoreHostToOffscn(PPDEV ppdev, POFMHDL pdh, PBYTE pHostAddr)
{
  BYTE       *pvScan0;
  ULONG      ultmp;
  LONG       cx, cy;
  LONG       i, j, k;
  ULONG      XYcord;
  PDWORD     pPattern;
  HOST_DATA  datapattern;
  LONG       xsize, ysize;


  if ((pdh == NULL) || (pHostAddr == NULL))
     return FALSE;

  DISPDBG((DISPLVL, "RestoreHostToOffscn\n"));

  // Do the host to screen blt
  // Wait for BLT engine not busy    
  while (((ultmp = LLDR_SZ (grSTATUS)) & 0x7) != 0)
    ;

  pPattern = &datapattern.dwData[0];

  pvScan0 = pHostAddr;

  // Get dimensions of the bitmap
  cx = pdh->sizex;
  cy = pdh->sizey;

  // Setup the laguna registers for byte to byte BLT extents
  REQUIRE(9);
  LL_DRAWBLTDEF(0x102000CC, 0);

  // LL16 (grOP1_opRDRAM.pt.X, 0);
  LL_OP1 (0,0);
  XYcord = (pdh->y << 16) | (pdh->x);
  LL32 (grOP0_opMRDRAM.dw, XYcord);

  // LL16 (grMBLTEXT_EX.pt.X, (WORD)lSrcDelta);
  // LL16 (grMBLTEXT_EX.pt.Y, cy);
  LL_MBLTEXT (cx, cy);

  // Copy the host bitmap data into the space in offscreen memory
  k = 0;
  for (i=0; i < cy; i++)
  {
    datapattern.dwData[0] = 0;

    // Copy one screen line data from source to destination
    for (j=0; j < cx; j++)
    {
      datapattern.bData[k++] = *pvScan0;
      pvScan0++;
  
      if (k > 3)
      {
		 REQUIRE(1);
         LL32 (grHOSTDATA[0], *pPattern);

         k = 0;
      };  // endif (k > 3)
    }; // endfor j
  }; // end for i

  return TRUE;
}
#endif

#if 0 // SWAT3 - the "inifinite" loop has gone
#if 1 //#ddl
  #pragma optimize("", off)
#endif
#endif
/****************************************************************************
* FUNCTION NAME: DDOffScnMemAlloc()
*
* DESCRIPTION:   Free up as much off-screen memory as possible, and
*                reserve the biggest chunk for use by DirectDraw.
*
* Output:        Pointer to the OFMHDL structure or.
*                NULL means not enough memory for allocation.
****************************************************************************/
POFMHDL DDOffScnMemAlloc(PPDEV ppdev)
{
  LONG    lg_szx, lg_szy;
  OFMHDL  *pds, *pallochdl;
  POFMHDL pofm, pofmNext;
  ULONG   ultmp;

  DISPDBG((DISPLVL, "DDOffScnMemAlloc\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  #if WINBENCH96
      // Free the pre-allocate magic block
      if (ppdev->pofmMagic != NULL)
      {
          FreeOffScnMem(ppdev, ppdev->pofmMagic);
          ppdev->pofmMagic = NULL;
          ppdev->bMagicUsed = 0;
      };
  #endif

#if 0   // Not free the brush cache
  // Free the brush cache
  if (ppdev->Bcache != NULL)
  {
     FreeOffScnMem(ppdev, ppdev->Bcache);
     ppdev->Bcache = NULL;
  };
#endif  // Not free the brush cache

        // We have to move all off-screen device bitmaps to memory.
        for (pofm = ppdev->OFM_UsedQ; pofm; pofm = pofmNext)
        {
                pofmNext = pofm->nexthdl;

                if ( (pofm->pdsurf) && (pofm->pdsurf->pofm) )
                {
                        if (!bCreateDibFromScreen(ppdev, pofm->pdsurf))
                        {
                                DISPDBG((DISPLVL, "DD: Error moving off-screen bitmap to DIB"));
                                break;
                        }
                }
#if 1 //#ss
                else if (pofm->alignflag & SAVESCREEN_FLAG)
                {
                        // Free the DrvSaveScreenBits rectangle.
                        FreeOffScnMem(ppdev, pofm);
                }
#endif
        }

  // Free the Font cache.
#if 1 // SWAT3 - Font cache release has moved to vAssertModeText.
  vAssertModeText(ppdev, FALSE);
#else
  while (ppdev->pfcChain != NULL)
  {
    DrvDestroyFont(ppdev->pfcChain->pfo);
  }
#endif

  // Find the biggest chunk of free memory for use by DirectDraw.
#ifndef ALLOC_IN_CREATESURFACE
  if ((pds = ppdev->OFM_SubFreeQ2) == NULL)
     pds = ppdev->OFM_SubFreeQ1;
#endif

  pallochdl = NULL;

#ifndef ALLOC_IN_CREATESURFACE
  lg_szx = 0;
  lg_szy = 0;
  while (pds != NULL)
  {
    if (pds->flag == FREE)
    {
       if ((pds->sizex > lg_szx) || (pds->sizey > lg_szy))
       {
          lg_szx = pds->sizex;
          lg_szy = pds->sizey;
          pallochdl = pds;
       }; // if ((pds->sizex > lg_szx) || (pds->sizex > lg_szy))
    }; // if (pds->flag == FREE)

    // Next free block
    pds = pds->subnxthdl;
  } /* end while */

  // Remove the free block from Free Queue and insert into the Used Queue
  if (pallochdl != NULL)
  {
     OFS_RemoveFrmFreeQ(ppdev, pallochdl);
     OFS_InsertInUsedQ(ppdev, pallochdl);
  };
#endif

  return(pallochdl);

} // DDOffScnMemAlloc()


#if 0 // SWAT3
#if 1 //#ddl
  #pragma optimize("", on)
#endif
#endif
/****************************************************************************
* FUNCTION NAME: DDOffScnMemRestore()
*
* DESCRIPTION:   Restore the offscreen memory allocation after DirectDraw
*                use.
****************************************************************************/
void DDOffScnMemRestore(PPDEV ppdev)
{
  SIZEL   sizl;
  int     i;
  ULONG   curloc;
  ULONG   ultmp;
  DDOFM   *pds;
  DDOFM   *nxtpds;

  DISPDBG((DISPLVL, "DDOffScnMemRestore\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  // Free all the DD allocate offsreen memory
  pds = ppdev->DDOffScnMemQ;
  while (pds != NULL)
  {
    nxtpds = pds->nexthdl;
    FreeOffScnMem(ppdev, pds->phdl);
    MEMORY_FREE(pds);
    pds = nxtpds;
  };
  ppdev->DDOffScnMemQ = NULL;

  // Free the allocated DirectDraw off-screen memory
  if (ppdev->DirectDrawHandle != NULL)
  {
     FreeOffScnMem(ppdev, ppdev->DirectDrawHandle);
     ppdev->DirectDrawHandle = NULL;
  };

#if 0   // Not free the brush cache
  // Allocate brush cache
  vInvalidateBrushCache(ppdev);

  // Invalidate the entire monochrome brush cache.
  for (i = 0; i < NUM_MONO_BRUSHES; i++)
  {
    ppdev->Mtable[i].iUniq = 0;
    memset(ppdev->Mtable[i].ajPattern, 0, sizeof(ppdev->Mtable[i].ajPattern));
  }
  ppdev->MNext = 0;

  // Invalidate the entire 4-bpp brush cache.
  for (i = 0; i < NUM_4BPP_BRUSHES; i++)
  {
    ppdev->Xtable[i].iUniq = 0;
    memset(ppdev->Xtable[i].ajPattern, 0, sizeof(ppdev->Xtable[i].ajPattern));
  }
  ppdev->XNext = 0;

  // Invalidate the entire dither brush cache.
  for (i = 0; i < NUM_DITHER_BRUSHES; i++)
  {
    ppdev->Dtable[i].ulColor = (ULONG) -1;
  }
  ppdev->DNext = 0;

  // Invalidate the entire color brush cache.
  for (i = 0; i < (int) ppdev->CLast; i++)
  {
    ppdev->Ctable[i].brushID = 0;
  }
  ppdev->CNext = 0;
#else
  // Invalidate the entire brush cache now.
  vInvalidateBrushCache(ppdev);
#endif  // Not free the brush cache

  #if WINBENCH96
  // Allocate the magic block
  sizl.cx = MAGIC_SIZEX;
  sizl.cy = MAGIC_SIZEY;
  ppdev->pofmMagic =  AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);
  ppdev->bMagicUsed = 0;
  #endif

  // Invalidate all cached fonts.
  #if SWAT3
  vAssertModeText(ppdev, TRUE);
  #endif
  ppdev->ulFontCount++;

} // DDOffScnMemRestore()
#endif // ! ver3.51



/****************************************************************************
* FUNCTION NAME: InitOffScnMem()
*
* DESCRIPTION:   Initialize the offscreen memory. This module uses
*                the screen size, screen pitch and bits per pixel to
*                calculate the amount of off screen available and performs
*                the off screen memory management initialization.
*
*                When this routine is called, the following member in
*                the PDEV structure is assumed being setup for the current
*                mode.
*                    lOffset_2D,
*                    lTotalMem,
*                    lTileSize,
*                    lDeltaScreen,
*                    ulBitCount
*                    cxScreen,
*                    cyScreen.
*
*                This routine needs to be called whenever there is a
*                mode change.
*
* Output:        TRUE  = Ok,
*                FALSE = failed.
****************************************************************************/
BOOL InitOffScnMem(PPDEV ppdev)
{
    BOOL  bAllocCursorMaskBuf;
    RECTL surf;
    SIZEL rctsize;
    ULONG AvailMem;
    ULONG ulTemp;
    ULONG alignflag;
    LONG  ScnPitch;
    ULONG BytesInExtraRect, BytesInMainRect, Interleave, WidthInTiles,
    TileHeight, ExtraHeight, ExtraWidth, NumScanLines;
    ULONG ulLastLinearScan = ppdev->lTotalMem / ppdev->lDeltaScreen;
    BYTE TileCntl;

    DISPDBG((DISPLVL, "InitOffScnMem\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

    // If invalid argument or offscreen manager already initialized,
    // return FALSE
    if ((ppdev == NULL) || (ppdev->OFM_init == TRUE))
       return (FALSE);

    // Create Mutex
#ifdef WINNT_VER40
    if ((ppdev->MMhsem = EngCreateSemaphore()) == NULL)
#else
    if ((ppdev->MutexHdl = CreateMutex(NULL, FALSE, NULL)) == NULL)
#endif
       return (FALSE);

  // Wait for Mutex is released
#ifdef WINNT_VER40
  EngAcquireSemaphore(ppdev->MMhsem);
#else
  WaitForSingleObject(ppdev->MutexHdl, INFINITE);
#endif

    ppdev->bDirectDrawInUse = FALSE;
    ppdev->OFM_init = TRUE;
    ppdev->OFM_SubFreeQ1 = NULL;
    ppdev->OFM_SubFreeQ2 = NULL;
    ppdev->OFM_UsedQ = NULL;
    ppdev->OFM_FreeQ = NULL;
    ppdev->DDOffScnMemQ = NULL;

#ifdef WINNT_VER40
    ppdev->DirectDrawHandle = NULL;
#endif
  
  // Release the Mutex
#ifdef WINNT_VER40
  EngReleaseSemaphore(ppdev->MMhsem);
#else
  ReleaseMutex(ppdev->MutexHdl);
#endif

    //
    // Get the whole frame buffer as off screen memory.
    // The frame buffer is composed of 2 rectangles.  A main rectangle
    // whose width is the same as the memory pitch, and an "extra" rectangle
    // which is narrower and hangs off the lower left corner of the main 
    // rectangle.  
    //

    // The tiling interleave factor.
    TileCntl = LLDR_SZ(grTILE_CTRL);
    DISPDBG((DISPLVL, "InitOffScnMem - TileCntl = %d\n", TileCntl));
    TileCntl = (TileCntl >> 6) & 0x3;
    Interleave = 1 << TileCntl;
    
    DISPDBG((DISPLVL, "InitOffScnMem - Interleave = %d\n", Interleave));

    // Width of the frame buffer in tiles.  Each tile may be 128x16 bytes
    // or 256x8 bytes.
    WidthInTiles = ppdev->lDeltaScreen / ppdev->lTileSize;
    DISPDBG((DISPLVL, "InitOffScnMem - WidthInTiles = %d\n", WidthInTiles));

    // Get the size in bytes of the Extra rectangle.
    BytesInExtraRect = ppdev->lTotalMem % (WidthInTiles * 2048 * Interleave);
    DISPDBG((DISPLVL, "InitOffScnMem - BytesInExtraRect = %d\n", 
               BytesInExtraRect));

    // Get the size in bytes of the Main rectangle
    BytesInMainRect = ppdev->lTotalMem - BytesInExtraRect;
    DISPDBG((DISPLVL, "InitOffScnMem - BytesInMain = %d\n", BytesInMainRect));

    // Get the number of scan lines in the main rectangle.
    NumScanLines = BytesInMainRect / ppdev->lDeltaScreen;
    DISPDBG((DISPLVL, "InitOffScnMem - NumScanLines = %d\n", NumScanLines));

    // v-normmi
    ppdev->cyMemoryReal = NumScanLines; // without extra rectangle which will be
                                        // added below

    // Manage main rectangle
    if (NumScanLines > (ppdev->cyScreen + PREALLOC_Y))
    {
       surf.left = 0;
       surf.top  = 0;
       surf.right = ppdev->lDeltaScreen;
       surf.bottom = NumScanLines - PREALLOC_Y;
    }
    else if (NumScanLines > ppdev->cyScreen)
    {
       surf.left = 0;
       surf.top  = 0;
       surf.right = ppdev->lDeltaScreen;
       surf.bottom = ppdev->cyScreen;
    }

// v-normmi
//  else if ((ULONG) ppdev->lDeltaScreen != ppdev->cxScreen)
    else if ((ULONG) ppdev->lDeltaScreen != (ppdev->cxScreen * ppdev->iBytesPerPixel))
    {
       surf.left = ppdev->cxScreen * ppdev->iBytesPerPixel;
       surf.top  = 0;
       surf.right = ppdev->lDeltaScreen;
       surf.bottom = NumScanLines - PREALLOC_Y;

       if (!OFS_InitMem(ppdev, &surf))
       {
          DISPDBG((DISPLVL, "InitOffScnMem - InitMem1-1 failed\n"));
          return(FALSE);
       }

       surf.left = 0;
       surf.top  = 0;
       surf.right = ppdev->cxScreen * ppdev->iBytesPerPixel;
       surf.bottom = NumScanLines;
    }
    else
    {
       surf.left = 0;
       surf.top  = 0;
       surf.right = ppdev->lDeltaScreen;
       surf.bottom = NumScanLines;
    };

    DISPDBG((DISPLVL, "Initializing surface (x=%d,y=%d) to (x=%d,y=%d)....\n",
            surf.left, surf.top, surf.right, surf.bottom));

    if (!OFS_InitMem(ppdev, &surf))
    {
        DISPDBG((DISPLVL, "InitOffScnMem - InitMem1 failed\n"));
        return(FALSE);
    }

    // Mark a (PREALLOC_Y x Screen pitch) free block at the buttom
    // of the offscreen memory.
    // The purpose for that is to force the cursor mask and brush cache
    // to be allocated at that area.

    bAllocCursorMaskBuf = FALSE;

    if (NumScanLines > (ppdev->cyScreen + PREALLOC_Y))
    {
       bAllocCursorMaskBuf = TRUE;

       surf.left = 0;
       surf.top  = NumScanLines - PREALLOC_Y;
       surf.right = ppdev->lDeltaScreen;
       surf.bottom = NumScanLines;
    }
    else if (NumScanLines > ppdev->cyScreen)
    {
       bAllocCursorMaskBuf = TRUE;

       surf.left = 0;
       surf.top  = ppdev->cyScreen;
       surf.right = ppdev->lDeltaScreen;
       surf.bottom = NumScanLines;
    }
// v-normmi
//  else if ((ULONG) ppdev->lDeltaScreen != ppdev->cxScreen)
    else if ((ULONG) ppdev->lDeltaScreen != (ppdev->cxScreen * ppdev->iBytesPerPixel))
    {
       bAllocCursorMaskBuf = TRUE;

       surf.left = ppdev->cxScreen * ppdev->iBytesPerPixel;
       surf.top  = NumScanLines - PREALLOC_Y;
       surf.right = ppdev->lDeltaScreen;
       surf.bottom = NumScanLines;
    };

    if (bAllocCursorMaskBuf)
    {
       if (!OFS_InitMem(ppdev, &surf))
       {
          DISPDBG((DISPLVL, "InitOffScnMem - InitMem2 failed\n"));
          return(FALSE);
       }
    };

    //
    // BTN - For some reason, this extra rectange cause the WHQL PC97
    // Rand Create/Release 100x test fails on 1600x1200x16 and 1600x1200x8
    //
    if ((ppdev->cxScreen == 1600) &&
        (ppdev->cyScreen == 1200) &&
        ((ppdev->iBytesPerPixel == 2) || (ppdev->iBytesPerPixel == 1)))
        BytesInExtraRect = 0;

    //
    // Manage the extra rectangle.
    // NVH - Skip for 8 meg boards.
    //
    if (ppdev->lTotalMem < 8*1024*1024) 
    if (BytesInExtraRect)
    {
                // get Tile Height
                TileHeight = 2048 / ppdev->lTileSize;
                DISPDBG((DISPLVL, "InitOffScnMem - TileHeight = %d\n", TileHeight));

                // Get height of extra rectangle
                ExtraHeight = Interleave * TileHeight;
                DISPDBG((DISPLVL, "InitOffScnMem - ExtraHeight = %d\n", ExtraHeight));

    // v-normmi
    ppdev->cyMemoryReal += ExtraHeight; // account for extra rectangle

                // Get the width of the extra rectangle
                ExtraWidth = BytesInExtraRect / ExtraHeight;
                DISPDBG((DISPLVL, "InitOffScnMem - ExtraWidth = %d\n", ExtraWidth));

                ulLastLinearScan = (ExtraHeight + NumScanLines);  
                surf.left = 0;
                surf.top  = NumScanLines;
                surf.right = ExtraWidth;
                surf.bottom = MIN ((LONG) ulLastLinearScan,
                                (LONG) (ExtraHeight+NumScanLines));

                DISPDBG((DISPLVL, "Initializing surface (x=%d,y=%d) to (x=%d,y=%d).\n",
                                surf.left, surf.top, surf.right, surf.bottom));

        if (!OFS_InitMem(ppdev, &surf))
        {
             DISPDBG((DISPLVL, "InitOffScnMem - InitMem1 failed\n"));
             return(FALSE);
        }
    }
    else
    {
                DISPDBG((DISPLVL, " **** No extra rectangle.\n"));
    }




    #ifdef DBGBRK
        DBGBREAKPOINT();
    #endif

  // Allocate the active video buffer space from the off screen memory
  rctsize.cx = ppdev->cxScreen;
  rctsize.cy = ppdev->cyScreen;
 
  if ((ppdev->lTileSize == (LONG) 128) || (ppdev->lTileSize == (LONG) 256))
     alignflag = 0;
  else
     alignflag = NO_X_TILE_AlIGN | NO_Y_TILE_AlIGN;

  if ((ppdev->ScrnHandle = AllocOffScnMem(ppdev, &rctsize, alignflag, NULL)) == NULL)
  {
     DISPDBG((DISPLVL, "InitOffScnMem - AllocOffScnMem failed\n"));

     return(FALSE);
  };

  DISPDBG((DISPLVL, "InitOffScnMem Completed\n"));

#ifdef DBGBRK
    DBGBREAKPOINT();
#endif

  return (TRUE);

} // InitOffScnMem()



/****************************************************************************
* FUNCTION NAME: AllocOffScnMem()
*
* DESCRIPTION:   Allocate a rectange space from the offscreen memory.
*                This routine do a search of the Free Queue to find a
*                best fit free memory block. It the free block is bigger
*                than the request size, it will split the unused memory
*                into smaller rectange blocks and insert them back to
*                the Free Queue for future use. It will also do a tile
*                or pixel alignment if requested.
*      
*                If no more enough free memory for the current request,
*                This routine will search Used Queue for any discardable
*                allocated block. Releases those blocks to satisfy
*                the current request.
*
*                An user-supplied callback function will be call before
*                the discardable block is released.
*
* Input:         surf: Request of the offscreen memory size (in Pixel).
*
*                alignflag: Alignment flag.
*
*                pcallback: Callback function pointer.
*                (Only apply if the flag is set to DISCARDABLE_FLAG).
*
* Output:        Pointer to the OFMHDL structure or.
*                NULL means not enough memory for allocation.
****************************************************************************/
POFMHDL AllocOffScnMem(PPDEV  ppdev,
                       PSIZEL surf,
                       ULONG  alignflag,
                       POFM_CALLBACK  pcallback)
{
  // Convert the pixel into bytes requirement
  LONG    bpp;
  LONG    reqszx;
  LONG    reqszy;
  LONG    orgreqszx;

  OFMHDL  *pds, *pallochdl;
  BOOL    findflg, alignblkflg;
  LONG    szx, szy;
  LONG    tmpx, tmpy;

  DISPDBG((DISPLVL, "AllocOffScnMem\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  if (alignflag & MCD_Z_BUFFER_ALLOCATE)
  {
     // special memory region -> z buffer: always 16bit/pix
     bpp = 2;
  }  
  else if (alignflag & MCD_TEXTURE_ALLOCATE)
  {
     // special memory region -> texture map: depth varies and is coded in alignflag
     bpp = (alignflag & MCD_TEXTURE_ALLOCATE) >> MCD_TEXTURE_ALLOC_SHIFT;
  }  
  else  
  {
     // normal memory region -> allocate at depth of frame buffer
     bpp = ppdev->ulBitCount/8; 
  }  

  reqszx = surf->cx * bpp;
  reqszy = surf->cy;
  orgreqszx = reqszx;

  // If no more free memory or invalid arguments, return NULL
  //  if ((ppdev == NULL) || (surf == NULL) || (ppdev->OFM_FreeQ == NULL) || (!ppdev->OFM_init))
  if (ppdev->OFM_FreeQ == NULL)
     return (NULL);

#ifndef ALLOC_IN_CREATESURFACE
  if (ppdev->bDirectDrawInUse)
     return (NULL);
#endif

  // Wait for Mutex is released
#ifdef WINNT_VER40
  EngAcquireSemaphore(ppdev->MMhsem);
#else
  WaitForSingleObject(ppdev->MutexHdl, INFINITE);
#endif

  // Search for the free memory block
  findflg = FALSE;
  pallochdl = NULL;
  while (!findflg)
  {
    // Search for the best fit block for the request and
    // Check whether any free block satisfy the requirement
    if (reqszy < MEMSZY)
    {
       pallochdl = OFS_FindBestFitFreeBlock(ppdev,
                                            ppdev->OFM_SubFreeQ1,
                                            &reqszx, &reqszy,
                                            alignflag);
    };

    if (pallochdl == NULL)
    {
       pallochdl = OFS_FindBestFitFreeBlock(ppdev,
                                            ppdev->OFM_SubFreeQ2,
                                            &reqszx, &reqszy,
                                            alignflag);
    };


    if (pallochdl != NULL)
    {
       // Remove the free block from Free Queue
       OFS_RemoveFrmFreeQ(ppdev, pallochdl);

       alignblkflg = FALSE;

#if 0 // Frido 08/29/97: a new algorithm is in place now, see below. 
       // If tilt aligned, create the free block for the align adjusted
       // memory
       if (!(alignflag & PIXEL_AlIGN))
       {
          if ((tmpx = pallochdl->aligned_x - pallochdl->x) > MINSZX)
          {
             if ((pds = OFS_AllocHdl()) != NULL)
             {
                pds->x = pallochdl->x;
                pds->y = pallochdl->y;
                pds->sizex = tmpx;
                pds->sizey = reqszy;
                OFS_InsertInFreeQ(ppdev, pds);

                alignblkflg = TRUE;
             };
          };
       };

       szx = pallochdl->sizex;
       szy = pallochdl->sizey;

       // If the block is larger than the request size, create the
       // free blocks for excess size
       if ((szx > reqszx) && (szy > reqszy))
       {
          if ((szx - reqszx) > (szy - reqszy))
          {
             tmpx = reqszx;
             tmpy = szy;
          }
          else
          {
             tmpx = szx;
             tmpy = reqszy;
          };
       }
       else
       {
          tmpx = reqszx;
          tmpy = reqszy;
       };  // endif ((szx > reqszx) && (szy > reqszy))
     
       if (szx > reqszx)
       {
          if ((pds = OFS_AllocHdl()) != NULL)
          {
            pds->x = pallochdl->x + reqszx;
            pds->y = pallochdl->y;
            pds->sizex = szx - reqszx;
            pds->sizey = tmpy;
            OFS_InsertInFreeQ(ppdev, pds);
          };
       }
       else
       {
         reqszx = szx;
       };
     
       if (szy > reqszy)
       {
          if ((pds = OFS_AllocHdl()) != NULL)
          {
            pds->x = pallochdl->x;
            pds->y = pallochdl->y + reqszy;
            pds->sizex = tmpx;
            pds->sizey = szy - reqszy;
            OFS_InsertInFreeQ(ppdev, pds);
          };
       }
       else
       {
         reqszy = szy;
       };

       // If this is discardable block, save the callback function pointer     
       if ((alignflag & DISCARDABLE_FLAG) != 0)
          pallochdl->pcallback = pcallback;
       else
          pallochdl->pcallback = NULL;

       // Insert allocate block into the Used Queue
       if (alignblkflg)
       {
          pallochdl->x = pallochdl->aligned_x;
          pallochdl->y = pallochdl->aligned_y;

          pallochdl->sizex = orgreqszx;
       }
       else
       {
          pallochdl->sizex = reqszx;
       };

       pallochdl->sizey = reqszy;
#else
		tmpx = pallochdl->aligned_x + reqszx;
		tmpy = pallochdl->aligned_y + reqszy;

		// Do we have extra space at the top?
		szy = pallochdl->aligned_y - pallochdl->y;
		if (szy >= MINSZY)
		{
			pds = OFS_AllocHdl();
			if (pds != NULL)
			{
				pds->x = pallochdl->x;
				pds->y = pallochdl->y;
				pds->sizex = pallochdl->sizex;
				pds->sizey = szy;
				OFS_InsertInFreeQ(ppdev, pds);
				pallochdl->y += szy;
				pallochdl->sizey -= szy;
			}
		}

		// Do we have extra space at the bottom?
		szy = pallochdl->y + pallochdl->sizey - tmpy;
		if (szy >= MINSZY)
		{
			pds = OFS_AllocHdl();
			if (pds != NULL)
			{
				pds->x = pallochdl->x;
				pds->y = tmpy;
				pds->sizex = pallochdl->sizex;
				pds->sizey = szy;
				OFS_InsertInFreeQ(ppdev, pds);
				pallochdl->sizey -= szy;
			}
		}

		// Do we have extra space at the top?
		szx = pallochdl->aligned_x - pallochdl->x;
		if (szx >= MINSZX)
		{
			pds = OFS_AllocHdl();
			if (pds != NULL)
			{
				pds->x = pallochdl->x;
				pds->y = pallochdl->y;
				pds->sizex = szx;
				pds->sizey = pallochdl->sizey;
				OFS_InsertInFreeQ(ppdev, pds);
				pallochdl->x += szx;
				pallochdl->sizex -= szx;
			}
		}

		// Do we have extra space at the right?
		szx = pallochdl->x + pallochdl->sizex - tmpx;
		if (szx >= MINSZX)
		{
			pds = OFS_AllocHdl();
			if (pds != NULL)
			{
				pds->x = tmpx;
				pds->y = pallochdl->y;
				pds->sizex = szx;
				pds->sizey = pallochdl->sizey;
				OFS_InsertInFreeQ(ppdev, pds);
				pallochdl->sizex -= szx;
			}
		}
#endif
       pallochdl->alignflag = alignflag;
       OFS_InsertInUsedQ(ppdev, pallochdl);
   
       // Set Find flag to indicate a free block is found
       findflg = TRUE;
    }
    else
    {
      // Free block not found, try to discard any discardable memory
      // to satisfy the request
      if (!OFS_DiscardMem(ppdev, reqszx, reqszy))
      {
         DISPDBG((DISPLVL, "AllocOffScnMem failed\n"));

         // Allocation fail not enough memory
         break;
      };

    }; // endif pallochdl != NULL
  };  // endwhile

  // Release the Mutex
#ifdef WINNT_VER40
  EngReleaseSemaphore(ppdev->MMhsem);
#else
  ReleaseMutex(ppdev->MutexHdl);
#endif

  DISPDBG((DISPLVL, "AllocOffScnMem Completed\n"));

#ifdef DBGBRK
    DBGBREAKPOINT();
#endif

  if (pallochdl)
  {
    DISPDBG((DISPLVL, 
    "AllocOffScnMem: from (x=%d,y=%d) to (x=%d,y=%d).\n",
        pallochdl->x,  
        pallochdl->y, 
        (pallochdl->x + pallochdl->sizex),  
        (pallochdl->y + pallochdl->sizey)   ));
  }


  return(pallochdl);

} // AllocOffScnMem()



/****************************************************************************
* FUNCTION NAME: FreeOffScnMem()
*
* DESCRIPTION:   Free the allocated offscreen memory.
*
* Input:         Pointer to the OFMHDL structure.
* 
* Output:        TRUE  = Ok,
*                FALSE = failed.
****************************************************************************/
BOOL FreeOffScnMem(PPDEV ppdev,
                   OFMHDL *hdl)
{
  OFMHDL *pds;
  BOOL   fndflg;

  DISPDBG((DISPLVL, "FreeOffScnMem\n"));

#ifdef DBGBRK
    DBGBREAKPOINT();
#endif

//  if ((!ppdev->OFM_init) || (ppdev == NULL) || (hdl == NULL))
  if (ppdev == NULL)
     return (FALSE);

    #if CLEAR_WHEN_FREE
	REQUIRE(7);
        LL16(grBLTDEF, 0x1101);  // solid color fill
        LL16(grDRAWDEF, 0x00FF); // whiteness
        LL_OP0(hdl->x, hdl->y);
        LL_BLTEXT( (hdl->sizex/ppdev->iBytesPerPixel), hdl->sizey );
    #endif

  // Wait for Mutex is released
#ifdef WINNT_VER40
  EngAcquireSemaphore(ppdev->MMhsem);
#else
  WaitForSingleObject(ppdev->MutexHdl, INFINITE);
#endif

  // Validate the release block
  fndflg = FALSE;
  pds = ppdev->OFM_UsedQ;
  while (pds != 0)
  {
    if ((hdl == pds) && (pds->flag == IN_USE))
    {
       fndflg = TRUE;
       break;
    };

    // Next free block
    pds = pds->nexthdl;
  }; // end while

  // Return if it is an invalid handle
  if (!fndflg)  
     return (FALSE);

  DISPDBG((DISPLVL, 
  "FreeOffScnMem: from (x=%d,y=%d) to (x=%d,y=%d).\n",
      hdl->x,  
      hdl->y, 
      (hdl->x + hdl->sizex),  
      (hdl->y + hdl->sizey)   ));

  // Remove the block from the Used queue
  OFS_RemoveFrmUsedQ(ppdev, hdl);

  // Unfragment the memory
  OFS_PackMem(ppdev, hdl);

  // Insert the block into the Free queue
  OFS_InsertInFreeQ(ppdev, hdl);

  // Release the Mutex
#ifdef WINNT_VER40
  EngReleaseSemaphore(ppdev->MMhsem);
#else
  ReleaseMutex(ppdev->MutexHdl);
#endif

  DISPDBG((DISPLVL, "FreeOffScnMem Completed\n"));

#ifdef DBGBRK
    DBGBREAKPOINT();
#endif

  return (TRUE);

} // FreeOffScnMem()



/****************************************************************************
* FUNCTION NAME: CloseOffScnMem()
*
* DESCRIPTION:   Close the offscreen memory manager. This function
*                will release all allocated offscreen memories and the
*                memories used by the Offscreen manager back to Windows.
****************************************************************************/
void CloseOffScnMem(PPDEV ppdev)
{
  OFMHDL *pds;
  OFMHDL *nxtpds;

  DISPDBG((DISPLVL, "CloseOffScnMem\n"));

#ifdef DBGBRK
    DBGBREAKPOINT();
#endif

  // If invalid arguments, return NULL
  if ((!ppdev->OFM_init) || (ppdev == NULL))
     return;

  // Wait for Mutex is released
#ifdef WINNT_VER40
  EngAcquireSemaphore(ppdev->MMhsem);
#else
  WaitForSingleObject(ppdev->MutexHdl, INFINITE);
#endif

  pds = ppdev->OFM_UsedQ;
  while (pds != NULL)
  {
    nxtpds = pds->nexthdl;
    MEMORY_FREE(pds);
    pds = nxtpds;
  };

  pds = ppdev->OFM_FreeQ;
  while (pds != NULL)
  {
    nxtpds = pds->nexthdl;
    MEMORY_FREE(pds);
    pds = nxtpds;
  };

  ppdev->OFM_UsedQ = NULL;
  ppdev->OFM_FreeQ = NULL;
  ppdev->OFM_SubFreeQ1 = NULL;
  ppdev->OFM_SubFreeQ2 = NULL;
  ppdev->DDOffScnMemQ = NULL;

  ppdev->OFM_init = FALSE;

  // Release the Mutex
#ifdef WINNT_VER40
  EngReleaseSemaphore(ppdev->MMhsem);
#else
  ReleaseMutex(ppdev->MutexHdl);
#endif

  // Close the Mutex
#ifdef WINNT_VER40
  EngDeleteSemaphore(ppdev->MMhsem);
#else
  CloseHandle(ppdev->MutexHdl);
#endif

  DISPDBG((DISPLVL, "CloseOffScnMem Completed\n"));

#ifdef DBGBRK
    DBGBREAKPOINT();
#endif

} // CloseOffScnMem()



/****************************************************************************
* FUNCTION NAME: ConvertToVideoBufferAddr()
*
* DESCRIPTION:   Convert the X, Y rectange cordinate into Linear address
*                in video buffer.
*
* Input:         Pointer to the OFMHDL structure.
*
* Output:        32-bits Linear address pointer.
****************************************************************************/
PVOID ConvertToVideoBufferAddr(PPDEV ppdev, POFMHDL psurf)
{
  ULONG retaddr;

  DISPDBG((DISPLVL, "ConvertToVideoBufferAddr\n"));

  // If invalid arguments, return NULL

//v-normmi
//if ((!ppdev->OFM_init) || (ppdev == NULL) || (psurf == NULL))
  if (( ppdev == NULL) || (!ppdev->OFM_init) || (psurf == NULL))

     return (NULL);

  // Wait for Mutex is released
#ifdef WINNT_VER40
  EngAcquireSemaphore(ppdev->MMhsem);
#else
  WaitForSingleObject(ppdev->MutexHdl, INFINITE);
#endif

  // Calculate the linear address from the X & Y coordinate
  retaddr = ((ULONG) (psurf->x + (ppdev->lDeltaScreen * psurf->y))) +
            ((ULONG) ppdev->pjScreen);

  DISPDBG((DISPLVL, "ConvertToVideoBufferAddr Completed\n"));

#ifdef DBGBRK
    DBGBREAKPOINT();
#endif

  // Release the Mutex
#ifdef WINNT_VER40
  EngReleaseSemaphore(ppdev->MMhsem);
#else
  ReleaseMutex(ppdev->MutexHdl);
#endif

  return ((PVOID)retaddr);

} // ConvertToVideoBufAddr()


/****************************************************************************
* FUNCTION NAME: OFS_AllocHdl()
*
* DESCRIPTION:   Alocate offscreen memoru handler from the windows heap.
*
* Input:         None
*
* Output:        Pointer to OFMHDL structre
****************************************************************************/
POFMHDL OFS_AllocHdl()
{
  OFMHDL *pds;

#ifdef WINNT_VER40
  if ((pds = (POFMHDL) MEM_ALLOC (FL_ZERO_MEMORY, sizeof(OFMHDL), ALLOC_TAG)) != NULL)
#else
  if ((pds = (POFMHDL) MEM_ALLOC (LPTR, sizeof(OFMHDL))) != NULL)
#endif
  {
     pds->x = 0;
     pds->y = 0;
     pds->aligned_x = 0;
     pds->aligned_y = 0;
     pds->sizex = 0;
     pds->sizey = 0;
     pds->alignflag = 0;
     pds->flag = 0;
     pds->pcallback = 0;
     pds->prevhdl = 0;
     pds->nexthdl = 0;
     pds->subprvhdl = 0;
     pds->subnxthdl = 0;
     pds->prvFonthdl = 0;
     pds->nxtFonthdl = 0;
     pds->pdsurf = 0;
  };

  return (pds);

} // OFS_AllocHdl()


/****************************************************************************
* FUNCTION NAME: OFS_InitMem()
*
* DESCRIPTION:   Initialize the offscreen memory.
*
* Input:         Coordinate and size of the offscreen memory.
*
* Output:        TRUE  = Ok,
*                FALSE = failed.
****************************************************************************/
BOOL OFS_InitMem(PPDEV ppdev,
                 PRECTL surf)
{
  OFMHDL *pds;

  // Allocate the control block handle from local windows memory pool
#ifdef WINNT_VER40
  if ((pds = (POFMHDL) MEM_ALLOC(FL_ZERO_MEMORY, sizeof(OFMHDL), ALLOC_TAG)) == NULL)
#else
  if ((pds = (POFMHDL) MEM_ALLOC(LPTR, sizeof(OFMHDL))) == NULL)
#endif
     return (FALSE);

  // Wait for Mutex is released
#ifdef WINNT_VER40
  EngAcquireSemaphore(ppdev->MMhsem);
#else
  WaitForSingleObject(ppdev->MutexHdl, INFINITE);
#endif

  // Insert the free memory block into the queue
  pds->x = surf->left;
  pds->y = surf->top;
  pds->sizex = surf->right - surf->left;
  pds->sizey = surf->bottom - surf->top;
  OFS_InsertInFreeQ(ppdev, pds);

  // Release the Mutex
#ifdef WINNT_VER40
  EngReleaseSemaphore(ppdev->MMhsem);
#else
  ReleaseMutex(ppdev->MutexHdl);
#endif

  return (TRUE);

} // OFS_InitMem()



/****************************************************************************
* FUNCTION NAME: OFS_FindBestFitFreeBlock()
*
* DESCRIPTION:   Find the best fit free block.
*
* Input:         Request offscreen memory size (in bytes).
*
* Output:        Pointer to the OFMHDL structure or.
*                NULL means not enough memory for allocation.
****************************************************************************/
POFMHDL OFS_FindBestFitFreeBlock(PPDEV  ppdev,
                                 OFMHDL *pFreeQ,
                                 PLONG  preqszx,
                                 PLONG  preqszy,
                                 ULONG  alignflag)
{
  OFMHDL *pds = pFreeQ;
  LONG    reqszx = *preqszx;
  LONG    reqszy = *preqszy;
  OFMHDL  *pbestfit_hdl = NULL;
  LONG    bestfitx = 0x7FFFFFF;
  LONG    bestfity = 0x7FFFFFF;
  LONG    bpp;
  LONG    tileszx = 0;
  LONG    tileszy = 0;
  LONG    maskx = 0;
  LONG    masky = 0;
  BOOL    Findit = FALSE;

  ULONG   bestfit_aligned_x, bestfit_aligned_y;
  LONG    bestfit_Reqszx, bestfit_Reqszy;
  ULONG   aligned_x, aligned_y;
  LONG    szx, szy;
  LONG    NewReqszx, NewReqszy;
  BOOL    adjxflg, adjyflg;

  if (alignflag & MCD_Z_BUFFER_ALLOCATE)
  {
     // special memory region -> z buffer: always 16bit/pix
     bpp = 2;
  }  
  else if (alignflag & MCD_TEXTURE_ALLOCATE)
  {
     // special memory region -> texture map: depth varies and is coded in alignflag
     bpp = (alignflag & MCD_TEXTURE_ALLOCATE) >> MCD_TEXTURE_ALLOC_SHIFT;
  }  
  else  
  {
     // normal memory region -> allocate at depth of frame buffer
     bpp = ppdev->ulBitCount/8; 
  }  

  // Check the alignment flag and adjust the request size accordingly.
  if (alignflag & EIGHT_BYTES_ALIGN)
	{  // 8 bytes alignment.
     tileszx = 8;
     tileszy = 1;
     maskx = tileszx - 0x1;
     masky = 0;
	}
  else if (alignflag & PIXEL_AlIGN)
  {
     tileszx = bpp;
     tileszy = 1;
     maskx = tileszx - 0x1;
     masky = 0;

     if (bpp == 3)
     {
        maskx += 1;
        masky += 1;
     };
  }
  else if (alignflag & (MCD_DRAW_BUFFER_ALLOCATE|MCD_Z_BUFFER_ALLOCATE|MCD_TEXTURE_ALLOCATE))
  {
     // Determine tile size
     if (alignflag & MCD_DRAW_BUFFER_ALLOCATE)
         tileszx = 64;  // rgb buffer on 64 byte boundary (z always at x=0, so tile doesn't matter)
     else
         tileszx = 32;  // texture on 32 byte boundary

     if (alignflag & MCD_TEXTURE_ALLOCATE)
         tileszy = 16;  // textures must be on 16 scanline boundary
     else
         tileszy = 32;  // z,backbuf must be on 32 scanline boundary

     maskx = tileszx - 1;
     masky = tileszy - 1;
  }
  else
  {
     // Determine tile size
     tileszx = ppdev->lTileSize;
     tileszy = (LONG) 2048/ppdev->lTileSize;
     maskx = tileszx - 1;
     masky = tileszy - 1;
  };

  // Search for the best fit block for the request
  while (pds != NULL)
  {
    if (pds->flag == FREE)
    {
       szx = pds->sizex;
       szy = pds->sizey;
       // MCD z buffer, and possibly color buffer need to start at x=0 
       if ((szx >= reqszx) && (szy >= reqszy) && (!(alignflag & MCD_NO_X_OFFSET) || (pds->x==0)))
       {
          // If yes, calculate the aligned rectange starting positions
          aligned_x = pds->x;
          aligned_y = pds->y;

          adjxflg = FALSE;
          adjyflg = FALSE;
          if (alignflag & PIXEL_AlIGN)
          {
             if ((pds->x % bpp) != 0)
                adjxflg = TRUE;
      
             if ((pds->y % bpp) != 0)
                adjyflg = TRUE;
          }
          else
          {

             if ((!(alignflag & NO_X_TILE_AlIGN)) && ((pds->x % tileszx) != 0))
                adjxflg = TRUE;

             if ((!(alignflag & NO_Y_TILE_AlIGN)) && ((pds->y % tileszy) != 0))
                adjyflg = TRUE;
          };

          if (adjxflg)
             aligned_x = (pds->x & (~maskx)) + tileszx;

          if (adjyflg)
             aligned_y = (pds->y & (~masky)) + tileszy;

          // Adjust the request size again to fit the required alignment
          NewReqszx = reqszx + (aligned_x - pds->x);
          NewReqszy = reqszy + (aligned_y - pds->y);

          // Check the allocate block is large enough to hold the adjusted
          // request size
          if ((szx >= NewReqszx) && (szy >= NewReqszy))
          {
             if ((szx == NewReqszx) && (szy == NewReqszy))
             {
                Findit = TRUE;
                bestfit_Reqszx = NewReqszx;
                bestfit_Reqszy = NewReqszy;
                bestfit_aligned_x = aligned_x;
                bestfit_aligned_y = aligned_y;
                pbestfit_hdl = pds;
             }
             else if ((bestfitx > szx) || (bestfity > szy))
             {
                bestfit_Reqszx = NewReqszx;
                bestfit_Reqszy = NewReqszy;
                bestfit_aligned_x = aligned_x;
                bestfit_aligned_y = aligned_y;
                bestfitx = szx; 
                bestfity = szy;
                pbestfit_hdl = pds;
             }; // if ((bestfitx > szx) || (bestfity > szy))
          }; // if ((szx >= NewReqszx) && (szy >= NewReqszy))

       }; // if ((szx >= reqszx) && (szy >= reqszy))
    }; // if (pds->flag == FREE)

    // Next free block
    if (Findit)
       pds = NULL;
    else
       pds = pds->subnxthdl;
  } /* end while */

  if (pbestfit_hdl != NULL)
  {
     *preqszx = bestfit_Reqszx;
     *preqszy = bestfit_Reqszy;

     pbestfit_hdl->aligned_x = bestfit_aligned_x;
     pbestfit_hdl->aligned_y = bestfit_aligned_y;
  };

  return(pbestfit_hdl);

} // OFS_FindBestFitFreeBlock()



/****************************************************************************
* FUNCTION NAME: OFS_PackMem()
*
* DESCRIPTION:   Unfragment the memory.
*                This routine combines current release memory block
*                with the adjacent free blocks of same X or Y dimension into 
*                one big free block.
****************************************************************************/
void OFS_PackMem(PPDEV ppdev,
                 OFMHDL *hdl)
{
  BOOL  cmbflg;
  OFMHDL *pds;
  ULONG pdsxdim, pdsydim;

  pds = ppdev->OFM_FreeQ;
  while (pds != NULL)
  {
    // Check for any free block (aliasing in either X or Y direction)
    // before or after the current release block.
    // If yes, combine the two into one big free block
    pdsxdim = pds->x + pds->sizex;
    pdsydim = pds->y + pds->sizey;

    cmbflg = FALSE;

    // Check for X-axis
    if ((hdl->x == pds->x) && ((hdl->x + hdl->sizex) == pdsxdim))
    {
       if ((hdl->y == pdsydim) || (hdl->y == (pds->y - hdl->sizey)))
       {
          cmbflg = TRUE;
          hdl->sizey += pds->sizey;
          if (hdl->y == pdsydim)
             hdl->y = pds->y;
       };
    };

    // Check for Y-axis
    if ((hdl->y == pds->y) && ((hdl->y + hdl->sizey) == pdsydim))
    {
       if ((hdl->x == pdsxdim) || (hdl->x == (pds->x - hdl->sizex)))
       {
          cmbflg = TRUE;
          hdl->sizex += pds->sizex;
          if (hdl->x == pdsxdim)
             hdl->x = pds->x;
       };
    };

    if (cmbflg)
    {
      OFS_RemoveFrmFreeQ(ppdev, pds);

      // Release control block to Windows
      MEMORY_FREE(pds);

      // Restart the unfragment memory processing
      pds = ppdev->OFM_FreeQ;
    }
    else
    {
      // Next free block
      pds = pds->nexthdl;
    };
  }; // end while

} // OFS_PackMem



/****************************************************************************
* FUNCTION NAME: OFS_InsertInFreeQ()
*
* DESCRIPTION:   Insert the handle into the Free queue.
*
* Input:         Pointer to the OFMHDL structure.
*
* Output:        None
****************************************************************************/
void OFS_InsertInFreeQ(PPDEV  ppdev,
                       OFMHDL *hdl)
{
  hdl->flag = FREE;
  hdl->prevhdl = NULL;
  hdl->subprvhdl = NULL;    
  hdl->aligned_x = 0;
  hdl->aligned_y = 0;
  hdl->alignflag = 0;
  hdl->pcallback = NULL;

  // Fix for PDR9385 - added by Mark Einkauf
  // if pdsurf non-zero, when this block reused later, various DIB functions can misbehave
  // Exact scenario in 9385 was...
  //   first app exit:
  //    DrvDisableDirectDraw freed all OFM blocks (leaving pdsurf field non-0 in some cases)
  //   next app startup:
  //    DrvGetDirectDrawInfo, calls...
  //        DDOffScnMemAlloc 
  //            - loops through all OFM_UsedQ blocks, searching for
  //              off screen bit maps it can convert to DIB (and then free the offscreen memory)
  //            - Finds UsedQ block with non-zero pdsurf, pointing to non-existent pdsurf, 
  //                which then had non-zero pofm field, causing it to appear as a valid
  //                off-screen bitmap    
  //            - does memcpy with garbage x,y,sizex,sizey, wreaking havoc on system memory
  //                in a random sort of way
  hdl->pdsurf = NULL;

  // Insert into the SubFreeQs
  if (hdl->sizey < MEMSZY)
  {
     if (ppdev->OFM_SubFreeQ1 == NULL)
     {
       hdl->subnxthdl = NULL;
       ppdev->OFM_SubFreeQ1 = hdl;
     }
     else
     {
       ppdev->OFM_SubFreeQ1->subprvhdl = hdl;
       hdl->subnxthdl = ppdev->OFM_SubFreeQ1;
       ppdev->OFM_SubFreeQ1 = hdl;
     };
  }
  else
  {
     if (ppdev->OFM_SubFreeQ2 == NULL)
     {
       hdl->subnxthdl = NULL;
       ppdev->OFM_SubFreeQ2 = hdl;
     }
     else
     {
       ppdev->OFM_SubFreeQ2->subprvhdl = hdl;
       hdl->subnxthdl = ppdev->OFM_SubFreeQ2;
       ppdev->OFM_SubFreeQ2 = hdl;
     };
  };

  // Insert into the Main FreeQ
  if (ppdev->OFM_FreeQ == NULL)
  {
     hdl->nexthdl = NULL;
     ppdev->OFM_FreeQ = hdl;
  }
  else
  {
     ppdev->OFM_FreeQ->prevhdl = hdl;
     hdl->nexthdl = ppdev->OFM_FreeQ;
     ppdev->OFM_FreeQ = hdl;
  };

} // OFS_InsertInFreeQ()



/****************************************************************************
* FUNCTION NAME: OFS_RemoveFrmFreeQ()
*
* DESCRIPTION:   Remove the handle from the Free queue.
****************************************************************************/
void OFS_RemoveFrmFreeQ(PPDEV  ppdev,
                        OFMHDL *hdl)
{
  OFMHDL *prvpds, *nxtpds;
  OFMHDL *subprvpds, *subnxtpds;

  hdl->flag = UNKNOWN;
  prvpds = hdl->prevhdl;
  nxtpds = hdl->nexthdl;
  subprvpds = hdl->subprvhdl;
  subnxtpds = hdl->subnxthdl;

  // Remove from the SubFreeQs
  if (hdl->sizey < MEMSZY)
  {
     if (hdl == ppdev->OFM_SubFreeQ1)
     {
       ppdev->OFM_SubFreeQ1 = subnxtpds;
   
       if (subnxtpds != 0)
          subnxtpds->subprvhdl = NULL;
     }
     else
     {
       if (subnxtpds != NULL)
          subnxtpds->subprvhdl = subprvpds;
   
       if (subprvpds != NULL)
          subprvpds->subnxthdl = subnxtpds;
     };
  }
  else
  {
     if (hdl == ppdev->OFM_SubFreeQ2)
     {
       ppdev->OFM_SubFreeQ2 = subnxtpds;
   
       if (subnxtpds != 0)
          subnxtpds->subprvhdl = NULL;
     }
     else
     {
       if (subnxtpds != NULL)
          subnxtpds->subprvhdl = subprvpds;
   
       if (subprvpds != NULL)
          subprvpds->subnxthdl = subnxtpds;
     };
  };

  // Remove from the Main FreeQ
  if (hdl == ppdev->OFM_FreeQ)
  {
    ppdev->OFM_FreeQ = nxtpds;

    if (nxtpds != 0)
       nxtpds->prevhdl = NULL;
  }
  else
  {
    if (nxtpds != NULL)
       nxtpds->prevhdl = prvpds;

    if (prvpds != NULL)
       prvpds->nexthdl = nxtpds;
  };
} // OFS_RemoveFrmFreeQ



/****************************************************************************
* FUNCTION NAME: OFS_InsertInUsedQ()
*
* DESCRIPTION:   Insert the handle into the Used queue.
****************************************************************************/
void OFS_InsertInUsedQ(PPDEV  ppdev,
                       OFMHDL *hdl)
{
  hdl->flag = IN_USE;
  hdl->prevhdl = NULL;

  if (ppdev->OFM_UsedQ == NULL)
  {
    hdl->nexthdl = NULL;
    ppdev->OFM_UsedQ = hdl;
  }
  else
  {
    ppdev->OFM_UsedQ->prevhdl = hdl;
    hdl->nexthdl = ppdev->OFM_UsedQ;
    ppdev->OFM_UsedQ = hdl;
  };

} // OFS_InsertInUsedQ()



/****************************************************************************
* FUNCTION NAME: OFS_RemoveFrmUsedQ()
*
* DESCRIPTION:   Remove the handle from the Used queue.
****************************************************************************/
void OFS_RemoveFrmUsedQ(PPDEV  ppdev,
                        OFMHDL *hdl)
{
  OFMHDL *prvpds, *nxtpds;

  hdl->flag = UNKNOWN;
  prvpds = hdl->prevhdl;
  nxtpds = hdl->nexthdl;

  if (hdl == ppdev->OFM_UsedQ)
  {
    ppdev->OFM_UsedQ = nxtpds;

    if (nxtpds != 0)
       nxtpds->prevhdl = NULL;
  }
  else
  {
    if (nxtpds != NULL)
       nxtpds->prevhdl = prvpds;

    if (prvpds != NULL)
       prvpds->nexthdl = nxtpds;
  };

} // OFS_RemoveFrmUsedQ()



/****************************************************************************
* FUNCTION NAME: OFS_DiscardMem()
*
* DESCRIPTION:   This routine search Used Queue to find any discardable
*                allocated block. Releases those blocks to satisfy
*                the current request.
*
* Input:         Request offscreen memory size (in bytes).
*
* Output:        TRUE:  Find a free block.
*                FALSE: No free block available.
****************************************************************************/
BOOL OFS_DiscardMem(PPDEV ppdev,
                    LONG  reqszx,
                    LONG  reqszy)
{
  OFMHDL *hdl, *pds;
  
  hdl = ppdev->OFM_UsedQ;
  while (hdl != NULL)
  {
    if ((hdl->alignflag & DISCARDABLE_FLAG) != 0)
    {
       // Save the handle
       pds = hdl;

       // Get next free block handle
       hdl = hdl->nexthdl;

       // Call the callback function
       if (pds->pcallback != NULL)
          pds->pcallback();

       // Remove this discardable block from the Used queue
       OFS_RemoveFrmUsedQ(ppdev, pds);

       // Unfragment the memory
       OFS_PackMem(ppdev, pds);

       // Insert the block into the Free queue
       OFS_InsertInFreeQ(ppdev, pds);

       // Return TRUE, if the combined block is satisfy the request.
       // Otherwise continues search for next discardable block.
       if ((pds->sizex >= reqszx) && (pds->sizey >= reqszy))
          return TRUE;
    }
    else
    {
       // Next free block
       hdl = hdl->nexthdl;
    }; // endif ((hdl->alignflag & DISCARDABLE_FLAG) != 0)

  };  // endwhile (hdl != NULL)

  // Return FALSE, no more discardable block to release and still
  // no free block large enough for the request.
  return FALSE;

} // OFS_DiscardMem
#else /* MEMMGR */

/******************************************************************************\
*																			   *
*					   N E W   M E M O R Y   M A N A G E R					   *
*																			   *
\******************************************************************************/

#ifdef WINNT_VER40
	#define CREATE_MUTEX(ppdev)	ppdev->MMhsem = EngCreateSemaphore()
	#define DELETE_MUTEX(ppdev)	EngDeleteSemaphore(ppdev->MMhsem)
	#define	BEGIN_MUTEX(ppdev)	EngAcquireSemaphore(ppdev->MMhsem);
	#define END_MUTEX(ppdev)	EngReleaseSemaphore(ppdev->MMhsem)
#else
	#define CREATE_MUTEX(ppdev)	ppdev->MutexHdl = CreateMutex(NULL, FALSE, NULL)
	#define DELETE_MUTEX(ppdev)	CloseHandle(ppdev->MutexHdl)
	#define	BEGIN_MUTEX(ppdev)	WaitForSingleObject(ppdev->MutexHdl, INFINITE);
	#define END_MUTEX(ppdev)	ReleaseMutex(ppdev->MutexHdl)
#endif

/******************************************************************************\
* Function:		HostifyBitmap
*
* Purpose:		Move a device bitmap from off-screen memory to host memory.
*
* On entry:		pdm			Pointer to node to hostify.
*
* Returns:		TRUE if successful, FALSE if there is an error.
\******************************************************************************/
BOOL HostifyBitmap(PDEVMEM pdm)
{
	if (pdm->ofm.pdsurf != NULL)
	{
		// Hostify the bitmap.
		if (!bCreateDibFromScreen(pdm->ofm.pdsurf->ppdev, pdm->ofm.pdsurf))
		{
			// There was an error.
			return FALSE;
		}
	}

	return TRUE;
}

/******************************************************************************\
* Function:		HostifyAllBitmaps
*
* Purpose:		Move all device bitmaps from off-screen memory to host memory.
*
* On entry:		ppdev		Pointer to physical device.
*
* Returns:		Nothing.
\******************************************************************************/
void HostifyAllBitmaps(PPDEV ppdev)
{
	PDEVMEM	pdm, pdmNext;

	// Walk through all used nodes.
	for (pdm = ppdev->mmMemMgr.pdmUsed; pdm != NULL; pdm = pdmNext)
	{
		// Save pointer to next node.
		pdmNext = pdm->next;

		// If this is a device bitmap, hostify it.
		if (pdm->ofm.pdsurf != NULL)
		{
			if (bCreateDibFromScreen(ppdev, pdm->ofm.pdsurf))
			{
				// After successful hostification, free the node.
				mmFree(&ppdev->mmMemMgr, pdm);
			}
		}

		// If this is a SaveScreen bitmap, just remove it.
		else if (pdm->ofm.alignflag & SAVESCREEN_FLAG)
		{
			mmFree(&ppdev->mmMemMgr, pdm);
		}
	}
}

/******************************************************************************\
* Function:		CopyBitmap
*
* Purpose:		Move a device bitmap in off-screen memory.
*
* On entry:		pdmNew		Pointer to new node for device bitmap.
*				pdmOld		Pointer to old node of device bitmap.
*
* Returns:		Nothing.
\******************************************************************************/
void CopyBitmap(PDEVMEM pdmNew, PDEVMEM pdmOld)
{
	PPDEV	ppdev;
	PDSURF	pdsurf;
	ULONG	xSrc, xDest, xExt, cx;
	BOOL	fFirst = TRUE;

	// Set the pointers to the device bitmap and physical device.
	pdsurf = pdmOld->ofm.pdsurf;
	ppdev = pdsurf->ppdev;

	// Setup the values in the old NT structure.
	pdmNew->ofm.x = pdmNew->ofm.aligned_x = pdmNew->cbAddr.pt.x;
	pdmNew->ofm.y = pdmNew->ofm.aligned_y = pdmNew->cbAddr.pt.y;
	pdmNew->ofm.sizex = pdmNew->cbSize.pt.x;
	pdmNew->ofm.sizey = pdmNew->cbSize.pt.y;

	// Copy the information from the old node.
	pdmNew->ofm.alignflag = pdmOld->ofm.alignflag;
	pdmNew->ofm.pcallback = pdmOld->ofm.pcallback;
	pdmNew->ofm.pdsurf = pdsurf;

	// Update the device bitmap structure.
	pdsurf->pofm = (POFMHDL) pdmNew;
	pdsurf->ptl.x = pdmNew->cbAddr.pt.x / ppdev->iBytesPerPixel;
	pdsurf->ptl.y = pdmNew->cbAddr.pt.y;
	pdsurf->packedXY = (pdsurf->ptl.y << 16) | pdsurf->ptl.x;

	// Copy the device bitmap to a new location.
	xSrc = pdmOld->cbAddr.pt.x;
	xDest = pdmNew->cbAddr.pt.x;
	xExt = pdmNew->cbSize.pt.x;

	// We do striping.
	while (xExt > 0)
	{
		cx = min( xExt, ppdev->lTileSize - (xSrc % ppdev->lTileSize) );
		cx = min( cx, ppdev->lTileSize - (xDest % ppdev->lTileSize) );
		if (fFirst)
		{
			fFirst = FALSE;
			REQUIRE(9);
			LL_DRAWBLTDEF(0x101000CC, 0);
			LL_OP1_MONO(xSrc, pdmOld->cbAddr.pt.y);
			LL_OP0_MONO(xDest, pdmNew->cbAddr.pt.y);
			LL_MBLTEXT(cx, pdmNew->cbSize.pt.y);
		}
		else
		{
			REQUIRE(4);
			LL16(grOP1_opMRDRAM.PT.X, xSrc);
			LL16(grOP0_opMRDRAM.PT.X, xDest);
			LL16(grMBLTEXT_XEX.PT.X, cx);
		}
		xSrc += cx;
		xDest += cx;
		xExt -= cx;
	}
}

/******************************************************************************\
* Function:		InitOffScnMem
*
* Purpose:		Initialize the off-screen memory manager.
*
* On entry:		ppdev		Pointer to physical device.
*
* Returns:		TRUE if successful, FALSE if there is an error.
\******************************************************************************/
BOOL InitOffScnMem(PPDEV ppdev)
{
	UINT	Interleave, WidthInTiles, ExtraWidth, ExtraHeight;
	ULONG	BytesInMainRect, BytesInExtraRect;
	GXRECT	rect;
	SIZEL	size;
	GXPOINT	align;
	PDEVMEM	pdm;

	DISPDBG((DISPLVL, "InitOffScnMem\n"));

	// Already initialized?
	if (ppdev == NULL || ppdev->OFM_init == TRUE)
	{
		DISPDBG((DISPLVL, "InitOffScnMem: already initialized\n"));
		return FALSE;
	}

	// Create the semaphore.
	if ((CREATE_MUTEX(ppdev)) == NULL)
	{
		DISPDBG((DISPLVL, "InitOffScnMem: CREATE_MUTEX failed\n"));
		return FALSE;
	}

	// Setup the maximum width for a device bitmap for which we will move and
	// hostify other devcie bitmaps.
	if ( (ppdev->iBytesPerPixel == 3) || (ppdev->iBytesPerPixel == 4) )
	{
		ppdev->must_have_width = 0;
	}
	else
	{
		ppdev->must_have_width = ppdev->cxScreen * 98 / 100;
	}

	// Calculate memory stuff.
	Interleave = 1 << ((LLDR_SZ(grTILE_CTRL) & 0xC0) >> 6);
	WidthInTiles = ppdev->lDeltaScreen / ppdev->lTileSize;
	BytesInExtraRect = ppdev->lTotalMem % (WidthInTiles * 2048 * Interleave);
	BytesInMainRect = ppdev->lTotalMem - BytesInExtraRect;

    //
    // BTN - For some reason, this extra rectange cause the WHQL PC97
    // Rand Create/Release 100x test fails on 1600x1200x16 and 1600x1200x8
    //
    if ((ppdev->cxScreen == 1600) &&
        (ppdev->cyScreen == 1200) &&
        ((ppdev->iBytesPerPixel == 2) || (ppdev->iBytesPerPixel == 1)))
        BytesInExtraRect = 0;
	//
	// I have removed the extra rectangle at 1280x1024x8.  Somehow it messes up
	// FoxBear.
	//
	if (   (ppdev->cxScreen == 1280)
		&& (ppdev->cyScreen == 1024)
		&& (ppdev->iBytesPerPixel == 1)
	)
	{
		BytesInExtraRect = 0;
	}

	// Setup the main rectangle.
	rect.left = 0;
	rect.top = 0;
	rect.right = ppdev->lDeltaScreen;
	rect.bottom = BytesInMainRect / ppdev->lDeltaScreen;

	// Setup the extra rectangle.
	if (BytesInExtraRect && ppdev->lTotalMem < 8 * 1024 * 1024)
	{
		ExtraHeight = Interleave * 2048 / ppdev->lTileSize;
		ExtraWidth = BytesInExtraRect / ExtraHeight;
	}
	else
	{
		ExtraWidth = ExtraHeight = 0;
	}

// v-normmi   effective height of direct frame buffer access region
//              not all of it is populated with memory
    ppdev->cyMemoryReal = rect.bottom + ExtraHeight;

	BEGIN_MUTEX(ppdev)
	{
		// Initialize the mmemory manager core.
		ppdev->mmMemMgr.mmTileWidth = ppdev->lTileSize;
		ppdev->mmMemMgr.mmHeapWidth = rect.right;
		ppdev->mmMemMgr.mmHeapHeight = rect.bottom + ExtraHeight;
		mmInit(&ppdev->mmMemMgr);

		// Initialize flags and queues.
		ppdev->OFM_init = TRUE;
		ppdev->bDirectDrawInUse = FALSE;
		ppdev->DDOffScnMemQ = FALSE;
		ppdev->DirectDrawHandle = NULL;
	}
	END_MUTEX(ppdev);

	// Add the main rectangle to the heap.
	if (!mmAddRectToList(&ppdev->mmMemMgr, &ppdev->mmMemMgr.pdmHeap, &rect,
			FALSE))
	{
		DISPDBG((DISPLVL, "InitOffScnMem: mmAddRectToList failed\n"));
		return FALSE;
	}
	DISPDBG((DISPLVL, "InitOffScnMem: main rectangle from (%d,%d) to (%d,%d)\n",
			rect.left, rect.top, rect.right, rect.bottom));

	// Add the extra rectangle to the heap.
	if (ExtraWidth > 0 && ExtraHeight > 0)
	{
		rect.left = 0;
		rect.top = rect.bottom;
		rect.right = ExtraWidth;
		rect.bottom += ExtraHeight;
		if (mmAddRectToList(&ppdev->mmMemMgr, &ppdev->mmMemMgr.pdmHeap, &rect,
				FALSE))
		{
			DISPDBG((DISPLVL, "InitOffScnMem: "
					"extra rectangle from (%d,%d) to (%d,%d)\n", rect.left,
					rect.top, rect.right, rect.bottom));
		}
	}

	// Allocate a node for the screen.
	size.cx = ppdev->cxScreen;
	size.cy = ppdev->cyScreen;
	ppdev->ScrnHandle = AllocOffScnMem(ppdev, &size, SCREEN_ALLOCATE, NULL);
	if (ppdev->ScrnHandle == NULL)
	{
		DISPDBG((DISPLVL, "InitOffScnMem: AllocOffScnMem failed\n"));
		return FALSE;
	}

	// Determine if bitmap filter should be turned on.
	align.pt.x = align.pt.y = 1;
	pdm = mmAllocLargest(&ppdev->mmMemMgr, align);
	if (pdm == NULL)
	{
		DISPDBG((DISPLVL, "InitOffScnMem: mmAllocLargest faled\n"));
		return FALSE;
	}
	size.cx = pdm->cbSize.pt.x / ppdev->iBytesPerPixel;
	size.cy = pdm->cbSize.pt.y;
	mmFree(&ppdev->mmMemMgr, pdm);

	if ((ULONG) size.cx < ppdev->cxScreen || (ULONG) size.cy < ppdev->cyScreen)
	{
		ppdev->fBitmapFilter = TRUE;
		ppdev->szlBitmapMin.cx = 64;
		ppdev->szlBitmapMin.cy = 64;
		ppdev->szlBitmapMax.cx = size.cx;
		ppdev->szlBitmapMax.cy = size.cy;
	}
	else
	{
		ppdev->fBitmapFilter = FALSE;
	}

	// Return success.
	DISPDBG((DISPLVL, "InitOffScnMem: completed\n"));
	return TRUE;
}

/******************************************************************************\
* Function:		CloseOffScnMem
*
* Purpose:		Free all memory allocated for the off-screen memory manager.
*
* On entry:		ppdev		Pointer to physical device.
*
* Returns:		Nothing.
\******************************************************************************/
void CloseOffScnMem(PPDEV ppdev)
{
	PHANDLES ph, phNext;

	DISPDBG((DISPLVL, "CloseOffScnMem\n"));

	// Already closed?
	if (ppdev == NULL || !ppdev->OFM_init)
	{
		DISPDBG((DISPLVL, "CloseOffScnMem: already closed\n"));
		return;
	}

	BEGIN_MUTEX(ppdev)
	{
		// Delete all allocated arrays.
		for (ph = ppdev->mmMemMgr.phArray; ph != NULL; ph = phNext)
		{
			phNext = ph->pNext;
			MEMORY_FREE(ph);
		}
		ppdev->mmMemMgr.phArray = NULL;

		ppdev->mmMemMgr.pdmUsed = NULL;
		ppdev->mmMemMgr.pdmFree = NULL;
		ppdev->mmMemMgr.pdmHeap = NULL;
		ppdev->mmMemMgr.pdmHandles = NULL;

		ppdev->OFM_init = FALSE;
	}
	END_MUTEX(ppdev);

	// Delete the semaphore.
	DELETE_MUTEX(ppdev);
	DISPDBG((DISPLVL, "CloseOffScnMem: completed\n"));
}

/******************************************************************************\
* Function:		AllocOffScnMem
*
* Purpose:		Allocate a node in off-screen memory.
*
* On entry:		ppdev		Pointer to physical device.
*				psize		Pointer to the size of the requested node.  The size
*							is specified in pixels or bytes, depending on the
*							alignment flags.
*				alignflag	Alignment flags.
*				pcallback	Pointer to callback routine if DISCARDABLE_FLAG is
*							set.
*
* Returns:		Pointer to the node if successful, or NULL if there is not
*				enough memory to allocate the node.
\******************************************************************************/
POFMHDL AllocOffScnMem(PPDEV ppdev, PSIZEL psize, ULONG alignflag,
					   POFM_CALLBACK pcallback)
{
	GXPOINT	size, align;
	UINT	bpp;
	PDEVMEM	pdm;

	DISPDBG((DISPLVL, "AllocOffScnMem\n"));

	// If the memory manager active?
	if (ppdev == NULL || !ppdev->OFM_init || psize == NULL)
	{
		DISPDBG((DISPLVL, "AllocOffScnMem: not initialized\n"));
		return NULL;
	}

	#ifndef ALLOC_IN_CREATESURFACE
	// Return in case DirectDraw is active.
	if (pdpev->bDirectDrawInUse)
	{
		DISPDBG((DISPLVL, "AllocOffScnMem: DirectDraw is active\n"));
		return NULL;
	}
	#endif

	// Z-buffer alignment.
	if (alignflag & MCD_Z_BUFFER_ALLOCATE)
	{
		bpp = 2;
		align.pt.x = 32;
		align.pt.y = 32;
	}

	// Texture alignment.
	else if (alignflag & MCD_TEXTURE_ALLOCATE)
	{
		bpp = (alignflag & MCD_TEXTURE_ALLOCATE) >> MCD_TEXTURE_ALLOC_SHIFT;
		align.pt.x = 32;
		align.pt.y = 16;
	}

	// DirectDraw buffer alignment.
	else if (alignflag & MCD_DRAW_BUFFER_ALLOCATE)
	{
		bpp = ppdev->iBytesPerPixel;
		align.pt.x = 64;
		align.pt.y = 32;
	}

	// 8 bytes alignment.
	else if (alignflag & EIGHT_BYTES_ALIGN)
	{
		bpp = ppdev->iBytesPerPixel;
		align.pt.x = 8;
		align.pt.y = 1;
	}

	// Pixel alignment.
	else if (alignflag & PIXEL_AlIGN)
	{
		bpp = ppdev->iBytesPerPixel;
		align.pt.x = ppdev->iBytesPerPixel;
		align.pt.y = 1;
	}

	// Screen alignment.
	else if (alignflag & SCREEN_ALLOCATE)
	{
		bpp = ppdev->iBytesPerPixel;
		align.pt.x = ppdev->lDeltaScreen;
		align.pt.y = ppdev->cyMemory;
	}

	// Tile alignment.
	else
	{
		bpp = 1;
		align.pt.x = ppdev->lTileSize;
		align.pt.y = 2048 / ppdev->lTileSize;

		if (alignflag & NO_X_TILE_AlIGN)
		{
			align.pt.x = 1;
		}
		if (alignflag & NO_Y_TILE_AlIGN)
		{
			align.pt.y = 1;
		}
	}

	// The Z-buffer needs to be allocated at x=0.
	if (alignflag & MCD_NO_X_OFFSET)
	{
		align.pt.x = ppdev->lDeltaScreen;
	}

	#if TILE_ALIGNMENT
	// If this is a call from DrvCreateDeviceBitmap, set tile alignment.
	if (alignflag & MUST_HAVE)
	{
		align.pt.x |= 0x8000;
	}
	#endif

	// Set the size of the node.
	size.pt.x = psize->cx * bpp;
	size.pt.y = psize->cy;

	#if 1 // PDR#10526
	// Immortal Klowns copies a few bytes too much to the screen if the size of
	// a DirectDraw surface is not DWORD aligned.  So for DirectDraw and pixel
	// aligned allocations we align the size to DWORDs.
	if (ppdev->bDirectDrawInUse && (alignflag & PIXEL_AlIGN))
	{
		size.pt.x = (size.pt.x + 3) & ~3;
	}
	#endif

	BEGIN_MUTEX(ppdev)
	{
		// 1st pass, allocate the node.
		pdm = mmAlloc(&ppdev->mmMemMgr, size, align);
		if (pdm == NULL && (alignflag & MUST_HAVE))
		{
			// 2nd pass, move stuff away and allocate the node.
			pdm = mmMove(&ppdev->mmMemMgr, size, align, CopyBitmap);
		}
	}
	END_MUTEX(ppdev);

	if (pdm == NULL)
	{
		// Oops, no room for the node.
		DISPDBG((DISPLVL, "AllocOffScnMem: failed for (%dx%d)\n", size.pt.x,
				size.pt.y));
		return NULL;
	}

	// Setup the values in the old NT structure.
	pdm->ofm.x = pdm->ofm.aligned_x = pdm->cbAddr.pt.x;
	pdm->ofm.y = pdm->ofm.aligned_y = pdm->cbAddr.pt.y;
	pdm->ofm.sizex = pdm->cbSize.pt.x;
	pdm->ofm.sizey = pdm->cbSize.pt.y;
	pdm->ofm.alignflag = alignflag;
	pdm->ofm.pdsurf = NULL;

	// Set the address of the callback function.
	if (alignflag & DISCARDABLE_FLAG)
	{
		pdm->ofm.pcallback = pcallback;
	}
	else if (alignflag & MUST_HAVE)
	{
		// This is a device bitmap.
		pdm->ofm.pcallback = (POFM_CALLBACK) HostifyBitmap;
	}
	else
	{
		// No callback function.
		pdm->ofm.pcallback = NULL;
	}

	// Return node.
	DISPDBG((DISPLVL, "AllocOffScnMem: completed from (%d,%d) to (%d,%d)\n",
			pdm->cbAddr.pt.x, pdm->cbAddr.pt.y, pdm->cbAddr.pt.x +
			pdm->cbSize.pt.x, pdm->cbAddr.pt.y + pdm->cbSize.pt.y));
	return (POFMHDL) pdm;
}

/******************************************************************************\
* Function:		FreeOffScnMem
*
* Purpose:		Free a node allocated from off-screen memory.
*
* On entry:		ppdev		Pointer to physical device.
*				hdl			Handle of node to free.
*
* Returns:		TRUE if successful, FALSE if there is an error.
\******************************************************************************/
BOOL FreeOffScnMem(PPDEV ppdev, POFMHDL hdl)
{
	DISPDBG((DISPLVL, "FreeOffScnMem\n"));

	// If the memory manager enabled?
	if (ppdev == NULL || !ppdev->OFM_init || hdl == NULL)
	{
		DISPDBG((DISPLVL, "FreeOffScnMem: not initialized\n"));
		return FALSE;
	}

	// Free the node.
	DISPDBG((DISPLVL, "FreeOffScnMem: from (%d,%d) to (%d,%d)\n", hdl->x,
			hdl->y, hdl->x + hdl->sizex, hdl->y + hdl->sizey));
	mmFree(&ppdev->mmMemMgr, (PDEVMEM) hdl);

	// Return success.
	DISPDBG((DISPLVL, "FreeOffScnMem: completed\n"));
	return TRUE;
}

/******************************************************************************\
* Function:		ConvertToVideoBufferAddr
*
* Purpose:		Convert the location of a node in off-screen memory to a linear
*				address.
*
* On entry:		ppdev		Pointer to physical device.
*				hdl			Handle of node.
*
* Returns:		Linear address of node.
\******************************************************************************/
PVOID ConvertToVideoBufferAddr(PPDEV ppdev, POFMHDL hdl)
{
	PBYTE	retaddr;

	BEGIN_MUTEX(ppdev)
	{
		// Calculate the address.
		retaddr = ppdev->pjScreen + hdl->x + hdl->y * ppdev->lDeltaScreen;
	}
	END_MUTEX(ppdev);

	return (PVOID) retaddr;
}

/******************************************************************************\
* Function:		DDOffScnMemAlloc
*
* Purpose:		Free all non-essential memory to make room for DirectDraw.
*
* On entry:		ppdev		Pointer to physical device.
*
* Returns:		Pointer to biggest node for DirectDraw or NULL if the memory
*				manager handles DirectDraw surfaces.
\******************************************************************************/
POFMHDL DDOffScnMemAlloc(PPDEV ppdev)
{
	PDEVMEM	pdm;
	GXPOINT	align;

	DISPDBG((DISPLVL, "DDOffScnMemAlloc\n"));

	// Hostify all device bitmaps.
	HostifyAllBitmaps(ppdev);

	// SWAT3: Font cache release has moved to vAssertModeText.
	vAssertModeText(ppdev, FALSE);

	#ifdef ALLOC_IN_CREATESURFACE
	// We handle DirectDraw surfaces ourselfs.
	pdm = NULL;
	#else
	// Allocate the biggest chunk of memory for DirectDraw.
	align.pt.x = align.pt.y = 1;
	pdm = mmAllocLargest(&ppdev->mmMemMgr, align);
	#endif

	DISPDBG((DISPLVL, "DDOffScnMemAlloc: completed\n"));
	return (POFMHDL) pdm;
}

/******************************************************************************\
* Function:		DDOffScnMemRestore
*
* Purpose:		Release the memory allocated by DirectDraw.
*
* On entry:		ppdev		Pointer to physical device.
*
* Returns:		Nothing.
\******************************************************************************/
void DDOffScnMemRestore(PPDEV ppdev)
{
	PDDOFM	pdd, pddNext;

	DISPDBG((DISPLVL, "DDOffScnMemRestore\n"));

	// Release all DirectDraw nodes.
	for (pdd = ppdev->DDOffScnMemQ; pdd != NULL; pdd = pddNext)
	{
		pddNext = pdd->nexthdl;
		mmFree(&ppdev->mmMemMgr, (PDEVMEM) pdd->phdl);
		MEMORY_FREE(pdd);
	}
	ppdev->DDOffScnMemQ = NULL;

	// Release DirectDraw memory.
	if (ppdev->DirectDrawHandle != NULL)
	{
		mmFree(&ppdev->mmMemMgr, (PDEVMEM) ppdev->DirectDrawHandle);
		ppdev->DirectDrawHandle = NULL;
	}

	// Invalidate the entire brush cache now.
	vInvalidateBrushCache(ppdev);

	// Invalidate all cached fonts.
	#if SWAT3
	vAssertModeText(ppdev, TRUE);
	#endif
	ppdev->ulFontCount++;

	DISPDBG((DISPLVL, "DDOffScnMemRestore: completed\n"));
}

/******************************************************************************\
* Function:		FindHandle
*
* Purpose:		Find a specific node int the used list.
*
* On entry:		ppdev		Pointer to physical device.
*				hdl			Handle of node to find.
*
* Returns:		A pointer to the specified handle if it is found in the used
*				list, otherwise NULL will be returned.
\******************************************************************************/
POFMHDL FindHandle(PPDEV ppdev, POFMHDL hdl)
{
	PDEVMEM	pdm;

	// Walk through the used list.
	for (pdm = ppdev->mmMemMgr.pdmUsed; pdm != NULL; pdm = pdm->next)
	{
		if ((POFMHDL) pdm == hdl)
		{
			// We have a match!
			return hdl;
		}
	}

	return NULL;
}
#endif /* MEMMGR */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\host2scn.c ===
/*============================ Module Header ==========================*\
*
* Module Name: HOST2SCN.c
* Author: Noel VanHook
* Date: Oct. 10, 1995
* Purpose: Handles HOST to SCREEN BLTs
*
* Copyright (c) 1995 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/HOST2SCN.C  $
*
*    Rev 1.7   Mar 04 1998 15:27:16   frido
* Added new shadow macros.
*
*    Rev 1.6   Nov 03 1997 15:43:52   frido
* Added REQUIRE and WRITE_STRING macros.
*
\*=====================================================================*/


#include "precomp.h"

#if BUS_MASTER

extern ULONG ulXlate[16]; // See COPYBITS.C


/*****************************************************************************\
 *                                                                                                                                                       *
 *                                                                      8 - B P P                                                                *
 *                                                                                                                                                       *
\*****************************************************************************/

/*****************************************************************************\
 * BusMasterBufferedHost8ToDevice
 *
 * This routine performs a HostToScreen or HostToDevice blit. The host data
 * can be either monochrome, 4-bpp, or 8-bpp. Color translation is supported.
 *
 * Host data is read from the host bitmap and stored in a common buffer.
 * The HOSTXY unit on the chip is used to transfer the data from the common
 * buffer to the screen.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL BusMasterBufferedHost8ToDevice(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlDest, ptlSrc;
        SIZEL  sizl;
        PPDEV  ppdev;
        PBYTE  pBits;
        LONG   lDelta, i, j, n, lLeadIn, lExtra;
        ULONG  *pulXlate;
        FLONG  flXlate;
    ULONG  CurrentBuffer,
           BufPhysAddr;
    long   ScanLinesPerBuffer,
           ScanLinesThisBuffer;
    PDWORD pHostData;

        // Calculate the source offset.
        ptlSrc.x = pptlSrc->x;
        ptlSrc.y = pptlSrc->y;

    //
    // If the destination is a device bitmap, then our destination coordinates
    // are relative the the upper left corner of the bitmap.  The chip expects
    // destination coordinates relative to to screen(0,0).
    //
        // Determine the destination type and calculate the destination offset.
    //
        if (psoTrg->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF) psoTrg->dhsurf;

                ptlDest.x = prclTrg->left + pdsurf->ptl.x;
                ptlDest.y = prclTrg->top + pdsurf->ptl.y;
                ppdev = pdsurf->ppdev;
        }
        else
        {
                ptlDest.x = prclTrg->left;
                ptlDest.y = prclTrg->top;
                ppdev = (PPDEV) psoTrg->dhpdev;
        }

        // Calculate the size of the blit.
    sizl.cx = prclTrg->right - prclTrg->left;
    sizl.cy = prclTrg->bottom - prclTrg->top;

    //
        // Get the source variables and offset into source bits.
    // point pBits at the first scan line in the source.
    //
        lDelta = psoSrc->lDelta;
        pBits = (PBYTE)psoSrc->pvScan0 + (ptlSrc.y * lDelta);

        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
                pulXlate = XLATEOBJ_piVector(pxlo);
        }
    else
    {
        // Some kind of translation we don't handle.
        return FALSE;
    }


        // -----------------------------------------------------------------------
    //
        //      Test for monochrome source.
    //
        // ------------------------------------------------------------------------
        if (psoSrc->iBitmapFormat == BMF_1BPP)
        {
                ULONG  bgColor, fgColor;
                PDWORD pHostData = (PDWORD) ppdev->pLgREGS->grHOSTDATA;

                // Set background and foreground colors.
                if (pulXlate == NULL)
                {
                        bgColor = 0x00000000;
                        fgColor = 0xFFFFFFFF;
                }
                else
                {
                        bgColor = pulXlate[0];
                        fgColor = pulXlate[1];

                        // Expand the colors.
                        bgColor |= bgColor << 8;
                        fgColor |= fgColor << 8;
                        bgColor |= bgColor << 16;
                        fgColor |= fgColor << 16;
                }

                //
                // Special case: when we are expanding monochrome sources and we
                // already have a colored brush, we must make sure the monochrome color
                // translation can be achived by setting the saturation bit (expanding
                // 0's to 0 and 1's to 1). If the monochrome source also requires color
                // translation, we simply punt this blit back to GDI.
                //
                if (ulDRAWBLTDEF & 0x00040000)
                {
                        if ( (bgColor == 0x00000000) && (fgColor == 0xFFFFFFFF) )
                        {
                                // Enable saturation for source (OP1).
                                ulDRAWBLTDEF |= 0x00008000;
                        }
                        #if SOLID_CACHE
                        else if ( ((ulDRAWBLTDEF & 0x000F0000) == 0x00070000) &&
                                          ppdev->Bcache )
                        {
                                CacheSolid(ppdev);
                                ulDRAWBLTDEF ^= (0x00070000 ^ 0x00090000);
                                REQUIRE(4);
                                LL_BGCOLOR(bgColor, 2);
                                LL_FGCOLOR(fgColor, 2);
                        }
                        #endif
                        else
                        {
                                // Punt this call to the GDI.
                                return(FALSE);
                        }
                }
                else
                {
                        REQUIRE(4);
                        LL_BGCOLOR(bgColor, 2);
                        LL_FGCOLOR(fgColor, 2);
                }

                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we must setup the source phase.
                lLeadIn = ptlSrc.x & 31;
                pBits += (ptlSrc.x >> 3) & ~3;
                n = (sizl.cx + lLeadIn + 31) >> 5;

                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                REQUIRE(10);
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 0);

                // Start the blit.
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // Copy all the bits to the screen, 32-bits at a time. We don't have to
                // worry about crossing any boundary since NT is always DWORD aligned.
                while (sizl.cy--)
                {
                        WRITE_STRING(pBits, n);
                        pBits += lDelta;
                }

                // Disable the swizzle bit in the grCONTROL register.
                ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
        }

        //      -----------------------------------------------------------------------
    //
        //      Test for 4-bpp source.
    //
        //      -----------------------------------------------------------------------
        else if (psoSrc->iBitmapFormat == BMF_4BPP)
        {
                // Calculate the source parameters. We are going to BYTE adjust the
                // source, so we also set the source phase.
                lLeadIn = ptlSrc.x & 1;
                pBits += ptlSrc.x >> 1;
                n = sizl.cx + (ptlSrc.x & 1);

                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
                lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx, lLeadIn, ptlDest.x)];

                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // If there is no translation table, use the default translation table.
                if (pulXlate == NULL)
                {
                        pulXlate = ulXlate;
                }

                // Now we are ready to copy all the pixels to the hardware.
                while (sizl.cy--)
                {
                        BYTE  *p = pBits;
                        BYTE  data[4];

                        // First, we convert 4 pixels at a time to create a 32-bit value to
                        // write to the hardware.
                        for (i = n; i >= 4; i -= 4)
                        {
                                data[0] = (BYTE) pulXlate[p[0] >> 4];
                                data[1] = (BYTE) pulXlate[p[0] & 0x0F];
                                data[2] = (BYTE) pulXlate[p[1] >> 4];
                                data[3] = (BYTE) pulXlate[p[1] & 0x0F];
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], *(DWORD *)data);
                                p += 2;
                        }

                        // Now, write any remaining pixels.
                        switch (i)
                        {
                                case 1:
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], pulXlate[p[0] >> 4]);
                                        break;

                                case 2:
                                        data[0] = (BYTE) pulXlate[p[0] >> 4];
                                        data[1] = (BYTE) pulXlate[p[0] & 0x0F];
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], *(DWORD *)data);
                                        break;

                                case 3:
                                        data[0] = (BYTE) pulXlate[p[0] >> 4];
                                        data[1] = (BYTE) pulXlate[p[0] & 0x0F];
                                        data[2] = (BYTE) pulXlate[p[1] >> 4];
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], *(DWORD *)data);
                                        break;
                        }

                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }

                        // Next line.
                        pBits += lDelta;
                }
        }


        //      -----------------------------------------------------------------------
    //
        //      Source is in same color depth as screen (8 bpp).
    //
        //      -----------------------------------------------------------------------
        else
        {
        DISPDBG((1, " * * * * Doing bus mastered SRCCPY. * * * * \n"));

                // If we have invalid translation flags, punt the blit.
                if (flXlate & 0x10)
                        return(FALSE);


        //
        // pBits points to the first host bitmap scan line that will
        // be part of the BLT.
        // This function relies on the fact that in NT land, scanlines always
        // begin on a DWORD boundry in system memory.
        //
        ASSERTMSG( ((((ULONG)pBits) % 4) == 0),
                   "Scanline doesn't begin on a DWORD boundry.\n");

        // Now point pBits at the first host bitmap pixel to be
        // transferred to the screen.
                pBits += ptlSrc.x;   // pBits = First pixel of source bitmap.

        //
        // The Intel CPU doesn't like to transfer unaligned DWORDs.
        //
        // Just because the first pixel in a host bitmap scan line
        // is DWORD aligned, doesn't mean that the first source pixel
        // in this BLT is DWORD alinged.  We may be starting with
        // pixel 3 or something.
        // If our first pixel is in the middle of a DWORD, we need to know
        // where in the DWORD it lives.
        //   For example:
        //   If our first pixel is 0, then it lives at the start of a DWORD.
        //   If our first pixel is 3, then it lives at byte 3 in the DWORD.
        //   If our first pixel is 6, then it lives at byte 2 in the DWORD.
        //
                lLeadIn = (DWORD)pBits & 3;


        // If the first pixel of the source data doesn't fall on a
        // DWORD boundry, adjust it to the left until it does.
        // We can do this because of the ASSERT we made above.
        // We will instruct the chip to ignore the 'lead in' pixels
        // at the start of each scan line.
                pBits -= lLeadIn;


        // Now figure out how many dwords there are in each scan line.
                n = (sizl.cx + lLeadIn + 3) >> 2;


        //
        // We will split the BLT into pieces that can fit into our common
        // buffer.  We are guarenteed by the miniport that each buffer is big
        // enough to fit at least one scan line.
        //
        // One optimization is if bitmap pitch = blt width, glue the
        // scan lines together.
        //
        ScanLinesPerBuffer = ppdev->BufLength / (n*4);
        CurrentBuffer = 1;

        //
        // Now BLT the bitmap one buffer at a time.
        //

        // Enable the HOST XY unit.
        LL32(grHXY_HOST_CRTL_3D, 1);
        LL32(grHXY_BASE1_OFFSET1_3D, 0);

        // Setup the Laguna registers.
        REQUIRE(4);
        LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
        LL_OP1_MONO(lLeadIn, 0);

        while (1) // Each loop transfers one buffer.
        {
            DISPDBG((1, "    Filling buffer.\n"));

            //
            // Select the buffer we will use for this BLT.
            //
            if (CurrentBuffer)
            {
                        pHostData = (PDWORD) ppdev->Buf1VirtAddr;
                BufPhysAddr = (ULONG) ppdev->Buf1PhysAddr;
            }
            else
            {
                        pHostData = (PDWORD) ppdev->Buf2VirtAddr;
                BufPhysAddr = (ULONG) ppdev->Buf2PhysAddr;
            }


            // Is there enough bitmap left to fill an entire buffer?
            if (ScanLinesPerBuffer > sizl.cy)
                ScanLinesThisBuffer = sizl.cy; // No.
            else
                ScanLinesThisBuffer = ScanLinesPerBuffer;


            //
            // Now fill the buffer with bitmap data.
            //
            j = ScanLinesThisBuffer; // Counter for scan lines.


                // Test for color translation.
                if (pulXlate == NULL)
                    {
                            while (j--)  // Loop for each scan line.
                            {
                                // Copy all data in 32-bit. We don't have to worry about
                                // crossing any boundaries, since within NT everything is
                                // DWORD aligned.
                                #if defined(i386) && INLINE_ASM
                                        _asm
                                        {
                                                mov             edi, pHostData
                                                mov             esi, pBits
                                                mov             ecx, n
                                                rep     movsd
                                        }
                                #else
                                        for (i = 0; i < n; i++)
                                                pHostData[i] = pBits[i];
                                #endif

                                // Next line in source.
                                pBits += lDelta;

                    // Next line in buffer.
                    pHostData += n;
                        }
                }
                else
                {
                                DWORD *p;
                        while (j--)  // Loop for each scan line.
                        {
                    // p = pointer to source scan line
                                p = (DWORD *)pBits;

                    // Copy the scan line one DWORD at a time.
                                for (i = 0; i < n; i++)
                                {

                                    // We copy 4 pixels to fill an entire 32-bit DWORD.
                                        union
                                        {
                                            BYTE  byte[4];
                            DWORD dw;
                        } hostdata;

                        // Read a DWORD from the source.
                        hostdata.dw = *p++;

                        // Color convert it.
                                        hostdata.byte[0] = (BYTE) pulXlate[hostdata.byte[0]];
                                        hostdata.byte[1] = (BYTE) pulXlate[hostdata.byte[1]];
                                        hostdata.byte[2] = (BYTE) pulXlate[hostdata.byte[2]];
                                        hostdata.byte[3] = (BYTE) pulXlate[hostdata.byte[3]];

                        // Write it to the buffer.
                                        *pHostData++ =  hostdata.dw;
                                }

                                // Move to next line in source.
                                pBits += lDelta;
                        }
                }

            //
            // The common buffer is full, now BLT it.
            //

            //
            // Wait until HOST XY unit goes idle.
            //
            DISPDBG((1, "    Waiting for HOSTXY idle.\n"));
            do {
                i = LLDR_SZ (grPF_STATUS_3D);
            } while (i & 0x80);

            //
            // Wait until 2D unit goes idle.
            //
            DISPDBG((1, "    Waiting for 2D idle.\n"));
            do {
                i = LLDR_SZ (grSTATUS);
            } while (i);


            //
            // Program 2D Blitter.
            //
            DISPDBG((1, "    Blitting buffer.\n"));

                // Start the blit.
                REQUIRE(5);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, ScanLinesThisBuffer);


            //
            // Program HostXY unit.
            //

            // Write host address page.
            LL32(grHXY_BASE1_ADDRESS_PTR_3D, (BufPhysAddr&0xFFFFF000));

            // Write host address offset.
            LL32(grHXY_BASE1_OFFSET0_3D, (BufPhysAddr&0x00000FFF));


            if (0)
            {
               // Write the length of the host data (in bytes)
               // This starts the Host XY unit.
               LL32(grHXY_BASE1_LENGTH_3D, (n*ScanLinesThisBuffer*4));
            }
            else
            {
                int i;
                PDWORD BufVirtAddr;

                if (CurrentBuffer)
                    BufVirtAddr = (PDWORD) ppdev->Buf1VirtAddr;
                else
                    BufVirtAddr = (PDWORD) ppdev->Buf2VirtAddr;

                                WRITE_STRING(BufVirtAddr, n * ScanLinesThisBuffer);
            }

            //
            // Get ready to do the next buffer.
            //

            //
            // Wait until HOST XY unit goes idle.
            //
            DISPDBG((1, "    Waiting for HOSTXY idle.\n"));
            do {
                i = LLDR_SZ (grPF_STATUS_3D);
            } while (i & 0x80);

            //
            // Wait until 2D unit goes idle.
            //
            DISPDBG((1, "    Waiting for 2D idle.\n"));
            do {
                i = LLDR_SZ (grSTATUS);
            } while (i);

            //
            // Subtract the amount we're doing in this buffer from the
            // total amount we have to do.
            //
            sizl.cy -= ScanLinesThisBuffer;
            ptlDest.y += ScanLinesThisBuffer;

            //
            // Have we done the entire host bitmap?
            //
            if (sizl.cy == 0)
                break;

            DISPDBG((1, "    Swapping buffers.\n"));

            // Swap buffers.
            // CurrentBuffer = !(CurrentBuffer);
            if (CurrentBuffer)
                CurrentBuffer = 0;
            else
                CurrentBuffer = 1;


        } // End loop.  Do next buffer.

        //
        // Wait until HOST XY unit goes idle.
        //
        DISPDBG((1, "    Waiting for final idle.\n"));
        do {
                i = LLDR_SZ (grPF_STATUS_3D);
        } while (i & 0x80);

        DISPDBG((1, "    Done.\n"));
   }
   return(TRUE);
}



























#if 0

#define H2S_DBG_LEVEL    1

//
// In an attempt to trace the problems with the FIFO, we supply a few
// macros that will allow us to easily try different FIFO stratagies.
//

//
// Certian parts of our driver are optimized for the i386.
// They have slower counterparts for non i386 machines.
//
#if defined(i386)
    #define USE_DWORD_CAST       1 // i386 can address a DWORD anywhere.
    #define USE_REP_MOVSD        0 // We could use a bit of in-line assembler.
#else
    #define USE_DWORD_CAST       0
    #define USE_REP_MOVSD        0
#endif

//
// All the BLT functions take the same parameters.
//
typedef BOOL BLTFN(
        PPDEV     ppdev,
        RECTL*    DestRect,
        SURFOBJ*  psoSrc,
        POINTL*   pptlSrc,
        BRUSHOBJ* pbo,
        POINTL*   pptlBrush,
        ULONG      fg_rop,
        XLATEOBJ* pxlo,
        CLIPOBJ*  pco);


//
// Top level BLT functions.
//
BLTFN   MonoHostToScreen;
BLTFN   Color8HostToScreen, Color16HostToScreen,
        Color24HostToScreen, Color32HostToScreen;

//
// Clipping stuff
//
VOID BltClip(
        PPDEV     ppdev,
        CLIPOBJ*  pco,
        RECTL*    DestRect,
        SURFOBJ*  psoSrc,
        POINTL*   pptlSrc,
        BRUSHOBJ* pbo,
        POINTL*   pptlBrush,
        ULONG      fg_rop,
        XLATEOBJ* pxlo,
        BLTFN*    pDoBlt);

//
// Bottom level BLT functions.
//
BLTFN   HW1HostToScreen, HW8HostToScreen, HW16HostToScreen, HW32HostToScreen;

//
// 8 bpp HostToScreen helper functions.
//
VOID DoAlignedH2SBlt(
        PPDEV   ppdev,
        ULONG   ulDstX,   ULONG ulDstY,
        ULONG   ulExtX,   ULONG ulExtY,
        UCHAR   *pucData, ULONG deltaX);

VOID DoNarrowH2SBlt(
        PPDEV ppdev,
        ULONG ulDstX,     ULONG ulDstY,
        ULONG ulExtX,     ULONG ulExtY,
        UCHAR *pucImageD, ULONG deltaX);

//
// Driver profiling stuff.
// Gets compiled out in a free bulid.
// Declaring puntcode as a global violates display driver rules, but the
// emulator was chock full of globals anyway, and besides we won't ever
// release a version with this enabled.
//
#if PROFILE_DRIVER
    void DumpInfo(int acc, PPDEV ppdev, SURFOBJ* psoSrc, SURFOBJ* psoDest,
        ULONG fg_rop, ULONG bg_rop, CLIPOBJ*  pco, BRUSHOBJ* pbo,       XLATEOBJ* pxlo);
    extern int puntcode;
    #define PUNTCODE(x) puntcode = x;
#else
    #define DumpInfo(acc,ppdev,psoSrc,psoDest,fg_rop,bg_rop,pco,pbo,pxlo)
    #define PUNTCODE(x)
#endif

// *************************************************************************
//
// MonoHostToScreen()
//
//      Handles Monochrome Host to screen blts.
//      Called by op1BLT() and op1op2BLT
//      op1BLT() calls this routine with pbo = NULL.
//      op1op2BLT calls it with pbo = current brush.
//
//      This is the top level function.  This function verifies parameters,
//      and decides if we should punt or not.
//
//      The BLT is then handed off to the clipping function.  The clipping
//      function is also given a pointer to the lower level BLT function
//      HW1HostToScreen(), which will complete the clipped BLT.
//
//      This function is the last chance to decide to punt.  The clipping
//      functions and the lower level HW1HostToScreen() function aren't
//      allowed to punt.
//
//      Return TRUE if we can do the BLT,
//      Return FALSE to punt it back to GDI.
//
// *************************************************************************
BOOL MonoHostToScreen(
        PPDEV     ppdev,
        RECTL*    prclDest,
        SURFOBJ*  psoSrc,
        POINTL*   pptlSrc,
        BRUSHOBJ* pbo,
        POINTL*   pptlBrush,
        ULONG      fg_rop,
        XLATEOBJ* pxlo,
        CLIPOBJ*  pco)
{
    PULONG pulXlate;
    ULONG  fg, bg, bltdef = 0x1160;

    DISPDBG(( H2S_DBG_LEVEL,"DrvBitBlt: MonoHostToScreen Entry.\n"));

    //
    // Make sure source is a standard top-down bitmap.
    //
    if ( (psoSrc->iType != STYPE_BITMAP)     ||
         (!(psoSrc->fjBitmap & BMF_TOPDOWN))  )
        { PUNTCODE(4);    return FALSE; }

    //
    // We don't do brushes with mono src.
    //
    if (pbo)
        { PUNTCODE(7);  return FALSE; }


    //
    // Handle color translation.
    //
    if (pxlo == NULL) // Mono source requires translation.
    {
        PUNTCODE(6);
        return FALSE;
    }
    else if (pxlo->flXlate & XO_TRIVIAL)
    {
        // For trivial translation we don't need a Xlate table.
        fg = 1;
        bg = 0;
    }
    else
    {
        // Get the Xlate table.
        if (pxlo->flXlate & XO_TABLE)
                pulXlate = pxlo->pulXlate;
        else if (pxlo->iSrcType == PAL_INDEXED)
            {
                    pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle.
            return FALSE;
        }

        // Translate the colors.
            fg = ExpandColor(pulXlate[1],ppdev->ulBitCount);
        bg = ExpandColor(pulXlate[0],ppdev->ulBitCount);
    }
    REQUIRE(4);
    LL_FGCOLOR(fg, 2);
    LL_BGCOLOR(bg, 2);

    //
    // Turn swizzle on.
    //
    ppdev->grCONTROL |= SWIZ_CNTL;
         LL16(grCONTROL, ppdev->grCONTROL);

    //
    // Set function and ROP code.
    //
    LL_DRAWBLTDEF(((DWORD)bltdef << 16) | fg_rop, 2);

    //
    // Clip the BLT.
    // The clipping function will call HW1HostToScreen() to finish the BLT.
    //
    if ((pco == 0) || (pco->iDComplexity==DC_TRIVIAL))
        HW1HostToScreen(ppdev, prclDest, psoSrc, pptlSrc,
                 pbo, pptlBrush, fg_rop, pxlo, pco);
    else
        BltClip(ppdev, pco, prclDest, psoSrc, pptlSrc,
                        pbo, pptlBrush, fg_rop, pxlo, &HW1HostToScreen);

    //
    // Turn swizzle off
    //
    ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
    LL16(grCONTROL, ppdev->grCONTROL);

    return TRUE;
}




// ************************************************************************* //
//                                                                           //
// HW1HostToScreen()                                                         //
//                                                                           //
//  This function is responsible for actually talking to the chip.           //
//  At this point we are required to handle the BLT, so we must return TRUE. //
//  All decisions as to whether to punt or not must be made in the top level //
//  function MonoHostToScreen().                                             //
//                                                                           //
//  This function is called from BltClip() through a pointer set by          //
//  MonoHostToScreen().                                                      //
//                                                                           //
// ************************************************************************* //
BOOL HW1HostToScreen(
        PPDEV     ppdev,
        RECTL*    prclDest,
        SURFOBJ*  psoSrc,
        POINTL*   pptlSrc,
        BRUSHOBJ* pbo,
        POINTL*   pptlBrush,
        ULONG      fg_rop,
        XLATEOBJ* pxlo,
        CLIPOBJ*  pco)
{
    INT    x, y, i;
    INT    bltWidth, bltHeight, phase;
    PBYTE  psrc;
    DWORD hostdata;
    char *phd = (char *)&hostdata;

    DISPDBG(( H2S_DBG_LEVEL,"DrvBitBlt: HW1HostToScreen Entry.\n"));


    // Calculate BLT size in pixels.
    bltWidth  = (prclDest->right - prclDest->left);
    bltHeight = (prclDest->bottom - prclDest->top);


    //
    // Phase
    // For 1bpp sources, we must be concerned with phase.
    // Phase is the number of pixels to skip in the first dword
    // of a scan line.  For instance, if our BLT has a Src_X of 10,
    // we take our first dword starting at second byte in the src
    // scan line, and set our phase to 2 to indicate that we skip
    // the first two pixels.
    //
    phase = pptlSrc->x % 8;
    REQUIRE(7);
    LL_OP1_MONO(phase,0);

    //
    // Calculate blt width in BYTESs.
    // When calculating the number of BYTES per line, we need to
    // include the unused pixels at the start of the first BYTE
    //
    bltWidth += phase;

    // Divide bltWidth by 8 pixels per BYTE.
    // Account for extra partial BYTE if bltWidth isn't evenly
    // divisible by 8.
    bltWidth =  (bltWidth+7) / 8;

    //
    // Set psrc to point to first pixel in source.
    //
    psrc =  psoSrc->pvScan0;               // Start of surface.
    psrc += (psoSrc->lDelta * pptlSrc->y); // Start of scanline.
    psrc += (pptlSrc->x / 8);              // Starting pixel in scanline.

    // Set up the chip.
        LL_OP0 (prclDest->left, prclDest->top);
    LL_BLTEXT ((prclDest->right - prclDest->left), bltHeight);


    // For each scan line in the source rectangle.
    for (y=0; y<bltHeight; ++y)
    {
        //
        // Supply the HOSTDATA for this scan line.
        // We do this by reading it one byte at a time, and packing it into a
        // DWORD, which we write to the chip when it gets full.
        // It sound's inefficent, but a general purpose solution that
        // does only aligned DWORD accesses on both the host and the chip would
        // require lots of special casing around the first and last DWORD.
        // Combine that with the fact that most Mono-to-Color BLTS are
        // less than 2 dwords wide, and this simpler solution becomes
        // more attractive.
        //
#if 1
        WRITE_STRING(psrc, (bltWidth + 3) / 4);
#else
        i=0;        // counter to tell us when our DWORD is full.
        hostdata=0; // The DWORD we will be filling with hostdata.
                    // pdh is a char pointer that points to the start
                    // of the dword we are filling up.

        for (x=0; x<bltWidth; )   // For each byte in the scan line...
        {
          #if (USE_DWORD_CAST)
            if ( (x + 4) <= bltWidth)
            {

                REQUIRE(1);
                LL32 (grHOSTDATA[0], *(DWORD*)(&psrc[x]));
                x += 4;
            }
            else
          #endif
            {
                phd[i++] = psrc[x];  // Store this byte.

                if (i == 4) // We have a full DWORD of data, write it to the chip.
                {
                    REQUIRE(1);
                    LL32 (grHOSTDATA[0], hostdata);
                    i=0;
                    hostdata=0;
                }
                ++x;
            }
        }

        // Write the last partial DWORD.
        if (i != 0)
                REQUIRE(1);
                LL32 (grHOSTDATA[0], hostdata);
#endif

        // Move down one scanline in source.
        psrc += psoSrc->lDelta;
    }

    return TRUE;
}



// ************************************************************************* //
//                                                                           //
// Color8HostToScreen()                                                      //
//                                                                           //
//      Handles 8 bpp Host to screen blts.                                   //
//                                                                           //
//      Called by op1BLT() and op1op2BLT                                     //
//      op1BLT() calls this routine with pbo = NULL.                         //
//      op1op2BLT calls it with pbo = current brush.                         //
//                                                                           //
//      This is the top level function.  This function verifies parameters,  //
//      and decides if we should punt or not.                                //
//                                                                           //
//      The BLT is then handed off to the clipping function.  The clipping   //
//      function is also given a pointer to the lower level BLT function     //
//      HW8HostToScreen(), which will complete the clipped BLT.              //
//                                                                           //
//      This function is the last chance to decide to punt.  The clipping    //
//      functions and the lower level HW8HostToScreen() function aren't      //
//      allowed to punt.                                                     //
//                                                                           //
//      Return TRUE if we can do the BLT,                                    //
//      Return FALSE to punt it back to GDI.                                 //
//                                                                           //
//                                                                           //
// ************************************************************************* //
BOOL Color8HostToScreen(
        PPDEV     ppdev,
        RECTL*    prclDest,
        SURFOBJ*  psoSrc,
        POINTL*   pptlSrc,
        BRUSHOBJ* pbo,
        POINTL*   pptlBrush,
        ULONG      fg_rop,
        XLATEOBJ* pxlo,
        CLIPOBJ*  pco)
{
    ULONG bltdef = 0x1120; // RES=fb, OP0=fb OP1=host

    DISPDBG(( H2S_DBG_LEVEL, "DrvBitBlt: Color8HostToScreen Entry.\n"));

    //
    //  We don't handle src with a different color depth than the screen
    //
    if (psoSrc->iBitmapFormat != ppdev->iBitmapFormat)
    {
        PUNTCODE(13);
        return FALSE;
    }

    //
    // Translation type must be nothing or trivial.
    // We don't handle Xlates for color source.
    //
    if (!((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
    {
        PUNTCODE(5);
        return FALSE;
    }

    //
    // Make sure source is a standard top-down bitmap.
    //
    if ( (psoSrc->iType != STYPE_BITMAP)     ||
         (!(psoSrc->fjBitmap & BMF_TOPDOWN))  )
    {
        PUNTCODE(4);
        return FALSE;
    }

    //
    // Set up the brush if there is one.
    //
    if (pbo)
    {
        if (SetBrush(ppdev, &bltdef, pbo, pptlBrush) == FALSE)
        {
            PUNTCODE(8);
            return FALSE;
        }
    }

    //
    // Function and ROP code.
    //
    REQUIRE(1);
    LL_DRAWBLTDEF((bltdef << 16) | fg_rop, 2);

    //
    // Turn swizzle off.
    //
    ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
    LL16(grCONTROL, ppdev->grCONTROL);

    //
    // Clip the BLT.
    // The clipping function will call HW8HostToScreen() to finish the BLT.
    //
    if ((pco == 0) || (pco->iDComplexity==DC_TRIVIAL))
        HW8HostToScreen(ppdev, prclDest, psoSrc, pptlSrc,
                 pbo, pptlBrush, fg_rop, pxlo, pco);
    else
        BltClip(ppdev, pco, prclDest, psoSrc, pptlSrc,
                        pbo, pptlBrush, fg_rop, pxlo, &HW8HostToScreen);

    return (TRUE);
}


// *************************************************************************
//
// HW8HostToScreen()
//
//  This function is responsible for actually talking to the chip.
//  At this point we are required to handle the BLT, so we must return TRUE.
//  All decisions as to whether to punt or not must be made in the top level
//  function Color8HostToScreen().
//
//  This function is called from BltClip() through a pointer set by
//  Color8HostToScreen().
//
/*

    This routine does host to screen BLTs using DWORD aligned
    reads on the host whenever possible.

    The general plan is to split the BLT into up to three stripes.

    The first stripe is used if the BLT doesn't begin on a DWORD
    boundry.
    This stripe is < 1 DWORD wide and uses CHAR accesses on
    the host, and a single DWORD write to the screen, with the
    source phase set to indicated which bytes are valid.

    The second stripe is a middle stripe that both starts and ends
    on DWORD boundries.  This stripe will make up the bulk of large BLTs,
    but for narrow BLTs, it may not be used at all.

    The third stripe is used if the BLT doesn't end on a DWORD boundry.
    It is implimented much the way the first stripe is.

    One thing to consider is the scan line length of the bitmap on
    the host.  We can ignore bitmaps with an odd scan line length
    since Windows requires that all bitmaps have an even scan line
    length.  That leaves two interesting cases:

       1) Bitmaps with a scan line length that is DWORD divisable.
           (even WORD length)

       2) Bitmaps with a scan line lenght that is *not* DWORD divisable.
           (odd WORD length)

     For case one, the above plan works nicely.  It handles the host data
     one byte at a time until it reaches the first DWORD boundry, then
     it handles the data one DWORD at a time, until there is less than
     one DWORD of data left, and then handles the last couple of bytes
     one byte at a time.

     For case two, however, the plan only works for odd scan lines.
     When BLTing the large "aligned" block in the middle of the BLT,
     the odd scan lines will all align nicely on DWORD boundries,
     but the even scan lines will be "off" by one word.  While this
     is not optimal, it "almost" optimal, and is easier than an
     optimal solution, and will work even on a Power PC.

     The code looks something like this:

        if (BLT is 4 bytes wide or less)
        {
            Read host one byte at a time, pack it into DWORDS, and
            write it to the chip.
        }
        else
        {
            if (left edge of the source doesn't align to a DWORD address)
            {
                Split the BLT at the first DWORD boundry on the source.

                BLT the left part like it was an under-4-byte-wide BLT.
                    (see above)

                Adjust BLT source, destination and extents to exclude
                    the stripe just done.
            }

            //
            // Now we know that the left edge of source aligns to a
            // DWORD boundry on the host.
            //

            if (right edge of source doesn't align to a DWORD address)
            {
                Split off a stripe to the right of the last DWORD
                boundry, and use an under-4-byte-wide BLT on it.

                Adjust BLT extent to exclude the stripe just done.
            }


            //
            // Anything left over will always DWORD aligned on both edges.
            //

            if (there is any part of the BLT left over)
            {
                do an ALINGED BLT.
            }

        }

        All Done!

*/
//
// *************************************************************************

BOOL HW8HostToScreen(
        PPDEV     ppdev,
        RECTL*    prclDest,
        SURFOBJ*  psoSrc,
        POINTL*   pptlSrc,
        BRUSHOBJ* pbo,
        POINTL*   pptlBrush,
        ULONG      fg_rop,
        XLATEOBJ* pxlo,
        CLIPOBJ*  pco)
{
    PBYTE  psrc;
    DWORD *pdsrc;
    UCHAR *pucData;
    ULONG  temp, x, y,
           ulExtX, ulExtY,
           ulDstX, ulDstY;


    DISPDBG(( H2S_DBG_LEVEL, "DrvBitBlt: HW8HostToScreen Entry.\n"));

    //
    // Calculate BLT size in pixels.
    //
    ulDstX = prclDest->left;
        ulDstY = prclDest->top;
    ulExtX = (prclDest->right - prclDest->left);
    ulExtY = (prclDest->bottom - prclDest->top);


    //
    // Get the address of the upper left source pixel.
    //
    pucData =  psoSrc->pvScan0;               // Start of surface.
    pucData += (psoSrc->lDelta * pptlSrc->y); // Start of scanline.
    pucData += (pptlSrc->x * ppdev->iBytesPerPixel);  // Starting pixel.



    //
    // if the BLT is 4 or less bytes wide, just do it.
    //
    if (ulExtX <= 4)
    {
        // Do the BLT and exit.
        DoNarrowH2SBlt( ppdev,
                        ulDstX, ulDstY,
                        ulExtX, ulExtY,
                        pucData, psoSrc->lDelta);

        return TRUE;
    }


    //
    // Is the left edge DWORD aligned?
    //
    temp = ((ULONG)pucData) % 4;
    if ( temp != 0)     // No.
    {
        ULONG ulLeftStripeExtX;

        //
        // Blt the unaligned left edge.
        //
        ulLeftStripeExtX = (4 - temp);
        DoNarrowH2SBlt( ppdev,
                        ulDstX, ulDstY,
                        ulLeftStripeExtX, ulExtY,
                        pucData, psoSrc->lDelta);

        //
        // Adjust BLT parameters to exclude the part we just did.
        //
        ulDstX = ulDstX + ulLeftStripeExtX;
        ulExtX  = ulExtX  - ulLeftStripeExtX;
        pucData = pucData + ulLeftStripeExtX;

    }


    //
    // Is the right edge DWORD aligned?
    //
    temp = ((ULONG)(pucData + ulExtX)) % 4;
    if (temp != 0)                  // No.
    {
        ULONG   ulMiddleStripeExtX,
                ulRightStripeExtX,
                ulRightStripeDstX;
        UCHAR * pucRightStripeData;


        //
        // Break the BLT into a middle (aligned) stripe and a
        // right (unaligned) stripe.
        // The middle stripe could be 0 width.
        //
        ulRightStripeExtX = temp;
        ulMiddleStripeExtX = ulExtX - ulRightStripeExtX;
        ulRightStripeDstX = ulDstX + ulMiddleStripeExtX;
        pucRightStripeData = pucData + ulMiddleStripeExtX;

        //
        // BLT the right (unaligned) stripe.
        //
        DoNarrowH2SBlt( ppdev,
                        ulRightStripeDstX, ulDstY,
                        ulRightStripeExtX, ulExtY,
                        pucRightStripeData, psoSrc->lDelta);

        //
        // Adjust BLT parameters to exclude the right stripe we just did.
        //
        ulExtX = ulMiddleStripeExtX;
    }

    //
    // If anything remains, it is aligned to a DWORD boundry
    // on the HOST and is an multiple of 4 wide.
    //

    if (ulExtX != 0)
    {
        DoAlignedH2SBlt
            (ppdev, ulDstX, ulDstY, ulExtX, ulExtY, pucData, psoSrc->lDelta);
    }

    return TRUE;
}



//****************************************************************************
//
//   DoNarrowBlt()  --  Does an 8bpp BLT that is no more than 4 pixels wide
//
//****************************************************************************
VOID DoNarrowH2SBlt(
        PPDEV ppdev,
        ULONG ulDstX,
        ULONG ulDstY,
        ULONG ulExtX,
        ULONG ulExtY,
        UCHAR *pucImageD,
        ULONG deltaX)
{
    ULONG  usDataIncrement = deltaX,
           usSrcPhase = 0,
           ulY;
    UCHAR  *pucData = pucImageD;
    union
    {
        ULONG ul;
        struct
        {
            unsigned char c0;
            unsigned char c1;
            unsigned char c2;
            unsigned char c3;
        } b;
    } hostdata;

    DISPDBG(( (H2S_DBG_LEVEL), "DrvBitBlt: Entry to DoNarrowH2SBlt.\n"));

    REQUIRE(7);
    LL_OP1(usSrcPhase,0);
    LL_OP0 (ulDstX, ulDstY);
    LL_BLTEXT (ulExtX, ulExtY);

    //
    // Since there are only 4 possible x extents,
    // we will handle each seperatly for maximum speed.
    //
    switch (ulExtX)
    {
        case 1:
            for (ulY = 0; ulY < ulExtY; ulY++)
            {
                #if USE_DWORD_CAST // Intel x86 can do DWORD access anywhere.
                    REQUIRE(1);
                    LL32 (grHOSTDATA[0], ((ULONG)pucData[0]) );
                #else
                    hostdata.ul = 0;
                    hostdata.b.c0 = pucData[0];
                    REQUIRE(1);
                    LL32 (grHOSTDATA[0], hostdata.ul );
                #endif

                pucData += usDataIncrement; // Move to next scan line.
            } // End for each scan line.
            break;

        case 2:
            for (ulY = 0; ulY < ulExtY; ulY++)
            {
                #if USE_DWORD_CAST // Intel x86 can do DWORD access anywhere.
                    REQUIRE(1);
                    LL32 (grHOSTDATA[0], (ULONG)(*((unsigned short *) pucData)) );
                #else
                    hostdata.ul = 0;
                    hostdata.b.c1 = pucData[1];
                    hostdata.b.c0 = pucData[0];
                    REQUIRE(1);
                    LL32 (grHOSTDATA[0], hostdata.ul );
                #endif

                pucData += usDataIncrement; // Move to next scan line.
            } // End for each scan line.
            break;

        case 3:
            for (ulY = 0; ulY < ulExtY; ulY++)
            {
                hostdata.ul = 0;
                hostdata.b.c2 = pucData[2];
                hostdata.b.c1 = pucData[1];
                hostdata.b.c0 = pucData[0];
                REQUIRE(1);
                LL32 (grHOSTDATA[0], hostdata.ul );

                pucData += usDataIncrement; // Move to next scan line.
            } // End for each scan line.
            break;

        case 4:
            for (ulY = 0; ulY < ulExtY; ulY++)
            {
                #if USE_DWORD_CAST // Intel x86 can do DWORD access anywhere.
                    REQUIRE(1);
                    LL32 (grHOSTDATA[0], (*((unsigned long *) pucData)) );
                #else
                    hostdata.b.c3 = pucData[3];
                    hostdata.b.c2 = pucData[2];
                    hostdata.b.c1 = pucData[1];
                    hostdata.b.c0 = pucData[0];
                    REQUIRE(1);
                    LL32 (grHOSTDATA[0], hostdata.ul );
                #endif

                pucData += usDataIncrement; // Move to next scan line.
            } // End for each scan line.
            break;
    } // End switch.
}





//****************************************************************************
//
// DoAlignedH2SBlt()
//
// Does an aligned 8bpp BLT.
// On entry Source will always be aligned to a DWORD boundry and
// X extent will always be a DWORD multiple.
//
//****************************************************************************

VOID DoAlignedH2SBlt(
        PPDEV   ppdev,
        ULONG   ulDstX,
        ULONG   ulDstY,
        ULONG   ulExtX,
        ULONG   ulExtY,
        UCHAR   *pucData,
        ULONG   deltaX)

{
    ULONG       ulX, ulY, i, num_extra, ulNumDwords,
                usDataIncrement, usSrcPhase;
    void *pdst = (void *)ppdev->pLgREGS->grHOSTDATA;

    DISPDBG(( (H2S_DBG_LEVEL), "DrvBitBlt: Entry to DoAlignedH2SBlt.\n"));

    ulNumDwords = ulExtX / 4;
    usDataIncrement = deltaX;
    usSrcPhase = 0;


    //
    // We have a bug in the chip that causes it to require extra data under
    // certian conditions.  We use a look-up table to see how much extra
    // data this BLT will require for each scanline.
    //
    i = MAKE_HD_INDEX(ulExtX, usSrcPhase, ulDstX);
    num_extra =  ExtraDwordTable [i];


    //
    // Set up the chip.
    //
    REQUIRE(7);
    LL_OP1 (usSrcPhase,0);
    LL_OP0 (ulDstX, ulDstY);
    LL_BLTEXT (ulExtX, ulExtY);


    //
    // Supply the HOSTDATA.
    // We keep the decision about whether we have to work
    // around the HOSTDATA bug *outside* of the loop, even though
    // that means keeping two copies of it.
    //

    if (num_extra) // Do we have to deal with the HostData bug?
    {
        //
        // Yes, append extra DWORDs to the end of each scan line.
        //

        for (ulY = 0; ulY < ulExtY; ulY++) // for each scan line.
        {
            // Write the data for this scan line.
                WRITE_STRING(pucData, ulNumDwords);

            // Write extra data to get around chip bug.
            REQUIRE(num_extra);
            for (i=0; i<num_extra; ++i)
                LL32 (grHOSTDATA[0], 0);

            // Move to next scan line.
            pucData += usDataIncrement;

        } // End for each scan line.
    }
    else
    {
        //
        // No need to worry about the HOSTDATA bug,
        // Just blast the data out there.
        //

        for (ulY = 0; ulY < ulExtY; ulY++) // for each scan line.
        {
            // Write the data for this scan line.
                WRITE_STRING(pucData, ulNumDwords);

            // Move to next scan line.
            pucData += usDataIncrement;

        } // End for each scan line.
    }
}




// ===========================================================================
//
// Color16HostToScreen
//
//      Handles 16 bpp Host to screen blts.
//
//      Called by op1BLT() and op1op2BLT
//      op1BLT() calls this routine with pbo = NULL.
//      op1op2BLT calls it with pbo = current brush.
//
//      This is the top level function.  This function verifies parameters,
//      and decides if we should punt or not.
//
//      The BLT is then handed off to the clipping function.  The clipping
//      function is also given a pointer to the lower level BLT function
//      HW16HostToScreen(), which will complete the clipped BLT.
//
//      This function is the last chance to decide to punt.  The clipping
//      functions and the lower level HW16HostToScreen() function aren't
//      allowed to punt.
//
//      Return TRUE if we can do the BLT,
//      Return FALSE to punt it back to GDI.
//
// ===========================================================================
BOOL Color16HostToScreen(
        PPDEV     ppdev,
        RECTL*    prclDest,
        SURFOBJ*  psoSrc,
        POINTL*   pptlSrc,
        BRUSHOBJ* pbo,
        POINTL*   pptlBrush,
        ULONG      fg_rop,
        XLATEOBJ* pxlo,
        CLIPOBJ*  pco)
{
    PULONG pulXlate;
    ULONG  bltdef = 0x1120; // RES=fb, OP0=fb OP1=host

    DISPDBG(( H2S_DBG_LEVEL, "DrvBitBlt: Color16HostToScreen Entry.\n"));

    //
    //  We don't handle src with a different color depth than the screen
    //
    if (psoSrc->iBitmapFormat != ppdev->iBitmapFormat)
    {
        PUNTCODE(13);
        return FALSE;
    }

    //
    // Get the source translation type.
    // We don't handle Xlates for color source.
    //
    if (!((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
    {
        PUNTCODE(5);
        return FALSE;
    }

    //
    // Make sure source is a standard top-down bitmap.
    //
    if ( (psoSrc->iType != STYPE_BITMAP)     ||
         (!(psoSrc->fjBitmap & BMF_TOPDOWN))  )
    {
        PUNTCODE(4);
        return FALSE;
    }

    //
    // Set up the brush if there is one.
    //
    if (pbo)
        if (SetBrush(ppdev, &bltdef, pbo, pptlBrush) == FALSE)
        {
            PUNTCODE(8);
            return FALSE;
        }


    //
    // Turn swizzle off.
    //
    ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
    LL16(grCONTROL, ppdev->grCONTROL);

    //
    // BLTDEF, and rop code.
    //
    REQUIRE(1);
    LL_DRAWBLTDEF((bltdef << 16) | fg_rop, 2);

    //
    // Clip the BLT.
    // The clipping function will call HW16HostToScreen() to finish the BLT.
    //
    if ((pco == 0) || (pco->iDComplexity==DC_TRIVIAL))
        HW16HostToScreen(ppdev, prclDest, psoSrc, pptlSrc,
                 pbo, pptlBrush, fg_rop, pxlo, pco);
    else
        BltClip(ppdev, pco, prclDest, psoSrc, pptlSrc,
                        pbo, pptlBrush, fg_rop, pxlo, &HW16HostToScreen);

    return TRUE;
}

// ===========================================================================
//
// HW16HostToScreen
//
//  This function is responsible for actually talking to the chip.
//  At this point we are required to handle the BLT, so we must return TRUE.
//  All decisions as to whether to punt or not must be made in the top level
//  function Color16HostToScreen().
//
//  This function is called from BltClip() through a pointer set by
//  Color16HostToScreen().                                                           //
//
//  Since scan lines are WORD aligned by GDI, that means
//  all pixels will be WORD aligned by GDI, so the only thing
//  we need to be concerned about is if there are a even or an odd
//  number of WORDS per scan line.
//
// ===========================================================================
BOOL HW16HostToScreen(
        PPDEV     ppdev,
        RECTL*    prclDest,
        SURFOBJ*  psoSrc,
        POINTL*   pptlSrc,
        BRUSHOBJ* pbo,
        POINTL*   pptlBrush,
        ULONG      fg_rop,
        XLATEOBJ* pxlo,
        CLIPOBJ*  pco)
{
    ULONG  bltWidth, bltHeight,
           x, y, i, odd,
           num_dwords, num_extra;
    PBYTE  psrc;
    DWORD *pdsrc;
    UCHAR *pucData;
    ULONG SrcPhase = 0;
    void *pHOSTDATA = (void *)ppdev->pLgREGS->grHOSTDATA;


    DISPDBG(( H2S_DBG_LEVEL, "DrvBitBlt: HW16HostToScreen Entry.\n"));

    //
    // Set psrc to point to first pixel in source.
    //
    psrc =  psoSrc->pvScan0;               // Start of surface.
    psrc += (psoSrc->lDelta * pptlSrc->y); // Start of scanline.
    psrc += (pptlSrc->x * ppdev->iBytesPerPixel);  // Starting pixel in scanline.


    //
    // Set source phase
    //
    REQUIRE(7);
    LL_OP1 (SrcPhase,0);


    //
    // Set DEST x,y
    //
    LL_OP0 (prclDest->left, prclDest->top);


    //
    // Set the X and Y extents, and do the BLT.
    // Calculate BLT size in pixels.
    //
    bltWidth = (prclDest->right - prclDest->left);
    bltHeight = (prclDest->bottom - prclDest->top);
    DISPDBG(( H2S_DBG_LEVEL, "DrvBitBlt: BLT width is %d pixels.\n",bltWidth));
    LL_BLTEXT (bltWidth, bltHeight);


    //
    // The chip has a bug in it that causes us to have to write extra HOSTDATA
    // under certian conditions.
    //
    i = MAKE_HD_INDEX((bltWidth*2), SrcPhase, (prclDest->left*2));
    num_extra =  ExtraDwordTable [i];
    DISPDBG(( H2S_DBG_LEVEL, "DrvBitBlt: BLT requires %d extra HOSTDATA writes.\n",num_extra));

    //
    // Now we supply the HOSTDATA for each scan line.
    //

    for (y=0; y<bltHeight; ++y)
    {
                WRITE_STRING(psrc, ((bltWidth + 1) / 2);

        //
        // Add any extra hostdata we need to get around the hostdata bug.
        //
        REQUIRE(num_extra);
        for (i=0; i<num_extra; ++i)
                LL32 (grHOSTDATA[0], 0);

        // Move down one scanline in source.
        psrc += psoSrc->lDelta;
    }

    return TRUE;

}







// ===========================================================================
//
// Color24HostToScreen
//
//      Handles 24 bpp Host to screen blts.
//
//      Called by op1BLT() and op1op2BLT
//      op1BLT() calls this routine with pbo = NULL.
//      op1op2BLT calls it with pbo = current brush.
//
//      This is the top level function.  This function verifies parameters,
//      and decides if we should punt or not.
//
//      The BLT is then handed off to the clipping function.  The clipping
//      function is also given a pointer to the lower level BLT function
//      HW24HostToScreen(), which will complete the clipped BLT.
//
//      This function is the last chance to decide to punt.  The clipping
//      functions and the lower level HW24HostToScreen() function aren't
//      allowed to punt.
//
//      Return TRUE if we can do the BLT,
//      Return FALSE to punt it back to GDI.
//
// ===========================================================================
BOOL Color24HostToScreen(
        PPDEV     ppdev,
        RECTL*    prclDest,
        SURFOBJ*  psoSrc,
        POINTL*   pptlSrc,
        BRUSHOBJ* pbo,
        POINTL*   pptlBrush,
        ULONG      fg_rop,
        XLATEOBJ* pxlo,
        CLIPOBJ*  pco)
{

    //
    // I'm not even going to try this.
    // I've got better things to do with my time.
    //

    DISPDBG(( H2S_DBG_LEVEL, "DrvBitBlt: Color24HostToScreen Entry.\n"));
    PUNTCODE(17);
    return FALSE;
}






// ===========================================================================
//
// Color32HostToScreen
//
//      Handles 32 bpp Host to screen blts.
//
//      Called by op1BLT() and op1op2BLT
//      op1BLT() calls this routine with pbo = NULL.
//      op1op2BLT calls it with pbo = current brush.
//
//      This is the top level function.  This function verifies parameters,
//      and decides if we should punt or not.
//
//      The BLT is then handed off to the clipping function.  The clipping
//      function is also given a pointer to the lower level BLT function
//      HW24HostToScreen(), which will complete the clipped BLT.
//
//      This function is the last chance to decide to punt.  The clipping
//      functions and the lower level HW24HostToScreen() function aren't
//      allowed to punt.
//
//      Return TRUE if we can do the BLT,
//      Return FALSE to punt it back to GDI.
//
// ===========================================================================
BOOL Color32HostToScreen(
        PPDEV     ppdev,
        RECTL*    prclDest,
        SURFOBJ*  psoSrc,
        POINTL*   pptlSrc,
        BRUSHOBJ* pbo,
        POINTL*   pptlBrush,
        ULONG      fg_rop,
        XLATEOBJ* pxlo,
        CLIPOBJ*  pco)
{
    PULONG pulXlate;
    ULONG  bltdef = 0x1120; // RES=fb, OP0=fb OP1=host

    return FALSE;     // There are some unresolved issues here.

    DISPDBG(( H2S_DBG_LEVEL, "DrvBitBlt:  Color32HostToScreen Entry.\n"));

    //
    //  We don't handle src with a different color depth than the screen
    //
    if (psoSrc->iBitmapFormat != ppdev->iBitmapFormat)
    {
        PUNTCODE(13);   return FALSE;
    }

    //
    // Get the source translation type.
    // We don't handle Xlates for color source.
    //
    if (!((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
    {
        PUNTCODE(5);    return FALSE;
    }

    //
    // Make sure source is a standard top-down bitmap.
    //
    if ( (psoSrc->iType != STYPE_BITMAP)     ||
         (!(psoSrc->fjBitmap & BMF_TOPDOWN))  )
    {
        PUNTCODE(4);    return FALSE;
    }

    //
    // Set up the brush if there is one.
    //
    if (pbo)
        if (SetBrush(ppdev, &bltdef, pbo, pptlBrush) == FALSE)
        {
            PUNTCODE(8);
            return FALSE;
        }

    //
    // Source phase.
    //
    //LL16 (grOP1_opRDRAM.pt.X, (WORD)0);
    REQUIRE(4);
    LL_OP1(0,0);

    //
    // Turn swizzle off.
    //
    ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
         LL16(grCONTROL, ppdev->grCONTROL);

    //
    // BLTDEF, and rop code.
    //
    LL_DRAWBLTDEF((bltdef << 16) | fg_rop, 2);

    //
    // Clip the BLT.
    // The clipping function will call HW16HostToScreen() to finish the BLT.
    //
    if ((pco == 0) || (pco->iDComplexity==DC_TRIVIAL))
        HW32HostToScreen(ppdev, prclDest, psoSrc, pptlSrc,
                 pbo, pptlBrush, fg_rop, pxlo, pco);
    else
        BltClip(ppdev, pco, prclDest, psoSrc, pptlSrc,
                        pbo, pptlBrush, fg_rop, pxlo, &HW32HostToScreen);

    return TRUE;
}// ===========================================================================
//
// HW32HostToScreen
//
//  This function is responsible for actually talking to the chip.
//  At this point we are required to handle the BLT, so we must return TRUE.
//  All decisions as to whether to punt or not must be made in the top level
//  function Color32HostToScreen().
//
//  This function is called from BltClip() through a pointer set by
//  Color326HostToScreen().
//
// ===========================================================================
BOOL HW32HostToScreen(
        PPDEV     ppdev,
        RECTL*    prclDest,
        SURFOBJ*  psoSrc,
        POINTL*   pptlSrc,
        BRUSHOBJ* pbo,
        POINTL*   pptlBrush,
        ULONG      fg_rop,
        XLATEOBJ* pxlo,
        CLIPOBJ*  pco)
{
    ULONG  x, y, i,
           bltWidth, bltHeight,
           num_dwords, num_extra;
    PBYTE  psrc;
    DWORD *pdsrc;
    UCHAR *pucData;
    ULONG SrcPhase = 0;
    void *pHOSTDATA = (void *)ppdev->pLgREGS->grHOSTDATA;


    DISPDBG(( H2S_DBG_LEVEL, "DrvBitBlt: HW32HostToScreen Entry.\n"));

    //
    // Set psrc to point to first pixel in source.
    //
    psrc =  psoSrc->pvScan0;               // Start of surface.
    psrc += (psoSrc->lDelta * pptlSrc->y); // Start of scanline.
    psrc += (pptlSrc->x * ppdev->iBytesPerPixel);  // Starting pixel in scanline.


    //
    // Set DEST x,y
    //
    REQUIRE(5);
    LL_OP0 (prclDest->left, prclDest->top);


    //
    // Set the X and Y extents, and do the BLT.
    // Calculate BLT size in pixels.
    //
    bltWidth = (prclDest->right - prclDest->left);
    bltHeight = (prclDest->bottom - prclDest->top);
    LL_BLTEXT (bltWidth, bltHeight);


    //
    // Now we supply the HOSTDATA.
    // 1 pixel per DWORD.  This is easy.
    //

    //
    // The chip has a bug in it that causes us to have to write extra HOSTDATA
    // under certian conditions.
    //
    i = MAKE_HD_INDEX((bltWidth*4), SrcPhase, (prclDest->left*4));
    num_extra =  ExtraDwordTable [i];
    DISPDBG(( H2S_DBG_LEVEL, "DrvBitBlt: BLT requires %d extra HOSTDATA writes.\n",num_extra));


    // Supply HOSTDATA for each scan line.
    for (y=0; y<bltHeight; ++y)
    {
                WRITE_STRING(psrc, bltWidth);


        //
        // Add any extra hostdata we need to get around the hostdata bug.
        //
        REQUIRE(num_extra);
        for (i=0; i<num_extra; ++i)
                LL32 (grHOSTDATA[0], 0);


        // Move down one scanline in source.
        psrc += psoSrc->lDelta;
    }

    return TRUE;

}

#endif // 0
#endif // BUS_MASTER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\lines.c ===
#include "precomp.h"

///////////////////////////////////////////////////////////////////////

// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit
// signed LONGLONGs and 64-bit unsigned DWORDLONGs.
//
// UUInt32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies
//      two 32-bit ULONGs to produce a 64-bit DWORDLONG result.
//
// UInt64By32To32 is our own macro to divide a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// UInt64Mod32To32 is our own macro to modulus a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// 64 bit divides are usually very expensive.  Since it's very rare
// that we'll get lines where the upper 32 bits of the 64 bit result
// are used, we can almost always use 32-bit ULONG divides.  We still
// must correctly handle the larger cases:

#define UInt64Div32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define UInt64Mod32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) % (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) % (ULONG)(b)))

#define SWAPL(x,y,t)        {t = x; x = y; y = t;}

FLONG gaflRound[] = {
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // no flips
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_V
    FL_V_ROUND_DOWN,                   // FL_FLIP_V | FL_FLIP_D
    FL_V_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE
    0xbaadf00d,                        // FL_FLIP_SLOPE_ONE | FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE | FL_FLIP_V
    0xbaadf00d                         // FL_FLIP_SLOPE_ONE | FL_FLIP_V | FL_FLIP_D
};

BOOL bIntegerLine(PDEV*, ULONG, ULONG, ULONG, ULONG);
BOOL bHardwareLine(PDEV*, POINTFIX*, POINTFIX*);

/******************************Public*Routine******************************\
* BOOL bLines(ppdev, pptfxFirst, pptfxBuf, cptfx, pls,
*                   prclClip, apfn[], flStart)
*
* Computes the DDA for the line and gets ready to draw it.  Puts the
* pixel data into an array of strips, and calls a strip routine to
* do the actual drawing.
*
* Doing NT Lines Right
* --------------------
*
* In NT, all lines are given to the device driver in fractional
* coordinates, in a 28.4 fixed point format.  The lower 4 bits are
* fractional for sub-pixel positioning.
*
* Note that you CANNOT! just round the coordinates to integers
* and pass the results to your favorite integer Bresenham routine!!
* (Unless, of course, you have such a high resolution device that
* nobody will notice -- not likely for a display device.)  The
* fractions give a more accurate rendering of the line -- this is
* important for things like our Bezier curves, which would have 'kinks'
* if the points in its polyline approximation were rounded to integers.
*
* Unfortunately, for fractional lines there is more setup work to do
* a DDA than for integer lines.  However, the main loop is exactly
* the same (and can be done entirely with 32 bit math).
*
* If You've Got Hardware That Does Bresenham
* ------------------------------------------
*
* A lot of hardware limits DDA error terms to 'n' bits.  With fractional
* coordinates, 4 bits are given to the fractional part, letting
* you draw in hardware only those lines that lie entirely in a 2^(n-4)
* by 2^(n-4) pixel space.
*
* And you still have to correctly draw those lines with coordinates
* outside that space!  Remember that the screen is only a viewport
* onto a 28.4 by 28.4 space -- if any part of the line is visible
* you MUST render it precisely, regardless of where the end points lie.
* So even if you do it in software, somewhere you'll have to have a
* 32 bit DDA routine.
*
* Our Implementation
* ------------------
*
* We employ a run length slice algorithm: our DDA calculates the
* number of pixels that are in each row (or 'strip') of pixels.
*
* We've separated the running of the DDA and the drawing of pixels:
* we run the DDA for several iterations and store the results in
* a 'strip' buffer (which are the lengths of consecutive pixel rows of
* the line), then we crank up a 'strip drawer' that will draw all the
* strips in the buffer.
*
* We also employ a 'half-flip' to reduce the number of strip
* iterations we need to do in the DDA and strip drawing loops: when a
* (normalized) line's slope is more than 1/2, we do a final flip
* about the line y = (1/2)x.  So now, instead of each strip being
* consecutive horizontal or vertical pixel rows, each strip is composed
* of those pixels aligned in 45 degree rows.  So a line like (0, 0) to
* (128, 128) would generate only one strip.
*
* We also always draw only left-to-right.
*
* Styled lines may have arbitrary style patterns.  We specially
* optimize the default patterns (and call them 'masked' styles).
*
* The DDA Derivation
* ------------------
*
* Here is how I like to think of the DDA calculation.
*
* We employ Knuth's "diamond rule": rendering a one-pixel-wide line
* can be thought of as dragging a one-pixel-wide by one-pixel-high
* diamond along the true line.  Pixel centers lie on the integer
* coordinates, and so we light any pixel whose center gets covered
* by the "drag" region (John D. Hobby, Journal of the Association
* for Computing Machinery, Vol. 36, No. 2, April 1989, pp. 209-229).
*
* We must define which pixel gets lit when the true line falls
* exactly half-way between two pixels.  In this case, we follow
* the rule: when two pels are equidistant, the upper or left pel
* is illuminated, unless the slope is exactly one, in which case
* the upper or right pel is illuminated.  (So we make the edges
* of the diamond exclusive, except for the top and left vertices,
* which are inclusive, unless we have slope one.)
*
* This metric decides what pixels should be on any line BEFORE it is
* flipped around for our calculation.  Having a consistent metric
* this way will let our lines blend nicely with our curves.  The
* metric also dictates that we will never have one pixel turned on
* directly above another that's turned on.  We will also never have
* a gap; i.e., there will be exactly one pixel turned on for each
* column between the start and end points.  All that remains to be
* done is to decide how many pixels should be turned on for each row.
*
* So lines we draw will consist of varying numbers of pixels on
* successive rows, for example:
*
*       ******
*             *****
*                  ******
*                        *****
*
* We'll call each set of pixels on a row a "strip".
*
* (Please remember that our coordinate space has the origin as the
* upper left pixel on the screen; postive y is down and positive x
* is right.)
*
* Device coordinates are specified as fixed point 28.4 numbers,
* where the first 28 bits are the integer coordinate, and the last
* 4 bits are the fraction.  So coordinates may be thought of as
* having the form (x, y) = (M/F, N/F) where F is the constant scaling
* factor F = 2^4 = 16, and M and N are 32 bit integers.
*
* Consider the line from (M0/F, N0/F) to (M1/F, N1/F) which runs
* left-to-right and whose slope is in the first octant, and let
* dM = M1 - M0 and dN = N1 - N0.  Then dM >= 0, dN >= 0 and dM >= dN.
*
* Since the slope of the line is less than 1, the edges of the
* drag region are created by the top and bottom vertices of the
* diamond.  At any given pixel row y of the line, we light those
* pixels whose centers are between the left and right edges.
*
* Let mL(n) denote the line representing the left edge of the drag
* region.  On pixel row j, the column of the first pixel to be
* lit is
*
*       iL(j) = ceiling( mL(j * F) / F)
*
* Since the line's slope is less than one:
*
*       iL(j) = ceiling( mL([j + 1/2] F) / F )
*
* Recall the formula for our line:
*
*       n(m) = (dN / dM) (m - M0) + N0
*
*       m(n) = (dM / dN) (n - N0) + M0
*
* Since the line's slope is less than one, the line representing
* the left edge of the drag region is the original line offset
* by 1/2 pixel in the y direction:
*
*       mL(n) = (dM / dN) (n - F/2 - N0) + M0
*
* From this we can figure out the column of the first pixel that
* will be lit on row j, being careful of rounding (if the left
* edge lands exactly on an integer point, the pixel at that
* point is not lit because of our rounding convention):
*
*       iL(j) = floor( mL(j F) / F ) + 1
*
*             = floor( ((dM / dN) (j F - F/2 - N0) + M0) / F ) + 1
*
*             = floor( F dM j - F/2 dM - N0 dM + dN M0) / F dN ) + 1
*
*                      F dM j - [ dM (N0 + F/2) - dN M0 ]
*             = floor( ---------------------------------- ) + 1
*                                   F dN
*
*                      dM j - [ dM (N0 + F/2) - dN M0 ] / F
*             = floor( ------------------------------------ ) + 1       (1)
*                                     dN
*
*             = floor( (dM j + alpha) / dN ) + 1
*
* where
*
*       alpha = - [ dM (N0 + F/2) - dN M0 ] / F
*
* We use equation (1) to calculate the DDA: there are iL(j+1) - iL(j)
* pixels in row j.  Because we are always calculating iL(j) for
* integer quantities of j, we note that the only fractional term
* is constant, and so we can 'throw away' the fractional bits of
* alpha:
*
*       beta = floor( - [ dM (N0 + F/2) - dN M0 ] / F )                 (2)
*
* so
*
*       iL(j) = floor( (dM j + beta) / dN ) + 1                         (3)
*
* for integers j.
*
* Note if iR(j) is the line's rightmost pixel on row j, that
* iR(j) = iL(j + 1) - 1.
*
* Similarly, rewriting equation (1) as a function of column i,
* we can determine, given column i, on which pixel row j is the line
* lit:
*
*                       dN i + [ dM (N0 + F/2) - dN M0 ] / F
*       j(i) = ceiling( ------------------------------------ ) - 1
*                                       dM
*
* Floors are easier to compute, so we can rewrite this:
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F
*       j(i) = floor( ----------------------------------------------- ) - 1
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F - dM
*            = floor( ---------------------------------------------------- )
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 - 1 ] / F
*            = floor( ---------------------------------------- )
*                                       dM
*
* We can once again wave our hands and throw away the fractional bits
* of the remainder term:
*
*       j(i) = floor( (dN i + gamma) / dM )                             (4)
*
* where
*
*       gamma = floor( [ dM (N0 + F/2) - dN M0 - 1 ] / F )              (5)
*
* We now note that
*
*       beta = -gamma - 1 = ~gamma                                      (6)
*
* To draw the pixels of the line, we could evaluate (3) on every scan
* line to determine where the strip starts.  Of course, we don't want
* to do that because that would involve a multiply and divide for every
* scan.  So we do everything incrementally.
*
* We would like to easily compute c , the number of pixels on scan j:
*                                  j
*
*    c  = iL(j + 1) - iL(j)
*     j
*
*       = floor((dM (j + 1) + beta) / dN) - floor((dM j + beta) / dN)   (7)
*
* This may be rewritten as
*
*    c  = floor(i    + r    / dN) - floor(i  + r  / dN)                 (8)
*     j          j+1    j+1                j    j
*
* where i , i    are integers and r  < dN, r    < dN.
*        j   j+1                   j        j+1
*
* Rewriting (7) again:
*
*    c  = floor(i  + r  / dN + dM / dN) - floor(i  + r  / dN)
*     j          j    j                          j    j
*
*
*       = floor((r  + dM) / dN) - floor(r  / dN)
*                 j                      j
*
* This may be rewritten as
*
*    c  = dI + floor((r  + dR) / dN) - floor(r  / dN)
*     j                j                      j
*
* where dI + dR / dN = dM / dN, dI is an integer and dR < dN.
*
* r  is the remainder (or "error") term in the DDA loop: r  / dN
*  j                                                      j
* is the exact fraction of a pixel at which the strip ends.  To go
* on to the next scan and compute c    we need to know r   .
*                                  j+1                  j+1
*
* So in the main loop of the DDA:
*
*    c  = dI + floor((r  + dR) / dN) and r    = (r  + dR) % dN
*     j                j                  j+1     j
*
* and we know r  < dN, r    < dN, and dR < dN.
*              j        j+1
*
* We have derived the DDA only for lines in the first octant; to
* handle other octants we do the common trick of flipping the line
* to the first octant by first making the line left-to-right by
* exchanging the end-points, then flipping about the lines y = 0 and
* y = x, as necessary.  We must record the transformation so we can
* undo them later.
*
* We must also be careful of how the flips affect our rounding.  If
* to get the line to the first octant we flipped about x = 0, we now
* have to be careful to round a y value of 1/2 up instead of down as
* we would for a line originally in the first octant (recall that
* "In the case where two pels are equidistant, the upper or left
* pel is illuminated...").
*
* To account for this rounding when running the DDA, we shift the line
* (or not) in the y direction by the smallest amount possible.  That
* takes care of rounding for the DDA, but we still have to be careful
* about the rounding when determining the first and last pixels to be
* lit in the line.
*
* Determining The First And Last Pixels In The Line
* -------------------------------------------------
*
* Fractional coordinates also make it harder to determine which pixels
* will be the first and last ones in the line.  We've already taken
* the fractional coordinates into account in calculating the DDA, but
* the DDA cannot tell us which are the end pixels because it is quite
* happy to calculate pixels on the line from minus infinity to positive
* infinity.
*
* The diamond rule determines the start and end pixels.  (Recall that
* the sides are exclusive except for the left and top vertices.)
* This convention can be thought of in another way: there are diamonds
* around the pixels, and wherever the true line crosses a diamond,
* that pel is illuminated.
*
* Consider a line where we've done the flips to the first octant, and the
* floor of the start coordinates is the origin:
*
*        +-----------------------> +x
*        |
*        | 0                     1
*        |     0123456789abcdef
*        |
*        |   0 00000000?1111111
*        |   1 00000000 1111111
*        |   2 0000000   111111
*        |   3 000000     11111
*        |   4 00000    ** 1111
*        |   5 0000       ****1
*        |   6 000           1***
*        |   7 00             1  ****
*        |   8 ?                     ***
*        |   9 22             3         ****
*        |   a 222           33             ***
*        |   b 2222         333                ****
*        |   c 22222       3333                    **
*        |   d 222222     33333
*        |   e 2222222   333333
*        |   f 22222222 3333333
*        |
*        | 2                     3
*        v
*        +y
*
* If the start of the line lands on the diamond around pixel 0 (shown by
* the '0' region here), pixel 0 is the first pel in the line.  The same
* is true for the other pels.
*
* A little more work has to be done if the line starts in the
* 'nether-land' between the diamonds (as illustrated by the '*' line):
* the first pel lit is the first diamond crossed by the line (pixel 1 in
* our example).  This calculation is determined by the DDA or slope of
* the line.
*
* If the line starts exactly half way between two adjacent pixels
* (denoted here by the '?' spots), the first pixel is determined by our
* round-down convention (and is dependent on the flips done to
* normalize the line).
*
* Last Pel Exclusive
* ------------------
*
* To eliminate repeatedly lit pels between continuous connected lines,
* we employ a last-pel exclusive convention: if the line ends exactly on
* the diamond around a pel, that pel is not lit.  (This eliminates the
* checks we had in the old code to see if we were re-lighting pels.)
*
* The Half Flip
* -------------
*
* To make our run length algorithm more efficient, we employ a "half
* flip".  If after normalizing to the first octant, the slope is more
* than 1/2, we subtract the y coordinate from the x coordinate.  This
* has the effect of reflecting the coordinates through the line of slope
* 1/2.  Note that the diagonal gets mapped into the x-axis after a half
* flip.
*
* How Many Bits Do We Need, Anyway?
* ---------------------------------
*
* Note that if the line is visible on your screen, you must light up
* exactly the correct pixels, no matter where in the 28.4 x 28.4 device
* space the end points of the line lie (meaning you must handle 32 bit
* DDAs, you can certainly have optimized cases for lesser DDAs).
*
* We move the origin to (floor(M0 / F), floor(N0 / F)), so when we
* calculate gamma from (5), we know that 0 <= M0, N0 < F.  And we
* are in the first octant, so dM >= dN.  Then we know that gamma can
* be in the range [(-1/2)dM, (3/2)dM].  The DDI guarantees us that
* valid lines will have dM and dN values at most 31 bits (unsigned)
* of significance.  So gamma requires 33 bits of significance (we store
* this as a 64 bit number for convenience).
*
* When running through the DDA loop, r  + dR can have a value in the
*                                     j
* range 0 <= r  < 2 dN; thus the result must be a 32 bit unsigned value.
*             j
*
* Testing Lines
* -------------
*
* To be NT compliant, a display driver must exactly adhere to GIQ,
* which means that for any given line, the driver must light exactly
* the same pels as does GDI.  This can be tested using the Guiman tool
* provided elsewhere in the DDK, and 'ZTest', which draws random lines
* on the screen and to a bitmap, and compares the results.
*
* If You've Got Line Hardware
* ---------------------------
*
* If your hardware already adheres to GIQ, you're all set.  Otherwise
* you'll want to look at the S3 sample code and read the following:
*
* 1) You'll want to special case integer-only lines, since they require
*    less processing time and are more common (CAD programs will probably
*    only ever give integer lines).  GDI does not provide a flag saying
*    that all lines in a path are integer lines; consequently, you will
*    have to explicitly check every line.
*
* 2) You are required to correctly draw any line in the 28.4 device
*    space that intersects the viewport.  If you have less than 32 bits
*    of significance in the hardware for the Bresenham terms, extremely
*    long lines would overflow the hardware.  For such (rare) cases, you
*    can fall back to strip-drawing code (or if your display is a frame
*    buffer, fall back to the engine).
*
* 3) If you can explicitly set the Bresenham terms in your hardware, you
*    can draw non-integer lines using the hardware.  If your hardware has
*    'n' bits of precision, you can draw GIQ lines that are up to 2^(n-5)
*    pels long (4 bits are required for the fractional part, and one bit is
*    used as a sign bit).  Note that integer lines don't require the 4
*    fractional bits, so if you special case them as in 1), you can do
*    integer lines that are up to 2^(n - 1) pels long.  See the
*    'bHardwareLine' routine for an example.
*
\**************************************************************************/

BOOL bLines(
PDEV*	   ppdev,
POINTFIX*  pptfxFirst,  // Start of first line
POINTFIX*  pptfxBuf,    // Pointer to buffer of all remaining lines
RUN*       prun,        // Pointer to runs if doing complex clipping
ULONG      cptfx,       // Number of points in pptfxBuf or number of runs
                        // in prun
LINESTATE* pls,         // Colour and style info
RECTL*     prclClip,    // Pointer to clip rectangle if doing simple clipping
PFNSTRIP   apfn[],      // Array of strip functions
FLONG      flStart)     // Flags for each line, which is a combination of:
                        //      FL_SIMPLE_CLIP
                        //      FL_COMPLEX_CLIP
                        //      FL_STYLED
                        //      FL_LAST_PEL_INCLUSIVE
                        //        - Should be set only for all integer lines,
                        //          and can't be used with FL_COMPLEX_CLIP
{
    ULONG     M0;
    ULONG     dM;
    ULONG     N0;
    ULONG     dN;
    ULONG     dN_Original;
    FLONG     fl;
    LONG      x;
    LONG      y;

    LONGLONG  llBeta;
    LONGLONG  llGamma;
    LONGLONG  dl;
    LONGLONG  ll;

    ULONG     ulDelta;

    ULONG     x0;
    ULONG     y0;
    ULONG     x1;
    ULONG     cStylePels;    // Major length of line in pixels for styling
    ULONG     xStart;
    POINTL    ptlStart;
    STRIP     strip;
    PFNSTRIP  pfn;
    LONG      cPels;
    LONG*     plStrip;
    LONG*     plStripEnd;
    LONG      cStripsInNextRun;

    POINTFIX* pptfxBufEnd = pptfxBuf + cptfx; // Last point in path record
    STYLEPOS  spThis;                         // Style pos for this line

    do {

/***********************************************************************\
* Start the DDA calculations.                                           *
\***********************************************************************/

        M0 = (LONG) pptfxFirst->x;
        dM = (LONG) pptfxBuf->x;

        N0 = (LONG) pptfxFirst->y;
        dN = (LONG) pptfxBuf->y;

        fl = flStart;

	// Check for non-clipped, non-styled integer endpoint lines

        if ((fl & (FL_CLIP | FL_STYLED)) == 0)
        {
            // Special-case integer end-point lines:

#ifdef S3
#if !defined(i386)

	    if (((M0 | dM | N0 | dN) & (F - 1)) == 0)
            {
                if (bIntegerLine(ppdev, M0, N0, dM, dN))
                {
                    goto Next_Line;
                }
            }
            else

#endif
#endif

            // Check for fractional endpoint lines that are small enough
            // to use the hardware DDA:
#ifdef S3
            if (bHardwareLine(ppdev, pptfxFirst, pptfxBuf))
            {
                goto Next_Line;
            }
#endif
        }
	
        if ((LONG) M0 > (LONG) dM)
        {
        // Ensure that we run left-to-right:

            register ULONG ulTmp;
            SWAPL(M0, dM, ulTmp);
            SWAPL(N0, dN, ulTmp);
            fl |= FL_FLIP_H;
        }

    // Compute the delta dx.  The DDI says we can never have a valid delta
    // with a magnitued more than 2^31 - 1, but GDI never actually checks
    // its transforms.  So we have to check for this case to avoid overflow:

        dM -= M0;
        if ((LONG) dM < 0)
        {
            goto Next_Line;
        }

        if ((LONG) dN < (LONG) N0)
        {
        // Line runs from bottom to top, so flip across y = 0:

            N0 = -(LONG) N0;
            dN = -(LONG) dN;
            fl |= FL_FLIP_V;
        }

        dN -= N0;

        if ((LONG) dN < 0)
        {
            goto Next_Line;
        }

    // We now have a line running left-to-right, top-to-bottom from (M0, N0)
    // to (M0 + dM, N0 + dN):

        if (dN >= dM)
        {
            if (dN == dM)
            {
            // Have to special case slopes of one:

                fl |= FL_FLIP_SLOPE_ONE;
            }
            else
            {
            // Since line has slope greater than 1, flip across x = y:

                register ULONG ulTmp;
                SWAPL(dM, dN, ulTmp);
                SWAPL(M0, N0, ulTmp);
                fl |= FL_FLIP_D;
            }
        }

        fl |= gaflRound[(fl & FL_ROUND_MASK) >> FL_ROUND_SHIFT];

        x = LFLOOR((LONG) M0);
        y = LFLOOR((LONG) N0);

        M0 = FXFRAC(M0);
        N0 = FXFRAC(N0);

    // Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ]:

        llGamma = UInt32x32To64(dM, N0 + F/2) - UInt32x32To64(M0, dN);
        if (fl & FL_V_ROUND_DOWN)   // Adjust so y = 1/2 rounds down
        {
            llGamma--;
        }

        llGamma >>= FLOG2;
        llBeta = ~llGamma;

/***********************************************************************\
* Figure out which pixels are at the ends of the line.                  *
\***********************************************************************/

    // The toughest part of GIQ is determining the start and end pels.
    //
    // Our approach here is to calculate x0 and x1 (the inclusive start
    // and end columns of the line respectively, relative to our normalized
    // origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
    // start point is easily calculated by plugging x0 into our line equation
    // (which takes care of whether y = 1/2 rounds up or down in value)
    // getting y0, and then undoing the normalizing flips to get back
    // into device space.
    //
    // We look at the fractional parts of the coordinates of the start and
    // end points, and call them (M0, N0) and (M1, N1) respectively, where
    // 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
    // to determine x0:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 ........?xxxxxxx
    //   |   1 ..........xxxxxx
    //   |   2 ...........xxxxx
    //   |   3 ............xxxx
    //   |   4 .............xxx
    //   |   5 ..............xx
    //   |   6 ...............x
    //   |   7 ................
    //   |   8 ................
    //   |   9 ......**........
    //   |   a ........****...x
    //   |   b ............****
    //   |   c .............xxx****
    //   |   d ............xxxx    ****
    //   |   e ...........xxxxx        ****
    //   |   f ..........xxxxxx
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one require a special case for both the start
    // and end.  For example, if the line ends such that (M1, N1) is (9, 1),
    // the line has gone exactly through (8, 0) -- which may be considered
    // to be part of 'x' because of rounding!  So slopes of exactly slope
    // one going through (8, 0) must also be considered as belonging in 'x'.
    //
    // For lines that go left-to-right, we have the following grid:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 xxxxxxxx?.......
    //   |   1 xxxxxxx.........
    //   |   2 xxxxxx..........
    //   |   3 xxxxx...........
    //   |   4 xxxx............
    //   |   5 xxx.............
    //   |   6 xx..............
    //   |   7 x...............
    //   |   8 x...............
    //   |   9 x.....**........
    //   |   a xx......****....
    //   |   b xxx.........****
    //   |   c xxxx............****
    //   |   d xxxxx...........    ****
    //   |   e xxxxxx..........        ****
    //   |   f xxxxxxx.........
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 0.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) - 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one must be handled similarly to the right-to-
    // left case.

        {

        // Calculate x0, x1

            ULONG N1 = FXFRAC(N0 + dN);
	    ULONG M1 = FXFRAC(M0 + dM);

	    x1 = LFLOOR(M0 + dM);

            if (fl & FL_LAST_PEL_INCLUSIVE)
            {
            // It sure is easy to compute the first pel when lines have only
            // integer coordinates and are last-pel inclusive:

                x0 = 0;
                y0 = 0;

            // Last-pel inclusive lines that are exactly one pixel long
            // have a 'delta-x' and 'delta-y' equal to zero.  The problem is
            // that our clip code assumes that 'delta-x' is always non-zero
            // (since it never happens with last-pel exclusive lines).  As
            // an inelegant solution, we simply modify 'delta-x' in this
            // case -- because the line is exactly one pixel long, changing
            // the slope will obviously have no effect on rasterization.

                if (x1 == 0)
                {
                    dM      = 1;
                    llGamma = 0;
                    llBeta  = ~llGamma;
                }
            }
            else
            {
                if (fl & FL_FLIP_H)
                {
                // ---------------------------------------------------------------
                // Line runs right-to-left:  <----

                // Compute x1:

                    if (N1 == 0)
                    {
                        if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                        {
                            x1++;
                        }
                    }
                    else if (abs((LONG) (N1 - F/2)) + M1 > F)
                    {
                        x1++;
                    }

                    if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                           == (FL_FLIP_SLOPE_ONE))
                    {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                        if ((N1 > 0) && (M1 == N1 + 8))
                            x1++;

                    // Don't you love special cases?  Is this a rhetorical question?

                        if ((N0 > 0) && (M0 == N0 + 8))
                        {
                            x0      = 2;
                            ulDelta = dN;
                            goto right_to_left_compute_y0;
                        }
                    }

                // Compute x0:

                    x0      = 1;
                    ulDelta = 0;
                    if (N0 == 0)
                    {
                        if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                        {
                            x0      = 2;
                            ulDelta = dN;
                        }
                    }
                    else if (abs((LONG) (N0 - F/2)) + M0 > F)
                    {
                        x0      = 2;
                        ulDelta = dN;
                    }


                // Compute y0:

                right_to_left_compute_y0:

                    y0 = 0;
                    ll = llGamma + (LONGLONG) ulDelta;

                    if (ll >= (LONGLONG) (2 * dM - dN))
                        y0 = 2;
                    else if (ll >= (LONGLONG) (dM - dN))
                        y0 = 1;
                }
                else
                {
                // ---------------------------------------------------------------
                // Line runs left-to-right:  ---->

                // Compute x1:

                    if (!(fl & FL_LAST_PEL_INCLUSIVE))
                        x1--;

                    if (M1 > 0)
                    {
                        if (N1 == 0)
                        {
                            if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                                x1++;
                        }
                        else if (abs((LONG) (N1 - F/2)) <= (LONG) M1)
                        {
                            x1++;
                        }
                    }

                    if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                           == (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                    {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                        if ((M1 > 0) && (N1 == M1 + 8))
                            x1--;

                        if ((M0 > 0) && (N0 == M0 + 8))
                        {
                            x0 = 0;
                            goto left_to_right_compute_y0;
                        }
                    }

                // Compute x0:

                    x0 = 0;
                    if (M0 > 0)
                    {
                        if (N0 == 0)
                        {
                            if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                                x0 = 1;
                        }
                        else if (abs((LONG) (N0 - F/2)) <= (LONG) M0)
                        {
                            x0 = 1;
                        }
                    }

                // Compute y0:

                left_to_right_compute_y0:

                    y0 = 0;
                    if (llGamma >= (LONGLONG) (dM - (dN & (-(LONG) x0))))
                    {
                        y0 = 1;
                    }
                }
            }
        }

        cStylePels = x1 - x0 + 1;
        if ((LONG) cStylePels <= 0)
            goto Next_Line;

        xStart = x0;

/***********************************************************************\
* Complex clipping.                                                     *
\***********************************************************************/

        if (fl & FL_COMPLEX_CLIP)
        {
            dN_Original = dN;

        Continue_Complex_Clipping:

            if (fl & FL_FLIP_H)
            {
            // Line runs right-to-left <-----

                x0 = xStart + cStylePels - prun->iStop - 1;
                x1 = xStart + cStylePels - prun->iStart - 1;
            }
            else
            {
            // Line runs left-to-right ----->

                x0 = xStart + prun->iStart;
                x1 = xStart + prun->iStop;
            }

            prun++;

        // Reset some variables we'll nuke a little later:

            dN          = dN_Original;
            pls->spNext = pls->spComplex;

        // No overflow since large integer math is used.  Both values
        // will be positive:

            dl = UInt32x32To64(x0, dN) + llGamma;

        // y0 = dl / dM:

            y0 = UInt64Div32To32(dl, dM);

            ASSERTDD((LONG) y0 >= 0, "y0 weird: Goofed up end pel calc?");
        }

/***********************************************************************\
* Simple rectangular clipping.                                          *
\***********************************************************************/

        if (fl & FL_SIMPLE_CLIP)
        {
            ULONG y1;
            LONG  xRight;
            LONG  xLeft;
            LONG  yBottom;
            LONG  yTop;

        // Note that y0 and y1 are actually the lower and upper bounds,
        // respectively, of the y coordinates of the line (the line may
        // have actually shrunk due to first/last pel clipping).
        //
        // Also note that x0, y0 are not necessarily zero.

            RECTL* prcl = &prclClip[(fl & FL_RECTLCLIP_MASK) >>
                                    FL_RECTLCLIP_SHIFT];

        // Normalize to the same point we've normalized for the DDA
        // calculations:

            xRight  = prcl->right  - x;
            xLeft   = prcl->left   - x;
            yBottom = prcl->bottom - y;
            yTop    = prcl->top    - y;

            if (yBottom <= (LONG) y0 ||
                xRight  <= (LONG) x0 ||
                xLeft   >  (LONG) x1)
            {
            Totally_Clipped:

                if (fl & FL_STYLED)
                {
                    pls->spNext += cStylePels;
                    if (pls->spNext >= pls->spTotal2)
                        pls->spNext %= pls->spTotal2;
                }

                goto Next_Line;
            }

            if ((LONG) x1 >= xRight)
                x1 = xRight - 1;

        // We have to know the correct y1, which we haven't bothered to
        // calculate up until now.  This multiply and divide is quite
        // expensive; we could replace it with code similar to that which
        // we used for computing y0.
        //
        // The reason why we need the actual value, and not an upper
        // bounds guess like y1 = LFLOOR(dM) + 2 is that we have to be
        // careful when calculating x(y) that y0 <= y <= y1, otherwise
        // we can overflow on the divide (which, needless to say, is very
        // bad).

            dl = UInt32x32To64(x1, dN) + llGamma;

        // y1 = dl / dM:

            y1 = UInt64Div32To32(dl, dM);

            if (yTop > (LONG) y1)
                goto Totally_Clipped;

            if (yBottom <= (LONG) y1)
            {
                y1 = yBottom;
                dl = UInt32x32To64(y1, dM) + llBeta;

            // x1 = dl / dN:

                x1 = UInt64Div32To32(dl, dN);
            }

        // At this point, we've taken care of calculating the intercepts
        // with the right and bottom edges.  Now we work on the left and
        // top edges:

            if (xLeft > (LONG) x0)
            {
                x0 = xLeft;
                dl = UInt32x32To64(x0, dN) + llGamma;

            // y0 = dl / dM;

                y0 = UInt64Div32To32(dl, dM);

                if (yBottom <= (LONG) y0)
                    goto Totally_Clipped;
            }

            if (yTop > (LONG) y0)
            {
                y0 = yTop;
                dl = UInt32x32To64(y0, dM) + llBeta;

            // x0 = dl / dN + 1;

                x0 = UInt64Div32To32(dl, dN) + 1;

                if (xRight <= (LONG) x0)
                    goto Totally_Clipped;
            }

            ASSERTDD(x0 <= x1, "Improper rectangle clip");
        }

/***********************************************************************\
* Done clipping.  Unflip if necessary.                                 *
\***********************************************************************/

        ptlStart.x = x + x0;
        ptlStart.y = y + y0;

        if (fl & FL_FLIP_D)
        {
            register LONG lTmp;
            SWAPL(ptlStart.x, ptlStart.y, lTmp);
        }


        if (fl & FL_FLIP_V)
        {
            ptlStart.y = -ptlStart.y;
        }

        cPels = x1 - x0 + 1;

/***********************************************************************\
* Style calculations.                                                   *
\***********************************************************************/

        if (fl & FL_STYLED)
        {
            STYLEPOS sp;

            spThis       = pls->spNext;
            pls->spNext += cStylePels;

            {
                if (pls->spNext >= pls->spTotal2)
                    pls->spNext %= pls->spTotal2;

                if (fl & FL_FLIP_H)
                    sp = pls->spNext - x0 + xStart;
                else
                    sp = spThis + x0 - xStart;

                ASSERTDD(fl & FL_STYLED, "Oops");

            // Normalize our target style position:

                if ((sp < 0) || (sp >= pls->spTotal2))
                {
                    sp %= pls->spTotal2;

                // The modulus of a negative number is not well-defined
                // in C -- if it's negative we'll adjust it so that it's
                // back in the range [0, spTotal2):

                    if (sp < 0)
                        sp += pls->spTotal2;
                }

            // Since we always draw the line left-to-right, but styling is
            // always done in the direction of the original line, we have
            // to figure out where we are in the style array for the left
            // edge of this line.

                if (fl & FL_FLIP_H)
                {
                // Line originally ran right-to-left:

                    sp = -sp;
                    if (sp < 0)
                        sp += pls->spTotal2;

                    pls->ulStyleMask = ~pls->ulStartMask;
                    pls->pspStart    = &pls->aspRtoL[0];
                    pls->pspEnd      = &pls->aspRtoL[pls->cStyle - 1];
                }
                else
                {
                // Line originally ran left-to-right:

                    pls->ulStyleMask = pls->ulStartMask;
                    pls->pspStart    = &pls->aspLtoR[0];
                    pls->pspEnd      = &pls->aspLtoR[pls->cStyle - 1];
                }

                if (sp >= pls->spTotal)
                {
                    sp -= pls->spTotal;
                    if (pls->cStyle & 1)
                        pls->ulStyleMask = ~pls->ulStyleMask;
                }

                pls->psp = pls->pspStart;
                while (sp >= *pls->psp)
                    sp -= *pls->psp++;

                ASSERTDD(pls->psp <= pls->pspEnd,
                        "Flew off into NeverNeverLand");

                pls->spRemaining = *pls->psp - sp;
                if ((pls->psp - pls->pspStart) & 1)
                    pls->ulStyleMask = ~pls->ulStyleMask;
            }
        }

        plStrip    = &strip.alStrips[0];
        plStripEnd = &strip.alStrips[STRIP_MAX];    // Is exclusive
        cStripsInNextRun   = 0x7fffffff;

	strip.ptlStart = ptlStart;

#ifdef S3
//
//	We cannot due diagonal lines without a DDA.  Therefore don't let it happen
//

        if (2 * dN > dM &&
            !(fl & FL_STYLED))
        {
        // Do a half flip!  Remember that we may doing this on the
        // same line multiple times for complex clipping (meaning the
        // affected variables should be reset for every clip run):

            fl |= FL_FLIP_HALF;

            llBeta  = llGamma - (LONGLONG) ((LONG) dM);
            dN = dM - dN;
            y0 = x0 - y0;       // Note this may overflow, but that's okay
        }
#endif

    // Now, run the DDA starting at (ptlStart.x, ptlStart.y)!

        strip.flFlips = fl;
        pfn           = apfn[(fl & FL_STRIP_MASK) >> FL_STRIP_SHIFT];

    // Now calculate the DDA variables needed to figure out how many pixels
    // go in the very first strip:

        {
            register LONG  i;
            register ULONG dI;
            register ULONG dR;
                     ULONG r;

            if (dN == 0)
                i = 0x7fffffff;
            else
            {
                dl = UInt32x32To64(y0 + 1, dM) + llBeta;

                ASSERTDD(dl >= 0, "Oops!");

            // i = (dl / dN) - x0 + 1;
            // r = (dl % dN);

                i = UInt64Div32To32(dl, dN);
                r = UInt64Mod32To32(dl, dN);
                i = i - x0 + 1;

                dI = dM / dN;
                dR = dM % dN;               // 0 <= dR < dN

                ASSERTDD(dI > 0, "Weird dI");
            }

            ASSERTDD(i > 0 && i <= 0x7fffffff, "Weird initial strip length");
            ASSERTDD(cPels > 0, "Zero pel line");

/***********************************************************************\
* Run the DDA!                                                          *
\***********************************************************************/

            while(TRUE)
            {
                cPels -= i;
                if (cPels <= 0)
                    break;

                *plStrip++ = i;

                if (plStrip == plStripEnd)
                {
                    strip.cStrips = plStrip - &strip.alStrips[0];
                    (*pfn)(ppdev, &strip, pls);
                    plStrip = &strip.alStrips[0];
                }

                i = dI;
                r += dR;

                if (r >= dN)
                {
                    r -= dN;
                    i++;
                }
            }

            *plStrip++ = cPels + i;

            strip.cStrips = plStrip - &strip.alStrips[0];
            (*pfn)(ppdev, &strip, pls);


        }

    Next_Line:

        if (fl & FL_COMPLEX_CLIP)
        {
            cptfx--;
            if (cptfx != 0)
                goto Continue_Complex_Clipping;

            break;
        }
        else
        {
            pptfxFirst = pptfxBuf;
            pptfxBuf++;
        }

    } while (pptfxBuf < pptfxBufEnd);

    return(TRUE);

}


#ifdef S3
//////////////////////////////////////////////////////////////////////////
// General defines for bHardwareLine

#define HW_FLIP_D           0x0001L     // Diagonal flip
#define HW_FLIP_V           0x0002L     // Vertical flip
#define HW_FLIP_H           0x0004L     // Horizontal flip
#define HW_FLIP_SLOPE_ONE   0x0008L     // Normalized line has exactly slope one
#define HW_FLIP_MASK        (HW_FLIP_D | HW_FLIP_V | HW_FLIP_H)

#define HW_X_ROUND_DOWN     0x0100L     // x = 1/2 rounds down in value
#define HW_Y_ROUND_DOWN     0x0200L     // y = 1/2 rounds down in value

LONG gaiDir[] = { 0, 1, 7, 6, 3, 2, 4, 5 };

FLONG gaflHardwareRound[] = {
    HW_X_ROUND_DOWN | HW_Y_ROUND_DOWN,  //           |        |        |
    HW_X_ROUND_DOWN | HW_Y_ROUND_DOWN,  //           |        |        | FLIP_D
    HW_X_ROUND_DOWN,                    //           |        | FLIP_V |
    HW_Y_ROUND_DOWN,                    //           |        | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    //           | FLIP_H |        |
    HW_X_ROUND_DOWN,                    //           | FLIP_H |        | FLIP_D
    0,                                  //           | FLIP_H | FLIP_V |
    0,                                  //           | FLIP_H | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    // SLOPE_ONE |        |        |
    0xffffffff,                         // SLOPE_ONE |        |        | FLIP_D
    HW_X_ROUND_DOWN,                    // SLOPE_ONE |        | FLIP_V |
    0xffffffff,                         // SLOPE_ONE |        | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    // SLOPE_ONE | FLIP_H |        |
    0xffffffff,                         // SLOPE_ONE | FLIP_H |        | FLIP_D
    HW_X_ROUND_DOWN,                    // SLOPE_ONE | FLIP_H | FLIP_V |
    0xffffffff                          // SLOPE_ONE | FLIP_H | FLIP_V | FLIP_D
};

//////////////////////////////////////////////////////////////////////////
// S3 specific defines

#define DEFAULT_DRAW_CMD (DRAW_LINE | DRAW | DIR_TYPE_XY | MULTIPLE_PIXELS | \
                          WRITE | LAST_PIXEL_OFF)

LONG gaiDrawCmd[] = {
    DEFAULT_DRAW_CMD | PLUS_X | PLUS_Y |       0,   // Octant 0
    DEFAULT_DRAW_CMD | PLUS_X | PLUS_Y | MAJOR_Y,   // Octant 1
    DEFAULT_DRAW_CMD | PLUS_X |      0 |       0,   // Octant 7
    DEFAULT_DRAW_CMD | PLUS_X |      0 | MAJOR_Y,   // Octant 6
    DEFAULT_DRAW_CMD | 0      | PLUS_Y |       0,   // Octant 3
    DEFAULT_DRAW_CMD | 0      | PLUS_Y | MAJOR_Y,   // Octant 2
    DEFAULT_DRAW_CMD | 0      |      0 |       0,   // Octant 4
    DEFAULT_DRAW_CMD | 0      |      0 | MAJOR_Y,   // Octant 5
};

// The S3's hardware can have 13 bits of significance for the error and
// step terms:

#define NUM_DDA_BITS 13

/******************************Public*Routine******************************\
* BOOL bHardwareLine(ppdev, pptfxStart, pptfxEnd)
*
* This routine is useful for folks who have line drawing hardware where
* they can explicitly set the Bresenham terms -- they can use this routine
* to draw fractional coordinate GIQ lines with the hardware.
*
* Fractional coordinate lines require an extra 4 bits of precision in the
* Bresenham terms.  For example, if your hardware has 13 bits of precision
* for the terms, you can only draw GIQ lines up to 255 pels long using this
* routine.
*
* Input:
*   pptfxStart  - Points to GIQ coordinate of start of line
*   pptfxEnd    - Points to GIQ coordinate of end of line
*   NUM_DDA_BITS- The number of bits of precision your hardware can support.
*
* Output:
*   returns     - TRUE if the line was drawn.
*                 FALSE if the line is too long, and the strips code must be
*                 used.
*
* DDALINE:
*   iDir        - Direction of the line, as an octant numbered as follows:
*
*                    \ 5 | 6 /
*                     \  |  /
*                    4 \ | / 7
*                       \ /
*                   -----+-----
*                       /|\
*                    3 / | \ 0
*                     /  |  \
*                    / 2 | 1 \
*
*   ptlStart    - Start pixel of line.
*   cPels       - # of pels in line.  *NOTE* You must check if this is <= 0!
*   dMajor      - Major axis delta.
*   dMinor      - Minor axis delta.
*   lErrorTerm  - Error term.
*
* What you do with the last 3 terms may be a little tricky.  They are
* actually the terms for the formula of the normalized line
*
*                     dMinor * x + (lErrorTerm + dMajor)
*       y(x) = floor( ---------------------------------- )
*                                  dMajor
*
* where y(x) is the y coordinate of the pixel to be lit as a function of
* the x-coordinate.
*
* Every time the line advances one in the major direction 'x', dMinor
* gets added to the current error term.  If the resulting value is >= 0,
* we know we have to move one pixel in the minor direction 'y', and
* dMajor must be subtracted from the current error term.
*
* If you're trying to figure out what this means for your hardware, you can
* think of the DDALINE terms as having been computed equivalently as
* follows:
*
*     dMinor     = 2 * (minor axis delta)
*     dMajor     = 2 * (major axis delta)
*     lErrorTerm = - (major axis delta) - fixup
*
* That is, if your documentation tells you that for integer lines, a
* register is supposed to be initialized with the value
* '2 * (minor axis delta)', you'll actually use dMinor.
*
* Example: Setting up the 8514
*
*     AXSTPSIGN is supposed to be the axial step constant register, defined
*     as 2 * (minor axis delta).  You set:
*
*           AXSTPSIGN = dMinor
*
*     DGSTPSIGN is supposed to be the diagonal step constant register,
*     defined as 2 * (minor axis delta) - 2 * (major axis delta).  You set:
*
*           DGSTPSIGN = dMinor - dMajor
*
*     ERR_TERM is supposed to be the adjusted error term, defined as
*     2 * (minor axis delta) - (major axis delta) - fixup.  You set:
*
*           ERR_TERM = lErrorTerm + dMinor
*
* Implementation:
*
*     You'll want to special case integer lines before calling this routine
*     (since they're very common, take less time to the computation of line
*     terms, and can handle longer lines than this routine because 4 bits
*     aren't being given to the fraction).
*
*     If a GIQ line is too long to be handled by this routine, you can just
*     use the slower strip routines for that line.  Note that you cannot
*     just fail the call -- you must be able to accurately draw any line
*     in the 28.4 device space when it intersects the viewport.
*
* Testing:
*
*     Use Guiman, or some other test that draws random fractional coordinate
*     lines and compares them to what GDI itself draws to a bitmap.
*
\**************************************************************************/

BOOL bHardwareLine(
PDEV*     ppdev,
POINTFIX* pptfxStart,       // Start of line
POINTFIX* pptfxEnd)         // End of line
{
    FLONG fl;    // Various flags
    ULONG M0;    // Normalized fractional unit x start coordinate (0 <= M0 < F)
    ULONG N0;    // Normalized fractional unit y start coordinate (0 <= N0 < F)
    ULONG M1;    // Normalized fractional unit x end coordinate (0 <= M1 < F)
    ULONG N1;    // Normalized fractional unit x end coordinate (0 <= N1 < F)
    ULONG dM;    // Normalized fractional unit x-delta (0 <= dM)
    ULONG dN;    // Normalized fractional unit y-delta (0 <= dN <= dM)
    LONG  x;     // Normalized x coordinate of origin
    LONG  y;     // Normalized y coordinate of origin
    LONG  x0;    // Normalized x offset from origin to start pixel (inclusive)
    LONG  y0;    // Normalized y offset from origin to start pixel (inclusive)
    LONG  x1;    // Normalized x offset from origin to end pixel (inclusive)
    LONG  lGamma;// Bresenham error term at origin
    LONG  cPels; // Number of pixels in line

/***********************************************************************\
* Normalize line to the first octant.
\***********************************************************************/

    fl = 0;

    M0 = pptfxStart->x;
    dM = pptfxEnd->x;

    if ((LONG) dM < (LONG) M0)
    {
    // Line runs from right to left, so flip across x = 0:

        M0 = -(LONG) M0;
        dM = -(LONG) dM;
        fl |= HW_FLIP_H;
    }

// Compute the delta.  The DDI says we can never have a valid delta
// with a magnitude more than 2^31 - 1, but the engine never actually
// checks its transforms.  To ensure that we'll never puke on our shoes,
// we check for that case and simply refuse to draw the line:

    dM -= M0;
    if ((LONG) dM < 0)
        return(FALSE);

    N0 = pptfxStart->y;
    dN = pptfxEnd->y;

    if ((LONG) dN < (LONG) N0)
    {
    // Line runs from bottom to top, so flip across y = 0:

        N0 = -(LONG) N0;
        dN = -(LONG) dN;
        fl |= HW_FLIP_V;
    }

// Compute another delta:

    dN -= N0;
    if ((LONG) dN < 0)
        return(FALSE);

    if (dN >= dM)
    {
        if (dN == dM)
        {
        // Have to special case slopes of one:

            fl |= HW_FLIP_SLOPE_ONE;
        }
        else
        {
        // Since line has slope greater than 1, flip across x = y:

            register ULONG ulTmp;
            ulTmp = dM; dM = dN; dN = ulTmp;
            ulTmp = M0; M0 = N0; N0 = ulTmp;
            fl |= HW_FLIP_D;
        }
    }

// Figure out if we can do the line in hardware, given that we have a
// limited number of bits of precision for the Bresenham terms.
//
// Remember that one bit has to be kept as a sign bit:

    if ((LONG) dM >= (1L << (NUM_DDA_BITS - 1)))
        return(FALSE);

    fl |= gaflHardwareRound[fl];

/***********************************************************************\
* Calculate the error term at pixel 0.
\***********************************************************************/

    x = LFLOOR((LONG) M0);
    y = LFLOOR((LONG) N0);

    M0 = FXFRAC(M0);
    N0 = FXFRAC(N0);

// NOTE NOTE NOTE: If this routine were to handle any line in the 28.4
// space, it will overflow its math (the following part requires 36 bits
// of precision)!  But we get here for lines that the hardware can handle
// (see the expression (dM >= (1L << (NUM_DDA_BITS - 1))) above?), so if
// cBits is less than 28, we're safe.
//
// If you're going to use this routine to handle all lines in the 28.4
// device space, you will HAVE to make sure the math doesn't overflow,
// otherwise you won't be NT compliant!  (See 'bHardwareLine' for an example
// how to do that.  You don't have to worry about this if you simply
// default to the strips code for long lines, because those routines
// already do the math correctly.)

// Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ].  Note
// that M0 and N0 have at most 4 bits of significance (and if the
// arguments are properly ordered, on a 486 each multiply would be no
// more than 13 cycles):

    lGamma = (N0 + F/2) * dM - M0 * dN;

    if (fl & HW_Y_ROUND_DOWN)
        lGamma--;

    lGamma >>= FLOG2;

/***********************************************************************\
* Figure out which pixels are at the ends of the line.
\***********************************************************************/

// The toughest part of GIQ is determining the start and end pels.
//
// Our approach here is to calculate x0 and x1 (the inclusive start
// and end columns of the line respectively, relative to our normalized
// origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
// start point is easily calculated by plugging x0 into our line equation
// (which takes care of whether y = 1/2 rounds up or down in value)
// getting y0, and then undoing the normalizing flips to get back
// into device space.
//
// We look at the fractional parts of the coordinates of the start and
// end points, and call them (M0, N0) and (M1, N1) respectively, where
// 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
// to determine x0:
//
//   +-----------------------> +x
//   |
//   | 0                     1
//   |     0123456789abcdef
//   |
//   |   0 ........?xxxxxxx
//   |   1 ..........xxxxxx
//   |   2 ...........xxxxx
//   |   3 ............xxxx
//   |   4 .............xxx
//   |   5 ..............xx
//   |   6 ...............x
//   |   7 ................
//   |   8 ................
//   |   9 ......**........
//   |   a ........****...x
//   |   b ............****
//   |   c .............xxx****
//   |   d ............xxxx    ****
//   |   e ...........xxxxx        ****
//   |   f ..........xxxxxx
//   |
//   | 2                     3
//   v
//
//   +y
//
// This grid accounts for the appropriate rounding of GIQ and last-pel
// exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
// on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
// depending on what flips have been done to normalize the line.
//
// For the end point, if (M1, N1) lands on an 'x', x1 =
// floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
// floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
// depending on what flips have been done to normalize the line.
//
// Lines of exactly slope one require a special case for both the start
// and end.  For example, if the line ends such that (M1, N1) is (9, 1),
// the line has gone exactly through (8, 0) -- which may be considered
// to be part of 'x' because of rounding!  So slopes of exactly slope
// one going through (8, 0) must also be considered as belonging in 'x'
// when an x value of 1/2 is supposed to round up in value.

// Calculate x0, x1:

    N1 = FXFRAC(N0 + dN);
    M1 = FXFRAC(M0 + dM);

    x1 = LFLOOR(M0 + dM);

// Line runs left-to-right:

// Compute x1:

    x1--;
    if (M1 > 0)
    {
        if (N1 == 0)
        {
            if (LROUND(M1, fl & HW_X_ROUND_DOWN))
                x1++;
        }
        else if (abs((LONG) (N1 - F/2)) <= (LONG) M1)
        {
            x1++;
        }
    }

    if ((fl & (HW_FLIP_SLOPE_ONE | HW_X_ROUND_DOWN))
           == (HW_FLIP_SLOPE_ONE | HW_X_ROUND_DOWN))
    {
    // Have to special-case diagonal lines going through our
    // the point exactly equidistant between two horizontal
    // pixels, if we're supposed to round x=1/2 down:

        if ((M1 > 0) && (N1 == M1 + 8))
            x1--;

        if ((M0 > 0) && (N0 == M0 + 8))
        {
            x0 = 0;
            goto left_to_right_compute_y0;
        }
    }

// Compute x0:

    x0 = 0;
    if (M0 > 0)
    {
        if (N0 == 0)
        {
            if (LROUND(M0, fl & HW_X_ROUND_DOWN))
                x0 = 1;
        }
        else if (abs((LONG) (N0 - F/2)) <= (LONG) M0)
        {
            x0 = 1;
        }
    }

left_to_right_compute_y0:

/***********************************************************************\
* Calculate the start pixel.
\***********************************************************************/

// We now compute y0 and adjust the error term.  We know x0, and we know
// the current formula for the pixels to be lit on the line:
//
//                     dN * x + lGamma
//       y(x) = floor( --------------- )
//                           dM
//
// The remainder of this expression is the new error term at (x0, y0).
// Since x0 is going to be either 0 or 1, we don't actually have to do a
// multiply or divide to compute y0.  Finally, we subtract dM from the
// new error term so that it is in the range [-dM, 0).

    y0      = 0;
    lGamma += (dN & (-x0));
    lGamma -= dM;
    if (lGamma >= 0)
    {
        y0      = 1;
        lGamma -= dM;
    }

// Undo our flips to get the start coordinate:

    x += x0;
    y += y0;

    if (fl & HW_FLIP_D)
    {
        register LONG lTmp;
        lTmp = x; x = y; y = lTmp;
    }

    if (fl & HW_FLIP_V)
    {
        y = -y;
    }

    if (fl & HW_FLIP_H)
    {
        x = -x;
    }

/***********************************************************************\
* Return the Bresenham terms:
\***********************************************************************/

    // iDir       = gaiDir[fl & HW_FLIP_MASK];
    // ptlStart.x = x;
    // ptlStart.y = y;
    // cPels      = x1 - x0 + 1;  // NOTE: You'll have to check if cPels <= 0!
    // dMajor     = dM;
    // dMinor     = dN;
    // lErrorTerm = lGamma;

/***********************************************************************\
* Draw the line.  S3 specific code follows:
\***********************************************************************/

    cPels = x1 - x0 + 1;
    if (cPels > 0)
    {
        IO_FIFO_WAIT(ppdev, 7);

        IO_CUR_X(ppdev, x);
        IO_CUR_Y(ppdev, y);
        IO_MAJ_AXIS_PCNT(ppdev, cPels);
        IO_AXSTP(ppdev, dN);
        IO_DIASTP(ppdev, dN - dM);
        IO_ERR_TERM(ppdev, dN + lGamma);
        IO_CMD(ppdev, gaiDrawCmd[fl & HW_FLIP_MASK]);
    }

    return(TRUE);
}

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\overlay.c ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1997, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         overlay.c
*
* DESCRIPTION:
*
* REVISION HISTORY:
*
* $Log:   //uinac/log/log/laguna/ddraw/src/overlay.c  $
* 
*    Rev 1.20   Apr 07 1998 10:48:04   frido
* PDR#11299. We should always handle the DDOVER_HIDE flag in
* UpdateSurface32, even when the device is in background mode.
* Otherwise we might end up having the overlay disabled when it is no
* longer updated.
* 
*    Rev 1.19   06 Jan 1998 14:58:22   xcong
* Passs lpDDHALData into SyncWithQueusManager().
* 
*    Rev 1.18   06 Jan 1998 11:53:16   xcong
* Change pDriverData into local lpDDHALData for multi-monitor support.
*
*    Rev 1.17   08 Dec 1997 14:43:40   BERSABE
* used in fw162b12, fixed PDR# 10991. OverFly disappeared after switch back and
* and forth to DOS full several times
* 
*    Rev 1.16.1.2   Dec 06 1997 14:45:48   bersabe
* * Fixed PDR# 10991. OverFly disappered after switch back and forth to DOS ful
* * several times. 
* 
*    Rev 1.16.1.2   06 Dec 1997 14:35:00   chaoyi #cyl1
* 
* Fixed PDR# 10991. OverFly disappered after switch back and forth to DOS full screen
* several times. 
* 
*    Rev 1.16.1.1   25 Nov 1997 16:39:32   randys
* 
* Updated VDD API values to maintain backward compatibility
* 
*    Rev 1.16.1.0   10 Nov 1997 13:44:24   randys
* 
* Updated hard coded Win32 overlay API function number 12 ----> 13
* 
*    Rev 1.16   23 Oct 1997 11:17:30   frido
* Merged file with 161 tree.
* 
*    Rev 1.11.1.0   21 Oct 1997 17:49:10   frido
* HP#75. Added call to VXD whenever we get a request to update the position
* of an overlay so the VXD knows it has been updated.
* 
*    Rev 1.15   17 Oct 1997 11:31:32   bennyn
* 
* For NT, in UpdateOverlay32 & SetOverlayPosition32, return if dwReser0
* 
*    Rev 1.14   09 Oct 1997 15:16:18   bennyn
* Removed Noel's hack in QueryOverlaySupport.
* 
*    Rev 1.13   08 Oct 1997 11:15:44   RUSSL
* Fix for NT40 build without overlay support
*
*    Rev 1.12   08 Oct 1997 10:34:28   noelv
* HAcked QueryOverlaySupport to always return FALSE for NT.
*
*    Rev 1.11   19 Sep 1997 14:33:42   bennyn
* Fixed the NT4.0 5462/64 build problem
*
*    Rev 1.10   16 Sep 1997 15:10:26   bennyn
* Modified for NT DD overlay
*
*    Rev 1.9   29 Aug 1997 16:25:28   RUSSL
* Added support for NT
*
*    Rev 1.8   09 Jul 1997 14:47:58   RUSSL
* For forward compatibility, assume future chips support overlay
*
*    Rev 1.7   27 Apr 1997 22:10:38   cjl
* Added DX5-related test code.
* Added code, wrapped by "#ifdef TEST_DX5_AGP_HBT," that forces
* overlay support off.
*
*    Rev 1.6   01 Apr 1997 09:14:36   RUSSL
* Added calls to SyncWithQueueManager in UpdateOverlay32, SetOverlayPosition32
*   & SetColorKey32
*
*    Rev 1.5   12 Mar 1997 15:18:16   RUSSL
* replaced a block of includes with include of precomp.h for
*   precompiled headers
* Added check of pDriverData->bInBackground flag in UpdateOverlay32 and
*   SetOverlayPosition32.  If this flag is set then we want to fail the
*   call because we are in fullscreen DOS.
*
*    Rev 1.4   07 Mar 1997 12:57:44   RUSSL
* Modified DDRAW_COMPAT usage
*
*    Rev 1.3   31 Jan 1997 08:51:48   RUSSL
* Added better chip checking to QueryOverlaySupport
*
*    Rev 1.2   27 Jan 1997 18:36:02   RUSSL
* Moved GetFormatInfo to surface.c
*
*    Rev 1.1   21 Jan 1997 14:37:12   RUSSL
* Added OverlayReInit and GetFormatInfo functions
*
*    Rev 1.0   15 Jan 1997 10:33:36   RUSSL
* Initial revision.
*
***************************************************************************
***************************************************************************/

/***************************************************************************
* I N C L U D E S
****************************************************************************/

#include "precomp.h"

#if defined WINNT_VER35      // WINNT_VER35
// If WinNT 3.5 skip all the source code
#elif defined (NTDRIVER_546x)
// If WinNT 4.0 and 5462/64 build skip all the source code
#elif defined(WINNT_VER40) && !defined(OVERLAY)
// if nt40 without overlay, skip all the source code
#else

#ifndef WINNT_VER40
#include "flip.h"
#include "surface.h"
#include "blt.h"
#include "overlay.h"
#endif

/***************************************************************************
* D E F I N E S
****************************************************************************/

// VW_CAP0 bits
#define VWCAP_VW_PRESENT      0x00000001

#ifdef WINNT_VER40
#define lpDDHALData     ((DRIVERDATA *)(&(ppdev->DriverData)))
#endif

/***************************************************************************
* G L O B A L   V A R I A B L E S
****************************************************************************/

#ifndef WINNT_VER40
OVERLAYTABLE  OverlayTable;
#endif

/***************************************************************************
* S T A T I C   V A R I A B L E S
****************************************************************************/

#ifndef WINNT_VER40
ASSERTFILE("overlay.c");
#endif

/***************************************************************************
*
* FUNCTION:    QueryOverlaySupport()
*
* DESCRIPTION:
*
****************************************************************************/

BOOL QueryOverlaySupport
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#else
   LPGLOBALDATA lpDDHALData, 
#endif
  DWORD dwChipType
)
{
#ifdef TEST_DX5_AGP_HBT
  lpDDHALData->fOverlaySupport = FALSE;
  return lpDDHALData->fOverlaySupport;
#endif // TEST_DX5_AGP_HBT

  // We should check the capabilities register on the chip
  // but it's busted

#ifdef WINNT_VER40
  if (CL_GD5465 > dwChipType)
    lpDDHALData->fOverlaySupport = FALSE;
  else if (CL_GD5465 == dwChipType)
    lpDDHALData->fOverlaySupport = TRUE;

#else
  if (REVID_PRE65 & lpDDHALData->bRevInfoBits)
    lpDDHALData->fOverlaySupport = FALSE;
  else if (GD5465_PCI_DEVICE_ID == dwChipType)
    lpDDHALData->fOverlaySupport = TRUE;
#endif

  else
  {
#if 1
    // assume overlay hw exists
    lpDDHALData->fOverlaySupport = TRUE;
#else
    int     i;
    PVGAR   pREG = (PVGAR)lpDDHALData->RegsAddress;

    // assume no overlay hw
    lpDDHALData->fOverlaySupport = FALSE;

    // now check caps to see if any overlay hw present
    for (i = 0; i < MAX_VIDEO_WINDOWS; i++)
    {
      if (VWCAP_VW_PRESENT & pREG->VideoWindow[i].grVW_CAP0)
        lpDDHALData->fOverlaySupport = TRUE;
    }
#endif
  }

  return lpDDHALData->fOverlaySupport;
}

/***************************************************************************
*
* FUNCTION:    OverlayInit()
*
* DESCRIPTION:
*
****************************************************************************/

VOID OverlayInit
(
#ifdef WINNT_VER40
  PDEV                  *ppdev,
  DWORD                 dwChipType,
  PDD_SURFACECALLBACKS  pSurfaceCallbacks,
  PDD_HALINFO           pDDHalInfo
#else
  DWORD                       dwChipType,
  LPDDHAL_DDSURFACECALLBACKS  pSurfaceCallbacks,
  LPDDHALINFO                 pDDHalInfo,
  LPGLOBALDATA                lpDDHALData
#endif
)
{
#ifdef WINNT_VER40
#else
  memset(&OverlayTable,0, sizeof(OVERLAYTABLE));
#endif

#ifdef WINNT_VER40
  if (! QueryOverlaySupport(ppdev,dwChipType))
#else
    if (! QueryOverlaySupport(lpDDHALData,dwChipType))
#endif
    return;

#ifdef WINNT_VER40
  // NT passes pSurfaceCallbacks as NULL from DrvGetDirectDrawInfo
  if (NULL != pSurfaceCallbacks)
#endif
  {
    // fill in overlay callbacks
    pSurfaceCallbacks->UpdateOverlay = UpdateOverlay32;
    pSurfaceCallbacks->dwFlags |= DDHAL_SURFCB32_UPDATEOVERLAY;

    pSurfaceCallbacks->SetOverlayPosition = SetOverlayPosition32;
    pSurfaceCallbacks->dwFlags |= DDHAL_SURFCB32_SETOVERLAYPOSITION;

    pSurfaceCallbacks->SetColorKey = SetColorKey32;
    pSurfaceCallbacks->dwFlags |= DDHAL_SURFCB32_SETCOLORKEY;
  }

#ifdef WINNT_VER40
  // NT passes pDDHalInfo as NULL from DrvEnableDirectDraw
  if ((NULL != pDDHalInfo) && (CL_GD5465 == dwChipType))
    Init5465Overlay(ppdev, dwChipType, pDDHalInfo, &ppdev->DriverData.OverlayTable);
#else
  if (GD5465_PCI_DEVICE_ID == dwChipType)
    Init5465Overlay(dwChipType, pDDHalInfo, &OverlayTable, lpDDHALData);
#endif
}

#ifndef WINNT_VER40
/***************************************************************************
*
* FUNCTION:    OverlayReInit()
*
* DESCRIPTION:
*
****************************************************************************/

VOID OverlayReInit
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DWORD       dwChipType,
  PDD_HALINFO pDDHalInfo
#else
  DWORD       dwChipType,
  LPDDHALINFO pDDHalInfo,
  LPGLOBALDATA lpDDHALData
#endif
)
{
#ifdef WINNT_VER40
  if (! QueryOverlaySupport(ppdev,dwChipType))
#else
    if (! QueryOverlaySupport(lpDDHALData, dwChipType))
#endif
    return;

#ifdef WINNT_VER40
#pragma message("OverlayReInit: Is this function even needed for NT?")
  if (CL_GD5465 == dwChipType)
    Init5465Info(ppdev, pDDHalInfo);
#else
  if (GD5465_PCI_DEVICE_ID == dwChipType)
    Init5465Info(pDDHalInfo, lpDDHALData);
#endif
}
#endif  // ifndef WINNT_VER40

/***************************************************************************
*
* FUNCTION:     UpdateOverlay32
*
* DESCRIPTION:
*
****************************************************************************/

DWORD __stdcall UpdateOverlay32
(
#ifdef WINNT_VER40
  PDD_UPDATEOVERLAYDATA     pInput
#else
  LPDDHAL_UPDATEOVERLAYDATA pInput
#endif
)
{
#ifdef WINNT_VER40
  PDEV*   ppdev = (PDEV *)pInput->lpDD->dhpdev;
#else
	DWORD	cbBytesReturned;
	HANDLE	vxd;
    LPGLOBALDATA lpDDHALData = GetDDHALContext(pInput->lpDD);
#endif

  DD_LOG(("UpdateOverlay32 Entry\r\n"));

#ifndef WINNT_VER40
  DBG_MESSAGE(("UpdateOverlay32 (lpInput = 0x%08lX)", pInput));

	vxd = CreateFile("\\\\.\\546X.VXD", 0, 0, 0, CREATE_NEW,
			FILE_FLAG_DELETE_ON_CLOSE, 0);
	if (vxd != INVALID_HANDLE_VALUE)
	{
                DeviceIoControl(vxd, 12, NULL, 0, NULL, 0, &cbBytesReturned, NULL);
		CloseHandle(vxd);
	}
#endif

#ifdef WINNT_VER40
//#pragma message("UpdateOverlay32: Does NT ddraw call this function while in fullscreen DOS?")
  if (pInput->lpDDSrcSurface->dwReserved1 == 0)
  {
    pInput->ddRVal = DDERR_SURFACEBUSY;
    return DDHAL_DRIVER_HANDLED;
  }
#else
  if (lpDDHALData->bInBackground
#if 1 // PDR#11299. Always handle an overlaydisable call.
  && !(pInput->dwFlags & DDOVER_HIDE)
#endif
  )
  {
//#cyl1    pInput->ddRVal = DDERR_SURFACEBUSY;
    pInput->ddRVal = DD_OK; //#cyl1	 
    return DDHAL_DRIVER_HANDLED;
  }
#endif

#ifdef WINNT_VER40
  SYNC_W_3D(ppdev);
  return ppdev->DriverData.OverlayTable.pfnUpdateOverlay(ppdev,pInput);
#else
  SyncWithQueueManager(lpDDHALData);
  return OverlayTable.pfnUpdateOverlay(pInput);
#endif
} /* UpdateOverlay32 */

/***************************************************************************
*
* FUNCTION:     SetOverlayPosition32
*
* DESCRIPTION:
*
****************************************************************************/

DWORD __stdcall SetOverlayPosition32
(
#ifdef WINNT_VER40
  PDD_SETOVERLAYPOSITIONDATA      pInput
#else
  LPDDHAL_SETOVERLAYPOSITIONDATA  pInput
#endif
)
{
#ifdef WINNT_VER40
  PDEV*   ppdev = (PDEV *)pInput->lpDD->dhpdev;
#else
    LPGLOBALDATA lpDDHALData = GetDDHALContext(pInput->lpDD);
#endif

  DD_LOG(("SetOverlayPosition32 Entry\r\n"));

#ifndef WINNT_VER40
  DBG_MESSAGE(("SetOverlayPosition32 (lpInput = 0x%08lX)", pInput));
#endif

#ifdef WINNT_VER40
//#pragma message("SetOverlayPosition32: Does NT ddraw call this function while in fullscreen DOS?")
  if (pInput->lpDDSrcSurface->dwReserved1 == 0)
  {
    pInput->ddRVal = DDERR_SURFACEBUSY;
    return DDHAL_DRIVER_HANDLED;
  }
#else
  if (lpDDHALData->bInBackground)
  {
    pInput->ddRVal = DDERR_SURFACEBUSY;
    return DDHAL_DRIVER_HANDLED;
  }
#endif

#ifdef WINNT_VER40
  SYNC_W_3D(ppdev);
  return ppdev->DriverData.OverlayTable.pfnSetOverlayPos(ppdev,pInput);
#else
  SyncWithQueueManager(lpDDHALData);
  return OverlayTable.pfnSetOverlayPos(pInput);
#endif
} /* SetOverlayPosition32 */

/***************************************************************************
*
* FUNCTION:     SetColorKey32
*
* DESCRIPTION:
*
****************************************************************************/

DWORD __stdcall SetColorKey32
(
#ifdef WINNT_VER40
  PDD_SETCOLORKEYDATA     pInput
#else
  LPDDHAL_SETCOLORKEYDATA pInput
#endif
)
{
#ifdef WINNT_VER40
  PDEV*   ppdev = (PDEV *)pInput->lpDD->dhpdev;
#else
  LPGLOBALDATA lpDDHALData = GetDDHALContext( pInput->lpDD);
#endif

  DD_LOG(("SetColorKey32 Entry\r\n"));

#ifndef WINNT_VER40
  DBG_MESSAGE(("SetColorKey32 (lpInput = 0x%08lX)", pInput));
#endif

  // make sure it's a colorkey for an overlay surface
  if ((DDCKEY_DESTOVERLAY | DDCKEY_SRCOVERLAY) & pInput->dwFlags)
  {
#ifdef WINNT_VER40
    SYNC_W_3D(ppdev);
    ppdev->DriverData.OverlayTable.pfnSetColorKey(ppdev,pInput);
#else
    SyncWithQueueManager(lpDDHALData);
    OverlayTable.pfnSetColorKey(pInput);
#endif
  }

  return DDHAL_DRIVER_NOTHANDLED;
} /* SetColorKey32 */

#endif // WINNT_VER35


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\path.c ===
/******************************Module*Header*******************************\
*
* $Workfile:   PATH.C  $
*
* Author: Noel VanHook
* Date: Jan 10, 1996
*
* Purpose: Handle calls to DrvStokeAndFillPath.
*
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/path.c  $
* 
*    Rev 1.7   21 Mar 1997 12:21:42   noelv
* Combined "do_flag" and "sw_test_flag" together into "pointer_switch"
* 
*    Rev 1.6   26 Nov 1996 09:57:52   noelv
* Added DBG prints.
* 
*    Rev 1.5   06 Sep 1996 15:16:36   noelv
* Updated NULL driver for 4.0
* 
*    Rev 1.4   20 Aug 1996 11:04:08   noelv
* Bugfix release from Frido 8-19-96
* 
*    Rev 1.3   17 Aug 1996 14:03:28   frido
* Added PVCS header.
*
\**************************************************************************/

#include "precomp.h"

#define PATH_DBG_LEVEL 1

//
// Since we don't accelerate these, we only hook them for analysys purposes.
// Otherwise, skip the entire file.
//
#if NULL_STROKEFILL || PROFILE_DRIVER

//
// Table to convert ROP2 codes to ROP3 codes.
//

extern BYTE Rop2ToRop3[]; // See paint.c


//
// Driver profiling stuff.
// Gets compiled out in a free bulid.
//
#if PROFILE_DRIVER
    void DumpStrokeAndFillInfo(INT acc, SURFOBJ* pso, MIX mix, BRUSHOBJ* pbo);
#else
    #define DumpStrokeAndFillInfo(acc, pso, mix, pbo)
#endif

/**************************************************************************\
* DrvStrokeAndFillPath								                       *
*									                                       *
* We don't currently accelerate this, but we hook it for analysis.         *
*									                                       *
\**************************************************************************/

BOOL DrvStrokeAndFillPath
(
    SURFOBJ   *pso,
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    XFORMOBJ  *pxo,
    BRUSHOBJ  *pboStroke,
    LINEATTRS *plineattrs,
    BRUSHOBJ  *pboFill,
    POINTL    *pptlBrushOrg,
    MIX        mix,
    FLONG      flOptions
)
{
    #if NULL_STROKEFILL
    {
    	if (pointer_switch)	return TRUE;
    }
    #endif

    DISPDBG((PATH_DBG_LEVEL, "DrvStrokeAndFillPath.\n"));

    //
    // Dump info on what is being punted to a file.
    //
    DumpStrokeAndFillInfo(0, pso, mix, pboStroke);
    
    //
    // Punt it back to GDI.
    //
    return FALSE;
}






// ==================================================================

#if PROFILE_DRIVER
void DumpStrokeAndFillInfo(
	INT	  acc,
	SURFOBJ*  pso,
	MIX 	  mix,
	BRUSHOBJ* pbo)
{

    PPDEV ppdev;

    ppdev = (PPDEV) (pso ? pso->dhpdev : 0); 	    


    //////////////////////////////////////////////////////////////
    // Profiling info to keep track of what GDI is asking us to do.
    //
    if (!ppdev)
    {
	    RIP(("DrvStrokeAndFillPath() with no clipOBJ and no PDEV!\n"));
    }
    else
    {

    	fprintf(ppdev->pfile,"DrvStrokeAndFillPath: ");
	
        fprintf(ppdev->pfile,"(PUNT) ");

	//
	// Check the DEST
	//
	fprintf(ppdev->pfile,"DEST=%s ", (ppdev ? "FB" : "HOST?") );

	//
	// Check the MIX
	//
    	fprintf(ppdev->pfile,"Mix=0x%08X ", mix);

	//
	// Type of pattern.
        //
	if (pbo == NULL)
            fprintf(ppdev->pfile,"BRUSH=NONE ");

	else if (pbo->iSolidColor == 0xFFFFFFFF )
 	{
            fprintf(ppdev->pfile,"BRUSH=PATTERN ");
	}
	else
	{
            fprintf(ppdev->pfile,"BRUSH=SOLID ");
	    fprintf(ppdev->pfile,"COLOR = 0x%08X ",(pbo->iSolidColor));
	}

        fprintf(ppdev->pfile,"\n");
        fflush(ppdev->pfile);
    }
}
#endif // PROFILE_DRIVER

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\mmcore.c ===
/******************************************************************************\
*
* $Workfile:   mmCore.c  $
*
* This file holds the new memory manager core.
*
* Copyright (c) 1997, Cirrus Logic, Inc.
* All Rights Reserved.
*
* $Log:   X:/log/laguna/powermgr/inc/MMCORE.C  $
* 
*    Rev 1.5   Dec 10 1997 13:32:18   frido
* Merged from 1.62 branch.
* 
*    Rev 1.4.1.0   Nov 07 1997 15:04:10   frido
* PDR#10912. Fixed several problems in the mmMove routine that would cause
* lock ups inside WB98.
* 
*    Rev 1.4   Oct 24 1997 10:48:28   frido
* Copied from Windows 95.
* Removed #define MEMMGR SWAT5 line (I need to update this in 95 as well).
* 
*    Rev 1.5   23 Oct 1997 09:23:42   frido
* Removed fixes from RandyS.
* Merged fixed memory manager from 161 tree.
* 
*    Rev 1.3.1.0   15 Oct 1997 12:39:32   frido
* Added roll back functions for when we run out of handles.
* Added support for these roll back functions in mmAddRectToList.
* Changed the mmRemoveRectFromList algorithm.
* Added checks for the Windows 95 core to return NULL in allocations when
* there are no more handles.
* 
*    Rev 1.3   26 Sep 1997 16:18:00   FRIDO
* PDR #10617.  During mmFree the node should be marked NODE_FREE and during
* the first loop of mmAlloc the node status should be turned back to NOD_USED
* 
*    Rev 1.2   14 Aug 1997 16:54:16   FRIDO
* The last changes dropped the score a little, walking through the list
* of used nodes was taken too much time.  So now I have added a new field
* in the DEVMEM structure which holds the current state of the node.
* 
*    Rev 1.1   14 Aug 1997 14:12:12   FRIDO
* Added an extra check inside mmFree to see if the node to be freed indeed
* lives in the used list.
* 
*    Rev 1.0   07 Aug 1997 17:38:04   FRIDO
* Initial revision.
* SWAT: 
* SWAT:    Rev 1.10   06 Aug 1997 21:30:46   frido
* SWAT: Changed mmAllocGrid a little again, it will optimize allocation a bit.
* SWAT: 
* SWAT:    Rev 1.9   05 Aug 1997 23:07:50   frido
* SWAT: Changed grid allocation scheme a little to gain more memory.
* SWAT: 
* SWAT:    Rev 1.8   30 Jul 1997 17:38:00   frido
* SWAT: Added initialization of first rectangle in mmGetLargest.
* SWAT: 
* SWAT:    Rev 1.7   30 Jul 1997 14:26:08   frido
* SWAT: Fixed a counting problem in mmAllocGrid.
* SWAT: 
* SWAT:    Rev 1.6   17 Jun 1997 17:12:32   frido
* SWAT: Combined Windows 95 and NT versions together.
* SWAT: 
* SWAT:    Rev 1.5   16 Jun 1997 23:20:58   frido
* SWAT: Removed byte to pixel conversion.
* SWAT: More Windows 95 / NT combined code.
* SWAT: 
* SWAT:    Rev 1.4   27 May 1997 16:32:12   frido
* SWAT: Changed debug code.
* SWAT: Fixed a bug in non-tile-optimized move code.
* SWAT: 
* SWAT:    Rev 1.3   16 May 1997 23:06:56   frido
* SWAT: Renamed TILE_ALIGNMENT into MEMMGR_TILES.
* SWAT: 
* SWAT:    Rev 1.2   07 May 1997 15:38:10   frido
* SWAT: Fixed alignment code in 24-bpp.
* SWAT: 
* SWAT:    Rev 1.1   06 May 1997 17:57:28   frido
* SWAT: Added tile alignment.
* SWAT: 
* SWAT:    Rev 1.0   03 May 1997 14:34:08   frido
* SWAT: New memory manager core.
*
\******************************************************************************/
#include "PreComp.h"

#ifdef WIN95 /* Windows 95 */
	#pragma warning(disable : 4001 4209 4201)
	#include "SWAT.inc"
	#include "DDMini.h"
	#include "DMM.h"
	#include "mmCore.h"
	#include <string.h>

#else /* Windows NT */
	#include "SWAT.h"
#endif

#if MEMMGR

/******************************************************************************\
* BOOL FAR mmInit(PIIMEMMGR pmm)
*
* PURPOSE:	Initialize the MEMMGR structure.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*
* RETURNS:	TRUE if the initialization was successful, FALSE if there was an
*			error.
\******************************************************************************/
BOOL FAR mmInit(PIIMEMMGR pmm)
{
	// Initialize the list of available nodes.
	pmm->phArray = NULL;
	pmm->pdmHandles = NULL;
	if (!mmAllocArray(pmm))
	{
		return FALSE;
	}

	// Zero the heaps.
	pmm->pdmUsed = NULL;
	pmm->pdmFree = NULL;
	pmm->pdmHeap = NULL;

	return TRUE;
}

/******************************************************************************\
* BOOL mmAllocArray(PIIMEMMGR pmm)
*
* PURPOSE:	Allocdate an array of nodes and initialize the array.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*
* RETURNS:	TRUE if successful, FALSE if there is an error.
\******************************************************************************/
BOOL mmAllocArray(PIIMEMMGR pmm)
{
	PHANDLES	phArray;
	UINT		i;

	#ifdef WIN95 /* Windows 95 */
	{
		static HANDLES mmHandleArray;

		// We only support one static array under Windows 95.
		if (pmm->phArray != NULL)
		{
			return FALSE;
		}

		// Zero the entire array.
		memset(&mmHandleArray, 0, sizeof(mmHandleArray));

		// Store the pointer to the array.
		pmm->phArray = phArray = &mmHandleArray;
	}
	#else /* Windows NT */
	{
		// Allocate a new array.
		#ifdef WINNT_VER40
		{
			phArray = (PHANDLES) MEM_ALLOC(FL_ZERO_MEMORY, sizeof(HANDLES),
					ALLOC_TAG);
		}
		#else
		{
			phArray = (PHANDLES) MEM_ALLOC(LPTR, sizeof(HANDLES));
		}
		#endif

        if (phArray==NULL)  // v-normmi: need check for alloc failure
        {
            return FALSE;
        }

		// Link the allocated array into the list of arrays.
		phArray->pNext = pmm->phArray;
		pmm->phArray = phArray;
	}
	#endif

	// Copy all nodes into the list of free handles.
	for (i = 0; i < MM_NUM_HANDLES; i++)
	{
		mmFreeNode(pmm, &phArray->dmArray[i]);
	}

	// Return success.
	return TRUE;
}

/******************************************************************************\
* PDEVMEM mmAllocNode(PIIMEMMGR pmm)
*
* PURPOSE:	Allocate a node from the list of available nodes.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*
* RETURNS:	A pointer to the node or NULL is there are no more nodes available.
\******************************************************************************/
PDEVMEM mmAllocNode(PIIMEMMGR pmm)
{
	PDEVMEM	pdm;

	// Are we out of handles?
	if (pmm->pdmHandles == NULL)
	{
		// Yep, allocate a new array of handles.
		if (!mmAllocArray(pmm))
		{
			return NULL;
		}
	}

	// Remove one handle fromn the list of handles.
	pdm = pmm->pdmHandles;
	pmm->pdmHandles = pdm->next;
	pdm->mmFlags = NODE_FREE;
	return pdm;
}

/******************************************************************************\
* void mmFreeNode(PIIMEMMGR pmm, PDEVMEM pdm)
*
* PURPOSE:	Insert a node back into the list of available nodes.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			pdm		Pointer to node.
*
* RETURNS:	Nothing.
\******************************************************************************/
void mmFreeNode(PIIMEMMGR pmm, PDEVMEM pdm)
{
	pdm->next = pmm->pdmHandles;
	pmm->pdmHandles = pdm;
	pdm->mmFlags = NODE_AVAILABLE;
}

/******************************************************************************\
* PDEVMEM mmAlloc(PIIMEMMGR pmm, GXPOINT size, GXPOINT align)
*
* PURPOSE:	Allocate a node in off-screen memory which fits the requsted size
*			and alignment.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			size	Requested size.
*			align	Requested alignment.
*
* RETURNS:	A pointer to a memory node which fits the requested size and
*			alignment or NULL is there is not enough memory.
\******************************************************************************/
PDEVMEM mmAlloc(PIIMEMMGR pmm, GXPOINT size, GXPOINT align)
{
	PDEVMEM pdm;
	GXRECT	rect;

	// Walk through all nodes in the free list for an exact match.
	for (pdm = pmm->pdmFree; pdm != NULL; pdm = pdm->next)
	{
		if (   (pdm->cbSize.pt.x == size.pt.x)
			&& (pdm->cbSize.pt.y == size.pt.y)
			&& (pdm->cbAlign.pt.x == align.pt.x)
			&& (pdm->cbAlign.pt.y == align.pt.y)
		)
		{
			mmTRACE(("mmAlloc: %08X pos=%u,%u size=%u,%u align=%u,%u\r\n", pdm,
					pdm->cbAddr.pt.x, pdm->cbAddr.pt.y, size.pt.x, size.pt.y,
					align.pt.x, align.pt.y));

			// We have a match, move the node to the used list.
			mmRemoveFromList(&pmm->pdmFree, pdm);
			mmInsertInList(&pmm->pdmUsed, pdm);
			pdm->mmFlags = NODE_USED;
			return pdm;
		}
	}

	// Pack the list of free nodes.
	mmPack(pmm);

	#ifdef WIN95
	{
		// We need a free handle for Windows 95.
		if (pmm->pdmHandles == NULL)
		{
			return(NULL);
		}
	}
	#endif

	// Find a rectangle in the heap.
	if (!mmFindRect(pmm, &rect, size, align))
	{
		return NULL;
	}

	// Remove the rectangle from the heap.
	pdm = mmRemoveRectFromList(pmm, &pmm->pdmHeap, &rect, SINGLE_NODE);
	if (pdm != NULL)
	{
		mmTRACE(("mmAlloc: %08X pos=%u,%u size=%u,%u align=%u,%u\r\n", pdm,
				pdm->cbAddr.pt.x, pdm->cbAddr.pt.y, size.pt.x, size.pt.y,
				align.pt.x, align.pt.y));

		// Insert the node into the used list.
		mmInsertInList(&pmm->pdmUsed, pdm);
		mmDebugList(pmm->pdmUsed, FALSE);

		// Store alignment.
		pdm->cbAlign = align;
		pdm->mmFlags = NODE_USED;
	}

	// Return the node.
	return pdm;
}

/******************************************************************************\
* PDEVMEM mmAllocGrid(PIIMEMMGR pmm, GXPOINT size, GXPOINT align, UINT count)
*
* PURPOSE:	Allocate a node which holds a specific number of cells.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			size	The size of a single cell.
*			align	Requested alignment.
*			count	The number of cells.
*
* RETURNS:	A pointer to a memory node which fits the requested size and
*			alignment or NULL is there is not enough memory.
\******************************************************************************/
PDEVMEM mmAllocGrid(PIIMEMMGR pmm, GXPOINT size, GXPOINT align, UINT count)
{
	PDEVMEM	pdm;
	ULONG	scrap, scrapBest, area;
	GXRECT	rect, rectBest;
	UINT	countX, countY;

	// Pack the list of free nodes.
	mmPack(pmm);

	#ifdef WIN95
	{
		// We need a free handle for Windows 95.
		if (pmm->pdmHandles == NULL)
		{
			return(NULL);
		}
	}
	#endif

	// Calculate the requested area.
	area = MUL(size.pt.x * size.pt.y, count);
	scrapBest = (ULONG) -1;

	for (pdm = pmm->pdmHeap; pdm != NULL; pdm = pdm->next)
	{
		if (pdm->cbSize.pt.x >= size.pt.x)
		{
			// Get the largest rectangle for this node.
			rect.left = pdm->cbAddr.pt.x;
			rect.top = pdm->cbAddr.pt.y;
			rect.right = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
			rect.bottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;
			if (mmGetLargest(pdm, &rect, align) >= area)
			{
				// Calculate the dimension of the grid.
				countX = min((rect.right - rect.left) / size.pt.x, count);
				if (countX == 0)
				{
					continue;
				}
				countY = (count + countX - 1) / countX;
				if (   (countY == 0)
					|| (rect.top + countY * size.pt.y > rect.bottom)
					)
				{
					continue;
				}

				// Calculate the amount of scrap.
				scrap = MUL(countX * countY - count, size.pt.x * size.pt.y)
													// remaining cells
					  + MUL(pdm->cbSize.pt.x - countX * size.pt.x,
					  		countY * size.pt.y)		// space at right
					  + MUL(rect.top - pdm->cbAddr.pt.y, pdm->cbSize.pt.x);
					  								// space at top

				if (   (scrap < scrapBest)
					|| (scrap == scrapBest && rect.area < rectBest.area)
				)
				{
					// Use this rectangle.
					scrapBest = scrap;
					rectBest.left = rect.left;
					rectBest.top = rect.top;
					rectBest.right = rect.left + countX * size.pt.x;
					rectBest.bottom = rect.top + countY * size.pt.y;
					rectBest.area = rect.area;

					if (   (pdm->next == NULL)
						&& (rectBest.right - rectBest.left == pmm->mmHeapWidth)
					)
					{
						rectBest.top = rect.bottom - countY * size.pt.y;
						rectBest.top -= rectBest.top % align.pt.y;
						rectBest.bottom = rectBest.top + countY * size.pt.y;
					}
				}
			}
		}
	}

	if (scrapBest == (ULONG) -1)
	{
		// We don't have any rectangle that fits.
		return NULL;
	}

	// Remove the rectangle from the heap.
	pdm = mmRemoveRectFromList(pmm, &pmm->pdmHeap, &rectBest, SINGLE_NODE);
	if (pdm != NULL)
	{
		mmTRACE(("mmAllocGrid: %08X pos=%u,%u size=%u,%u align=%u,%u "
				"count=%u\r\n", pdm, pdm->cbAddr.pt.x, pdm->cbAddr.pt.y,
				size.pt.x, size.pt.y, align.pt.x, align.pt.y, count));

		// Insert the node into the used list.
		mmInsertInList(&pmm->pdmUsed, pdm);

		// Store alignment.
		pdm->cbAlign = align;
		pdm->mmFlags = NODE_USED;
	}

	// Return the node.
	return pdm;
}

/******************************************************************************\
* PDEVMEM mmAllocLargest(PIIMEMMGR pmm, GXPOINT align)
*
* PURPOSE:	Allocate the largest node in off-screen memory which fits the
*			requsted alignment.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			align	Requested alignment.
*
* RETURNS:	A pointer to a memory node which fits the requested alignment or
*			NULL is there is not enough memory.
\******************************************************************************/
PDEVMEM mmAllocLargest(PIIMEMMGR pmm, GXPOINT align)
{
	PDEVMEM pdm;
	GXRECT	rect, rectFind;

	// Pack the list of free nodes.
	mmPack(pmm);

	#ifdef WIN95
	{
		// We need a free handle for Windows 95.
		if (pmm->pdmHandles == NULL)
		{
			return(NULL);
		}
	}
	#endif

	// Zero the largest area.
	rect.area = 0;

	// Walk through all nodes in the heap.
	for (pdm = pmm->pdmHeap; pdm != NULL; pdm = pdm->next)
	{
		rectFind.left = pdm->cbAddr.pt.x;
		rectFind.top = pdm->cbAddr.pt.y;
		rectFind.right = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
		rectFind.bottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;
		if (mmGetLargest(pdm, &rectFind, align) > rect.area)
		{
			// Use the larger rectangle.
			rect = rectFind;
		}
	}

	// Test if we have a valid rectangle.
	if (rect.area == 0)
	{
		return NULL;
	}

	// Remove the rectangle from the heap.
	pdm = mmRemoveRectFromList(pmm, &pmm->pdmHeap, &rect, SINGLE_NODE);
	if (pdm != NULL)
	{
		mmTRACE(("mmAllocLargest: %08X pos=%u,%u size=%u,%u align=%u,%u\r\n",
				pdm, pdm->cbAddr.pt.x, pdm->cbAddr.pt.y, pdm->cbSize.pt.x,
				pdm->cbSize.pt.y, align.pt.x, align.pt.y));

		// Insert the node into the used list.
		mmInsertInList(&pmm->pdmUsed, pdm);

		// Store alignment.
		pdm->cbAlign = align;
		pdm->mmFlags = NODE_USED;
	}

	// Return the node.
	return pdm;
}

/******************************************************************************\
* void mmFree(PIIMEMMGR pmm, PDEVMEM pdm)
*
* PURPOSE:	Free an offscreen memory node.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			pdm		Pointer to the node.
*
* RETURNS:	Nothing.
\******************************************************************************/
void mmFree(PIIMEMMGR pmm, PDEVMEM pdm)
{
	// The node must not be NULL and must be in use.
	if (pdm == NULL || pdm->mmFlags != NODE_USED)
	{
		return;
	}

	mmTRACE(("mmFree: %08X\r\n", pdm));

	// Remove the node from the used list.
	mmRemoveFromList(&pmm->pdmUsed, pdm);

	// Insert the node into the free list.
	mmInsertInList(&pmm->pdmFree, pdm);
	pdm->mmFlags = NODE_FREE;
}

/******************************************************************************\
* void mmPack(PIIMEMMGR pmm)
*
* PURPOSE:	Insert all free nodes into am off-screen memory heap.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*
* RETURNS:	Nothing.
\******************************************************************************/
void mmPack(PIIMEMMGR pmm)
{
	PDEVMEM pdm, pdmNext;
	GXRECT	rect;

	if (pmm->pdmFree == NULL)
	{
		// The free list is empty.
		return;
	}

	#if DEBUG_HEAP
	{
		if (pmm->mmDebugHeaps)
		{
			mmDebug("\nmmPack:\r\n");
			mmDumpList(pmm->pdmFree, "Free:\r\n");
			mmDumpList(pmm->pdmHeap, "Before:\r\n");
		}
	}
	#endif

	// Walk through all nodes in the free list.
	for (pdm = pmm->pdmFree; pdm != NULL; pdm = pdmNext)
	{
		// Store pointer to next node.
		pdmNext = pdm->next;

		// Add the node to the heap.
		rect.left = pdm->cbAddr.pt.x;
		rect.top = pdm->cbAddr.pt.y;
		rect.right = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
		rect.bottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;
		if (mmAddRectToList(pmm, &pmm->pdmHeap, &rect, FALSE))
		{
			// Remove the node from the free list.
			mmRemoveFromList(&pmm->pdmFree, pdm);
			mmFreeNode(pmm, pdm);
		}
		mmDebugList(pmm->pdmHeap, TRUE);
	}

	// Combine all nodes equal in size.
	mmCombine(pmm, pmm->pdmHeap);

	#if DEBUG_HEAP
	{
		if (!mmDebugList(pmm->pdmHeap, TRUE) && pmm->mmDebugHeaps)
		{
			mmDumpList(pmm->pdmHeap, "Free:\r\n");
			mmDumpList(pmm->pdmHeap, "After:\r\n");
		}
	}
	#endif
}

/******************************************************************************\
* PDEVMEM mmMove(PIIMEMMGR pmm, GXPOINT size, GXPOINT align, FNMMCOPY fnCopy)
*
* PURPOSE:	Move other nodes out of the way to make room for the requested node.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			size	Requested size.
*			align	Requested alignment.
*			fcCopy	Pointer to callback function to move a node.
*
* RETURNS:	A pointer to a memory node which fits the requested size and
*			alignment or NULL is there is not enough memory.
\******************************************************************************/
PDEVMEM mmMove(PIIMEMMGR pmm, GXPOINT size, GXPOINT align, FNMMCOPY fnCopy)
{
	PDEVMEM	pdm, pdmList, pdmNext, pdmNew;
	GXRECT	rect, rectFind;
	BOOL	fHostified = FALSE;

	// If we don't have a copy routine, return NULL.
	if (fnCopy == NULL)
	{
		return NULL;
	}

	// Pack all free nodes.
	mmPack(pmm);

	#ifdef WIN95
	{
		// We need a free handle for Windows 95.
		if (pmm->pdmHandles == NULL)
		{
			return(NULL);
		}
	}
	#endif

	// Zero the largest area.
	rect.area = 0;

	// Walk through all nodes in the heap.
	for (pdm = pmm->pdmHeap; pdm != NULL; pdm = pdm->next)
	{
		rectFind.left = pdm->cbAddr.pt.x;
		rectFind.top = pdm->cbAddr.pt.y;
		rectFind.right = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
		rectFind.bottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;
		if (mmGetLargest(pdm, &rectFind, align) > rect.area)
		{
			// Use the larger rectangle.
			rect = rectFind;
		}
	}

	// If rectangle is too small on all sides, reject the move.
	if (   (rect.right - rect.left < size.pt.x)
		&& (rect.bottom - rect.top < size.pt.y)
	)
	{
		return NULL;
	}

	// Extent the largest rectangle to accomodate the requested size.
	if (rect.right - rect.left >= size.pt.x)
	{
		#if TILE_ALIGNMENT
		{
			rect.left = mmAlignX(pmm, rect.right - size.pt.x, size.pt.x,
					align.pt.x, TRUE);
		}
		#else
		{
			rect.left = rect.right - size.pt.x;
			rect.left -= rect.left % align.pt.x;
		}
		#endif
		rect.right = rect.left + size.pt.x;
	}
	else
	{
		rect.right = rect.left + size.pt.x;
		if (rect.right > pmm->mmHeapWidth)
		{
			#if TILE_ALIGNMENT
			{
				rect.left = mmAlignX(pmm, pmm->mmHeapWidth - size.pt.x,
						size.pt.x, align.pt.x, TRUE);
			}
			#else
			{
				rect.left = pmm->mmHeapWidth - size.pt.x;
				rect.left -= rect.left % align.pt.x;
			}
			#endif
			rect.right = rect.left + size.pt.x;
		}
	}

	if (rect.bottom - rect.top >= size.pt.y)
	{
		rect.top = rect.bottom - size.pt.y;
		rect.top -= rect.top % align.pt.y;
		rect.bottom = rect.top + size.pt.y;
	}
	else
	{
		if (rect.top < size.pt.y - (rect.bottom - rect.top))
		{
			// Not enough room on top to extent.
			return NULL;
		}
		rect.top = rect.bottom - size.pt.y;
		rect.top -= rect.top % align.pt.y;
		rect.bottom = rect.top + size.pt.y;
	}

	// First allocate as much free space as possible.
	pdmList = mmRemoveRectFromList(pmm, &pmm->pdmHeap, &rect, MULTIPLE_NODES);
	if (pdmList == NULL)
	{
		return(NULL);
	}

	// Walk the list of used nodes to find overlapping nodes.
	for (pdm = pmm->pdmUsed; pdm != NULL; pdm = pdmNext)
	{
		pdmNext = pdm->next;

		// Does the node overlap?
		if (   (pdm->cbAddr.pt.x < rect.right)
			&& (pdm->cbAddr.pt.y < rect.bottom)
			&& (pdm->cbAddr.pt.x + pdm->cbSize.pt.x > rect.left)
			&& (pdm->cbAddr.pt.y + pdm->cbSize.pt.y > rect.top)
		)
		{
			// Can this node be moved?
			if (!MM_MOVEABLE(pdm))
			{
				break;
			}

			// Allocate a new position for this node.
			pdmNew = mmAlloc(pmm, pdm->cbSize, pdm->cbAlign);
			if (pdmNew == NULL)
			{
				if (   !MM_HOSTIFYABLE(pdm)
					|| (MUL(pdm->cbSize.pt.x, pdm->cbSize.pt.y) > rect.area)
				)
				{
					break;
				}

				mmTRACE(("mmHostified: %08X\r\n", pdm));

				// Hostify the node.
				MM_HOSTIFY(pdm);
				fHostified = TRUE;
			}
			else
			{
				mmTRACE(("mmCopied: %08X to %08X pos=%u,%u\r\n", pdm, pdmNew,
						pdmNew->cbAddr.pt.x, pdmNew->cbAddr.pt.y));

				// Move the node.
				fnCopy(pdmNew, pdm);
			}

			// Free the old node.
			mmFree(pmm, pdm);

			// Add the rectangle to the list of allocated nodes.
			pdmNew = mmRemoveRectFromList(pmm, &pmm->pdmHeap, &rect,
					MULTIPLE_NODES);
			for (pdm = pdmNew; pdm != NULL; pdm = pdmNew)
			{
				pdmNew = pdm->next;
				rectFind.left = pdm->cbAddr.pt.x;
				rectFind.top = pdm->cbAddr.pt.y;
				rectFind.right = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
				rectFind.bottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;
				if (mmAddRectToList(pmm, &pdmList, &rectFind, FALSE))
				{
					// Added, free the node.
					mmFreeNode(pmm, pdm);
				}
				else
				{
					// Not added, add to free list.
					mmInsertInList(&pmm->pdmFree, pdm);
				}
			}
		}
	}
	if (pdmList == NULL)
	{
		return(NULL);
	}

	// Combine all equal sized nodes together.
	mmCombine(pmm, pdmList);
	
	#if DEBUG_HEAP
	{
		if (pmm->mmDebugHeaps)
		{
			mmDumpList(pdmList, "\nmmMove:\r\n");
		}
	}
	#endif

	// If we still have a list of nodes, there must be not enough room.
	if (   (pdmList->next != NULL)
		|| (pdmList->cbSize.pt.x < size.pt.x)
		|| (pdmList->cbSize.pt.y < size.pt.y)
		|| (fHostified)
	)
	{
		// Move all allocated nodes to the free list.
		for (pdm = pdmList; pdm != NULL; pdm = pdmNext)
		{
			pdmNext = pdm->next;
			mmRemoveFromList(&pdmList, pdm);
			mmInsertInList(&pmm->pdmFree, pdm);
		}
	}
	else
	{
		mmTRACE(("mmMove: %08X pos=%u,%u size=%u,%u align=%u,%u\r\n", pdm,
				pdm->cbAddr.pt.x, pdm->cbAddr.pt.y, size.pt.x, size.pt.y,
				align.pt.x, align.pt.y));

		// Insert the node into the used list.
		mmInsertInList(&pmm->pdmUsed, pdmList);

		// Store alignment.
		pdmList->cbAlign = align;
		pdmList->mmFlags = NODE_USED;
	}

	return pdmList;
}

/******************************************************************************\
* void mmInsertInList(PDEVMEM FAR* pdmRoot, PDEVMEM pdm)
*
* PURPOSE:	Insert a node into a list.
*
* ON ENTRY:	pdmRoot	Address of the pointer to the root of the list.
*			pdm		Pointer to the node.
*
* RETURNS:	Nothing.
\******************************************************************************/
void mmInsertInList(PDEVMEM FAR* pdmRoot, PDEVMEM pdm)
{
	pdm->next = *pdmRoot;
	*pdmRoot = pdm;

	pdm->prev = NULL;
	if (pdm->next != NULL)
	{
		pdm->next->prev = pdm;
	}
}

/******************************************************************************\
* void mmRemoveFromList(PDEVMEM FAR* pdmRoot, PDEVMEM pdm)
*
* PURPOSE:	Remove a node from a list.
*
* ON ENTRY:	pdmRoot	Address of the pointer to the root of the list.
*			pdm		Pointer to the node.
*
* RETURNS:	Nothing.
\******************************************************************************/
void mmRemoveFromList(PDEVMEM FAR* pdmRoot, PDEVMEM pdm)
{
	if (pdm->prev == NULL)
	{
		*pdmRoot = pdm->next;
	}
	else
	{
		pdm->prev->next = pdm->next;
	}

	if (pdm->next != NULL)
	{
		pdm->next->prev = pdm->prev;
	}
}

/******************************************************************************\
* BOOL FAR far_mmAddRectToList(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot,
*							   LPGXRECT lpRect)
*
* PURPOSE:	Add a rectangle to an off-screen memory list.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			pdmRoot	Address of the pointer to the root of the list.
*			lpRect	Pointer to rectangle to add to te list.
*
* RETURNS:	TRUE if the rectangle has been completely added to the list or FALSE
*			if lpRect holds the coordinates of the rectangle which could not be
*			added to the list.
\******************************************************************************/
BOOL FAR far_mmAddRectToList(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot,
							 LPGXRECT lpRect)
{
	return mmAddRectToList(pmm, pdmRoot, lpRect, FALSE);
}

/******************************************************************************\
* void mmRollBackAdd(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot, LPGXRECT lpRect,
*					 LPGXRECT rectList, UINT nCount)
*
* PURPOSE:	Roll back the added rectangles.
*
* ON ENTRY:	pmm			Pointer to MEMMGR structure.
*			pdmRoot		Address of the pointer to the root of the list.
*			lpRect		Pointer to original rectangle to add to the list.
*			rectList	List of rectangles to roll back.
*			nCount		Number of rectangles in the list to roll back.
*
* RETURNS:	Nothing.
\******************************************************************************/
void mmRollBackAdd(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot, LPGXRECT lpRect,
				   LPGXRECT rectList, UINT nCount)
{
	GXRECT rect;
	
	while (nCount-- > 0)
	{
		if (   rectList[nCount].left >= rectList[nCount].right
			|| rectList[nCount].top >= rectList[nCount].bottom )
		{
			continue;
		}
		
		if (rectList[nCount].top < lpRect->top)
		{
			rect.left = rectList[nCount].left;
			rect.top = rectList[nCount].top;
			rect.right =  rectList[nCount].right;
			rect.bottom = lpRect->top;
			rectList[nCount].top = lpRect->top;
			if (!mmAddRectToList(pmm, pdmRoot, &rect, TRUE))
			{
				mmRollBackAdd(pmm, pdmRoot, lpRect, rectList, ++nCount);
				if (!mmAddRectToList(pmm, pdmRoot, &rect, TRUE))
				{
					mmASSERT(1, ("mmRollBackAdd failed\r\n"));
				}
				continue;
			}
			
			if (rectList[nCount].top >= rectList[nCount].bottom)
			{
				continue;
			}
		}
		
		if (rectList[nCount].bottom > lpRect->bottom)
		{
			rect.left = rectList[nCount].left;
			rect.top = lpRect->bottom;
			rect.right =  rectList[nCount].right;
			rect.bottom = rectList[nCount].bottom;
			rectList[nCount].bottom = lpRect->bottom;
			if (!mmAddRectToList(pmm, pdmRoot, &rect, TRUE))
			{
				mmRollBackAdd(pmm, pdmRoot, lpRect, rectList, ++nCount);
				if (!mmAddRectToList(pmm, pdmRoot, &rect, TRUE))
				{
					mmASSERT(1, ("mmRollBackAdd failed\r\n"));
				}
				continue;
			}
			
			if (rectList[nCount].top >= rectList[nCount].bottom)
			{
				continue;
			}
		}
		
		if (rectList[nCount].left < lpRect->left)
		{
			rect.left = rectList[nCount].left;
			rect.top = rectList[nCount].top;
			rect.right = lpRect->left;
			rect.bottom = rectList[nCount].bottom;
			rectList[nCount].left = lpRect->left;
			if (!mmAddRectToList(pmm, pdmRoot, &rect, TRUE))
			{
				mmRollBackAdd(pmm, pdmRoot, lpRect, rectList, ++nCount);
				if (!mmAddRectToList(pmm, pdmRoot, &rect, TRUE))
				{
					mmASSERT(1, ("mmRollBackAdd failed\r\n"));
				}
				continue;
			}
			
			if (rectList[nCount].left >= rectList[nCount].right)
			{
				continue;
			}
		}
		
		if (rectList[nCount].right > lpRect->right)
		{
			rect.left = lpRect->right;
			rect.top = rectList[nCount].top;
			rect.right = rectList[nCount].right;
			rect.bottom = rectList[nCount].bottom;
			rectList[nCount].right = lpRect->right;
			if (!mmAddRectToList(pmm, pdmRoot, &rect, TRUE))
			{
				mmRollBackAdd(pmm, pdmRoot, lpRect, rectList, ++nCount);
				if (!mmAddRectToList(pmm, pdmRoot, &rect, TRUE))
				{
					mmASSERT(1, ("mmRollBackAdd failed\r\n"));
				}
				continue;
			}
			
			if (rectList[nCount].left >= rectList[nCount].right)
			{
				continue;
			}
		}
	}
}

/******************************************************************************\
* BOOL mmAddRectToList(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot, LPGXRECT lpRect,
*					   BOOL fRollBack)
*
* PURPOSE:	Add a rectangle to an off-screen memory list.
*
* ON ENTRY:	pmm			Pointer to MEMMGR structure.
*			pdmRoot		Address of the pointer to the root of the list.
*			lpRect		Pointer to rectangle to add to te list.
*			fRollBack	True if this called from a roll back routine.
*
* RETURNS:	TRUE if the rectangle has been completely added to the list or FALSE
*			if lpRect holds the coordinates of the rectangle which could not be
*			added to the list.
\******************************************************************************/
BOOL mmAddRectToList(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot, LPGXRECT lpRect,
					 BOOL fRollBack)
{
	PDEVMEM	pdm, pdmNext, pdmNew;
	int		n = 0;
	GXRECT	rectList[10];
	UINT	left, top, right, bottom;
	UINT	pdmLeft, pdmTop, pdmRight, pdmBottom;
	UINT	nextLeft = 0, nextTop = 0, nextRight = 0, nextBottom = 0;

	#define ADDRECT(l, t, r, b)		\
	{								\
		rectList[n].left = l;		\
		rectList[n].top = t;		\
		rectList[n].right = r;		\
		rectList[n].bottom = b;		\
		n++;						\
	}

	// Test if there is no list yet.
	if (*pdmRoot == NULL)
	{
		// Allocate a new node.
		pdm = mmAllocNode(pmm);
		if (pdm == NULL)
		{
			return FALSE;
		}

		// Insert the node into the list.
		mmInsertInList(pdmRoot, pdm);

		// Set the node coordinates.
		pdm->cbAddr.pt.x = lpRect->left;
		pdm->cbAddr.pt.y = lpRect->top;
		pdm->cbSize.pt.x = lpRect->right - lpRect->left;
		pdm->cbSize.pt.y = lpRect->bottom - lpRect->top;
		return TRUE;
	}

	// Copy the rectangle coordinates.
	rectList[n++] = *lpRect;

	// Loop until all rectangles done.
	while (n-- > 0)
	{
		// Get coordinates of rectangle.
		left = rectList[n].left;
		top = rectList[n].top;
		right = rectList[n].right;
		bottom = rectList[n].bottom;

		// Walk the heap.
		for (pdm = *pdmRoot; pdm != NULL; pdm = pdm->next)
		{
			// Get coordinates of current node.
			pdmLeft = pdm->cbAddr.pt.x;
			pdmTop = pdm->cbAddr.pt.y;
			pdmRight = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
			pdmBottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;

			if (pdmTop < top && pdmBottom > top && pdmRight == left)
			{
				if (pdmBottom < bottom)
				{
					// Ŀ            Ŀ
					//                   pdm 
					//  pdm Ŀ      Ŀ
					//            >     rct    
					// Ĵ rct       Ĵ
					//                         add 
					//                   
					mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
					ADDRECT(left, pdmBottom, right, bottom);
					pdm->cbSize.pt.y = top - pdmTop;
					left = pdmLeft;
					bottom = pdmBottom;
				}
				else if (pdmBottom > bottom)
				{
					// Ŀ            Ŀ
					//                   pdm 
					//      Ŀ      Ŀ
					//  pdm  rct  >     rct    
					//            
					//                   add 
					//             
					mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
					ADDRECT(pdmLeft, bottom, pdmRight, pdmBottom);
					pdm->cbSize.pt.y = top - pdmTop;
					left = pdmLeft;
				}
				else // if (pdmBottom == bottom)
				{
					// Ŀ            Ŀ
					//                   pdm 
					//  pdm Ŀ > Ŀ
					//       rct           rct    
					//       
					pdm->cbSize.pt.y = top - pdmTop;
					left = pdmLeft;
				}
			}

			else if (pdmTop < top && pdmBottom > top && pdmLeft == right)
			{
				if (pdmBottom < bottom)
				{
					//       Ŀ            Ŀ
					//                         pdm 
					// Ĵ pdm       Ĵ
					//            >     rct    
					//  rct       
					//                   add 
					//             
					mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
					ADDRECT(left, pdmBottom, right, bottom);
					pdm->cbSize.pt.y = top - pdmTop;
					right = pdmRight;
					bottom = pdmBottom;
				}
				else if (pdmBottom > bottom)
				{
					//       Ŀ            Ŀ
					//                         pdm 
					// Ĵ           Ĵ
					//  rct  pdm  >     rct    
					// Ĵ           Ĵ
					//                         add 
					//                   
					mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
					ADDRECT(pdmLeft, bottom, pdmRight, pdmBottom);
					pdm->cbSize.pt.y = top - pdmTop;
					right = pdmRight;
				}
				else // if (pdmBottom == bottom)
				{
					//       Ŀ            Ŀ
					//                         pdm 
					// Ĵ pdm  > Ĵ
					//  rct                rct    
					//       
					pdm->cbSize.pt.y = top - pdmTop;
					right = pdmRight;
				}
			}

			else if (pdmTop == top && pdmRight == left)
			{
				// Find the next rectangle at the right side.
				for (pdmNext = pdm->next; pdmNext != NULL;
					 pdmNext = pdmNext->next
				)
				{
					nextLeft = pdmNext->cbAddr.pt.x;
					nextTop = pdmNext->cbAddr.pt.y;
					nextRight = pdmNext->cbAddr.pt.x + pdmNext->cbSize.pt.x;
					nextBottom = pdmNext->cbAddr.pt.y + pdmNext->cbSize.pt.y;

					if (nextLeft == right && nextTop < bottom)
					{
						break;
					}
					if (nextTop >= bottom)
					{
						pdmNext = NULL;
						break;
					}
				}

				if (pdmNext == NULL || nextTop >= pdmBottom)
				{
					if (pdmBottom < bottom)
					{
						// Ŀ      Ŀ
						//  pdm                pdm    
						// Ĵ rct  > Ĵ
						//                         rct 
						//                   
						pdm->cbSize.pt.x = right - pdmLeft;
						top = pdmBottom;
					}
					else if (pdmBottom > bottom)
					{
						// Ŀ      Ŀ
						//       rct           pdm    
						//  pdm  > 
						//                   rct 
						//             
						pdm->cbSize.pt.x = right - pdmLeft;
						pdm->cbSize.pt.y = bottom - top;
						left = pdmLeft;
						top = bottom;
						right = pdmRight;
						bottom = pdmBottom;
					}
					else // if (pdmBottom == bottom)
					{
						// Ŀ	  Ŀ
						//  pdm  rct  >     pdm    
						//       
						pdm->cbSize.pt.x = right - pdmLeft;
						break;
					}
				}

				else if (nextTop == top)
				{
					if (pdmBottom < bottom)
					{
						if (nextBottom < pdmBottom)
						{
							// Ŀ      Ŀ
							//            nxt              pdm       
							//  pdm            
							//       rct        >     rct    
							// Ĵ                 Ĵ
							//                               add 
							//                         
							mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
							ADDRECT(left, pdmBottom, right, bottom);
							pdm->cbSize.pt.x = nextRight - pdmLeft;
							pdm->cbSize.pt.y = pdmNext->cbSize.pt.y;
							left = pdmLeft;
							top = nextBottom;
							bottom = pdmBottom;
						}
						else if (nextBottom > pdmBottom)
						{
							if (nextBottom < bottom)
							{
								// Ŀ      Ŀ
								//  pdm                        pdm       
								// Ĵ      nxt       Ĵ
								//        rct       >           rct    
								//                        
								//                               add 
								//                         
								mmASSERT(n == 10,
										("Out of rectangle heap!\r\n"));
								ADDRECT(left, nextBottom, right, bottom);
								pdm->cbSize.pt.x = nextRight - pdmLeft;
								top = pdmBottom;
								right = nextRight;
								bottom = nextBottom;
							}
							else if (nextBottom > bottom)
							{
								// Ŀ      Ŀ
								//  pdm                        pdm       
								// Ĵ rct            Ĵ
								//             nxt  >           rct    
								//       Ĵ                 Ĵ
								//                                     add 
								//                               
								mmASSERT(n == 10,
										("Out of rectangle heap!\r\n"));
								ADDRECT(right, bottom, nextRight, nextBottom);
								pdm->cbSize.pt.x = nextRight - pdmLeft;
								top = pdmBottom;
								right = nextRight;
							}
							else // if (nextBottom == bottom)
							{
								// Ŀ      Ŀ
								//  pdm                        pdm       
								// Ĵ rct  nxt  > Ĵ
								//                                 rct    
								//                   
								pdm->cbSize.pt.x = nextRight - pdmLeft;
								top = pdmBottom;
								right = nextRight;
							}
						}
						else // if (nextBottom == pdmBottom)
						{
							// Ŀ      Ŀ
							//  pdm       nxt              pdm       
							// Ĵ rct  > 
							//                               rct 
							//                         
							pdm->cbSize.pt.x = nextRight - pdmLeft;
							top = pdmBottom;
						}
					}
					else if (pdmBottom > bottom)
					{
						if (nextBottom < bottom)
						{
							// Ŀ      Ŀ
							//            nxt              pdm       
							//       rct       
							//  pdm             >     rct    
							//                  
							//                         add 
							//                   
							mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
							ADDRECT(pdmLeft, bottom, pdmRight, pdmBottom);
							pdm->cbSize.pt.x = nextRight - pdmLeft;
							pdm->cbSize.pt.y = pdmNext->cbSize.pt.y;
							left = pdmLeft;
							top = nextBottom;
						}
						else if (nextBottom > bottom)
						{
							// Ŀ      Ŀ
							//       rct                   pdm       
							//  pdm Ĵ nxt  > Ĵ
							//                       rct       add 
							//                 
							mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
							ADDRECT(right, bottom, nextRight, nextBottom);
							pdm->cbSize.pt.x = nextRight - pdmLeft;
							pdm->cbSize.pt.y = bottom - top;
							left = pdmLeft;
							top = bottom;
							right = pdmRight;
							bottom = pdmBottom;
						}
						else // if (nextBottom == bottom)
						{
							// Ŀ      Ŀ
							//       rct  nxt              pdm       
							//  pdm  > 
							//                         rct 
							//                   
							pdm->cbSize.pt.x = nextRight - pdmLeft;
							pdm->cbSize.pt.y = pdmNext->cbSize.pt.y;
							left = pdmLeft;
							top = bottom;
							right = pdmRight;
							bottom = pdmBottom;
						}
					}
					else // if (pdmBottom == bottom)
					{
						if (nextBottom < pdmBottom)
						{
							// Ŀ      Ŀ
							//            nxt              pdm       
							//  pdm  rct  > 
							//                           rct    
							//             
							pdm->cbSize.pt.x = nextRight - pdmLeft;
							pdm->cbSize.pt.y = pdmNext->cbSize.pt.y;
							left = pdmLeft;
							top = nextBottom;
						}
						else if (nextBottom > pdmBottom)
						{
							// Ŀ      Ŀ
							//  pdm  rct                   pdm       
							// Ĵ nxt  > Ĵ
							//                                     rct 
							//                               
							pdm->cbSize.pt.x = nextRight - pdmLeft;
							left = right;
							top = bottom;
							right = nextRight;
							bottom = nextBottom;
						}
						else // if (nextBottom == pdmBottom)
						{
							// Ŀ      Ŀ
							//  pdm  rct  nxt  >        pdm       
							//       
							pdm->cbSize.pt.x = nextRight - pdmLeft;
							mmRemoveFromList(pdmRoot, pdmNext);
							mmFreeNode(pmm, pdmNext);
							break;
						}
					}

					// Free the <next> rectangle.
					mmRemoveFromList(pdmRoot, pdmNext);
					mmFreeNode(pmm, pdmNext);
				}

				else // if (nextTop > top)
				{
					if (pdmBottom < bottom)
					{
						// Ŀ            Ŀ
						//                           pdm    
						//  pdm      Ŀ      Ŀ
						//       rct       >     rct         
						// Ĵ      nxt       Ĵ nxt 
						//                              add      
						//       Ĵ                 Ĵ     
						mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
						ADDRECT(left, pdmBottom, right, bottom);
						pdm->cbSize.pt.x = right - pdmLeft;
						pdm->cbSize.pt.y = nextTop - top;
						left = pdmLeft;
						top = nextTop;
						bottom = pdmBottom;
					}
					else if (pdmBottom > bottom)
					{
						// Ŀ            Ŀ
						//                           pdm    
						//       rct Ŀ      Ŀ
						//  pdm       nxt  >     rct     nxt 
						//      Ĵ           Ĵ     
						//                         add 
						//                   
						mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
						ADDRECT(pdmLeft, bottom, pdmRight, pdmBottom);
						pdm->cbSize.pt.x = right - pdmLeft;
						pdm->cbSize.pt.y = nextTop - top;
						left = pdmLeft;
						top = nextTop;
					}
					else // if (pdmBottom == bottom)
					{
						// Ŀ            Ŀ
						//                           pdm    
						//  pdm  rct Ŀ > Ŀ
						//            nxt           rct     nxt 
						// Ĵ           Ĵ     
						pdm->cbSize.pt.x = right - pdmLeft;
						pdm->cbSize.pt.y = nextTop - top;
						left = pdmLeft;
						top = nextTop;
					}
				}
			}

			else if (pdmTop == top && pdmLeft == right)
			{
				// Find the next rectangle at the left side.
				for (pdmNext = pdm->next; pdmNext != NULL;
					 pdmNext = pdmNext->next
				)
				{
					nextLeft = pdmNext->cbAddr.pt.x;
					nextTop = pdmNext->cbAddr.pt.y;
					nextRight = pdmNext->cbAddr.pt.x + pdmNext->cbSize.pt.x;
					nextBottom = pdmNext->cbAddr.pt.y + pdmNext->cbSize.pt.y;

					if (nextRight == left && nextTop < bottom)
					{
						break;
					}
					if (nextTop >= bottom)
					{
						pdmNext = NULL;
						break;
					}
				}

				if (pdmNext == NULL || nextTop >= pdmBottom)
				{
					if (pdmBottom < bottom)
					{
						// Ŀ      Ŀ
						//       pdm           pdm    
						//  rct  > 
						//                   rct 
						//             
						pdm->cbAddr.pt.x = left;
						pdm->cbSize.pt.x = pdmRight - left;
						top = pdmBottom;
					}
					else if	(pdmBottom > bottom)
					{
						// Ŀ      Ŀ
						//  rct                pdm    
						// Ĵ pdm  > Ĵ
						//                         rct 
						//                   
						pdm->cbAddr.pt.x = left;
						pdm->cbSize.pt.x = pdmRight - left;
						pdm->cbSize.pt.y = bottom - top;
						left = pdmLeft;
						top = bottom;
						right = pdmRight;
						bottom = pdmBottom;
					}
					else // if (pdmBottom == bottom)
					{
						// Ŀ      Ŀ
						//  rct  pdm  >     pdm    
						//       
						pdm->cbAddr.pt.x = left;
						pdm->cbSize.pt.x = pdmRight - left;
						break;
					}
				}

				else if (pdmBottom < bottom)
				{
					//       Ŀ            Ŀ
					//                                 pdm    
					// Ĵ      pdm       Ĵ
					//  nxt  rct       >  nxt     rct    
					//                      
					//                               add 
					//                         
					mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
					ADDRECT(left, pdmBottom, right, bottom);
					pdm->cbAddr.pt.x = left;
					pdm->cbSize.pt.x = pdmRight - left;
					pdm->cbSize.pt.y = nextTop - top;
					top = nextTop;
					right = pdmRight;
					bottom = pdmBottom;
				}
				else if (pdmBottom > bottom)
				{
					//       Ŀ            Ŀ
					//                                 pdm    
					// Ĵ rct            Ĵ
					//  nxt       pdm  >  nxt     rct    
					//      Ĵ                Ĵ
					//                                     add 
					//                               
					mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
					ADDRECT(pdmLeft, bottom, pdmRight, pdmBottom);
					pdm->cbAddr.pt.x = left;
					pdm->cbSize.pt.x = pdmRight - left;
					pdm->cbSize.pt.y = nextTop - top;
					top = pdmNext->cbAddr.pt.y;
					right = pdmRight;
				}
				else // if (pdmBottom == bottom)
				{
					//       Ŀ            Ŀ
					//                                 pdm    
					// Ĵ rct  pdm  > Ĵ
					//  nxt                  nxt     rct    
					//                 
					pdm->cbAddr.pt.x = left;
					pdm->cbSize.pt.x = pdmRight - left;
					pdm->cbSize.pt.y = nextTop - top;
					top = nextTop;
					right = pdmRight;
				}
			}
			
			else
			{
				if (pdmBottom == top && pdmLeft == left && pdmRight == right)
				{
					// Find the next rectangle at the left or right side.
					for (pdmNext = pdm->next; pdmNext != NULL; pdmNext =
							pdmNext->next)
					{
						nextLeft = pdmNext->cbAddr.pt.x;
						nextTop = pdmNext->cbAddr.pt.y;
						nextRight = pdmNext->cbAddr.pt.x + pdmNext->cbSize.pt.x;
						nextBottom = pdmNext->cbAddr.pt.y +
								pdmNext->cbSize.pt.y;

						if (   (nextLeft == right || nextRight == left)
							&& (nextTop < bottom) )
						{
							break;
						}
						if (nextTop >= bottom)
						{
							pdmNext = NULL;
							break;
						}
					}
					
					if (pdmNext == NULL)
					{
						// Ŀ      Ŀ
						//  pdm            
						// Ĵ >  pdm 
						//  rct            
						//       
						pdm->cbSize.pt.y += bottom - top;
						break;
					}
				}

				// Are we at the location where we should insert a new
				// rectangle?
				if ((pdmTop == top && pdmLeft > right) || pdmTop > top)
				{
					// Find the next rectangle at the left or right side.
					for (pdmNext = pdm; pdmNext != NULL; pdmNext =
							pdmNext->next)
					{
						nextLeft = pdmNext->cbAddr.pt.x;
						nextTop = pdmNext->cbAddr.pt.y;
						nextRight = pdmNext->cbAddr.pt.x + pdmNext->cbSize.pt.x;
						nextBottom = pdmNext->cbAddr.pt.y +
								pdmNext->cbSize.pt.y;

						if (   (nextTop < bottom)
							&& (nextRight == left || nextLeft == right)
						)
						{
							break;
						}
						else if (  nextTop == bottom
								&& nextLeft == left && nextRight == right )
						{
							break;
						}
						if (pdmNext->cbAddr.pt.y > bottom)
						{
							pdmNext = NULL;
							break;
						}
					}
					
					if (pdmNext != NULL && nextTop == bottom)
					{
						// Ŀ      Ŀ
						//  new            
						// Ĵ >  add 
						//  nxt            
						//       
						mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
						ADDRECT(left, top, right, nextBottom);
						mmRemoveFromList(pdmRoot, pdmNext);
						mmFreeNode(pmm, pdmNext);
						break;
					}

					// Allocate a new node.
					pdmNew = mmAllocNode(pmm);
					if (pdmNew == NULL)
					{
						// We are out of nodes!
						if (!fRollBack)
						{                                     
							mmRemoveRectFromList(pmm, pdmRoot, lpRect,
									NO_NODES);
							mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
							ADDRECT(left, top, right, bottom);
							mmRollBackAdd(pmm, pdmRoot, lpRect, rectList, n);
						}
						return FALSE;
					}

					// Insert node into the list.
					pdmNew->prev = pdm->prev;
					pdmNew->next = pdm;
					pdm->prev = pdmNew;
					if (pdmNew->prev == NULL)
					{
						*pdmRoot = pdmNew;
					}
					else
					{
						pdmNew->prev->next = pdmNew;
					}

					if (pdmNext == NULL)
					{
						// No neighbors at all.
						pdmNew->cbAddr.pt.x = left;
						pdmNew->cbAddr.pt.y = top;
						pdmNew->cbSize.pt.x = right - left;
						pdmNew->cbSize.pt.y = bottom - top;
						break;
					}
					else
					{
						//       Ŀ                  Ŀ
						//                               new 
						// Ĵ rct Ŀ > Ŀ
						//  nxt       nxt        nxt  rct  nxt 
						//      Ĵ                Ĵ     
						pdmNew->cbAddr.pt.x = left;
						pdmNew->cbAddr.pt.y = top;
						pdmNew->cbSize.pt.x = right - left;
						pdmNew->cbSize.pt.y = nextTop - top;
						if (pdm->prev == NULL)
						{
							mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
							ADDRECT(left, nextTop, right, bottom);
							break;
						}
						else
						{
							top = nextTop;
							pdm = pdm->prev;
						}
					}
				}
			}
			
			// Are we at the end of the packed queue?
			if (pdm->next == NULL)
			{
				// Allocate a new node.
				pdmNew = mmAllocNode(pmm);
				if (pdmNew == NULL)
				{
					// We are out of nodes!
					if (!fRollBack)
					{
						mmRemoveRectFromList(pmm, pdmRoot, lpRect, NO_NODES);
						mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
						ADDRECT(left, top, right, bottom);
						mmRollBackAdd(pmm, pdmRoot, lpRect, rectList, n);					
					}
					return FALSE;
				}

				// Append node after current node.
				pdmNew->next = NULL;

				pdmNew->prev = pdm;
				pdm->next = pdmNew;

				// No neighbors.
				pdmNew->cbAddr.pt.x = left;
				pdmNew->cbAddr.pt.y = top;
				pdmNew->cbSize.pt.x = right - left;
				pdmNew->cbSize.pt.y = bottom - top;
				break;
			}
		}
	}

	return TRUE;
}

/******************************************************************************\
* void mmRollBackRemove(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot,
*						PDEVMEM FAR* pdmList)
*
* PURPOSE:	Roll back a list of removed rectangles to a heap.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			pdmRoot	Address of the pointer to the root of the heap.
*			pdmList	Address of the pointer to the root of the list of removed
*					rectangles.
*
* RETURNS:	Nothing.
\******************************************************************************/
void mmRollBackRemove(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot, PDEVMEM FAR* pdmList)
{
	PDEVMEM	pdm, pdmNext;
	GXRECT	rect;

	for (pdm = *pdmList; pdm != NULL; pdm = pdmNext)
	{
		pdmNext = pdm->next;
		
		// Get the node coordinates.
		rect.left = pdm->cbAddr.pt.x;
		rect.top = pdm->cbAddr.pt.y;
		rect.right = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
		rect.bottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;
		
		// Free the node.
		mmRemoveFromList(pdmList, pdm);
		mmFreeNode(pmm, pdm);
		
		// Add the freed node to the list.
		if (!mmAddRectToList(pmm, pdmRoot, &rect, TRUE))
		{
			mmASSERT(1, ("mmRollBackRemove failed\r\n"));
		}
	}
}

/******************************************************************************\
* PDEVMEM mmRemoveRectFromList(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot,
*							   LPGXRECT lpRect, REMOVE_METHOD fMethod)
*
* PURPOSE:	Remove a rectangle from a list.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			pdmRoot	Address of the pointer to the root of the list.
*			lpRect	Pointer to rectangle which holds the rectangle coordinates.
*			fMethod	Method of removing rectangles.
*
* RETURNS:	A pointer to the node which holds the removed rectangle or NULL if
*			there is an error.
\******************************************************************************/
PDEVMEM mmRemoveRectFromList(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot,
							 LPGXRECT lpRect, REMOVE_METHOD fMethod)
{
	PDEVMEM	pdm, pdmNext, pdmList = NULL;
	UINT	left, top, right, bottom;
	GXRECT	rect, newRect;
	BOOL	fRollBack = (fMethod == NO_NODES);

	left = lpRect->left;
	top = lpRect->top;
	right = lpRect->right;
	bottom = lpRect->bottom;

	#if DEBUG_HEAP
	{
		if (pmm->mmDebugHeaps)
		{
			mmDebug("\nmmRemoveRectFromList: %d,%d - %d,%d\r\n", left, top,
					right, bottom);
			mmDumpList(*pdmRoot, "before:\r\n");
		}
	}
	#endif

	for (pdm = *pdmRoot; pdm != NULL; pdm = pdmNext)
	{
		if (pdm->cbAddr.pt.y >= bottom)
		{
			// We have completely removed the specified rectangle.
			break;
		}

		pdmNext = pdm->next;

		// Does this node crosses the rectangle?
		if (   (pdm->cbAddr.pt.y + pdm->cbSize.pt.y > top)
			&& (pdm->cbAddr.pt.x + pdm->cbSize.pt.x > left)
			&& (pdm->cbAddr.pt.x < right)
		)                                                         
		{
			// Yes, get the node coordinates.
			rect.left = pdm->cbAddr.pt.x;
			rect.top = pdm->cbAddr.pt.y;
			rect.right = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
			rect.bottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;

			// Free the node.
			mmRemoveFromList(pdmRoot, pdm);
			mmFreeNode(pmm, pdm);
			
			if (rect.top < top)
			{
				// Split the node at the top.
				newRect.left = rect.left;
				newRect.top = rect.top;
				newRect.right = rect.right;
				newRect.bottom = top;

				// Insert the split rectangle into the list.
				if (!mmAddRectToList(pmm, pdmRoot, &newRect, fRollBack))
				{
					if (fMethod == NO_NODES)
					{
						// We are in a roll back, do other nodes first.
						mmRemoveRectFromList(pmm, pdmRoot, lpRect, NO_NODES);
						if (!mmAddRectToList(pmm, pdmRoot, &newRect, fRollBack))
						{
							mmASSERT(1, ("mmRemoveRectFromList - PANIC!\r\n"));
						}
						pdmNext = *pdmRoot;
					}
					else
					{
						// Roll back and exit.
						if (mmAddRectToList(pmm, pdmRoot, &rect, fRollBack))
						{
							mmRollBackRemove(pmm, pdmRoot, &pdmList);
						}
						else
						{
							mmRollBackRemove(pmm, pdmRoot, &pdmList);
							if (!mmAddRectToList(pmm, pdmRoot, &rect,
									fRollBack))
							{
								mmASSERT(1, ("mmRemoveRectFromList - rollback "
										"failed\r\n"));
							}
						}
						return(NULL);
					}
				}
				
				// Update the rectangle coordinates.
				rect.top = top;
			}

			if (rect.bottom > bottom)
			{
				// Split the node at the bottom.
				newRect.left = rect.left;
				newRect.top = bottom;
				newRect.right = rect.right;
				newRect.bottom = rect.bottom;

				// Insert the split rectangle into the list.
				if (!mmAddRectToList(pmm, pdmRoot, &newRect, fRollBack))
				{
					if (fMethod == NO_NODES)
					{
						// We are in a roll back, do other nodes first.
						mmRemoveRectFromList(pmm, pdmRoot, lpRect, NO_NODES);
						if (!mmAddRectToList(pmm, pdmRoot, &newRect, fRollBack))
						{
							mmASSERT(1, ("mmRemoveRectFromList - PANIC!\r\n"));
						}
						pdmNext = *pdmRoot;
					}
					else
					{
						// Roll back and exit.
						if (mmAddRectToList(pmm, pdmRoot, &rect, fRollBack))
						{
							mmRollBackRemove(pmm, pdmRoot, &pdmList);
						}
						else
						{
							mmRollBackRemove(pmm, pdmRoot, &pdmList);
							if (!mmAddRectToList(pmm, pdmRoot, &rect,
									fRollBack))
							{
								mmASSERT(1, ("mmRemoveRectFromList - rollback "
										"failed\r\n"));
							}
						}
						return(NULL);
					}
				}
				
				// Update the rectangle coordinates.
				rect.bottom = bottom;
			}

			if (rect.left < left)
			{
				// Split the node at the left.
				newRect.left = rect.left;
				newRect.top = rect.top;
				newRect.right = left;
				newRect.bottom = rect.bottom;
				
				// Insert the split rectangle into the list.
				if (!mmAddRectToList(pmm, pdmRoot, &newRect, fRollBack))
				{
					if (fMethod == NO_NODES)
					{
						// We are in a roll back, do other nodes first.
						mmRemoveRectFromList(pmm, pdmRoot, lpRect, NO_NODES);
						if (!mmAddRectToList(pmm, pdmRoot, &newRect, fRollBack))
						{
							mmASSERT(1, ("mmRemoveRectFromList - PANIC!\r\n"));
						}
						pdmNext = *pdmRoot;
					}
					else
					{
						// Roll back and exit.
						if (mmAddRectToList(pmm, pdmRoot, &rect, fRollBack))
						{
							mmRollBackRemove(pmm, pdmRoot, &pdmList);
						}
						else
						{
							mmRollBackRemove(pmm, pdmRoot, &pdmList);
							if (!mmAddRectToList(pmm, pdmRoot, &rect,
									fRollBack))
							{
								mmASSERT(1, ("mmRemoveRectFromList - rollback "
										"failed\r\n"));
							}
						}
						return(NULL);
					}
				}

				// Update the rectangle coordinates.
				rect.left = left;
			}

			if (rect.right > right)
			{
				// Split the node at the right.
				newRect.left = right;
				newRect.top = rect.top;
				newRect.right = rect.right;
				newRect.bottom = rect.bottom;
				
				// Insert the split rectangle into the list.
				if (!mmAddRectToList(pmm, pdmRoot, &newRect, fRollBack))
				{
					if (fMethod == NO_NODES)
					{
						// We are in a roll back, do other nodes first.
						mmRemoveRectFromList(pmm, pdmRoot, lpRect, NO_NODES);
						if (!mmAddRectToList(pmm, pdmRoot, &newRect, fRollBack))
						{
							mmASSERT(1, ("mmRemoveRectFromList - PANIC!\r\n"));
						}
						pdmNext = *pdmRoot;
					}
					else
					{
						// Roll back and exit.
						if (mmAddRectToList(pmm, pdmRoot, &rect, fRollBack))
						{
							mmRollBackRemove(pmm, pdmRoot, &pdmList);
						}
						else
						{
							mmRollBackRemove(pmm, pdmRoot, &pdmList);
							if (!mmAddRectToList(pmm, pdmRoot, &rect,
									fRollBack))
							{
								mmASSERT(1, ("mmRemoveRectFromList - rollback "
										"failed\r\n"));
							}
						}
						return(NULL);
					}
				}
				
				// Update the rectangle coordinates.
				rect.right = right;
			}

			if (fMethod != NO_NODES)
			{
				// Add the freed rectangle to the list.
				if (!mmAddRectToList(pmm, &pdmList, &rect, fRollBack))
				{
						// Roll back and exit.
						if (mmAddRectToList(pmm, pdmRoot, &rect, fRollBack))
						{
							mmRollBackRemove(pmm, pdmRoot, &pdmList);
						}
						else
						{
							mmRollBackRemove(pmm, pdmRoot, &pdmList);
							if (!mmAddRectToList(pmm, pdmRoot, &rect, fRollBack))
							{
								mmASSERT(1, ("mmRemoveRectFromList - rollback "
										"failed\r\n"));
							}
						}
						return(NULL);
				}
			}
		}
	}

	if (pdmList == NULL)
	{
		// No nodes found.
		return(NULL);
	}
	mmDebugList(pdmList, TRUE);

	// Combine all nodes equal in size.
	mmCombine(pmm, pdmList);

	#if DEBUG_HEAP
	{
		if (!mmDebugList(*pdmRoot, TRUE) && pmm->mmDebugHeaps)
		{
			mmDumpList(*pdmRoot, "After:\r\n");
			mmDumpList(pdmList, "Result:\r\n");
		}
	}
	#endif

	// In case we have a list and the method is not MULTIPLE_NODES, roll back.
	if ((fMethod != MULTIPLE_NODES) && (pdmList->next != NULL))
	{
		// Roll back and exit.
		mmRollBackRemove(pmm, pdmRoot, &pdmList);
		return(NULL);
	}

	return(pdmList);
}

/******************************************************************************\
* void mmCombine(PIIMEMMGR pmm, PDEVMEM pdmRoot)
*
* PURPOSE:	Combine all vertical nodes equal in width together in a list.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			pdmRoot	Pointer to root of list.
*
* RETURNS:	Nothing.
\******************************************************************************/
void mmCombine(PIIMEMMGR pmm, PDEVMEM pdmRoot)
{
	PDEVMEM	pdm, pdmNext;

	for (pdm = pdmRoot; pdm != NULL; pdm = pdm->next)
	{
		for (pdmNext = pdm->next; pdmNext != NULL; pdmNext = pdmNext->next)
		{
			// Are we too far under the current node?
			if (pdmNext->cbAddr.pt.y > pdm->cbAddr.pt.y + pdm->cbSize.pt.y)
			{
				break;
			}

			// Do we have a node under the current node of equal width?
			if (   (pdm->cbAddr.pt.x == pdmNext->cbAddr.pt.x)
				&& (pdm->cbSize.pt.x == pdmNext->cbSize.pt.x)
				&& (pdm->cbAddr.pt.y + pdm->cbSize.pt.y == pdmNext->cbAddr.pt.y)
			)
			{
				mmTRACE(("mmCombine: combined nodes %08X and %08X\r\n", pdm,
						pdmNext));
				
				// Merge the nodes together.
				pdm->cbSize.pt.y += pdmNext->cbSize.pt.y;
				mmRemoveFromList(&pdmRoot, pdmNext);
				mmFreeNode(pmm, pdmNext);

				// Rescan for more nodes.
				pdmNext = pdm;
			}
		}
	}
}

/******************************************************************************\
* BOOL mmFindRect(PIIMEMMGR pmm, LPGXRECT lpRect, GXPOINT size, GXPOINT align)
*
* PURPOSE:	Find a rectangle in the off-screen memory heap that fits the
*			requested size.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			lpRect	Pointer to rectangle which holds the return rectangle.
*			size	Size of requested rectangle.
*			align	Alignment of requested rectangle.
*
* RETURNS:	TRUE if lpRect holds a valid rectangle which is large enough to fit
*			the requested size or FALSE if there is not enough free memory in
*			the heap.
\******************************************************************************/
BOOL mmFindRect(PIIMEMMGR pmm, LPGXRECT lpRect, GXPOINT size, GXPOINT align)
{
	GXRECT	rect;
	PDEVMEM	pdm;
	UINT	bestDistance;

	// Initialize the area.
	lpRect->area = (ULONG) -1;

	// Case 1: we have a narrow and tall device bitmap.  We need to allocate it
	// at either the left side or the right side of the heap to leave room in
	// the middle for other device bitmaps.
	if (size.pt.x < size.pt.y)
	{
		// Initialize best distance.
		bestDistance = (UINT) -1;

		// Walk through all nodes.
		for (pdm = pmm->pdmHeap; pdm != NULL; pdm = pdm->next)
		{
			// Try allocating it at the left side of this node.
			rect.left = pdm->cbAddr.pt.x;
			rect.top = pdm->cbAddr.pt.y;
			rect.right = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
			rect.bottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;
			if (   (pdm->cbAddr.pt.x < bestDistance)
				&& (mmGetLeft(pmm, pdm, &rect, size, align) < bestDistance)
			)
			{
				*lpRect = rect;

				bestDistance = rect.left;
				if (bestDistance == 0)
				{
					break;
				}
			}

			// Try allocating it at the right side of this node.
			rect.left = pdm->cbAddr.pt.x;
			rect.top = pdm->cbAddr.pt.y;
			rect.right = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
			rect.bottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;
			if (   (pdm->cbAddr.pt.x + pdm->cbSize.pt.x > pmm->mmHeapWidth -
						bestDistance)
				&& (mmGetRight(pmm, pdm, &rect, size, align) > pmm->mmHeapWidth
						- bestDistance)
			)
			{
				*lpRect = rect;

				bestDistance = pmm->mmHeapWidth - rect.right;
				if (bestDistance == 0)
				{
					break;
				}
			}
		}
	}

	// Cae 2: we have a device bitmap which width equals the heap width.  We
	// will allocate this at the bottom of the heap.
	else if (size.pt.x == pmm->mmHeapWidth)
	{
		// Zero vertical coordinates.
		lpRect->top = 0;
		lpRect->bottom = 0;

		// Walk through all nodes.
		for (pdm = pmm->pdmHeap; pdm != NULL; pdm = pdm->next)
		{
			// Find the bottom coordinate of this node.
			rect.left = pdm->cbAddr.pt.x;
			rect.top = pdm->cbAddr.pt.y;
			rect.right = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
			rect.bottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;
			if (   (pdm->cbSize.pt.x >= size.pt.x)
				&& (pdm->cbAddr.pt.y >= lpRect->top)
				&& (mmGetBottom(pmm, pdm, &rect, size, align) > lpRect->bottom)
			)
			{
				*lpRect = rect;
			}
		}
	}

	// All other cases.  Find the best possible match by finding the smallest
	// area which will fit the device bitmap.
	else
	{
		// Walk though all nodes.
		for (pdm = pmm->pdmHeap; pdm != NULL; pdm = pdm->next)
		{
			// Find the area for this node.
			rect.left = pdm->cbAddr.pt.x;
			rect.top = pdm->cbAddr.pt.y;
			rect.right = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
			rect.bottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;
			if (   (pdm->cbSize.pt.x >= size.pt.x)
				&& (mmGetBest(pmm, pdm, &rect, size, align) < lpRect->area)
			)
			{
				*lpRect = rect;
			}
		}
	}

	if (lpRect->area == (ULONG) -1)
	{
		// No node was found, return an error.
		return FALSE;
	}

	// Reduce the size of the node to fit the requested size.
	if (lpRect->right - lpRect->left > size.pt.x)
	{
		lpRect->right = lpRect->left + size.pt.x;
	}
	if (lpRect->bottom - lpRect->top > size.pt.y)
	{
		lpRect->bottom = lpRect->top + size.pt.y;
	}
	return TRUE;
}

/******************************************************************************\
* UINT mmGetLeft(PIIMEMMGR pmm, PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT size,
*				 GXPOINT align)
*
* PURPOSE:	Find the first rectangle that fits the requested size and alignment.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			pdmNode	Pointer to a node from which to start the search.
*			lpRect	Pointer to rectangle which holds the rectangle coordinates.
*			size	Size of requested rectangle.
*			align	Alignment of requested rectangle.
*
* RETURNS:	The left coordinate of the rectangle if it fits the requested size
*			or -1 if there is no such rectangle.
\******************************************************************************/
UINT mmGetLeft(PIIMEMMGR pmm, PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT size,
			   GXPOINT align)
{
	GXRECT	rect, rectPath;
	PDEVMEM	pdm;
	UINT	pdmRight, left;

	// Copy rectangle coordinates.
	rect = *lpRect;

	// Align rectangle.
	#if TILE_ALIGNMENT
	{
		rect.left = mmAlignX(pmm, rect.left, size.pt.x, align.pt.x, FALSE);
	}
	#else
	{
		rect.left += align.pt.x - 1;
		rect.left -= rect.left % align.pt.x;
	}
	#endif
	rect.top += align.pt.y - 1;
	rect.top -= rect.top % align.pt.y;
	if (rect.left + size.pt.x > rect.right)
	{
		// Rectangle is too narrow for size or alignment.
		return (UINT) -1;
	}

	// Loop through all following nodes.
	for (pdm = pdmNode->next; pdm != NULL; pdm = pdm->next)
	{
		// Test if rectangle fits.
		if (rect.top + size.pt.y < rect.bottom)
		{
			break;
		}

		// Test if node is below rectangle.
		if (pdm->cbAddr.pt.y > rect.bottom)
		{
			break;
		}

		// Calculate right coordinate of node.
		pdmRight = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;

		// Test if node borders the rectangle at the bottom.
		if (   (pdm->cbAddr.pt.y == rect.bottom)
			&& (pdm->cbAddr.pt.x < rect.right)
			&& (pdmRight > rect.left)
		)
		{
			if (pdmRight < rect.right)
			{
				if (pdm->cbAddr.pt.x > rect.left)
				{
					// Ŀ
					//   rect  
					// 
					//   node 
					//  
					// Align the node horizontally.
					#if TILE_ALIGNMENT
					{
						left = mmAlignX(pmm, pdm->cbAddr.pt.x, size.pt.x,
								align.pt.x, FALSE);
					}
					#else
					{
						left = pdm->cbAddr.pt.x + align.pt.x - 1;
						left -= left % align.pt.x;
					}
					#endif
					if (left + size.pt.x < pdmRight)
					{
						// Follow the path of this node.
						rectPath.left = left;
						rectPath.top = rect.top;
						rectPath.right = pdmRight;
						rectPath.bottom = rect.bottom + pdm->cbSize.pt.y;
						if (mmGetLeft(pmm, pdm, &rectPath, size, align) !=
								(UINT) -1)
						{
							*lpRect = rectPath;
							return rectPath.left;
						}
					}
				}
				else
				{
					//  Ŀ
					//   rect 
					// 
					//  node 
					// 
					if (rect.left + size.pt.x < pdmRight)
					{
						// Follow the path of this node.
						rectPath.left = rect.left;
						rectPath.top = rect.top;
						rectPath.right = pdmRight;
						rectPath.bottom = rect.bottom + pdm->cbSize.pt.y;
						if (mmGetLeft(pmm, pdm, &rectPath, size, align) !=
								(UINT) -1)
						{
							*lpRect = rectPath;
							return rectPath.left;
						}
					}
				}
			}
			else
			{
				if (pdm->cbAddr.pt.x > rect.left)
				{
					// Ŀ
					//  rect 
					// 
					//   node 
					//  
					// Align the node horizontally.
					#if TILE_ALIGNMENT
					{
						left = mmAlignX(pmm, pdm->cbAddr.pt.x, size.pt.x,
								align.pt.x, FALSE);
					}
					#else
					{
						left = pdm->cbAddr.pt.x + align.pt.x - 1;
						left -= left % align.pt.x;
					}
					#endif
					if (left + size.pt.x > rect.right)
					{
						// Node is too narrow for size or alignment.
						break;
					}
					rect.left = left;
					rect.bottom += pdm->cbSize.pt.y;
				}
				else
				{
					//  Ŀ
					//   rect 
					// 
					//   node  
					// 
					rect.bottom += pdm->cbSize.pt.y;
				}
			}
		}
	}

	if (rect.top + size.pt.y > rect.bottom)
	{
		// Node is too low for size or alignment.
		return (UINT) -1;
	}

	// The rectangle fits.
	rect.area = MUL(rect.right - rect.left, rect.bottom - rect.top);
	*lpRect = rect;
	return rect.left;
}

/******************************************************************************\
* UINT mmGetRight(PIIMEMMGR pmm, PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT size,
*				  GXPOINT align)
*
* PURPOSE:	Find the right most rectangle that fits the requested size and
*			alignment.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			pdmNode	Pointer to a node from which to start the search.
*			lpRect	Pointer to rectangle which holds the rectangle coordinates.
*			size	Size of requested rectangle.
*			align	Alignment of requested rectangle.
*
* RETURNS:	The right coordinate of the rectangle if it fits the requested size
*			or 0 if there is no such rectangle.
\******************************************************************************/
UINT mmGetRight(PIIMEMMGR pmm, PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT size,
				GXPOINT align)
{
	GXRECT	rect, rectPath;
	PDEVMEM	pdm;
	UINT	pdmRight, left;

	// Copy rectangle coordinates.
	rect = *lpRect;

	// Align rectangle.
	#if TILE_ALIGNMENT
	{
		rect.left = mmAlignX(pmm, rect.left, size.pt.x, align.pt.x, FALSE);
	}
	#else
	{
		rect.left += align.pt.x - 1;
		rect.left -= rect.left % align.pt.x;
	}
	#endif
	rect.top += align.pt.y - 1;
	rect.top -= rect.top % align.pt.y;
	if (rect.left + size.pt.x > rect.right)
	{
		// Rectangle is too narrow for size or alignment.
		return 0;
	}

	// Zero the right most coordinate.
	lpRect->right = 0;

	// Loop through all following nodes.
	for (pdm = pdmNode->next; pdm != NULL; pdm = pdm->next)
	{
		// Test if node is below rectangle.
		if (pdm->cbAddr.pt.y > rect.bottom)
		{
			break;
		}

		// Calculate right coordinate of node.
		pdmRight = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;

		// Test if node borders the rectangle at the bottom.
		if (   (pdm->cbAddr.pt.y == rect.bottom)
			&& (pdm->cbAddr.pt.x < rect.right)
			&& (pdmRight > rect.left)
		)
		{
			if (pdmRight < rect.right)
			{
				if (pdm->cbAddr.pt.x > rect.left)
				{
					// Ŀ
					//   rect  
					// 
					//   node 
					//  
					// Align the node horizontally.
					#if TILE_ALIGNMENT
					{
						left = mmAlignX(pmm, pdm->cbAddr.pt.x, size.pt.x,
								align.pt.x, FALSE);
					}
					#else
					{
						left = pdm->cbAddr.pt.x + align.pt.x - 1;
						left -= left % align.pt.x;
					}
					#endif
					if (left + size.pt.x < pdmRight)
					{
						// Follow the path of this node.
						rectPath.left = left;
						rectPath.top = rect.top;
						rectPath.right = pdmRight;
						rectPath.bottom = rect.bottom + pdm->cbSize.pt.y;
						rectPath.area = 0;
						if (mmGetRight(pmm, pdm, &rectPath, size, align) >
								lpRect->right)
						{
							*lpRect = rectPath;
						}
					}
				}
				else
				{
					//  Ŀ
					//   rect 
					// 
					//  node 
					// 
					if (rect.left + size.pt.x < pdmRight)
					{
						// Follow the path of this node.
						rectPath.left = rect.left;
						rectPath.top = rect.top;
						rectPath.right = pdmRight;
						rectPath.bottom = rect.bottom + pdm->cbSize.pt.y;
						rectPath.area = 0;
						if (mmGetRight(pmm, pdm, &rectPath, size, align) >
								lpRect->right)
						{
							*lpRect = rectPath;
						}
					}
				}
			}
			else
			{
				if (pdm->cbAddr.pt.x > rect.left)
				{
					// Ŀ
					//  rect 
					// 
					//   node 
					//  
					// Align the node horizontally.
					#if TILE_ALIGNMENT
					{
						left = mmAlignX(pmm, pdm->cbAddr.pt.x, size.pt.x,
								align.pt.x, FALSE);
					}
					#else
					{
						left = pdm->cbAddr.pt.x + align.pt.x - 1;
						left -= left % align.pt.x;
					}
					#endif
					if (left + size.pt.x > rect.right)
					{
						// Node is too narrow for size or alignment.
						break;
					}
					rect.left = left;
					rect.bottom += pdm->cbSize.pt.y;
				}
				else
				{
					//  Ŀ
					//   rect 
					// 
					//   node  
					// 
					rect.bottom += pdm->cbSize.pt.y;
				}
			}
		}
	}

	if (rect.top + size.pt.y > rect.bottom)
	{
		// Node is too low for size or alignment.
		return 0;
	}

	// Align the rectangle to the right most coordinate.
	#if TILE_ALIGNMENT
	{
		rect.left = mmAlignX(pmm, rect.right - size.pt.x, size.pt.x, align.pt.x,
				TRUE);
	}
	#else
	{
		rect.left = rect.right - size.pt.x;
		rect.left -= rect.left % align.pt.x;
	}
	#endif
	rect.right = rect.left + size.pt.x;

	// Use the right most rectangle.
	if (rect.right > lpRect->right)
	{
		rect.area = MUL(rect.right - rect.left, rect.bottom - rect.top);
		*lpRect = rect;
	}
	return lpRect->right;
}

/******************************************************************************\
* UINT mmGetBottom(PIIMEMMGR pmm, PDEVMEM pdmNode, LPGXRECT lpRect,
*				   GXPOINT size, GXPOINT align)
*
* PURPOSE:	Find the bottom most rectangle that fits the requested size and
*			alignment.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			pdmNode	Pointer to a node from which to start the search.
*			lpRect	Pointer to rectangle which holds the rectangle coordinates.
*			size	Size of requested rectangle.
*			align	Alignment of requested rectangle.
*
* RETURNS:	The bottom coordinate of the rectangle if it fits the requested size
*			or 0 if there is no such rectangle.
\******************************************************************************/
UINT mmGetBottom(PIIMEMMGR pmm, PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT size,
				 GXPOINT align)
{
	GXRECT	rect, rectPath;
	PDEVMEM	pdm;
	UINT	pdmRight, left;

	// Copy rectangle coordinates.
	rect = *lpRect;

	// Align rectangle.
	#if TILE_ALIGNMENT
	{
		rect.left = mmAlignX(pmm, rect.left, size.pt.x, align.pt.x, FALSE);
	}
	#else
	{
		rect.left += align.pt.x - 1;
		rect.left -= rect.left % align.pt.x;
	}
	#endif
	rect.top += align.pt.y - 1;
	rect.top -= rect.top % align.pt.y;
	if (rect.left + size.pt.x > rect.right)
	{
		// Rectangle is too narrow for size or alignment.
		return 0;
	}

	// Zero the bottom most coordinate.
	lpRect->bottom = 0;

	// Loop through all following nodes.
	for (pdm = pdmNode->next; pdm != NULL; pdm = pdm->next)
	{
		// Test if node is below rectangle.
		if (pdm->cbAddr.pt.y > rect.bottom)
		{
			break;
		}

		// Calculate right coordinate of node.
		pdmRight = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;

		// Test if node borders the rectangle at the bottom.
		if (   (pdm->cbAddr.pt.y == rect.bottom)
			&& (pdm->cbAddr.pt.x < rect.right)
			&& (pdmRight > rect.left)
		)
		{
			if (pdmRight < rect.right)
			{
				if (pdm->cbAddr.pt.x > rect.left)
				{
					// Ŀ
					//   rect  
					// 
					//   node 
					//  
					// Align the node horizontally.
					#if TILE_ALIGNMENT
					{
						left = mmAlignX(pmm, pdm->cbAddr.pt.x, size.pt.x,
								align.pt.x, FALSE);
					}
					#else
					{
						left = pdm->cbAddr.pt.x + align.pt.x - 1;
						left -= left % align.pt.x;
					}
					#endif
					if (left + size.pt.x < pdmRight)
					{
						// Follow the path of this node.
						rectPath.left = left;
						rectPath.top = rect.top;
						rectPath.right = pdmRight;
						rectPath.bottom = rect.bottom + pdm->cbSize.pt.y;
						rectPath.area = 0;
						if (mmGetBottom(pmm, pdm, &rectPath, size, align) >
								lpRect->bottom)
						{
							*lpRect = rectPath;
						}
					}
				}
				else
				{
					//  Ŀ
					//   rect 
					// 
					//  node 
					// 
					if (rect.left + size.pt.x < pdmRight)
					{
						// Follow the path of this node.
						rectPath.left = rect.left;
						rectPath.top = rect.top;
						rectPath.right = pdmRight;
						rectPath.bottom = rect.bottom + pdm->cbSize.pt.y;
						rectPath.area = 0;
						if (mmGetBottom(pmm, pdm, &rectPath, size, align) >
								lpRect->bottom)
						{
							*lpRect = rectPath;
						}
					}
				}
			}
			else
			{
				if (pdm->cbAddr.pt.x > rect.left)
				{
					// Ŀ
					//  rect 
					// 
					//   node 
					//  
					// Align the node horizontally.
					#if TILE_ALIGNMENT
					{
						left = mmAlignX(pmm, pdm->cbAddr.pt.x, size.pt.x,
								align.pt.x, FALSE);
					}
					#else
					{
						left = pdm->cbAddr.pt.x + align.pt.x - 1;
						left -= left % align.pt.x;
					}
					#endif
					if (left + size.pt.x > rect.right)
					{
						// Node is too narrow for size or alignment.
						break;
					}
					rect.left = left;
					rect.bottom += pdm->cbSize.pt.y;
				}
				else
				{
					//  Ŀ
					//   rect 
					// 
					//   node  
					// 
					rect.bottom += pdm->cbSize.pt.y;
				}
			}
		}
	}

	if (rect.top + size.pt.y > rect.bottom)
	{
		// Node is too low for size or alignment.
		return 0;
	}

	// Align the rectangle to the bottom most coordinate.
	rect.top = rect.bottom - size.pt.y;
	rect.top -= rect.top % align.pt.y;
	rect.bottom = rect.top + size.pt.y;

	// Use the bottom most rectangle.
	if (rect.bottom > lpRect->bottom)
	{
		rect.area = MUL(rect.right - rect.left, rect.bottom - rect.top);
		*lpRect = rect;
	}
	return lpRect->bottom;
}

/******************************************************************************\
* UINT mmGetBest(PIIMEMMGR pmm, PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT size,
*				 GXPOINT align)
*
* PURPOSE:	Find the best rectangle that fits the requested size and alignment.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			pdmNode	Pointer to a node from which to start the search.
*			lpRect	Pointer to rectangle which holds the rectangle coordinates.
*			size	Size of requested rectangle.
*			align	Alignment of requested rectangle.
*
* RETURNS:	The area of the rectangle if it fits the requested size or -1 if
*			there is no such rectangle.
\******************************************************************************/
ULONG mmGetBest(PIIMEMMGR pmm, PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT size,
				GXPOINT align)
{
	GXRECT	rect, rectPath;
	PDEVMEM	pdm;
	UINT	pdmRight, left;

	// Copy rectangle coordinates.
	rect = *lpRect;

	// Align rectangle.
	#if TILE_ALIGNMENT
	{
		rect.left = mmAlignX(pmm, rect.left, size.pt.x, align.pt.x, FALSE);
	}
	#else
	{
		rect.left += align.pt.x - 1;
		rect.left -= rect.left % align.pt.x;
	}
	#endif
	rect.top += align.pt.y - 1;
	rect.top -= rect.top % align.pt.y;
	if (rect.left + size.pt.x > rect.right)
	{
		// Rectangle is too narrow for size or alignment.
		return (ULONG) -1;
	}

	// Initialize the area.
	lpRect->area = (ULONG) -1;

	// Loop through all following nodes.
	for (pdm = pdmNode->next; pdm != NULL; pdm = pdm->next)
	{
		// Test if node is below rectangle.
		if (pdm->cbAddr.pt.y > rect.bottom)
		{
			break;
		}

		// Calculate right coordinate of node.
		pdmRight = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;

		// Test if node borders the rectangle at the bottom.
		if (   (pdm->cbAddr.pt.y == rect.bottom)
			&& (pdm->cbAddr.pt.x < rect.right)
			&& (pdmRight > rect.left)
		)
		{
			if (pdmRight < rect.right)
			{
				if (pdm->cbAddr.pt.x > rect.left)
				{
					// Ŀ
					//   rect  
					// 
					//   node 
					//  
					// Align the node horizontally.
					#if TILE_ALIGNMENT
					{
						left = mmAlignX(pmm, pdm->cbAddr.pt.x, size.pt.x,
								align.pt.x, FALSE);
					}
					#else
					{
						left = pdm->cbAddr.pt.x + align.pt.x - 1;
						left -= left % align.pt.x;
					}
					#endif
					if (left + size.pt.x < pdmRight)
					{
						// Follow the path of this node.
						rectPath.left = left;
						rectPath.top = rect.top;
						rectPath.right = pdmRight;
						rectPath.bottom = rect.bottom + pdm->cbSize.pt.y;
						rectPath.area = 0;
						if (mmGetBest(pmm, pdm, &rectPath, size, align) <
								lpRect->area)
						{
							*lpRect = rectPath;
						}
					}
				}
				else
				{
					//  Ŀ
					//   rect 
					// 
					//  node 
					// 
					if (rect.left + size.pt.x < pdmRight)
					{
						// Follow the path of this node.
						rectPath.left = rect.left;
						rectPath.top = rect.top;
						rectPath.right = pdmRight;
						rectPath.bottom = rect.bottom + pdm->cbSize.pt.y;
						rectPath.area = 0;
						if (mmGetBest(pmm, pdm, &rectPath, size, align) <
								lpRect->area)
						{
							*lpRect = rectPath;
						}
					}
				}
			}
			else
			{
				if (pdm->cbAddr.pt.x > rect.left)
				{
					// Ŀ
					//  rect 
					// 
					//   node 
					//  
					// Align the node horizontally.
					#if TILE_ALIGNMENT
					{
						left = mmAlignX(pmm, pdm->cbAddr.pt.x, size.pt.x,
								align.pt.x, FALSE);
					}
					#else
					{
						left = pdm->cbAddr.pt.x + align.pt.x - 1;
						left -= left % align.pt.x;
					}
					#endif
					if (left + size.pt.x > rect.right)
					{
						// Node is too narrow for size or alignment.
						break;
					}
					rect.left = left;
					rect.bottom += pdm->cbSize.pt.y;
				}
				else
				{
					//  Ŀ
					//   rect 
					// 
					//   node  
					// 
					rect.bottom += pdm->cbSize.pt.y;
				}
			}
		}
	}

	if (rect.top + size.pt.y > rect.bottom)
	{
		// Node is too low for size or alignment.
		return (ULONG) -1;
	}

	// Use the smallest rectangle.
	rect.area = MUL(rect.right - rect.left, rect.bottom - rect.top);
	if (rect.area < lpRect->area)
	{
		*lpRect = rect;
	}

	// Return area of smallest rectangle that fits.
	return lpRect->area;
}

/******************************************************************************\
* UINT mmGetLargest(PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT align)
*
* PURPOSE:	Find the largest rectangle that fits the requested alignment.
*
* ON ENTRY:	pdmNode	Pointer to a node from which to start the search.
*			lpRect	Pointer to rectangle which holds the rectangle coordinates.
*			align	Alignment of requested rectangle.
*
* RETURNS:	The area of the rectangle if it fits the requested alignment or 0
*			if there is no such rectangle.
\******************************************************************************/
ULONG mmGetLargest(PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT align)
{
	GXRECT	rect, rectPath;
	PDEVMEM	pdm;
	UINT	pdmRight, left;

	// Copy rectangle coordinates.
	rect = *lpRect;

	// Align rectangle.
	rect.left += align.pt.x - 1;
	rect.left -= rect.left % align.pt.x;
	rect.top += align.pt.y - 1;
	rect.top -= rect.top % align.pt.y;
	if (rect.left >= rect.right)
	{
		// Rectangle is too narrow for alignment.
		return 0;
	}

	// Set the largest area to the aligned block size.
	rect.area = MUL(rect.right - rect.left, rect.bottom - rect.top);
	*lpRect = rect;

	// Loop through all following nodes.
	for (pdm = pdmNode->next; pdm != NULL; pdm = pdm->next)
	{
		// Test if node is below rectangle.
		if (pdm->cbAddr.pt.y > rect.bottom)
		{
			break;
		}

		// Calculate right coordinate of node.
		pdmRight = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;

		// Test if node borders the rectangle at the bottom.
		if (   (pdm->cbAddr.pt.y == rect.bottom)
			&& (pdm->cbAddr.pt.x < rect.right)
			&& (pdmRight > rect.left)
		)
		{
			if (pdmRight < rect.right)
			{
				if (pdm->cbAddr.pt.x > rect.left)
				{
					// Ŀ
					//   rect  
					// 
					//   node 
					//  
					// Align the node horizontally.
					left = pdm->cbAddr.pt.x + align.pt.x - 1;
					left -= left % align.pt.x;
					if (left < pdmRight)
					{
						// Follow the path of this node.
						rectPath.left = left;
						rectPath.top = rect.top;
						rectPath.right = pdmRight;
						rectPath.bottom = rect.bottom + pdm->cbSize.pt.y;
						rectPath.area = 0;
						if (mmGetLargest(pdm, &rectPath, align) > lpRect->area)
						{
							*lpRect = rectPath;
						}
					}
				}
				else
				{
					//  Ŀ
					//   rect 
					// 
					//  node 
					// 
					// Follow the path of this node.
					rectPath.left = rect.left;
					rectPath.top = rect.top;
					rectPath.right = pdmRight;
					rectPath.bottom = rect.bottom + pdm->cbSize.pt.y;
					rectPath.area = 0;
					if (mmGetLargest(pdm, &rectPath, align) > lpRect->area)
					{
						*lpRect = rectPath;
					}
				}
			}
			else
			{
				if (pdm->cbAddr.pt.x > rect.left)
				{
					// Ŀ
					//  rect 
					// 
					//   node 
					//  
					// Align the node horizontally.
					left = pdm->cbAddr.pt.x + align.pt.x - 1;
					left -= left % align.pt.x;
					if (left > rect.right)
					{
						// Node is too narrow for alignment.
						break;
					}
					rect.left = left;
					rect.bottom += pdm->cbSize.pt.y;
				}
				else
				{
					//  Ŀ
					//   rect 
					// 
					//   node  
					// 
					rect.bottom += pdm->cbSize.pt.y;
				}
			}
		}
	}

	if (rect.top >= rect.bottom)
	{
		// Node is too low for alignment.
		return 0;
	}

	// Use the largest rectangle.
	rect.area = MUL(rect.right - rect.left, rect.bottom - rect.top);
	if (rect.area > lpRect->area)
	{
		*lpRect = rect;
	}

	// Return area of largest rectangle.
	return lpRect->area;
}

#if TILE_ALIGNMENT
/******************************************************************************\
* UINT mmAlignX(PIIMEMMGR pmm, UINT x, UINT size, UINT align, BOOL fLeft)
*
* PURPOSE:	Align an x coordinate with the requested alignment factor.  Check
*			the alignment for too many tile boundary crossings.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			x		Unaligned x coordinate.
*			size	Requested width.
*			align	Requested alignment.
*			fLeft	TRUE if alignment should move to left, FALSE if alignment
*					should move to right.
*
* RETURNS:	The aligned x coordinate.
\******************************************************************************/
UINT mmAlignX(PIIMEMMGR pmm, UINT x, UINT size, UINT align, BOOL fLeft)
{
	BOOL	fFlag;

	// Remove tile-alignment flag from requested alignment.
	fFlag = align & 0x8000;
	align &= ~0x8000;

	// Loop forever.
	for (;;)
	{
		if (x % align)
		{
			// Align with the requested alignment.
			if (fLeft)
			{
				x -= x % align;
			}
			else
			{
				x += align - (x % align);
			}
		}

		// Do we cross too many tile boundaries?
		else if (fFlag && (x ^ (size - 1) ^ (x + size - 1)) & pmm->mmTileWidth)
		{
			// Align with tile boundary.
			if (fLeft)
			{
				x -= (x + size) & (pmm->mmTileWidth - 1);
			}
			else
			{
				x += pmm->mmTileWidth - (x & (pmm->mmTileWidth - 1));
			}
		}

		else
		{
			// We are done!
			break;
		}
	}

	// Return aligned x coordinate.
	return x;
}
#endif /* TILE_ALIGNMENT */

/******************************************************************************\
*																			   *
*					  1 6 - B I T   S U P P O R T   C O D E					   *
*																			   *
\******************************************************************************/
#ifdef WIN95
/******************************************************************************\
* UINT mmFindClient(PIIMEMMGR pmm, PCLIENT pClient, FNMMCALLBACK fnCallback)
*
* PURPOSE:	Call the given callback function for each node in the used list
*			which belongs to the specified client.
*
* ON ENTRY:	pmm			Pointer to MEMMGR structure.
*			pClient		Pointer to the client to look for.
*			fcCallback	Pointer to a callback function.
*
* RETURNS:	The return value of the callback function.
\******************************************************************************/
UINT mmFindClient(PIIMEMMGR pmm, PCLIENT pClient, FNMMCALLBACK fnCallback)
{
	PDEVMEM	pdm, pdmNext;
	UINT	status;

	// If we don't have a callback function just return 0.
	if (fnCallback == NULL)
	{
		return 0;
	}

	// Walk through all nodes.
	for (pdm = pmm->pdmUsed; pdm != NULL; pdm = pdmNext)
	{
		// Store pointer to next node.
		pdmNext = pdm->next;

		// Test if the client matches.
		if (pdm->client == pClient)
		{
			// If the callback function returns an error, return right away.
			status = fnCallback(pdm);
			if (status != 0)
			{
				return status;
			}
		}
	}

	return 0;
}

/******************************************************************************\
* ULONG mmMultiply(UINT n1, UINT n2)
*
* PURPOSE:	Multiply two unsigned values.
*
* ON ENTRY:	n1		First value to multiply.
*			n2		Second value to multiply.
*
* RETURNS:	The result of the multiplication.
\******************************************************************************/
#pragma optimize("", off)	// Oh boy, Microsoft does not understand assembly.
#pragma warning(disable : 4035)	// Yes, we do have a return value.
ULONG mmMultiply(UINT n1, UINT n2)
{
	_asm
	{
		mov ax, [n1]
		mul [n2]
	}
}
#pragma optimize("", on)
#pragma warning(default : 4035)
#endif /* WIN95 */

/******************************************************************************\
*																			   *
*						   D E B U G G I N G   C O D E						   *
*																			   *
\******************************************************************************/
#if DEBUG_HEAP
#pragma optimize("", off)	// Oh boy, Microsoft does not understand assembly.
void mmBreak()
{
	_asm int 3;         
}
#pragma optimize("", on)

void mmDumpList(PDEVMEM pdmRoot, LPCSTR lpszMessage)
{
	PDEVMEM	pdm;

	mmDebug(lpszMessage);
	for (pdm = pdmRoot; pdm != NULL; pdm = pdm->next)
	{
		mmDebug("%d,%d - %d,%d (%dx%d)\r\n", pdm->cbAddr.pt.x, pdm->cbAddr.pt.y,
				pdm->cbAddr.pt.x + pdm->cbSize.pt.x, pdm->cbAddr.pt.y +
				pdm->cbSize.pt.y, pdm->cbSize.pt.x, pdm->cbSize.pt.y);
	}
}

ULONG mmDebugList(PDEVMEM pdmRoot, BOOL fCheckSort)
{
	PDEVMEM pdm, pdmNext;
	UINT left, top, right, bottom;
	UINT nextLeft, nextTop, nextRight, nextBottom;
	ULONG error = 0;

	for (pdm = pdmRoot; pdm != NULL; pdm = pdm->next)
	{
		left = pdm->cbAddr.pt.x;
		top = pdm->cbAddr.pt.y;
		right = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
		bottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;
		if (left >= right || top >= bottom)
		{
			mmDebug("ERROR: Invalid size: %08X(%u,%u - %u,%u)\r\n", pdm, left,
					top, right, bottom);
			mmBreak();
			error++;
		}
		for (pdmNext = pdm->next; pdmNext != NULL; pdmNext = pdmNext->next)
		{
			if (pdm == pdmNext)
			{
				mmDebug("ERROR: Cyclic list: %08X\r\n", pdm);
				mmBreak();
				error++;
				break;
			}

			nextLeft = pdmNext->cbAddr.pt.x;
			nextTop = pdmNext->cbAddr.pt.y;
			nextRight = pdmNext->cbAddr.pt.x + pdmNext->cbSize.pt.x;
			nextBottom = pdmNext->cbAddr.pt.y + pdmNext->cbSize.pt.y;
			if (   (nextLeft < right && nextTop < bottom)
				&& (nextRight > left && nextBottom > top)
			)
			{
				mmDebug("ERROR: Overlap: %08X(%u,%u - %u,%u) & "
						"%08X(%u,%u - %u,%u)\r\n", pdm, left, top, right,
						bottom, pdmNext, nextLeft, nextTop, nextRight,
						nextBottom);
				mmBreak();
				error++;
			}

			if (   (fCheckSort)
				&& (nextTop < top || (nextTop == top && nextLeft <= left))
			)
			{
				mmDebug("ERROR: Not sorted: %08X(%u,%u - %u,%u) & "
						"%08X(%u,%u - %u,%u)\r\n", pdm, left, top, right,
						bottom, pdmNext, nextLeft, nextTop, nextRight,
						nextBottom);
				mmBreak();
				error++;
			}

			if (   (fCheckSort)
				&& (left == nextRight || right == nextLeft)
				&& (top < nextBottom && bottom > nextTop)
			)
			{
				mmDebug("ERROR: Not packed: %08X(%u,%u - %u,%u) & "
						"%08X(%u,%u - %u,%u)\r\n", pdm, left, top, right,
						bottom, pdmNext, nextLeft, nextTop, nextRight,
						nextBottom);
				mmBreak();
				error++;
			}
		}
	}

	if (error > 0)
	{
		mmDumpList(pdmRoot, "Offending heap:\r\n");
	}

	return error;
}

void mmDebug(LPCSTR lpszFormat, ...)
{
	#ifdef WIN95 /* Windows 95 */
	{
		typedef int (PASCAL FAR* LPWVSPRINTF)(LPSTR lpszOutput,
				LPCSTR lpszFormat, const void FAR* lpvArgList);
		static LPWVSPRINTF lpwvsprintf;
		char szBuffer[128];

		if (lpwvsprintf == NULL)
		{
			lpwvsprintf = (LPWVSPRINTF) GetProcAddress(GetModuleHandle("USER"),
					"WVSPRINTF");
		}

		lpwvsprintf(szBuffer, lpszFormat, (LPVOID) (&lpszFormat + 1));
		OutputDebugString(szBuffer);
	}
	#else /* Windows NT */
	{
		va_list arglist;
		va_start(arglist, lpszFormat);

		#ifdef WINNT_VER40
		{
			EngDebugPrint("MemMgr: ", (PCHAR) lpszFormat, arglist);
		}
		#else
		{
			char buffer[128];

			vsprintf(szBuffer, lpszFormat, arglist);
			OutputDebugString(szBuffer);
		}
		#endif
	}
	#endif
}
#endif /* DEBUG_HEAP */
#endif /* MEMMGR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\pattern.c ===
/******************************Module*Header*******************************\
* Module Name: pattern.c
*
* Used for creating and destroying the default patterns to be used on this
* device.
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Data*Struct*************************\
* gaajPat
*
* These are the standard patterns defined Windows, they are used to produce
* hatch brushes, grey brushes etc.
*
\**************************************************************************/

const BYTE gaajPat[HS_DDI_MAX][32] = {

    { 0x00,0x00,0x00,0x00,                 // ........     HS_HORIZONTAL 0
      0x00,0x00,0x00,0x00,                 // ........
      0x00,0x00,0x00,0x00,                 // ........
      0xff,0x00,0x00,0x00,                 // ********
      0x00,0x00,0x00,0x00,                 // ........
      0x00,0x00,0x00,0x00,                 // ........
      0x00,0x00,0x00,0x00,                 // ........
      0x00,0x00,0x00,0x00 },               // ........

    { 0x08,0x00,0x00,0x00,                 // ....*...     HS_VERTICAL 1
      0x08,0x00,0x00,0x00,                 // ....*...
      0x08,0x00,0x00,0x00,                 // ....*...
      0x08,0x00,0x00,0x00,                 // ....*...
      0x08,0x00,0x00,0x00,                 // ....*...
      0x08,0x00,0x00,0x00,                 // ....*...
      0x08,0x00,0x00,0x00,                 // ....*...
      0x08,0x00,0x00,0x00 },               // ....*...

    { 0x80,0x00,0x00,0x00,                 // *.......     HS_FDIAGONAL 2
      0x40,0x00,0x00,0x00,                 // .*......
      0x20,0x00,0x00,0x00,                 // ..*.....
      0x10,0x00,0x00,0x00,                 // ...*....
      0x08,0x00,0x00,0x00,                 // ....*...
      0x04,0x00,0x00,0x00,                 // .....*..
      0x02,0x00,0x00,0x00,                 // ......*.
      0x01,0x00,0x00,0x00 },               // .......*

    { 0x01,0x00,0x00,0x00,                 // .......*     HS_BDIAGONAL 3
      0x02,0x00,0x00,0x00,                 // ......*.
      0x04,0x00,0x00,0x00,                 // .....*..
      0x08,0x00,0x00,0x00,                 // ....*...
      0x10,0x00,0x00,0x00,                 // ...*....
      0x20,0x00,0x00,0x00,                 // ..*.....
      0x40,0x00,0x00,0x00,                 // .*......
      0x80,0x00,0x00,0x00 },               // *.......

    { 0x08,0x00,0x00,0x00,                 // ....*...     HS_CROSS 4
      0x08,0x00,0x00,0x00,                 // ....*...
      0x08,0x00,0x00,0x00,                 // ....*...
      0xff,0x00,0x00,0x00,                 // ********
      0x08,0x00,0x00,0x00,                 // ....*...
      0x08,0x00,0x00,0x00,                 // ....*...
      0x08,0x00,0x00,0x00,                 // ....*...
      0x08,0x00,0x00,0x00 },               // ....*...

    { 0x81,0x00,0x00,0x00,                 // *......*     HS_DIAGCROSS 5
      0x42,0x00,0x00,0x00,                 // .*....*.
      0x24,0x00,0x00,0x00,                 // ..*..*..
      0x18,0x00,0x00,0x00,                 // ...**...
      0x18,0x00,0x00,0x00,                 // ...**...
      0x24,0x00,0x00,0x00,                 // ..*..*..
      0x42,0x00,0x00,0x00,                 // .*....*.
      0x81,0x00,0x00,0x00 }                // *......*
};

/******************************Public*Routine******************************\
* bInitPatterns
*
* This routine initializes the default patterns.
*
\**************************************************************************/

BOOL bInitPatterns(IN PPDEV ppdev, ULONG cPatterns)
{
    SIZEL           sizl;
    ULONG           ulLoop;

    sizl.cx = 8;
    sizl.cy = 8;

    for (ulLoop = 0; ulLoop < cPatterns; ulLoop++)
    {
        ppdev->ahbmPat[ulLoop] = EngCreateBitmap(sizl, 4, BMF_1BPP,
        BMF_TOPDOWN, (PULONG) (&gaajPat[ulLoop][0]));

        if (ppdev->ahbmPat[ulLoop] == (HBITMAP) 0)
        {
        // Set the count created so vDisablePatterns will clean up.

            ppdev->cPatterns = ulLoop;
            return(FALSE);
        }
    }

    ppdev->cPatterns = cPatterns;
    return(TRUE);
}

/******************************Public*Routine******************************\
* vDisablePatterns
*
* Delete the standard patterns allocated.
*
\**************************************************************************/

VOID vDisablePatterns(IN PPDEV ppdev)
{
    ULONG ulIndex;

// Erase all patterns.

    for (ulIndex = 0; ulIndex < ppdev->cPatterns; ulIndex++)
    {
        EngDeleteSurface((HSURF) ppdev->ahbmPat[ulIndex]);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\precomp.h ===
/******************************************************************************\
*
* $Workfile:   PRECOMP.H  $
*
* Contents:
* Common headers used throughout the display driver. This entire include file
* will typically be pre-compiled.
*
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/PRECOMP.H  $
* 
*    Rev 1.10   Feb 16 1998 15:54:18   frido
* Removed rx.h from NT 5.0 headers.
* 
*    Rev 1.9   29 Aug 1997 17:14:46   RUSSL
* Added overlay support
*
*    Rev 1.8   08 Aug 1997 16:05:10   FRIDO
*
* Added mMCore.h file.
*
*    Rev 1.7   26 Feb 1997 13:20:20   noelv
*
* disable MCD code for NT 3.5x
*
*    Rev 1.6   26 Feb 1997 09:24:14   noelv
*
* Added MCD include files.
*
*    Rev 1.5   20 Jan 1997 14:48:32   bennyn
*
* Added ddinline.h
*
*    Rev 1.4   16 Jan 1997 11:41:22   bennyn
*
* Added pwrmgr.h & lgddmsg.h
*
*    Rev 1.3   01 Nov 1996 09:24:12   BENNYN
*
* Added shareable DD blt include files
*
*    Rev 1.2   20 Aug 1996 11:05:22   noelv
* Bugfix release from Frido 8-19-96
*
*    Rev 1.1   15 Aug 1996 11:38:56   frido
* First revision.
*
\******************************************************************************/

#include <stddef.h>
#include <stdarg.h>
#include <limits.h>

#ifdef WINNT_VER40
	#include <windef.h>
	#include <wingdi.h>
	#include <winerror.h>
#else
	#include <windows.h>
#endif

#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <winddi.h>
#include <devioctl.h>
#include <ntddvdeo.h>
#include <ioaccess.h>
#if _WIN32_WINNT < 0x0500
	#include <rx.h>
#endif
#include <ntsdexts.h>
#include <dciddi.h>

#ifndef WINNT_VER35
    #include <mcdrv.h>              // OpenGL MCD ddk supplied header
#endif

#include "bltp.h"
#include "l2d.h"
#include "l3system.h"

#if DRIVER_5465 && defined(OVERLAY)
#include "overlay.h"
#include "5465bw.h"
#endif

#include "driver.h"
#include "HDtable.h"
#include "lines.h"
#include "Optimize.h"

#include "ddinline.h"
#include "lgddmsg.h"
#include "pwrmgr.h"
#include "mmCore.h"

/// Define the A vector polynomial bits
//
// Each bit corresponds to one of the terms in the polynomial
//
// Rop(D,S,P) = a + a D + a S + a P + a  DS + a  DP + a  SP + a   DSP
//               0   d     s     p     ds      dp      sp      dsp

#define AVEC_NOT    0x01
#define AVEC_D      0x02
#define AVEC_S      0x04
#define AVEC_P      0x08
#define AVEC_DS     0x10
#define AVEC_DP     0x20
#define AVEC_SP     0x40
#define AVEC_DSP    0x80

#define AVEC_NEED_SOURCE  (AVEC_S | AVEC_DS | AVEC_SP | AVEC_DSP)
#define AVEC_NEED_PATTERN (AVEC_P | AVEC_DP | AVEC_SP | AVEC_DSP)
#define AVEC_NEED_DEST    (AVEC_D | AVEC_DP | AVEC_DS | AVEC_DSP)

// This is Laguna specific or 3 OP ROP specific

#define ROP3MIX(fg, bg)	((fg & 0xCC) | (bg & 0x33))

// SWAP - Swaps the value of two variables, using a temporary variable

#define SWAP(a, b, tmp) { (tmp) = (a); (a) = (b); (b) = (tmp); }

#if defined(i386)

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    __asm mov eax, ulNumerator                                  \
    __asm sub edx, edx                                          \
    __asm div ulDenominator                                     \
    __asm mov ulQuotient, eax                                   \
    __asm mov ulRemainder, edx                                  \
}

#else

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    ulQuotient  = (ULONG) ulNumerator / (ULONG) ulDenominator;  \
    ulRemainder = (ULONG) ulNumerator % (ULONG) ulDenominator;  \
}
#endif

#define BD_OP1_IS_SRAM_MONO (BD_OP1 * IS_SRAM_MONO)

#ifdef DEBUG

#define ASSERTDD(x, y) if (!(x)) RIP (y)

#else

#define ASSERTDD(x, y)

#endif

typedef VOID (FNFILL)(PDEV*, LONG, RECTL*, ULONG, ULONG, BRUSHOBJ*, POINTL*);

//
// File Prototypes
BOOL bIntersect(RECTL*  prcl1, RECTL*  prcl2, RECTL*  prclResult);
BOOL bSetMask(PPDEV	ppdev, BRUSHOBJ *pbo, POINTL   *pptlBrush, ULONG  *bltdef);
BOOL bMmFastFill(
PDEV*       ppdev,
LONG        cEdges,         // Includes close figure edge
POINTFIX*   pptfxFirst,
ULONG       ulHwForeMix,
ULONG       ulHwBackMix,
ULONG       iSolidColor,
BRUSHOBJ*  pbo);

VOID vMmFillSolid(              // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           ulHwForeMix,    // Hardware mix mode
ULONG           ulHwBackMix,    // Not used
BRUSHOBJ*    	 pbo,            // Drawing colour is pbo->iSolidColor
POINTL*         pptlBrush);      // Not used

VOID vMmFillPatFast(            // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           ulHwForeMix,    // Hardware mix mode (foreground mix mode if
                                //   the brush has a mask)
ULONG           ulHwBackMix,    // Not used (unless the brush has a mask, in
                                //   which case it's the background mix mode)
BRUSHOBJ*		 pbo,            // pbo
POINTL*         pptlBrush);      // Pattern alignment

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\pwrmgr.c ===
/***************************************************************************
*
*                ******************************************
*                * Copyright (c) 1997, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:  Laguna (CL-GD546X) - 
*
* FILE:     pwrmgr.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module contains Power manager code for both
*           Laguna Win95 and NT drivers.
*
* MODULES:
*           LgPM_SetHwModuleState()
*           LgPM_GetHwModuleState()
*
* REVISION HISTORY:
* $Log:   X:/log/laguna/powermgr/src/pwrmgr.c  $
* 
*    Rev 1.3   20 Jun 1997 13:37:16   bennyn
* 
* Moved power manager functions to Miniport
* 
*    Rev 1.2   23 Apr 1997 08:01:42   SueS
* Enable MMIO access to PCI configuration registers before VS_Clk_Control
* and VS_Control are referenced.  Disable MMIO access after they're
* referenced.
* 
*    Rev 1.1   23 Jan 1997 16:29:28   bennyn
* Use bit-11 instead of bit-15 to enable VS_CLK_CNTL
* 
*    Rev 1.0   16 Jan 1997 11:48:20   bennyn
* Initial revision.
* 
*
****************************************************************************
****************************************************************************/


#include "precomp.h"
#include "clioctl.h"

#if defined WINNT_VER35      // WINNT_VER35
  // If WinNT 3.5 skip all the source code
#else

/*----------------------------- INCLUDES ----------------------------------*/
#ifndef WINNT_VER40
#include <pwrmgr.h>
#endif

/*----------------------------- DEFINES -----------------------------------*/

/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/

/*-------------------------- STATIC VARIABLES -----------------------------*/
            
            
/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/
            
/****************************************************************************
* FUNCTION NAME: LgPM_SetHwModuleState()
*
* DESCRIPTION:   This routine validates the request for any conflict between
*                the request and the current chip operation. If it is valid,
*                it will enable or disable the specified HW module by turning
*                on or off appropriate HW clocks and returns TRUE. If it is 
*                invalid or there is a conflict to the current chip operation,
*                it ignores the request and return FAIL.
*
* Input:
*   hwmod - can be one of the following HW modules
*             MOD_2D
*             MOD_3D
*             MOD_TVOUT
*             MOD_VPORT
*             MOD_VGA
*             MOD_EXTMODE
*             MOD_STRETCH
*
*   state - Ether ENABLE or DISABLE.
*
* Return: TRUE - succeed, FALSE - failed.     
*
*****************************************************************************/
BOOL LgPM_SetHwModuleState (PPDEV ppdev, ULONG hwmod, ULONG state)
{
  LGPM_IN_STRUCT    InBuf;
  LGPM_OUT_STRUCT   OutBuf;
  DWORD  cbBytesReturned;

  InBuf.arg1 = hwmod;
  InBuf.arg2 = state;
  OutBuf.status = FALSE;
  OutBuf.retval = 0;

  if (DEVICE_IO_CTRL(ppdev->hDriver,
                     IOCTL_SET_HW_MODULE_POWER_STATE,
                     (LPVOID)&InBuf,  sizeof(InBuf),
                     (LPVOID)&OutBuf, sizeof(OutBuf),
                     &cbBytesReturned, NULL))
     return TRUE;
  else
     return FALSE;

};  // LgPM_SetHwModuleState



/****************************************************************************
* FUNCTION NAME: LgPM_GetHwModuleState()
*
* DESCRIPTION:   This routine returns the current state of a particular
*                hardware module.
* 
* Input:
*   hwmod - can be one of the following HW modules
*             MOD_2D
*             MOD_3D
*             MOD_TVOUT
*             MOD_VPORT
*             MOD_VGA
*             MOD_EXTMODE
*             MOD_STRETCH
*
*   state - Pointer to ULONG variable for returning the HW module state
*           (ENABLE or DISABLE).
*
* Return: TRUE - succeed, FALSE - failed.     
*                
****************************************************************************/
BOOL LgPM_GetHwModuleState (PPDEV ppdev, ULONG hwmod, ULONG* state)
{
  LGPM_IN_STRUCT    InBuf;
  LGPM_OUT_STRUCT   OutBuf;
  DWORD  cbBytesReturned;

  InBuf.arg1 = hwmod;
  InBuf.arg2 = (ULONG) state;
  OutBuf.status = FALSE;
  OutBuf.retval = 0;

  if (DEVICE_IO_CTRL(ppdev->hDriver,
                     IOCTL_GET_HW_MODULE_POWER_STATE,
                     (LPVOID)&InBuf,  sizeof(InBuf),
                     (LPVOID)&OutBuf, sizeof(OutBuf),
                     &cbBytesReturned, NULL))
     return TRUE;
  else
     return FALSE;

};  // LgPM_GetHwModuleState


#endif // WINNT_VER35


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\paint.c ===
/******************************Module*Header*******************************\
* Module Name: PAINT.c
* Author: Noel VanHook
* Date: Mar. 21, 1995
* Purpose: Handle calls to DrvPaint
*
* Copyright (c) 1995 Cirrus Logic, Inc.
*
\**************************************************************************/

/*

    This module handles calls to DrvPaint() by converting them into calls
    to DrvBitBlt().  The only conversion needed to to change the MIX into
    a ROP4.  

*/


#include "precomp.h"

#define PAINT_DBG_LEVEL 1

//==========================================================================
//
// In an attempt to trace the problems with the FIFO, we supply a few
// macros that will allow us to easily try different FIFO stratagies.
//

//
// This macro is executed at the start of every BLT, before any registers
// are written.
//
#define STARTBLT()      \
    do {                \
    }while (0)

//
// This macro is executed at the top of inner BLT loops. 
// If there were clipping, for example, STARTBLT() would be executed
// once at the start of the BLT, and STARTBLTLOOP() would be executed 
// before each rectangle in the clip list.
//
#define STARTBLTLOOP()  \
    do {                \
	REQUIRE(0);     \
    }while (0)
//==========================================================================


//
// Table to convert ROP2 codes to ROP3 codes.
//

BYTE Rop2ToRop3[]=
{
	0xFF, // R2_WHITE       /*  1       */ 
	0x00, // R2_BLACK       /*  0       */
	0x05, // R2_NOTMERGEPEN /* DPon     */
	0x0A, // R2_MASKNOTPEN  /* DPna     */
	0x0F, // R2_NOTCOPYPEN  /* PN       */
	0x50, // R2_MASKPENNOT  /* PDna     */
	0x55, // R2_NOT         /* Dn       */
	0x5A, // R2_XORPEN      /* DPx      */
	0x5F, // R2_NOTMASKPEN  /* DPan     */
	0xA0, // R2_MASKPEN     /* DPa      */
	0xA5, // R2_NOTXORPEN   /* DPxn     */
	0xAA, // R2_NOP         /* D        */
	0xAF, // R2_MERGENOTPEN /* DPno     */
	0xF0, // R2_COPYPEN     /* P        */
	0xF5, // R2_MERGEPENNOT /* PDno     */
	0xFA, // R2_MERGEPEN    /* DPo      */
	0xFF  // R2_WHITE       /*  1       */
};


//
// If data logging is enabled, Prototype the logging files.
//
#if LOG_CALLS
    void LogPaint(
	int 	  acc,
        SURFOBJ*  psoDest,
	MIX       mix,
        CLIPOBJ*  pco,
        BRUSHOBJ* pbo);

//
// If data logging is not enabled, compile out the calls.
//
#else
    #define LogPaint(acc, psoDest, mix, pco, pbo)
#endif





/**************************************************************************\
* DrvPaint                                                                 *
*                                                                          *
* Paint the clipping region with the specified brush                       *
* Accomplished by converting into a call to DrvBitBlt()                    *
*                                                                          *
\**************************************************************************/

BOOL DrvPaint
(
    SURFOBJ  *pso,
    CLIPOBJ  *pco,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    MIX       mix
)
{
    ULONG fg_rop, bg_rop, rop4;
    DWORD  color;
    PPDEV ppdev;      

    #if NULL_PAINT
    {
	if (pointer_switch)	    return TRUE;
    }
    #endif

    ppdev = (PPDEV) pso->dhpdev;  
    ASSERTMSG (ppdev,"No PDEV in DrvPaint.");

    SYNC_W_3D(ppdev);

    //
    // The destination rectangle is defined by the clipping region, 
    // so we should never get a null clipping region.
    //
    ASSERTMSG (pco, "DrvPaint without a clip object!\n");

    DISPDBG((PAINT_DBG_LEVEL,"Drvpaint: Entry.\n"));


    // Are we painting to a device bitmap?
    if (pso->iType == STYPE_DEVBITMAP)
    {
        // Yes. 
	PDSURF pdsurf = (PDSURF)pso->dhsurf;

	// Is the device bitmap currently in host memory?
	if ( pdsurf->pso )
	{
	    // Yes.  Move it into off screen memory.
	    if ( !bCreateScreenFromDib(ppdev, pdsurf) )
	    {
		// We couldn't move it to off-screen memory.
		LogPaint(1, pso, mix, pco, pbo);
	        return EngPaint(pdsurf->pso, pco, pbo, pptlBrush, mix);
	    }
	}

	// The device bitmap now resides in off-screen memory.
	// This is the offset to it.
	ppdev->ptlOffset.x = pdsurf->ptl.x;
	ppdev->ptlOffset.y = pdsurf->ptl.y;
    }
    else
    {
	// No, we are not painting to a device bitmap.
	ppdev->ptlOffset.x = ppdev->ptlOffset.y = 0;
    }
    
    //
    // DrvPaint is most often called with 
    // mix 0D (PAT COPY) and mix 06 (DEST INVERT).
    // It behooves us, therefore, to handle these as
    // special cases... provided they aren't clipped.
    //
    if ((pco->iDComplexity != DC_COMPLEX))
    {
	// =================== PATCOPY ==================================
        if (mix == 0x0D0D) 
        {
    	    ASSERTMSG(pbo, "DrvPaint PATCOPY without a brush.\n");
    	    if (pbo->iSolidColor != 0xFFFFFFFF) // Solid color
	    {
	        color = pbo->iSolidColor;
	        switch (ppdev->ulBitCount)
	        {
		    case 8: // For 8 bpp duplicate byte 0 into byte 1. 
	    		color |=  (color << 8);
	
		    case 16: // For 8,16 bpp, duplicate the low word into the high word.
		    	color |=  (color << 16);
	    	    break;
        	}
	
			REQUIRE(9);
       	    LL_BGCOLOR(color, 0);
	        LL_DRAWBLTDEF(0x100700F0, 0);
	        LL_OP0(pco->rclBounds.left + ppdev->ptlOffset.x,
        	       pco->rclBounds.top + ppdev->ptlOffset.y);
	        LL_BLTEXT ((pco->rclBounds.right - pco->rclBounds.left),
    				   (pco->rclBounds.bottom - pco->rclBounds.top));
          
		LogPaint(0, pso, mix, pco, pbo);
	        return TRUE;
	    } // End PATCOPY with solid color.  

	    else // PATCOPY with a brush.
            {
	        DWORD bltdef = 0x1000;
	        if (SetBrush(ppdev, &bltdef, pbo, pptlBrush))
	        {
				REQUIRE(7);
	    	    LL_DRAWBLTDEF((bltdef << 16) | 0x00F0, 0);
	    	    LL_OP0 (pco->rclBounds.left + ppdev->ptlOffset.x,
    	                pco->rclBounds.top + ppdev->ptlOffset.y);
	    	    LL_BLTEXT ((pco->rclBounds.right -  pco->rclBounds.left) ,
    		               (pco->rclBounds.bottom - pco->rclBounds.top) );
    
		    LogPaint(0, pso, mix, pco, pbo);
	    	    return TRUE;
	        }
	    } // End PATCOPY with a brush
	
       } // End PATCOPY

       // ======================= DEST INVERT ============================
       else if (mix == 0x0606)
       {
		REQUIRE(7);
	    LL_DRAWBLTDEF(0x11000055, 0);
	    LL_OP0(pco->rclBounds.left + ppdev->ptlOffset.x,
        	   pco->rclBounds.top + ppdev->ptlOffset.y);
	    LL_BLTEXT ((pco->rclBounds.right -  pco->rclBounds.left),
    		       (pco->rclBounds.bottom - pco->rclBounds.top) );
	
	    LogPaint(0, pso, mix, pco, pbo);
            return TRUE;
	
       } // End DEST INVERT

    } // End special cases


    // First, convert the fg and bg mix into a fg and bg rop
    fg_rop = Rop2ToRop3[ (mix & 0x0F) ];      // convert fg mix to fg rop.
    bg_rop = Rop2ToRop3[ ((mix>>8) & 0x0F) ]; // convert bg mix to bg rop
    rop4 = (bg_rop<<8) | fg_rop;              // build rop4.

    //
    // Now convert Paint to BitBLT
    //
    LogPaint(2, pso, mix, pco, pbo);

    DISPDBG((PAINT_DBG_LEVEL,"Drvpaint: Convert to DrvBitBlt().\n"));
    return DrvBitBlt(pso,	            // Target
    		     (SURFOBJ *) NULL,      // Source
	    	     (SURFOBJ *) NULL,      // Mask
	    	     pco,                   // Clip object
		     (XLATEOBJ *) NULL,     // Xlate object
	    	     &(pco->rclBounds),     // Dest rectangle.
	    	     (PPOINTL) NULL,        // Src point.
	    	     (PPOINTL) NULL,        // Mask point.
	    	     pbo,                   // Brush
	    	     pptlBrush,             // Brush alignment
	    	     rop4);                 // ROP4
}



#if LOG_CALLS
// ============================================================================
//
//    Everything from here down is for data logging and is not used in the 
//    production driver.
//
// ============================================================================


// ****************************************************************************
//
// LogPaint()
// This routine is called only from DrvPaint()
// Dump information to a file about what is going on in DrvPaint land.
//
// ****************************************************************************
void LogPaint(
	int 	  acc,
        SURFOBJ*  psoDest,
	MIX 	  mix,
        CLIPOBJ*  pco,
        BRUSHOBJ* pbo)
{
    PPDEV dppdev,sppdev,ppdev;
    char buf[256];
    int i;
    BYTE fg_rop, bg_rop;
    ULONG iDComplexity;

    ppdev = (PPDEV) (psoDest ? psoDest->dhpdev : 0);
     
    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    i = sprintf(buf,"DrvPaint: ");
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    switch(acc)
    {
	case 0: // Accelerated
	    i = sprintf(buf, "ACCL ");
	    break;

	case 1: // Punted
	    i = sprintf(buf,"PUNT host ");
	    break;

	case 2: // Punted
	    i = sprintf(buf, "PUNT BitBlt ");
	    break;

	default:
 	    i = sprintf(buf, "PUNT unknown ");
	    break;

    }
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);


    //
    // Check the DEST
    //
    if (psoDest)
    {
        if (psoDest->iType == STYPE_DEVBITMAP)
        {
            i = sprintf(buf, "Id=%p ", psoDest->dhsurf);
            WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
            if (  ((PDSURF)psoDest->dhsurf)->pso   )
                i = sprintf(buf,"DST=DH ");
            else
                i = sprintf(buf,"DST=DF ");
        }
        else if (psoDest->hsurf == ppdev->hsurfEng)
            i = sprintf(buf,"DST=S  ");
        else
            i = sprintf(buf,"DST=H  ");
    }
    else
        i = sprintf(buf,"DST=N  ");
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);



    //
    // Check the MIX
    //
    i = sprintf(buf,"MIX = 0x%04X   ", mix);
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    //
    // Check the type of clipping.
    //
    iDComplexity = (pco ? pco->iDComplexity : DC_TRIVIAL);
    i = sprintf(buf,"CLIP=%s ",
                (iDComplexity==DC_TRIVIAL ? "T": 
                (iDComplexity == DC_RECT ? "R" : "C" )));
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    //
    // Type of pattern.
    //
    if (pbo == NULL)
    {
        i = sprintf(buf,"BRUSH=N          ");
        WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }
    else if (pbo->iSolidColor == 0xFFFFFFFF )
    {
        i = sprintf(buf,"BRUSH=P          ");
        WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }
    else
    {
        i = sprintf(buf,"BRUSH=0x%08X ",(pbo->iSolidColor));
        WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }


    i = sprintf(buf,"\r\n");
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\palette.c ===
/******************************Module*Header*******************************\
* Module Name: palette.c
*
* Palette support.
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

// Global Table defining the 20 Window Default Colors.        For 256 color
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.

const PALETTEENTRY BASEPALETTE[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};

BOOL bInitDefaultPalette(PPDEV ppdev, DEVINFO *pDevInfo);

/******************************Public*Routine******************************\
* bInitPaletteInfo
*
* Initializes the palette information for this PDEV.
*
* Called by DrvEnablePDEV.
*
\**************************************************************************/

BOOL bInitPaletteInfo(PPDEV ppdev, DEVINFO *pDevInfo)
{
    if (!bInitDefaultPalette(ppdev, pDevInfo))
        return(FALSE);

    return(TRUE);
}

/******************************Public*Routine******************************\
* vDisablePalette
*
* Frees resources allocated by bInitPaletteInfo.
*
\**************************************************************************/

VOID vDisablePalette(PPDEV ppdev)
{
// Delete the default palette if we created one.

    if (ppdev->hpalDefault)
    {
        EngDeletePalette(ppdev->hpalDefault);
        ppdev->hpalDefault = (HPALETTE) 0;
    }

    if (ppdev->pPal != (PPALETTEENTRY)NULL)
        MEMORY_FREE((PVOID)ppdev->pPal);
}

/******************************Public*Routine******************************\
* bInitDefaultPalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bInitDefaultPalette(PPDEV ppdev, DEVINFO *pDevInfo)
{
    if (ppdev->ulBitCount == 8)
    {
        ULONG ulLoop;
        BYTE jRed,jGre,jBlu;

        // Allocate our palette

#ifdef WINNT_VER40
        ppdev->pPal = (PPALETTEENTRY)MEM_ALLOC(FL_ZERO_MEMORY,
                (sizeof(PALETTEENTRY) * 256), ALLOC_TAG);
#else
        ppdev->pPal = (PPALETTEENTRY)MEM_ALLOC(LMEM_FIXED | LMEM_ZEROINIT,
                (sizeof(PALETTEENTRY) * 256));
#endif

        if ((ppdev->pPal) == NULL) {
            RIP("DISP bInitDefaultPalette() failed MEM_ALLOC\n");
            return(FALSE);
        }


        // Generate 256 (8*4*4) RGB combinations to fill the palette

        jRed = jGre = jBlu = 0;

        for (ulLoop = 0; ulLoop < 256; ulLoop++)
        {
            ppdev->pPal[ulLoop].peRed   = jRed;
            ppdev->pPal[ulLoop].peGreen = jGre;
            ppdev->pPal[ulLoop].peBlue  = jBlu;
            ppdev->pPal[ulLoop].peFlags = (BYTE)0;

            if (!(jRed += 32))
            if (!(jGre += 32))
            jBlu += 64;
        }

    // Fill in Windows Reserved Colors from the WIN 3.0 DDK
    // The Window Manager reserved the first and last 10 colors for
    // painting windows borders and for non-palette managed applications.

        for (ulLoop = 0; ulLoop < 10; ulLoop++)
        {
        // First 10

            ppdev->pPal[ulLoop] = BASEPALETTE[ulLoop];

        // Last 10

            ppdev->pPal[246 + ulLoop] = BASEPALETTE[ulLoop+10];
        }

    // Create handle for palette.

        ppdev->hpalDefault =
        pDevInfo->hpalDefault = EngCreatePalette(PAL_INDEXED,
                                                   256,
                                                   (PULONG) ppdev->pPal,
                                                   0,0,0);

        if (ppdev->hpalDefault == (HPALETTE) 0)
        {
            RIP("DISP bInitDefaultPalette failed EngCreatePalette\n");
            MEMORY_FREE(ppdev->pPal);
            return(FALSE);
        }

    // Initialize the hardware with the initial palette.

        return(TRUE);
    } else {

        ppdev->hpalDefault =
        pDevInfo->hpalDefault = EngCreatePalette(PAL_BITFIELDS,
                                                   0,(PULONG) NULL,
                                                   ppdev->flRed,
                                                   ppdev->flGreen,
                                                   ppdev->flBlue);

        if (ppdev->hpalDefault == (HPALETTE) 0)
        {
            RIP("DISP bInitDefaultPalette failed EngCreatePalette\n");
            return(FALSE);
        }
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* bInit256ColorPalette
*
* Initialize the hardware's palette registers.
*
\**************************************************************************/

BOOL bInit256ColorPalette(PPDEV ppdev)
{
    BYTE        ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT pScreenClut;
    ULONG       ulReturnedDataLength;
    ULONG       cColors;
    PVIDEO_CLUTDATA pScreenClutData;

    if (ppdev->ulBitCount == 8)
    {
        // Fill in pScreenClut header info:

        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        // Copy colours in:

        cColors = 256;
        pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

        while(cColors--)
        {
            pScreenClutData[cColors].Red =    ppdev->pPal[cColors].peRed >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Green =  ppdev->pPal[cColors].peGreen >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue =   ppdev->pPal[cColors].peBlue >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }

        // Set palette registers:

        if (!DEVICE_IO_CTRL(ppdev->hDriver,
                             IOCTL_VIDEO_SET_COLOR_REGISTERS,
                             pScreenClut,
                             MAX_CLUT_SIZE,
                             NULL,
                             0,
                             &ulReturnedDataLength,
                             NULL))
        {
            DISPDBG((1, "Failed bEnablePalette"));
            return(FALSE);
        }
    }

    DISPDBG((5, "Passed bEnablePalette"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* DrvSetPalette
*
* DDI entry point for manipulating the palette.
*
\**************************************************************************/

BOOL DrvSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BYTE            ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT     pScreenClut;
    PVIDEO_CLUTDATA pScreenClutData;
    PDEV*           ppdev;

    UNREFERENCED_PARAMETER(fl);

    DISPDBG((1, "DISP DrvSetPalette: Entry.\n"));

    ppdev = (PDEV*) dhpdev;

    // Fill in pScreenClut header info:

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = (USHORT) cColors;
    pScreenClut->FirstEntry = (USHORT) iStart;

    pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

    if (cColors != PALOBJ_cGetColors(ppalo, iStart, cColors,
                                     (ULONG*) pScreenClutData))
    {
        DISPDBG((1, "DrvSetPalette failed PALOBJ_cGetColors\n"));
        return (FALSE);
    }

    // Set the high reserved byte in each palette entry to 0.
    // Do the appropriate palette shifting to fit in the DAC.

    if (ppdev->cPaletteShift)
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Red >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Green >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }
    }
    else
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Unused = 0;
        }
    }

    // Set palette registers

    if (!DEVICE_IO_CTRL(ppdev->hDriver,
                         IOCTL_VIDEO_SET_COLOR_REGISTERS,
                         pScreenClut,
                         MAX_CLUT_SIZE,
                         NULL,
                         0,
                         &cColors,
                         NULL))
    {
        DISPDBG((1, "DrvSetPalette failed DEVICE_IO_CTRL\n"));
        return (FALSE);
    }

    DISPDBG((1, "DISP DrvSetPalette: Exit.\n"));
    return(TRUE);

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\sync.c ===
/****************************************************************************
*****************************************************************************
*
*                ******************************************
*                * Copyright (c) 1995, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:	Laguna I (CL-GD5462) - 
*
* FILE:		sync.c
*
* Initial AUTHOR:   Benny Ng
* Major re-write:   Noel VanHook
*
* DESCRIPTION:
*           This module contains the implementation of DrvSynchronize()
*           routine.
*
* MODULES:
*           DrvSynchronize()
*
* REVISION HISTORY:
*   7/06/95     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/sync.c  $
* 
*    Rev 1.13   22 Apr 1997 11:06:36   noelv
* Removed frame buffer cache invalidate since FB cache is disabled.
* 
*    Rev 1.12   09 Apr 1997 10:50:06   SueS
* Changed sw_test_flag to pointer_switch.
* 
*    Rev 1.11   08 Apr 1997 12:32:00   einkauf
* 
* add SYNC_W_3D to coordinate MCD/2D hw access
* 
*    Rev 1.10   04 Feb 1997 13:52:36   noelv
* Fixed typo.
* 
*    Rev 1.9   04 Feb 1997 10:50:56   noelv
* Added workaround for 5465 direct frame buffer readback bug.
* 
*    Rev 1.8   26 Nov 1996 10:45:48   SueS
* Changed WriteLogFile parameters for buffering.
* 
*    Rev 1.7   13 Nov 1996 17:05:34   SueS
* Changed WriteFile calls to WriteLogFile.
* 
*    Rev 1.6   20 Aug 1996 11:04:32   noelv
* Bugfix release from Frido 8-19-96
* 
*    Rev 1.1   15 Aug 1996 11:39:20   frido
* Added precompiled header.
* 
*    Rev 1.0   14 Aug 1996 17:16:32   frido
* Initial revision.
* 
*    Rev 1.5   07 Aug 1996 08:30:56   noelv
* added comments
* 
*    Rev 1.4   20 Mar 1996 16:09:44   noelv
* 
* Updated data logging
* 
*    Rev 1.3   05 Mar 1996 11:59:18   noelv
* Frido version 19
 * 
 *    Rev 1.1   20 Jan 1996 01:11:38   frido
* 
*    Rev 1.6   15 Jan 1996 17:01:34   NOELV
* 
*    Rev 1.5   12 Jan 1996 10:54:30   NOELV
* Totally re-written.
* 
*    Rev 1.4   22 Sep 1995 10:24:58   NOELV
* Re-aranged the order of the tests.
* 
*    Rev 1.1   19 Sep 1995 16:31:02   NOELV
* Ported to rev AB.
* 
*    Rev 1.0   25 Jul 1995 11:23:22   NOELV
* Initial revision.
* 
*    Rev 1.1   07 Jul 1995 10:37:22   BENNYN
* Initial version
* 
*    Rev 1.0   06 Jul 1995 14:55:48   BENNYN
* Initial revision.
*
****************************************************************************
****************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/
#include "precomp.h"

/*----------------------------- DEFINES -----------------------------------*/
#define DBGDISP

#define  MAX_CNT           0x7FFFFF

#define  BLT_RDY_BIT       0x1L
#define  BLT_FLAG_BIT      0x2L
#define  WF_EMPTY_BIT      0x4L

#define  BITS_CHK          (BLT_RDY_BIT | BLT_FLAG_BIT | WF_EMPTY_BIT)
#define  ENGINE_IDLE        0

#define  SYNC_DBG_LEVEL     0

//
// If data logging is enabled, Prototype the logging files.
//
#if LOG_CALLS
    void LogSync(
        int     acc,
        PPDEV   ppdev,
        int     count);

//
// If data logging is not enabled, compile out the calls.
//
#else
    #define LogSync(acc, ppdev, count)
#endif



/****************************************************************************
* FUNCTION NAME: DrvSynchronize()
*
* REVISION HISTORY:
*   7/06/95     Benny Ng      Initial version
****************************************************************************/
VOID DrvSynchronize(DHPDEV dhpdev,
                    RECTL  *prcl)
{

    PPDEV ppdev = (PPDEV) dhpdev;

    SYNC_W_3D(ppdev);

    //
    // NOTE:  We also call this function from within the driver.
    // When we do, we don't bother to set prcl.  If you need to use
    // prcl here, you need to find where we call DrvSynchronize, and
    // set prcl to a real value.
    //


    //
    // Make the first chip test as fast as possible.  If the chip
    // is already idle, we want to return to NT as fast as possible.
    //
    if ( LLDR_SZ (grSTATUS) == ENGINE_IDLE)
    {
        LogSync(0, ppdev, 0);
    }

    //
    // Alright, the chip isn't idle yet.  
    // Go into a wait loop.
    //
    else
    {
        ULONG ultmp;
        LONG delaycnt = 1;

        while (1)
        {
            ultmp = LLDR_SZ (grSTATUS);
     
            if ((ultmp & BITS_CHK) == ENGINE_IDLE)
            {
                LogSync(0, ppdev, delaycnt);
                break;
            }

            if (delaycnt++ >= MAX_CNT)
            {
                //
                // The chip never went idle.  This most likely means the chip
                // is totally dead.  In a checked build we will halt with a
                // debug message.
                // In a free build we will return to NT and hope for the best.
                //

                LogSync(1, ppdev, 0);
                RIP("Chip failed to go idle in DrvSynchronize!\n");
                break;
            }
        }
    }

    //
    // We can skp this 'cause frame buffer caching is broken.
    //
    #if 0 
    #if DRIVER_5465
    {
        //
        // The 5465 Rev AA and Rev AB have a bug.
        // We must invalidate the frame buffer cache before direct 
        // frame buffer accesses will work correctly.
        // We do this with two DWORD reads of the frame buffer, 
        // 8 QWORDS apart.
        //
   
        DWORD temp;

        temp = * ((volatile DWORD *) (ppdev->pjScreen));
        temp = * ((volatile DWORD *) (ppdev->pjScreen+64));
        
    }
    #endif
    #endif

    return;
}

// meant to be called only from .asm routines - .c routines use SYNC_W_3D macro
VOID Sync_w_3d_proc(PPDEV ppdev)
{
    SYNC_W_3D(ppdev);
}


#if LOG_CALLS
// ============================================================================
//
//    Everything from here down is for data logging and is not used in the 
//    production driver.
//
// ============================================================================


// ****************************************************************************
//
// LogPaint()
// This routine is called only from DrvPaint()
// Dump information to a file about what is going on in DrvPaint land.
//
// ****************************************************************************
void LogSync(
	int   acc,
        PPDEV ppdev,
        int   count)
{
    char buf[256];
    int i;

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    i = sprintf(buf,"DrvSync: ");
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    switch(acc)
    {
	case 0: // Accelerated
	    i = sprintf(buf,"Wait %d Idle ",count);
	    break;

	case 1: // Punted
	    i = sprintf(buf, "Never idle ");
	    break;

	default:
 	    i = sprintf(buf, "PUNT unknown ");
	    break;

    }
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    i = sprintf(buf,"\r\n");
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\pointer.c ===
/***************************************************************************
*
*                ******************************************
*                * Copyright (c) 1995, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:	Laguna I (CL-GD5462) - 
*
* FILE:		pointer.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module contains the SW & HW curosr support for the
*           Laguna NT driver.
*
* MODULES:
*           DrvMovePointer()
*           DrvSetPointerShape()
*
* REVISION HISTORY:
*   6/20/95     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/POINTER.C  $
* 
*    Rev 1.39   Mar 04 1998 15:30:24   frido
* Added new shadow macros.
* 
*    Rev 1.38   Jan 19 1998 10:26:26   frido
* HP#86 (no PDR yet). Removed hardware cursor for 1600x1200 >=65Hz.
* 
*    Rev 1.37   Nov 03 1997 11:30:16   frido
* Added REQUIRE macros.
* 
*    Rev 1.36   23 Sep 1997 10:48:22   bennyn
* Not use HW cursor if the resolution is below 640x480
* 
*    Rev 1.35   11 Jun 1997 15:13:14   bennyn
* Fixed PDR 9747 Punt to SW cursor in 1600x1200x8 & x16 at 65,70,75 Hz
* 
*    Rev 1.34   11 Jun 1997 14:02:30   bennyn
* Fixed PDR 9741 (animated cursor turns back)
* 
*    Rev 1.33   28 May 1997 14:17:58   bennyn
* Fixed PDR 9741 and eliminated dead code
* 
*    Rev 1.32   01 May 1997 15:02:12   bennyn
* Punt the cursor if it is in interlace modes
* 
*    Rev 1.31   09 Apr 1997 10:53:36   SueS
* Changed type of pointer_switch to eliminate compiler warning.
* 
*    Rev 1.30   08 Apr 1997 15:22:50   SueS
* Don't use color for monochrome animated cursors - otherwise we'll 
* reference a NULL pointer.
* 
*    Rev 1.29   07 Apr 1997 12:44:50   BENNYN
* Added the checking ptrmaskhandle equal to NULL
* 
*    Rev 1.28   02 Apr 1997 14:24:14   noelv
* NT 35.1 wass accessing a NULL pointer in DrvMovePointer
* Removed SW cursor and chainblt cursor code 
* 
*    Rev 1.27   21 Mar 1997 13:37:44   noelv
* 
* Combined do_flag and sw_test_flag into pointer_switch
* 
*    Rev 1.26   03 Feb 1997 13:35:22   bennyn
* Modified the 5465 cursor algorithm
* 
*    Rev 1.25   30 Jan 1997 17:15:02   bennyn
* Added cursor algorithm for 5465
* 
*    Rev 1.24   17 Dec 1996 17:01:10   SueS
* Added test for writing to log file based on cursor at (0,0).
* 
*    Rev 1.23   10 Dec 1996 14:32:46   bennyn
* 
* Fixed cursor mask from device bitmap problem
* 
*    Rev 1.22   26 Nov 1996 10:43:04   SueS
* Changed WriteLogFile parameters for buffering.
* 
*    Rev 1.21   13 Nov 1996 17:00:52   SueS
* Changed WriteFile calls to WriteLogFile.
* 
*    Rev 1.20   01 Nov 1996 09:26:46   BENNYN
* 
* Cleanup unused code
* 
*    Rev 1.19   23 Oct 1996 14:44:44   BENNYN
* 
* Fixed the YUV cursor problems
* 
*    Rev 1.18   06 Sep 1996 09:07:02   noelv
* 
* Cleaned up NULL driver code.
* 
*    Rev 1.17   26 Aug 1996 17:35:08   bennyn
* 
* Restore the changes for the losed version
* 
*    Rev 1.16   20 Aug 1996 11:04:20   noelv
* Bugfix release from Frido 8-19-96
* 
*    Rev 1.3   17 Aug 1996 19:39:20   frido
* Fixed DirectDraw cursor problem.
* 
*    Rev 1.2   17 Aug 1996 13:34:56   frido
* New release from Bellevue.
* 
*    Rev 1.1   15 Aug 1996 11:40:18   frido
* Added precompiled header.
* 
*    Rev 1.0   14 Aug 1996 17:16:30   frido
* Initial revision.
* 
*    Rev 1.13   25 Jul 1996 15:56:00   bennyn
* 
* Modified to support DirectDraw
* 
*    Rev 1.12   18 Jun 1996 12:44:18   noelv
* Fixed the way interleave is calculated.
* 
*    Rev 1.11   28 May 1996 15:11:28   noelv
* Updated data logging.
* 
*    Rev 1.10   01 May 1996 12:23:30   bennyn
* 
*    Rev 1.9   01 May 1996 12:05:36   bennyn
* Fixed resolution change bug for NT4.0
* 
*    Rev 1.8   01 May 1996 11:00:48   bennyn
* 
* Modified for NT4.0
* 
*    Rev 1.7   04 Apr 1996 13:20:24   noelv
* Frido release 26
 * 
 *    Rev 1.4   28 Mar 1996 20:22:28   frido
 * Removed warning messages from new Bellevue release.
* 
*    Rev 1.6   25 Mar 1996 18:55:30   noelv
* Fixed bouncing screeen when cursor is disabled.
* 
*    Rev 1.5   08 Mar 1996 17:27:38   noelv
* 
* Added NULL_POINTER flag
* 
*    Rev 1.4   07 Mar 1996 18:22:46   bennyn
* 
* Removed read/modify/write on CONTROL reg
* 
*    Rev 1.3   05 Mar 1996 11:58:26   noelv
* Frido version 19
 * 
 *    Rev 1.1   20 Jan 1996 01:22:00   frido
 *  
* 
*    Rev 1.10   15 Jan 1996 16:59:58   NOELV
* AB workaround reductions
* 
*    Rev 1.9   11 Jan 1996 09:22:04   NOELV
* Removed al 16 bit writes to X,Y,and BLTEXT registers.
* 
*    Rev 1.8   10 Jan 1996 16:20:56   NOELV
* Added increased logging capabilities.
* Added null driver capabilities.
* 
*    Rev 1.7   29 Nov 1995 12:11:42   noelv
* 
* Coded a workaround for HW bug.  The screen corrupts sometimes when the curs
* I changed the code to turn the cursor off as little as possible.
* 
*    Rev 1.6   29 Sep 1995 10:26:20   bennyn
* 
* Punt the cursor to GDI for 1600x1200 modes
* 
*    Rev 1.5   29 Sep 1995 09:54:58   bennyn
* 
*    Rev 1.4   27 Sep 1995 16:45:40   bennyn
* Fixed the HW cursor AND mask
* 
*    Rev 1.3   26 Sep 1995 16:27:50   bennyn
* 
*    Rev 1.2   26 Sep 1995 09:35:16   bennyn
* Enable HW cursor
* 
*    Rev 1.1   21 Aug 1995 13:52:16   NOELV
* Initial port to real hardware.
* Converted all 32 bit register writes to 2 16 bit regiser writes.
* 
*    Rev 1.0   25 Jul 1995 11:19:28   NOELV
* Initial revision.
* 
*    Rev 1.6   06 Jul 1995 09:57:10   BENNYN
* 
* Fixed the problem switching between full-screen & Windowed DOS box
* 
*    Rev 1.5   29 Jun 1995 09:50:54   BENNYN
* Fixed the unsupport cursor request problem
* 
*    Rev 1.4   29 Jun 1995 09:01:30   BENNYN
* 
*    Rev 1.3   28 Jun 1995 11:13:32   BENNYN
* Fixed 16-bit/pixel problem
* 
*    Rev 1.2   22 Jun 1995 13:33:32   BENNYN
* 
* Added SW cursor auto BLT
* 
*    Rev 1.1   20 Jun 1995 16:09:30   BENNYN
* 
*
****************************************************************************
****************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/
#include "precomp.h"

/*----------------------------- DEFINES -----------------------------------*/
//#define DBGBRK
//#define DBGDISP
#define CURSOR_DBG_LEVEL 1

#define  MAX_CNT           0x7FFF
#define  BLT_FLAG_BIT      0x2L
#define  BYTES_PER_TILE    0x800  // 2048


/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/
typedef union _HOST_DATA {
    BYTE    bData[4];
    DWORD   dwData;
} HOST_DATA;


/*-------------------------- STATIC VARIABLES -----------------------------*/

/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/
VOID CopyLgHWPtrMaskData(PPDEV ppdev,
                         LONG  Ycord,
                         LONG  lSrcDelta,
                         LONG  cy,
                         ULONG tileszx,
                         BYTE  *pANDSrcScan,
                         BYTE  *pXORSrcScan);

ULONG ConvertMaskBufToLinearAddr(PPDEV ppdev);

VOID RestoreSaveShowCursor(PPDEV ppdev,
                           LONG  x,
                           LONG  y);

#if POINTER_SWITCH_ENABLED
    int pointer_switch=0;
#endif

#if LOG_QFREE
    unsigned long QfreeData[32];
#endif



/****************************************************************************
* FUNCTION NAME: InitPointerHW()
*
* DESCRIPTION:   Initialization the cursor palette colors.
*
****************************************************************************/
VOID InitPointerHW (PPDEV ppdev)
{
  ULONG   ultmp;

  // Enable HW cursor color access
  ultmp = LLDR_SZ (grPalette_State);
  ultmp |= 0x8;
  LL8 (grPalette_State, ultmp);

  // Write HW cursor BK & FG color
  ultmp = 0;
  LL8 (grPalette_Write_Address, ultmp);
  LL8 (grPalette_Data, ultmp);
  LL8 (grPalette_Data, ultmp);
  LL8 (grPalette_Data, ultmp);
  
  ultmp = 0xF;
  LL8 (grPalette_Write_Address, ultmp);

  ultmp = 0xFF;
  LL8 (grPalette_Data, ultmp);
  LL8 (grPalette_Data, ultmp);
  LL8 (grPalette_Data, ultmp);

  // Disable HW cursor color access
  ultmp = LLDR_SZ (grPalette_State);
  ultmp &= 0xFFF7;
  LL8 (grPalette_State, ultmp);
}



/****************************************************************************
* FUNCTION NAME: InitPointer()
*
* DESCRIPTION:   Initialization the variables used by the pointer.
*
* REVISION HISTORY:
*   6/20/95     Benny Ng      Initial version
****************************************************************************/
VOID InitPointer(PPDEV ppdev)
{
  ULONG   ultmp;
  SIZEL   reqsz;

  ppdev->PointerUsage = HW_CURSOR;
  DISPDBG((CURSOR_DBG_LEVEL, "HW cursor\n"));

  ppdev->bYUVuseSWPtr = FALSE;
  ppdev->PtrImageHandle = NULL;
  ppdev->PtrABltHandle = NULL;

  // Get the current tile size
  if (ppdev->lTileSize == (LONG) 128)
  {
     reqsz.cx = 128;  
     reqsz.cy = 8;
  }
  else if (ppdev->lTileSize == (LONG) 256)
  {
     reqsz.cx = 256;
     reqsz.cy = 4;
  }
  else
  {
     reqsz.cx = 1024;
     reqsz.cy = 1;
  };

  InitPointerHW (ppdev);

  // Allocate the mask buffer from offscreen memory
  DISPDBG((CURSOR_DBG_LEVEL, "Allocating Pointer Mask\n"));
  ppdev->PtrMaskHandle = AllocOffScnMem(ppdev, &reqsz, 0, NULL);

#ifdef WINNT_VER40
  ppdev->CShsem = NULL;
#endif
}



/****************************************************************************
* FUNCTION NAME: DrvMovePointer()
*
* DESCRIPTION:   This function Moves the hardware pointer to a new position.
*
* REVISION HISTORY:
*   6/20/95     Benny Ng      Initial version
****************************************************************************/
VOID DrvMovePointer(SURFOBJ *pso,
                    LONG     x,
                    LONG     y,
                    RECTL   *prcl)
{
    LONG  adjx, adjy;
    LONG  delaycnt = 0;

    PPDEV ppdev = (PPDEV) pso->dhpdev;

    if (x==0 && y==0)
    {
        // 
        // This isn't used in the released code.  This is test code for setting
        // the sw_test_flag to different values by pointing the cursor to 
        // 'special' places.  Used to turn different test features on and off.
        //
        #if (POINTER_SWITCH_ENABLED)
       	    if (pointer_switch)
                pointer_switch = 0;
            else
                pointer_switch = 1;
        #endif

   	    #if ENABLE_LOG_SWITCH && POINTER_SWITCH_ENABLED
       	    if (pointer_switch)
            {
                CreateLogFile(ppdev->hDriver, &ppdev->TxtBuffIndex);
                ppdev->pmfile = ppdev->hDriver;   // handle to the miniport
                lg_i = sprintf(lg_buf, "Log file opened\r\n");
                WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

            }
            else
   	           CloseLogFile(ppdev->pmfile, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
   	    #endif

        #if NULL_HW
            //
            // Enables and disables the "infinitly fast hardware" feature.
            // then "on" all register writes go to a chunk of blank memory 
            // on the host.  Register reads proceed normally.
            //
    	    if (ppdev->pLgREGS == ppdev->pLgREGS_real)
	        	ppdev->pLgREGS = (GAR *)ppdev->buffer;
	        else
    	    	ppdev->pLgREGS = ppdev->pLgREGS_real;
        #endif

        #if LOG_QFREE
        {
            int i;
            
            DISPDBG((CURSOR_DBG_LEVEL,"Dumping QFREE log.\n"));
            lg_i = sprintf(lg_buf,"\r\n\r\n");
            WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

            for (i=0; i<32; ++i)
            {
                lg_i = sprintf(lg_buf,"QFREE %d: %d times.\r\n", i, QfreeData[i]);
                WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
                QfreeData[i] = 0;
            }
        }
        #endif    
   	} // End if x==0 and y==0


    #if LOG_CALLS
        #if ENABLE_LOG_SWITCH
        if (pointer_switch)
        #endif
        {
            lg_i = sprintf(lg_buf,"DrvMovePointer: x=%d, y=%d \r\n", x, y);
            WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
        }
    #endif


    #if NULL_POINTER
        if (pointer_switch)	return;
    #endif

    if ((ppdev->PointerUsage == DEF_CURSOR) ||
        (ppdev->PtrMaskHandle == NULL))
		return;

    adjx = x;
    adjy = y;

    // Check whether want to hide the pointer.
    if (x == -1)
    {
	    #if HW_PRESET_BUG
            LL16 (grCursor_X, (WORD)0xFFFF);
            LL16 (grCursor_Y, (WORD)0xFFFF);
 	    #else
        	// Disable the Hw cursor by clearing the hw cursor enable
            // bit in CURSOR_CONTROL reg
            ultmp = LLDR_SZ (grCursor_Control);
            if (ultmp & 1)
            {
                ultmp &= 0xFFFE;
                LL16 (grCursor_Control, ultmp);
            }
	    #endif
    }

    else if ((adjx >= 0) && (adjy >= 0))
    {
	    // Restore the current pointer area screen image from offscreen memory.
     	// Save the new pointer area screen image to offscreen memory.
     	// Show the curosr using both AND and XOR masks
     	RestoreSaveShowCursor(ppdev, adjx, adjy);

     	ppdev->PtrX = adjx;
     	ppdev->PtrY = adjy;

        if (prcl != NULL)
        {
           	prcl->left = ppdev->PtrX;
          	prcl->top  = ppdev->PtrY;
          	prcl->right  = prcl->left + ppdev->PtrSzX;
          	prcl->bottom = prcl->top  + ppdev->PtrSzY;

 	        ppdev->prcl.left = prcl->left;
    	    ppdev->prcl.top  = prcl->top;
    	    ppdev->prcl.right = prcl->right;
    	    ppdev->prcl.bottom = prcl->bottom;
        }
    }
    return;
}



/****************************************************************************
* FUNCTION NAME: DrvSetPointerShape()
*
* DESCRIPTION:   This function sets the new pointer shape.
*
* REVISION HISTORY:
*   6/20/95     Benny Ng      Initial version
****************************************************************************/
ULONG DrvSetPointerShape(SURFOBJ  *pso,
                         SURFOBJ  *psoMask,
                         SURFOBJ  *psoColor,
                         XLATEOBJ *pxlo,
                         LONG      xHot,
                         LONG      yHot,
                         LONG      x,
                         LONG      y,
                         RECTL    *prcl,
                         FLONG     fl)
{

  BOOL    bAnimatedCursor = FALSE;
  LONG    lSrcDelta;
  ULONG   retul;
  ULONG   cx, cy;
  LONG    bpp;
  SIZEL   tilesz;
  SIZEL   reqsz;
  BYTE    *pANDSrcScan;
  BYTE    *pXORSrcScan;
  LONG    Ycord;
  ULONG   curloc;
  ULONG   ultmp;
  PPDEV   ppdev = (PPDEV) pso->dhpdev;

    #if NULL_POINTER
        if (pointer_switch)
		return SPS_ACCEPT_NOEXCLUDE;
    #endif
   
    DISPDBG((CURSOR_DBG_LEVEL, "DrvSetPointerShape %d, x=%d, y=%d, xHot=%d, yHot=%d\n",
           ppdev->PointerUsage, x, y, xHot, yHot));

    // If no HW cursor mask buffer allocated from offscreen memory,
    // or If in intrelace mode, Use SW cursor
    // Use SW cursor
    if ((ppdev->PtrMaskHandle == NULL) || (ppdev->ulFreq < 50))
       return (SPS_DECLINE);

    // HW cursor bug in 1600x1200-8bpp & 16bpp with refresh rate 65,
    // 70 or 75Hz. Use SW cursor
    if ((ppdev->cxScreen == 1600) && (ppdev->cyScreen == 1200) &&
        ((ppdev->ulBitCount == 8) || (ppdev->ulBitCount == 16)))
    {
       if (ppdev->ulFreq >= 65)
          return (SPS_DECLINE);
    };

    // Don't use HW cursor if resolution below 640x480
    if ((ppdev->cxScreen < 640) || (ppdev->cyScreen < 480))
       return (SPS_DECLINE);

    // Get dimensions of the pointer
    cx = psoMask->sizlBitmap.cx ;
    cy = psoMask->sizlBitmap.cy >> 1;

    // Calculate bytes per pixel
    bpp = ppdev->iBytesPerPixel;

    // Get the current tile size
    if (ppdev->lTileSize == (LONG) 128)
    {
        tilesz.cx = 128;	
	    tilesz.cy = 16;
    }
    else if (ppdev->lTileSize == (LONG) 256)
    {
        tilesz.cx = 256;
	    tilesz.cy = 8;
    }
    else
    {
        tilesz.cx = 2048;
	    tilesz.cy = 1;
    };

    lSrcDelta = psoMask->lDelta;
    retul = SPS_ACCEPT_NOEXCLUDE; // We can still draw while HW cursor is on the screen.

    // Check whether we should let the GDI handle the pointer
    if ((ppdev->PointerUsage == DEF_CURSOR) ||
        (psoMask == (SURFOBJ *) NULL)       ||
        (cx > HW_POINTER_DIMENSION)         ||
        (cy > (HW_POINTER_DIMENSION - 1))   ||
        (psoColor != NULL)       ||
        (fl & SPS_ASYNCCHANGE)	|| // We can't change the cursor shape while drawing.
        (fl & SPS_ANIMATESTART)	|| // We don't do animated cursors
        (fl & SPS_ANIMATEUPDATE) || // We don't do animated cursors
        !(fl & SPS_CHANGE))
    {
        bAnimatedCursor = TRUE;

	    #if HW_PRESET_BUG
            LL16 (grCursor_X, (WORD)0xFFFF);
            LL16 (grCursor_Y, (WORD)0xFFFF);
	    #else
            // Disable the Hw cursor by clearing the hw cursor enable
            // bit in CURSOR_CONTROL reg
            ultmp = LLDR_SZ (grCursor_Control);
            if (ultmp & 1)
            {
                ultmp &= 0xFFFE;
                LL16 (grCursor_Control, ultmp);
            }
	    #endif
    };

    // Save the position informations
    //
    ppdev->PtrXHotSpot = xHot;
    ppdev->PtrYHotSpot = yHot;
    ppdev->PtrSzX = cx;
    ppdev->PtrSzY = cy;

    // Setup the AND and XOR mask data pointer
    pANDSrcScan = psoMask->pvScan0;
    pXORSrcScan = psoMask->pvScan0;
    pXORSrcScan += (cy * lSrcDelta);

    // If animated cursor generate the XOR mask from psoColor->pvScan0
    // data
    if ((bAnimatedCursor) && (psoColor != NULL))
    {
       PDSURF  pDSURF;
       POFMHDL pOFMHDL;
       SURFOBJ*  pDsurfSo;
       BYTE  XorMaskBuf[130];
       BYTE  *pColorSrcScan;
       BYTE  maskval;
       LONG  ii, jj, kk, mm;
       BOOL  bCalc;

       bCalc = FALSE;
       pColorSrcScan = NULL;
       if (psoColor->pvScan0 != NULL)
       {
          // From host memory
          pColorSrcScan = psoColor->pvScan0;
       }
       else
       {
          // From device bitmap
          pDSURF  = (DSURF *) psoColor->dhsurf;
          pDsurfSo = (SURFOBJ*) pDSURF->pso;

          if (pDsurfSo != NULL)
          {
             pColorSrcScan = pDsurfSo->pvScan0;
          }
          else
          {
             pOFMHDL = (OFMHDL *) pDSURF->pofm;
             if (pOFMHDL != NULL)
             {
                bCalc = TRUE;
                pColorSrcScan = (BYTE *)((pOFMHDL->aligned_y * ppdev->lDeltaScreen) +
                                          pOFMHDL->aligned_x + (ULONG) ppdev->pjScreen);
             };  // endif (pOFMHDL != NULL)
          };  // endif (pDsurfSo != NULL)
       };  // endif (psoColor->pvScan0 != NULL)

       if (pColorSrcScan != NULL)
       {
          mm = 0;
          for (ii=0; ii < 0x20; ii++)
          {
            for (jj=0; jj < 0x4; jj++)
            {
              maskval = 0;
              for (kk=0; kk < 0x8; kk++)
              {
                maskval = maskval << 1;
   
                if ((*pColorSrcScan & 1) != 0)
                   maskval |= 0x1;
   
                pColorSrcScan += ppdev->iBytesPerPixel;
   
              };  // endfor kk
   
              XorMaskBuf[mm++] = maskval;
   
            };  // endfor jj

            if (bCalc)
            {
               pColorSrcScan = (BYTE *)(((pOFMHDL->aligned_y+ii) * ppdev->lDeltaScreen) +
                                          pOFMHDL->aligned_x + (ULONG) ppdev->pjScreen);
            };

          };  // endfor ii

          pXORSrcScan = &XorMaskBuf[0];

       };  // endif (pColorSrcScan != NULL)
    };  // endif (bAnimatedCursor)

    // Set Laguna Command Control Register SWIZ_CNTL bit
    ppdev->grCONTROL |= SWIZ_CNTL;
    LL16(grCONTROL, ppdev->grCONTROL);

    // Setup the laguna registers for byte to byte BLT extents
	REQUIRE(6);
    LL_DRAWBLTDEF(0x102000CC, 0);
    LL_OP1 (0,0);
    Ycord = ppdev->PtrMaskHandle->aligned_y;
    LL_OP0_MONO (ppdev->PtrMaskHandle->aligned_x, Ycord);

    // Use the AND and XOR mask to create the mask buffer for Laguna HW.
    CopyLgHWPtrMaskData(ppdev, Ycord, lSrcDelta, cy, tilesz.cx, pANDSrcScan, pXORSrcScan);

    // Set the HW cursor mask location register
    curloc = ConvertMaskBufToLinearAddr(ppdev);
    curloc = (curloc >> 8) & 0xFFFC;
    LL16 (grCursor_Location, curloc);

    // Clear Laguna Command Control Register SWIZ_CNTL bit
    ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
    LL16(grCONTROL, ppdev->grCONTROL);

    // Specific the exclude rectange
    if (prcl != NULL)
    {
       prcl->left = x - xHot;
       prcl->top  = y - yHot;
       prcl->right  = prcl->left + cx;
       prcl->bottom = prcl->top  + cy;

       ppdev->prcl.left = prcl->left;
       ppdev->prcl.top  = prcl->top;
       ppdev->prcl.right = prcl->right;
       ppdev->prcl.bottom = prcl->bottom;
    };

    if (bAnimatedCursor)
    {
        DISPDBG((CURSOR_DBG_LEVEL, "DrvSetPointerShape - SPS_DECLINE\n"));

        // Indicate use animiated cursor
        ppdev->bYUVuseSWPtr = TRUE;

        if (!ppdev->bYUVSurfaceOn)
            return (SPS_DECLINE);
    };

    if ((ppdev->bYUVuseSWPtr) && (x == -1) && (y == -1))
    {
	    #if HW_PRESET_BUG
            LL16 (grCursor_X, (WORD)0xFFFF);
            LL16 (grCursor_Y, (WORD)0xFFFF);
	    #else
            // Disable the Hw cursor by clearing the hw cursor enable
            // bit in CURSOR_CONTROL reg
            ultmp = LLDR_SZ (grCursor_Control);
            if (ultmp & 1)
            {
                ultmp &= 0xFFFE;
                LL16 (grCursor_Control, ultmp);
            }
	    #endif

       ppdev->bYUVuseSWPtr = FALSE;

       return (SPS_DECLINE);
    };

    // Enable the Hw cursor by setting the hw cursor enable
    // bit in CURSOR_CONTROL reg
    ultmp = LLDR_SZ (grCursor_Control);
    if ((ultmp & 1) == 0)
    {
       ultmp |= 0x0001;
       LL16 (grCursor_Control, ultmp);
    };

    // Indicate use HW cursor
    ppdev->bYUVuseSWPtr = FALSE;

    // Show the pointer by using the mask buffer
    DrvMovePointer(pso, x, y, prcl);

    return (retul);
}



/****************************************************************************
* FUNCTION NAME: CopyLgHWPtrMaskData()
*
* DESCRIPTION:   Using the AND & XOR source mask data to generate
*                a 64x64 bits pointer size mask buffer in the offscreen
*                memory for Laguna HW.
*
* REVISION HISTORY:
*   6/20/95     Benny Ng      Initial version
****************************************************************************/
VOID CopyLgHWPtrMaskData(PPDEV ppdev,
                         LONG  Ycord,
                         LONG  lSrcDelta,
                         LONG  cy,
                         ULONG tileszx,
                         BYTE  *pANDSrcScan,
                         BYTE  *pXORSrcScan)
{
  LONG       i, j, k;
  LONG       cnt;
  LONG       DWcnt;
  PDWORD     pPattern;
  LONG       TileSize;
  HOST_DATA  MaskPattern;

  pPattern = &MaskPattern.dwData;

  TileSize = ppdev->lTileSize;
  REQUIRE(3);
  LL_MBLTEXT (TileSize, (1024/TileSize));

  DWcnt = tileszx / sizeof(DWORD);

  // Copy the mask data into the 64x64 space with unused portion
  // fill with AND or XOR default mask value.
  cnt = DWcnt;
  k = 0;
  for (i=0; i < 64; i++)
  {
    // Copy XOR mask
    for (j=0; j < 8; j++)
    {
      // Copy one screen line mask data from source to destination
      if ((j < lSrcDelta) && (i < cy))
      {
         MaskPattern.bData[k++] = *pXORSrcScan;
         pXORSrcScan++;
      }
      else
      {
         MaskPattern.bData[k++] = 0x0;
      };
  
      if (k > 3)
      {
		 REQUIRE(1);
         LL32 (grHOSTDATA[0], *pPattern);

         k = 0;
         cnt--;
      };  // endif (k > 3)
    }; // endfor j

    // Copy AND mask
    for (j=0; j < 8; j++)
    {
      // Copy one screen line mask data from source to destination
      if ((j < lSrcDelta) && (i < cy))
      {
         MaskPattern.bData[k++] = *pANDSrcScan;
         pANDSrcScan++;
      }
      else
      {
         MaskPattern.bData[k++] = 0xFF;
      };
  
      if (k > 3)
      {
         *pPattern = ~ *pPattern;
		 REQUIRE(1);
         LL32 (grHOSTDATA[0], *pPattern);

         k = 0;
         cnt--;
      };  // endif (k > 3)
    }; // endfor j

    // Check whether one tile row size of host data is written to the
    // HOSTDATA register. 
    if (cnt == 0)
    {
       // Reset the row data count
       cnt = DWcnt;
    };  // endif (cnt == 0)
  }; // end for i
};
 


/****************************************************************************
* FUNCTION NAME: RestoreSaveShowCursor()
*
* DESCRIPTION:   Restore the screen image (if needed), save the new
*                cursor location the image to offscreen memory and
*                show the cursor in the new location
*
* REVISION HISTORY:
*   6/20/95     Benny Ng      Initial version
****************************************************************************/
VOID RestoreSaveShowCursor(PPDEV ppdev,
                           LONG  x,
                           LONG  y)
{
  ULONG  curloc;
  LONG   ltmpX, ltmpY;

  DISPDBG((CURSOR_DBG_LEVEL, "DrvMovePointer - RestoreSaveShowCursor\n"));

    ltmpX = x;
    ltmpY = y;

    // Set Hw cursor preset register
    curloc = 0;

    if ((ltmpY = (y - ppdev->PtrYHotSpot)) < 0)
    {
       curloc = (-ltmpY) & 0x7F;
       ltmpY = 0;
    }

    if ((ltmpX = (x - ppdev->PtrXHotSpot)) < 0)
    {
       curloc = curloc | (((-ltmpX) << 8) & 0x7F00);
       ltmpX = 0;
    }

    LL16 (grCursor_Preset, curloc);

    // Set Hw cursor X & Y registers
    LL16 (grCursor_X, (WORD)ltmpX);
    LL16 (grCursor_Y, (WORD)ltmpY);

    return;
}; 



/****************************************************************************
* FUNCTION NAME: ConvertMaskBufToLinearAddr()
*
* DESCRIPTION:   Convert the HW cursor mask buffer address to linear offset
*                address.
*
* Input:         Pointer to the OFMHDL structure.
*
* Output:        32-bits Linear address pointer.
*
* REVISION HISTORY:
*   6/12/95     Benny Ng      Initial version
****************************************************************************/
ULONG ConvertMaskBufToLinearAddr(PPDEV ppdev)
{
#if DRIVER_5465
  ULONG  Page;
  ULONG  Bank;
  ULONG  CurLoc;
  ULONG  DP;
#endif  // DRIVER_5465

  ULONG  retaddr;
  ULONG  xtile, ytile;
  ULONG  tileszx, tileszy;
  ULONG  tileno;
  ULONG  xByteOffset, yByteOffset;
  ULONG  bpp;
  ULONG  TilesPerLine, Interleave;

#ifdef DBGDISP
  DISPDBG((CURSOR_DBG_LEVEL, "ConvertMaskBufToLinearAddr\n"));
#endif

  // Calculate the linear address from the X & Y coordinate
  if ((ppdev->lTileSize == (LONG) 128) || (ppdev->lTileSize == (LONG) 256))
  {
    if (ppdev->lTileSize == (LONG) 128)
    {
        tileszx = 128;
        tileszy = 16;
    }
    else if (ppdev->lTileSize == (LONG) 256)
    {
        tileszx = 256;
        tileszy = 8;
    };

    Interleave = LLDR_SZ(grTILE_CTRL);
    TilesPerLine = Interleave & 0x3F;
    Interleave = ((Interleave >> 6) & 0x3);
    Interleave = 1 << Interleave;
     
    bpp = ppdev->ulBitCount/8;

    #if DRIVER_5465
         DP = TilesPerLine * tileszx;
         Page = (ppdev->PtrMaskHandle->aligned_y) /
                (tileszy * Interleave) * TilesPerLine +
                (ppdev->PtrMaskHandle->aligned_x/tileszx);

         Bank = (((ppdev->PtrMaskHandle->aligned_x / tileszx) +
                  (ppdev->PtrMaskHandle->aligned_y / tileszy)) % Interleave) +
                 ((Page/512) << (Interleave >> 1));

         Page = Page & 0x1FF;
       
         CurLoc = (Bank<<20) + (Page<<11) +
                  (ppdev->PtrMaskHandle->aligned_y % tileszy) * tileszx;
       
         retaddr = CurLoc;
    #else
         // calculate x tile coordinate and byte offset into tile due to x
         // xTileCoord  = x / TileWidth
         // xByteOffset = x % TileWidth

         xtile = ppdev->PtrMaskHandle->aligned_x / tileszx;
         xByteOffset = ppdev->PtrMaskHandle->aligned_x % tileszx;

         // calculate y tile coordinate and byte offset into tile due to y
         // yTileCoord  =  y / TileHeight
         // yByteOffset = (y % TileHeight) * TileWidth
         // byteOffset  = yByteOffset + xByteOffset

         ytile = ppdev->PtrMaskHandle->aligned_y / tileszy;
         yByteOffset = (ppdev->PtrMaskHandle->aligned_y % tileszy) * tileszx;

         // calculate tile number from start of RDRAM
         // (the LS 0,1,or 2 bits of this will become the bank selects based
         //	on interleave of 1,2,or 4)
         //
         //  tileNo = ((yTile / Interleave) * TilesPerLine) * Interleave
         //           + xTile * Interleave
         //	         + (yTile + xTile) % Interleave
         // (the "+xTile" takes care of interleave rotation)

         tileno = (((ytile / Interleave) * TilesPerLine) * Interleave)
                  + (xtile * Interleave)
                  + ((ytile + xtile) % Interleave);

         // calculate linear offset
         //   LinOffset = tileNo * BYTES_PER_TILE + xByteOffset + yByteOffset
         retaddr = (tileno * BYTES_PER_TILE) + xByteOffset + yByteOffset;
    #endif  // DRIVER_5465
  }
  else 
  {
     // Calculate the linear address from the X & Y coordinate
     retaddr = (ULONG) ppdev->PtrMaskHandle->aligned_x +
               (ULONG) ppdev->lDeltaScreen * ppdev->PtrMaskHandle->aligned_y;
  };

  return (retaddr);
};


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\i386\font.inc ===
;===============================================================================
;
;	$Workfile:   FONT.INC  $
;
;	Contents:
;	Include file for the font cache.
;
;	Copyright (c) 1996, Cirrus Logic, Inc.
;
;	$Log:   X:/log/laguna/nt35/displays/cl546x/i386/FONT.INC  $
; 
;    Rev 1.6   20 Aug 1996 11:28:58   noelv
; Bugfix release from Frido 8-19-96
; 
;    Rev 1.0   14 Aug 1996 17:14:34   frido
; Initial revision.
; 
;    Rev 1.5   25 Jul 1996 15:50:12   bennyn
; 
; Modified to support DirectDraw
; 
;    Rev 1.4   04 Apr 1996 13:22:20   noelv
; Frido version 26
;	
;	   Rev 1.1   25 Jan 1996 12:44:16   frido
;	Added ID counter in FONTCACHE structure.
;	
;	   Rev 1.0   24 Jan 1996 23:13:38   frido
;	 Initial release.
;
;===============================================================================

BYTES_PER_TILE		=		128
LINES_PER_TILE		=		16

CACHE_EXPAND_XPAR	=		105501F0h


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\screen.c ===
/******************************Module*Header*******************************\
 *
 * Module Name: screen.c
 *
 * Initializes the GDIINFO and DEVINFO structures for DrvEnablePDEV.
 *
 * Copyright (c) 1992 Microsoft Corporation
 * Copyright (c) 1995 Cirrus Logic, Inc.
 *
 * $Log:   X:/log/laguna/nt35/displays/cl546x/SCREEN.C  $
* 
*    Rev 1.68   Mar 04 1998 15:33:44   frido
* Added new shadow macros.
* 
*    Rev 1.67   Mar 04 1998 14:45:02   frido
* Added initialization of shadowFGCOLOR register.
* 
*    Rev 1.66   Feb 27 1998 17:00:46   frido
* Added zeroing of shadowQFREE register.
* 
*    Rev 1.65   Feb 03 1998 10:43:32   frido
* There was a (not yet reported) bug in the shadow registers. When the
* mode was reset after a DOS box the shadow registers need to be initialized.
* 
*    Rev 1.64   Dec 10 1997 13:32:20   frido
* Merged from 1.62 branch.
* 
*    Rev 1.63.1.0   Nov 14 1997 13:48:02   frido
* PDR#10750: Moved the allocation of the font cache down. It caused
* fragmentation of the off-screen memory heap in certain modes.
* 
*    Rev 1.63   Nov 04 1997 09:50:02   frido
* Added COLOR_TRANSLATE switches around hardware color translation code.
* 
*    Rev 1.62   Nov 03 1997 11:20:40   frido
* Added REQUIRE macros.
* 
*    Rev 1.61   12 Sep 1997 12:00:28   bennyn
* 
* Added PDEV and DRIVERDATA structure signature initialization.
* 
*    Rev 1.60   12 Aug 1997 16:55:46   bennyn
* Added DD scratch buffer allocation
* 
*    Rev 1.59   22 Jul 1997 12:32:52   bennyn
* 
* Added dwLgVenID to PDEV
* 
*    Rev 1.58   02 Jul 1997 15:57:12   noelv
* Added LgMatchDriverToChip() function.  Moved driver/chip match from bin
* from binitSurface to DrvEnablePdev()
* 
*    Rev 1.57   20 Jun 1997 13:38:16   bennyn
* 
* Eliminated power manager initialization
* 
*    Rev 1.56   16 Jun 1997 16:17:58   noelv
* Fixed conversion warning line 539
* 
*    Rev 1.55   23 May 1997 15:41:00   noelv
* 
* Added chip revision id to pdev
* 
*    Rev 1.54   15 May 1997 15:57:54   noelv
* 
* moved swat4 stuff to miniport
* 
*    Rev 1.53   29 Apr 1997 16:28:48   noelv
* 
* Merged in new SWAT code.
* SWAT: 
* SWAT:    Rev 1.5   24 Apr 1997 11:28:00   frido
* SWAT: NT140b09 merge.
* SWAT: 
* SWAT:    Rev 1.4   19 Apr 1997 16:40:26   frido
* SWAT: Added 4-way interleave.
* SWAT: Added Frame Buffer Bursting.
* SWAT: Added SWAT.h include file.
* SWAT: 
* SWAT:    Rev 1.3   18 Apr 1997 00:15:26   frido
* SWAT: NT140b07 merge.
* SWAT: 
* SWAT:    Rev 1.2   10 Apr 1997 14:09:00   frido
* SWAT: Added hardware optimizations SWAT4.
* SWAT: 
* SWAT:    Rev 1.1   09 Apr 1997 17:32:02   frido
* SWAT: Called vAssertModeText during first time initialization.
* 
*    Rev 1.52   23 Apr 1997 07:40:20   SueS
* Moved VS_CONTROL_HACK to laguna.h.  Send message to miniport to
* enable MMIO access to PCI registers before use.
* 
*    Rev 1.51   22 Apr 1997 11:03:54   noelv
* Changed chip detect to allow 5465 driver to load on 5465 and later chips.
* 
*    Rev 1.50   17 Apr 1997 14:40:24   noelv
* 
* Added hack for VS_CONTROL reg.
* 
*    Rev 1.49   07 Apr 1997 10:25:10   SueS
* Removed sw_test_flag and unreferenced #if USE_FLAG.
* 
*    Rev 1.48   19 Feb 1997 13:11:02   noelv
* 
* Moved brush cache invalidation to it's own function
* 
*    Rev 1.47   28 Jan 1997 11:14:16   noelv
* 
* Removed extra dword requirements from 5465 driver.
* 
*    Rev 1.46   28 Jan 1997 10:52:00   noelv
* 
* Match driver type to chip type.
* 
*    Rev 1.45   23 Jan 1997 17:22:28   bennyn
* 
* Added #ifdef DRIVER_5465
* 
*    Rev 1.44   16 Jan 1997 11:43:00   bennyn
* 
* Added power manager init call
* 
*    Rev 1.43   10 Dec 1996 13:30:10   bennyn
* 
* Added update the ulFreq in PDEV
* 
*    Rev 1.42   27 Nov 1996 11:32:40   noelv
* Disabled Magic Bitmap.  Yeah!!!
* 
*    Rev 1.41   18 Nov 1996 10:15:50   bennyn
* 
* Added grFormat to PDEV
* 
*    Rev 1.40   13 Nov 1996 16:59:38   SueS
* Changed WriteFile calls to WriteLogFile.
* 
*    Rev 1.39   13 Nov 1996 08:16:52   noelv
* 
* Added hooks for bus mastered host to screen.
* 
*    Rev 1.38   31 Oct 1996 11:15:16   noelv
* 
* Split common buffer into two buffers.
* 
*    Rev 1.37   24 Oct 1996 14:40:04   noelv
* 
* Get the loations of the bus master common buffer from the miniport.
* 
*    Rev 1.36   04 Oct 1996 16:53:24   bennyn
* Added DirectDraw YUV support
* 
*    Rev 1.35   18 Sep 1996 13:58:16   bennyn
* 
* Save the DeviceID into PDEV
* 
*    Rev 1.34   21 Aug 1996 16:43:38   noelv
* 
* Turned on the GoFast bit.
* 
*    Rev 1.33   20 Aug 1996 11:04:22   noelv
* Bugfix release from Frido 8-19-96
* 
*    Rev 1.2   17 Aug 1996 13:54:18   frido
* New release from Bellevue.
* 
*    Rev 1.1   15 Aug 1996 11:36:08   frido
* Added precompiled header.
* 
*    Rev 1.0   14 Aug 1996 17:16:30   frido
* Initial revision.
* 
*    Rev 1.31   25 Jul 1996 15:57:14   bennyn
* 
* Modified for DirectDraw
* 
*    Rev 1.30   11 Jul 1996 15:54:42   bennyn
* 
* Added DirectDraw support
* 
*    Rev 1.29   04 Jun 1996 16:00:00   noelv
* Added debug information.
* 
*    Rev 1.28   17 May 1996 12:56:08   bennyn
* 
* Fixed the problem NT40 allocate 400x90 twice
* 
*    Rev 1.27   16 May 1996 15:00:22   bennyn
* Add PIXEL_ALIGN to allocoffscnmem()
* 
*    Rev 1.26   13 May 1996 16:01:26   bennyn
* Fill ExtraDwordTable with 0 if 5464 is detected
* 
*    Rev 1.25   08 May 1996 17:02:58   noelv
* 
* Preallocate device bitmap
* 
*    Rev 1.24   08 May 1996 10:31:08   BENNYN
* 
* Added version display for NT4.0
* 
*    Rev 1.23   03 May 1996 15:18:58   noelv
* 
* Added switch to turn font caching off in low memory situations.
* Moved driver version to a header file.
* 
*    Rev 1.22   01 May 1996 11:01:28   bennyn
* 
* Modified for NT4.0
* 
*    Rev 1.21   25 Apr 1996 22:41:58   noelv
* clean-up
* 
*    Rev 1.20   16 Apr 1996 22:48:26   noelv
* label 3.5.17
* 
*    Rev 1.19   14 Apr 1996 11:49:06   noelv
* Optimized device to device xlate some.
* 
*    Rev 1.18   13 Apr 1996 17:57:52   noelv
* 
* 
*    Rev 1.17   12 Apr 1996 17:24:00   noelv
* I *knew* I should have skipped rev 13...
* 
*    Rev 1.16   12 Apr 1996 10:08:54   noelv
* 
* 
*    Rev 1.15   10 Apr 1996 14:15:04   NOELV
* 
* Made version 3.5.12
 * 
 *    Rev 1.17   08 Apr 1996 16:41:14   frido
 * Cleared brush cache on mode re-init.
 * 
 *    Rev 1.16   02 Apr 1996 09:12:02   frido
 * Bellevue lg102b04 release.
 * 
 *    Rev 1.15   28 Mar 1996 20:26:00   frido
 * New bellevue release.
 * 
 *    Rev 1.14   27 Mar 1996 13:12:32   frido
 * Added FILL support for all color resolutions.
 * 
 *    Rev 1.13   25 Mar 1996 12:07:44   frido
 * Removed warning message.
 * 
 *    Rev 1.12   25 Mar 1996 11:50:34   frido
 * Bellevue 102B03.
* 
*    Rev 1.9   20 Mar 1996 16:12:00   noelv
* Bumped rev
* 
*    Rev 1.8   15 Mar 1996 09:39:04   andys
* Bracketed BITMASK setting with set/clear of enable bit in DRAWDEF
* .
* 
*    Rev 1.7   14 Mar 1996 09:37:02   andys
* 
* Added code to calculate Tile Width in Pixels and SRAM Width in Pixels at 
* switch instead of each pass
* 
*    Rev 1.6   12 Mar 1996 15:46:14   noelv
* Added support file Stroke and Fill
* 
*    Rev 1.5   07 Mar 1996 18:23:14   bennyn
* 
* Removed read/modify/write on CONTROL reg
* 
*    Rev 1.4   06 Mar 1996 12:56:42   noelv
* 
* Set version number to 3.5.0
* 
*    Rev 1.3   05 Mar 1996 12:01:34   noelv
* Frido version 19
 * 
 *    Rev 1.10   26 Feb 1996 23:38:46   frido
 * Added initialization of new function pointers.
 * 
 *    Rev 1.9   17 Feb 1996 21:45:38   frido
 *  
 * 
 *    Rev 1.8   13 Feb 1996 16:50:24   frido
 * Changed the layout of the PDEV structure.
 * 
 *    Rev 1.7   10 Feb 1996 21:43:22   frido
 * Split monochrome and colored translation tables.
 * 
 *    Rev 1.6   08 Feb 1996 00:18:04   frido
 * Changed reinitialization of XLATE cache.
 * 
 *    Rev 1.5   05 Feb 1996 17:35:44   frido
 * Added translation cache.
 * 
 *    Rev 1.4   03 Feb 1996 13:43:18   frido
 * Use the compile switch "-Dfrido=0" to disable my extensions.
 * 
 *    Rev 1.3   25 Jan 1996 12:46:30   frido
 * Added initialization of dither cache and font counter ID after mode switch.
 * 
 *    Rev 1.2   20 Jan 1996 22:14:10   frido
 * Added GCAPS_DITHERONREALIZE.
 *
\**************************************************************************/

#include "precomp.h"
#include "version.h"
#include "clioctl.h"
#include "SWAT.h"		// SWAT optimizations.

VOID InitPointerHW (PPDEV ppdev);


#if !DRIVER_5465
    extern unsigned char ExtraDwordTable[1]; 
#endif

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,CLIP_STROKE_PRECIS,PROOF_QUALITY,VARIABLE_PITCH | FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,CLIP_STROKE_PRECIS,PROOF_QUALITY,FIXED_PITCH | FF_DONTCARE, L"Courier"}

// This is the basic devinfo for a default driver.  This is used as a base and customized based
// on information passed back from the miniport driver.

const DEVINFO gDevInfoFrameBuffer =
{
	GCAPS_OPAQUERECT                // flGraphicsCaps
#ifdef WINNT_VER40
   | GCAPS_DIRECTDRAW
#endif
	| GCAPS_DITHERONREALIZE
	| GCAPS_ALTERNATEFILL
	| GCAPS_WINDINGFILL
	| GCAPS_MONO_DITHER,
	SYSTM_LOGFONT,                  // lfDefaultFont
	HELVE_LOGFONT,                  // lfAnsiVarFont
	COURI_LOGFONT,                  // lfAnsiFixFont
	0,                                              // cFonts
	0,                                              // iDitherFotmat
	8,                                              // cxDither
	8,                                              // cyDither
	0                                               // hpalDefault
};

COPYFN DoHost8ToDevice;
COPYFN DoDeviceToHost8;
COPYFN DoHost16ToDevice;
COPYFN DoDeviceToHost16;
COPYFN DoHost24ToDevice;
COPYFN DoDeviceToHost24;
COPYFN DoHost32ToDevice;
COPYFN DoDeviceToHost32;

//
// Array of HostToScreen routines for each resolution.
// These host to screen functions use the HOSTDATA port.
//
COPYFN *afnHostToScreen[4] =
{
	DoHost8ToDevice,
	DoHost16ToDevice,
	DoHost24ToDevice,
	DoHost32ToDevice
};

//
// Array of ScreenToHost routines for eache resolution.
// These host to screen functions use the HOSTDATA port.
//
COPYFN *afnScreenToHost[4] =
{
	DoDeviceToHost8,
	DoDeviceToHost16,
	DoDeviceToHost24,
	DoDeviceToHost32
};


#if BUS_MASTER
    COPYFN BusMasterBufferedHost8ToDevice;

    //
    // Array of HostToScreen routines for each resolution.
    // These host to screen functions use bus mastering through a buffer.
    //
    COPYFN *afnBusMasterBufferedHostToScreen[4] =
    {
        BusMasterBufferedHost8ToDevice,
	    DoHost16ToDevice,
	    DoHost24ToDevice,
	    DoHost32ToDevice
    };
#endif


#define LG_SRAM_SIZE 120


/******************************Public*Routine******************************\
* bInitSURF
*
* Enables the surface.        Maps the frame buffer into memory.
*
\**************************************************************************/

BOOL bInitSURF(PPDEV ppdev, BOOL bFirst)
{
	WORD	DeviceID;

	DWORD returnedDataLength;
	VIDEO_MEMORY videoMemory;
	VIDEO_MEMORY_INFORMATION videoMemoryInformation;
	VIDEO_PUBLIC_ACCESS_RANGES   VideoAccessRanges[2];

        DISPDBG((1,"bInitSurf: Entry.\n"));

	if (!DEVICE_IO_CTRL(ppdev->hDriver,
			IOCTL_VIDEO_SET_CURRENT_MODE,
			&(ppdev->ulMode),
			sizeof(ULONG),
			NULL,
			0,
			&returnedDataLength,
			NULL))
	{
		RIP("DISP bInitSURF failed IOCTL_SET_MODE\n");
		return(FALSE);
	}

	// Initialize the shadow registers.
	ppdev->shadowFGCOLOR = 0xDEADBEEF;
	ppdev->shadowBGCOLOR = 0xDEADBEEF;
	ppdev->shadowDRAWBLTDEF = 0xDEADBEEF;
	ppdev->shadowQFREE = 0;

	//
	// If this is the first time we enable the surface we need to map in the
	// memory also.
	//
	if (bFirst)
	{

		videoMemory.RequestedVirtualAddress = NULL;

		if (!DEVICE_IO_CTRL(ppdev->hDriver,
							IOCTL_VIDEO_MAP_VIDEO_MEMORY,
							&videoMemory,
							sizeof(VIDEO_MEMORY),
							&videoMemoryInformation,
							sizeof(VIDEO_MEMORY_INFORMATION),
							&returnedDataLength,
							NULL))
		{
			RIP("DISP bInitSURF failed IOCTL_VIDEO_MAP_VIDEO_MEMORY.\n");
			return(FALSE);
		}

		ppdev->pjScreen = (PBYTE)(videoMemoryInformation.FrameBufferBase);
		ppdev->lTotalMem = videoMemoryInformation.FrameBufferLength;

                DISPDBG((1,"FrameBufferSize: %d.\n", ppdev->lTotalMem));


		//
		// Calculate start of off screen memory.
		//
		ppdev->pjOffScreen = ppdev->pjScreen +
				(ppdev->cxScreen * ppdev->cyScreen * (ppdev->iBytesPerPixel));


		//
		// Map graphics registers into memory.
		//

                DISPDBG((1,"bInitSurf:  Getting pointer to LgREGS from miniport.\n"));

		if (!DEVICE_IO_CTRL(ppdev->hDriver,
						 IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
						 NULL,                      // input buffer
						 0,
						 (PVOID) VideoAccessRanges, // output buffer
						 sizeof (VideoAccessRanges),
						 &returnedDataLength,
						 NULL))
		{
			RIP("bInitSURF - QUERY_PUBLIC_ACCESS_RANGES ioctl failed!\n");
			return (FALSE);
		}

		ppdev->pLgREGS = (GAR*) VideoAccessRanges[0].VirtualAddress;
		ppdev->pLgREGS_real = (GAR*) VideoAccessRanges[0].VirtualAddress;

                DISPDBG((1,"bInitSurf:  Got pointer to registers.\n"));

        //
        // Map common bus master data buffer.
        // If the chip can't do bus mastering, then the size of
        // the data buffer will be 0.
        //
        #if BUS_MASTER
        {
            // Must match structure in Miniport:CIRRUS.H
            struct {
                PVOID PhysAddress;
                PVOID VirtAddress;
                ULONG  Length;
            } CommonBufferInfo;

            DISPDBG((1,"bInitSurf:  Getting the common buffer.\n"));
            if (!DEVICE_IO_CTRL(ppdev->hDriver,
                IOCTL_CL_GET_COMMON_BUFFER,
                NULL,                        // Input buffer.
                0,
                &CommonBufferInfo,           // Output buffer.
                sizeof(CommonBufferInfo),
                &returnedDataLength,
                NULL))
            {
                RIP("bInitSURF - GET_COMMON_BUFFER ioctl failed!\n");
                return (FALSE);
            }

            //
            // Split the buffer in half and store it in the PDEV
            //
            ppdev->Buf1VirtAddr = CommonBufferInfo.VirtAddress;
            ppdev->Buf1PhysAddr = CommonBufferInfo.PhysAddress;
            ppdev->BufLength =    CommonBufferInfo.Length/2;

            ppdev->Buf2VirtAddr = ppdev->Buf1VirtAddr + ppdev->BufLength;
            ppdev->Buf2PhysAddr = ppdev->Buf1PhysAddr + ppdev->BufLength;


            DISPDBG((1,"bInitSurf:  Got the common buffer.\n"
                       "            Virtual:  0x%08X\n"
                       "            Physical: 0x%08X\n"
                       "            Length:   %d\n",
                     CommonBufferInfo.VirtAddress,
                     CommonBufferInfo.PhysAddress,
                     CommonBufferInfo.Length
            ));

           // ppdev->BufLength = 0;
        }
        #endif



        // DirectDraw initalization
        ppdev->DriverData.DrvSemaphore = 0;
        ppdev->DriverData.VideoSemaphore = 0;
        ppdev->DriverData.YUVTop  = 0;
        ppdev->DriverData.YUVLeft = 0;
        ppdev->DriverData.YUVXExt = 0;
        ppdev->DriverData.YUVYExt = 0;


		//
		// The following is "good practice" for GRX setup.
		//
                DISPDBG((1,"bInitSurf:  Beginning register init.\n"));
		REQUIRE(13);
		LL16(grOP0_opRDRAM.pt.X, 0);	//# Set host phase 0
		LL16(grOP1_opRDRAM.pt.X, 0);	//# Set host phase 0
		LL16(grOP2_opRDRAM.pt.X, 0);	//# Set host phase 0
		LL16(grOP0_opSRAM, 0);			//# Point to start of SRAM0
		LL16(grOP1_opSRAM, 0);			//# Point to start of SRAM1
		LL16(grOP2_opSRAM, 0);			//# Point to start of SRAM2
		LL16(grOP1_opMSRAM, 0);			//# Point to start of mono SRAM1
		LL16(grOP2_opMSRAM, 0);			//# Point to start of mono SRAM2
		LL16(grPATOFF.w, 0);			//# All patterns aligned to 0,0
		LL_BGCOLOR(0xFFFFFFFF, 0);		//# Background color is White
		LL_FGCOLOR(0x00000000, 0);		//# Foreground color is Black

        #if (VS_CONTROL_HACK && DRIVER_5465)
        {
           DWORD ReturnedDataLength;

           DISPDBG((1,"bInitSurf: Enable MMIO for PCI config regs.\n"));
           // Send message to miniport to enable MMIO access of PCI registers 
           if (!DEVICE_IO_CTRL(ppdev->hDriver,
                              IOCTL_VIDEO_ENABLE_PCI_MMIO,
                              NULL,
                              0,
                              NULL,
                              0,
                              &ReturnedDataLength,
                              NULL))
           {
             RIP("bInitSurf failed IOCTL_VIDEO_ENABLE_PCI_MMIO");
           }
        }
        #endif

        //
        // Get the chip ID.
        //
        ppdev->dwLgVenID = (DWORD) LLDR_SZ (grVendor_ID);
        DeviceID = (WORD) LLDR_SZ (grDevice_ID);
        ppdev->dwLgDevID = DeviceID;
        ppdev->dwLgDevRev = (DWORD) LLDR_SZ (grRevision_ID);

        #if !(DRIVER_5465)
            //
            // If it is not a 5462 chip, fill ExtraDwordTable with zero
            //
            if (ppdev->dwLgDevID != CL_GD5462)
            {
                memset(&ExtraDwordTable[0],      0, 0x8000);
                memset(&ExtraDwordTable[0x8000], 0, 0x8000);

                //
                // Turn on the GoFast(tm) bit (bit 7 of OP0_opSRAM).
                //
				REQUIRE(1);
                LL16(grOP0_opSRAM, 0x0080);
            }
        #endif

		// Bit 13 must be on for BITMASK to happen
		REQUIRE(4);
		LL16 (grDRAWDEF, LLDR_SZ(grDRAWDEF) | 0x2000);
		LL32 (grBITMASK.dw,0xFFFFFFFF);      //# Turn on all bits
		LL16 (grDRAWDEF, LLDR_SZ(grDRAWDEF) & ~0x2000);
                DISPDBG((1,"bInitSurf:  Register init complete.\n"));

		//
		// Get the tile size and offset_2D informations
		// *** Note: ***
		//    Temporary set, should read from Laguna OFFSET_2D register
		ppdev->lOffset_2D = 0;        
		ppdev->grFORMAT = (DWORD) LLDR_SZ (grFormat);
		ppdev->grCONTROL = (DWORD) LLDR_SZ (grCONTROL);
		ppdev->grVS_CONTROL = (DWORD) LLDR_SZ (grVS_Control);
		if (ppdev->grCONTROL & 0x1000)
		{
                        DISPDBG((1,"Tiling not enabled!\n"));
			return(FALSE);
		}
		ppdev->lTileSize = (ppdev->grCONTROL & 0x0800) ? 256 : 128;

		// Initialize Some variable for stroke and fill
		if (ppdev->iBytesPerPixel == 3)
		{
			ppdev->dcTileWidth = (USHORT) (ppdev->lTileSize / (ppdev->iBytesPerPixel + 1));
			ppdev->dcSRAMWidth = (USHORT) (LG_SRAM_SIZE / (ppdev->iBytesPerPixel + 1));
		}       
		else
		{
			ppdev->dcTileWidth = (USHORT) (ppdev->lTileSize / ppdev->iBytesPerPixel);
			ppdev->dcSRAMWidth = (USHORT) (LG_SRAM_SIZE / ppdev->iBytesPerPixel);
		}       


        //
        // HACK!!! for VS_CONTROL bit 0
        //
        #if (VS_CONTROL_HACK && DRIVER_5465)
        {
            DISPDBG((1,"bInitSurf: Disable MMIO for PCI config regs.\n"));
            ppdev->grVS_CONTROL &= 0xFFFFFFFE; // Clear bit 0
            LL32 (grVS_Control, ppdev->grVS_CONTROL);
        }
        #endif

		// Initialize the offscreen manager
		if (!InitOffScnMem(ppdev))
		{
                        DISPDBG((1,"bInitSurf: Fail off screen memory init. Exit.\n"));
			return(FALSE);
		}

      // Allocate a 1x(lDeltaScreen/bpp) block offscreen mem as
      // DD scratch buffer
      {
        DRIVERDATA* pDriverData = (DRIVERDATA*) &ppdev->DriverData;
        SIZEL  sizl;

        if (pDriverData->ScratchBufferOrg == 0)
        {
           sizl.cx = ppdev->lDeltaScreen/BYTESPERPIXEL;
           sizl.cy = 1;
           ppdev->DDScratchBufHandle = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);

           if (ppdev->DDScratchBufHandle != NULL)
           {
              pDriverData->ScratchBufferOrg = (DWORD) ((ppdev->DDScratchBufHandle->aligned_y << 16) |
                                                        ppdev->DDScratchBufHandle->aligned_x);
           };
        };
      }

		// Initialize the cursor information.
		InitPointer(ppdev);

		//
		// Initialize the brush cache.
		//
		vInitBrushCache(ppdev);

		#if COLOR_TRANSLATE
		//
		// Initialize the color translation cache.
		//
		vInitHwXlate(ppdev);
		#endif
		
		#if SWAT3
		// Enable font cache.
		vAssertModeText(ppdev, TRUE);
		#endif

        #if BUS_MASTER
        if (ppdev->BufLength != 0)
        {
		    ppdev->pfnHostToScreen =
			    afnBusMasterBufferedHostToScreen[ppdev->iBytesPerPixel - 1];
		    ppdev->pfnScreenToHost =
			    afnScreenToHost[ppdev->iBytesPerPixel - 1];
        }
        else
        #endif
        {
		    ppdev->pfnHostToScreen =
			    afnHostToScreen[ppdev->iBytesPerPixel - 1];
		    ppdev->pfnScreenToHost =
			    afnScreenToHost[ppdev->iBytesPerPixel - 1];
        }


	} // END bFirst

	else // The surface is being re-initialized for some reason.
	{    // Usually this means the user is switching back from a 
		 // full-screen DOS box back to Windows.
		
		int i;

        // get cursor HW going again
        InitPointerHW (ppdev);

		//
		// The following is "good practice" for GRX setup.
		//
		REQUIRE(13);
		LL16(grOP0_opRDRAM.pt.X, 0);	//# Set host phase 0
		LL16(grOP1_opRDRAM.pt.X, 0);	//# Set host phase 0
		LL16(grOP2_opRDRAM.pt.X, 0);	//# Set host phase 0
		LL16(grOP0_opSRAM, 0);			//# Point to start of SRAM0
		LL16(grOP1_opSRAM, 0);			//# Point to start of SRAM1
		LL16(grOP2_opSRAM, 0);			//# Point to start of SRAM2
		LL16(grOP1_opMSRAM, 0);			//# Point to start of mono SRAM1
		LL16(grOP2_opMSRAM, 0);			//# Point to start of mono SRAM2
		LL16(grPATOFF.w, 0);			//# All patterns aligned to 0,0
		LL_BGCOLOR(0xFFFFFFFF, 0);		//# Background color is White
		LL_FGCOLOR(0x00000000, 0);		//# Foreground color is Black (~FGC)

		// Bit 13 must be on for BITMASK to happen
		REQUIRE(4);
		LL16 (grDRAWDEF, LLDR_SZ(grDRAWDEF) | 0x2000);
		LL32 (grBITMASK.dw,0xFFFFFFFF);      //# Turn on all bits
		LL16 (grDRAWDEF, LLDR_SZ(grDRAWDEF) & ~0x2000);


		#if COLOR_TRANSLATE
        // Invalidate the color translation cache
        vInvalidateXlateCache(ppdev);
		#endif

		// Invalidate the brush cache.
        vInvalidateBrushCache(ppdev);

		// Invalidate all cached fonts.
		ppdev->ulFontCount++;

		// Release the pointer buffers
		if (ppdev->PtrImageHandle != NULL)
		{
		   FreeOffScnMem(ppdev, ppdev->PtrImageHandle);
		   ppdev->PtrImageHandle = NULL;
		};

		if (ppdev->PtrABltHandle != NULL)
		{
		   FreeOffScnMem(ppdev, ppdev->PtrABltHandle);
		   ppdev->PtrABltHandle = NULL;
		};

		ppdev->CursorHidden = TRUE;

	}

	#if HW_PRESET_BUG
	{
		ULONG ultmp;

		//
		// Enable the HW cursor once, then leave it on.
		// Turn it "off" by moving it off the screen.
		//
		LL16 (grCursor_X, (WORD)0xFFFF);
		LL16 (grCursor_Y, (WORD)0xFFFF);

		ultmp = LLDR_SZ (grCursor_Control);
		if ((ultmp & 1) == 0)
		{
			ultmp |= 0x0001;
			LL16 (grCursor_Control, ultmp);
		}
	}
	#endif
	
	//
	// Decide whether to use the font cache or not.
	// In low offscreen memory situations, we want to ensure we 
	// have enough off screen memory for device bitmaps.
	//
	ppdev->UseFontCache = 1; // Enable it.

	#if 0
	// Now disable it if we don't have much memory.
	if (ppdev->lTotalMem == 4*1024*1024) // 4 meg board.
	{
	    ; // Leave it enabled.
	}
	else if (ppdev->lTotalMem == 2*1024*1024) // 2 meg board.
	{
	    switch (ppdev->iBytesPerPixel)
	    {
		case 1: // 8 bpp, Lots of memory, leave it on.
		    break;         

		case 2: // 16 bpp.  
		    if (ppdev->cxScreen >= 1024)
			ppdev->UseFontCache = 1;
		    break;

		case 3: // 24 bpp
		    if (ppdev->cxScreen == 800)
			ppdev->UseFontCache = 0;
		    break;

		case 4: // 32 bpp. 
		    if (ppdev->cxScreen == 640)
			ppdev->UseFontCache = 0;
		    break; 
	    }
	}
	else if (ppdev->lTotalMem == 1*1024*1024) // 1 meg board.
	{
	    ; // leave it on.
	}
	else
	{
	    RIP("Error determining memory on board.\n");
	}
	#endif 


    #if WINBENCH96
	{
        //
	    // Pre allocate a small chunk of off screen memory for device bitmaps.
  	    // Otherwise the font cache quickly consumes all offscreen memory on
	    // 1 and 2 meg boards.
	    //
	    SIZEL  sizl;

		sizl.cx = MAGIC_SIZEX;
		sizl.cy = MAGIC_SIZEY;

		if (!ppdev->pofmMagic)
		{
                        DISPDBG((1,"Allocating magic bitmap.\n"));
			ppdev->pofmMagic =  AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);
			ppdev->bMagicUsed = 0;  // We've allocated it, but we haven't used it.
		};
	}
    #endif
	
        DISPDBG((1,"bInitSurf: Exit.\n"));
	return TRUE;
}

/******************************Public*Routine******************************\
* vDisableSURF
*
* Disable the surface. Un-Maps the frame in memory.
*
\**************************************************************************/

VOID vDisableSURF(PPDEV ppdev)
{
	DWORD returnedDataLength;
	VIDEO_MEMORY videoMemory;

        DISPDBG((1,"vDisableSURF:  Entry.\n"));

	videoMemory.RequestedVirtualAddress = (PVOID) ppdev->pjScreen;

	if (!DEVICE_IO_CTRL(ppdev->hDriver,
						IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
						&videoMemory,
						sizeof(VIDEO_MEMORY),
						NULL,
						0,
						&returnedDataLength,
						NULL))
	{
		RIP("DISP vDisableSURF failed IOCTL_VIDEO_UNMAP\n");
	}

        DISPDBG((1,"vDisableSurface:  Exit.\n"));

}


/******************************Public*Routine******************************\
* bInitPDEV
*
* Determine the mode we should be in based on the DEVMODE passed in.
* Query mini-port to get information needed to fill in the DevInfo and the
* GdiInfo .
*
\**************************************************************************/

BOOL bInitPDEV(
PPDEV ppdev,
DEVMODEW *pDevMode,
GDIINFO *pGdiInfo,
DEVINFO *pDevInfo)
{
	ULONG cModes;
	PVIDEO_MODE_INFORMATION pVideoBuffer, pVideoModeSelected, pVideoTemp;
	VIDEO_COLOR_CAPABILITIES colorCapabilities;
	ULONG ulTemp;
	BOOL bSelectDefault;
	ULONG cbModeSize;

	//
	// calls the miniport to get mode information.
	//

        DISPDBG((1,"bInitPDEV:  Entry.\n"));

	cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);

	if (cModes == 0)
	{
                DISPDBG((1,"bInitPDEV:  Exit. cModes==0.\n"));
		return(FALSE);
	}

	//
	// Determine if we are looking for a default mode.
	//

	if ( ((pDevMode->dmPelsWidth) ||
		  (pDevMode->dmPelsHeight) ||
		  (pDevMode->dmBitsPerPel) ||
		  (pDevMode->dmDisplayFlags) ||
		  (pDevMode->dmDisplayFrequency)) == 0)
	{
		bSelectDefault = TRUE;
	}
	else
	{
		bSelectDefault = FALSE;
	}

	//
	// Now see if the requested mode has a match in that table.
	//

	pVideoModeSelected = NULL;
	pVideoTemp = pVideoBuffer;

	while (cModes--)
	{
		if (pVideoTemp->Length != 0)
		{
			if (bSelectDefault ||
				((pVideoTemp->VisScreenWidth  == pDevMode->dmPelsWidth) &&
				 (pVideoTemp->VisScreenHeight == pDevMode->dmPelsHeight) &&
				 (pVideoTemp->BitsPerPlane *
				  pVideoTemp->NumberOfPlanes  == pDevMode->dmBitsPerPel) &&
				 ((pVideoTemp->Frequency  == pDevMode->dmDisplayFrequency) ||
					(pDevMode->dmDisplayFrequency == 0)) ) )
			{
				pVideoModeSelected = pVideoTemp;
				break;
			}
		}

		pVideoTemp = (PVIDEO_MODE_INFORMATION)
			(((PUCHAR)pVideoTemp) + cbModeSize);
	}

	//
	// If no mode has been found, return an error
	//

	if (pVideoModeSelected == NULL)
	{
		MEMORY_FREE(pVideoBuffer);
                DISPDBG((1,"DISP bInitPDEV failed - no valid modes\n"));
		return(FALSE);
	}

   // Fill in signature for PDEV and DriverData structures
   {
      DRIVERDATA* pDriverData = (DRIVERDATA*) &ppdev->DriverData;

      ppdev->signature = 0x12345678;
      pDriverData->signature = 0x9abcdef0;
   }

	//
	// Fill in the GDIINFO data structure with the information returned from
	// the kernel driver.
	//

	ppdev->ulFreq = pVideoModeSelected->Frequency;
	ppdev->ulMode = pVideoModeSelected->ModeIndex;
	ppdev->cxScreen = pVideoModeSelected->VisScreenWidth-OFFSCREEN_COLS;
	ppdev->cyScreen = pVideoModeSelected->VisScreenHeight-OFFSCREEN_LINES;
	ppdev->cxMemory = pVideoModeSelected->VideoMemoryBitmapWidth;
	ppdev->cyMemory = pVideoModeSelected->VideoMemoryBitmapHeight;
	ppdev->ulBitCount = pVideoModeSelected->BitsPerPlane *
						pVideoModeSelected->NumberOfPlanes;
	ppdev->lDeltaScreen = pVideoModeSelected->ScreenStride;
	ppdev->iBytesPerPixel = ppdev->ulBitCount/8;


        DISPDBG((1, "DISP bInitPDEV: Screen size = %d x %d.\n",ppdev->cxScreen,ppdev->cyScreen));
        DISPDBG((1, "DISP bInitPDEV: Color depth = %d bpp.\n",ppdev->ulBitCount));
        DISPDBG((1, "DISP bInitPDEV: Screen Delta = %d bpp.\n",ppdev->lDeltaScreen));

	ppdev->flRed = pVideoModeSelected->RedMask;
	ppdev->flGreen = pVideoModeSelected->GreenMask;
	ppdev->flBlue = pVideoModeSelected->BlueMask;

	// pGdiInfo->ulVersion    = 0x1019;    // Our driver is verion 3.5.00

#ifdef WINNT_VER40
	pGdiInfo->ulVersion    = GDI_DRIVER_VERSION | (VER_REV & 0xFF);
#else
	pGdiInfo->ulVersion    = (((VER_MAJ) & 0xF) << 12) |
				 (((VER_MIN) & 0xF) << 8 ) | 
				 (((VER_REV) & 0xFFFF)   ) ;
#endif

	pGdiInfo->ulTechnology = DT_RASDISPLAY;
	pGdiInfo->ulHorzSize   = pVideoModeSelected->XMillimeter;
	pGdiInfo->ulVertSize   = pVideoModeSelected->YMillimeter;

	pGdiInfo->ulHorzRes        = ppdev->cxScreen;
	pGdiInfo->ulVertRes        = ppdev->cyScreen;

#ifdef WINNT_VER40
	pGdiInfo->ulPanningHorzRes = ppdev->cxScreen;
	pGdiInfo->ulPanningVertRes = ppdev->cyScreen;
#else
	pGdiInfo->ulDesktopHorzRes = ppdev->cxScreen;
	pGdiInfo->ulDesktopVertRes = ppdev->cyScreen;
#endif

	pGdiInfo->cBitsPixel       = pVideoModeSelected->BitsPerPlane;
	pGdiInfo->cPlanes          = pVideoModeSelected->NumberOfPlanes;
	pGdiInfo->ulVRefresh       = pVideoModeSelected->Frequency;
	pGdiInfo->ulBltAlignment   = 0; // We have accelerated screen-to-screen.

	pGdiInfo->ulLogPixelsX = pDevMode->dmLogPixels;
	pGdiInfo->ulLogPixelsY = pDevMode->dmLogPixels;

	pGdiInfo->flTextCaps = TC_RA_ABLE;

	pGdiInfo->flRaster = 0;           // flRaster is reserved by DDI

	pGdiInfo->ulDACRed   = pVideoModeSelected->NumberRedBits;
	pGdiInfo->ulDACGreen = pVideoModeSelected->NumberGreenBits;
	pGdiInfo->ulDACBlue  = pVideoModeSelected->NumberBlueBits;

	pGdiInfo->ulAspectX    = 0x24;    // One-to-one aspect ratio
	pGdiInfo->ulAspectY    = 0x24;
	pGdiInfo->ulAspectXY   = 0x33;

	pGdiInfo->xStyleStep   = 1;       // A style unit is 3 pels
	pGdiInfo->yStyleStep   = 1;
	pGdiInfo->denStyleStep = 3;

	pGdiInfo->ptlPhysOffset.x = 0;
	pGdiInfo->ptlPhysOffset.y = 0;
	pGdiInfo->szlPhysSize.cx  = 0;
	pGdiInfo->szlPhysSize.cy  = 0;

	// RGB and CMY color info.

	// try to get it from the miniport.
	// if the miniport doesn ot support this feature, use defaults.

	if (!DEVICE_IO_CTRL(ppdev->hDriver,
						 IOCTL_VIDEO_QUERY_COLOR_CAPABILITIES,
						 NULL,
						 0,
						 &colorCapabilities,
						 sizeof(VIDEO_COLOR_CAPABILITIES),
						 &ulTemp,
						 NULL))
	{

                DISPDBG((1, "DISP getcolorCapabilities failed \n"));

		pGdiInfo->ciDevice.Red.x = 6700;
		pGdiInfo->ciDevice.Red.y = 3300;
		pGdiInfo->ciDevice.Red.Y = 0;
		pGdiInfo->ciDevice.Green.x = 2100;
		pGdiInfo->ciDevice.Green.y = 7100;
		pGdiInfo->ciDevice.Green.Y = 0;
		pGdiInfo->ciDevice.Blue.x = 1400;
		pGdiInfo->ciDevice.Blue.y = 800;
		pGdiInfo->ciDevice.Blue.Y = 0;
		pGdiInfo->ciDevice.AlignmentWhite.x = 3127;
		pGdiInfo->ciDevice.AlignmentWhite.y = 3290;
		pGdiInfo->ciDevice.AlignmentWhite.Y = 0;

		pGdiInfo->ciDevice.RedGamma = 20000;
		pGdiInfo->ciDevice.GreenGamma = 20000;
		pGdiInfo->ciDevice.BlueGamma = 20000;

	}
	else
	{
		pGdiInfo->ciDevice.Red.x = colorCapabilities.RedChromaticity_x;
		pGdiInfo->ciDevice.Red.y = colorCapabilities.RedChromaticity_y;
		pGdiInfo->ciDevice.Red.Y = 0;
		pGdiInfo->ciDevice.Green.x = colorCapabilities.GreenChromaticity_x;
		pGdiInfo->ciDevice.Green.y = colorCapabilities.GreenChromaticity_y;
		pGdiInfo->ciDevice.Green.Y = 0;
		pGdiInfo->ciDevice.Blue.x = colorCapabilities.BlueChromaticity_x;
		pGdiInfo->ciDevice.Blue.y = colorCapabilities.BlueChromaticity_y;
		pGdiInfo->ciDevice.Blue.Y = 0;
		pGdiInfo->ciDevice.AlignmentWhite.x = colorCapabilities.WhiteChromaticity_x;
		pGdiInfo->ciDevice.AlignmentWhite.y = colorCapabilities.WhiteChromaticity_y;
		pGdiInfo->ciDevice.AlignmentWhite.Y = colorCapabilities.WhiteChromaticity_Y;

		// if we have a color device store the three color gamma values,
		// otherwise store the unique gamma value in all three.

		if (colorCapabilities.AttributeFlags & VIDEO_DEVICE_COLOR)
		{
			pGdiInfo->ciDevice.RedGamma = colorCapabilities.RedGamma;
			pGdiInfo->ciDevice.GreenGamma = colorCapabilities.GreenGamma;
			pGdiInfo->ciDevice.BlueGamma = colorCapabilities.BlueGamma;
		}
		else
		{
			pGdiInfo->ciDevice.RedGamma = colorCapabilities.WhiteGamma;
			pGdiInfo->ciDevice.GreenGamma = colorCapabilities.WhiteGamma;
			pGdiInfo->ciDevice.BlueGamma = colorCapabilities.WhiteGamma;
		}

	};

	pGdiInfo->ciDevice.Cyan.x = 0;
	pGdiInfo->ciDevice.Cyan.y = 0;
	pGdiInfo->ciDevice.Cyan.Y = 0;
	pGdiInfo->ciDevice.Magenta.x = 0;
	pGdiInfo->ciDevice.Magenta.y = 0;
	pGdiInfo->ciDevice.Magenta.Y = 0;
	pGdiInfo->ciDevice.Yellow.x = 0;
	pGdiInfo->ciDevice.Yellow.y = 0;
	pGdiInfo->ciDevice.Yellow.Y = 0;

	// No dye correction for raster displays.

	pGdiInfo->ciDevice.MagentaInCyanDye = 0;
	pGdiInfo->ciDevice.YellowInCyanDye = 0;
	pGdiInfo->ciDevice.CyanInMagentaDye = 0;
	pGdiInfo->ciDevice.YellowInMagentaDye = 0;
	pGdiInfo->ciDevice.CyanInYellowDye = 0;
	pGdiInfo->ciDevice.MagentaInYellowDye = 0;

	pGdiInfo->ulDevicePelsDPI = 0;   // For printers only
	pGdiInfo->ulPrimaryOrder = PRIMARY_ORDER_CBA;

        // This should be modified to take into account the size
	// of the display and the resolution.

	pGdiInfo->ulHTPatternSize = HT_PATSIZE_4x4_M;

	pGdiInfo->flHTFlags = HT_FLAG_ADDITIVE_PRIMS;

	// Fill in the basic devinfo structure

	*pDevInfo = gDevInfoFrameBuffer;

	// Fill in the rest of the devinfo and GdiInfo structures.

	if (ppdev->ulBitCount == 8)
	{
		// It is Palette Managed.

		pGdiInfo->ulNumColors = 20;
		pGdiInfo->ulNumPalReg = 1 << ppdev->ulBitCount;

		pDevInfo->flGraphicsCaps |= GCAPS_PALMANAGED | GCAPS_COLOR_DITHER;

		pGdiInfo->ulHTOutputFormat = HT_FORMAT_8BPP;
		pDevInfo->iDitherFormat = BMF_8BPP;

		// Assuming palette is orthogonal - all colors are same size.

		ppdev->cPaletteShift   = 8 - pGdiInfo->ulDACRed;
	}
	else
	{
		pGdiInfo->ulNumColors = (ULONG) (-1);
		pGdiInfo->ulNumPalReg = 0;

		if (ppdev->ulBitCount == 16)
		{
			pGdiInfo->ulHTOutputFormat = HT_FORMAT_16BPP;
			pDevInfo->iDitherFormat = BMF_16BPP;
		}
		else if (ppdev->ulBitCount == 24)
		{
			pGdiInfo->ulHTOutputFormat = HT_FORMAT_24BPP;
			pDevInfo->iDitherFormat = BMF_24BPP;
		}
		else
		{
			pGdiInfo->ulHTOutputFormat = HT_FORMAT_32BPP;
			pDevInfo->iDitherFormat = BMF_32BPP;
		}
	}

	MEMORY_FREE(pVideoBuffer);
        DISPDBG((1,"bInitPDEV:  Exit.\n"));
	return(TRUE);
}


/******************************Public*Routine******************************\
* getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

DWORD getAvailableModes(
HANDLE hDriver,
PVIDEO_MODE_INFORMATION *modeInformation,
DWORD *cbModeSize)
{
	ULONG ulTemp;
	VIDEO_NUM_MODES modes;
	PVIDEO_MODE_INFORMATION pVideoTemp;

	//
	// Get the number of modes supported by the mini-port
	//

        DISPDBG((1,"getAvailableModes:  Entry.\n"));

	if (!DEVICE_IO_CTRL(hDriver,
			IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
			NULL,
			0,
			&modes,
			sizeof(VIDEO_NUM_MODES),
			&ulTemp,
			NULL))
	{
                DISPDBG((1, "framebuf.dll getAvailableModes failed VIDEO_QUERY_NUM_AVAIL_MODES\n"));
		return(0);
	}

	*cbModeSize = modes.ModeInformationLength;

	//
	// Allocate the buffer for the mini-port to write the modes in.
	//

	*modeInformation = (PVIDEO_MODE_INFORMATION)
#ifdef WINNT_VER40
						MEM_ALLOC(FL_ZERO_MEMORY,
								   modes.NumModes *
								   modes.ModeInformationLength, ALLOC_TAG);
#else
						MEM_ALLOC(LMEM_FIXED | LMEM_ZEROINIT,
								   modes.NumModes *
								   modes.ModeInformationLength);
#endif

	if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
	{
                DISPDBG((1, "framebuf.dll getAvailableModes failed LocalAlloc\n"));

		return 0;
	}

	//
	// Ask the mini-port to fill in the available modes.
	//

	if (!DEVICE_IO_CTRL(hDriver,
			IOCTL_VIDEO_QUERY_AVAIL_MODES,
			NULL,
			0,
			*modeInformation,
			modes.NumModes * modes.ModeInformationLength,
			&ulTemp,
			NULL))
	{

                DISPDBG((1, "framebuf.dll getAvailableModes failed VIDEO_QUERY_AVAIL_MODES\n"));

		MEMORY_FREE(*modeInformation);
		*modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

		return(0);
	}

	//
	// Now see which of these modes are supported by the display driver.
	// As an internal mechanism, set the length to 0 for the modes we
	// DO NOT support.
	//

	ulTemp = modes.NumModes;
	pVideoTemp = *modeInformation;

	//
	// Mode is rejected if it is not one plane, or not graphics, or is not
	// one of 8, 16 or 32 bits per pel.
	//

	while (ulTemp--)
	{
		if ((pVideoTemp->NumberOfPlanes != 1 ) ||
			!(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
			((pVideoTemp->BitsPerPlane != 8) &&
			 (pVideoTemp->BitsPerPlane != 16) &&
			 (pVideoTemp->BitsPerPlane != 24) &&
			 (pVideoTemp->BitsPerPlane != 32)))
		{
			pVideoTemp->Length = 0;
		}

		pVideoTemp = (PVIDEO_MODE_INFORMATION)
			(((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
	}

        DISPDBG((1,"getAvailableModes:  Exit.\n"));

	return modes.NumModes;

}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\stroke.c ===
/******************************Module*Header*******************************\
*
* $Workfile:   STROKE.C  $
*
* Handle DrvStrokePath routine.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1997 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/STROKE.C  $
*
*    Rev 1.17   Mar 04 1998 15:35:34   frido
* Added new shadow macros.
*
*    Rev 1.16   Nov 03 1997 10:20:44   frido
* Added REQUIRE macros.
*
\**************************************************************************/


#include "precomp.h"
#define STROKE_DBG_LEVEL 1

#if LOG_CALLS
    void LogStrokePath(
        ULONG     acc,
        PPDEV     ppdev,
        CLIPOBJ*   pco,
        BRUSHOBJ*  pbo,
        MIX        mix,
        LINEATTRS* pla,
        PATHOBJ*   ppo
        );
#else
    #define LogStrokePath(acc, ppdev, pco, pbo, mix, pla, ppo)
#endif

VOID (*gapfnStrip[])(PDEV*, STRIP*, LINESTATE*) = {
    vrlSolidHorizontal,
    vrlSolidVertical,
    NULL,
    NULL,

// Should be NUM_STRIP_DRAW_DIRECTIONS = 4 strip drawers in every group

    vrlSolidHorizontal,
    vrlSolidVertical,
    NULL,
    NULL,

// Should be NUM_STRIP_DRAW_STYLES = 8 strip drawers in total for doing
// solid lines, and the same number for non-solid lines:

    vStripStyledHorizontal,
    vStripStyledVertical,
    NULL,       // Diagonal goes here
    NULL,       // Diagonal goes here

    vStripStyledHorizontal,
    vStripStyledVertical,
    NULL,       // Diagonal goes here
    NULL,       // Diagonal goes here
};

// Style array for alternate style (alternates one pixel on, one pixel off):

STYLEPOS gaspAlternateStyle[] = { 1 };

extern BYTE Rop2ToRop3[];

USHORT mixToBLTDEF[] =
{
        0x1000,         //0  R2_WHITE 1
        0x1000,         //1  R2_BLACK 0
        0x1107,         //2  DPon
        0x1107,         //3  DPna
        0x1007,         //4  PN
        0x1107,         //5  PDna
        0x1100,         //6  Dn
        0x1107,         //7  DPx
        0x1107,         //8  DPan
        0x1107,         //9  DPa
        0x1107,         //A  DPxn
        0x1100,         //B  D
        0x1107,         //C  DPno
        0x1007,         //D  P
        0x1107,         //E  PDno
        0x1107,         //F  DPo
};


/******************************Public*Routine******************************\
* BOOL DrvStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix)
*
* Strokes the path.
*
\**************************************************************************/
BOOL DrvStrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)
{
    STYLEPOS  aspLtoR[STYLE_MAX_COUNT];
    STYLEPOS  aspRtoL[STYLE_MAX_COUNT];
    LINESTATE ls;
    PFNSTRIP* apfn;
    FLONG     fl;
    PDEV*     ppdev;
    RECTL     arclClip[4];                  // For rectangular clipping
    DWORD     color;

    #if NULL_STROKE
    {
        if (pointer_switch)     return(TRUE);
    }
    #endif

    DISPDBG((STROKE_DBG_LEVEL,"DrvStrokePath: Entry %x.\n", mix));
    ppdev = (PDEV*) pso->dhpdev;

    SYNC_W_3D(ppdev);

    if (pso->iType == STYPE_DEVBITMAP)
    {
        PDSURF pdsurf = (PDSURF) pso->dhsurf;
        if ( pdsurf->pso && !bCreateScreenFromDib(ppdev, pdsurf) )
        {
            LogStrokePath(4,ppdev, pco, pbo, mix, pla, ppo);
            return(EngStrokePath(pdsurf->pso, ppo, pco, pxo, pbo,
                                                 pptlBrush, pla, mix));
        }
        ppdev->ptlOffset = pdsurf->ptl;
    }
    else
    {
        ppdev->ptlOffset.x = ppdev->ptlOffset.y = 0;
    }
    // Convert to 3 OP ROP
    ppdev->uRop = Rop2ToRop3[mix & 0xF];
    ppdev->uBLTDEF = mixToBLTDEF[mix & 0x0F];

    //
    // Get the device ready:
    //
    ASSERTMSG(pbo,"Null brush in SrvStrokePath!\n");
    color = pbo->iSolidColor; // & 0x00000000FF; // Clear upper 24 bits.
    ASSERTMSG((color !=0xFFFFFFFF),"DrvStrokePath got a Pattern!\n");

    switch (ppdev->ulBitCount)
    {
        case 8: // For 8 bpp duplicate byte 0 into bytes 1,2,3.
            color =  (color << 8)  | (color & 0xFF);

        case 16: // For 16 bpp, duplicate the low word into the high word.
            color =  ((color << 16) | (color & 0xFFFF));

        default:
            break;
    }


    DISPDBG((STROKE_DBG_LEVEL,"DrvStrokePath: Set Color %x.\n", color));
    REQUIRE(2);
    LL_BGCOLOR(color, 2);

    fl = 0;

    // Check line style.
    if (pla->fl & LA_ALTERNATE)
    {
        ls.cStyle      = 1;
        ls.spTotal     = 1;
        ls.spTotal2    = 2;
        ls.spRemaining = 1;
        ls.aspRtoL     = &gaspAlternateStyle[0];
        ls.aspLtoR     = &gaspAlternateStyle[0];
        ls.spNext      = HIWORD(pla->elStyleState.l);
        ls.xyDensity   = 1;
        fl            |= FL_STYLED;
        ls.ulStartMask = 0L;
    }

    // Is it styled or solid?
    else if (pla->pstyle != (FLOAT_LONG*) NULL)
    {
        // Styled.

        PFLOAT_LONG pstyle;
        STYLEPOS*   pspDown;
        STYLEPOS*   pspUp;

        pstyle = &pla->pstyle[pla->cstyle];

        ls.xyDensity = STYLE_DENSITY;
        ls.spTotal   = 0;
        while (pstyle-- > pla->pstyle)
        {
            ls.spTotal += pstyle->l;
        }
        ls.spTotal *= STYLE_DENSITY;
        ls.spTotal2 = 2 * ls.spTotal;

        // Compute starting style position
        // (this is guaranteed not to overflow):

        ls.spNext = HIWORD(pla->elStyleState.l) * STYLE_DENSITY +
                    LOWORD(pla->elStyleState.l);

        fl        |= FL_STYLED;
        ls.cStyle  = pla->cstyle;
        ls.aspRtoL = aspRtoL;
        ls.aspLtoR = aspLtoR;

        if (pla->fl & LA_STARTGAP)
            ls.ulStartMask = 0xffffffffL;
        else
            ls.ulStartMask = 0L;

        pstyle  = pla->pstyle;
        pspDown = &ls.aspRtoL[ls.cStyle - 1];
        pspUp   = &ls.aspLtoR[0];

        while (pspDown >= &ls.aspRtoL[0])
        {
            *pspDown = pstyle->l * STYLE_DENSITY;
            *pspUp   = *pspDown;

            pspUp++;
            pspDown--;
            pstyle++;
        }
    }

    apfn = &gapfnStrip[NUM_STRIP_DRAW_STYLES *
                            ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT)];

    // Set up to enumerate the path:

    if (pco->iDComplexity != DC_COMPLEX)
    {
        PATHDATA  pd;
        RECTL*    prclClip = (RECTL*) NULL;
        BOOL      bMore;
        ULONG     cptfx;
        POINTFIX  ptfxStartFigure;
        POINTFIX  ptfxLast;
        POINTFIX* pptfxFirst;
        POINTFIX* pptfxBuf;

        if (pco->iDComplexity == DC_RECT)
        {
            fl |= FL_SIMPLE_CLIP;

            arclClip[0]        =  pco->rclBounds;

            // FL_FLIP_D:

            arclClip[1].top    =  pco->rclBounds.left;
            arclClip[1].left   =  pco->rclBounds.top;
            arclClip[1].bottom =  pco->rclBounds.right;
            arclClip[1].right  =  pco->rclBounds.bottom;

            // FL_FLIP_V:

            arclClip[2].top    = -pco->rclBounds.bottom + 1;
            arclClip[2].left   =  pco->rclBounds.left;
            arclClip[2].bottom = -pco->rclBounds.top + 1;
            arclClip[2].right  =  pco->rclBounds.right;

            // FL_FLIP_V | FL_FLIP_D:

            arclClip[3].top    =  pco->rclBounds.left;
            arclClip[3].left   = -pco->rclBounds.bottom + 1;
            arclClip[3].bottom =  pco->rclBounds.right;
            arclClip[3].right  = -pco->rclBounds.top + 1;

            prclClip = arclClip;
        } // End DC_RECT

        pd.flags = 0;

        do {
            bMore = PATHOBJ_bEnum(ppo, &pd);

            cptfx = pd.count;
            if (cptfx == 0)
            {
                break;
            }

            if (pd.flags & PD_BEGINSUBPATH)
            {
                ptfxStartFigure  = *pd.pptfx;
                pptfxFirst       = pd.pptfx;
                pptfxBuf         = pd.pptfx + 1;
                cptfx--;
            }
            else
            {
                pptfxFirst       = &ptfxLast;
                pptfxBuf         = pd.pptfx;
            }

            if (pd.flags & PD_RESETSTYLE)
                ls.spNext = 0;

            if (cptfx > 0)
            {
                if (!bLines(ppdev,
                            pptfxFirst,
                            pptfxBuf,
                            (RUN*) NULL,
                            cptfx,
                            &ls,
                            prclClip,
                            apfn,
                            fl))
                {
                    LogStrokePath(2, ppdev, pco, pbo, mix, pla, ppo);
                    return(FALSE);
                }
            }

            ptfxLast = pd.pptfx[pd.count - 1];

            if (pd.flags & PD_CLOSEFIGURE)
            {
                if (!bLines(ppdev,
                            &ptfxLast,
                            &ptfxStartFigure,
                            (RUN*) NULL,
                            1,
                            &ls,
                            prclClip,
                            apfn,
                            fl))
                {
                    LogStrokePath(2, ppdev, pco, pbo, mix, pla, ppo);
                    return(FALSE);
                }
            }
        } while (bMore);

        if (fl & FL_STYLED)
        {
            // Save the style state:

            ULONG ulHigh;
            ULONG ulLow;

            // Masked styles don't normalize the style state.  It's a good
            // thing to do, so let's do it now:

            if ((ULONG) ls.spNext >= (ULONG) ls.spTotal2)
                ls.spNext = (ULONG) ls.spNext % (ULONG) ls.spTotal2;

            ulHigh = ls.spNext / ls.xyDensity;
            ulLow  = ls.spNext % ls.xyDensity;

            pla->elStyleState.l = MAKELONG(ulLow, ulHigh);
        }
    } // End non complex clipping.

    else // clipping is DC_COMPLEX
    {
        // Local state for path enumeration:

        BOOL bMore;
        union {
            BYTE     aj[offsetof(CLIPLINE, arun) + RUN_MAX * sizeof(RUN)];
            CLIPLINE cl;
        } cl;

        fl |= FL_COMPLEX_CLIP;

        // We use the clip object when non-simple clipping is involved:

        PATHOBJ_vEnumStartClipLines(ppo, pco, pso, pla);

        do {
            bMore = PATHOBJ_bEnumClipLines(ppo, sizeof(cl), &cl.cl);
            if (cl.cl.c != 0)
            {
                if (fl & FL_STYLED)
                {
                    ls.spComplex = HIWORD(cl.cl.lStyleState) * ls.xyDensity
                                 + LOWORD(cl.cl.lStyleState);
                }
                if (!bLines(ppdev,
                            &cl.cl.ptfxA,
                            &cl.cl.ptfxB,
                            &cl.cl.arun[0],
                            cl.cl.c,
                            &ls,
                            (RECTL*) NULL,
                            apfn,
                            fl))
                {
                    LogStrokePath(2, ppdev, pco, pbo, mix, pla, ppo);
                    return(FALSE);
                }
            }
        } while (bMore);
    }

    DISPDBG((STROKE_DBG_LEVEL,"DrvStrokePath: Exit.\n"));

    LogStrokePath(0, ppdev, pco, pbo, mix, pla, ppo);
    return(TRUE);
}


#if LOG_CALLS

extern long lg_i;
extern char lg_buf[256];

void LogStrokePath(
ULONG     acc,
PPDEV     ppdev,
CLIPOBJ*   pco,
BRUSHOBJ*  pbo,
MIX        mix,
LINEATTRS* pla,
PATHOBJ*   ppo
)
{
    BYTE iDComplexity;

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    lg_i = sprintf(lg_buf,"DSP: ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    // Did we realize it?  If not, why?
    switch (acc)
    {
        case  0: lg_i = sprintf(lg_buf,"(ACCL) ");                  break;
        case  2: lg_i = sprintf(lg_buf,"(Punt - bLines failed) ");  break;
        case  3: lg_i = sprintf(lg_buf,"(Punt - S3) ");             break;
        case  4: lg_i = sprintf(lg_buf,"(Punt - DevBmp on host) "); break;
        default: lg_i = sprintf(lg_buf,"(STATUS UNKNOWN) ");        break;
    }
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    //
    // Check the type of clipping.
    //
    iDComplexity = (pco ? pco->iDComplexity : DC_TRIVIAL);
    lg_i = sprintf(lg_buf,"C=%s ",
                (iDComplexity==DC_TRIVIAL ? "T":
                (iDComplexity == DC_RECT ? "R" : "C" )));
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);


    //
    // Check the brush
    //
    if (pbo)
      if (pbo->iSolidColor == 0xFFFFFFFF )
        lg_i = sprintf(lg_buf,"BR=P ");
      else
        lg_i = sprintf(lg_buf,"BR=0x%X ",(pbo->iSolidColor));
    else
        lg_i = sprintf(lg_buf,"BR=N ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    //
    // Check the MIX
    //
    lg_i = sprintf(lg_buf,"MIX = 0x%04X   ", mix);
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    //
    // Check the Line Attrs
    //
    if      (pla->fl & LA_GEOMETRIC)    lg_i = sprintf(lg_buf,"LA=G ");
    else if (pla->fl & LA_ALTERNATE)    lg_i = sprintf(lg_buf,"LA=A ");
    else if (pla->fl & LA_STARTGAP)     lg_i = sprintf(lg_buf,"LA=S ");
    else                                lg_i = sprintf(lg_buf,"LA=U ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);


    if      (pla->iJoin == JOIN_ROUND)  lg_i = sprintf(lg_buf,"J=R ");
    else if (pla->iJoin == JOIN_BEVEL)  lg_i = sprintf(lg_buf,"J=B ");
    else if (pla->iJoin == JOIN_MITER)  lg_i = sprintf(lg_buf,"J=M ");
    else                                lg_i = sprintf(lg_buf,"J=U ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);


    if      (pla->iEndCap == ENDCAP_ROUND)  lg_i = sprintf(lg_buf,"E=R ");
    else if (pla->iEndCap == ENDCAP_SQUARE) lg_i = sprintf(lg_buf,"E=S ");
    else if (pla->iEndCap == ENDCAP_BUTT)   lg_i = sprintf(lg_buf,"E=B ");
    else                                    lg_i = sprintf(lg_buf,"E=U ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);


    if (pla->pstyle == NULL)  lg_i = sprintf(lg_buf,"SOLID ");
    else                      lg_i = sprintf(lg_buf,"STYLED ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);


    lg_i = sprintf(lg_buf,"\r\n");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\stretch.c ===
/****************************************************************************
*****************************************************************************
*
*                ******************************************
*                * Copyright (c) 1995, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:  Laguna I (CL-GD5462) - 
*
* FILE:     stretch.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module implements the DrvStretchBlt() function for the
*           Laguna NT driver.
*
* MODULES:
*           AdjustSrcSize()
*           bRectIntersect()
*           cRectIntersect()
*           Shrink()
*           Stretch()
*           CopySrcToOffMem()
*           bStretchDIB()
*           HandleCase_1()
*           DrvStretchBlt()
*
* REVISION HISTORY:
*   7/11/95     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/STRETCH.C  $
* 
*    Rev 1.14   Nov 03 1997 11:10:48   frido
* Added REQUIRE and WRITE_STRING macros.
* 
*    Rev 1.13   08 Apr 1997 12:29:06   einkauf
* 
* add SYNC_W_3D to coordinate MCD/2D access
* 
*    Rev 1.12   21 Mar 1997 12:22:16   noelv
* Combined "do_flag" and "sw_test_flag" together into "pointer_switch"
* 
*    Rev 1.11   07 Mar 1997 10:15:58   SueS
* Handle NULL pointer in DrvStretchBlt.
* 
*    Rev 1.10   06 Sep 1996 15:16:40   noelv
* Updated NULL driver for 4.0
* 
*    Rev 1.9   20 Aug 1996 11:04:26   noelv
* Bugfix release from Frido 8-19-96
* 
*    Rev 1.1   15 Aug 1996 11:39:42   frido
* Added precompiled header.
* 
*    Rev 1.0   14 Aug 1996 17:16:30   frido
* Initial revision.
* 
*    Rev 1.8   16 May 1996 15:01:40   bennyn
* 
* Add PIXEL_ALIGN to allocoffscnmem()
* 
*    Rev 1.7   04 Apr 1996 13:20:28   noelv
* No change.
* 
*    Rev 1.6   15 Mar 1996 09:40:00   andys
* 
* Removed BITMASK setting from code
* 
*    Rev 1.5   13 Mar 1996 11:11:20   bennyn
* Added device bitmap support
* 
*    Rev 1.4   07 Mar 1996 18:23:50   bennyn
* 
* Removed read/modify/write on CONTROL reg
* 
*    Rev 1.3   05 Mar 1996 11:59:10   noelv
* Frido version 19
 * 
 *    Rev 1.1   20 Jan 1996 01:16:50   frido
 *  
* 
*    Rev 1.5   10 Jan 1996 16:11:12   NOELV
* Added NULL driver ability.
* 
*    Rev 1.4   18 Oct 1995 14:09:06   NOELV
* 
* Fixed the mess I made of STRETCH.C  I was writing to the BLT extents instea
* 
*    Rev 1.3   18 Oct 1995 12:10:26   NOELV
* 
* Reworked register writes.
* punted 16,24, and 32 bpp
* 
*    Rev 1.2   06 Oct 1995 13:50:26   bennyn
* 
*    Rev 1.1   22 Aug 1995 16:40:38   bennyn
* 
*    Rev 1.3   15 Aug 1995 11:27:28   bennyn
* 
*    Rev 1.2   07 Aug 1995 08:02:34   bennyn
* 
*    Rev 1.1   02 Aug 1995 12:13:04   bennyn
* 
*    Rev 1.0   11 Jul 1995 15:14:16   BENNYN
* Initial revision.
* 
****************************************************************************
****************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/
#include "precomp.h"

/*----------------------------- DEFINES -----------------------------------*/
//#define PUNTBRK
//#define DBGBRK
#define DBGDISP
#define OPTION_1
//#define OPTION_2
//#define OPTION_3

#define X_INTERP_ENABLE        0x1
#define Y_INTERP_ENABLE        0x2
#define X_SHRINK_ENABLE        0x4
#define Y_SHRINK_ENABLE        0x8

#define _32K                   32768
#define SF                     0x10000L


/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/
typedef union _HOST_DATA {
    BYTE    bData[4];
    DWORD   dwData;
} HOST_DATA;


/*-------------------------- STATIC VARIABLES -----------------------------*/

/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/



/****************************************************************************
* FUNCTION NAME: AdjustSrcSize()
*
* DESCRIPTION:   If the destination rectange is changed due to the clipping,
*                the source rectange size need to proportional change.
*                This routine handles the source size change calcualtion.
*
* RETURN:        TRUE: Punt it.
*
* REVISION HISTORY:
*   7/27/95     Benny Ng      Initial version
****************************************************************************/
BOOL AdjustSrcSize(LONG dx,
                   LONG dy,
                   LONG origdx,
                   LONG origdy,
                   LONG dszX,
                   LONG dszY,
                   LONG origdszX,
                   LONG origdszY,
                   LONG *sszX,
                   LONG *sszY,
                   LONG *XsrcOff,
                   LONG *YsrcOff)
{
  LONG ratioX, ratioY;
  LONG ltemp;
  UINT orig_sszX, orig_sszY;

  BOOL bpuntit = FALSE;

  BOOL bStretchX = FALSE;
  BOOL bStretchY = FALSE;

  orig_sszX = *sszX;
  orig_sszY = *sszY;

  // -------------------------------------------------------
  // Calculate the source to destination size ratio
  if (*sszX < origdszX)
  {
     ratioX = (origdszX * SF) / *sszX;
     bStretchX = TRUE;
  }
  else
  {
     ratioX = (*sszX * SF) / origdszX;
  };

  if (*sszY < origdszY)
  {
     ratioY = (origdszY * SF) / *sszY;
     bStretchY = TRUE;
  }
  else
  {
     ratioY = (*sszY * SF) / origdszY;
  };

  // -------------------------------------------------------
  // Calculate the source X offset
  if (origdx != dx)
  {
     if (bStretchX)
        ltemp = ((dx - origdx) * SF) / ratioX;
     else
        ltemp = ((dx - origdx) * ratioX) / SF;

     *XsrcOff = ltemp;
  };

  // Calculate the source X size change
  if (origdszX != dszX)
  {
     if (bStretchX)
        ltemp = ((origdszX - dszX) * SF) / ratioX;
     else
        ltemp = ((origdszX - dszX) * ratioX) / SF;

     *sszX = *sszX - ltemp;
  };

  // -------------------------------------------------------
  // Calculate the source Y offset
  if (origdy != dy)
  {
     if (bStretchY)
        ltemp = ((dy - origdy) * SF) / ratioY;
     else
        ltemp = ((dy - origdy) * ratioY) / SF;

     *YsrcOff = ltemp;
  };

  // Calculate the source Y size change
  if (origdszY != dszY)
  {
     if (bStretchY)
        ltemp = ((origdszY - dszY) * SF) / ratioY;
     else
        ltemp = ((origdszY - dszY) * ratioY) / SF;

     *sszY = *sszY - ltemp;
  };

  #ifdef DBGDISP
    DISPDBG((1, "AdjustSrcSize - bpuntit= %x, ratioX=%d, ratioY=%d\n",
           bpuntit, ratioX, ratioY));
    DISPDBG((1, "dx=%d, dy=%d, origdx=%d, origdy=%d,\n",
               dx, dy, origdx, origdy));
    DISPDBG((1, "dszX=%d, dszY=%d, origdszX=%d, origdszY=%d,\n",
               dszX, dszY, origdszX, origdszY));
    DISPDBG((1, "*sszX=%d, *sszY=%d, orig_sszX=%d, orig_sszY=%d,\n",
               *sszX, *sszY, orig_sszX, orig_sszY));
    DISPDBG((1, "*XsrcOff=%d, *YsrcOff=%d\n", *XsrcOff, *YsrcOff));
  #endif

  #ifdef DBGBRK
    DbgBreakPoint();
  #endif

  return(bpuntit);
}



/****************************************************************************
* FUNCTION NAME: bRectIntersect()
*
* DESCRIPTION:   If 'prcl1' and 'prcl2' intersect, has a return value of
*                TRUE and returns the intersection in 'prclResult'.
*                If they don't intersect, has a return value of FALSE,
*                and 'prclResult' is undefined.
*
* RETURN:        TRUE: Rectange intersect.
*
* REVISION HISTORY:
*   8/01/95     Benny Ng      Initial version
\**************************************************************************/
BOOL bRectIntersect(RECTL*  prcl1,
                    RECTL*  prcl2,
                    RECTL*  prclResult)
{
  prclResult->left  = max(prcl1->left,  prcl2->left);
  prclResult->right = min(prcl1->right, prcl2->right);

  if (prclResult->left < prclResult->right)
  {
     prclResult->top    = max(prcl1->top,    prcl2->top);
     prclResult->bottom = min(prcl1->bottom, prcl2->bottom);

     if (prclResult->top < prclResult->bottom)
        return(TRUE);
  };

  return(FALSE);
}


/****************************************************************************
* FUNCTION NAME: cRectIntersect()
*
* DESCRIPTION:   This routine takes a list of rectangles from 'prclIn'
*                and clips them in-place to the rectangle 'prclClip'.
*                The input rectangles don't have to intersect 'prclClip';
*                the return value will reflect the number of input rectangles
*                that did intersect, and the intersecting rectangles will
*                be densely packed.
*
* RETURN:        TRUE: Rectange intersect.
*
* REVISION HISTORY:
*   8/01/95     Benny Ng      Initial version
\**************************************************************************/
LONG cRectIntersect(RECTL*  prclClip,
                    RECTL*  prclIn,      // List of rectangles
                    LONG    c)           // Can be zero
{
  LONG    cIntersections;
  RECTL*  prclOut;

  cIntersections = 0;
  prclOut = prclIn;

  for (; c != 0; prclIn++, c--)
  {
    prclOut->left  = max(prclIn->left,  prclClip->left);
    prclOut->right = min(prclIn->right, prclClip->right);

    if (prclOut->left < prclOut->right)
    {
       prclOut->top    = max(prclIn->top,    prclClip->top);
       prclOut->bottom = min(prclIn->bottom, prclClip->bottom);

       if (prclOut->top < prclOut->bottom)
       {
          prclOut++;
          cIntersections++;
       };
    };
  }

  return(cIntersections);
}



/****************************************************************************
* FUNCTION NAME: Shrink()
*
* DESCRIPTION:   This function calculates the parameters for shrink BLT
*                operation.
*
* REVISION HISTORY:
*   7/18/95     Benny Ng      Initial version
****************************************************************************/
VOID Shrink(PPDEV ppdev,
            LONG  lSrc,
            LONG  lDst,
            char  chCoord,
            ULONG LnCntl,
            LONG *sShrinkInc)
{
  LONG  maj = 0;
  LONG  min = 0;
  LONG  accum = 0;
    
  // Set SHRINKINC value,
  //   for y, SHRINKINC = ratio of src/dst
  //   for x, SHRINKINC = ratio of src/dst if not interpolating
  //          SHRINKINC = (ratio of src/dst minus one) if interpolating
  // low byte for x coordinate
  // high byte for y coordinate
  if (chCoord == 'X')
  {
     *sShrinkInc |= (lSrc / lDst);
     if (LnCntl & X_INTERP_ENABLE)
        sShrinkInc--;
  }
  else
  {
     *sShrinkInc |= ((lSrc / lDst) << 8);
  };

  // Compute ACCUM_?, MAJ_? and MIN_? values
  // MAJ_? = width (for x) or height (for y) of destination
  // MIN_? = negative of the remainder of src/dst
  // ACCUM_? = MAJ_? - 1 - ( Src%Dst / (shrink factor + 1))
  maj = lDst;
  min = -(lSrc % lDst);
  accum = maj - 1 - ((lSrc % lDst) / ((lSrc / lDst) + 1)) ;

  if (chCoord == 'X')
  {
	 REQUIRE(3);
     LL16 (grMAJ_X, maj);
     LL16 (grMIN_X, min);
     LL16 (grACCUM_X, accum);
  }
  else
  {
	 REQUIRE(3);
     LL16 (grMAJ_Y, maj);
     LL16 (grMIN_Y, min);
     LL16 (grACCUM_Y, accum);
  };

  #ifdef DBGBRK
    DISPDBG((1, "DrvStretchBlt - shrink\n"));
    DbgBreakPoint();
  #endif
}
    

/****************************************************************************
* FUNCTION NAME: Stretch()
*
* DESCRIPTION:   This function calculates the parameters for stretch BLT
*                operation.
*
* REVISION HISTORY:
*   7/18/95     Benny Ng      Initial version
****************************************************************************/
VOID Stretch(PPDEV ppdev,
             LONG lSrc,
             LONG lDst,
             char chCoord,
             ULONG LnCntl)
{ 
  LONG  min = 0;
  LONG  maj = 0;
  LONG  accum = 0;
    
  // For interpolated stretches registers values differ from values for
  // replicated stretches
  if (((chCoord == 'X') && ((LnCntl & X_INTERP_ENABLE) == 0)) ||
      ((chCoord == 'Y') && ((LnCntl & Y_INTERP_ENABLE) == 0)))
  {
     // Compute ACCUM_?, MAJ_? and MIN_? for replicated stretch
     //   MAJ_? = width (for x) or height (for y) of destination
     //   MIN_? = negative of width (for x) or height (for y) of source
     //   ACCUM_? = MAJ_? - 1 - ( Dst%Src / (stretch factor    + 1))
     maj = lDst;
     min = -lSrc;
     accum = maj - 1 - ((lDst % lSrc) / ((lDst / lSrc) + 1));
  }
  else
  {
     // Compute ACCUM_?, MAJ_? and MIN_? for interpolated stretch
     // Interpolated strecthes use bits 13 & 14 of ACCUM_? to determine
     // whether to use pixel A, 3/4 A + 1/4 B, 1/2 A + 1/2 B or
     // 1/4 A + 3/4 B.
     // To set DDA values appropriately there are three choices.
     // 1) Set MAJ_? to 32k and scale MIN_? to keep ratio approximately
     //    correct
     //      MAJ_? = 32k
     //      MIN_? = (negative of ratio of src/dst) scaled up to 32k
     //      ACCUM_? = MAJ_? - 1 - (1/2 * Absolute difference of MAJ and MIN)
     //
     // 2) Scale both src and dst appropriately such that the ratio of
     //    src/dst is preserved exactly.
     //    Note: In the following, the division is performed first thus
     //          there is a possiblity of a rounding error which shows the
     //          difference between options 1 & 2.
     //      MAJ_? = (32k / dst) * dst
     //      MIN_? = (32k / dst) * src
     //      ACCUM_? = MAJ_? - 1 - (1/2 * Absolute difference of MAJ and MIN)
     //
     // 3) Scale both SRC and Dest in such a manner as to force the last
     //    pixels output on a line to match the last source pixels rather
     //    than the last source interpolated with the pixel past the end
     //    of the line. Option 3 is used here.
     //    NOTE: Options 1 and both oversample Src data and so will replicate
     //          last pixel in X and interpolate past end of data in Y
     
#ifdef OPTION_1  // Option 1
      maj = _32K;
      min = -((_32K * lSrc) / lDst);
#endif

#ifdef OPTION_2  // Option 2
      maj =  ((_32K / lDst) * lDst);
      min = -((_32K / lDst) * lSrc);
#else         // Option 3
      lDst *= 4;
      lSrc = lSrc * 4 - 3; 
      maj =  ((_32K / lDst) * lDst);
      min = -((_32K / lDst) * lSrc);
#endif

      accum = maj - 1 - ((maj % -min) / (lDst/lSrc + 1));
    };

  if (chCoord == 'X')
  {
	 REQUIRE(3);
     LL16 (grMAJ_X, maj);
     LL16 (grMIN_X, min);
     LL16 (grACCUM_X, accum);
  }
  else
  {
	 REQUIRE(3);
     LL16 (grMAJ_Y, maj);
     LL16 (grMIN_Y, min);
     LL16 (grACCUM_Y, accum);
  };

  #ifdef DBGBRK
    DISPDBG((1, "DrvStretchBlt - stretch\n"));
    DbgBreakPoint();
  #endif
}


/****************************************************************************
* FUNCTION NAME: CopySrcToOffMem()
*
* DESCRIPTION:   This function copies source data from host memory to
*                offscreen memory
*
* REVISION HISTORY:
*   7/18/95     Benny Ng      Initial version
****************************************************************************/
VOID CopySrcToOffMem(PPDEV ppdev,
                     BYTE  *pSrcScan0,
                     LONG  sDelta,
                     LONG  sszY,
                     POFMHDL SrcHandle)
{
  LONG    DWcnt;
  LONG    i, j, k;
  LONG    cnt;
  BYTE    *pSrcScan;
  PDWORD  pSrcData;
  ULONG   ultmp;
  LONG    Ycord;
  HOST_DATA  SrcData;

  pSrcScan = pSrcScan0;
  Ycord = SrcHandle->aligned_y;

  // Clear Laguna Command Control Register SWIZ_CNTL bit
  ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
  LL16(grCONTROL, ppdev->grCONTROL);

  pSrcData = &SrcData.dwData;
  DWcnt = sDelta / sizeof(DWORD);

  // Setup the laguna registers for byte to byte BLT extents
  REQUIRE(8);
  LL16 (grBLTDEF,  0x1020);
  LL16 (grDRAWDEF, 0x00CC);

  LL16 (grOP1_opRDRAM.pt.X, 0);

  // LL (grOP0_opMRDRAM.pt.X, SrcHandle->aligned_x);
  // LL (grOP0_opMRDRAM.pt.Y, Ycord);
  LL_OP0_MONO (SrcHandle->aligned_x + ppdev->ptlOffset.x, Ycord + ppdev->ptlOffset.y);

  // LL (grMBLTEXT_EX.pt.X, sDelta);
  // LL (grMBLTEXT_EX.pt.Y, sszY);
  LL_MBLTEXT (sDelta, sszY);

  cnt = DWcnt;
  k = 0;
  for (i=0; i < sszY; i++)
  {
    // Pre-fill the 32-bits pattern with default values
    for (j=0; j < 4; j++)
      SrcData.bData[j] = 0;

    // Copy one screen line mask data from source to destination
    for (j=0; j < sDelta; j++)
    {
      SrcData.bData[k++] = *pSrcScan;
      pSrcScan++;
  
      if (k > 3)
      {
		 REQUIRE(1);
         LL32 (grHOSTDATA[0], *pSrcData);
         k = 0;
         cnt--;
      };  // endif (k > 3)
    }; // endfor j

    // Check whether one screen line of data are written to the
    // HOSTDATA register. 
    if (cnt == 0)
    {
       // Reset the row data count
       cnt = DWcnt;
    };  // endif (cnt == 0)
  }; // end for i

  #ifdef DBGBRK
    DISPDBG((0, "DrvStretchBlt-CopySrcToOffMem\n"));
    DbgBreakPoint();
  #endif
}



/****************************************************************************
* FUNCTION NAME: bStretchDIB()
*
* DESCRIPTION:   StretchBlt using integer math. Must be from one surface
*                to another surface of the same format.
*
* RETURN:        TRUE: Punt it.
*
* REVISION HISTORY:
*   7/27/95     Benny Ng      Initial version
****************************************************************************/
BOOL bStretchDIB(SURFOBJ* psoSrc,
                 SURFOBJ* psoMsk,
                 PDEV*    ppdev,
                 VOID*    pvDst,
                 LONG     lDeltaDst,
                 RECTL*   prclDst,
                 VOID*    pvSrc,
                 LONG     lDeltaSrc,
                 RECTL*   prclSrc,
                 RECTL*   prclClip)
{
  LONG    ltmp;
  ULONG   ultmp;
  SIZEL   reqsz;
  LONG    bpp;
  BYTE    *pSrcScan;
  RECTL   rclRes;

  BOOL    bNoBlt = FALSE;
  BOOL    bpuntit = TRUE;
  POFMHDL SrcHandle = NULL;

  long    drawdef = 0;
  long    srcx = 0;
  ULONG   LnCntl = 0;
  LONG    sShrinkInc = 0;
  LONG    XsrcOff = 0;
  LONG    YsrcOff = 0;

  // Calculate the rectange start points and sizes:
  //
  LONG  WidthDst  = prclDst->right  - prclDst->left;
  LONG  HeightDst = prclDst->bottom - prclDst->top;

  LONG  WidthSrc  = prclSrc->right  - prclSrc->left;
  LONG  HeightSrc = prclSrc->bottom - prclSrc->top;

  LONG  XDstStart = prclDst->left;
  LONG  YDstStart = prclDst->top;

  LONG  XSrcStart = prclSrc->left;
  LONG  YSrcStart = prclSrc->top;


  // -------------------------------------------------------
  // Calculate bytes per pixel
  bpp = ppdev->ulBitCount/8;

  // Get the informations from source and destination surface
  pSrcScan = pvSrc;

  if (psoMsk != NULL)
  {
     #ifdef DBGDISP
        DISPDBG((1, "DrvStretchBlt - HandleCase_1 mask pointer != NULL (punt it)\n"));
     #endif

     goto Punt_It;
  };

  // -------------------------------------------------------
  // Check whether source is from host or video memory
  if ((pSrcScan <  ppdev->pjScreen) ||
      (pSrcScan > (ppdev->pjScreen + ppdev->lTotalMem)))
  {    
     #ifdef DBGDISP
       DISPDBG((1, "DrvStretchBlt - HandleCase_1 - src host\n"));
     #endif

     // Allocate the offscreen memory for the source if not enough offscreen
     // memory available punt it.
     reqsz.cx = psoSrc->sizlBitmap.cx;
     reqsz.cy = psoSrc->sizlBitmap.cy;

     if ((SrcHandle = AllocOffScnMem(ppdev, &reqsz, PIXEL_AlIGN, NULL)) == NULL)
     {   goto Punt_It;     };

//?? bbbbbbbbbb
// Note: The following lines of code takes care the host data HW problem,
//       it punt back to GDI when host data size is 29 to 30 to DWORD.
//
     if ((lDeltaSrc >= 116) && (lDeltaSrc <= 120))
     {
        DISPDBG((1, "DrvStretchBlt - src host (punt it)\n"));
        goto Punt_It;
     };
//?? eeeeeeeeee

     // Copy the source data into allocated offscreen memory
     CopySrcToOffMem(ppdev,
                     pSrcScan,
                     lDeltaSrc,
                     HeightSrc,
                     SrcHandle);

     XSrcStart = SrcHandle->aligned_x / bpp;
     YSrcStart = SrcHandle->aligned_y;
  }
  else
  {    
     #ifdef DBGDISP
        DISPDBG((1, "DrvStretchBlt - HandleCase_1 - src videow\n"));
     #endif
     if ((WidthSrc * bpp) > ppdev->lDeltaScreen)
        WidthSrc = ppdev->lDeltaScreen / bpp;

     ltmp = ppdev->lTotalMem / ppdev->lDeltaScreen;

     if (HeightSrc > ltmp)
        HeightSrc = ltmp;
  };

  // -------------------------------------------------------
  if (prclClip != NULL)
  {
     // Test for intersection of clipping rectangle and destination
     // rectangle. If they don't intersect, go on for stretch BLT.
     // For DC_RECT clipping we have a single clipping rectangle.
     // We create a new destination rectangle which is the intersection 
     // between the old destination rectangle and the clipping rectangle.
     // Then we adjust our source rectangle accordingly.
     //
     if (!bRectIntersect(prclDst, prclClip, &rclRes))
     {
        #ifdef DBGDISP
          DISPDBG((1, "DrvStretchBlt - HandleCase_1 - DC_RECT no intersect\n"));
        #endif
        goto Punt_It;
     };

     // Adjust the source size
     bNoBlt = AdjustSrcSize(rclRes.left, rclRes.top,
                            XDstStart,   YDstStart, 
                            (rclRes.right - rclRes.left),
                            (rclRes.bottom - rclRes.top),
                            WidthDst,    HeightDst,
                            &WidthSrc,   &HeightSrc,
                            &XsrcOff,    &YsrcOff);
         
     // Adjust the destination rectange size
     XDstStart = rclRes.left;
     YDstStart = rclRes.top;
     WidthDst  = rclRes.right  - rclRes.left; 
     HeightDst = rclRes.bottom - rclRes.top;
  }; // endif (prclClip != NULL)

  if (!bNoBlt)
  {
     // -------------------------------------------------------
     // Perform the shrink or stretch operation

     // Set the shrink or interpolate bit in LNCNTL
     if (WidthSrc >= WidthDst)
     {
        LnCntl |= X_SHRINK_ENABLE;
        Shrink(ppdev, WidthSrc, WidthDst, 'X', LnCntl, &sShrinkInc);
     }
     else
     {
        Stretch(ppdev, WidthSrc, WidthDst, 'X', LnCntl);
     };

     if (HeightSrc >= HeightDst)
     {
        LnCntl |= Y_SHRINK_ENABLE;
        Shrink(ppdev, HeightSrc, HeightDst, 'Y', LnCntl, &sShrinkInc);
     }
     else
     {
        Stretch(ppdev, HeightSrc, HeightDst, 'Y', LnCntl);
     };

     #ifdef DBGBRK
       DISPDBG((1, "DrvStretchBlt - bStretchDIB - before exec\n"));
       DbgBreakPoint();
     #endif

     // -------------------------------------------------------
     XSrcStart += XsrcOff;
     YSrcStart += YsrcOff;

     // LL (grOP1_opRDRAM.pt.X, XSrcStart);
     // LL (grOP1_opRDRAM.pt.Y, YSrcStart);
	 REQUIRE(12);
     LL_OP1 (XSrcStart, YSrcStart);

     LL16 (grSHRINKINC, sShrinkInc);

     LL16 (grBLTDEF,  0x1010);
     LL16 (grDRAWDEF, 0x00CC);
   
     // Setup the shrink and interpolate bits in LNCNTL
     ultmp = LLDR_SZ (grLNCNTL.w);
     ultmp |= LnCntl;
     LL16 (grLNCNTL, ultmp);

     srcx = WidthSrc * bpp;
     LL16 (grSRCX, srcx);

     // LL (grOP0_opRDRAM.pt.X, XDstStart);
     // LL (grOP0_opRDRAM.pt.Y, YDstStart);
     LL_OP0 (XDstStart + ppdev->ptlOffset.x, YDstStart + ppdev->ptlOffset.y);
   
     // LL (grBLTEXTR_EX.pt.X, WidthDst);
     // LL (grBLTEXTR_EX.pt.Y, HeightDst);
     LL_BLTEXTR (WidthDst, HeightDst);

     #ifdef DBGBRK
       DISPDBG((1, "DrvStretchBlt - bStretchDIB - after exec\n"));
       DbgBreakPoint();
     #endif

     bpuntit = FALSE;
  }; //endif (!bNoBlt)

Punt_It:
  // -------------------------------------------------------
  // Release the offscreen buffer if allocated
  if (SrcHandle != NULL)
     FreeOffScnMem(ppdev, SrcHandle);

  return(bpuntit);
}



/****************************************************************************
* FUNCTION NAME: HandleCase_1()
*
* DESCRIPTION:   This function handle the case when
*                Both src and dst surface types are equal to STYPE_BITMAP,
*                both src and dst surface have same iBitmapFormat,
*                no color translation.
*
* RETURN:        TRUE: Punt it.
*
* REVISION HISTORY:
*   7/18/95     Benny Ng      Initial version
****************************************************************************/
BOOL HandleCase_1(SURFOBJ*  psoDst,
                  SURFOBJ*  psoSrc,
                  SURFOBJ*  psoMsk,
                  CLIPOBJ*  pco,
                  RECTL*    prclDst,
                  RECTL*    prclSrc,
                  POINTL*   pptlMsk,
                  BOOL*     bRet)
{
  BOOL  bpuntit = TRUE;
  PDEV* ppdev = (PDEV*) psoDst->dhpdev;

  BYTE    iDComplexity;
  PRECTL  prclClip;

  ENUMRECTS  ce;
  BOOL    bMore;
  LONG    c;
  LONG    i;

  *bRet = FALSE;

  // -------------------------------------------------------
  // CHeck what kind of clipping is it?
  iDComplexity = (pco ? pco->iDComplexity : DC_TRIVIAL);

  switch (iDComplexity)
  {
    case  DC_TRIVIAL:
      #ifdef DBGDISP
        DISPDBG((1, "DrvStretchBlt - HandleCase_1 - DC_TRIVIAL\n"));
      #endif

      bpuntit = bStretchDIB(psoSrc,
                            psoMsk,
                            ppdev,
                            NULL,
                            psoDst->lDelta,
                            prclDst,
                            psoSrc->pvScan0,
                            psoSrc->lDelta,
                            prclSrc,
                            NULL);
      break;
  
    case DC_RECT:
      #ifdef DBGDISP
        DISPDBG((1, "DrvStretchBlt - HandleCase_1 - DC_RECT\n"));
      #endif

      // Get the clipping rectangle.
      prclClip = &pco->rclBounds;

      bpuntit = bStretchDIB(psoSrc,
                            psoMsk,
                            ppdev,
                            NULL,
                            psoDst->lDelta,
                            prclDst,
                            psoSrc->pvScan0,
                            psoSrc->lDelta,
                            prclSrc,
                            prclClip);
      break;

    case DC_COMPLEX:
      #ifdef DBGDISP
        DISPDBG((1, "DrvStretchBlt - HandleCase_1 - DC_COMPLEX\n"));
      #endif

      bpuntit = FALSE;
      CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

      do
      {
         bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

         c = cRectIntersect(prclDst, ce.arcl, ce.c);

         if (c != 0)
         {
            for (i = 0; i < c; i++)
            {
              bpuntit = bStretchDIB(psoSrc,
                                    psoMsk,
                                    ppdev,
                                    NULL,
                                    psoDst->lDelta,
                                    prclDst,
                                    psoSrc->pvScan0,
                                    psoSrc->lDelta,
                                    prclSrc,
                                    &ce.arcl[i]);

              if (bpuntit)
                 break;

            }; // enddo
         }; // endif

      } while ((bMore) && (!bpuntit));

      break;

    default:
      break;
  };  // end switch (iDComplexity)

  // -------------------------------------------------------
  // Check whether the operation was handled successfully
  if (!bpuntit)
     *bRet = TRUE;

  return (bpuntit);
}


/****************************************************************************
* FUNCTION NAME: DrvStretchBlt()
*
* DESCRIPTION:   This function provides stretching bit-block transfer
*                capabilities for Laguna NT
*
* REVISION HISTORY:
*   7/11/95     Benny Ng      Initial version
****************************************************************************/
#define  TSTFRIDO     1

BOOL DrvStretchBlt(SURFOBJ*   psoDst,
                   SURFOBJ*   psoSrc,
                   SURFOBJ*   psoMsk,
                   CLIPOBJ*   pco,
                   XLATEOBJ*  pxlo,
                   COLORADJUSTMENT*  pca,
                   POINTL*    pptlHTOrg,
                   RECTL*     prclDst,
                   RECTL*     prclSrc,
                   POINTL*    pptlMsk,
                   ULONG      iMode)
{
  BOOL    bRet = TRUE;
  BOOL    bPuntIt = TRUE;
  LONG    HandleIt = 0;

  #if NULL_STRETCH
  {
      if (pointer_switch)    	    return TRUE;
  }
  #endif


#ifdef TSTFRIDO
{
  PPDEV  ppdev = (PPDEV) psoDst->dhpdev;      
  SYNC_W_3D(ppdev);
  if (psoDst->iType == STYPE_DEVBITMAP)
  {
	  PDSURF pdsurf = (PDSURF)psoDst->dhsurf;

	  if ( pdsurf->pso )
	  {
	  	  if ( !bCreateScreenFromDib(ppdev, pdsurf) )
  	  	  {
           return EngStretchBlt(psoDst, psoSrc, psoMsk, pco,
                                pxlo, pca, pptlHTOrg,
                                prclDst, prclSrc, pptlMsk, iMode);
  	  	  };
	  };
	  ppdev->ptlOffset.x = pdsurf->ptl.x;
	  ppdev->ptlOffset.y = pdsurf->ptl.y;
  }
  else
  {
     if (ppdev != NULL)
        ppdev->ptlOffset.x = ppdev->ptlOffset.y = 0;
     else
        return(EngStretchBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca, pptlHTOrg,
                             prclDst, prclSrc, pptlMsk, iMode));
  };

  ppdev = (PPDEV) psoSrc->dhpdev;      
  if (psoSrc->iType == STYPE_DEVBITMAP)
  {
	  PDSURF pdsurf = (PDSURF)psoSrc->dhsurf;

	  if ( pdsurf->pso )
	  {
	  	  if ( !bCreateScreenFromDib(ppdev, pdsurf) )
	  	  {
           return EngStretchBlt(psoDst, psoSrc, psoMsk, pco,
                                pxlo, pca, pptlHTOrg,
                                prclDst, prclSrc, pptlMsk, iMode);
	  	  };
	  };
	  ppdev->ptlOffset.x = pdsurf->ptl.x;
	  ppdev->ptlOffset.y = pdsurf->ptl.y;
  }
  else
  {
     if (ppdev != NULL)
        ppdev->ptlOffset.x = ppdev->ptlOffset.y = 0;
     else
        return(EngStretchBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca, pptlHTOrg,
                             prclDst, prclSrc, pptlMsk, iMode));
  };
}
#else
  {  
  PPDEV  ppdev = (PPDEV) psoDst->dhpdev;      
  SYNC_W_3D(ppdev);
  }
  bRet = EngStretchBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca, pptlHTOrg,
                          prclDst, prclSrc, pptlMsk, iMode);
  return(bRet);
#endif


  #ifdef DBGDISP
    DISPDBG((1, "DrvStretchBlt - %d\n", iMode));
  #endif

  if ((psoDst->iType == psoSrc->iType) &&
      (psoDst->fjBitmap == psoSrc->fjBitmap) &&
      (psoDst->fjBitmap == BMF_TOPDOWN))
  {
    // If src and dst surface have same iBitmapFormat
    if (psoDst->iBitmapFormat == psoSrc->iBitmapFormat)
    {
       // Check for color translation
       if (pxlo == NULL)
       {
          HandleIt = 1;
       }
       else if ((pxlo != NULL) && (pxlo->iSrcType == pxlo->iDstType))
       {
          switch (pxlo->flXlate)
          {
            case XO_TRIVIAL:
            case 0:
              HandleIt = 1;
              break;

            default:
	      #ifdef DBGDISP
                DISPDBG((1, "DrvStretchBlt - pxlo->flXlate (punt it)\n"));
	      #endif
              break;
          };
       }; // endif (pxlo == NULL)
    }; // endif (src and dst surface have same iBitmapFormat)
  }; // endif (Both src and dst surface types are equal to STYPE_BITMAP)

  // Check whether we can handle this case, if yes call the case
  // handle routine to try to handle it. Otherwise punt it back to GDI
  if (HandleIt != 0)
  {
     if (HandleIt == 1)
     {
        bPuntIt = HandleCase_1(psoDst,
                               psoSrc,
                               psoMsk,
                               pco,
                               prclDst,
                               prclSrc,
                               pptlMsk,
                               &bRet);
     }
     else if (HandleIt == 2)
     {
     };
  };  // endif (HandleIt)

  // -------------------------------------------------------
  // Punt It back to GDI to handle it
  if (bPuntIt)
  {
     DISPDBG((1, "DrvStretchBlt - punt it\n"));

     #ifdef PUNTBRK
         DbgBreakPoint();  
     #endif

     bRet = EngStretchBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca, pptlHTOrg,
                          prclDst, prclSrc, pptlMsk, iMode);
  };

  return(bRet);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\ssbits.c ===
/****************************************************************************
*****************************************************************************
*
*                ******************************************
*                * Copyright (c) 1995, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:	Laguna I (CL-GD5462) - 
*
* FILE:		ssbits.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module implements the DrvSaveScreenBits() for
*           Laguna NT driver.
*
* MODULES:
*           DrvSaveScreenBits()
*
* REVISION HISTORY:
*   6/20/95     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/SSBITS.C  $
* 
*    Rev 1.18   Apr 28 1998 12:51:44   frido
* PDR#11389. I have disabled DrvSaveScreenBits on 2MB boards. We
* seem to run out of memory and the memory manager moves the blocks
* to a different place causing corruption.
* 
*    Rev 1.17   Mar 04 1998 15:34:18   frido
* Added new shadow macros.
* 
*    Rev 1.16   Nov 03 1997 11:18:10   frido
* Added REQUIRE macros.
* 
*    Rev 1.15   08 Aug 1997 17:24:22   FRIDO
* Added support for new memory manager.
* 
*    Rev 1.14   09 Apr 1997 10:49:28   SueS
* Changed sw_test_flag to pointer_switch.
* 
*    Rev 1.13   08 Apr 1997 12:27:40   einkauf
* 
* add SYNC_W_3D to coordinate MCD/2D hw access
* 
*    Rev 1.12   26 Nov 1996 10:44:02   SueS
* Changed WriteLogFile parameters for buffering.
* 
*    Rev 1.11   13 Nov 1996 17:08:46   SueS
* Changed WriteFile calls to WriteLogFile.
* 
*    Rev 1.10   07 Nov 1996 16:09:08   bennyn
* 
* Added no offscn allocation if DD enabled
* 
*    Rev 1.9   23 Aug 1996 09:10:38   noelv
* Save unders are now discardable.
* 
*    Rev 1.2   22 Aug 1996 17:07:14   frido
* #ss - Added validation of saved area before restoring or freeing it.
* 
*    Rev 1.1   15 Aug 1996 11:39:54   frido
* Added precompiled header.
* 
*    Rev 1.0   14 Aug 1996 17:16:30   frido
* Initial revision.
* 
*    Rev 1.7   18 Jun 1996 12:39:34   noelv
* added debug information.
* 
*    Rev 1.6   28 May 1996 15:11:30   noelv
* Updated data logging.
* 
*    Rev 1.5   16 May 1996 15:01:02   bennyn
* 
* Add PIXEL_ALIGN to allocoffscnmen()
* 
*    Rev 1.4   20 Mar 1996 16:09:42   noelv
* 
* Updated data logging
* 
*    Rev 1.3   05 Mar 1996 12:01:46   noelv
* Frido version 19
 * 
 *    Rev 1.1   20 Jan 1996 01:16:48   frido
 *  
* 
*    Rev 1.4   15 Jan 1996 17:00:08   NOELV
* AB workaround reductions
* 
*    Rev 1.3   20 Oct 1995 11:21:50   NOELV
* 
* Was leaking offscreen memory.  Now it releases its memory after resoring.
* 
*    Rev 1.2   04 Oct 1995 10:17:36   NOELV
* 
* Used updated write macros.
* 
*    Rev 1.1   21 Aug 1995 13:52:44   NOELV
* Initial port to real hardware.
* Converted all 32 bit register writes to 2 16 bit regiser writes.
* 
*    Rev 1.0   25 Jul 1995 11:23:20   NOELV
* Initial revision.
* 
*    Rev 1.2   06 Jul 1995 09:59:10   BENNYN
* 
* 
*    Rev 1.1   05 Jul 1995 08:39:44   BENNYN
* Initial version
* 
*    Rev 1.0   29 Jun 1995 14:20:44   BENNYN
* Initial revision.
* 
****************************************************************************
****************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/
#include "precomp.h"
#include "SWAT.h"

#if MEMMGR
POFMHDL FindHandle(PPDEV ppdev, POFMHDL hdl);
#endif

/*----------------------------- DEFINES -----------------------------------*/
#define SSB_DBG_LEVEL 1

/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/

/*-------------------------- STATIC VARIABLES -----------------------------*/

/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/

//
// If data logging is enabled, Prototype the logging files.
//
#if LOG_CALLS
    void LogSaveScreenBits(
	int 	  acc,
        PPDEV ppdev);

//
// If data logging is not enabled, compile out the calls.
//
#else
    #define LogSaveScreenBits(acc, ppdev)
#endif


/****************************************************************************
* FUNCTION NAME: DrvSaveScreenBits()
*
* DESCRIPTION:   Do the save and restore of a given rectange of the
*                displayed image
*
* REVISION HISTORY:
*   7/05/95     Benny Ng      Initial version
****************************************************************************/
ULONG DrvSaveScreenBits(
SURFOBJ* pso,
ULONG    iMode,
ULONG    ident,
RECTL*   prcl)
{
	POFMHDL Handle;
	SIZEL   reqsz;
	LONG    szx, szy;
	PPDEV   ppdev = (PPDEV) pso->dhpdev;
#if 1 //#ss
	POFMHDL pofm;
#endif

    SYNC_W_3D(ppdev);

	DISPDBG((SSB_DBG_LEVEL, "DrvSaveScreenBits - (%d)\n", iMode));

	switch (iMode)
	{
	case SS_SAVE: // -----------------------------------------------------------

#ifdef ALLOC_IN_CREATESURFACE
      if (ppdev->bDirectDrawInUse)
         return (0);
#ifdef WINNT_VER40      // WINNT_VER40
      // MCD should be active only when DDraw is active, but after mode change, 
      // it seems that DDraw is disabled and not re-enabled.  Since MCD uses
      // off screen memory like DDraw, we should punt SS_SAVE as if DDraw was alive
      if (ppdev->NumMCDContexts > 0)                                                                          \
         return (0);
#endif
#endif

#if 1 // PDR#11389
		if (ppdev->lTotalMem < 4096 * 1024)
		{
			DISPDBG((SSB_DBG_LEVEL, "DrvSaveScreenBits - Not enough memory\n"));
			return (ULONG)NULL;
		}
#endif

		ASSERTMSG((prcl != NULL),
				  "NULL rectangle in SaveScreenBits. Mode=SS_SAVE.\n");

		szx = prcl->right  - prcl->left;
		szy = prcl->bottom - prcl->top;
		reqsz.cx = szx;
		reqsz.cy = szy;
      
		Handle = AllocOffScnMem(ppdev, &reqsz, PIXEL_AlIGN, NULL);
		if (Handle != NULL)
		{
			// Save the image to offscreen memory
			REQUIRE(9);
			LL_DRAWBLTDEF(0x101000CC, 0);
			LL_OP1(prcl->left, prcl->top);
			LL_OP0(Handle->aligned_x / ppdev->iBytesPerPixel,
				   Handle->aligned_y);
			LL_BLTEXT(szx, szy);
			LogSaveScreenBits(0, ppdev);
#if 1 //#ss
			Handle->alignflag |= SAVESCREEN_FLAG;
#endif
		}
		else
		{
			LogSaveScreenBits(9, ppdev);
		}

		DISPDBG((SSB_DBG_LEVEL, "DrvSaveScreenBits - Exit\n", iMode));
		return((ULONG) Handle);

	case SS_RESTORE: // --------------------------------------------------------
		ASSERTMSG((prcl != NULL),
				  "NULL rectangle in SaveScreenBits. Mode=SS_RESTORE.\n");

		Handle = (POFMHDL) ident;

#if 1 //#ss
	#if MEMMGR
		pofm = FindHandle(ppdev, Handle);
	#else
		for (pofm = ppdev->OFM_UsedQ; pofm; pofm = pofm->nexthdl)
		{
			if (Handle == pofm)
			{
				break;
			}
		}
	#endif
		if (pofm == NULL)
		{
			DISPDBG((SSB_DBG_LEVEL,
					 "DrvSaveScreenBits - Unable to restore.\n"));
			return(FALSE);
		}
#endif
      
		// Restore the image using the BLT operation
		REQUIRE(9);
		LL_DRAWBLTDEF(0x101000CC, 0);
		LL_OP1(Handle->aligned_x / ppdev->iBytesPerPixel, Handle->aligned_y);
		LL_OP0(prcl->left, prcl->top);
		LL_BLTEXT(prcl->right - prcl->left, prcl->bottom - prcl->top);

		//
		// After doing a restore we automatically do a free, So fall through to
		// SS_FREE.
		//
		LogSaveScreenBits(1, ppdev);

	case SS_FREE: // -----------------------------------------------------------
		Handle = (POFMHDL) ident;
		#if MEMMGR
		pofm = FindHandle(ppdev, Handle);
		#else
		for (pofm = ppdev->OFM_UsedQ; pofm; pofm = pofm->nexthdl)
		{
			if (Handle == pofm)
			{
				break;
			}
		}
		#endif
		if (pofm != NULL)
		{
			FreeOffScnMem(ppdev, Handle);
			LogSaveScreenBits(2, ppdev);
		}
		DISPDBG((SSB_DBG_LEVEL, "DrvSaveScreenBits - Exit\n", iMode));
        return(TRUE);

	} // end switch

	//
	// We shouldn't ever get here.
	//

	DISPDBG((SSB_DBG_LEVEL, "DrvSaveScreenBits - PANIC\n", iMode));
	RIP(("Panic! SaveScreenBits got an invalid command.\n"));
	LogSaveScreenBits(2, ppdev);
	return(FALSE);
}

#if LOG_CALLS
void LogSaveScreenBits(
	int 	  acc,
        PPDEV ppdev)
{
    char buf[256];
    int i;

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    i = sprintf(buf,"DrvSaveScreenBits: ");
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    switch(acc)
    {
	case 0: 
	    i = sprintf(buf, "SAVE (success)");
	    break;

	case 1: 
	    i = sprintf(buf,"RESTORE ");
	    break;

	case 2: 
	    i = sprintf(buf, "DELETE ");
	    break;

	case 3: 
	    i = sprintf(buf, "INVALID ");
	    break;

	case 9: 
	    i = sprintf(buf, "SAVE (fail) ");
	    break;

	default:
 	    i = sprintf(buf, "PUNT unknown ");
	    break;

    }
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);




    i = sprintf(buf,"\r\n");
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

}


#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\strips.c ===
/******************************Module*Header*******************************\
* Module Name: Strips.c
*
* All the line code in this driver amounts to a big bag of dirt.  Someday,
* I'm going to rewrite it all.  Not today, though (sigh)...
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
* $Workfile:   STRIPS.C  $
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/STRIPS.C  $
*
*    Rev 1.4   Mar 04 1998 15:35:14   frido
* Added new shadow macros.
*
*    Rev 1.3   Nov 03 1997 10:50:06   frido
* Added REQUIRE macros.
*
*    Rev 1.2   20 Aug 1996 11:04:28   noelv
* Bugfix release from Frido 8-19-96
*
*    Rev 1.0   14 Aug 1996 17:16:32   frido
* Initial revision.
*
*    Rev 1.1   28 Mar 1996 08:58:40   noelv
* Frido bug fix release 22
 *
 *    Rev 1.1   27 Mar 1996 13:57:28   frido
 * Fixed line drawing.
*
\**************************************************************************/

#include "precomp.h"

#define STARTBLT()

/******************************Public*Routine******************************\
* VOID vrlSolidHorizontal
*
* Draws left-to-right x-major near-horizontal lines using radial lines.
*
\**************************************************************************/

VOID vrlSolidHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    LONG  cStrips;
    LONG  i, yDir, x, y;
    PLONG pStrips;
        LONG  xPels;

    cStrips = pStrip->cStrips;
        pStrips = pStrip->alStrips;

        // Get the starting coordinates and adjust for device bitmaps.
    x = pStrip->ptlStart.x + ppdev->ptlOffset.x;
    y = pStrip->ptlStart.y + ppdev->ptlOffset.y;

        // Determine y-direction.
    if (pStrip->flFlips & FL_FLIP_V)
        {
                yDir = -1;
                ppdev->uBLTDEF |= BD_YDIR;
        }
        else
        {
                yDir = 1;
                ppdev->uBLTDEF &= ~BD_YDIR;
        }

        // Start the BitBlt.
    STARTBLT();

    // Here is where we will setup DrawDef and BlitDef
        REQUIRE(2);
        LL_DRAWBLTDEF((ppdev->uBLTDEF << 16) | ppdev->uRop, 2);

        // Loop through all the strips.
    for (i = 0; i < cStrips; i++)
    {
                // Get the width of this stripe.
                xPels = *pStrips++;

                // Draw it.
                REQUIRE(5);
                LL_OP0(x, y);
                LL_BLTEXT(xPels, 1);

                // Advance to next strip.
                x += xPels;
        y += yDir;
    }

        // Store the current coordinates back.
    pStrip->ptlStart.x = x - ppdev->ptlOffset.x;
    pStrip->ptlStart.y = y - ppdev->ptlOffset.y;
}

/******************************Public*Routine******************************\
* VOID vrlSolidVertical
*
* Draws left-to-right y-major near-vertical lines using radial lines.
*
\**************************************************************************/

VOID vrlSolidVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    LONG  cStrips;
    LONG  i, x, y, yDir;
    PLONG pStrips;
        LONG  yPels;

    cStrips = pStrip->cStrips;
    pStrips = pStrip->alStrips;

        // Get the starting coordinates and adjust for device bitmaps.
    x = pStrip->ptlStart.x + ppdev->ptlOffset.x;
    y = pStrip->ptlStart.y + ppdev->ptlOffset.y;

        // Determine y-direction.
        if (pStrip->flFlips & FL_FLIP_V)
        {
                ppdev->uBLTDEF |= BD_YDIR;
                yDir = -1;
        }
        else
        {
                yDir = 1;
                ppdev->uBLTDEF &= ~BD_YDIR;
        }

        // Start the BitBlt.
    STARTBLT();

    // Here is where we will setup DrawDef and BlitDef
        REQUIRE(2);
        LL_DRAWBLTDEF((ppdev->uBLTDEF << 16) | ppdev->uRop, 2);

        // Loop through all the strips.
    for (i = 0; i < cStrips; i++)
        {
                // Get the height of this stripe.
                yPels = *pStrips++;

                // Draw it.
                REQUIRE(5);
                LL_OP0(x, y);
                LL_BLTEXT(1, yPels);

                // Advance to next strip.
                x++;
                y += yDir * yPels;
        }

        // Store the current coordinates back.
    pStrip->ptlStart.x = x - ppdev->ptlOffset.x;
    pStrip->ptlStart.y = y - ppdev->ptlOffset.y;
}


/******************************Public*Routine******************************\
* VOID vStripStyledHorizontal
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles x-major lines that run left-to-right,
* and are comprised of horizontal strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vStripStyledHorizontal(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    LONG  x, y, dy;
    PLONG plStrip;
    LONG  cStrips;
    LONG  cStyle;
    LONG  cStrip;
    LONG  cThis;
    ULONG bIsGap;

        // Determine y-direction.
        if (pstrip->flFlips & FL_FLIP_V)
        {
                dy = -1;
                ppdev->uBLTDEF |= BD_YDIR;
        }
        else
        {
                ppdev->uBLTDEF &= ~BD_YDIR;
                dy = 1;
        }

    cStrips = pstrip->cStrips;      // Total number of strips we'll do
    plStrip = pstrip->alStrips;     // Points to current strip

        // Get the starting coordinates and adjust for device bitmaps.
    x = pstrip->ptlStart.x + ppdev->ptlOffset.x;
    y = pstrip->ptlStart.y + ppdev->ptlOffset.y;

        // Start the BitBlt.
    STARTBLT();

    // Here is where we will setup DrawDef and BlitDef.
    REQUIRE(2);
    LL_DRAWBLTDEF((ppdev->uBLTDEF << 16) | ppdev->uRop, 2);

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        x += cThis;

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
                goto OutputADash;
    }

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

                // Draw the stripe.
                REQUIRE(5);
                LL_OP0(x, y);
                LL_BLTEXT(cThis, 1);

                x += cThis;

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x - ppdev->ptlOffset.x;
    pstrip->ptlStart.y = y - ppdev->ptlOffset.y;
}

/******************************Public*Routine******************************\
* VOID vStripStyledVertical
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles y-major lines that run left-to-right,
* and are comprised of vertical strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vStripStyledVertical(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    LONG  x, y, dy;
    PLONG plStrip;
    LONG  cStrips;
    LONG  cStyle;
    LONG  cStrip;
    LONG  cThis;
    ULONG bIsGap;

        // Determine the y-direction.
    if (pstrip->flFlips & FL_FLIP_V)
        {
                dy = -1;
                ppdev->uBLTDEF |= BD_YDIR;
        }
        else
        {
                dy = 1;
                ppdev->uBLTDEF &= ~BD_YDIR;
        }

    cStrips = pstrip->cStrips;      // Total number of strips we'll do
    plStrip = pstrip->alStrips;     // Points to current strip

        // Get the starting coordinates and adjust for device bitmaps.
    x = pstrip->ptlStart.x + ppdev->ptlOffset.x;
    y = pstrip->ptlStart.y + ppdev->ptlOffset.y;

        // Start the BitBlt.
    STARTBLT();

    // Here is where we will setup DrawDef and BlitDef.
    REQUIRE(2);
    LL_DRAWBLTDEF((ppdev->uBLTDEF << 16) | ppdev->uRop, 2);

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        y += (dy > 0) ? cThis : -cThis;

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        goto OutputADash;
    }

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

                // Draw the stripe.
                REQUIRE(5);
                LL_OP0(x, y);
                LL_BLTEXT(1, cThis);

                y += dy * cThis;

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x - ppdev->ptlOffset.x;
    pstrip->ptlStart.y = y - ppdev->ptlOffset.y;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\i386\macros.inc ===
;===============================================================================
;
;	$Workfile:   MACROS.INC  $
;
;	Contents:
;	Several macros to track the stack status.
;
;	Copyright (c) 1996, Cirrus Logic, Inc.
;
;	$Log:   X:/log/laguna/nt35/displays/cl546x/i386/MACROS.INC  $
; 
;    Rev 1.5   20 Aug 1996 11:29:02   noelv
; Bugfix release from Frido 8-19-96
; 
;    Rev 1.0   14 Aug 1996 17:14:36   frido
; Initial revision.
; 
;    Rev 1.4   04 Apr 1996 13:22:24   noelv
; Frido version 26
;	
;	   Rev 1.2   30 Jan 1996 21:49:52   frido
;	Added OPTION switches for all .ASM files to disable MASM 5.1 compatibility.
;	
;	   Rev 1.1   25 Jan 1996 12:43:08   frido
;	Added more stack tracing macros.
;	
;	   Rev 1.0   24 Jan 1996 23:13:42   frido
;	 Initial release.
;
;===============================================================================

OPTION	NOM510
OPTION	CASEMAP:NONE
OPTION	NODOTNAME
OPTION	NOOLDMACROS
OPTION	NOOLDSTRUCTS
OPTION	SCOPED
OPTION	EXPR32
OPTION	LJMP

push_	MACRO	vArg:REQ
	push	vArg
espPTR = espPTR + 4
frmPTR = frmPTR + 4
	ENDM

pop_	MACRO	vArg:REQ
	pop	vArg
espPTR = espPTR - 4
frmPTR = frmPTR - 4
	ENDM

enter_	MACRO	vArg:REQ
	sub	esp, vArg
espPTR = espPTR + vArg
frmPTR = 0
	ENDM

leave_	MACRO	vArg:REQ
	add	esp, vArg
espPTR = espPTR - vArg
	ENDM

save_	MACRO	n:REQ
espPTR_&n = espPTR
frmPTR_&n = frmPTR
	ENDM

load_	MACRO	n:REQ
espPTR = espPTR_&n
frmPTR = frmPTR_&n
	ENDM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\i386\winnt.inc ===
;===============================================================================
;
;	$Workfile:   WINNT.INC  $
;
;	Contents:
;	This include file contains the standard Windows NT structures used by
;	the display driver.
;
;	Copyright (c) 1996, Cirrus Logic, Inc.
;
;	$Log:   X:/log/laguna/nt35/displays/cl546x/i386/WINNT.INC  $
; 
;    Rev 1.6   20 Aug 1996 11:29:04   noelv
; Bugfix release from Frido 8-19-96
; 
;    Rev 1.0   14 Aug 1996 17:14:40   frido
; Initial revision.
; 
;    Rev 1.5   01 May 1996 11:07:06   bennyn
; 
; Modified for NT 4.0
; 
;    Rev 1.4   04 Apr 1996 13:22:26   noelv
; Frido version 26
;	
;	   Rev 1.4   10 Feb 1996 21:47:18   frido
;	Added debugging routines.
;	
;	   Rev 1.3   08 Feb 1996 00:10:52   frido
;	Added more objects from WinDDI.h.
;	Reordered objects.
;	
;	   Rev 1.2   25 Jan 1996 22:03:46   frido
;	Yes, added some more stuff.
;	
;	   Rev 1.1   25 Jan 1996 12:45:04   frido
;	Added some more functon prototypes.
;	
;	   Rev 1.0   24 Jan 1996 23:13:44   frido
;	 Initial release.
;
;===============================================================================

UINT			TYPEDEF		DWORD
LONG			TYPEDEF		SDWORD
ULONG			TYPEDEF		DWORD
PBYTE			TYPEDEF		PTR BYTE
FLONG			TYPEDEF		LONG
BOOL			TYPEDEF		SDWORD
PVOID			TYPEDEF		PTR
HANDLE			TYPEDEF		PVOID
USHORT			TYPEDEF		WORD
LPCTSTR			TYPEDEF		PTR BYTE

RTL_CRITICAL_SECTION STRUCT
  DebugInfo		DWORD		?
  LockCount		LONG		?
  RecursionCount	LONG		?
  OwningThread		HANDLE		?
  LockSemaphore		HANDLE		?
  Reserved		DWORD		?
RTL_CRITICAL_SECTION ENDS

CRITICAL_SECTION	TYPEDEF		RTL_CRITICAL_SECTION

RECTL STRUCT
  left			LONG		?
  top			LONG		?
  right			LONG		?
  bottom		LONG		?
RECTL ENDS

POINTL STRUCT
  x			LONG		?
  y			LONG		?
POINTL ENDS

SIZEL STRUCT
  _cx			LONG		?
  _cy			LONG		?
SIZEL ENDS

FONTOBJ STRUCT
  iUniq			DWORD		?
  iFace			DWORD		?
  cxMax			DWORD		?
  flFontType		DWORD		?
  iTTUniq		DWORD		?
  iFile			DWORD		?
  sizLogResPpi		SIZEL		{}
  ulStyleSize		DWORD		?
  pvConsumer		DWORD		?
  pvProducer		DWORD		?
FONTOBJ ENDS

GLYPHBITS STRUCT
  ptlOrigin		POINTL		{}
  sizlBitmap		SIZEL		{}
  aj			BYTE		0 DUP(?)
GLYPHBITS ENDS

GLYPHDEF STRUCT
  pgb			DWORD		?
  ppo			DWORD		?
GLYPHDEF ENDS

GLYPHPOS STRUCT
  hg			DWORD		?
  pgdf			DWORD		?
  ptl			POINTL		{}
GLYPHPOS ENDS

OutputDebugStringA	PROTO		PROC,
			lpOutputString	:LPCTSTR

ifdef WINNT_VER40
EngAllocMem		PROTO		PROC,
			uFlags		:UINT,
			uBytes		:UINT,
			uTag		:UINT

FL_ZERO_MEMORY      	=		00000001h

else
LocalAlloc		PROTO		PROC,
			uFlags		:UINT,
			uBytes		:UINT

LocalFree		PROTO		PROC,
			hMem		:HANDLE

LMEM_FIXED		=		00000000h
LMEM_MOVEABLE		=		00000002h
LMEM_NOCOMPACT		=		00000010h
LMEM_NODISCARD		=		00000020h
LMEM_ZEROINIT		=		00000040h
LMEM_MODIFY		=		00000080h
LMEM_LOCKCOUNT		=		000000FFh
LMEM_DISCARDABLE	=		00000F00h
LMEM_VALID_FLAGS	=		00000F72h
LMEM_DISCARDED		=		00004000h
LMEM_INVALID_HANDLE	=		00008000h
endif

HS_DDI_MAX		=		6

;-------------------------------------------------------------------------------
; STROBJ
;-------------------------------------------------------------------------------
SO_FLAG_DEFAULT_PLACEMENT	=	00000001h
SO_HORIZONTAL			=	00000002h
SO_VERTICAL			=	00000004h
SO_RESERVED			=	00000008h
SO_ZERO_BEARINGS		=	00000010h
SO_CHAR_INC_EQUAL_BM_BASE	=	00000020h
SO_MAXEXT_EQUAL_BM_SIDE		=	00000040h

STROBJ STRUCT
  cGlyphs		ULONG		?
  flAccel		FLONG		?
  ulCharInc		ULONG		?
  rclBkGround		RECTL		{}
  pgp			DWORD		?
  pwzsOrg		DWORD		?
STROBJ ENDS

STROBJ_vEnumStart	PROTO		PROC,
			pstro		:PTR STROBJ

STROBJ_bEnum		PROTO		PROC,
			pstro		:PTR STROBJ,
			pc		:ULONG,
			ppgpos		:PTR GLYPHPOS

SGI_EXTRASPACE		=		0

;-------------------------------------------------------------------------------
; SURFOBJ
;-------------------------------------------------------------------------------
SURFOBJ STRUCT
  dhsurf		DWORD		?
  hsurf			DWORD		?
  dhpdev		DWORD		?
  hdev			DWORD		?
  sizlBitmap		SIZEL		{}
  cjBits		ULONG		?
  pvBits		PVOID		?
  pvScan0		PVOID		?
  lDelta		LONG		?
  iUniq			ULONG		?
  iBitmapFormat		ULONG		?
  iType			USHORT		?
  fjBitmap		USHORT		?
SURFOBJ ENDS

STYPE_BITMAP		=		0
STYPE_DEVICE		=		1
STYPE_JOURNAL		=		2
STYPE_DEVBITMAP		=		3

BMF_1BPP		=		1
BMF_4BPP		=		2
BMF_8BPP		=		3
BMF_16BPP		=		4
BMF_24BPP		=		5
BMF_32BPP		=		6
BMF_4RLE		=		7
BMF_8RLE		=		8

BMF_TOPDOWN		=		0001h
BMF_NOZEROINIT		=		0004h
BMF_DONTCACHE		=		0008h

;-------------------------------------------------------------------------------
; BRUSHOBJ
;-------------------------------------------------------------------------------
BRUSHOBJ STRUCT
  iSolidColor		ULONG		?
  pvRbrush		PVOID		?
BRUSHOBJ ENDS

BRUSHOBJ_pvAllocRbrush	PROTO		PROC,
			pbo		:PTR BRUSHOBJ,
			cj		:ULONG

BRUSHOBJ_pvGetRbrush	PROTO		PROC,
			pbo		:PTR BRUSHOBJ

RB_DITHERCOLOR		=		80000000h

;-------------------------------------------------------------------------------
; CLIPOBJ
;-------------------------------------------------------------------------------
CLIPOBJ STRUCT
  iUniq			ULONG		?
  rclBounds		RECTL		{}
  iDComplexity		BYTE		?
  iFComplexity		BYTE		?
  iMode			BYTE		?
  fjOptions		BYTE		?
CLIPOBJ ENDS

DC_TRIVIAL		=		0
DC_RECT			=		1
DC_COMPLEX		=		3

FC_RECT			=		1
FC_RECT4		=		2
FC_COMPLEX		=		3

TC_RECTANGLES		=		0
TC_PATHOBJ		=		2

OC_BANK_CLIP		=		1

CT_RECTANGLES		=		0

CD_RIGHTDOWN		=		0
CD_LEFTDOWN		=		1
CD_RIGHTUP		=		2
CD_LEFTUP		=		3
CD_ANY			=		4

CD_LEFTWARDS		=		1
CD_UPWARDS		=		2

ENUMRECTS STRUCT
  _c			ULONG		?
  arcl			RECTL		1 DUP({})
ENUMRECTS ENDS

CLIPOBJ_cEnumStart	PROTO		PROC,
			pco		:PTR CLIPOBJ,
			bAll		:BOOL,
			iType		:ULONG,
			iDirection	:ULONG,
			cLimit		:ULONG

CLIPOBJ_bEnum		PROTO		PROC,
			pco		:PTR CLIPOBJ,
			cj		:ULONG,
			pul		:PTR ULONG

CLIPOBJ_ppoGetPath	PROTO		PROC,
			pci		:PTR CLIPOBJ

;-------------------------------------------------------------------------------
; XLATEOBJ
;-------------------------------------------------------------------------------
XLATEOBJ STRUCT
  iUniq			ULONG		?
  flXlate		FLONG		?
  iSrcType		USHORT		?
  iDstType		USHORT		?
  cEntries		ULONG		?
  pulXlate		DWORD		?
XLATEOBJ ENDS

XO_TRIVIAL		=		00000001h
XO_TABLE		=		00000002h
XO_TO_MONO		=		00000004h

XO_SRCPALETTE		=		1
XO_DESTPALETTE		=		2
XO_DESTDCPALETTE	=		3

XLATEOBJ_iXlate		PROTO		PROC,
			pxlo		:PTR XLATEOBJ,
			iColor		:ULONG

XLATEOBJ_piVector	PROTO		PROC,
			pxlo		:PTR XLATEOBJ

XLATEOBJ_cGetPalette	PROTO		PROC,
			pxlo		:PTR XLATEOBJ,
			iPal		:ULONG,
			cPal		:ULONG,
			pPal		:ULONG

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\textout.c ===
/******************************Module*Header*******************************\
*
* Module Name: TEXTOUT.c
* Author: Martin Barber
* Date: Jun. 19, 1995
* Purpose: Handle calls to DrvTxtOut
*
* Copyright (c) 1995,1996 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/TEXTOUT.C  $
*
*    Rev 1.34   Mar 27 1998 14:47:14   frido
* PDR#11280. In the monospaced font loop there was a problem loading
* the pointer to the next glyph bits. It always got the pointer to the
* previous glyph.
*
*    Rev 1.33   Mar 04 1998 15:38:46   frido
* Added new shadow macros.
*
*    Rev 1.32   Dec 17 1997 16:42:14   frido
* PDR#10875: There was a GPF inside vMmClipGlyphExpansion and NT
* 3.51 does not handle this very well. It caused the hardware to wait for
* another DWORD which was never send.
*
*    Rev 1.31   Dec 10 1997 13:32:20   frido
* Merged from 1.62 branch.
*
*    Rev 1.30.1.1   Dec 03 1997 18:12:20   frido
* PDR#11039. Fixed allocation of font cache. In certain cases it would
* allocate too few cells and still use the unallocated cells causing
* corruption.
*
*    Rev 1.30.1.0   Nov 18 1997 15:40:16   frido
* Changed a spelling error: RWQUIRE into REQUIRE.
*
*    Rev 1.30   Nov 03 1997 10:17:36   frido
* Added REQUIRE and WRITE_STRING macros.
* Removed CHECK_QFREE macros.
*
*    Rev 1.29   25 Aug 1997 16:07:24   FRIDO
*
* Fixed lockup in 8-bpp vMmClipGlyphExpansion SWAT7 code.
*
*    Rev 1.28   08 Aug 1997 17:24:30   FRIDO
* Added support for new memory manager.
* Added SWAT7 switches for 8-bpp hardware bug.
*
*    Rev 1.27   29 Apr 1997 16:28:50   noelv
*
* Merged in new SWAT code.
* SWAT:
* SWAT:    Rev 1.7   24 Apr 1997 12:05:38   frido
* SWAT: Fixed a missing "}".
* SWAT:
* SWAT:    Rev 1.6   24 Apr 1997 11:22:18   frido
* SWAT: NT140b09 merge.
* SWAT: Changed pfm into pCell for SWAT3 changes.
* SWAT:
* SWAT:    Rev 1.5   19 Apr 1997 17:11:02   frido
* SWAT: Added SWAT.h include file.
* SWAT: Fixed a bug in DrvDestroyFont causing hangups in 2nd WB97 pass.
* SWAT:
* SWAT:    Rev 1.4   18 Apr 1997 00:34:28   frido
* SWAT: Fixed a merge bug.
* SWAT:
* SWAT:    Rev 1.3   18 Apr 1997 00:15:28   frido
* SWAT: NT140b07 merge.
* SWAT:
* SWAT:    Rev 1.2   10 Apr 1997 16:02:06   frido
* SWAT: Oops, I allocated the font cache in the wrong size.
* SWAT:
* SWAT:    Rev 1.1   09 Apr 1997 17:37:30   frido
* SWAT: New font cache allocation scheme.  Allocate from a 'pool' of cells
* SWAT: instead of putting the font cache all over the place.
*
*    Rev 1.26   08 Apr 1997 12:32:50   einkauf
*
* add SYNC_W_3D to coordinate MCD/2D hw access
*
*    Rev 1.25   21 Mar 1997 13:37:06   noelv
* Added checkes for QFREE.
*
*    Rev 1.24   06 Feb 1997 10:38:04   noelv
* Removed WAIT_FOR_IDLE
*
*    Rev 1.23   04 Feb 1997 11:11:00   SueS
* Added support for hardware clipping for the 5465.
*
*    Rev 1.22   17 Dec 1996 16:59:00   SueS
* Added test for writing to log file based on cursor at (0,0).
*
*    Rev 1.21   26 Nov 1996 10:46:36   SueS
* Changed WriteLogFile parameters for buffering.
*
*    Rev 1.20   13 Nov 1996 17:01:28   SueS
* Changed WriteFile calls to WriteLogFile.
*
*    Rev 1.19   07 Nov 1996 16:10:16   bennyn
*
* Added no offscn mem allocation if DD enabled
*
*    Rev 1.18   06 Sep 1996 15:16:44   noelv
* Updated NULL driver for 4.0
*
*    Rev 1.17   20 Aug 1996 11:04:36   noelv
* Bugfix release from Frido 8-19-96
*
*    Rev 1.3   16 Aug 1996 14:48:20   frido
* Fixed a small wanring error.
*
*    Rev 1.2   15 Aug 1996 11:54:32   frido
* Fixed precompiled headers.
*
*    Rev 1.1   15 Aug 1996 11:38:32   frido
* Added precompiled header.
*
*    Rev 1.0   14 Aug 1996 17:16:32   frido
* Initial revision.
*
*    Rev 1.16   25 Jul 1996 15:56:28   bennyn
*
* Modified to support DirectDraw
*
*    Rev 1.15   28 May 1996 15:11:36   noelv
* Updated data logging.
*
*    Rev 1.14   16 May 1996 15:06:18   bennyn
*
* Added PIXEL_ALIGN to allocoffscnmem()
*
*    Rev 1.13   16 May 1996 14:54:32   noelv
* Added logging code.
*
*    Rev 1.12   03 May 1996 15:09:42   noelv
*
* Added flag to turn caching on and off.
*
*    Rev 1.11   01 May 1996 11:01:48   bennyn
*
* Modified for NT4.0
*
*    Rev 1.10   12 Apr 1996 18:13:06   andys
* Fixed bug in combining 3 bytes into DWORD (<< | bug)
*
*    Rev 1.9   11 Apr 1996 18:00:56   andys
* Added Code to the > 16 PEL case to guard against walking off the end of a b
*
*    Rev 1.8   04 Apr 1996 13:20:32   noelv
* Frido release 26
 *
 *    Rev 1.16   01 Apr 1996 15:29:22   frido
 * Fixed bug in font cache when glyph cannot be cached.
 *
 *    Rev 1.15   28 Mar 1996 23:37:34   frido
 * Fixed drawing of partially left-clipped glyphs.
 *
 *    Rev 1.14   27 Mar 1996 14:12:18   frido
 * Commented changes.
 *
 *    Rev 1.13   25 Mar 1996 11:58:38   frido
 * Removed warning message.
 *
 *    Rev 1.12   25 Mar 1996 11:50:42   frido
 * Bellevue 102B03.
*
*    Rev 1.5   18 Mar 1996 12:34:10   noelv
*
* Added data logging stuff
*
*    Rev 1.4   07 Mar 1996 18:24:14   bennyn
*
* Removed read/modify/write on CONTROL reg
*
*    Rev 1.3   05 Mar 1996 11:59:20   noelv
* Frido version 19
*
*    Rev 1.11   04 Mar 1996 20:23:28   frido
* Cached grCONTROL register.
*
*    Rev 1.10   29 Feb 1996 20:23:08   frido
* Changed some comments.
*
*    Rev 1.9   28 Feb 1996 22:39:46   frido
* Added Optimize.h.
*
*    Rev 1.8   27 Feb 1996 16:38:12   frido
* Added device bitmap store/restore.
*
*    Rev 1.7   24 Feb 1996 01:23:16   frido
* Added device bitmaps.
*
*    Rev 1.6   03 Feb 1996 13:57:24   frido
* Use the compile switch "-Dfrido=0" to disable my extensions.
*
*    Rev 1.5   03 Feb 1996 12:17:58   frido
* Added text clipping.
*
*    Rev 1.4   25 Jan 1996 12:45:56   frido
* Added reinitialization of font cache after mode switch.
*
*    Rev 1.3   24 Jan 1996 23:10:16   frido
* Moved font cache and entry point to assembly for i386.
*
*    Rev 1.2   23 Jan 1996 15:37:20   frido
* Added font cache.
*
\**************************************************************************/

#include "precomp.h"
#include "font.h"
#include "SWAT.h"               // SWAT optimizations

#define TEXT_DBG_LEVEL  1
#define TEXT_DBG_LEVEL1 1
#define RECORD_ON               FALSE
#define BUFFER_EXPAND   FALSE


/*
-------------------------------------------------------------------------------
Module Entry Points:
--------------------
    DrvTextOut()

General Plan:
--------------------
*
* On every TextOut, GDI provides an array of 'GLYPHPOS' structures
* for every glyph to be drawn.  Each GLYPHPOS structure contains a
* the glyph.    (Note that unlike Windows 3.1, which provides a column-
* major glyph bitmap, Windows NT always provides a row-major glyph
* bitmap.)  As such, there are three basic methods for drawing text
* with hardware acceleration:
*
* 1) Glyph caching -- Glyph bitmaps are cached by the accelerator
*       (probably in off-screen memory), and text is drawn by
*       referring the hardware to the cached glyph locations.
*
* 2) Glyph expansion -- Each individual glyph is colour-expanded
*       directly to the screen from the monochrome glyph bitmap
*       supplied by GDI.
*
* 3) Buffer expansion -- The CPU is used to draw all the glyphs into
*       a 1bpp monochrome bitmap, and the hardware is then used
*       to colour-expand the result.
*
* The fastest method depends on a number of variables, such as the
* colour expansion speed, bus speed, CPU speed, average glyph size,
* and average string length.
*
* Copyright (c) 1992-1994 Microsoft Corporation
*
\**************************************************************************/

//
// Data logging stuff.
// Gets compiled out in a free bulid.
//
#if LOG_CALLS
    char BUF[256];

    #if ENABLE_LOG_SWITCH
    #define LogFile(x)                      \
    do {                            \
        if (pointer_switch == 1)                           \
        {                                                       \
    int i = sprintf x ;                     \
        WriteLogFile(ppdev->pmfile, BUF, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);  \
        }                                                       \
    } while(0);                         \

    #else
    #define LogFile(x)                      \
    do {                            \
    int i = sprintf x ;                     \
        WriteLogFile(ppdev->pmfile, BUF, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);  \
    } while(0);                         \

    #endif
#else
    #define BUF 0
    #define LogFile(x)
#endif



POINTL gptlZero = { 0, 0 }; // Specifies that the origin of the
                //  temporary buffer given to the 1bpp
                //  transfer routine for fasttext is
                //  at (0, 0)

/******************************Public*Routine******************************\
* void AddToFontCacheChain
*
* Add the FONTCACHE to the Font cache chain
*
\**************************************************************************/
void AddToFontCacheChain(PDEV*       ppdev,
                         FONTOBJ*    pfo,
                         PFONTCACHE  pfc)
{
        DISPDBG((TEXT_DBG_LEVEL1," AddToFontCacheChain.\n"));

        pfc->pfo = pfo;

#if !SWAT3 // We don't need this anymore.  The cell grid has all the pointers.
        // Hook the font cache into the chain.
        if (ppdev->pfcChain != NULL)
        {
                ppdev->pfcChain->pfcPrev = pfc;
        }

        pfc->pfcPrev = NULL;
        pfc->pfcNext = ppdev->pfcChain;
        ppdev->pfcChain = pfc;
#endif
}


/******************************Public*Routine******************************\
* BOOL bIntersect
*
* If 'prcl1' and 'prcl2' intersect, has a return value of TRUE and returns
* the intersection in 'prclResult'. If they don't intersect, has a return
* value of FALSE, and 'prclResult' is undefined.
*
\**************************************************************************/

BOOL bIntersect(
RECTL*  prcl1,
RECTL*  prcl2,
RECTL*  prclResult)
{
    DISPDBG((TEXT_DBG_LEVEL1," bIntersect.\n"));

    prclResult->left    = max(prcl1->left, prcl2->left);
    prclResult->right   = min(prcl1->right, prcl2->right);

    if (prclResult->left < prclResult->right)
    {
    prclResult->top = max(prcl1->top, prcl2->top);
    prclResult->bottom = min(prcl1->bottom, prcl2->bottom);

    if (prclResult->top < prclResult->bottom)
    {
        return(TRUE);
    }
    }

    return(FALSE);
}




/******************************Public*Routine******************************\
* LONG cIntersect
*
* This routine takes a list of rectangles from 'prclIn' and clips them
* in-place to the rectangle 'prclClip'. The input rectangles don't
* have to intersect 'prclClip'; the return value will reflect the
* number of input rectangles that did intersect, and the intersecting
* rectangles will be densely packed.
*
\**************************************************************************/

LONG cIntersect(
    RECTL*  prclClip,
    RECTL*  prclIn,     // List of rectangles
    LONG    c)          // Can be zero
{
    LONG    cIntersections;
    RECTL*  prclOut;

    DISPDBG((TEXT_DBG_LEVEL1," cIntersect.\n"));
    cIntersections = 0;
    prclOut = prclIn;

    for ( ; c != 0; prclIn++, c--)
    {
        prclOut->left  = max(prclIn->left,  prclClip->left);
        prclOut->right = min(prclIn->right, prclClip->right);

        if (prclOut->left < prclOut->right)
        {
            prclOut->top    = max(prclIn->top,    prclClip->top);
            prclOut->bottom = min(prclIn->bottom, prclClip->bottom);

            if (prclOut->top < prclOut->bottom)
            {
                prclOut++;
                cIntersections++;
            }
        }
    }

    return(cIntersections);
}




/******************************Public*Routine******************************\
* VOID vClipSolid
*
* Fills the specified rectangles with the specified colour, honouring
* the requested clipping.  No more than four rectangles should be passed in.
* Intended for drawing the areas of the opaquing rectangle that extend
* beyond the text box.  The rectangles must be in left to right, top to
* bottom order. Assumes there is at least one rectangle in the list.
*
\**************************************************************************/

VOID vClipSolid(
    PDEV*       ppdev,
    LONG        crcl,
    RECTL*      prcl,
    ULONG       iColor,
    CLIPOBJ*    pco)
{
    BOOL        bMore;  // Flag for clip enumeration
    ENUMRECTS8  ce;     // Clip enumeration object
    ULONG       i;
    ULONG       j;
    #if !(DRIVER_5465 && HW_CLIPPING)
        RECTL       arclTmp[4];
        ULONG       crclTmp;
        RECTL*      prclTmp;
        RECTL*      prclClipTmp;
        LONG        iLastBottom;
    #endif
    RECTL*      prclClip;

    DISPDBG((TEXT_DBG_LEVEL1,"vClipSolid: Entry.\n"));
    ASSERTMSG( (crcl > 0) && (crcl <= 4), "Expected 1 to 4 rectangles");
    ASSERTMSG( (pco != NULL) && (pco->iDComplexity != DC_TRIVIAL),
                "Expected a non-null clip object");

    // Do the loop invariant setup here
    REQUIRE(2);
    LL_DRAWBLTDEF(SOLID_COLOR_FILL, 2);

    if (pco->iDComplexity == DC_RECT)
    {
        crcl = cIntersect(&pco->rclBounds, prcl, crcl);
        while (crcl--)
        {
            REQUIRE(5);
            LL_OP0(prcl->left + ppdev->ptlOffset.x,
                prcl->top + ppdev->ptlOffset.y);
            LL_BLTEXT((prcl->right - prcl->left), (prcl->bottom - prcl->top));
            prcl++;
        }
    }

    else // iDComplexity == DC_COMPLEX
    {
        // Initialize the clip rectangle enumeration to right-down so we can
        // take advantage of the rectangle list being right-down:

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_RIGHTDOWN, 0);

        #if DRIVER_5465 && HW_CLIPPING
            // Set up the hardware clipping
            REQUIRE(6);
            LL_DRAWBLTDEF(SOLID_COLOR_FILL | DD_CLIPEN, 0);
            i = max(0, prcl->left);
            j = max(0, prcl->top);
            LL_OP0(i + ppdev->ptlOffset.x, j + ppdev->ptlOffset.y);
            LL_BLTEXT_EXT(prcl->right - i, prcl->bottom - j);

            do
            {
               // Get a batch of region rectangles:
               bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (VOID*)&ce);

               // Clip the rect list to each region rect:
               for (j = ce.c, prclClip = ce.arcl; j-- > 0; prclClip++)
               {
                    // Draw the clipped rects
                    REQUIRE(5);
                    LL_CLIPULE(prclClip->left + ppdev->ptlOffset.x,
                    prclClip->top + ppdev->ptlOffset.y);
                    LL_CLIPLOR_EX(prclClip->right + ppdev->ptlOffset.x,
                    prclClip->bottom + ppdev->ptlOffset.y);

               } // End for each rectangle in the list.

            } while (bMore); // End loop for each batch
        #else

            // Bottom of last rectangle to fill
            iLastBottom = prcl[crcl - 1].bottom;

            // Scan through all the clip rectangles, looking for intersects
            // of fill areas with region rectangles:

            do
            {
                // Get a batch of region rectangles:
                bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (VOID*)&ce);

                // Clip the rect list to each region rect:
                for (j = ce.c, prclClip = ce.arcl; j-- > 0; prclClip++)
                {
                    // Since the rectangles and the region enumeration are both
                    // right-down, we can zip through the region until we reach
                    // the first fill rect, and are done when we've passed the
                    // last fill rect.

                    if (prclClip->top >= iLastBottom)
                    {
                        // Past last fill rectangle; nothing left to do:
                        return;
                    }

                    // Do intersection tests only if we've reached the top of
                    // the first rectangle to fill:

                    if (prclClip->bottom > prcl->top)
                    {
                        // We've reached the top Y scan of the first rect, so
                        // it's worth bothering checking for intersection.

                        // Generate a list of the rects clipped to this region
                        // rect:

                        prclTmp = prcl;
                        prclClipTmp = arclTmp;

                        for (i = crcl, crclTmp = 0; i-- != 0; prclTmp++)
                        {
                            // Intersect fill and clip rectangles

                            if (bIntersect(prclTmp, prclClip, prclClipTmp))
                            {
                                // Draw the clipped rects
                                REQUIRE(5);
                                LL_OP0(prclClipTmp->left + ppdev->ptlOffset.x,
                                    prclClipTmp->top + ppdev->ptlOffset.y);
                                LL_BLTEXT ( (prclClipTmp->right - prclClipTmp->left) ,
                                    (prclClipTmp->bottom - prclClipTmp->top) );
                             }

                        } // End for each rectangle in the batch.

                    } // End intersect test.

                } // End for each rectangle in the list.

            } while (bMore); // End loop for each batch
        #endif   // if !(DRIVER_5465 && HW_CLIPPING)

    } // End DC_COMPLEX

}

#if SWAT7
/******************************Public*Routine******************************\
* VOID Xfer64Pixels
*
* Copy 64 pixels of font data to the Laguna memory.
*
\**************************************************************************/

VOID Xfer64Pixels(
        PDEV*   ppdev,
        UINT    x,
        UINT    y,
        UINT    bitOffset,
        UINT    height,
        BYTE*   pjGlyph,
        UINT    delta
)
{
        delta = (delta + 7) >> 3;

        REQUIRE(5);
        LL_OP0(x + ppdev->ptlOffset.x, y + ppdev->ptlOffset.y);
        LL_BLTEXT(64, height);

        while (height--)
        {
                REQUIRE(3);
                LL32(grHOSTDATA[0], *(ULONG*) &pjGlyph[0]);
                LL32(grHOSTDATA[1], *(ULONG*) &pjGlyph[4]);
                if (bitOffset > 0)
                {
                        LL32(grHOSTDATA[2], pjGlyph[8]);
                }
                pjGlyph += delta;
        }
}
#endif

/******************************Public*Routine******************************\
* VOID vMmClipGlyphExpansion
*
* Handles any strings that need to be clipped, using the 'glyph
* expansion' method.
*
\**************************************************************************/

VOID vMmClipGlyphExpansion(
PDEV*    ppdev,
STROBJ* pstro,
CLIPOBJ*    pco)
{
    BOOL        bMoreGlyphs;
    ULONG       cGlyphOriginal;
    ULONG       cGlyph;
    GLYPHPOS*   pgpOriginal;
    GLYPHPOS*   pgp;
    GLYPHBITS*  pgb;
    POINTL      ptlOrigin;
    BOOL        bMore;
    ENUMRECTS8  ce;
    RECTL*      prclClip;
    ULONG       ulCharInc;
    LONG        cxGlyph;
    LONG        cyGlyph;
    BYTE*       pjGlyph;
    BYTE*       pTmp;
    LONG        cj;
    LONG        cw;
    LONG        xLeft;
    LONG        yTop;
    LONG        xRight;
    LONG        yBottom;
    LONG        xBias;
    LONG        lDelta;
    LONG        cx;
    LONG        cy;
#if SWAT7
        UINT            xOrigin;
#endif

    DISPDBG((TEXT_DBG_LEVEL1,"vMmClipGlyphExpansion: Entry.\n"));

    ASSERTMSG(pco != NULL, "Don't expect NULL clip objects here");

    do // Loop for each batch of glyphs to be done.
    {
        //
        // Get a batch of glyphs.
        //

        if (pstro->pgp != NULL)
        {
            // There's only the one batch of glyphs, so save ourselves
            // a call:

            pgpOriginal = pstro->pgp;
            cGlyphOriginal = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
        }

        //
        // cGlyphOrigional is the number of glyphs in the batch before they
        // are clipped.
        // bMoreGlyphs is TRUE if there are more batches to be done after
        // this one.
        //

        if (cGlyphOriginal > 0) // Were there any glyphs in the batch?
        {
            ulCharInc = pstro->ulCharInc;

            if (pco->iDComplexity == DC_RECT)
            {
                //
                // We could call 'cEnumStart' and 'bEnum' when the clipping is
                // DC_RECT, but the last time I checked, those two calls took
                // more than 150 instructions to go through GDI. Since
                // 'rclBounds' already contains the DC_RECT clip rectangle,
                // and since it's such a common case, we'll special case it:
                //

                bMore    = FALSE; // No more clip lists to do.
                prclClip = &pco->rclBounds;
                ce.c     = 1;     // Only one rectangle in this list.

                goto SingleRectangle;
            }

            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

            do // For each list of rectangles.
            {
                bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                // For each rectangle in the list.
                for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
                {
                    SingleRectangle:

                    pgp    = pgpOriginal;
                    cGlyph = cGlyphOriginal;
                    pgb    = pgp->pgdf->pgb;

                    ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
                    ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

                    // Loop through all the glyphs for this rectangle:
                    while (TRUE)
                    {
                        LogFile((BUF, "GC:M\r\n"));

                        cxGlyph = pgb->sizlBitmap.cx;
                        cyGlyph = pgb->sizlBitmap.cy;

                        pjGlyph = pgb->aj;
                                                #if SWAT7
                                                lDelta  = (cxGlyph + 7) >> 3;
                                                #endif

                        if ((prclClip->left <= ptlOrigin.x) &&
                            (prclClip->top  <= ptlOrigin.y) &&
                            (prclClip->right  >= ptlOrigin.x + cxGlyph) &&
                            (prclClip->bottom >= ptlOrigin.y + cyGlyph))
                        {
                            //-----------------------------------------------------
                            // Unclipped glyph

                                                        #if SWAT7
                                                        xOrigin = ptlOrigin.x;
                                                        #endif

                                                        #if SWAT7
                                                        //
                                                        // Test for 5465AD hardware bug in 8-bpp.
                                                        //
                                                        if (   (cxGlyph > 64) && (cxGlyph < 128)
                                                                && (ppdev->iBytesPerPixel == 1)
                                                        )
                                                        {
                                                                Xfer64Pixels(ppdev, xOrigin, ptlOrigin.y, 0,
                                                                                cyGlyph, pjGlyph, cxGlyph);
                                                                pjGlyph += 64 / 8;
                                                                xOrigin += 64;
                                                                cxGlyph -= 64;
                                                        }
                            REQUIRE(5);
                            LL_OP0(xOrigin + ppdev->ptlOffset.x,
                                                                   ptlOrigin.y + ppdev->ptlOffset.y);
                                                        #else
                            REQUIRE(5);
                            LL_OP0(ptlOrigin.x + ppdev->ptlOffset.x,
                                    ptlOrigin.y + ppdev->ptlOffset.y);
                                                        #endif
                            LL_BLTEXT(cxGlyph, cyGlyph);

                            if (cxGlyph <= 8)
                            {
                                //-----------------------------------------------------
                                // 1 to 8 pels in width

                                while ( cyGlyph-- )
                                {
                                    REQUIRE(1);
                                                                        #if SWAT7
                                    LL32 (grHOSTDATA[0], *pjGlyph);
                                                                        pjGlyph += lDelta;
                                                                        #else
                                    LL32 (grHOSTDATA[0], *pjGlyph++);
                                                                        #endif
                                                                }

                            }

                            else if (cxGlyph <= 16)
                            {
                                //-----------------------------------------------------
                                // 9 to 16 pels in width

                                while ( cyGlyph-- )
                                {
                                    REQUIRE(1);
                                                                        #if SWAT7
                                    LL32 (grHOSTDATA[0], *(USHORT*)pjGlyph);
                                                                        pjGlyph += lDelta;
                                                                        #else
                                    LL32 (grHOSTDATA[0], *((USHORT*)pjGlyph)++);
                                                                        #endif
                                                                }
                            }

                            else
                            {
                                //-----------------------------------------------------
                                // More than 16 pels in width

                                                                #if SWAT7
                                                                cw = (cxGlyph + 31) >> 5;
                                                                #else
                                lDelta = (pgb->sizlBitmap.cx + 7) >> 3;
                                cw   = (lDelta + 3) >> 2;
                                                                #endif
                                pTmp = pjGlyph + lDelta * pgb->sizlBitmap.cy;

                                for (;cyGlyph!=1; cyGlyph--)
                                {
                                                                        WRITE_STRING(pjGlyph, cw);
                                    pjGlyph += lDelta;
                                }

                                {
                                    ULONG *pSrc = (ULONG*) pjGlyph + cw - 1;
                                                                        WRITE_STRING(pjGlyph, cw - 1);

                                    if ((BYTE *)pSrc+4<=pTmp)
                                    {
                                        REQUIRE(1);
                                        LL32 (grHOSTDATA[0], *pSrc++ );
                                    }
                                    else
                                    {
                                        int Extra = (ULONG) pTmp - (ULONG) pSrc;
                                        BYTE * pByte = (BYTE *)pSrc;
                                        ULONG ulData;

                                        DISPDBG((TEXT_DBG_LEVEL1,
                                            "Caught it %s %d %d %x %x\n", __FILE__, __LINE__, Extra, pTmp, pSrc));

                                        if (Extra == 1)
                                            ulData = (ULONG)(*pByte);
                                        else if (Extra == 2)
                                            ulData = (ULONG)(*(USHORT*)pByte);
                                        else
                                            ulData = (((ULONG)*(pByte+2) << 8) | (ULONG)*(pByte+1)) << 8 | *pByte;

                                        REQUIRE(1);
                                        LL32 (grHOSTDATA[0], ulData );
                                    }
                                }
                            } // End 16 pels or wider.
                        } // End unclipped glyph.

                        else
                        {
                            //-----------------------------------------------------
                            // Clipped glyph

                            // Find the intersection of the glyph rectangle
                            // and the clip rectangle:

                            xLeft   = max(prclClip->left,   ptlOrigin.x);
                            yTop    = max(prclClip->top,    ptlOrigin.y);
                            xRight  = min(prclClip->right,  ptlOrigin.x + cxGlyph);
                            yBottom = min(prclClip->bottom, ptlOrigin.y + cyGlyph);

                            // Check for trivial rejection:
                            if (((cx = xRight - xLeft) > 0) &&
                                ((cy = yBottom - yTop) > 0))
                            {

                                xBias = (xLeft - ptlOrigin.x) & 7;

                                // 'xBias' is the bit position in the monochrome glyph
                                // bitmap of the first pixel to be lit, relative to
                                // the start of the byte.   That is, if 'xBias' is 2,
                                // then the first unclipped pixel is represented by bit
                                // 2 of the corresponding bitmap byte.
                                //
                                // Normally, the accelerator expects bit 0 to be the
                                // first lit byte.  We set the host phase to discard the
                                // first 'xBias' bits.
                                //

                                if ( xBias )
                                {
                                    REQUIRE(2);
                                    LL_OP2_MONO (xBias,0);
                                }

                                                                #if !SWAT7
                                REQUIRE(5);
                                LL_OP0(xLeft + ppdev->ptlOffset.x,
                                        yTop + ppdev->ptlOffset.y);
                                LL_BLTEXT (cx, cy);
                                                                #endif

                                lDelta   = (cxGlyph + 7) >> 3;

                                // compute the end-of-glyph marker before
                                // clipping the glyph.
                                pTmp = pjGlyph + lDelta * cy;

                                pjGlyph += (yTop - ptlOrigin.y) * lDelta
                                     + ((xLeft - ptlOrigin.x) >> 3);

                                                                #if SWAT7
                                                                //
                                                                // Test for 5465AD hardware bug in 8-bpp.
                                                                //
                                                                if (   (cx > 64) && (cx < 128)
                                                                        && (ppdev->iBytesPerPixel == 1)
                                                                )
                                                                {
                                                                        Xfer64Pixels(ppdev, xLeft, yTop, xBias, cy,
                                                                                        pjGlyph, cxGlyph);
                                                                        pjGlyph += 64 / 8;
                                                                        xLeft += 64;
                                                                        cx -= 64;
                                                                }

                                REQUIRE(5);
                                LL_OP0(xLeft + ppdev->ptlOffset.x,
                                                                           yTop + ppdev->ptlOffset.y);
                                LL_BLTEXT (cx, cy);
                                                                #endif

                                cj = (cx + xBias + 31) >> 5;

                                for (;cy!=1; cy--)
                                {
                                                                        WRITE_STRING(pjGlyph, cj);
                                    pjGlyph += lDelta;
                                }

                                {
                                    ULONG *pSrc = (ULONG*) pjGlyph + cj - 1;

                                    int Extra = (ULONG) pTmp - (ULONG) pSrc;
                                    BYTE * pByte = (BYTE *)pSrc;
                                    ULONG ulData;

                                                                        WRITE_STRING(pjGlyph, cj - 1);

                                    if (Extra == 1)
                                        ulData = (ULONG)(*pByte);
                                    else if (Extra == 2)
                                        ulData = (ULONG)(*(USHORT*)pByte);
                                    else if (Extra == 3)
                                        ulData = (((ULONG)*(pByte+2) << 8) | (ULONG)*(pByte+1)) << 8 | *pByte;
                                                                        else
                                                                                ulData = *pSrc;

                                    REQUIRE(1);
                                    LL32 (grHOSTDATA[0], ulData );
                                }

                                if (xBias != 0)
                                {
                                    REQUIRE(2);
                                    LL_OP2_MONO(0,0);
                                }

                            } // if not trivially rejected.

                        } // End clipped glyph.

                        //
                        // If we're out of glyphs the get next batch.
                        if (--cGlyph == 0)
                            break;

                        // Get ready for next glyph:
                        pgp++;
                        pgb = pgp->pgdf->pgb;

                        //
                        // Calculate where to place the next glyph.
                        // If this is mono spaced text, we may need to
                        // skip over some pixels to make our characters
                        // line up.
                        //
                        if (ulCharInc == 0)
                        {
                            ptlOrigin.x = pgp->ptl.x + pgb->ptlOrigin.x;
                            ptlOrigin.y = pgp->ptl.y + pgb->ptlOrigin.y;
                        }
                        else
                        {
                            ptlOrigin.x += ulCharInc;
                        }

                    } // End loop for each glyph in the batch.

                } // End for each rectangle in the list.

            } while (bMore); // Loop for each batch of clipping rectangles.

        } // If there were any glyphs in this batch.

    } while (bMoreGlyphs); // Loop for each batch of glyphs.

} // End clipped glyph expansion.




/******************************Public*Routine******************************\
* BOOL DrvTextOut
*
* If it's the fastest method, outputs text using the 'glyph expansion'
* method.   Each individual glyph is colour-expanded directly to the
* screen from the monochrome glyph bitmap supplied by GDI.
*
* If it's not the fastest method, calls the routine that implements the
* 'buffer expansion' method.
*
\**************************************************************************/

#if (USE_ASM && defined(i386))
BOOL i386DrvTextOut(
#else
BOOL APIENTRY DrvTextOut(
#endif
SURFOBJ*    pso,
STROBJ*     pstro,
FONTOBJ*    pfo,
CLIPOBJ*    pco,
RECTL*      prclExtra,  // If we had set GCAPS_HORIZSTRIKE, we would have
                // to fill these extra rectangles (it is used
                // largely for underlines). It's not a big
                // performance win (GDI will call our DrvBitBlt
                // to draw the extra rectangles).
RECTL*      prclOpaque,
BRUSHOBJ*   pboFore,
BRUSHOBJ*   pboOpaque,
POINTL*     pptlBrush,
MIX         mix)
{
    PDEV*           ppdev;
    BOOL            bTextPerfectFit;
    ULONG           cGlyph;
    BOOL            bMoreGlyphs;
    GLYPHPOS*       pgp;
    GLYPHBITS*      pgb;
    BYTE*           pjGlyph;
    BYTE*           pTmp;
        #if SWAT7
        LONG                    cxGlyph;
        #endif
    LONG            cyGlyph;
    POINTL          ptlOrigin;
    LONG            ulCharInc;
    BYTE            iDComplexity;
    LONG            lDelta;
    LONG            cw;
    ULONG           iFGColor;
    ULONG           iBGColor;
    ULONG           bitCount;
        #if SWAT7
        UINT                    xOrigin;
        #endif

    #if NULL_TEXTOUT
    {
        if (pointer_switch)    return TRUE;
    }
    #endif

    DISPDBG((TEXT_DBG_LEVEL,"DrvTextOut: Entry.\n"));


    // The DDI spec says we'll only ever get foreground and background
    // mixes of R2_COPYPEN:

    ASSERTMSG(mix == 0x0d0d, "GDI should only give us a copy mix");

    ppdev = (PDEV*) pso->dhpdev;

    SYNC_W_3D(ppdev);   // if 3D context(s) active, make sure 3D engine idle before continuing...

    if (pso->iType == STYPE_DEVBITMAP)
    {
        PDSURF pdsurf = (PDSURF)pso->dhsurf;
        LogFile((BUF, "DTO Id=%p ", pdsurf));
        if (pdsurf->pso)
        {
            if ( !bCreateScreenFromDib(ppdev, pdsurf) )
            {
                LogFile((BUF, "DTO: D=DH (punted)\r\n"));
                return(EngTextOut(pdsurf->pso, pstro, pfo, pco, prclExtra,
                  prclOpaque, pboFore, pboOpaque, pptlBrush, mix));
        }
        else
        {
            LogFile((BUF, "DTO: D=DF "));
        }


        }
        else
        {
            LogFile((BUF, "DTO: D=D "));
        }
        ppdev->ptlOffset.x = pdsurf->ptl.x;
        ppdev->ptlOffset.y = pdsurf->ptl.y;
    }
    else
    {
        LogFile((BUF, "DTO: D=S "));
        ppdev->ptlOffset.x = ppdev->ptlOffset.y = 0;
    }

    //
    // Dump information about the call to the log file.
    //
    LogFile((BUF, "FG=%X BG=%X ",
                  pboFore->iSolidColor, pboOpaque->iSolidColor));
    LogFile((BUF, "C=%s ",
        (pco == NULL) ? "N " :
          ((pco->iDComplexity == DC_TRIVIAL) ? "T" :
             ((pco->iDComplexity == DC_RECT) ? "R" : "C" ))
    ));
    LogFile((BUF, "%s ", (prclOpaque != NULL) ? "O" : "T"));
    LogFile((BUF, "%s ", (pstro->ulCharInc == 0) ? "P" : "M"));


    #if !(USE_ASM && defined(i386))
    // If we have a font that is cached but the screen has been reinitialized,
    // we delete the font from memory and try again.

    if (ppdev->UseFontCache == 0)
        pfo->pvConsumer = (VOID*) -1;

    if (pfo->pvConsumer != NULL && pfo->pvConsumer != (PVOID) -1)
    {
        if (((PFONTCACHE) pfo->pvConsumer)->ulFontCount != ppdev->ulFontCount)
        {
            LogFile((BUF, "FCD "));
            DrvDestroyFont(pfo);
        }
        else
            LogFile((BUF, "GC=2 "));
    }

    if (pfo->pvConsumer == (PVOID) -1)
    {
        LogFile((BUF, "GC=3"));
    }


    // If we have a font that has not yet been cached, try caching it.
    if (pfo->pvConsumer == NULL)
    {
        // New font, check it out.
        int height = pstro->rclBkGround.bottom - pstro->rclBkGround.top;
        LogFile((BUF, "GC="));

#if SWAT3
            if (height > FONTCELL_Y * 3 / 2)
#else
        if (height > LINES_PER_TILE * 3 / 2)
#endif
            {
                // Font too big, mark is as uncacheable.
                LogFile((BUF, "0size "));
                pfo->pvConsumer = (PVOID) -1;
            }
            else
            {
                // Allocate memory for the font cache.
                #ifdef WINNT_VER40
                    pfo->pvConsumer = MEM_ALLOC(FL_ZERO_MEMORY, sizeof(FONTCACHE), ALLOC_TAG);
                #else
                    pfo->pvConsumer = MEM_ALLOC(LMEM_FIXED | LMEM_ZEROINIT, sizeof(FONTCACHE));
                #endif
                if (pfo->pvConsumer == NULL)
                {
                    // Not enough memory, mark it as uncacheable.
                    LogFile((BUF, "0mem "));
                    pfo->pvConsumer = (PVOID) -1;
                }
                else
                {
                    LogFile((BUF, "1 "));

                                AddToFontCacheChain(ppdev, pfo, pfo->pvConsumer);

                // Store device this font belongs to.
                ((PFONTCACHE) pfo->pvConsumer)->ppdev = ppdev;
            }
        }
    }

    #endif

    // Set FG / BG colors at this level

    iFGColor = pboFore->iSolidColor;
    iBGColor = pboOpaque->iSolidColor;

    switch (ppdev->iBitmapFormat)
    {
        case BMF_8BPP:
            iFGColor |= iFGColor << 8;
            iBGColor |= iBGColor << 8;

        case BMF_16BPP:
            iFGColor |= iFGColor << 16;
            iBGColor |= iBGColor << 16;
            break;
    }

    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    #if !(USE_ASM && defined(i386))
    // Can we use the font cache?
    if (  (pfo->pvConsumer != (PVOID) -1) && (iDComplexity != DC_COMPLEX)
       && (((PFONTCACHE) pfo->pvConsumer)->ppdev == ppdev))
    {
        // Set color registers.
        REQUIRE(4);
        LL_BGCOLOR(iBGColor, 2);
        LL_FGCOLOR(iFGColor, 2);

        if (prclOpaque != NULL)
        {
            #if LOG_CALLS
                #define FIT_FLAGS (SO_ZERO_BEARINGS      | \
                       SO_FLAG_DEFAULT_PLACEMENT | \
                       SO_MAXEXT_EQUAL_BM_SIDE   | \
                       SO_CHAR_INC_EQUAL_BM_BASE)

                    bTextPerfectFit =
                        (pstro->flAccel & FIT_FLAGS) == FIT_FLAGS;

                if (!(bTextPerfectFit)                              ||
                   (pstro->rclBkGround.top    > prclOpaque->top)    ||
                   (pstro->rclBkGround.left   > prclOpaque->left)   ||
                   (pstro->rclBkGround.right  < prclOpaque->right)  ||
                   (pstro->rclBkGround.bottom < prclOpaque->bottom))
                {
                    LogFile((BUF, "FIT=N "));
                }
                else
                {
                    LogFile((BUF, "FIT=Y "));
                }
            #endif


            // Draw opaqueing rectangle.
            if (iDComplexity == DC_TRIVIAL)
            {
                REQUIRE(7);
                LL_DRAWBLTDEF(SOLID_COLOR_FILL, 0);
                LL_OP0(prclOpaque->left + ppdev->ptlOffset.x,
                  prclOpaque->top + ppdev->ptlOffset.y);
                LL_BLTEXT(prclOpaque->right - prclOpaque->left,
                  prclOpaque->bottom - prclOpaque->top);
            }
            else
            {
                LONG x, y, cx, cy;
                x = max(prclOpaque->left, pco->rclBounds.left);
                y = max(prclOpaque->top, pco->rclBounds.top);
                cx = min(prclOpaque->right, pco->rclBounds.right) - x;
                cy = min(prclOpaque->bottom, pco->rclBounds.bottom) - y;
                if ( (cx > 0) && (cy > 0) )
                {
                    REQUIRE(7);
                        LL_DRAWBLTDEF(SOLID_COLOR_FILL, 0);
                    LL_OP0(x + ppdev->ptlOffset.x, y + ppdev->ptlOffset.y);
                    LL_BLTEXT(cx, cy);
                }
            }
        }

        // Enable bit swizzling and set DRAWBLTDEF.
        ppdev->grCONTROL |= SWIZ_CNTL;
        LL16(grCONTROL, ppdev->grCONTROL);
        REQUIRE(2);
        LL_DRAWBLTDEF(CACHE_EXPAND_XPAR, 2);
        LogFile((BUF, "UC"));
        LogFile((BUF, "\r\n"));

        // Call the font cache handler.
        if (iDComplexity == DC_TRIVIAL)
        {
               FontCache((PFONTCACHE) pfo->pvConsumer, pstro);
        }
        else
        {
               ClipCache((PFONTCACHE) pfo->pvConsumer, pstro, pco->rclBounds);
        }

        // Disable bit swizzling.
        ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
        LL16(grCONTROL, ppdev->grCONTROL);
        return(TRUE);
    }
    #endif

    DISPDBG((TEXT_DBG_LEVEL1,"DrvTextOut: Setting FG/BG Color.\n"));
    REQUIRE(4);
    LL_BGCOLOR(iBGColor, 2);
    LL_FGCOLOR(iFGColor, 2);

    ppdev->grCONTROL |= SWIZ_CNTL;
    LL16(grCONTROL, ppdev->grCONTROL);

    if (prclOpaque != NULL)
    {
        DISPDBG((TEXT_DBG_LEVEL1,"DrvTextOut: Setting Opaque.\n"));
        ////////////////////////////////////////////////////////////
        // Opaque Initialization
        ////////////////////////////////////////////////////////////
        //
        // If we paint the glyphs in 'opaque' mode, we may not actually
        // have to draw the opaquing rectangle up-front -- the process
        // of laying down all the glyphs will automatically cover all
        // of the pixels in the opaquing rectangle.
        //
        // The condition that must be satisfied is that the text must
        // fit 'perfectly' such that the entire background rectangle is
        // covered, and none of the glyphs overlap (if the glyphs
        // overlap, such as for italics, they have to be drawn in
        // transparent mode after the opaquing rectangle is cleared).
        //

        #define PERFECT_FIT_FLAGS (SO_ZERO_BEARINGS          | \
            SO_FLAG_DEFAULT_PLACEMENT | \
            SO_MAXEXT_EQUAL_BM_SIDE   | \
            SO_CHAR_INC_EQUAL_BM_BASE)

        bTextPerfectFit =
            (pstro->flAccel & PERFECT_FIT_FLAGS) == PERFECT_FIT_FLAGS;

        if (!(bTextPerfectFit)                              ||
             (pstro->rclBkGround.top    > prclOpaque->top)  ||
             (pstro->rclBkGround.left   > prclOpaque->left) ||
             (pstro->rclBkGround.right  < prclOpaque->right)||
             (pstro->rclBkGround.bottom < prclOpaque->bottom))
        {
            //
            // Draw opaquing rectangle.
            //

            if (iDComplexity == DC_TRIVIAL)
            {
                DISPDBG((TEXT_DBG_LEVEL1,"DrvTextOut: Opaque DC_TRIVIAL.\n"));
                REQUIRE(7);
                LL_DRAWBLTDEF(SOLID_COLOR_FILL, 0);
                LL_OP0(prclOpaque->left + ppdev->ptlOffset.x,
                        prclOpaque->top + ppdev->ptlOffset.y);
                LL_BLTEXT ((prclOpaque->right - prclOpaque->left) ,
                        (prclOpaque->bottom - prclOpaque->top) );
            }
            else
            {
                vClipSolid(ppdev, 1, prclOpaque, pboOpaque->iSolidColor, pco);
            }

            LogFile((BUF, "FIT=N "));
            // Opaquing rectangle has been drawn, now
            // we do transparent text.
        }
        else
        {
             LogFile((BUF, "FIT=Y "));
            // We don't have to draw the opaquing rectangle because
            // the text is an exact fit.
            goto TextInitOpaque;
        }

    } // End (prclOpaque != NULL)

    LogFile((BUF, "\r\n"));

    ////////////////////////////////////////////////////////////
    // Transparent Initialization
    ////////////////////////////////////////////////////////////


    // Initialize the hardware for transparent text:

    //
    // Set the chip up to do transparent text.
    //
    DISPDBG((TEXT_DBG_LEVEL1,"DrvTextOut: Setting XPAR Text.\n"));
    LL_DRAWBLTDEF(TEXT_EXPAND_XPAR, 2);

    goto TextInitDone;

TextInitOpaque:

    //
    // Set the chip up to do opaque text.
    // Any opaquing rectangle needed has been drawn by now.
    //
    DISPDBG((TEXT_DBG_LEVEL1,"DrvTextOut: Setting Opaque Text.\n"));
    LL_DRAWBLTDEF(TEXT_EXPAND_OPAQUE, 2);

TextInitDone:

    //
    // We're all set up to do either opaque or transparent text.
    // If necessary, any opaquing has been done by now.
    // So let's draw some glyphs on the screen.
    //

    REQUIRE(2);
    LL_OP2_MONO (0,0); // Set Zero phase for transfers
    if (iDComplexity == DC_TRIVIAL)
    {
        do // Loop while there are glyphs to draw.
        {
            //
            // Get a batch of glyphs to draw.
            //

            if (pstro->pgp != NULL)
            {
                DISPDBG((TEXT_DBG_LEVEL1,"DrvTextOut: One batch of Glyphs.\n"));
                // There's only the one batch of glyphs, so save ourselves
                // a call:

                pgp = pstro->pgp;
                cGlyph = pstro->cGlyphs;
                bMoreGlyphs = FALSE;
            }
            else
            {
                DISPDBG((TEXT_DBG_LEVEL1,
                    "DrvTextOut: Calling STROBJ_bEnum for Glyphs.\n"));
                bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
            }

            //
            // cGlyph is the count of glyphs in this batch.
            // bMorGlyphs is TRUE if there is another batch waiting for
            // us after this one.
            //

            if (cGlyph > 0)
            {
                //
                // Check the type of spacing.
                //

                if (pstro->ulCharInc == 0)
                {
                    ///////////////////////////////////////////////////////////
                    // Proportional Spacing

                    DISPDBG((TEXT_DBG_LEVEL1,
                        "DrvTextOut: Proportional Spacing.\n"));

                    while (TRUE) // Loop once for each Glyph.
                    {
                        pgb = pgp->pgdf->pgb;

                        LogFile((BUF, "GC:M\r\n"));

                                                #if !SWAT7
                        REQUIRE(5);
                        LL_OP0(pgp->ptl.x + pgb->ptlOrigin.x + ppdev->ptlOffset.x,
                                    pgp->ptl.y + pgb->ptlOrigin.y + ppdev->ptlOffset.y);
                        LL_BLTEXT (pgb->sizlBitmap.cx, pgb->sizlBitmap.cy);
                                                #endif

                                                #if SWAT7
                                                xOrigin = pgp->ptl.x + pgb->ptlOrigin.x;
                                                cxGlyph = pgb->sizlBitmap.cx;
                                                lDelta  = (cxGlyph + 7) >> 3;
                                                #endif
                        pjGlyph = pgb->aj;
                        cyGlyph = pgb->sizlBitmap.cy;

                                                #if SWAT7
                                                //
                                                // Test for 5465AD hardware bug in 8-bpp.
                                                //
                                                if (   (cxGlyph > 64) && (cxGlyph < 128)
                                                        && (ppdev->iBytesPerPixel == 1)
                                                )
                                                {
                                                        Xfer64Pixels(ppdev, xOrigin, pgp->ptl.y +
                                                                        pgb->ptlOrigin.y, 0, cyGlyph, pjGlyph,
                                                                        cxGlyph);
                                                        pjGlyph += 64 / 8;
                                                        xOrigin += 64;
                                                        cxGlyph -= 64;
                                                }

                        REQUIRE(5);
                        LL_OP0(xOrigin + ppdev->ptlOffset.x, pgp->ptl.y +
                                                                pgb->ptlOrigin.y + ppdev->ptlOffset.y);
                        LL_BLTEXT (cxGlyph, cyGlyph);
                                                #endif

                        // The monochrome bitmap describing the glyph is
                        // byte-aligned.  This means that if the glyph is
                        // 1 to 8 pels in width, each row of the glyph is
                        // defined in consecutive bytes; if the glyph is 9
                        // to 16 pels in width, each row of the glyph is
                        // defined in consecutive words, etc.
                        //

                                                #if SWAT7
                        if (cxGlyph <= 8)
                                                #else
                        if (pgb->sizlBitmap.cx <= 8)
                                                #endif
                        {
                            //--------------------------------------------------
                            // 1 to 8 pels in width
                            // 91% of all glyphs will go through this path.

                            while (cyGlyph--)
                                                        #if SWAT7
                            {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], *pjGlyph);
                                                                pjGlyph += lDelta;
                            }
                                                        #else
                            REQUIRE(1);
                                                                LL32 (grHOSTDATA[0], *pjGlyph++);

                            // We're a bit tricky here in order to avoid letting
                            // the compiler tail-merge this code (which would
                            // add an extra jump):

                            pgp++;
                            if (--cGlyph != 0)
                                continue; // Go do the next glyph.

                            break;  // Done with all glyphs in this batch.
                                    // breakout of Glyph Loop.
                                                        #endif
                        }

                                                #if SWAT7
                        else if (cxGlyph <= 16)
                                                #else
                        else if (pgb->sizlBitmap.cx <= 16)
                                                #endif
                        {
                            //--------------------------------------------------
                            // 9 to 16 pels in width
                            // 5% of all glyphs will go through this path.

                            while ( cyGlyph-- )
                                                        #if SWAT7
                            {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], *(USHORT*)pjGlyph);
                                                                pjGlyph += lDelta;
                                                        }
                                                        #else
                                REQUIRE(1);
                                LL32 (grHOSTDATA[0], *((USHORT*)pjGlyph)++);
                                                        #endif
                        }

                        else
                        {
                            //--------------------------------------------------
                            // More than 16 pels in width

                                                        #if SWAT7
                            cw = (cxGlyph + 31) >> 5;
                                                        #else
                            lDelta = (pgb->sizlBitmap.cx + 7) >> 3;
                            cw = (lDelta + 3) >> 2;
                                                        #endif

                            pTmp = pjGlyph + lDelta * pgb->sizlBitmap.cy;

                            for (;cyGlyph!=1; cyGlyph--)
                            {
                                                                WRITE_STRING(pjGlyph, cw);
                                pjGlyph += lDelta;
                            }

                            {
                                ULONG *pSrc = (ULONG*) pjGlyph + cw - 1;
                                                                WRITE_STRING(pjGlyph, cw - 1);

                                if ((BYTE *)pSrc+4<=pTmp)
                                {
                                    REQUIRE(1);
                                    LL32 (grHOSTDATA[0], *pSrc++ );
                                }
                                else
                                {
                                    int Extra = (ULONG) pTmp - (ULONG) pSrc;
                                    BYTE * pByte = (BYTE *)pSrc;
                                    ULONG ulData;

                                    DISPDBG((TEXT_DBG_LEVEL1,
                                        "Caught it %s %d %d %x %x\n", __FILE__, __LINE__, Extra, pTmp, pSrc));

                                    if (Extra == 1)
                                        ulData = (ULONG)(*pByte);
                                    else if (Extra == 2)
                                        ulData = (ULONG)(*(USHORT*)pByte);
                                    else
                                        ulData = (((ULONG)*(pByte+2) << 8) | (ULONG)*(pByte+1)) << 8 | *pByte;

                                    REQUIRE(1);
                                    LL32 (grHOSTDATA[0], ulData );
                                }
                            }

                        } // END pel width test.

                        pgp++;    // Next glyph
                        if (--cGlyph == 0)
                            break;  // Done with this batch.
                                    // Break out of the Glyph Loop.

                    } // End Glyph Loop.

                } // End porportional characters.

                else
                {
                    ////////////////////////////////////////////////////////////
                    // Mono Spacing

                    DISPDBG((TEXT_DBG_LEVEL1,"DrvTextOut: Mono Spacing.\n"));

                    ulCharInc = pstro->ulCharInc;
                    pgb = pgp->pgdf->pgb;

                    ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
                    ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

                    while (TRUE) // Loop once for each Glyph in the batch.
                    {
                        LogFile((BUF, "GC:M\r\n"));
                        pgb = pgp->pgdf->pgb;

                                                #if !SWAT7
                        REQUIRE(5);
                        LL_OP0(ptlOrigin.x + ppdev->ptlOffset.x,
                                ptlOrigin.y + ppdev->ptlOffset.y);

                        ptlOrigin.x += ulCharInc;

                        LL_BLTEXT (pgb->sizlBitmap.cx, pgb->sizlBitmap.cy);
                                                #endif

                        pjGlyph = pgb->aj;
                        cyGlyph = pgb->sizlBitmap.cy;
                                                #if SWAT7
                                                xOrigin = ptlOrigin.x;
                                                cxGlyph = pgb->sizlBitmap.cx;
                                                lDelta  = (cxGlyph + 7) >> 3;

                                                //
                                                // Test for 5465AD hardware bug in 8-bpp.
                                                //
                                                if (   (cxGlyph > 64) && (cxGlyph < 128)
                                                        && (ppdev->iBytesPerPixel == 1)
                                                )
                                                {
                                                        Xfer64Pixels(ppdev, xOrigin, ptlOrigin.y, 0,
                                                                        cyGlyph, pjGlyph, cxGlyph);
                                                        pjGlyph += 64 / 8;
                                                        xOrigin += 64;
                                                        cxGlyph -= 64;
                                                }

                                                REQUIRE(5);
                                                LL_OP0(xOrigin + ppdev->ptlOffset.x,
                                   ptlOrigin.y + ppdev->ptlOffset.y);

                        ptlOrigin.x += ulCharInc;

                        LL_BLTEXT (cxGlyph, cyGlyph);
                                                #endif

                        //
                        // Note: Mono spacing does not guarantee that all the
                        //  glyphs are the same size -- that is, we cannot
                        //  move the size check out of this inner loop,
                        //  unless we key off some more of the STROBJ
                        //  accelerator flags.
                        //  We are not guarenteed the Glyphs are the same size,
                        //  only that they are the same distance apart.
                        //

                                                #if SWAT7
                        if (cxGlyph <= 8)
                                                #else
                        if (pgb->sizlBitmap.cx <= 8)
                                                #endif
                        {
                            //-----------------------------------------------------
                            // 1 to 8 pels in width

                            while ( cyGlyph-- )
                                                        #if SWAT7
                                                        {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], *pjGlyph);
                                                                pjGlyph += lDelta;
                                                        }
                                                        #else
                                REQUIRE(1);
                                LL32 (grHOSTDATA[0], *pjGlyph++);
                                                        #endif

                        }
                                                #if SWAT7
                        else if (cxGlyph <= 16)
                                                #else
                        else if (pgb->sizlBitmap.cx <= 16)
                                                #endif
                        {
                            //-----------------------------------------------------
                            // 9 to 16 pels in width


                            while ( cyGlyph-- )
                                                        #if SWAT7
                                                        {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], *(USHORT*)pjGlyph);
                                                                pjGlyph += lDelta;
                                                        }
                                                        #else
                                REQUIRE(1);
                                LL32 (grHOSTDATA[0], *((USHORT*)pjGlyph)++);
                                                        #endif

                        }
                        else
                        {
                            //-----------------------------------------------------
                            // More than 16 pels in width


                                                        #if SWAT7
                            cw = (cxGlyph + 31) >> 5;
                                                        #else
                            lDelta = (pgb->sizlBitmap.cx + 7) >> 3;
                            cw = (lDelta + 3) >> 2;
                                                        #endif

                            pTmp = pjGlyph + lDelta * pgb->sizlBitmap.cy;

                            for (;cyGlyph!=1; cyGlyph--)
                            {
                                                                WRITE_STRING(pjGlyph, cw);
                                pjGlyph += lDelta;
                            }

                            {
                                ULONG *pSrc = (ULONG*) pjGlyph + cw - 1;
                                                                WRITE_STRING(pjGlyph, cw - 1);

                                if ((BYTE *)pSrc+4<=pTmp)
                                {
                                    REQUIRE(1);
                                    LL32 (grHOSTDATA[0], *pSrc++ );
                                }
                                else
                                {
                                    int Extra = (ULONG) pTmp - (ULONG) pSrc;
                                    BYTE * pByte = (BYTE *)pSrc;
                                    ULONG ulData;

                                    DISPDBG((TEXT_DBG_LEVEL1,
                                        "Caught it %s %d %d %x %x\n",
                                        __FILE__, __LINE__, Extra, pTmp, pSrc));

                                    if (Extra == 1)
                                        ulData = (ULONG)(*pByte);
                                    else if (Extra == 2)
                                        ulData = (ULONG)(*(USHORT*)pByte);
                                    else
                                        ulData = (((ULONG)*(pByte+2) << 8) | (ULONG)*(pByte+1)) << 8 | *pByte;

                                    REQUIRE(1);
                                    LL32 (grHOSTDATA[0], ulData );
                                }
                            }
                         } // End more than 16 pels wide.

                        pgp++;
                        if (--cGlyph == 0)  // We are done with this batch
                            break;  // of glyphs.  Break out of the glyph loop.

                    } // End Glyph Loop.

                } // End Mono Spacing.

            } // End  if (cGlyph > 0)

            //
            // Done with this batch of Glyphs.
            // Go get the next one.
            //

        } while (bMoreGlyphs);

    } // End DC_TRIVIAL
    else
    {
        // If there's clipping, call off to a function:
        vMmClipGlyphExpansion(ppdev, pstro, pco);
    }

    ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
    LL16(grCONTROL, ppdev->grCONTROL);

    return(TRUE);

} // End DrvTextOut.


/******************************Public*Routine******************************\
* BOOL bEnableText
*
* Performs the necessary setup for the text drawing subcomponent.
*
\**************************************************************************/

BOOL bEnableText(
PDEV*   ppdev)
{
    // Our text algorithms require no initialization.   If we were to
    // do glyph caching, we would probably want to allocate off-screen
    // memory and do a bunch of other stuff here.

    DISPDBG((TEXT_DBG_LEVEL,"bEnableText: Entry.\n"));
#if RECORD_ON
    LL( RECORD, 1);     // Switch on
    LL( RECORD, 2);     // Pause
    DISPDBG((TEXT_DBG_LEVEL1,"xbEnableText: Recording Paused.\n"));
#endif
    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableText
*
* Performs the necessary clean-up for the text drawing subcomponent.
*
\**************************************************************************/

VOID vDisableText(PDEV* ppdev)
{
    // Here we free any stuff allocated in 'bEnableText'.

    DISPDBG((TEXT_DBG_LEVEL,"vDisableText: Entry.\n"));
}

#if !SWAT3
#pragma optimize("", off) // Microsoft doesn't know how to do compile...
#endif
/******************************Public*Routine******************************\
* VOID vAssertModeText
*
* Disables or re-enables the text drawing subcomponent in preparation for
* full-screen entry/exit.
*
\**************************************************************************/

VOID vAssertModeText(
PDEV*   ppdev,
BOOL    bEnable)
{
#if SWAT3
        SIZEL sizl;
        POINTL pos;
        int i;

        if (bEnable)
        {
                // We are enabling the screen again, so allocate the font cache if it
                // is not yet allocated.
                if (ppdev->pofmFontCache == NULL)
                {
                        #if MEMMGR
                        sizl.cx = ppdev->lDeltaScreen / FONTCELL_X;
                        #else
                        //sizl.cx = ppdev->cxMemory;
                        sizl.cx = ppdev->lDeltaScreen / ppdev->iBytesPerPixel / FONTCELL_X;
                        #endif
                        sizl.cy = (FONTCELL_COUNT + sizl.cx - 1) / sizl.cx;
                        sizl.cx *= FONTCELL_X;
                        sizl.cy *= FONTCELL_Y;

                        ppdev->pofmFontCache = AllocOffScnMem(ppdev, &sizl, 0, NULL);
                        //ppdev->pofmFontCache = AllocOffScnMem(ppdev, &sizl,
                        //              PIXEL_AlIGN, NULL);
                }

                if (ppdev->pofmFontCache != NULL)
                {
                        // Clear the entire font cell array.
                        pos.x = pos.y = 0;
                        for (i = 0; i < FONTCELL_COUNT; i++)
                        {
                                if (pos.y >= sizl.cy)
                                {
                                        ppdev->fcGrid[i].x = 0;
                                        ppdev->fcGrid[i].y = 0;
                                        ppdev->fcGrid[i].pfc = (PFONTCACHE) -1;
                                }
                                else
                                {
                                        ppdev->fcGrid[i].x = ppdev->pofmFontCache->x + pos.x;
                                        ppdev->fcGrid[i].y = ppdev->pofmFontCache->y + pos.y;
                                        ppdev->fcGrid[i].pfc = NULL;
                                        ppdev->fcGrid[i].ulLastX = 0;
                                        ppdev->fcGrid[i].pNext = NULL;

                                        pos.x += FONTCELL_X;
                                        if (pos.x >= (LONG) ppdev->cxMemory)
                                        {
                                                pos.x = 0;
                                                pos.y += FONTCELL_Y;
                                        }
                                }
                        }
                }
        }
        else
        {
                // We are disabling the screen so destroy all cached fonts.
                if (ppdev->pofmFontCache != NULL)
                {
                        for (i = 0; i < FONTCELL_COUNT; i++)
                        {
                                if (   (ppdev->fcGrid[i].pfc != NULL)
                                        && (ppdev->fcGrid[i].pfc != (PFONTCACHE) -1)
                                )
                                {
                                        DrvDestroyFont(ppdev->fcGrid[i].pfc->pfo);
                                }
                        }

                        // Free the font cache cells.
                        FreeOffScnMem(ppdev, ppdev->pofmFontCache);
                        ppdev->pofmFontCache = NULL;
                }
        }
#elif !SWAT3
        if (!bEnable)
        {
                // Remove all chained fonts.
                PFONTCACHE p = ppdev->pfcChain;
                while (p != NULL)
                {
                        DrvDestroyFont(p->pfo);
                        p = ppdev->pfcChain;
                }
        }
#endif // SWAT3

}
#if !SWAT3
#pragma optimize("", on)
#endif

#if SWAT3
/******************************************************************************\
* PFONTCELL fcAllocCell(PFONTCACGE pfc)
*
* Allocate a font cell for the given font cache.  Returns NULL if there are no
* more empty font cells.
\******************************************************************************/
PFONTCELL fcAllocCell(PFONTCACHE pfc)
{
        int i;
        PPDEV ppdev = pfc->ppdev;
        PFONTCELL p = ppdev->fcGrid;

        if (ppdev->pofmFontCache == NULL)
        {
                // Font cache is disabled, return NULL.
                return NULL;
        }

        for (i = 0; i < FONTCELL_COUNT; i++, p++)
        {
                if (p->pfc == NULL)
                {
                        p->pfc = pfc;
                        return p;
                }
        }

        return NULL;
}

/******************************************************************************\
* void fcFreeCell(PFONTCELL pCell)
*
* Mark the given font cell as free.
\******************************************************************************/
void fcFreeCell(PFONTCELL pCell)
{
        pCell->pfc = NULL;
        pCell->ulLastX = 0;
        pCell->pNext = NULL;
}
#endif // SWAT3

/******************************Public*Routine******************************\
* VOID DrvDestroyFont
*
* We're being notified that the given font is being deallocated; clean up
* anything we've stashed in the 'pvConsumer' field of the 'pfo'.
*
\**************************************************************************/

VOID DrvDestroyFont(FONTOBJ *pfo)
{
        DISPDBG((TEXT_DBG_LEVEL, "DrvDestroyFont Entry\n"));

        if (pfo->pvConsumer != NULL && pfo->pvConsumer != (PVOID) -1)
        {
                PFONTCACHE pfc = (PFONTCACHE) pfo->pvConsumer;
#if SWAT3
                PFONTCELL pCell, pCellNext;
#else
                PFONTMEMORY     pfm, pfmNext;
#endif
                PPDEV ppdev;

                ppdev = pfc->ppdev;

                LogFile((BUF, "DrvDestroyFont: "));

#if SWAT3
                for (pCell = pfc->pFontCell; pCell != NULL; pCell = pCellNext)
                {
                        pCellNext = pCell->pNext;
                        fcFreeCell(pCell);
                }
                LogFile((BUF, "\r\n"));
#else
                for (pfm = pfc->pFontMemory; pfm != NULL; pfm = pfmNext)
                {
                        pfmNext = pfm->pNext;
                        if (pfm->pTile != NULL)
                        {
                                FreeOffScnMem(pfc->ppdev, pfm->pTile);
                        }
                        MEMORY_FREE(pfm);
                }

                // Unhook the font cache from the chain.
                if (pfc->pfcPrev != NULL)
                {
                        pfc->pfcPrev->pfcNext = pfc->pfcNext;
                }
                else
                {
                        ppdev->pfcChain = pfc->pfcNext;
                }

                if (pfc->pfcNext != NULL)
                {
                        pfc->pfcNext->pfcPrev = pfc->pfcPrev;
                }
#endif

                LogFile((BUF, "\r\n"));
                MEMORY_FREE(pfc);
        }

        pfo->pvConsumer = NULL;
        DISPDBG((TEXT_DBG_LEVEL, "DrvDestroyFont Exit\n"));
}

/*
 *  GetGlyphSize
 *
 *  Get the size (in pixels) of the requested glyph. Return the width of the
 *  glyph in bytes or 0 if the glyph is too big to cache.
 *
 */
long GetGlyphSize(
    GLYPHBITS*  pgb,        // Pointer to glyph.
    POINTL*     pptlOrigin, // Pointer to return origin in.
    DWORD*      pcSize      // Pointer to return size in.
)
{
    long  x, y, height = 0;
    BYTE* pByte = pgb->aj;
    int   i;

    x = (pgb->sizlBitmap.cx + 7) >> 3;  // get width in bytes
    if (x > 0)
    {
    // find first line in glyph that contains data
    for (y = 0; y < pgb->sizlBitmap.cy; y++, pByte += x)
    {
        // walk trough every byte on a line
        for (i = 0; i < x; i++)
        {
        if (pByte[i])   // we have data, so we are at the first line
        {
            // find the last line in te glyph that contains data
            height = pgb->sizlBitmap.cy - y;
            for (pByte += (height - 1) * x; height > 0; height--)
            {
            // walk trough every byte on a line
            for (i = 0; i < x; i++)
            {
                if (pByte[i])
                {
                    // test height of glyph
#if SWAT3
                    if (height > FONTCELL_Y)
#else
                    if (height > LINES_PER_TILE)
#endif
                    {
                        // glyph too big, mark it as uncacheable
                        *pcSize = (DWORD) -1;
                        return(0);
                    }
                    // fill return parameters
                    pptlOrigin->y = y;
                    *pcSize = PACK_XY(pgb->sizlBitmap.cx, height);
                    return(x);
                }
            }
            pByte -= x;
            }
        }
        }
    }
    }

    // glyph is empty
    *pcSize = 0;
    return(0);
}

/*
 *  AllocFontCache
 *
 *  Allocate the requsted memory in off-screen memory. Return TRUE and the x,y
 *  coordinates of the upper left corner of this region, or FALSE if there is
 *  not enough memory.
 *
 */
BOOL AllocFontCache(
  PFONTCACHE  pfc,       // Pointer to font cache.
  long        cWidth,    // Width (in bytes) to allocate.
  long        cHeight,   // Height to allocate.
  POINTL*     ppnt       // Point to return cooridinate in.
)
{
#if SWAT3
        PFONTCELL       pCell;
#else
        SIZEL           sizl;
        PFONTMEMORY     pfm;
#endif
        long            x;
        PPDEV           ppdev = pfc->ppdev;

#if !SWAT3
        if (ppdev->iBytesPerPixel == 3)
        {
                sizl.cx = (128 + 2) / 3;
        }
        else
        {
                sizl.cx = 128 / ppdev->iBytesPerPixel;
        }
        sizl.cy = 16;
#endif

#if SWAT3
        if (pfc->pFontCell == NULL)
        {
                pfc->pFontCell = fcAllocCell(pfc);
        }
#else
        if (pfc->pFontMemory == NULL)
        {
                pfc->pFontMemory = (PFONTMEMORY)
                #ifdef WINNT_VER40
                                MEM_ALLOC(FL_ZERO_MEMORY, sizeof(FONTMEMORY), ALLOC_TAG);
                #else
                                MEM_ALLOC(LMEM_FIXED | LMEM_ZEROINIT, sizeof(FONTMEMORY));
                #endif
        }
#endif

#if SWAT3
        for (pCell = pfc->pFontCell; pCell != NULL; pCell = pCell->pNext)
        {
                x = pCell->ulLastX;
                if (x + cWidth <= FONTCELL_X)
                {
                        pCell->ulLastX += cWidth;
                        ppnt->x = pCell->x + x;
                        ppnt->y = pCell->y;
                        return TRUE;
            }

                if (pCell->pNext == NULL)
                {
                        pCell->pNext = fcAllocCell(pfc);
                }
        }
#else
        for (pfm = pfc->pFontMemory; pfm; pfm = pfm->pNext)
        {
                if (pfm->pTile == NULL)
                {
                        #ifdef ALLOC_IN_CREATESURFACE
                        if (!ppdev->bDirectDrawInUse)
                        #endif
                        pfm->pTile  = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);
                        if (pfm->pTile == NULL)
                        {
                                return FALSE;
                        }

                        ppnt->x = pfm->pTile->x;
                        ppnt->y = pfm->pTile->y;
                        pfm->ulLastX = cWidth;
                        return TRUE;
                }

                x = pfm->ulLastX;
                if (x + cWidth <= BYTES_PER_TILE)
                {
                        pfm->ulLastX += cWidth;
                        ppnt->x = pfm->pTile->x + x;
                        ppnt->y = pfm->pTile->y;
                        return TRUE;
            }

                if (pfm->pNext == NULL)
                {
                        pfm->pNext = (PFONTMEMORY)
                        #ifdef WINNT_VER40
                                        MEM_ALLOC(FL_ZERO_MEMORY, sizeof(FONTMEMORY), ALLOC_TAG);
                        #else
                                        MEM_ALLOC(LMEM_FIXED | LMEM_ZEROINIT, sizeof(FONTMEMORY));
                        #endif
                }
        }
#endif
        return FALSE;
}

/*
 *  AllocGlyph
 *
 *  Allocate memory for the requested glyph and copy the glyph into off-screen
 *  memory. If there is not enough off-screen memory left, or the glyph is too
 *  large to glyph, return FALSE, otherwise return TRUE.
 *
 */
VOID AllocGlyph(
    PFONTCACHE  pfc,        // pointer to font cache
    GLYPHBITS*  pgb,        // pointer to glyph to cache
    GLYPHCACHE* pgc     // pointer to glyph cache structure
)
{
    long   cBytes;
    BYTE   *pOffScreen, *pSrc;
    long   y;
    PDEV   *ppdev;
    POINTL pointl;

    ppdev = pfc->ppdev;
    cBytes = GetGlyphSize(pgb, &pgc->ptlOrigin, &pgc->cSize);
    if (cBytes == 0)
    {
        pgc->xyPos = (DWORD) -1;
        LogFile((BUF, "GC:F\r\n"));
        return;
    }

    if (AllocFontCache(pfc, cBytes, pgc->cSize >> 16, &pointl) == FALSE)
    {
        pgc->cSize = (DWORD) -1;
        LogFile((BUF, "GC:F\r\n"));
        return;
    }

    pOffScreen = ppdev->pjScreen + pointl.x + pointl.y * ppdev->lDeltaScreen;
    pSrc = &pgb->aj[pgc->ptlOrigin.y * cBytes];
    y = (long) (pgc->cSize >> 16);
    if (cBytes == sizeof(BYTE))
    {
        while (y-- > 0)
        {
            *pOffScreen = Swiz[*pSrc];
            pOffScreen += ppdev->lDeltaScreen;
            pSrc += sizeof(BYTE);
        }
    }
    else
    {
        while (y-- > 0)
        {
            long lDelta = ppdev->lDeltaScreen - cBytes;
            long i;

            for (i = cBytes; i > 0; i--)
            {
                *pOffScreen++ = Swiz[*pSrc++];
            }
            pOffScreen += lDelta;
        }
    }
    pgc->xyPos = PACK_XY(pointl.x * 8, pointl.y);
    pgc->ptlOrigin.x = pgb->ptlOrigin.x;
    pgc->ptlOrigin.y += pgb->ptlOrigin.y;
    LogFile((BUF, "GC:S\r\n"));
}


#if !(USE_ASM && defined(i386))

/*
 *  FontCache
 *
 *  Draw glyphs using the off-screen font cache.
 *
 */
VOID FontCache(
    PFONTCACHE  pfc,        // Pointer to font cache.
    STROBJ*     pstro       // Pointer to glyphs.
)
{
    PDEV*       ppdev;
    BOOL        bMoreGlyphs = TRUE;
    ULONG       cGlyph;
    GLYPHPOS*   pgp;
    POINTL      ptlOrigin;
    PGLYPHCACHE pgc;
    ULONG       ulCharInc;

    // set pointer to physical device
    ppdev = pfc->ppdev;

    // loop until there are no more glyphs to process
    while (bMoreGlyphs)
    {
        if (pstro->pgp != NULL)
        {
            // we have just one set of glyphs
            pgp = pstro->pgp;
            cGlyph = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            // enumerate a set of glyphs
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
        }

        if (pstro->ulCharInc)
        {
            // fixed fonts... get x and y coordinates of first glyph
            ptlOrigin.x = pgp->ptl.x;
            ptlOrigin.y = pgp->ptl.y;
            // get glyph increment
            ulCharInc = pstro->ulCharInc;

            // walk through all glyphs
            while (cGlyph-- > 0)
            {
                if (pgp->hg < MAX_GLYPHS)
                {
                    // this glyph index is cacheable
                    pgc = &pfc->aGlyphs[pgp->hg];
                    if (pgc->xyPos == 0)
                    {
                        // cache the glyph
                        AllocGlyph(pfc, pgp->pgdf->pgb, pgc);
                    }
                    if ((long) pgc->cSize > 0)
                    {
                        LogFile((BUF, "GC:H\r\n"));
                        // the glyph is cached, blit it on the screen
                        REQUIRE(7);
                        LL_OP0(ptlOrigin.x + pgc->ptlOrigin.x + ppdev->ptlOffset.x,
                               ptlOrigin.y + pgc->ptlOrigin.y + ppdev->ptlOffset.y);
                        LL32 (grOP2_opMRDRAM, pgc->xyPos);
                        LL32 (grBLTEXT_EX.dw, pgc->cSize);
                    }
                    else if ((long) pgc->cSize == -1)
                    {
                        // the glyph is uncacheable, draw it directly
                        DrawGlyph(ppdev, pgp->pgdf->pgb, ptlOrigin);
                    }
                }
                else
                {
                    // the glyph index is out of range, draw it directly
                    DrawGlyph(ppdev, pgp->pgdf->pgb, ptlOrigin);
                }
                // increment glyph x coordinate
                ptlOrigin.x += ulCharInc;
                // next glyph
                pgp++;
            }
        }
        else
        {
            // variable width fonts, walk trough all glyphs
            while (cGlyph-- > 0)
            {
                if (pgp->hg < MAX_GLYPHS)
                {
                    // this glyph index is cacheable
                    pgc = &pfc->aGlyphs[pgp->hg];
                    if (pgc->xyPos == 0)
                    {
                        // cache the glyph
                        AllocGlyph(pfc, pgp->pgdf->pgb, pgc);
                    }
                    if ((long) pgc->cSize > 0)
                    {
                        LogFile((BUF, "GC:H\r\n"));
                        // the glyph is cached, blit it on the screen
                        REQUIRE(7);
                        LL_OP0(pgp->ptl.x + pgc->ptlOrigin.x + ppdev->ptlOffset.x,
                               pgp->ptl.y + pgc->ptlOrigin.y + ppdev->ptlOffset.y);
                        LL32 (grOP2_opMRDRAM, pgc->xyPos);
                        LL32 (grBLTEXT_EX.dw, pgc->cSize);
                    }
                    else if ((long) pgc->cSize == -1)
                    {
                        // the glyph is uncacheable, draw it directly
                        DrawGlyph(ppdev, pgp->pgdf->pgb, pgp->ptl);
                    }
                }
                else
                {
                    // the glyph index is out of range, draw it directly
                    DrawGlyph(ppdev, pgp->pgdf->pgb, pgp->ptl);
                }
                // next glyph
                pgp++;
            }
        }
    }
}

/*
 * DrawGlyph
 *
 * Draw glyphs directly on the screen.
 *
 */
VOID DrawGlyph(
    PDEV*       ppdev,      // Pointer to physical device.
    GLYPHBITS*  pgb,        // Pointer to glyph to draw.
    POINTL      ptl         // Location of glyph.
)
{
    BYTE*   pjGlyph;
    ULONG   cyGlyph;
        #if SWAT7
    ULONG   cxGlyph;
        ULONG   xOrigin;
        LONG    lDelta;
        #endif

    LogFile((BUF, "GC:M\r\n"));

        #if SWAT7
        xOrigin = ptl.x + pgb->ptlOrigin.x;
    cxGlyph = pgb->sizlBitmap.cx;
    cyGlyph = pgb->sizlBitmap.cy;
    pjGlyph = pgb->aj;
        lDelta  = (cxGlyph + 7) >> 3;
        #endif

    // start the blit
    REQUIRE(4);
    LL_DRAWBLTDEF(TEXT_EXPAND_XPAR, 0);
    LL_OP2_MONO(0, 0);
        #if !SWAT7
    REQUIRE(5);
    LL_OP0(ptl.x + pgb->ptlOrigin.x + ppdev->ptlOffset.x,
           ptl.y + pgb->ptlOrigin.y + ppdev->ptlOffset.y);
        LL_BLTEXT(pgb->sizlBitmap.cx, pgb->sizlBitmap.cy);

    pjGlyph = pgb->aj;
    cyGlyph = pgb->sizlBitmap.cy;
        #endif

        #if SWAT7
        //
        // Test for 5465AD hardware bug in 8-bpp.
        //
        if (   (cxGlyph > 64) && (cxGlyph < 128)
                && (ppdev->iBytesPerPixel == 1)
        )
        {
                Xfer64Pixels(ppdev, xOrigin, ptl.y + pgb->ptlOrigin.y, 0, cyGlyph,
                                pjGlyph, cxGlyph);
                pjGlyph += 64 / 8;
                xOrigin += 64;
                cxGlyph -= 64;
        }

    REQUIRE(5);
    LL_OP0(xOrigin + ppdev->ptlOffset.x,
                   ptl.y + pgb->ptlOrigin.y + ppdev->ptlOffset.y);
        LL_BLTEXT(cxGlyph, cyGlyph);
        #endif

        #if SWAT7
        if (cxGlyph <= 8)
        #else
    if (pgb->sizlBitmap.cx <= 8)
        #endif
    {
        // just one byte per line
        while (cyGlyph--)
        {
            REQUIRE(1);
            LL32 (grHOSTDATA[0], *pjGlyph);
                        #if SWAT7
            pjGlyph += lDelta;
                        #else
            pjGlyph++;
                        #endif
        }
    }
        #if SWAT7
    else if (cxGlyph <= 16)
        #else
    else if (pgb->sizlBitmap.cx <= 16)
        #endif
    {
        // just two bytes per line
        while (cyGlyph--)
        {
            REQUIRE(1);
            LL32 (grHOSTDATA[0], *(WORD *) pjGlyph);
                        #if SWAT7
            pjGlyph += lDelta;
                        #else
            pjGlyph += 2;
                        #endif
        }
    }
        #if SWAT7
    else if (cxGlyph <= 24)
        #else
    else if (pgb->sizlBitmap.cx <= 24)
        #endif
    {
        // just three bytes per line
        while (cyGlyph--)
        {
            REQUIRE(1);
            LL32 (grHOSTDATA[0], *(DWORD *) pjGlyph);
                        #if SWAT7
            pjGlyph += lDelta;
                        #else
            pjGlyph += 3;
                        #endif
        }
    }
        #if SWAT7
    else if (cxGlyph <= 32)
        #else
    else if (pgb->sizlBitmap.cx <= 32)
        #endif
    {
        // just four bytes per line
        while (cyGlyph--)
        {
            REQUIRE(1);
            LL32 (grHOSTDATA[0], *(DWORD *) pjGlyph);
                        #if SWAT7
            pjGlyph += lDelta;
                        #else
            pjGlyph += 4;
                        #endif
        }
    }
    else
    {
        // any number of bytes per line
                #if SWAT7
        int cw = (cxGlyph + 31) >> 5;
                #else
        long lDelta = (pgb->sizlBitmap.cx + 7) >> 3;
        int cw = (lDelta + 3) >> 2;
                #endif

        BYTE * pTmp = pjGlyph + lDelta * pgb->sizlBitmap.cy;

        for (;cyGlyph!=1; cyGlyph--)
        {
                        WRITE_STRING(pjGlyph, cw);
            pjGlyph += lDelta;
        }

        {
            ULONG *pSrc = (ULONG*) pjGlyph + cw - 1;
                        WRITE_STRING(pjGlyph, cw - 1);

            if ((BYTE *)pSrc+4<=pTmp)
            {
                REQUIRE(1);
                LL32 (grHOSTDATA[0], *pSrc++ );
            }
            else
            {
                int Extra = (ULONG) pTmp - (ULONG) pSrc;
                BYTE * pByte = (BYTE *)pSrc;
                ULONG ulData;

                DISPDBG((TEXT_DBG_LEVEL1,
                    "Caught it %s %d %d %x %x\n",
                    __FILE__, __LINE__, Extra, pTmp, pSrc));

                if (Extra == 1)
                    ulData = (ULONG)(*pByte);
                else if (Extra == 2)
                    ulData = (ULONG)(*(USHORT*)pByte);
                else
                    ulData = (((ULONG)*(pByte+2) << 8) | (ULONG)*(pByte+1)) << 8 | *pByte;

                REQUIRE(1);
                LL32 (grHOSTDATA[0], ulData );
            }
        }
    }

    // reset to transparent cache expansion
    LL_DRAWBLTDEF(CACHE_EXPAND_XPAR, 2);
}




VOID ClipCache(
    PFONTCACHE  pfc,        // Pointer to font cache.
    STROBJ*     pstro,      // Pointer to glyphs.
    RECTL       rclBounds   // Clipping rectangle.
)
{
    PDEV*       ppdev;
    BOOL        bMoreGlyphs = TRUE;
    ULONG       cGlyph;
    GLYPHPOS*   pgp;
    POINTL      ptlOrigin;
    PGLYPHCACHE pgc;
    ULONG       ulCharInc;

    // set pointer to physical device
    ppdev = pfc->ppdev;

    // loop until there are no more glyphs to process
    while (bMoreGlyphs)
    {
        if (pstro->pgp != NULL)
        {
            // we have just one set of glyphs
            pgp  = pstro->pgp;
            cGlyph = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            // enumerate a set of glyphs
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
        }

        // get x and y coordinates of first glyph
        ptlOrigin.x = pgp->ptl.x;
        ptlOrigin.y = pgp->ptl.y;
        // get glyph increment
        ulCharInc = pstro->ulCharInc;

        // walk through all glyphs
        while (cGlyph-- > 0)
        {
            if (pgp->hg < MAX_GLYPHS)
            {
                // this glyph index is cacheable
                pgc = &pfc->aGlyphs[pgp->hg];
                if (pgc->xyPos == 0)
                {
                    // cache the glyph
                    AllocGlyph(pfc, pgp->pgdf->pgb, pgc);
                }
                if ((long) pgc->cSize > 0)
                {
                    RECTL rcl;
                    LONG i, cx, cy;
                    ULONG xyPos;


                    // the glyph is cached, ckeck clipping
                    rcl.left = ptlOrigin.x + pgc->ptlOrigin.x;
                    rcl.top = ptlOrigin.y + pgc->ptlOrigin.y;
                    rcl.right = rcl.left + (pgc->cSize & 0x0000FFFF);
                    rcl.bottom = rcl.top + (pgc->cSize >> 16);
                    xyPos = pgc->xyPos;

                    i = rclBounds.left - rcl.left;
                    if (i > 0)
                    {
                        // the glyph is partially clipped on the left, draw it
                        // directly
                        ClipGlyph(ppdev, pgp->pgdf->pgb, ptlOrigin, rclBounds);
                    }
                    else
                    {
                        LogFile((BUF, "GC:H\r\n"));
                        cx = min(rcl.right, rclBounds.right) - rcl.left;
                        if (cx > 0)
                        {
                            i = rclBounds.top - rcl.top;
                            if (i > 0)
                            {
                                rcl.top += i;
                                xyPos += i << 16;
                            }
                            cy = min(rcl.bottom, rclBounds.bottom) - rcl.top;
                            if (cy > 0)
                            {
                                REQUIRE(7);
                                LL_OP0(rcl.left + ppdev->ptlOffset.x,
                                       rcl.top + ppdev->ptlOffset.y);
                                LL32(grOP2_opMRDRAM, xyPos);
                                LL_BLTEXT(cx, cy);
                            }
                        }
                    }
                }
                else if ((long) pgc->cSize == -1)
                {
                    // the glyph is uncacheable, draw it directly
                    ClipGlyph(ppdev, pgp->pgdf->pgb, ptlOrigin, rclBounds);
                }
            }
            else
            {
                // the glyph index is out of range, draw it directly
                ClipGlyph(ppdev, pgp->pgdf->pgb, ptlOrigin, rclBounds);
            }
            // next glyph
            pgp++;
            if (ulCharInc == 0)
            {
                ptlOrigin.x = pgp->ptl.x;
                ptlOrigin.y = pgp->ptl.y;
            }
            else
            {
                // increment glyph x coordinate
                ptlOrigin.x += ulCharInc;
            }
        }
    }
}

VOID ClipGlyph(
    PDEV*       ppdev,      // Pointer to physical device.
    GLYPHBITS*  pgb,        // Pointer to glyph to draw.
    POINTL      ptl,        // Location of glyph.
    RECTL       rclBounds   // Clipping rectangle.
)
{
    BYTE*   pjGlyph;
    LONG    cx, cy, lDelta, i;
    RECTL   rcl;
    ULONG   xBit;

    LogFile((BUF, "GC:M\r\n"));

    rcl.left = ptl.x + pgb->ptlOrigin.x;
    rcl.top = ptl.y + pgb->ptlOrigin.y;
    rcl.right = rcl.left + pgb->sizlBitmap.cx;
    rcl.bottom = rcl.top + pgb->sizlBitmap.cy;
    xBit = 0;
    pjGlyph = pgb->aj;
    lDelta = (pgb->sizlBitmap.cx + 7) >> 3;

    i = rclBounds.left - rcl.left;
    if (i > 0)
    {
        pjGlyph += i >> 3;
        xBit = i & 7;
        rcl.left += i;
    }
    cx = min(rcl.right, rclBounds.right) - rcl.left;
    if (cx > 0)
    {
        i = rclBounds.top - rcl.top;
        if (i > 0)
        {
            pjGlyph += i * lDelta;
            rcl.top += i;
        }
        cy = min(rcl.bottom, rclBounds.bottom) - rcl.top;
        if (cy > 0)
        {
            // start the blit
            REQUIRE(4);
            LL_DRAWBLTDEF(TEXT_EXPAND_XPAR, 0);
            LL_OP2(xBit, 0);

                        #if SWAT7
                        //
                        // Test for 5465AD hardware bug in 8-bpp.
                        //
                        if ((cx > 64) && (cx < 128) && (ppdev->iBytesPerPixel == 1))
                        {
                                Xfer64Pixels(ppdev, rcl.left, rcl.top, xBit, cy, pjGlyph,
                                                pgb->sizlBitmap.cx);
                                pjGlyph += 64 / 8;
                                rcl.left += 64;
                                cx -= 64;
                        }
                        #endif

            REQUIRE(5);
            LL_OP0(rcl.left + ppdev->ptlOffset.x,
                   rcl.top + ppdev->ptlOffset.y);
            LL_BLTEXT(cx, cy);

            cx = (xBit + cx + 7) >> 3;
            switch (cx)
            {
                case 1:
                    while (cy--)
                    {
                        REQUIRE(1);
                        LL32(grHOSTDATA[0], *(BYTE *) pjGlyph);
                        pjGlyph += lDelta;
                    }
                    break;

                case 2:
                    while (cy--)
                    {
                        REQUIRE(1);
                        LL32(grHOSTDATA[0], *(WORD *) pjGlyph);
                        pjGlyph += lDelta;
                    }
                    break;

                case 3:
                case 4:
                    while (cy--)
                    {
                        REQUIRE(1);
                        LL32(grHOSTDATA[0], *(DWORD *) pjGlyph);
                        pjGlyph += lDelta;
                    }
                    break;

                default:
                    while (cy--)
                    {
                                                WRITE_STRING(pjGlyph, (cx + 3) / 4);
                        pjGlyph += lDelta;
                    }
                    break;
            }

            // reset to transparent cache expansion
            REQUIRE(2);
            LL_DRAWBLTDEF(CACHE_EXPAND_XPAR, 2);
        }
    }
}

#endif  // !(USE_ASM && defined(i386))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\xlate.c ===
/******************************Module*Header***********************************\
*
* Module Name: Xlate.c
* Author: Noel VanHook
* Purpose: Handles hardware color translation.
*
* Copyright (c) 1997 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/xlate.c  $
*
*    Rev 1.9   Mar 04 1998 15:51:04   frido
* Added new shadow macros.
*
*    Rev 1.8   Nov 04 1997 09:50:38   frido
* Only include the code if COLOR_TRANSLATE switch is enabled.
*
*    Rev 1.7   Nov 03 1997 09:34:22   frido
* Added REQUIRE and WRITE_STRING macros.
*
*    Rev 1.6   15 Oct 1997 14:40:40   noelv
* Moved ODD[] from xlate.h to xlate.c
*
*    Rev 1.5   15 Oct 1997 12:04:52   noelv
*
* Test ROP code (only SRCCPY is supported)
* Add switch to disable frame buffer caching.
*
*    Rev 1.4   02 Oct 1997 09:42:22   noelv
* re-enabled color translation.
*
*    Rev 1.3   23 Sep 1997 17:35:14   FRIDO
*
* I have disabled color translation for now until we know what is the real
* cause.
*
*    Rev 1.2   17 Apr 1997 14:38:14   noelv
* Changed 16 bit writes to 32 bit writes in BLTDRAWDEF
*
*    Rev 1.1   19 Feb 1997 13:07:18   noelv
* Added translation table cache
*
*    Rev 1.0   06 Feb 1997 10:35:48   noelv
* Initial revision.
*/

/*
   Color translation occures under two conditions:
   1) The source bitmap has a different color depth than the destination.
   2) The source bitmap had a different palette than the destination.

   Color translation is done with a translation table.  A translation table
   is simply an array of DWORDS.  Source "pixels" are used as indices into
   the translation table.  Translation table entries are used as destination
   pixels.

   An example will clarify.  Suppose we are doing a host to screen source
   copy operation.  The host bitmap is a 4bpp bitmap.  The current screen
   mode is 8 bpp.  This operation will require color translation, so NT will
   supply a translation table.  Since a 4bpp bitmap can have 16 different
   colors, the translation table will have 16 entries.  Since the destination
   is an 8bpp bitmap, each entry will be an 8 bit color (1 byte).  Since
   translation tables are always arrays of DWORDs, the 1 byte color will be
   followed by 3 bytes of padding.

*/

#include "PreComp.h"

#define XLATE_DBG_LEVEL 1
#define CACHE_XLATE_TABLE 0

//
// Default 4-bpp translation table.
//
ULONG ulXlate[16] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
};

#if COLOR_TRANSLATE // Only include the next code if color translation is on.

//
// Table for determining bad BLTs.  See XLATE.H
//
char ODD[] = {0,1,1,1, 1,0,0,0, 0,1,1,1, 1,0,0,0};


//
// Chip bug in 5465-AA and AB
// Bring the chip to a known state before blitting to SRAM2
//
#define SRAM2_5465_WORKAROUND()                                                \
{                                                                              \
    WORD temp;                                                                 \
    while(LLDR_SZ (grSTATUS));          /* Wait for idle. */                   \
    temp = LLDR_SZ (grPERFORMANCE);     /* get the performance register. */    \
    LL16(grPERFORMANCE, (temp|0x8000)); /* toggle RES_FIFO_FLUSH */            \
    LL16(grPERFORMANCE, temp );         /* restore the performance register. */\
}





// ============================================================================
//
// vInvalidateXlateCache(PPDEV)
//
// Invalidates color translation cache
//
// ============================================================================
void vInvalidateXlateCache(PPDEV ppdev)
{

    DISPDBG((XLATE_DBG_LEVEL, "vInvalidateXlateCache: Entry.\n"));

    //
    // Whatever translation table that may have been stored in the cache has
    // been lost.  Mark the cache as empty.
    //
    ppdev->XlateCacheId = 0;

    DISPDBG((XLATE_DBG_LEVEL, "vInvalidateXlateCache: Exit.\n"));
}





// ============================================================================
//
// vInitHwXlate(PPDEV)
//
// Allocate and init scan line cache and xlate table cache.
//
// ============================================================================
void vInitHwXlate(PPDEV ppdev)
{

    DISPDBG((XLATE_DBG_LEVEL, "vInitHwXlate: Entry.\n"));

    //
    // Mark the cache as empty.
    //
    ppdev->XlateCacheId = 0;


    #if DRIVER_5465 // The 62 and 64 don't do HW xlate.
        #if CACHE_XLATE_TABLE

            //
            // Allocate a cache for color translation tables.
            //
            if (ppdev->XlateCache == NULL)
            {
                SIZEL  sizl;

                        sizl.cy = 1;
                        sizl.cx = 1024/ppdev->iBytesPerPixel;
                if (ppdev->iBytesPerPixel == 3) ++sizl.cx;

                        ppdev->XlateCache =  AllocOffScnMem(ppdev,
                                                            &sizl,
                                                            PIXEL_AlIGN,
                                                            NULL);
            }
        #endif
    #endif

    DISPDBG((XLATE_DBG_LEVEL, "vInitHwXlate: Exit.\n"));
}





// ============================================================================
//
// bCacheXlateTable()
//
// Caches a color translation table in SRAM.
// If the table is sucessfully cached, the chip is set up for hardware xlate.
//
// Returns TRUE if:
//        +  There is no color translation required,
//        +  or the color translation can be handled by hardware.
//
// Returns FALSE if:
//        + Color translation is required,
//        + and the color translation must be done in software.
//
// If a color translation table exists, *ppulXlate will be set to point to it.
// This is how we pass the translation table back to the caller.
//
// ============================================================================
BOOLEAN bCacheXlateTable(struct _PDEV *ppdev,
                        unsigned long **ppulXlate,
                        SURFOBJ  *psoTrg,
                        SURFOBJ  *psoSrc,
                        XLATEOBJ *pxlo,
                        BYTE      rop)
{
    unsigned long i, src_fmt, dst_fmt, stretch_ctrl;
    unsigned long *pulXlate;


    DISPDBG((XLATE_DBG_LEVEL, "bCacheXlateTable: Entry.\n"));


    //
    // Get the translation vector.
    //
    if ( (pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL) )
        pulXlate = NULL;

    else if (pxlo->flXlate & XO_TABLE)
        pulXlate = pxlo->pulXlate;
    else if (pxlo->iSrcType == PAL_INDEXED)
        pulXlate = XLATEOBJ_piVector(pxlo);
    else
    {
        // Some kind of translation we don't handle
        return FALSE;
    }


    //
    // Pass the translation table back to the caller.
    //
    *ppulXlate = pulXlate;

    //
    // If there is no color translation necessary, then we're done.
    //
    if (pulXlate == NULL)
    {
        DISPDBG((XLATE_DBG_LEVEL, "bCacheXlateTable: No color translation necessary.\n"));
        return TRUE;
    }

    //
    // The 5462 and 5464 don't do hardware color translation.
    //
    #if ! DRIVER_5465
        DISPDBG((XLATE_DBG_LEVEL,
            "bCacheXlateTable: Chip doesn't support hardware translation.\n"));
        return FALSE;
    #endif


    //
    // The 5465 only does hardware translation for rop code CC.
    //
    if (rop != 0xCC)
    {
        DISPDBG((XLATE_DBG_LEVEL,
            "bCacheXlateTable: Can't color translate ROP 0x%X.\n",
            rop));
        return FALSE;
    }


    //
    // Make sure we have an INDEXED palette
    //
    if (pxlo->iSrcType == PAL_BITFIELDS)
    {
        // I don't think we should get any of these.
        RIP("Panic!: bCacheXlateTable has PAL_BITFIELDS iSrcType.\n");
        return FALSE;
    }

    if  (pxlo->iDstType == PAL_BITFIELDS)
    {
        // I don't think we should get any of these.
        RIP ("Panic!: bCacheXlateTable has PAL_BITFIELDS iDstType.\n");
        return FALSE;
    }


    //
    // What is the source format?
    //
    ASSERTMSG(psoSrc,"bCacheXlateTable has no source object.\n");
    switch (psoSrc->iBitmapFormat)
    {
        case BMF_4BPP:  src_fmt = 5;    break;
        case BMF_8BPP:  src_fmt = 6;    break;
        default:
            // I don't think we should get any of these.
            RIP("Panic! bCacheXlateTable: Bad source format.\n");
            return FALSE;
    }


    //
    // What is the destination format?
    //
    ASSERTMSG(psoTrg,"bCacheXlateTable has no destination object.\n");
    switch (psoTrg->iBitmapFormat)
    {
        case BMF_8BPP:  dst_fmt = 0;    break;
        case BMF_16BPP: dst_fmt = 2;    break;
        case BMF_24BPP: dst_fmt = 3;    break;
        case BMF_32BPP: dst_fmt = 4;    break;
        default:
            // I don't think we should get any of these.
            RIP("Panic! bCacheXlateTable: Bad destination  format.\n");
            return FALSE;
    }

#if CACHE_XLATE_TABLE
    //
    // Have we cached this table already?
    //
    if (ppdev->XlateCacheId == pxlo->iUniq)
    {
        ULONG num_dwords = ( (pxlo->cEntries == 16) ? 64 : 256);

        DISPDBG((XLATE_DBG_LEVEL,
            "bCacheXlateTable: Table is already cached. ID=%d.\n", pxlo->iUniq));

        // Yep.  Refresh SRAM2 in case it was destroyed.
        // Blt from frame buffer cache into SRAM2
        ASSERTMSG( (ppdev->XlateCache != NULL),
            "bCacheXlateTable: Xlate cache pointer is NULL.\n");

        // Blt the table from the frame buffer cache to SRAM2
        SRAM2_5465_WORKAROUND();
        REQUIRE(9);
        LL_DRAWBLTDEF(0x601000CC, 2);  // SRC COPY
        LL_OP0(0,0);              // Dest location
        LL_OP1(ppdev->XlateCache->x,ppdev->XlateCache->y); // Src location
        LL_MBLTEXT( num_dwords, 1);

    }

    //
    // If not, can we cache it?
    //
    else if (ppdev->XlateCache != NULL)
    {
        DISPDBG((XLATE_DBG_LEVEL,
            "bCacheXlateTable: Caching table.  ID = %d.\n", pxlo->iUniq));

        // Store the translation table in the offscreen cache,
        REQUIRE(9);
        LL_DRAWBLTDEF(0x102000CC, 2);  // SRC COPY
        LL_OP0(ppdev->XlateCache->x,ppdev->XlateCache->y); // Dest
        LL_OP1(0,0);              // Source Phase.
        LL_MBLTEXT( (pxlo->cEntries*4), 1); // 4 bytes per table entry
                WRITE_STRING(pulXlate, pxlo->cEntries);

        // Make sure the table is the expected size.
        if ((pxlo->cEntries != 16) && (pxlo->cEntries != 256))
        {
            // Since we only do 4 and 8 bpp source, this shouldn't happen.
            RIP("Panic! bCacheXlateTable: Wrong number of entries in the table.\n");
            return FALSE;
        }

        // Blt the table from the frame buffer cache to SRAM2
        SRAM2_5465_WORKAROUND();
        REQUIRE(9);
        LL_DRAWBLTDEF(0x601000CC, 2);  // SRC COPY
        LL_OP0(0,0);              // Dest location
        LL_OP1(ppdev->XlateCache->x,ppdev->XlateCache->y); // Src location
        LL_MBLTEXT( (pxlo->cEntries*4), 1); // 4 bytes per table entry

        // Store the ID.
        ppdev->XlateCacheId = pxlo->iUniq;

    }


    //
    // Nope. Skip the frame buffer cache.
    //
    else
#endif
    {
        DISPDBG((XLATE_DBG_LEVEL, "bCacheXlateTable: Bypassing cache.\n"));

        //
        // There is no xlate table cache in the frame buffer.
        // Load the table directly from the host to the SRAM.
        //

        // Make sure the table is the expected size.
        ASSERTMSG( ((pxlo->cEntries==16) || (pxlo->cEntries == 256)),
                "XLATE.C: XLATE table has wrong number of entries.\n");
        //if ((pxlo->cEntries != 16) && (pxlo->cEntries != 256))
        //{
        //    // Since we only do 4 and 8 bpp source, this shouldn't happen.
        //    RIP("Panic! bCacheXlateTable: Wrong number of entries in the table.\n");
        //    return FALSE;
        //}


        // BLT the translation table into SRAM2 on the chip.
        SRAM2_5465_WORKAROUND();
        REQUIRE(9);
        LL32_DRAWBLTDEF(0x602000CC, 2);  // SRC COPY
        LL_OP0(0,0);              // SRAM location
        LL_OP1(0,0);              // Source Phase.
        LL_MBLTEXT( (pxlo->cEntries*4), 1); // 4 bytes per table entry

        // Now supply the table.
                WRITE_STRING(pulXlate, pxlo->cEntries);
    }



    //
    // Cache successful.
    // Set up the chip to use hardware xlate.
    //
    stretch_ctrl =  0                // Use NT style table.
                  | (src_fmt << 12)  // source pixel format
                  | (dst_fmt << 8);  // destination pixel format.
    REQUIRE(2);
    LL16(grSTRETCH_CNTL, stretch_ctrl);
    LL16(grCHROMA_CNTL, 0);  // disable chroma compare.


    DISPDBG((XLATE_DBG_LEVEL, "bCacheXlateTable: Exit - success.\n"));
    return TRUE;
}
#endif //!COLOR_TRANSLATE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\i386\i386brus.asm ===
;===============================================================================
;
;	$Workfile:   I386BRUS.ASM  $
;
;	Contents:
;	This file contains the assembly code for some of the brush realization.
;
;	Copyright (c) 1996, Cirrus Logic, Inc.
;
;	$Log:   X:/log/laguna/nt35/displays/cl546x/i386/I386BRUS.ASM  $
; 
;    Rev 1.11   29 Apr 1997 16:29:24   noelv
; Merged in new SWAT code.
; SWAT: 
; SWAT:    Rev 1.3   24 Apr 1997 10:46:06   frido
; SWAT: NT140b09 merge.
; SWAT: 
; SWAT:    Rev 1.2   19 Apr 1997 16:31:40   frido
; SWAT: Added automatic include file dependencies for BUILD.EXE.
; 
;    Rev 1.10   08 Apr 1997 11:45:06   einkauf
; 
; add call to SYNC_W_3D for MCD coordination
; 
;    Rev 1.9   22 Aug 1996 18:15:10   noelv
; Frido bug fix release 8-22.
; 
;    Rev 1.2   22 Aug 1996 19:11:14   frido
; #1308 - Added extra checks for empty cache slots.
; 
;    Rev 1.1   18 Aug 1996 15:19:52   frido
; #nbr - Added brush translation.
; 
;    Rev 1.0   14 Aug 1996 17:14:34   frido
; Initial revision.
; 
;    Rev 1.7   10 Apr 1996 13:39:20   NOELV
; Frido release 27
;       
;          Rev 1.11   08 Apr 1996 16:48:00   frido
;       Added new check for 32-bpp brushes.
;       
;          Rev 1.10   01 Apr 1996 13:57:44   frido
;       Added check for valid brush cache.
;       
;          Rev 1.9   30 Mar 1996 22:01:22   frido
;       Refined check for invalid translation flags.
;       
;          Rev 1.8   27 Mar 1996 13:04:58   frido
;       Removed 32-bpp colored brushes.
;       Added check for undocumented translation flags.
;       Masked 16-bit colors.
;       
;          Rev 1.7   04 Mar 1996 23:47:54   frido
;       Removed bug in realization of dithered brush.
;       
;          Rev 1.6   29 Feb 1996 20:20:38   frido
;       Fixed bug in 16-bpp brush realization.
;       
;          Rev 1.5   28 Feb 1996 22:40:08   frido
;       Added Optimize.h.
;       
;          Rev 1.4   19 Feb 1996 07:23:02   frido
;       Added comments.
;       Added assembly version of CacheMono and CacheDither.
;       
;          Rev 1.3   17 Feb 1996 21:46:16   frido
;       Revamped brushing algorithmn.
;       
;          Rev 1.2   13 Feb 1996 16:51:52   frido
;       Changed the layout of the PDEV structure.
;       Changed the layout of all brush caches.
;       Changed the number of brush caches.
;       
;          Rev 1.1   10 Feb 1996 21:51:12   frido
;       Split monochrome and colored translation cache.
;       Added debugging macro.
;       Fixed a bug that caused dithered brush never to be cached.
;       
;          Rev 1.0   08 Feb 1996 00:14:40   frido
;       First release.
;  
;===============================================================================

.386
.MODEL FLAT, STDCALL

OPTION	PROLOGUE:None
OPTION	EPILOGUE:None

.NOLIST
INCLUDE i386\Macros.inc
INCLUDE i386\WinNT.inc
INCLUDE i386\Laguna.inc
INCLUDE Optimize.h
COMMENT !		;automatic include file dependencies for BUILD.EXE
#include "i386\Macros.inc"
#include "i386\WinNT.inc"
#include "i386\Laguna.inc"
#include "Optimize.h"
!
.LIST

IF USE_ASM

.DATA

EXTERN		Swiz		:BYTE

.CODE
;
; Function prototypes.
;
vDitherColor	PROTO		PROC,
		rgb		:ULONG,
		pul		:PTR ULONG
CacheBrush	PROTO		PROC,
		ppdev		:PTR PDEV,
		pRbrush		:PTR RBRUSH
Cache4BPP	PROTO		PROC,
		ppdev		:PTR PDEV,
		pRbrush		:PTR RBRUSH
IF 1 ;#nbr
i386RealizeBrush PROTO		PROC,
		pbo		:PTR BRUSHOBJ,
		psoTarget	:PTR SURFOBJ,
		psoPattern	:PTR SURFOBJ,
		psoMask		:PTR SURFOBJ,
		pxlo		:PTR XLATEOBJ,
		iHatch		:ULONG
ENDIF

ifdef WINNT_VER40
Sync_w_3d_proc  	PROTO		PROC,
		ppdev		:PTR PDEV
endif

;
; Stack frame for DrvRealizeBrush.
;
espPTR		=	0
frmPTR		=	0
pbo_		TEXTEQU	<DWORD PTR [esp + 4 + espPTR]>
psoTarget_	TEXTEQU <DWORD PTR [esp + 8 + espPTR]>
psoPattern_	TEXTEQU <DWORD PTR [esp + 12 + espPTR]>
psoMask_	TEXTEQU	<DWORD PTR [esp + 16 + espPTR]>
pxlo_		TEXTEQU	<DWORD PTR [esp + 20 + espPTR]>
iHatch_		TEXTEQU <DWORD PTR [esp + 24 + espPTR]>

DrvRealizeBrush PROC PUBLIC,
	pbo		:PTR BRUSHOBJ,
	psoTarget	:PTR SURFOBJ,
	psoPattern	:PTR SURFOBJ,
	psoMask		:PTR SURFOBJ,
	pxlo		:PTR XLATEOBJ,
	iHatch		:ULONG

	mov	eax, [psoTarget_]	;EAX holds pointer to destination
	ASSUME	eax:PTR SURFOBJ
	push_	esi
	push_	edi
	or	eax, eax		;any destination?
	push_	ebx
	push_	ebp
	mov	esi, [psoPattern_]	;ESI holds pointer to psoPattern
	ASSUME	esi:PTR SURFOBJ
	jz	Error			;error: we don't have a target
	mov	ebx, [eax].dhpdev	;get handle to PDEV
	ASSUME	ebx:PTR PDEV
	mov	ebp, [iHatch_]		;get iHatch value
	test	ebx, ebx
	jz	Error			;error: we don't have a valid handle
	cmp	[ebx].Bcache, 0		;do we have a valid brush cache?
	je	Error			;nope

ifdef WINNT_VER40
;SYNC_W_3D macro equivalent
    cmp [ebx].NumMCDContexts, 0 ; is MCD alive?
	jle	Sync_end    			; no
    push    eax                 ; save
    push    ebx                 ; save
    push    ebx                 ; input to Sync_w_3d_proc
    call Sync_w_3d_proc         
    pop     ebx                 ; restore
    pop     eax                 ; restore
Sync_end:
endif

IF RB_DITHERCOLOR EQ 80000000h
	or	ebp, ebp		;must we realize a dither?
	js	RealizeDither		;yes, go do it now
ELSE
	test	ebp, RB_DITHERCOLOR	;must we realize a dither?
	jnz	RealizeDither		;yes, go do it now
ENDIF
	mov	ecx, [psoMask_]
	mov	eax, [pxlo_]
	ASSUME	eax:PTR XLATEOBJ
	cmp	[esi].sizlBitmap._cx, 8	;we only handle 8x8 patterns
	jne	Error
	cmp	[esi].sizlBitmap._cy, 8
	jne	Error
	or	ecx, ecx		;psoMask equals NULL?
	jnz	Error			;no, we don't support masks
	cmp	[esi].iType, STYPE_BITMAP
	jne	Error			;we only handle normal bitmaps

	mov	ecx, [esi].iBitmapFormat
	xor	ebp, ebp		;zero pointer to translation table
;//frido BEGIN 07-Apr-96
	cmp	ecx, BMF_1BPP		;monochrome pattern?
	je	@F			;yes, supported
	cmp	[ebx].iBitmapFormat, BMF_32BPP
					;32-bpp mode?
	je	Error			;yes, brushes are broken in chip

@@:	test	eax, eax
	jz	@F
;//frido END 07-Apr-96
	test	[eax].flXlate, XO_TRIVIAL
	jnz	@F
	mov	ebp, [eax].pulXlate	;get pointer from XLATEOBJ
	test	[eax].flXlate, XO_TABLE
	jnz	@F			;we have a translation table
	INVOKE	XLATEOBJ_piVector,	;get a pointer to the translation table
			eax
	mov	ecx, [esi].iBitmapFormat
	mov	ebp, eax
;//frido BEGIN 30-Mar-96
@@:	mov	eax, [pxlo_]
	cmp	ecx, BMF_4BPP		;test for 1- or 4-bpp pattern
	jb	RealizeMono		;realize monochrome pattern
	je	Realize4bpp		;realize 4-bpp pattern
	test	eax, eax		;XLATEOBJ specified?
	jz	@F			;no
IF 1 ;#nbr
	test	[eax].flXlate, XO_TRIVIAL
					;trivial translation?
	jz	ChainC			;no, chain to "C" code
ELSE
	test	[eax].flXlate, 10h	;invalid translation flags?
	jnz	Error			;yes
ENDIF

@@:	cmp	ecx, BMF_24BPP		;get number of bytes in pattern
;//frido END 30-Mar-96
	mov	edi, [esi].cjBits
	jne	@F
	add	edi, 64
@@:	cmp	ecx, [ebx].iBitmapFormat;must be same as device format
	jne	Error
	or	ebp, ebp		;we don't support translation
	jnz	Error
	lea	eax, [SIZEOF(RBRUSH) + edi]
	mov	edx, [pbo_]		;allocate the brush
	INVOKE	BRUSHOBJ_pvAllocRbrush,
			edx,
			eax
	ASSUME	eax:PTR RBRUSH
	test	eax, eax
	jz	Error			;error allocating the brush
	mov	ecx, [esi].iBitmapFormat
	mov	[eax].nPatSize, edi	;initialize the brush structure
	mov	[eax].iBitmapFormat, ecx
	mov	[eax].cjMask, 0
	mov	[eax].iType, BRUSH_COLOR

	mov	edx, [esi].lDelta	;get lDelta from pattern
	mov	esi, [esi].pvScan0	;get pointer to first scan line
	ASSUME	esi:NOTHING
	lea	edi, [eax].ajPattern	;get pointer to Rbrush->ajPattern
	mov	ebp, 8			;8 lines
	cmp	ecx, BMF_16BPP		;dispatch brush realization
	jb	Realize8bpp
	je	Realize16bpp
	cmp	ecx, BMF_24BPP
	je	Realize24bpp

;-------------------------------------------------------------------------------
; Realize32bpp - Realize a 32-bpp brush.
;
; On entry:	EDX	lDelta.
;		ESI	Pointer to source pattern.
;		EDI	Pointer to destination brush.
;		EBP	Number of lines to copy.
;-------------------------------------------------------------------------------
Realize32bpp:
	push	eax			;store arguments for CacheBrush
	push	ebx
@@:	mov	eax, [esi + 0]		;copy line
	mov	ebx, [esi + 4]
	mov	[edi + 0], eax
	mov	[edi + 4], ebx
	mov	eax, [esi + 8]
	mov	ebx, [esi + 12]
	mov	[edi + 8], eax
	mov	[edi + 12], ebx
	mov	eax, [esi + 16]
	mov	ebx, [esi + 20]
	mov	[edi + 16], eax
	mov	[edi + 20], ebx
	mov	eax, [esi + 24]
	mov	ebx, [esi + 28]
	mov	[edi + 24], eax
	mov	[edi + 28], ebx
	add	esi, edx		;next line
	add	edi, 32
	dec	ebp
	jnz	@B
	call	CacheBrush		;cache the brush
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi
	ret	24

;-------------------------------------------------------------------------------
; Realize24bpp - Realize a 24-bpp brush.
;
; On entry:	EDX	lDelta.
;		ESI	Pointer to source pattern.
;		EDI	Pointer to destination brush.
;		EBP	Number of lines to copy.
;-------------------------------------------------------------------------------
Realize24bpp:
	push	eax			;store arguments for CacheBrush
	push	ebx
@@:	mov	eax, [esi + 0]		;copy line
	mov	ebx, [esi + 4]
	mov	[edi + 0], eax
	mov	[edi + 4], ebx
	mov	eax, [esi + 8]
	mov	ebx, [esi + 12]
	mov	[edi + 8], eax
	mov	[edi + 12], ebx
	mov	eax, [esi + 16]
	mov	ebx, [esi + 20]
	mov	[edi + 16], eax
	mov	[edi + 20], ebx
	mov	eax, [esi + 0]
	mov	ebx, [esi + 4]
	mov	[edi + 24], eax
	mov	[edi + 28], ebx
	add	esi, edx		;next line
	add	edi, 32
	dec	ebp
	jnz	@B
	call	CacheBrush		;cache the brush
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi
	ret	24

;-------------------------------------------------------------------------------
; Realize16bpp - Realize a 16-bpp brush.
;
; On entry:	EDX	lDelta.
;		ESI	Pointer to source pattern.
;		EDI	Pointer to destination brush.
;		EBP	Number of lines to copy.
;-------------------------------------------------------------------------------
Realize16bpp:
	push	eax			;store arguments for CacheBrush
	push	ebx
@@:	mov	eax, [esi + 0]		;copy line
	mov	ebx, [esi + 4]
	mov	[edi + 0], eax
	mov	[edi + 4], ebx
	mov	eax, [esi + 8]
	mov	ebx, [esi + 12]
	mov	[edi + 8], eax
	mov	[edi + 12], ebx
	add	esi, edx		;next line
	add	edi, 16
	dec	ebp
	jnz	@B
	call	CacheBrush		;cache the brush
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi
	ret	24

;-------------------------------------------------------------------------------
; Realize8bpp - Realize an 8-bpp brush.
;
; On entry:	EDX	lDelta.
;		ESI	Pointer to source pattern.
;		EDI	Pointer to destination brush.
;		EBP	Number of lines to copy.
;-------------------------------------------------------------------------------
Realize8bpp:
	push	eax			;store arguments for CacheBrush
	push	ebx
@@:	mov	eax, [esi + 0]		;copy line
	mov	ebx, [esi + 4]
	mov	[edi + 0], eax
	mov	[edi + 4], ebx
	add	esi, edx		;next line
	add	edi, 8
	dec	ebp
	jnz	@B
	call	CacheBrush		;cache the brush
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi
	ret	24

;-------------------------------------------------------------------------------
; RealizeDither - Realize a dithered brush.
;
; Dithered brushes are only used in 8-bpp modes and are cached off-screen. The
; dither cache consists of a small table containing the off-screen location for
; each cache slot entry and a color value that is cached in that entry. When-
; ever we have to realize a dither, we first lookup the color in the cache
; table. If the color is found, we just load the brush with the cache parameters
; and return TRUE. Otherwise, we allocate a new cache slot and call the
; dithering routine which will create the dither directly in off-screen memory.
;
; On entry:	EBX	Pointer to PDEV.
;		EBP	Logical RGB color in lower three bytes.
;-------------------------------------------------------------------------------
RealizeDither:
	mov	eax, [pbo_]		;allocate the brush
	ASSUME	ebx:PTR PDEV
	INVOKE	BRUSHOBJ_pvAllocRbrush,
			eax,
			SIZEOF(RBRUSH)
	ASSUME	eax:PTR RBRUSH
	or	eax, eax
	jz	Error			;error
	and	ebp, 00FFFFFFh		;mask RGB color
	mov	edx, -SIZEOF(PDEV).Dtable
	mov	[eax].nPatSize, 0	;initialize brush structure
	mov	[eax].iBitmapFormat, BMF_8BPP
	mov	[eax].cjMask, 0
	mov	[eax].iType, BRUSH_DITHER
	mov	[eax].iUniq, ebp
@@:	cmp	[ebx].Dtable[edx + SIZEOF(PDEV).Dtable].ulColor, ebp
					;lookup color in Dtable
	jne	NextDither		;we still don't have a match
	lea	ebp, [edx + SIZEOF(PDEV).Dtable]
					;get index into cache table
	mov	esi, [ebx].Dtable[edx + SIZEOF(PDEV).Dtable].xy
	mov	[eax].cache_slot, ebp	;brush is cached
	mov	[eax].cache_xy, esi
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi
	mov	eax, 1			;return TRUE
	ret	24

NextDither:
	add	edx, SIZEOF(DC_ENTRY)	;next cache slot
	jnz	@B
;
; Cache the new dither.
;
	mov	edx, [ebx].DNext	;get the index of the next cache slot
	mov	ecx, edx
	and	edx, NUM_DITHER_BRUSHES - 1
	inc	ecx			;increment cache slot
	imul	edx, SIZEOF(DC_ENTRY)	;build cache table index
	mov	[ebx].DNext, ecx
	mov	[eax].cache_slot, edx	;store cache slot index
	mov	[ebx].Dtable[edx].ulColor, ebp
					;store logical color in cache table
	mov	esi, [ebx].Dtable[edx].xy
					;copy the x/y location of brush
	mov	edi, [ebx].Dtable[edx].pjLinear
					;get linear address
	mov	[eax].cache_xy, esi
	INVOKE	vDitherColor,		;dither the color
			ebp,
			edi
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi
	mov	eax, 1			;return TRUE
	ret	24

;-------------------------------------------------------------------------------
; Realize4bpp - Realize a 4-bpp brush.
;
; The 4-bpp cache consists of a small table containing the off-screen
; location for each cache slot entry, an 32-byte pattern, and a 16-color palette
; that is cached in that entry. Whenever we have to realize a 4-bpp brush, we
; first lookup the pattern and color palette in the cache table. If the pattern
; is found, we just load the brush with the cache parameters and return TRUE.
; Otherwise, we allocate a new cache slot and store the pattern and palette in
; the cache slot and translate the 4-bpp pattern in off-screen memory.
;
; On entry:	EAX	Pointer to XLATEOBJ.
;		EBX	Pointer to PDEV.
;		ESI	Pointer to psoPattern.
;		EBP	Pointer to translation table.
;-------------------------------------------------------------------------------
Realize4bpp:
	ASSUME	eax:PTR XLATEOBJ
	ASSUME	ebx:PTR PDEV
	ASSUME	esi:PTR SURFOBJ
	or	ebp, ebp		;we must have a valid translation table
	jz	Error
	cmp	[eax].cEntries, 16	;we only support 16 entries in the
	jne	Error			;  palette
	cmp	[esi].cjBits, 32	;we only support 32 bytes in the pattern
	jne	Error

	mov	edx, [pbo_]		;allocate the brush
	INVOKE	BRUSHOBJ_pvAllocRbrush,
			edx,
			SIZEOF(RBRUSH) + 32 + 64
	ASSUME	eax:PTR RBRUSH
	test	eax, eax
	jz	Error			;error allocating brush

	mov	[eax].nPatSize, 32 + 64	;initialize brush structure
	mov	[eax].iBitmapFormat, BMF_4BPP
	lea	edi, [eax].ajPattern
	mov	[eax].cjMask, 0
	mov	[eax].iType, BRUSH_4BPP

	cmp	[esi].lDelta, -4	;test for negative increment
	mov	esi, [esi].pvScan0	;get pointer to first scan line
	ASSUME	esi:NOTHING
	jne	Forward			;we have forward increment

	mov	ecx, [esi - 0]		;copy the pattern from top to bottom
	mov	edx, [esi - 4]
	mov	[edi + 0], ecx
	mov	[edi + 4], edx
	mov	ecx, [esi - 8]
	mov	edx, [esi - 12]
	mov	[edi + 8], ecx
	mov	[edi + 12], edx
	mov	ecx, [esi - 16]
	mov	edx, [esi - 20]
	mov	[edi + 16], ecx
	mov	[edi + 20], edx
	mov	ecx, [esi - 24]
	mov	edx, [esi - 28]
	mov	[edi + 24], ecx
	mov	[edi + 28], edx
	jmp	CopyPalette

Forward:
	mov	ecx, [esi + 0]		;copy the pattern from top to bottom
	mov	edx, [esi + 4]
	mov	[edi + 0], ecx
	mov	[edi + 4], edx
	mov	ecx, [esi + 8]
	mov	edx, [esi + 12]
	mov	[edi + 8], ecx
	mov	[edi + 12], edx
	mov	ecx, [esi + 16]
	mov	edx, [esi + 20]
	mov	[edi + 16], ecx
	mov	[edi + 20], edx
	mov	ecx, [esi + 24]
	mov	edx, [esi + 28]
	mov	[edi + 24], ecx
	mov	[edi + 28], edx

CopyPalette:
	mov	esi, ebp		;copy the palette into the brush
	add	edi, 32
	mov	ecx, 16
	mov	ebp, -SIZEOF(PDEV).Xtable
	cld
	rep	movsd

@@:	lea	esi, [ebx].Xtable[ebp + SIZEOF(PDEV).Xtable].ajPattern
	lea	edi, [eax].ajPattern	;check if the pattern and palette match
	mov	ecx, 8 + 16
	repe	cmpsd
	jne	NextXlate		;we still don't have a match
IF 1 ;#1308
	cmp	[ebx].Xtable[ebp + SIZEOF(PDEV).Xtable].iUniq, 0
	je	NextXlate
ENDIF
	mov	ecx, [ebx].Xtable[ebp + SIZEOF(PDEV).Xtable].xy
					;copy the cached parameters
	mov	ebx, [ebx].Xtable[ebp + SIZEOF(PDEV).Xtable].iUniq
	add	ebp, SIZEOF(PDEV).Xtable
	mov	[eax].iUniq, ebx
	mov	[eax].cache_slot, ebp
	mov	[eax].cache_xy, ecx
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi
	mov	eax, 1			;return TRUE
	ret	24

NextXlate:
	add	ebp, SIZEOF(XC_ENTRY)
	jnz	@B
	INVOKE	Cache4BPP,
			ebx,
			eax
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi
	ret	24

Error:
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi
	xor	eax, eax		;return FALSE
	ret	24

IF 1 ;#nbr
ChainC:
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi
	jmp	i386RealizeBrush
ENDIF

;-------------------------------------------------------------------------------
; RealizeMono - Realize a monochrome brush.
;
; The monochrome cache consists of a small table containing the off-screen
; location for each cache slot entry and an 8-byte pattern that is cached in
; that entry. Whenever we have to realize a monochrome brush, we first lookup
; the pattern in the cache table. If the pattern is found, we just load the
; brush with the cache parameters and return TRUE. Otherwise, we allocate a new
; cache slot and store the monochrome pattern in the cache slot and into off-
; screen memory.
;
; On entry:	EBX	Pointer to PDEV.
;		ESI	Pointer to psoPattern.
;		EBP	Pointer to translation table.
;-------------------------------------------------------------------------------
RealizeMono:
	ASSUME	ebx:PTR PDEV
	ASSUME	esi:PTR SURFOBJ
	or	ebp, ebp		;we must have a translation table
	jz	Error
	mov	edx, [pbo_]		;allocate the brush
	INVOKE	BRUSHOBJ_pvAllocRbrush,
			edx,
			SIZEOF(RBRUSH) + 8
	ASSUME	eax:PTR RBRUSH
	or	eax, eax
	jz	Error			;error

	mov	[eax].nPatSize, 8	;initialize the brush structure
	mov	[eax].iBitmapFormat, BMF_1BPP
	mov	[eax].cjMask, 0
	mov	[eax].iType, BRUSH_MONO

	mov	ecx, [ebp + 0]		;get the background color
	mov	edx, [ebp + 4]		;get the foreground color
	cmp	[ebx].iBytesPerPixel, 2	;expand the colors
	ja	XlateNone
	je	@F
	mov	ch, cl			;expand 8-bpp into 16-bit
	mov	dh, dl
@@:	mov	ebp, ecx		;expand 16-bpp into 32-bit
	mov	edi, edx
;//frido BEGIN 27-Mar-96
	and	ebp, 0000FFFFh		;mask 16-bits
	and	edi, 0000FFFFh
;//frido END 27-Mar-96
	shl	ecx, 16
	shl	edx, 16
	or	ecx, ebp
	or	edx, edi
XlateNone:
	mov	[eax].ulBackColor, ecx	;store the background color
	mov	[eax].ulForeColor, edx	;store the foreground color

	cmp	[esi].lDelta, 4		;test lDelta
	mov	esi, [esi].pvScan0	;get pointer to first scan line
	je	mForward

	mov	cl, [esi - 8]		;copy pattern into ECX/EDX bottom up
	mov	ch, [esi - 12]
	mov	dl, [esi - 24]
	mov	dh, [esi - 28]
	shl	ecx, 16
	mov	ebp, -SIZEOF(PDEV).Mtable
	shl	edx, 16
	mov	cl, [esi - 0]
	mov	ch, [esi - 4]
	mov	dl, [esi - 16]
	mov	dh, [esi - 20]
	jmp	@F

mForward:
	mov	cl, [esi + 8]		;copy pattern into ECX/EDX bottom down
	mov	ch, [esi + 12]
	mov	dl, [esi + 24]
	mov	dh, [esi + 28]
	shl	ecx, 16
	mov	ebp, -SIZEOF(PDEV).Mtable
	shl	edx, 16
	mov	cl, [esi + 0]
	mov	ch, [esi + 4]
	mov	dl, [esi + 16]
	mov	dh, [esi + 20]

@@:	mov	DWORD PTR [eax].ajPattern[0], ecx
					;store pattern in brush
	mov	DWORD PTR [eax].ajPattern[4], edx
mPTR	TEXTEQU	<ebp + SIZEOF(PDEV).Mtable>

@@:	cmp	DWORD PTR [ebx].Mtable[mPTR].ajPattern[0], ecx
					;lookup pattern in cache table
	jne	NextMono
	cmp	DWORD PTR [ebx].Mtable[mPTR].ajPattern[4], edx
	jne	NextMono
IF 1 ;#1308
	cmp	[ebx].Mtable[mPTR].iUniq, 0
	je	NextMono
ENDIF

	mov	ecx, [ebx].Mtable[mPTR].xy
					;copy the cached parameters
	mov	ebx, [ebx].Mtable[mPTR].iUniq
	add	ebp, SIZEOF(PDEV).Mtable
	mov	[eax].iUniq, ebx
	mov	[eax].cache_slot, ebp
	mov	[eax].cache_xy, ecx
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi
	mov	eax, 1			;return TRUE
	ret	24

NextMono:
	add	ebp, SIZEOF(MC_ENTRY)	;next table entry
	jnz	@B
;
; Cache the new brush.
;
	mov	edi, [ebx].MNext	;get the next monochrome cache slot
	mov	esi, edi
	and	edi, NUM_MONO_BRUSHES - 1
	inc	esi			;increment slot number
	imul	edi, SIZEOF(MC_ENTRY)	;build index into cache table
	mov	[ebx].MNext, esi	;stor new slot number

	mov	[eax].iUniq, esi	;store unique value
	mov	[eax].cache_slot, edi	;store index into cache table
	mov	[ebx].Mtable[edi].iUniq, esi
					;store unique value in cache table
	mov	DWORD PTR [ebx].Mtable[edi].ajPattern[0], ecx
					;store pattern in cache table
	mov	DWORD PTR [ebx].Mtable[edi].ajPattern[4], edx
	mov	esi, [ebx].Mtable[edi].xy
					;copy x/y location of brush
	mov	edi, [ebx].Mtable[edi].pjLinear
	mov	[eax].cache_xy, esi

	xor	eax, eax		;copy the swizzled bits to off-screen
	xor	ebx, ebx
	mov	al, cl
	mov	bl, ch
	shr	ecx, 16
	mov	al, [Swiz + eax]
	mov	bl, [Swiz + ebx]
	mov	[edi + 0], al
	mov	[edi + 1], bl
	mov	al, cl
	mov	bl, ch
	mov	al, [Swiz + eax]
	mov	bl, [Swiz + ebx]
	mov	[edi + 2], al
	mov	[edi + 3], bl
	mov	al, dl
	mov	bl, dh
	shr	edx, 16
	mov	al, [Swiz + eax]
	mov	bl, [Swiz + ebx]
	mov	[edi + 4], al
	mov	[edi + 5], bl
	mov	al, dl
	mov	bl, dh
	mov	al, [Swiz + eax]
	mov	bl, [Swiz + ebx]
	mov	[edi + 6], al
	mov	[edi + 7], bl

	pop	ebp
	pop	ebx
	pop	edi
	pop	esi
	mov	eax, 1			;return TRUE
	ret	24

DrvRealizeBrush ENDP

ENDIF ; USE_ASM

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\i386\laguna.inc ===
;===============================================================================
;
;	$Workfile:   LAGUNA.INC  $
;
;	Contents:
;	Laguna family structures and registers.
;
;	Copyright (c) 1996, Cirrus Logic, Inc.
;
;	$Log:   X:/log/laguna/nt35/displays/cl546x/i386/LAGUNA.INC  $
; 
;    Rev 1.59   Mar 25 1998 16:35:22   frido
; Added dwOverlayContr and dwCONTROL2Save variables.
; 
;    Rev 1.58   Mar 04 1998 14:43:10   frido
; Added shadowFGCOLOR.
; 
;    Rev 1.57   Feb 27 1998 17:03:34   frido
; Added shadowQFREE register and updated REQUIRE macro to use it.
; 
;    Rev 1.56   Jan 20 1998 11:45:54   frido
; Changed the REQUIRE macro for GBP on.
; Synchronized PDEV structure with C version.
; 
;    Rev 1.55   Jan 16 1998 14:06:26   frido
; Changed SOLID_COLOR_FILL so it uses the pattern.
; 
;    Rev 1.54   Nov 04 1997 09:25:22   frido
; Fixed a typo in DATASTREAMING switch.
; 
;    Rev 1.53   Nov 03 1997 16:26:04   frido
; Added fDataStreaming flag to PDEV structure.
; Changed REQUIRE macro.
; 
;    Rev 1.52   16 Oct 1997 09:50:34   bennyn
; 
; Added bPrevModeDDOutOfVideoMem to PDEV
; 
;    Rev 1.51   18 Sep 1997 16:02:18   bennyn
; Fixed compile/link problem of NT3.51
; 
;    Rev 1.50   16 Sep 1997 11:09:06   bennyn
; Fixed the DRIVERDATA mismatch in laguna.inc and driver.h
; 
;    Rev 1.49   12 Sep 1997 11:57:18   bennyn
; Fixed the PDEV misalignment and added overlay structures.
; 
;    Rev 1.48   18 Aug 1997 09:19:02   FRIDO
; 
; Added fields for bitmap filter.
; 
;    Rev 1.47   08 Aug 1997 17:19:18   FRIDO
; 
; Moved mmCore include file to after OFMHDL definition.
; 
;    Rev 1.46   08 Aug 1997 15:11:58   FRIDO
; Added automatic include file dependencies.
; 
;    Rev 1.45   08 Aug 1997 14:51:52   FRIDO
; Added support for new memory manager.
; 
;    Rev 1.44   01 Jul 1997 09:56:18   einkauf
; 
; 
; add dither x,y offsets to TMCDSYSTEM structs, to mirror PDEV changes
; 
;    Rev 1.43   23 May 1997 15:41:56   noelv
; 
; Added chip revision to pdev
; 
;    Rev 1.42   29 Apr 1997 16:29:42   noelv
; Merged in new SWAT code.
; SWAT: 
; SWAT:    Rev 1.4   24 Apr 1997 10:55:42   frido
; SWAT: NT140b09 merge.
; SWAT: Removed all memory manager changes for now.
; SWAT: 
; SWAT:    Rev 1.3   18 Apr 1997 00:26:10   frido
; SWAT: NT140b07 merge.
; SWAT: 
; SWAT:    Rev 1.2   11 Apr 1997 12:38:18   frido
; SWAT: Added OFM_HandleChain.
; SWAT: 
; SWAT:    Rev 1.1   09 Apr 1997 17:34:22   frido
; SWAT: Added fPreAllocate and nPages.
; SWAT: Added FONTCELL structure and variables.
; 
;    Rev 1.41   08 Apr 1997 11:49:34   einkauf
; 
; clean up TMCDSYSTEM struct, adds to PDEV to complete MCD
; 
;    Rev 1.40   04 Apr 1997 16:50:52   noelv
; Added pointer for new DDraw functions.
; 
;    Rev 1.39   27 Mar 1997 14:32:18   noelv
; Added new DDRAW function.
; 
;    Rev 1.38   21 Mar 1997 10:08:42   noelv
; Synced PDEV between C code and ASM code.
; Added macro to log QFREE data.
; Consolidated do_flag and sw_test_flag into a single pointer_switch flag.
; 
;    Rev 1.37   07 Mar 1997 09:35:48   SueS
; Define DO_FLAG based on NULL driver flags.
; 
;    Rev 1.36   26 Feb 1997 13:20:48   noelv
; 
; disable MCD code for NT 3.5x
; 
;    Rev 1.35   26 Feb 1997 09:24:50   noelv
; 
; Added support form OpenGL MCD driver
; 
;    Rev 1.33   28 Jan 1997 16:11:02   SueS
; Added clipping support for the 5465.
; 
;    Rev 1.32   23 Jan 1997 16:36:16   bennyn
; 
; Added 5465 DD support
; 
;    Rev 1.31   16 Jan 1997 11:32:38   bennyn
; Added power manager variables to PDEV
; 
;    Rev 1.30   10 Dec 1996 13:28:48   bennyn
; 
; Added ulFreq to PDEV
; 
;    Rev 1.29   27 Nov 1996 11:33:04   noelv
; Disabled Magic Bitmap
; 
;    Rev 1.28   18 Nov 1996 10:18:24   bennyn
; 
; Added grFormat to PDEV
; 
;    Rev 1.27   12 Nov 1996 15:17:16   bennyn
; 
; Added handle for DD blt scratch buffer
; 
;    Rev 1.26   07 Nov 1996 16:16:24   bennyn
; 
; Added support to alloc offscn mem in DD createsurface
; 
;    Rev 1.25   01 Nov 1996 09:21:12   BENNYN
; 
; Added support for DD blt code
; 
;    Rev 1.24   31 Oct 1996 11:13:44   noelv
; Split common buffer into two buffers.
; 
;    Rev 1.23   25 Oct 1996 11:53:06   noelv
; 
; added second common buffer
; 
;    Rev 1.22   23 Oct 1996 14:40:26   BENNYN
; 
; Added YUV cursor variables to PDEV
; 
;    Rev 1.21   04 Oct 1996 16:46:56   bennyn
; Added DirectDraw YUV support
; 
;    Rev 1.20   18 Sep 1996 13:56:08   bennyn
; Modified to support DD stretchBLT
; 
;    Rev 1.19   20 Aug 1996 11:29:00   noelv
; Bugfix release from Frido 8-19-96
; 
;    Rev 1.1   17 Aug 1996 12:32:50   frido
; New release from Bellevue.
; 
;    Rev 1.18   16 Aug 1996 08:59:02   bennyn
; 
; Moved bUseSWPtr outside of #ifdef WINNT_VER40
; 
;    Rev 1.17   16 Aug 1996 08:47:58   bennyn
; Modified to fix DirectDraw cursor problem
; 
;    Rev 1.16   25 Jul 1996 15:50:32   bennyn
; 
; Modified to support DirectDraw
; 
;    Rev 1.15   16 Jul 1996 14:26:44   BENNYN
; 
; 
;    Rev 1.14   11 Jul 1996 15:51:00   bennyn
; 
; Added DirectDraw support
; 
;    Rev 1.13   23 May 1996 16:23:06   BENNYN
; 
; Added SubFreeQ declarations
; 
;    Rev 1.12   08 May 1996 17:03:52   noelv
; preallocate device bitmap.
; 
;    Rev 1.11   03 May 1996 15:22:44   noelv
; added switch to turn font cache on and off
; 
;    Rev 1.10   01 May 1996 11:06:00   bennyn
; Modified for NT 4.0
; 
;    Rev 1.9   10 Apr 1996 13:40:02   NOELV
; Frido release 27
;	
;	   Rev 1.18   07 Apr 1996 17:12:30   frido
;	Added solid brush cache.
;	
;	   Rev 1.17   01 Apr 1996 13:58:40   frido
;	Changed layout of brush cache.
;	
;	   Rev 1.16   25 Mar 1996 11:42:18   frido
;	Bellevue 102B3.
; 
;    Rev 1.7   14 Mar 1996 09:40:08   andys
; 
; Added dcTileWidth and dsSRAMWidth
; 
;    Rev 1.6   12 Mar 1996 15:47:24   noelv
; Added support for stroke and fill path
; 
;    Rev 1.5   11 Mar 1996 11:53:40   noelv
; Added file pointer to PDEV
; 
;    Rev 1.4   08 Mar 1996 11:07:32   BENNYN
; 
;    Rev 1.3   05 Mar 1996 12:03:48   noelv
; Frido version 19
;	
;	   Rev 1.13   29 Feb 1996 19:57:10   frido
;	Added bEnable to PDEV structure.
;	
;	   Rev 1.12   27 Feb 1996 16:39:42   frido
;	Added device bitmap store/restore.
;	Changed DSURF structure.
;	
;	   Rev 1.11   26 Feb 1996 23:39:10   frido
;	Added function pointers for ScreenToHost and HostToScreen.
;	
;	   Rev 1.10   24 Feb 1996 01:22:40   frido
;	Added device bitmaps.
;	
;	   Rev 1.9   19 Feb 1996 05:10:50   frido
;	Changed broken_FIFO to 0.
;	
;	   Rev 1.8   17 Feb 1996 21:46:22   frido
;	Revamped brushing algorithmn.
;	
;	   Rev 1.7   13 Feb 1996 16:51:44   frido
;	Changed the layout of the PDEV structure.
;	Changed the layout of all brush caches.
;	Changed the number of brush caches.
;	
;	   Rev 1.6   10 Feb 1996 21:48:36   frido
;	Split monochrome and colored translation cache.
;	
;	   Rev 1.5   08 Feb 1996 00:03:06   frido
;	Added some extra definitions from Driver.h.
;	Changed number of XLATE caches to 8.
;	
;	   Rev 1.4   05 Feb 1996 17:35:10   frido
;	Added translation cache.
;	
;	   Rev 1.3   31 Jan 1996 13:48:32   frido
;	Added engine macros.
;	
;	   Rev 1.2   25 Jan 1996 22:03:10   frido
;	Added some more structures for the PatBLT.
;	
;	   Rev 1.1   25 Jan 1996 12:44:44   frido
;	Added font cache ID counter.
;	
;	   Rev 1.0   24 Jan 1996 23:13:40   frido
;	 Initial release.
;
;===============================================================================

.NOLIST
INCLUDE Optimize.h
INCLUDE SWAT.h
COMMENT ~		;automatic include file dependencies for BUILD.EXE
#include "Optimize.h"
#include "SWAT.h"
~
.LIST

; DirectDraw
; Be sure to synchronize these structures with those in driver.h!
ACCUM                 =     0
MAJ                   =     1
MIN                   =     2
MAX_REGS              =     3

MAX_FOURCCS           =     3
MAX_VIDEO_WINDOWS     =     8

; Bits defined in DrvSemaphore
; Be sure to synchronize these structures with those in driver.h!
DRVSEM_CURSOR_REMOVED_BIT    =     0
DRVSEM_HW_CURSOR_BIT         =     1
DRVSEM_IN_USE_BIT            =     2
DRVSEM_NEW_CURSOR_XY_BIT     =     3
DRVSEM_CHECK_CURSOR_BIT      =     4
DRVSEM_CURSOR_IN_USE_BIT     =     5
DRVSEM_CURSOR_CHANGED_BIT    =     6
DRVSEM_3D_BUSY_BIT           =     7
DRVSEM_MISSED_SET_BIT        =     8
DRVSEM_YUV_ON_BIT            =     9
DRVSEM_DISABLE_SETS_BIT      =     10
DRVSEM_YUV_RECT_VALID_BIT    =     11

; the corresponding mask values
; Be sure to synchronize these structures with those in driver.h!
DRVSEM_CURSOR_REMOVED        =     00000001h
DRVSEM_HW_CURSOR             =     00000002h
DRVSEM_IN_USE                =     00000004h
DRVSEM_NEW_CURSOR_XY         =     00000008h
DRVSEM_CHECK_CURSOR          =     00000010h
DRVSEM_CURSOR_IN_USE         =     00000020h
DRVSEM_CURSOR_CHANGED        =     00000040h
DRVSEM_3D_BUSY               =     00000080h
DRVSEM_MISSED_SET            =     00000100h
DRVSEM_YUV_ON                =     00000200h
DRVSEM_DISABLE_SETS          =     00000400h
DRVSEM_YUV_RECT_VALID        =     00000800h

broken_FIFO		=		0

autoblt_regs STRUCT
  LNCNTL		WORD		?
  SHRINKINC		WORD		?
  DRAWBLTDEF		DWORD		?
  FGCOLOR		DWORD		?
  BGCOLOR		DWORD		?
  OP0_opRDRAM		DWORD		?
  MAJ_Y			WORD		?
  MIN_Y			WORD		?
  OP1_opRDRAM		DWORD		?
  ACCUM_Y		WORD		?
  PATOFF		WORD		?
  OP2_opRDRAM		DWORD		?
  MAJ_X			WORD		?
  MIN_X			WORD		?
  BLTEXT		DWORD		?
  ACCUM_X		WORD		?
  OP0_opSRAM		WORD		?
  SRCX			WORD		?
  OP2_opSRAM		WORD		?
  BLTEXTR_EX            DWORD		?
  MBLTEXTR_EX           DWORD		?
  OP0_opMRDRAM          DWORD		?
  OP1_opMRDRAM          DWORD		?
  STRETCH_CNTL          WORD		?
  RESERVED              WORD		?
  CLIPULE               DWORD		?
  CLIPLOR               DWORD		?
  NEXT_HEAD		DWORD		?
autoblt_regs ENDS

NUM_MONO_BRUSHES	=		32
NUM_4BPP_BRUSHES	=		8
NUM_DITHER_BRUSHES	=		8
NUM_COLOR_BRUSHES	=		32
NUM_8BPP_BRUSHES	=		(NUM_COLOR_BRUSHES)
NUM_16BPP_BRUSHES	=		(NUM_COLOR_BRUSHES/2)
NUM_TC_BRUSHES		=		(NUM_COLOR_BRUSHES/4)
;//frido BEGIN 07-Apr-96
NUM_SOLID_BRUSHES	=		4
;//frido END 07-Apr-96

;//frido BEGIN 01-Apr-96
;FIRST_MONO_ROW		=		0
;NUM_MONO_ROWS		=		(NUM_MONO_BRUSHES/16)
;FIRST_4BPP_ROW		=		(FIRST_MONO_ROW + NUM_MONO_ROWS)
;NUM_4BPP_ROWS		=		(NUM_4BPP_BRUSHES*2)
;FIRST_DITHER_ROW	=		(FIRST_4BPP_ROW + NUM_4BPP_ROWS)
;NUM_DITHER_ROWS   	=		(NUM_DITHER_BRUSHES/2)
;FIRST_COLOR_ROW   	=		(FIRST_DITHER_ROW + NUM_DITHER_ROWS)
;NUM_COLOR_ROWS		=		(NUM_COLOR_BRUSHES/2)
;//frido END 01-Apr-96

RBRUSH STRUCT
  nPatSize		ULONG		?
  iBitmapFormat		ULONG		?
  ulForeColor		ULONG		?
  ulBackColor		ULONG		?
  iType			ULONG		?
    BRUSH_MONO		=		1
    BRUSH_4BPP		=		2
    BRUSH_DITHER	=		3
    BRUSH_COLOR		=		4
  iUniq			ULONG		?
  cache_slot		ULONG		?
  cache_xy		ULONG		?
  cjMask		ULONG		?
  ajPattern		BYTE		0 DUP(?)
RBRUSH ENDS

BC_ENTRY STRUCT
  xy			ULONG		?
  pjLinear		DWORD		?
  brushID		DWORD		?
BC_ENTRY ENDS

DC_ENTRY STRUCT
  xy			ULONG		?
  pjLinear		DWORD		?
  ulColor		ULONG		?
DC_ENTRY ENDS

MC_ENTRY STRUCT
  xy			ULONG		?
  pjLinear		DWORD		?
  iUniq			ULONG		?
  ajPattern		BYTE		8 DUP(?)
MC_ENTRY ENDS

XC_ENTRY STRUCT
  xy			ULONG		?
  pjLinear		DWORD		?
  iUniq			ULONG		?
  ajPattern		BYTE		8 * 4 DUP(?)
  ajPalette		ULONG		16 DUP(?)
XC_ENTRY ENDS

POFM_CALLBACK		TYPEDEF		PTR

OFMHDL STRUCT
  x			ULONG		?
  y			ULONG		?
  aligned_x		ULONG		?
  aligned_y		ULONG		?
  sizex			LONG		?
  sizey			LONG		?
  alignflag		ULONG		?
  flag			ULONG		?
  pcallback		POFM_CALLBACK	?
  prevhdl		DWORD		?
  nexthdl		DWORD		?
  subprvhdl		DWORD		?
  subnxthdl		DWORD		?
  prvFonthdl		DWORD		?
  nxtFonthdl		DWORD		?
  pdsurf		DWORD		?
OFMHDL ENDS
POFMHDL			TYPEDEF		PTR OFMHDL

IF MEMMGR
  INCLUDE mmCore.h
ENDIF
COMMENT ~
#include "mmCore.h" //automatic include file dependencies for BUILD.EXE
~

DDOFM STRUCT
  prevhdl      	DWORD        	?
  nexthdl	DWORD		?
  phdl		POFMHDL		?
DDOFM ENDS
PDDOFM			TYPEDEF		PTR DDOFM


MAX_GLYPHS		=		256
FONTMEMORY STRUCT
  pTile			DWORD		?
  ulLastX		DWORD		?
  pNext			DWORD		?
FONTMEMORY ENDS

GLYPHCACHE STRUCT
  xyPos			DWORD		?
  cSize			DWORD		?
  ptlOrigin		POINTL		{}
GLYPHCACHE ENDS

; New SWAT3 structure.
FONTCELL STRUCT
  x			DWORD		?
  y			DWORD		?
  pfc			DWORD		?
  ulLastX		DWORD		?
  pNext			DWORD		?
FONTCELL ENDS
PFONTCELL		TYPEDEF		PTR FONTCELL

FONTCACHE STRUCT
  ppdev			DWORD		?
  pFontMemory		DWORD		?
  pFontCell		PFONTCELL	?	;SWAT3
  ulFontCount		ULONG		?
  aGlyphs		GLYPHCACHE	MAX_GLYPHS DUP({})
  pfo                   DWORD		?
  pfcPrev               DWORD		?
  pfcNext               DWORD		?
FONTCACHE ENDS
PFONTCACHE      	TYPEDEF		PTR FONTCACHE

OFFSCR_YUV STRUCT
  SrcRect               RECTL		{}
  nInUse  		WORD		?
  ratio                 WORD		?
OFFSCR_YUV ENDS
POFFSCR_YUV  		TYPEDEF		PTR OFFSCR_YUV

if DRIVER_5465
ifdef OVERLAY

VIDCONFIG STRUCT
   sizXfer		SIZEL		{}
   sizCap		SIZEL		{}
   sizSrc		SIZEL		{}
   sizDisp		SIZEL		{}
   uXferDepth           DWORD           ?
   uCapDepth            DWORD           ?
   uSrcDepth            DWORD           ?
   uDispDepth           DWORD           ?
   uGfxDepth            DWORD           ?
   dwXferRate           DWORD           ?
   dwFlags              DWORD           ?
VIDCONFIG ENDS
LPVIDCONFIG  		TYPEDEF		PTR VIDCONFIG


PROGREGS STRUCT
   VW0_FIFO_THRSH          WORD            ?
   DispThrsTiming          WORD            ?
PROGREGS ENDS
LPPROGREGS  		TYPEDEF		PTR PROGREGS


OVERLAYFLIPRECORD STRUCT
   fpFlipFrom                 PBYTE        ?
   liFlipTime                 DWORD        ?
                              DWORD        ?
                              DWORD        ?
                              DWORD        ?
   dwFlipDuration             DWORD        ?
   dwFlipScanline             DWORD        ?
   bFlipFlag                  BOOL	   ?
   bHaveEverCrossedVBlank     BOOL	   ?
   bWasEverInDisplay          BOOL	   ?
OVERLAYFLIPRECORD ENDS


OVERLAYTABLE STRUCT
   pfnCanCreateSurface        DWORD        ?
   pfnCreateSurface           DWORD        ?
   pfnDestroySurface          DWORD        ?
   pfnLock                    DWORD        ?
   pfnUnlock                  DWORD        ?
   pfnSetColorKey             DWORD        ?
   pfnFlip                    DWORD        ?
   pfnUpdateOverlay           DWORD        ?
   pfnSetOverlayPos           DWORD        ?
   pfnGetFlipStatus           DWORD        ?
OVERLAYTABLE ENDS
LPOVERLAYTABLE  		TYPEDEF		PTR OVERLAYTABLE

endif ; OVERLAY
endif ; DRIVER_5465


DRIVERDATA STRUCT
   PTAGFooPixel         DWORD           ?
   fNineBitRDRAMS       WORD            ?
   fReset               BOOL		?
   ScreenAddress        PBYTE           ?
   VideoBase            PBYTE           ?
   RegsAddress          DWORD	        ?
   DrvSemaphore         WORD            ?
   EdgeTrim             WORD            ?
   YUVTop               WORD            ?
   YUVLeft              WORD            ?
   YUVXExt              WORD            ?
   YUVYExt              WORD            ?
   VideoSemaphore       WORD            ?
   CurrentVideoFormat   WORD            ?
   NumVideoSurfaces     WORD            ?
   ScratchBufferOrg     DWORD           ?

ifdef WINNT_VER40
if DRIVER_5465
ifdef OVERLAY
   fOverlaySupport      BOOL		?
   OverlayTable		OVERLAYTABLE	{}
   dwOverlayCount	DWORD		?
   dwCONTROL2Save	DWORD		?

   ; Win95 5465over.c static vars
   bUseBWEqn            BOOL		?
   bNoOverlayInThisMode BOOL		?

   lpHardwareOwner  	DWORD           MAX_VIDEO_WINDOWS DUP (?)
   lpColorSurfaceVW  	DWORD           MAX_VIDEO_WINDOWS DUP (?)
   lpSrcColorSurfaceVW  DWORD           MAX_VIDEO_WINDOWS DUP (?)

   grOverlaySrc		RECTL           MAX_VIDEO_WINDOWS DUP ({})
   grOverlayDest 	RECTL           MAX_VIDEO_WINDOWS DUP ({})
   gdwFourccVW 	        DWORD           MAX_VIDEO_WINDOWS DUP (?)
   bIsVWMirrored        BOOL	        MAX_VIDEO_WINDOWS DUP (?)

   gdwAvailVW           DWORD           ?
   gdwColorKey          DWORD           ?
   gdwSrcColorKeyLow    DWORD           ?
   gdwSrcColorKeyHigh   DWORD           ?
   gdwDestColorKeyOwnerVW DWORD         ?
   gdwSrcColorKeyOwnerVW  DWORD         ?

   giOvlyCnt 	        DWORD           MAX_VIDEO_WINDOWS DUP (?)
   giPlanarCnt          DWORD           ?
   bCLPLLobotomyMode    BOOL		?

   ; Win95 5465over.c global vars
   gsOverlayFlip 	OVERLAYFLIPRECORD	{}

   gsProgRegs           PROGREGS        {}

   gvidConfig           VIDCONFIG       {}

   gwNormalDTTR         WORD            ?
   dwNumVideoWindows    DWORD           ?

   bEnableCLPL          BOOL		?

   ; NT only data
   dwMaxOverlayStretch  DWORD           ?
   dwMinOverlayStretch  DWORD           ?

   dwFourCC 	        DWORD           MAX_FOURCCS DUP (?)
else
   dwFourCC             DWORD           ?
endif ; OVERLAY
else
   dwFourCC             DWORD           ?
endif ; DRIVER_5465
endif ; WINNT_VER40

   signature            DWORD           ?

DRIVERDATA ENDS
PDRIVERDATA  		TYPEDEF		PTR DRIVERDATA

FLIPRECORD STRUCT
ifdef WINNT_VER40
   fpFlipFrom              PBYTE        ?
endif
   liFlipTime              DWORD        ?
                           DWORD        ?
   liFlipDuration          DWORD        ?
                           DWORD        ?
   bFlipFlag               BOOL		?
   bHaveEverCrossedVBlank  BOOL		?
   bWasEverInDisplay       BOOL		?
   dwFlipScanLine          WORD         ?
FLIPRECORD ENDS
PFLIPRECORD  		TYPEDEF		PTR FLIPRECORD


LL_RECT STRUCT
    DWORD left                          ?
    DWORD top                           ?
    DWORD right                         ?
    DWORD bottom                        ?
LL_RECT ENDS

TDISPLAYLIST STRUCT
    pdwNext                 DWORD       ?
    hMem                    DWORD       ?
    pdwLinPtr               DWORD       ?
    pdwStartOutPtr          DWORD       ?
    dwPhyPtr                DWORD       ?
    dwLen                   DWORD       ?
    dwMargin                DWORD       ?
TDISPLAYLIST ENDS
PTRDL TYPEDEF		PTR TDISPLAYLIST

NUM_DL      =       2

LL_PATTERN STRUCT
    pat DWORD   8 DUP(?)
LL_PATTERN ENDS

TMCDSYSTEM STRUCT
    rColor_Min_Bounds       DWORD       ?
    rColor_Max_Bounds       DWORD       ?
    AlphaConstSource        DWORD       ?
    AlphaConstDest          DWORD       ?
    Displists  TDISPLAYLIST    NUM_DL  DUP({})
    pDL                     PTRDL       ?
    dwCdl                   DWORD       ?
    pRegs                   DWORD       ?
    pFrame                  PBYTE       ?
    pattern_ram_state       DWORD       ?
	dither_array            LL_PATTERN  {}	
    dither_x_offset         WORD        ?
    dither_y_offset         WORD        ?
TMCDSYSTEM  ENDS

;temporary mem for MCD display lists
SIZE_TEMP_DL    =     2048   
SIZE_FRECIP     =     2048+1

PDEV STRUCT
  hDriver		HANDLE		?
  hdevEng		HANDLE		?
  hsurfEng		HANDLE		?
  hPalDefault		HANDLE		?
  pjScreen		PBYTE		?
  cxScreen		ULONG		?
  cyScreen		ULONG		?
  cxMemory              ULONG           ?
  cyMemory              ULONG           ?
  cyMemoryReal          ULONG           ?
  ulMode		ULONG		?
  ulFreq		ULONG		?
  lDeltaScreen		LONG		?
  flRed			FLONG		?
  flGreen		FLONG		?
  flBlue		FLONG		?
  cPaletteShift		ULONG		?
  ptlHotSpot		POINTL		{}
  cPatterns		ULONG		?
  ahbmPat		HANDLE		HS_DDI_MAX DUP(?)
  pPal			DWORD		?
  pjOffScreen		PBYTE		?
  iBitmapFormat		ULONG		?
  ulBitCount		ULONG		?
  iBytesPerPixel	ULONG		?
  PtrABlt		autoblt_regs	3 DUP({})

ifdef WINNT_VER40
  CShsem		HANDLE		?
else
  PtrCritSec		CRITICAL_SECTION {}
endif

  prcl			RECTL		{}
  PtrBusy		BOOL		?
  fHwCursorActive	BOOL		?
  CursorHidden		BOOL		?
  PtrMaskHandle		POFMHDL		?
  PtrImageHandle	POFMHDL		?
  PtrABltHandle		POFMHDL		?
  PtrXHotSpot		ULONG		?
  PtrYHotSpot		ULONG		?
  PtrX			ULONG		?
  PtrY			ULONG		?
  PtrSzX		ULONG		?
  PtrSzY		ULONG		?
  PointerUsage		LONG		?
  grCONTROL             DWORD           ?
  grFORMAT              DWORD           ?
  grVSCONTROL           DWORD           ?
  lOffset_2D		LONG		?
  lTileSize		LONG		?
  lTotalMem		LONG		?
  OFM_init		BOOL		?

ifdef WINNT_VER40
  MMhsem		HANDLE		?
else
  MutexHdl		HANDLE		?
endif

  bDirectDrawInUse	BOOL		?
  ScrnHandle		POFMHDL		?
  OFM_UsedQ		POFMHDL		?
  OFM_FreeQ		POFMHDL		?
  OFM_SubFreeQ1		POFMHDL		?
  OFM_SubFreeQ2		POFMHDL		?
  pfcChain              PFONTCACHE      ?

  Bcache		POFMHDL		?

  Mtable		MC_ENTRY	NUM_MONO_BRUSHES DUP({})
  Xtable		XC_ENTRY	NUM_4BPP_BRUSHES DUP({})
  Dtable		DC_ENTRY	NUM_DITHER_BRUSHES DUP({})
  Ctable		BC_ENTRY	NUM_COLOR_BRUSHES DUP({})
;frido BEGIN 07-Apr-96
  Stable		DC_ENTRY	NUM_SOLID_BRUSHES DUP({})
  SNext			ULONG		?
;frido END 07-Apr-96
  CLast			ULONG		?
  MNext			ULONG		?
  XNext			ULONG		?
  DNext			ULONG		?
  CNext			ULONG		?

  ulFontCount		ULONG		?
  UseFontCache		ULONG		?

  ptlOffset		POINTL		{}
  bEnable		BOOL		?

  pfnHostToScreen	DWORD		?
  pfnScreenToHost	DWORD		?

  pLgREGS_real		DWORD		?
  pLgREGS		DWORD		?

  dcTileWidth		WORD		?
  dcSRAMWidth		WORD		?

  uBLTDEF		    ULONG		?
  uRop			    ULONG		?
  pvTmpBuffer		DWORD		?


  IF ENABLE_LOG_FILE 
    pmfile          DWORD           ? 
    TxtBuff         DWORD   1000h   DUP(?) 
    TxtBuffIndex    DWORD           ?
  ENDIF

  IF NULL_HW
    buffer          BYTE    1000h   DUP(?)
  ENDIF

  IF WINBENCH96
    pofmMagic           POFMHDL		?
    bMagicUsed          ULONG		?
  ENDIF

; SWAT1 changes.
  fPreAllocate		BOOL		?
  nPages		DWORD		?
; SWAT3 changes.
  FONTCELL_COUNT	=		64
  FONTCELL_X		=		128
  FONTCELL_y		=		16
  pofmFontCache		POFMHDL		?
  fcGrid		FONTCELL	FONTCELL_COUNT DUP({})
IF MEMMGR
; MEMMGR changes.
  mmMemMgr		IIMEMMGR	{}
  must_have_width	LONG		?
  bBitmapFilter		BOOL		?
  szlBitmapMin		SIZEL		{}
  szlBitmapMax		SIZEL		{}
ENDIF

  ; For DirectDraw      
  bPrevModeDDOutOfVideoMem  BOOL	?
  DirectDrawHandle      POFMHDL		?
  flipRecord            FLIPRECORD      {}
  DriverData            DRIVERDATA      {}
  offscr_YUV            OFFSCR_YUV      {}
  dwDDLinearCnt		DWORD		?
  pPtrMaskHost		PBYTE		?

  bYUVuseSWPtr     	BOOL		?
  dwLgDevID     	DWORD		?
  dwLgDevRev     	DWORD		?
  bYUVSurfaceOn         BOOL            ?
  InitBPP               WORD		?

  lRegVals              DWORD           2 * MAX_REGS DUP(?)
  sShrinkInc            DWORD		?
  usLnCntl              DWORD		?
  usStretchCtrl         DWORD		?

  pPMdatabuf            PBYTE		?

ifdef WINNT_VER40
  pfnDelay9BitBlt       DWORD		?
  pfnEdgeFillBlt        DWORD		?
  pfnMEdgeFillBlt       DWORD		?
  pfnDrvDstBlt          DWORD		?
  pfnDrvDstMBlt         DWORD		? 
  pfnDrvSrcBlt          DWORD		?
  pfnDrvSrcMBlt         DWORD		?
  pfnDrvStrBlt          DWORD		?
  pfnDrvStrMBlt         DWORD		?
  pfnDrvStrMBltY        DWORD		?
  pfnDrvStrMBltX        DWORD		?
  pfnDrvStrBltY         DWORD		?
  pfnDrvStrBltX         DWORD		?
endif

   DDScratchBufHandle   POFMHDL     ?
   DDOffScnMemQ         PDDOFM      ?

  IFDEF BUS_MASTER
    Buf1VirtAddr 	DWORD       ?
    Buf2VirtAddr 	DWORD       ?
    Buf1PhysAddr 	DWORD       ?
    Buf2PhysAddr 	DWORD       ?
    BufLength 		ULONG       ?
  ENDIF

  ;START OpenGL MCD additions
  IFNDEF WINNT_VER35
    hMCD                 HANDLE     ?
    pMCDFilterFunc       DWORD      ?
    cDoubleBufferRef     DWORD      ?
    cZBufferRef          DWORD      ?
    pohBackBuffer        POFMHDL	?
    pohZBuffer           POFMHDL	?

    temp_DL_chunk        DWORD		SIZE_TEMP_DL DUP(?)
    LL_State             TMCDSYSTEM {}

    pAllocOffScnMem      DWORD      ?
    pFreeOffScnMem       DWORD      ?
    pAssertModeMCD       DWORD      ?

    frecips              DWORD		SIZE_FRECIP DUP(?)

    pLastDevRC           DWORD      ?
    NumMCDContexts       DWORD      ?
    iUniqueness          DWORD      ?
    pFirstTexture        DWORD      ?
    pLastTexture         DWORD      ?
  ENDIF
  ;END OpenGL MCD additions

  XlateCache          POFMHDL ?
  XlateCacheId        ULONG   ?
  CachedChromaCtrl    WORD    ?
  CachedStretchCtrl   WORD    ?
                                      
  signature           DWORD   ?

if DATASTREAMING
   dwDataStreaming	DWORD		?
   shadowFGCOLOR	DWORD		?
   shadowBGCOLOR	DWORD		?
   shadowDRAWBLTDEF	DWORD		?
   shadowQFREE		BYTE		?
endif
PDEV ENDS

DSURF STRUCT
  ppdev			DWORD		?
  pofm			DWORD		?
  pso			DWORD		?
  ptl			POINTL		{}
  sizl			SIZEL		{}
  packedXY		DWORD		?
DSURF ENDS

TEXT_EXPAND_XPAR	=		106601F0h
TEXT_EXPAND_OPAQUE	=		100600F0h
SOLID_COLOR_FILL	=		100700F0h
CLIPEN			=		0800h

grSTATUS		=		400h
grCONTROL		=		402h
grQFREE			=		404h
grOFFSET_2D		=		405h
grTIMEOUT		=		406h
grTILE_CTRL		=		407h
grRESIZE_A_opRDRAM	=		408h
grRESIZE_B_opRDRAM	=		40Ch
grRESIZE_C_opRDRAM	=		410h
grCOMMAND		=		480h
grMIN_Y			=		500h
grMAJ_Y			=		502h
grACCUM_Y		=		504h
grMIN_X			=		508h
grMAJ_X			=		50Ah
grACCUM_X		=		50Ch
grLNCNTL		=		50Eh
grBLTEXT		=		518h
grMBLTEXT		=		51Ch
grOP0_opRDRAM		=		520h
grOP0_opMRDRAM		=		524h
grOP0_opSRAM		=		528h
grPATOFF		=		52Ah
grOP1_opRDRAM		=		540h
grOP1_opMRDRAM		=		544h
grOP1_opSRAM		=		548h
grOP1_opMSRAM		=		54Ah
grOP2_opRDRAM		=		560h
grOP2_opMRDRAM		=		564h
grOP2_opSRAM		=		568h
grOP2_opMSRAM		=		56Ah
grSRCX			=		580h
grSHRINKINC		=		582h
grDRAWBLTDEF		=		584h
grDRAWDEF		=		584h
grBLTDEF		=		586h
grMONOQW		=		588h
grCLIPULE		=		590h
grCLIPLOR		=		594h
grMCLIPULE		=		598h
grMCLIPLOR		=		59Ch
grOP_opFGCOLOR		=		5E0h
grOP_opBGCOLOR		=		5E4h
grBITMASK		=		5E8h
grPTAG			=		5ECh
grBOGUS			=		5FCh
grBLTEXT_XEX		=		600h
grBLTEXTFF_XEX		=		604h
grBLTEXTR_XEX		=		608h
grBLTEXT_LN_EX		=		60Ch
grMBLTEXT_XEX		=		620h
grMBLTEXTR_XEX		=		628h
grBLTEXT_EX		=		700h
grBLTEXTFF_EX		=		704h
grBLTEXTR_EX		=		708h
grMBLTEXT_EX		=		720h
grMBLTEXTR_EX		=		728h
grCLIPULE_EX		=		760h
grCLIPLOR_EX		=		770h
grMCLIPULE_EX		=		780h
grMCLIPLOR_EX		=		790h
grHOSTDATA		=		800h

SWIZ_CNTL		=		0400h

ENUMRECTS8 STRUCT
  _c			DWORD		?
  arcl			RECTL		8 DUP({})
ENUMRECTS8 ENDS

FUDGE			=		2	;fudge factor for QFREE register

REQUIRE MACRO n:REQ, ppdev:REQ, base:=<ebp>
  LOCAL WaitFIFO, SkipWait, WaitIdle, SkipWaitUpdate, WaitLoop
  IF DATASTREAMING
    TEMPREG8 TEXTEQU <>
    TEMPREG32 TEXTEQU <>
    IFDIFI <ppdev>, <eax>
      IFDIFI <base>, <eax>
        TEMPREG8 TEXTEQU <al>
        TEMPREG32 TEXTEQU <aex>
      ENDIF
    ENDIF
    IFDIFI <ppdev>, <ebx>
      IFDIFI <base>, <ebx>
        TEMPREG8 TEXTEQU <bl>
        TEMPREG32 TEXTEQU <ebx>
      ENDIF
    ENDIF
    IFDIFI <ppdev>, <ecx>
      IFDIFI <base>, <ecx>
        TEMPREG8 TEXTEQU <cl>
        TEMPREG32 TEXTEQU <ecx>
      ENDIF
    ENDIF
    IFDIFI <ppdev>, <edx>
      IFDIFI <base>, <edx>
        TEMPREG8 TEXTEQU <dl>
        TEMPREG32 TEXTEQU <edx>
      ENDIF
    ENDIF
	test	[ppdev].dwDataStreaming, -1
	js	WaitFIFO
	jz	SkipWait
	cmp	BYTE PTR [base + grQFREE], n + FUDGE
	jnb	SkipWait
WaitIdle:
	test	WORD PTR [base + grSTATUS], 8005h
	jnz	WaitIdle
	mov	byte ptr [ppdev].dwDataStreaming, 0
	jmp	SkipWait
WaitFIFO:
	push	TEMPREG32
	mov	TEMPREG8, [ppdev].shadowQFREE
WaitLoop:
	cmp	TEMPREG8, n + FUDGE
	jnb	SkipWaitUpdate
	mov	TEMPREG8, [base + grQFREE]
	jmp	WaitLoop
SkipWaitUpdate:
	sub	TEMPREG8, n
	mov	[ppdev].shadowQFREE, TEMPREG8
	pop	TEMPREG32
SkipWait:
  ENDIF
ENDM

IDLE MACRO base:=<ebp>
  LOCAL WaitFIFO
WaitFIFO:
	cmp	WORD PTR [base + grSTATUS], 0
	jne	WaitFIFO
ENDM

ENDREQUIRE MACRO ppdev:REQ
  IF DATASTREAMING
	or	[ppdev].dwDataStreaming, 1
  ENDIF
ENDM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\i386\patblt.asm ===
;===============================================================================
;
;	$Workfile:   PATBLT.ASM  $
;
;	Contents:
;	This file contains the assembly code for the pattern blit routine.
;
;	Copyright (c) 1996, Cirrus Logic, Inc.
;
;	$Log:   X:/log/laguna/nt35/displays/cl546x/i386/PATBLT.ASM  $
; 
;    Rev 1.21   Mar 04 1998 15:45:14   frido
; Added more shadowing.
; 
;    Rev 1.20   Jan 20 1998 11:45:22   frido
; Added shadowing for DRAWBLTDEF and BGCOLOR registers.
; 
;    Rev 1.19   Nov 04 1997 09:26:10   frido
; Fixed a typo (PPDEV into PDEV).
; 
;    Rev 1.18   Nov 03 1997 16:38:56   frido
; Added REQUIRE macros.
; 
;    Rev 1.17   29 Apr 1997 16:29:38   noelv
; Merged in new SWAT code.
; SWAT: 
; SWAT:    Rev 1.4   24 Apr 1997 10:52:56   frido
; SWAT: NT140b09 merge.
; SWAT: 
; SWAT:    Rev 1.3   19 Apr 1997 16:32:18   frido
; SWAT: Added automatic include file dependencies for BUILD.EXE.
; SWAT: Added SWAT.h include file.
; SWAT: 
; SWAT:    Rev 1.2   18 Apr 1997 00:26:12   frido
; SWAT: NT140b07 merge.
; SWAT: 
; SWAT:    Rev 1.1   15 Apr 1997 19:13:42   frido
; SWAT: Added SWAT6: striping in PatBlt.
; 
;    Rev 1.16   08 Apr 1997 11:47:28   einkauf
; 
; add call to SYNC_W_3D for MCD coordination
; 
;    Rev 1.15   21 Mar 1997 10:10:18   noelv
; Synced PDEV between C code and ASM code.
; Added macro to log QFREE data.
; Consolidated do_flag and sw_test_flag into a single pointer_switch flag.
; 
;    Rev 1.14   07 Mar 1997 09:41:56   SueS
; Added NULL_BITBLT flag to assembly code.  Changed order of include files.
; 
;    Rev 1.13   04 Feb 1997 11:57:34   SueS
; Added support for hardware clipping for the 5465.
; 
;    Rev 1.12   26 Nov 1996 11:38:02   bennyn
; Fixed the DSURF save bug
; 
;    Rev 1.11   21 Nov 1996 15:02:40   noelv
; DSURF (in EBX) was getting hammered before call to bCreateScreenFromDib.
; 
;    Rev 1.10   07 Oct 1996 09:51:00   bennyn
; Fixed push/pop worng order bug
; 
;    Rev 1.9   04 Oct 1996 16:47:50   bennyn
; 
; Added DirectDraw YUV support
; 
;    Rev 1.8   22 Aug 1996 18:15:18   noelv
; Frido bug fix release 8-22.
; 
;    Rev 1.2   22 Aug 1996 17:12:52   frido
; #ddblt - Added check for bDirectDrawInUse.
; 
;    Rev 1.1   17 Aug 1996 15:32:14   frido
; #1244 - Fixed brush rotation for off-screen bitmaps.
; 
;    Rev 1.0   14 Aug 1996 17:14:36   frido
; Initial revision.
; 
;    Rev 1.6   01 May 1996 11:06:20   bennyn
; 
; Modified for NT 4.0
; 
;    Rev 1.5   10 Apr 1996 13:39:32   NOELV
; Frido release 27
;       
;          Rev 1.15   08 Apr 1996 16:43:06   frido
;       Changed EngBitBlt into PuntBitBlt.
;       
;          Rev 1.14   29 Feb 1996 22:57:24   frido
;       Added check for destination in ROP and updated grDRAWBLTDEF.
;       
;          Rev 1.13   28 Feb 1996 22:40:18   frido
;       Added Optimize.h.
;       
;          Rev 1.12   27 Feb 1996 16:39:52   frido
;       Added device bitmap store/restore.
;       
;          Rev 1.11   26 Feb 1996 23:39:12   frido
;        
;       
;          Rev 1.10   24 Feb 1996 01:22:52   frido
;       Added device bitmaps.
;       
;          Rev 1.9   17 Feb 1996 21:46:26   frido
;       Revamped brushing algorithmn.
;       
;          Rev 1.8   13 Feb 1996 16:51:36   frido
;       Changed the layout of the PDEV structure.
;       Changed the layout of all brush caches.
;       Changed the number of brush caches.
;       
;          Rev 1.7   10 Feb 1996 21:49:46   frido
;       Split monochrome and colored translation cache.
;       
;          Rev 1.6   08 Feb 1996 00:09:58   frido
;       Added i386\ to include files.
;       Changed meaning of cache_slot index.
;
;	   Rev 1.5   05 Feb 1996 17:35:20   frido
;	Added translation cache.
;  
;	   Rev 1.4   03 Feb 1996 12:21:58   frido
;	Added more delays and checks for FIFOs.
;  
;	   Rev 1.3   31 Jan 1996 17:05:52   frido
;	Added more delays in the complex clipping.
;  
;	   Rev 1.2   31 Jan 1996 13:47:36   frido
;	Jumped to EngBitBlt in case of error.
;	Added comments.
;	Added delay in complex clipping.
;	Fixed bug in rectangle clipping.
;  
;	   Rev 1.1   25 Jan 1996 22:45:56   frido
;	Removed bug in complex clipping.
;  
;	   Rev 1.0   25 Jan 1996 22:03:28   frido
;	Initial release.
;	
;===============================================================================

.386
.MODEL FLAT, STDCALL

OPTION	PROLOGUE:None
OPTION	EPILOGUE:None

.NOLIST
INCLUDE i386\Macros.inc
INCLUDE i386\WinNT.inc
INCLUDE Optimize.h
INCLUDE i386\Laguna.inc
INCLUDE SWAT.h		;SWAT optimizations
COMMENT !		;automatic include file dependencies for BUILD.EXE
#include "i386\Macros.inc"
#include "i386\WinNT.inc"
#include "Optimize.h"
#include "i386\Laguna.inc"
#include "SWAT.h"
!
.LIST

IF USE_ASM

.DATA

IF POINTER_SWITCH_ENABLED
EXTERN pointer_switch: DWORD 
ENDIF

EXTERN		ropFlags:BYTE
ROP_PAT		= 1
ROP_SRC		= 2
ROP_DEST	= 4

.CODE

;-------------------------------------------------------------------------------
; Function prototypes.
;-------------------------------------------------------------------------------
i386BitBlt	PROTO		PROC,
		psoTrg		:DWORD,
		psoSrc		:DWORD,
		psoMask		:DWORD,
		pco		:DWORD,
		pxlo		:DWORD,
		prclTrg		:DWORD,
		pptlSrc		:DWORD,
		pptlMask	:DWORD,
		pbo		:DWORD,
		pptlBrush	:DWORD,
		rop4		:DWORD
PuntBitBlt	PROTO		PROC,
		psoTrg		:DWORD,
		psoSrc		:DWORD,
		psoMask		:DWORD,
		pco		:DWORD,
		pxlo		:DWORD,
		prclTrg		:DWORD,
		pptlSrc		:DWORD,
		pptlMask	:DWORD,
		pbo		:DWORD,
		pptlBrush	:DWORD,
		rop4		:DWORD
CacheBrush	PROTO		PROC,
		ppdev		:DWORD,
		pRbrush		:DWORD
CacheDither	PROTO		PROC,
		ppdev		:DWORD,
		pRbrush		:DWORD
CacheMono	PROTO		PROC,
		ppdev		:DWORD,
		pRbrush		:DWORD
Cache4BPP	PROTO		PROC,
		ppdev		:DWORD,
		pRbrush		:DWORD
bCreateScreenFromDib PROTO	PROC,
		ppdev		:DWORD,
		pdsurf		:DWORD
IF SWAT6
StripePatBlt	PROTO		PROC,
		ppdev		:DWORD,
		x		:DWORD,
		y		:DWORD,
		cWidth		:DWORD,
		cHeight		:DWORD
ENDIF
ifdef WINNT_VER40
Sync_w_3d_proc	PROTO		PROC,
		ppdev		:PTR PDEV
endif

;-------------------------------------------------------------------------------
; Stack frame for DrvBitBlt.
;-------------------------------------------------------------------------------
espPTR		=	0
frmPTR		=	0
psoTrg_		TEXTEQU	<DWORD PTR [esp +  4 + espPTR]>
psoSrc_		TEXTEQU	<DWORD PTR [esp +  8 + espPTR]>
psoMask_	TEXTEQU	<DWORD PTR [esp + 12 + espPTR]>
pco_		TEXTEQU	<DWORD PTR [esp + 16 + espPTR]>
pxlo_		TEXTEQU	<DWORD PTR [esp + 20 + espPTR]>
prclTrg_	TEXTEQU	<DWORD PTR [esp + 24 + espPTR]>
pptlSrc_	TEXTEQU	<DWORD PTR [esp + 28 + espPTR]>
pptlMask_	TEXTEQU	<DWORD PTR [esp + 32 + espPTR]>
pbo_		TEXTEQU	<DWORD PTR [esp + 36 + espPTR]>
pptlBrush_	TEXTEQU <DWORD PTR [esp + 40 + espPTR]>
rop4_		TEXTEQU <DWORD PTR [esp + 44 + espPTR]>

;-------------------------------------------------------------------------------
;
; Function:	DrvBitBlt
;
; Description:	Bit blit entry point for DDI.
;
; On entry:	See Windows NT 3.51 DDK.
;
; Returns:	BOOL - TRUE if the function was successful, FALSE otherwise.
;
; Destroyed:	EAX, ECX, EDX.
;
;-------------------------------------------------------------------------------
DrvBitBlt PROC PUBLIC,
	psoTrg		:DWORD,
	psoSrc		:DWORD,
	psoMask		:DWORD,
	pco		:DWORD,
	pxlo		:DWORD,
	prclTrg		:DWORD,
	pptlSrc		:DWORD,
	pptlMask	:DWORD,
	pbo		:DWORD,
	pptlBrush	:DWORD,
	rop4		:DWORD

IF NULL_BITBLT
	cmp	pointer_switch, 0		; Has the cursor been moved to (0,0)?
	je	NotNull			; No - continue on
	mov	eax, 1			; Make GDI think we succeeded
	ret	44			; Return and release stack frame
NotNull:
ENDIF

	mov	ecx, [psoTrg_]		;get pointer to target device
	ASSUME	ecx:PTR SURFOBJ
	mov	eax, [rop4_]		;get ROP4 code
	push_	esi
	push_	ebp
	push_	ebx
	push_	edi
	test	ecx, ecx		;no target?
	jz	Error			;indeed... pass the blit to GDI
	mov	edi, [ecx].dhpdev	;get pointer to physical device
	ASSUME	edi:PTR PDEV

        ;NVH test for bad PDEV pointer.
        test    edi,edi
        jz      Error
        
        
ifdef WINNT_VER40
;SYNC_W_3D macro equivalent
    cmp [edi].NumMCDContexts, 0 ; is MCD alive?
	jle	Sync_end    			; no
    push    eax                 ; save
    push    ecx                 ; save
    push    edi                 ; input to Sync_w_3d_proc
    call Sync_w_3d_proc         
    pop     ecx                 ; restore
    pop     eax                 ; restore
Sync_end:
endif

        ; Turn_PTAG_on
	test	[edi].DriverData.DrvSemaphore, DRVSEM_YUV_ON	
        jz      no_yuv_screen
        push    ecx
	mov	ecx, [edi].pLgREGS_real	; points to the MMIO registers
	mov	DWORD PTR [ecx + grDRAWBLTDEF], 20002000h
	mov	[edi].shadowDRAWBLTDEF, 20002000h
	mov	WORD PTR [ecx + grPTAG], 0FFFFH
        pop     ecx
no_yuv_screen:

	sub	ah, al			;the ROP must be ternary
	jnz	GoSlow			;not a ternary ROP... use the "C" code
	test	edi, edi		;any physical device?
	jz	GoSlow			;nope... use the "C" code
	test	[ropFlags + eax], ROP_SRC
					;does the ROP need a source?
	mov	ebx, [edi].hsurfEng	;get handle of surface
	jnz	GoSlow			;yes it does... use the "C" code
	cmp	[ecx].hsurf, ebx	;blit to screen?
	mov	ebx, [ecx].dhsurf	;get pointer to device bitmap
	ASSUME	ebx:PTR DSURF
	je	@F			;yes
	cmp	[ecx].iType, STYPE_DEVBITMAP
					;blit to device bitmap?
	jne	GoSlow			;no... use the "C" code

                            ; NVH - Save EBX cause we need it 
    push    ebx             ;     if we call bCreateScreenFromDib
	mov 	ebx, [ebx].pso	; get pointer to DIB
	ASSUME	ebx:PTR SURFOBJ
	or	    ebx, ebx		; do we have a DIB? (Is the bitmap on the host?)
    pop     ebx             ; NVH - Restore EBX.
	ASSUME	ebx:PTR DSURF
	jz	@F			        ; No. Device bitmap is already in the frame buffer.

    ; Move the device bitmap back into the frame buffer.
	push_	eax                     ; Save the rop code.
	INVOKE	bCreateScreenFromDib,	; copy the DIB to off-screen
			edi,    ; PPDEV
			ebx     ; PDSURF
	or	eax, eax                    ; Test for success.
	pop_	eax                     ; Restore the ROP code.
    jz	Simulate	; Failed to move device bitmap into frame buffer.
	save_	1

IF 1 ;#1244
@@:	mov	esi, [psoTrg_]		;get target object
	ASSUME	esi:PTR SURFOBJ
	xor	ecx, ecx		;zero x/y offset
	cmp	[esi].iType, STYPE_DEVBITMAP
	mov	esi, [esi].dhsurf
	jne	@F			;destination is screen
	ASSUME	esi:PTR DSURF
	mov	ecx, [esi].packedXY	;get x/y offset of device bitmap
@@:	mov	[edi].ptlOffset.x, ecx	;store packed x/y coordinate in PDEV
ELSE
@@:
ENDIF
	mov	esi, [pbo_]		;get pointer to brush
	ASSUME	esi:PTR BRUSHOBJ
	mov	cl, [ropFlags + eax]	;get ROP flags
	lea	ebx, [eax + 10000000h]	;EBX holds tne DRAWBLTDEF value
	test	cl, ROP_DEST		;test for destination
	jz	@F			;no destination, keep DRAWBLTDEF
	or	ebx, 01000000h		;set destination as frame buffer
@@:	test	cl, ROP_PAT
	mov	ebp, [edi].pLgREGS_real	;EBP points to the MMIO registers
	jz	DoBlit			;the ROP doesn't need a pattern
	mov	eax, [esi].iSolidColor	;get the solid color from the brush
	cmp	eax, -1			;do we have a solid color?
	jne	SolidColor		;yes...
IF 0 ;#ddblt
	cmp	[edi].bDirectDrawInUse, 0
					;is DirectDraw in use
	jne	Error			;
ENDIF
	mov	eax, [esi].pvRbrush	;get the pointer to the realized brush
	or	eax, eax
	jnz	@F			;the brush is already realized...
	INVOKE	BRUSHOBJ_pvGetRbrush,	;realize the brush
			esi
	or	eax, eax
	jz	Error			;we couldn't realize the brush...
@@:	mov	esi, eax		;ESI holds the pointer to the brush
	ASSUME	esi:PTR RBRUSH
	mov	eax, [esi].iType	;get the brush type
	mov	edx, [esi].cache_slot	;get the cache index for this brush
	mov	ecx, [esi].iUniq	;get the unique value from brush
	cmp	eax, BRUSH_4BPP		;dispatch brush
	jb	MonoBrush		;monochrome brush
	je	XlateBrush		;4-bpp brush
	cmp	eax, BRUSH_DITHER
	je	DitherBrush		;dither brush

;-------------------------------------------------------------------------------
; Load the patterned brush.
;-------------------------------------------------------------------------------
	cmp	[edi].Ctable[edx].brushID, esi
					;is it still the same brush?
	je	BrushIsCached		;yes
	INVOKE	CacheBrush,		;cache the brush into off-screen memory
			edi,
			esi
	jmp	BrushIsCached

;-------------------------------------------------------------------------------
; Load the dithered brush.
;-------------------------------------------------------------------------------
DitherBrush:
	cmp	[edi].Dtable[edx].ulColor, ecx
					;does the color still match?
	je	BrushIsCached		;yes...
	INVOKE	CacheDither,		;cache the brush into off-screen memory
			edi,
			esi
	jmp	BrushIsCached

;-------------------------------------------------------------------------------
; Load the 4-bpp brush.
;-------------------------------------------------------------------------------
XlateBrush:
	cmp	[edi].Xtable[edx].iUniq, ecx
					;does the ID still match?
	je	BrushIsCached		;yes...
	INVOKE	Cache4BPP,		;cache the brush into off-screen memory
			edi,
			esi
	jmp	BrushIsCached

;-------------------------------------------------------------------------------
; Load the monochrome brush.
;-------------------------------------------------------------------------------
MonoBrush:
	cmp	[edi].Mtable[edx].iUniq, ecx
					;does the ID still match?
	je	IsMono			;yes...
	INVOKE	CacheMono,		;cache the brush into off-screen memory
			edi,
			esi
IsMono:
	or	ebx, 000D0000h		;monochrome pattern
	mov	eax, [esi].ulForeColor	;copy brush fore- and background colors
	mov	edx, [esi].ulBackColor
	cmp	[edi].shadowFGCOLOR, eax
	je	@F
	REQUIRE	2, edi
	mov	[ebp + grOP_opFGCOLOR], eax
	mov	[edi].shadowFGCOLOR, eax
@@:	cmp	[edi].shadowBGCOLOR, edx
	je	@F
	REQUIRE	2, edi
	mov	[ebp + grOP_opBGCOLOR], edx
	mov	[edi].shadowBGCOLOR, edx
@@:

BrushIsCached:
	mov	ecx, [pptlBrush_]	;get pointer to brush origin
	ASSUME	ecx:PTR POINTL
	or	ebx, 00090000h		;assume colored pattern
	mov	dl, BYTE PTR [ecx].x	;get the brush x origin
	mov	dh, BYTE PTR [ecx].y	;get the brush y origin
IF 1 ;#1244
	add	dl, BYTE PTR [edi].ptlOffset.x[0]
	add	dh, BYTE PTR [edi].ptlOffset.x[2]
ENDIF
	dec	dl			;convert brush origin -x & 7
	dec	dh
	xor	edx, -1
	mov	eax, [esi].cache_xy	;get the off-screen y position of brush
	and	edx, 0707h
	REQUIRE	3, edi
	mov	[ebp + grOP2_opMRDRAM], eax
	mov	[ebp + grPATOFF], dx	;store brush origin
	jmp	DoBlit

;-------------------------------------------------------------------------------
; Load the solid color for the pattern blit.
;-------------------------------------------------------------------------------
SolidColor:
	cmp	[edi].iBytesPerPixel, 2	;test the number of bytes per pixel
	ja	XlateDone		;larger than 2 (24-bpp or 32-bpp)...
	je	@F
	mov	ah, al			;expand the 8-bpp into AX
@@:	mov	ecx, eax		;expand the 16-bpp into EAX
	shl	eax, 16
	or	eax, ecx
XlateDone:
	or	ebx, 00070000h		;source is solid color
	cmp	[edi].shadowBGCOLOR, eax
	je	@F
	REQUIRE	2, edi
	mov	[ebp + grOP_opBGCOLOR], eax;store the solid color in background
	mov	[edi].shadowBGCOLOR, eax
@@:

;-------------------------------------------------------------------------------
; Perform the blitting.
;-------------------------------------------------------------------------------
DoBlit:
        ; Turn off the PTAG
        cmp     BYTE PTR [rop4_], 5ah
        jnz     no_yuv_in_the_world

	test	[edi].DriverData.DrvSemaphore, DRVSEM_YUV_ON	
        jz      no_yuv_in_the_world

;; v-normmi   ebp already set to MMIO address
;;      push    ecx
;;	mov	ecx, [edi].pLgREGS_real	; points to the MMIO registers
	REQUIRE 3, edi
	mov	DWORD PTR [ebp + grDRAWBLTDEF], 20002000h
	mov	[edi].shadowDRAWBLTDEF, 20002000h
	mov	WORD  PTR [ebp + grPTAG], 0  ;if an xor rubber band, turn off ptag mask
;;      pop     ecx

no_yuv_in_the_world:

IF 1 ;#1244
	mov	ecx, [edi].ptlOffset.x	;get packed x/y offset
ELSE
	mov	edi, [psoTrg_]		;get target object
	ASSUME	edi:PTR SURFOBJ
	xor	ecx, ecx		;zero x/y offset
	cmp	[edi].iType, STYPE_DEVBITMAP
	mov	edi, [edi].dhsurf
	jne	@F			;destination is screen
	ASSUME	edi:PTR DSURF
	mov	ecx, [edi].packedXY	;get x/y offset of device bitmap
@@:
ENDIF
	mov	edx, edi		;store pointer to PDEV
	ASSUME	edx:PTR PDEV
	mov	edi, [prclTrg_]		;get pointer to destination rectangle
	ASSUME	edi:PTR RECTL
	mov	esi, [pco_]		;get pointer to clipping object
	ASSUME	esi:PTR CLIPOBJ
	cmp	[edx].shadowDRAWBLTDEF, ebx
	je	@F
	REQUIRE	2, edx
	mov	[ebp + grDRAWBLTDEF], ebx
	mov	[edx].shadowDRAWBLTDEF, ebx
@@:					;store DRAWBLTDEF register

	or	esi, esi		;any clipping object?
	jz	@F			;no...
	cmp	[esi].iDComplexity, DC_TRIVIAL
					;clipping required?
	jne	TestClip		;yes...
IF SWAT6
@@:	mov	eax, [edi].left		;get coordinates
	mov	ebx, [edi].top
	mov	esi, [edi].right
	mov	edi, [edi].bottom
	sub	esi, eax		;build width/height
	sub	edi, ebx
	mov	ebp, ecx		;split x/y offset into ECX(x) EBP(y)
	and	ecx, 0000FFFFh
	shr	ebp, 16
	add	eax, ecx		;add x/y offset
	add	ebx, ebp
	INVOKE	StripePatBlt, edx, eax, ebx, esi, edi
ELSE
@@:	push_	edx			;push ppdev on stack
	mov	ebx, [edi].top		;EBX = prclTrg->top
	mov	edx, [edi].bottom	;EDX = prclTrg->bottom
	mov	eax, [edi].left		;EAX = prclTrg->left
	sub	edx, ebx		;EDX = bottom - top (height)
	shl	ebx, 16			;EBX = top << 16
	mov	esi, [edi].right	;ESI = prclTrg->right
	shl	edx, 16			;EDX = height << 16
	sub	esi, eax		;ESI = right - left (width)
	or	ebx, eax		;EBX = (top << 16) | left
	or	edx, esi		;EDX = (height << 16) | width
	add	ebx, ecx		;add xyOffset
	pop_	edi			;restore ppdev from stack
	REQUIRE	5, edi
	mov	[ebp + grOP0_opRDRAM], ebx
					;do the blit
	mov	[ebp + grBLTEXT_EX], edx
ENDIF
Done:
	pop	edi
	pop	ebx
	pop	ebp
	pop	esi
	mov	eax, 1
	ret	44

TestClip:
	cmp	[esi].iDComplexity, DC_RECT
					;complex clipping required?
	jne	ComplexClip		;yes...
;-------------------------------------------------------------------------------
; We have a clipped rectangle to check with.
;-------------------------------------------------------------------------------
	push	edx			;store pointer to PDEV on stack
	push	ecx			;store xyOffset on stack
	mov	eax, [edi].left		;EAX = prclTrg->left
	mov	ebx, [edi].top		;EBX = prclTrg->top
	mov	ecx, [edi].right	;ECX = prclTrg->right
	mov	edx, [edi].bottom	;EDX = prclTrg->bottom
	cmp	eax, [esi].rclBounds.left
					;EAX = max(pco->rclBounds.left, left)
	jg	@F
	mov	eax, [esi].rclBounds.left
@@:	cmp	ebx, [esi].rclBounds.top;EBX = max(pco->rclBounds.top, top)
	jg	@F
	mov	ebx, [esi].rclBounds.top
@@:	cmp	ecx, [esi].rclBounds.right
					;ECX = min(pco->rclBounds.right, right)
	jl	@F
	mov	ecx, [esi].rclBounds.right
@@:	cmp	edx, [esi].rclBounds.bottom
					;EDX = min(pco->rclBounds.bottom,
	jl	@F			;	bottom)
	mov	edx, [esi].rclBounds.bottom
@@:	pop	esi			;restore xyOffset from stack
	pop	edi			;restore pointer to PDEV from stack
	sub	ecx, eax		;ECX = right - left (width)
	jle	Done
	sub	edx, ebx		;EDX = bottom - top (height)
	jle	Done
IF SWAT6
	mov	ebp, esi		;split x/y offset into ESI(x) EBP(y)
	and	esi, 0000FFFFh
	shr	ebp, 16
	add	eax, esi		;add x/y offset
	add	ebx, ebp
	INVOKE	StripePatBlt, edi, eax, ebx, ecx, edx
ELSE
	shl	ebx, 16			;EBX = top << 16
	shl	edx, 16			;EDX = height << 16
	or	ebx, eax		;EBX = (top << 16) | left
	or	edx, ecx		;EDX = (height << 16) | width
	add	ebx, esi		;add xyOffset
	REQUIRE	5, edi
	mov	[ebp + grOP0_opRDRAM], ebx
					;do the blit
	mov	[ebp + grBLTEXT_EX], edx
ENDIF ; SWAT6
	pop	edi
	pop	ebx
	pop	ebp
	pop	esi
	mov	eax, 1
	ret	44

;-------------------------------------------------------------------------------
; We have a complex clipping object to check with.
;-------------------------------------------------------------------------------
ComplexClip:
	enter_	<8 + SIZEOF(ENUMRECTS8)>;create stack frame
offset_	TEXTEQU <DWORD PTR [esp + 0 + frmPTR]>
pdev_	TEXTEQU <DWORD PTR [esp + 4 + frmPTR]>
enum_	TEXTEQU	<ENUMRECTS8 PTR [esp + 8 + frmPTR]>
	mov	[pdev_], edx		;store offset to PDEV structure
	mov	[offset_], ecx		;store xyOffset
	INVOKE	CLIPOBJ_cEnumStart,	;start enumeration
			esi,
			0,
			CT_RECTANGLES,
			CD_ANY,
			0
if DRIVER_5465 AND HW_CLIPPING AND (NOT SWAT6)
	;; Set up hardware clipping
	mov	eax, [pdev_]
	REQUIRE 6, eax
	add	ebx, CLIPEN
	cmp	[eax].shadowDRAWBLTDEF, ebx
	jne	@F
	mov	[ebp + grDRAWBLTDEF], ebx; use clipping
	mov	[eax].shadowDRAWBLTDEF, ebx
@@:

	mov	ebx, [edi].top		; ebx = prclTrg->top
	shl	ebx, 16			; 
	add	ebx, [edi].left		; prclTrg->left
	add	ebx, [offset_]		; add xyOffset
	mov	[ebp + grOP0_opRDRAM], ebx

	push	eax
	mov	eax, [edi].bottom
	shl	eax, 16
	add	eax, [edi].right
	add	eax, [offset_]		; add xyOffset
	sub	eax, ebx
	mov	[ebp + grBLTEXT], eax
	pop	eax
endif
MoreComplex:
	lea	ebx, [enum_]		;get a batch of rectangles
	INVOKE	CLIPOBJ_bEnum,
			esi,
			SIZEOF(ENUMRECTS8),
			ebx
	cmp	[enum_]._c, 0		;any rectangles at all?
	je	SkipArray		;no
	push_	esi			;store loop registers
	push_	eax
	lea	esi, [enum_].arcl	;load pointer to rectangles
	ASSUME	esi:PTR RECTL
ArrayLoop:
if DRIVER_5465 AND HW_CLIPPING AND (NOT SWAT6)
	mov	eax, [esi].left		;EAX = prcl->left
	mov	ebx, [esi].top		;EBX = prcl->top
	mov	ecx, [esi].right	;ECX = prcl->right
	mov	edx, [esi].bottom	;EDX = prcl->bottom
else
	mov	eax, [edi].left		;EAX = prclTrg->left
	mov	ebx, [edi].top		;EBX = prclTrg->top
	mov	ecx, [edi].right	;ECX = prclTrg->right
	mov	edx, [edi].bottom	;EDX = prclTrg->bottom
	cmp	eax, [esi].left		;EAX = max(prcl->left, left)
	jg	@F
	mov	eax, [esi].left
@@:	cmp	ebx, [esi].top		;EBX = max(prcl->top, top)
	jg	@F
	mov	ebx, [esi].top
@@:	cmp	ecx, [esi].right	;ECX = min(prcl->right, right)
	jl	@F
	mov	ecx, [esi].right
@@:	cmp	edx, [esi].bottom	;EDX = min(prcl->bottom, bottom)
	jl	@F
	mov	edx, [esi].bottom
endif
@@:	sub	ecx, eax		;ECX = right - left (width)
	jle	SkipClip		;nothing to draw
	sub	edx, ebx		;EDX = bottom - top (height)
	jle	SkipClip		;nothing to draw
IF SWAT6
	push_	edi
	mov	ebp, [offset_]		;get x/y offset
	mov	edi, ebp		;split x/y offset into EBP(x) EDI(y)
	and	ebp, 000FFFFh
	shr	edi, 16
	add	eax, ebp		;add x/y offset
	add	ebx, edi
	mov	edi, [pdev_]		;get pointer to PDEV
	INVOKE	StripePatBlt, edi, eax, ebx, ecx, edx
	pop_	edi
ELSE
	shl	ebx, 16			;EBX = top << 16
	shl	edx, 16			;EDX = height << 16
	or	ebx, eax		;EBX = (top << 16) | left
	or	edx, ecx		;EDX = (height << 16) | width
	mov	eax, [pdev_]		;get offset to PDEV structure
	add	ebx, [offset_]		;add xyOffset
	REQUIRE 5, eax
if DRIVER_5465 AND HW_CLIPPING
	mov	[ebp + grCLIPULE], ebx
	add	edx, ebx
					;do the blit
	mov	[ebp + grCLIPLOR_EX], edx
else
	mov	[ebp + grOP0_opRDRAM], ebx
					;do the blit
	mov	[ebp + grBLTEXT_EX], edx
endif
ENDIF ; SWAT6
SkipClip:
	add	esi, SIZEOF(RECTL)	;next clipping rectangle
	dec	[enum_]._c
	jnz	ArrayLoop
	pop_	eax			;restore loop registers
	pop_	esi
	ASSUME	esi:PTR CLIPOBJ
SkipArray:
	or	eax, eax		;are there more rectangles?
	jnz	MoreComplex		;yes
	leave_	<8 + SIZEOF(ENUMRECTS8)>;clean up stack frame
	pop	edi
	pop	ebx
	pop	ebp
	pop	esi
	mov	eax, 1
	ret	44

;-------------------------------------------------------------------------------
; Pass the bit blit to the "C" code.
;-------------------------------------------------------------------------------
GoSlow:
	pop	edi
	pop	ebx
	pop	ebp
	pop	esi
	jmp	i386BitBlt

;-------------------------------------------------------------------------------
; Pass the bit blit to the engine since we can't handle it.
;-------------------------------------------------------------------------------
Simulate:
	load_	1
	mov 	ebx, [ebx].pso	; get pointer to DIB
	mov	[psoTrg_], ebx		;store the new DIB surface

;-------------------------------------------------------------------------------
; Pass the bit blit to the engine since we can't handle it.
;-------------------------------------------------------------------------------
Error:
	pop	edi
	pop	ebx
	pop	ebp
	pop	esi
	jmp	PuntBitBlt

DrvBitBlt ENDP


;*****************************************************************************
;------ YUVBLT ---------------------------------------------------------------
;*****************************************************************************
; pmBLTDEF contents
BD_op2		equ	0001h	; start of OP2 field
BD_op1		equ	0010h	; start of OP1 field
BD_op0		equ	0100h	; start of OP0 field
BD_same		equ	0800h	; OP1/OP2 use same data if set
BD_res		equ	1000h	; start of RES field
BD_ydir		equ	8000h	; y direction bit

; field values for BD_opN, BD_res.
; example:
;	WRITE2	pmBLTDEF,(BD_op1*is_host_mono)+(BD_op2*(is_vram+is_pattern))+(BD_res*is_vram)

is_vram			equ	1
is_host			equ	2	; not for BD_op0
	; for BD_opN
is_sram			equ	0
	; for BD_op1/2
is_sram_mono		equ	4
is_vram_mono		equ	5
is_host_mono		equ	6
is_solid		equ	7
is_pattern		equ	8
	; for BD_res
is_sram0		equ	4
is_sram1		equ	5
is_sram2		equ	6
is_sram12		equ	7
is_mono			equ	4	; already part of is_XXXX_mono above


push_1	MACRO	vArg:REQ
	push	vArg
YUVespPTR = YUVespPTR + 4
YUVfrmPTR = YUVfrmPTR + 4
	ENDM

pop_1	MACRO	vArg:REQ
	pop	vArg
YUVespPTR = YUVespPTR - 4
YUVfrmPTR = YUVfrmPTR - 4
	ENDM

enter_1	MACRO	vArg:REQ
	sub	esp, vArg
YUVespPTR = YUVespPTR + vArg
YUVfrmPTR = 0
	ENDM

leave_1	MACRO	vArg:REQ
	add	esp, vArg
YUVespPTR = YUVespPTR - vArg
	ENDM

;-------------------------------------------------------------------------------
; Stack frame for YUVBlt.
;-------------------------------------------------------------------------------
YUVespPTR   	=	0
YUVfrmPTR   	=	0
YUVpsoTrg_	TEXTEQU	<DWORD PTR [esp +  4 + YUVespPTR]>
YUVpsoSrc_	TEXTEQU	<DWORD PTR [esp +  8 + YUVespPTR]>
YUVpco_		TEXTEQU	<DWORD PTR [esp + 12 + YUVespPTR]>
YUVpxlo_	TEXTEQU	<DWORD PTR [esp + 16 + YUVespPTR]>
YUVprclTrg_	TEXTEQU	<DWORD PTR [esp + 20 + YUVespPTR]>
YUVpptlSrc_	TEXTEQU	<DWORD PTR [esp + 24 + YUVespPTR]>


;-------------------------------------------------------------------------------
;
; Function:	YUVBlt
;
; Description:	Check and perform the YUV BLT
;
; Returns:	BOOL - TRUE if YUV BLT was successful, FALSE otherwise.
;
;-------------------------------------------------------------------------------
YUVBlt PROC PUBLIC,
	YUVpsoTrg	:DWORD,
	YUVpsoSrc	:DWORD,
	YUVpco		:DWORD,
	YUVpxlo		:DWORD,
	YUVprclTrg	:DWORD,
	YUVpptlSrc	:DWORD

        ;-----------------------------------------------------------
        ; Get the PDEV associated with the destination.
	mov	ecx, [YUVpsoTrg_] 	;get pointer to target device
	ASSUME	ecx:PTR SURFOBJ
	test	ecx, ecx		;no source?
        jz      Gen_blt

	mov	ecx, [ecx].dhpdev	;get pointer to physical device
        test    ecx, ecx
        jnz     yuv_blt_str

	mov	ecx, [YUVpsoSrc_] 	;get pointer to source device
	test	ecx, ecx		;no source?
        jz      Gen_blt

	mov	ecx, [ecx].dhpdev	;get pointer to physical device
        test    ecx, ecx
        jz      Gen_blt

        ;-----------------------------------------------------------
        ; Check the source is the frame buffer.
        ; (YUVpsoSrc != NULL) &&                 // Is there a source?
        ; (psoSrc->hsurf == ppdev->hsurfEng)  // Is it the screen?
        ;
yuv_blt_str:
	ASSUME	ecx:PTR PDEV
        mov     edx, ecx
	ASSUME	edx:PTR PDEV

        ; Turn PTAG on
	test	[ecx].DriverData.DrvSemaphore, DRVSEM_YUV_ON	
        jz      yuv_blt_str_1
        push    ecx
	mov	ecx, [ecx].pLgREGS_real	; points to the MMIO registers


;; v-normmi: REQUIRE defaults to ebp for LgREGS, need to specify ecx explicitly
;;	REQUIRE 3, edx
	REQUIRE 3, edx, ecx
	cmp	[edx].shadowDRAWBLTDEF, 20002000h
	je	@F
	mov	DWORD PTR [ecx + grDRAWBLTDEF], 20002000h
	mov	[edx].shadowDRAWBLTDEF, 20002000h
@@:	mov	WORD PTR [ecx + grPTAG], 0FFFFH
        pop     ecx
yuv_blt_str_1:

        ; Determine whether is screen to screen BLT
	mov	eax, [ecx].hsurfEng	;get handle of surface

	mov	ecx, [YUVpsoSrc_] 	;get pointer to source device
	ASSUME	ecx:PTR SURFOBJ
	test	ecx, ecx		;no source?
        jz      Gen_blt

	cmp	[ecx].hsurf, eax	;blit to screen?
        jne     Gen_blt

        ;-----------------------------------------------------------
        ; Check the destination is the frame buffer.
        ; (psoDest != NULL) &&                 // Is there a dest?
        ; (psoDest->hsurf == ppdev->hsurfEng)  // Is it the screen?
	mov	ecx, [YUVpsoTrg_] 	;get pointer to target device
	ASSUME	ecx:PTR SURFOBJ
	test	ecx, ecx		;no source?
        jz      Gen_blt

	cmp	[ecx].hsurf, eax	;blit to screen?
        je      DevBlt_s2s_YUV_Window

Gen_blt:
        mov     eax, 0
        ret     24

;------------------------------------------------------------------------
; DEVBLT_S2S_YUV_WINDOW
;
; A yuv-ly code block to perform a laguna mixed frame buffer window blt.
;
ESPOFFSET       equ     28

DevBlt_s2s_YUV_Window:

	enter_1	<ESPOFFSET>  ;create stack frame
        push_1  ebp
        mov     ebp, esp

        push_1  ebx
        push_1  edi
        push_1  esi

LocptrPDEV_     TEXTEQU <DWORD PTR [ebp + 4]>
LocSrcxOrg_     TEXTEQU <WORD  PTR [ebp + 8]>
LocSrcyOrg_     TEXTEQU <WORD  PTR [ebp + 10]>
LocSrcxExt_     TEXTEQU <WORD  PTR [ebp + 12]>
LocSrcyExt_     TEXTEQU <WORD  PTR [ebp + 14]>
LocYUVLeft_     TEXTEQU <WORD  PTR [ebp + 16]>
LocYUVTop_      TEXTEQU <WORD  PTR [ebp + 18]>
LocYUVXExt_     TEXTEQU <WORD  PTR [ebp + 20]>
LocYUVYExt_     TEXTEQU <WORD  PTR [ebp + 22]>
LocDstxOrg_     TEXTEQU <WORD  PTR [ebp + 24]>
LocDstyOrg_     TEXTEQU <WORD  PTR [ebp + 26]>

        ;Save the argument pointers into local variables
        mov     edi, edx
	ASSUME	edi:PTR PDEV

        mov     [LocptrPDEV_], edi

        ;-----------------------------------------------------------
        ; Test SRC rectange included the YUV rectange
	mov	ecx, [YUVpptlSrc_]	;get pointer to src POINTER struct
	ASSUME	ecx:PTR POINTL
        mov     edx, [ecx].x
        mov     [LocSrcxOrg_], dx
        shl     edx, 16
        mov     eax, [ecx].y
        mov     [LocSrcyOrg_], ax
        mov     dx, ax

        push_1  edx                     ;save the src org

	mov	ecx, [YUVprclTrg_] 	;get pointer to dst RECTL struct
	ASSUME	ecx:PTR RECTL
        mov     eax, [ecx].bottom
        mov     edx, [ecx].top
        mov     [LocDstyOrg_], dx
        sub     eax, edx
        mov     [LocSrcyExt_], ax
        shl     eax, 16
        mov     ebx, eax
        mov     eax, [ecx].right
        mov     edx, [ecx].left
        mov     [LocDstxOrg_], dx
        sub     eax, edx
        mov     [LocSrcxExt_], ax
        mov     bx, ax
        push_1  ebx                     ;save the XY extend

        ;get coords for last known YUV rectangle
        mov     edi, [LocptrPDEV_]
	ASSUME	edi:PTR PDEV

	mov	cx, [edi].DriverData.YUVLeft
        mov     [LocYUVLeft_], cx
	shl	ecx, 16
	mov	cx, [edi].DriverData.YUVTop
        mov     [LocYUVTop_], cx

	mov	dx, [edi].DriverData.YUVYExt
        mov     [LocYUVYExt_], dx
	shl	edx, 16		     	;get yuv extents, x low (for later...)
	mov	dx, [edi].DriverData.YUVXExt
        mov     [LocYUVXExt_], dx

        pop_1   ebx
        pop_1   eax

        ; At this point eax = SRC org, ebx = SRC extend
        ;               ecx = YUV org, edx = YUV extend

	;test for invalidated yuv rectangle...
	test	edx, edx
	jz	normalBLT		;all zero indicates invalid rectangle	

	cmp	ax, cx
	jge	normalBLT		;checked top
	rol	eax, 16
	rol	ecx, 16
	cmp	ax, cx
	jge	normalBLT		;checked left, x values now low

	add	eax, ebx    		;now we have right/bottom sides,
	add	ecx, edx    		;with the x values low
	
	cmp	ax, cx
	jle	normalBLT
	rol	eax, 16
	rol	ecx, 16
	cmp	ax, cx
	jle	normalBLT

        ; Okay... it's time for the show.  We have now established that:
        ; 1 - It's an onscreen to onscreen blt.
        ; 2 - The last YUV rectangle drawn by Direct Draw is completely inside
        ;     of the source rectangle.
        ; 3 - The last YUV rectangle is valid.
        ;
        ; We're going to do seven blts:
        ; 
        ; Five are shown here:
        ;
        ;  --5--
        ;  |   |
        ;  4 3 1
        ;  |   |
        ;  --2--
        ;
        ; Region 3 is the YUV area.
        ;
        ; The two extra blts are dummy ones around the YUV blt, to prevent
        ; screen corruption on the last packets of the surrounding blts.	
        ;
        ; There are four movement cases, depending on the movement direction.
        ; Because the rectangle is broken into five blts, I'm going to
        ; "lead with a corner."
        ; Up and to the right would result in an order of:   5-1-dummy-3-dummy-4-2
        ; Down and to the right would result in an order of: 2-1-dummy-3-dummy-4-5
        ; Down and to the left would result in an order of:  2-4-dummy-3-dummy-1-5
        ; Up and to the left would result in an order of:    5-4-dummy-3-dummy-1-2

        ; make the drawbltdef...
	mov	edi, 00cch + \
        	     ((BD_op0*is_vram+BD_op1*is_vram+BD_res*is_vram) shl 16)

        ; Determine the case, then push the necessary jump offsets on the stack,
        ; in reverse order...	
	push	YUV_exit            	;jump address for when we are done

        mov     ax, [LocSrcxOrg_]            ;get coords for src rect
        shl     eax, 16	
        mov     ax, [LocSrcyOrg_]

        mov     cx, [LocDstxOrg_]            ;get coords for dst rect
        shl     ecx, 16	
        mov     cx, [LocDstyOrg_]

	mov	esi, ecx
	sub	esi, eax 		;get delta from src to dest, useful later.

	cmp	ax, cx
	jle	YUV_going_down

	push	YUV_blt_two	;going up
	mov	ebx, YUV_blt_five
	jmp	YUV_check_left_right

YUV_going_down:
	push	YUV_blt_five	;going down
	mov	ebx, YUV_blt_two	
	or	edi, 80000000h		;turn on blt upside-down-ness

YUV_check_left_right:			;okay, we've handled up/down, how about left/right?
	rol	eax, 16
	rol	ecx, 16
	cmp	ax, cx
	jl	YUV_going_right

	push	YUV_blt_one	;going left
	mov	edx, YUV_blt_four
	jmp	YUV_finish_offsets

YUV_going_right:
	push	YUV_blt_four	 ;going right
	mov	edx, YUV_blt_one

YUV_finish_offsets:
	push	YUV_blt_three
	push	edx	;blt four or one, whichever isn't already on the stack

;no need to add pdevice origins... it's onscreen, eh?

;right now, level cases have the y_dir bit turned on.  if it's a move-left, we need to turn
;it off, so that we don't wind up in the striping code.
	test	edi, 80000000h
	jz	YUV_go_do_it

	rol	eax, 16
	rol	ecx, 16
	cmp	ax, cx
	jnz	YUV_go_do_it	;it's not a perfectly level move...
	
	rol	eax, 16
	rol	ecx, 16
	cmp	ax, cx
	jl	YUV_go_do_it	;if to the right, leave it on.
	and	edi, 7fffffffh	;level move to the left.		

YUV_go_do_it:
	jmp	ebx	;blt two or five, let's rock and roll!

YUV_blt_one:
;src x prime:  yuv left + yuv xext
;src y prime:  yuv top
;x ext prime:  (src x + xext) - (yuv left + yuv xext)
;y ext prime:  yuv yext

	mov	ax, [LocYUVLeft_]
	add	ax, [LocYUVXExt_]
	shl	eax, 16
	mov	ax, [LocYUVTop_] ;source point, y low

        mov	ecx, eax
	add	ecx, esi	;dest point, y low

	mov	dx,  [LocYUVYExt_]
	shl	edx, 16
	mov	dx, [LocSrcxOrg_]    
	add	dx, [LocSrcxExt_]  ;(src x + xext)
	mov	bx, [LocYUVLeft_]
	add	bx, [LocYUVXExt_]  ;(yuv left + yuv xext)
	sub	dx, bx		 ;x ext prime
	jz	yuv_one_done	 ;no right rgb rect, off screen edge

	test	edi, 80000000h	 ;are we in upside down mode?
	jz	@f
	mov	ebx, edx
	rol	ebx, 16		 ;get y extent
	dec	bx
	add	ax, bx
	add	cx, bx		 ;bump srcy prime and desty prime by yext-1
@@:
	cmp	ax, cx
	jnz	@f
	test	edi, 80000000h
	jnz	YUV_i_really_hate_level_moves_to_the_right
@@:
	rol	eax, 16
	rol	ecx, 16

        push	esi
	push	ebp
        mov     esi, [LocptrPDEV_] 
	ASSUME	esi:PTR PDEV
	mov	ebp, [esi].pLgREGS_real	; points to the MMIO registers

	REQUIRE	9, esi
	cmp	[esi].shadowDRAWBLTDEF, edi
	je	@F
	mov	DWORD PTR [ebp + grDRAWBLTDEF], edi
	mov	[esi].shadowDRAWBLTDEF, edi
@@:	mov	DWORD PTR [ebp + grOP0_opRDRAM], ecx
	mov	DWORD PTR [ebp + grOP1_opRDRAM], eax
	mov	DWORD PTR [ebp + grBLTEXT_EX], edx
	pop	ebp
        pop     esi

yuv_one_done:
	pop	eax
	jmp	eax		 ;boing!	

YUV_blt_two:
;src x prime:  known
;src y prime:  yuv top + yuv yext
;x ext prime:  known
;y ext prime:  (src y + yext) - (yuv top + yuv yext)

	mov	ax, [LocSrcxOrg_]
	shl	eax, 16
	mov	ax, [LocYUVTop_]
	add	ax, [LocYUVYExt_] ;source point, y low

	mov	ecx, eax
	add	ecx, esi	 ;dest point, y low

	mov	dx, [LocSrcyOrg_]
	add	dx, [LocSrcyExt_]  ;(src y + yext)
	mov	bx, [LocYUVTop_]
	add	bx, [LocYUVYExt_]  ;(yuv top + yuv yext)
	sub	dx, bx		 ;y ext prime
	jz	yuv_two_done	 ;no bottom rgb rect, off screen
	shl	edx, 16
	mov	dx, [LocSrcxExt_] ;extents, x low

	test	edi, 80000000h	 ;are we in upside down mode?
	jz	@f
	mov	ebx, edx
	rol	ebx, 16		 ;get y extent
	dec	bx
	add	ax, bx
	add	cx, bx			;bump srcy prime and desty prime by yext-1
@@:
	cmp	ax, cx
	jnz	@f
	test	edi, 80000000h
	jnz	YUV_i_really_hate_level_moves_to_the_right
@@:
	rol	eax, 16
	rol	ecx, 16

        push    esi
	push	ebp
        mov     esi, [LocptrPDEV_] 
	ASSUME	esi:PTR PDEV
	mov	ebp, [esi].pLgREGS_real	; points to the MMIO registers

	REQUIRE 9, esi
	cmp	[esi].shadowDRAWBLTDEF, edi
	je	@F
	mov	DWORD PTR [ebp + grDRAWBLTDEF], edi
	mov	[esi].shadowDRAWBLTDEF, edi
@@:	mov	DWORD PTR [ebp + grOP0_opRDRAM], ecx
	mov	DWORD PTR [ebp + grOP1_opRDRAM], eax
	mov	DWORD PTR [ebp + grBLTEXT_EX], edx
	pop	ebp
        pop     esi

yuv_two_done:
	pop	eax
	jmp	eax			;boing!	

YUV_blt_three:                          ;the YUV blt itself...
;just use the yuv coords

;YUV_blt_dummy_off

	mov	ebx, 400000CCh		;bogus move from rdram to sram

        push    esi
	push	ebp
        mov     esi, [LocptrPDEV_] 
	ASSUME	esi:PTR PDEV
	mov	ebp, [esi].pLgREGS_real	;points to the MMIO registers

	REQUIRE	5, esi
	cmp	[esi].shadowDRAWBLTDEF, edi
	je	@F
	mov	DWORD PTR [ebp + grDRAWBLTDEF], edi
	mov	[esi].shadowDRAWBLTDEF, edi
@@:	mov	DWORD PTR [ebp + grBLTEXT_EX], 00010001h
	pop	ebp
        pop     esi

;------

	mov	ax, [LocYUVLeft_]
	shl	eax, 16
	mov	ax, [LocYUVTop_] ;y low

	mov	ecx, eax
	add	ecx, esi	;dest, y low

	mov	dx, [LocYUVYExt_]
	shl	edx, 16
	mov	dx, [LocYUVXExt_]  ;extents, x lot

	test	edi, 80000000h	;are we in upside down mode?
	jz	@f
	mov	ebx, edx
	rol	ebx, 16		;get y extent
	dec	bx
	add	ax, bx
	add	cx, bx		;bump srcy prime and desty prime by yext-1
@@:
	rol	eax, 16
	rol	ecx, 16

	mov	ebx, edi
	or	ebx, 0400h	;do that funky 9th bit thing.

        push    esi
	push	ebp
        mov     esi, [LocptrPDEV_] 
	ASSUME	esi:PTR PDEV
	mov	ebp, [esi].pLgREGS_real	;points to the MMIO registers

	REQUIRE 9, esi
	cmp	[esi].shadowDRAWBLTDEF, ebx
	je	@F
	mov	DWORD PTR [ebp + grDRAWBLTDEF], ebx
	mov	[esi].shadowDRAWBLTDEF, ebx
@@:	mov	DWORD PTR [ebp + grOP0_opRDRAM], ecx
	mov	DWORD PTR [ebp + grOP1_opRDRAM], eax
	mov	DWORD PTR [ebp + grBLTEXT_EX], edx
	pop	ebp
        pop     esi

;YUV_blt_dummy_on

	mov	ebx, 400004CCh		;bogus move from rdram to sram

        push    esi
	push	ebp
        mov     esi, [LocptrPDEV_] 
	ASSUME	esi:PTR PDEV
	mov	ebp, [esi].pLgREGS_real	;points to the MMIO registers

	REQUIRE 5, esi
	cmp	[esi].shadowDRAWBLTDEF, edi
	je	@F
	mov	DWORD PTR [ebp + grDRAWBLTDEF], edi
	mov	[esi].shadowDRAWBLTDEF, edi
@@:	mov	DWORD PTR [ebp + grBLTEXT_EX], 00010001h
	pop	ebp
        pop     esi

;------

	pop	eax
	jmp	eax			;boing!	

YUV_blt_four:
;src x prime:  known
;src y prime:  yuv top
;x ext prime:  yuv left - src x
;y ext prime:  yuv yext

	mov	ax, [LocSrcxOrg_]
	shl	eax, 16
	mov	ax, [LocYUVTop_] ;source point, y low

	mov	ecx, eax
	add	ecx, esi	;dest point, y low

	mov	dx, [LocYUVYExt_]
	shl	edx, 16
	mov	dx, [LocYUVLeft_]
	sub	dx, [LocSrcxOrg_]  ;extents, x low
	jz	yuv_four_done	 ;no left rgb rect, off screen edge

	test	edi, 80000000h	 ;are we in upside down mode?
	jz	@f
	mov	ebx, edx
	rol	ebx, 16		 ;get y extent
	dec	bx
	add	ax, bx
	add	cx, bx		 ;bump srcy prime and desty prime by yext-1
@@:
	cmp	ax, cx
	jnz	@f
	test	edi, 80000000h
	jnz	YUV_i_really_hate_level_moves_to_the_right
@@:
	rol	eax, 16
	rol	ecx, 16

        push    esi
	push	ebp
        mov     esi, [LocptrPDEV_] 
	ASSUME	esi:PTR PDEV
	mov	ebp, [esi].pLgREGS_real	;points to the MMIO registers

	REQUIRE 9, esi
	cmp	[esi].shadowDRAWBLTDEF, edi
	je	@F
	mov	DWORD PTR [ebp + grDRAWBLTDEF], edi
	mov	[esi].shadowDRAWBLTDEF, edi
@@:	mov	DWORD PTR [ebp + grOP0_opRDRAM], ecx
	mov	DWORD PTR [ebp + grOP1_opRDRAM], eax
	mov	DWORD PTR [ebp + grBLTEXT_EX], edx
	pop	ebp
        pop     esi

yuv_four_done:
	pop	eax
	jmp	eax		 ;boing!	

YUV_blt_five:
;src xy prime:  known
;x ext prime :  known
;y ext prime :  yuv top - src top

        mov     ax, [LocSrcxOrg_]      ;;source point, y low
        shl     eax, 16	
        mov     ax, [LocSrcyOrg_]

	mov	ecx, eax
	add	ecx, esi		;dest point, y low

	mov	dx, [LocYUVTop_]
	sub	dx, word ptr [LocSrcyOrg_]
	shl	edx, 16
	mov	dx, [LocSrcxExt_]	;x low

	test	edi, 80000000h		;are we in upside down mode?
	jz	@f
	mov	ebx, edx
	rol	ebx, 16			;get y extent
	dec	bx
	add	ax, bx
	add	cx, bx			;bump srcy prime and desty prime by yext-1
@@:
	cmp	ax, cx
	jnz	@f
	test	edi, 80000000h
	jnz	YUV_i_really_hate_level_moves_to_the_right
@@:
	rol	eax, 16
	rol	ecx, 16

        push    esi
	push	ebp
        mov     esi, [LocptrPDEV_] 
	ASSUME	esi:PTR PDEV
	mov	ebp, [esi].pLgREGS_real	;points to the MMIO registers

	REQUIRE 9, esi
	cmp	[esi].shadowDRAWBLTDEF, edi
	je	@F
	mov	DWORD PTR [ebp + grDRAWBLTDEF], edi
	mov	[esi].shadowDRAWBLTDEF, edi
@@:	mov	DWORD PTR [ebp + grOP0_opRDRAM], ecx
	mov	DWORD PTR [ebp + grOP1_opRDRAM], eax
	mov	DWORD PTR [ebp + grBLTEXT_EX], edx
	pop	ebp
        pop     esi

	pop	eax
	jmp	eax			;boing!	

YUV_i_really_hate_level_moves_to_the_right:

        push    esi
	push	ebp
        mov     esi, [LocptrPDEV_] 
	ASSUME	esi:PTR PDEV
	mov	ebp, [esi].pLgREGS_real	;points to the MMIO registers

	cmp	[esi].shadowDRAWBLTDEF, edi
	je	@F
	REQUIRE 2, esi
	mov	DWORD PTR [ebp + grDRAWBLTDEF], edi
	mov	[esi].shadowDRAWBLTDEF, edi
@@:	pop	ebp
        pop     esi

	; now get ready for inner loop. shift x-coordinates into place

	mov	ebx, ecx
	rol	ebx, 16			;dest, x low

	mov	ecx, eax
	rol	ecx, 16			;src, x low

	; translate the x coordinates

	add	bx, dx
	add	cx, dx

	mov	eax, edx

        ; Because in Win95 LG_SRAM_PIXELS has difference values depends on
        ; the pixel depth.
        ;     LG_SRAM_PIXELS:   32bpp    30
        ;                       24bpp    40
        ;                       16bpp    60
        ;                        8bpp   120
        ;
        ; The following code is the equivalent to
        ;    mov  ax, LG_SRAM_PIXELS	; make it wide as possible
        push    esi
        mov     esi, [LocptrPDEV_] 
	ASSUME	esi:PTR PDEV
	mov	esi, [esi].iBytesPerPixel
        mov     ax, 30
        cmp     esi, 4
        je      got_LG_SRAM_PIXELS
        mov     ax, 40
        cmp     esi, 3
        je      got_LG_SRAM_PIXELS
        mov     ax, 60
        cmp     esi, 2
        je      got_LG_SRAM_PIXELS
        mov     ax, 120
got_LG_SRAM_PIXELS:
        pop     esi

;	mov	ax, LG_SRAM_PIXELS	; make it wide as possible

align   2
YUV_STRIPE_loop:
	cmp	ax, dx			; wider than blit?
	jle	@f			; no, use the actual width
	mov	ax, dx			; load remaining width
@@:
	sub	cx, ax			; offset srcX by width
	sub	bx, ax			; offset dstX by width

        push    esi
	push	ebp
        mov     esi, [LocptrPDEV_] 
	ASSUME	esi:PTR PDEV
	mov	ebp, [esi].pLgREGS_real	;points to the MMIO registers

	REQUIRE 7, esi
	mov	DWORD PTR [ebp + grOP0_opRDRAM], ebx
	mov	DWORD PTR [ebp + grOP1_opRDRAM], ecx
	mov	DWORD PTR [ebp + grBLTEXT_EX], eax
	pop	ebp
        pop     esi

	sub	dx, ax			; update remaining width count
	jnz	YUV_STRIPE_loop		; any pixels left?

	pop	eax
	jmp	eax			; boing!

YUV_exit:

; Good has triumphed over evil... the mixed mode window has moved without flickering.

; We need to update the YUV rectangle location.  It just moved, right?  

	mov	ax, [LocYUVLeft_]
	shl	eax, 16
	mov	ax, [LocYUVTop_]	;source, y low

	add	eax, esi		;dest, y low

        mov     edi, [LocptrPDEV_] 
	mov	[edi].DriverData.YUVTop, ax
	rol	eax, 16
        mov	[edi].DriverData.YUVLeft, ax   	;all better.

        mov     eax, 1                  ; indicate it is YUV exit
        jmp     YUV_ret

normalBLT:
        ; But before we go... invalidate the yuv rect!
        mov     edi, [LocptrPDEV_] 
	mov	[edi].DriverData.YUVXExt, word ptr 0
	mov	[edi].DriverData.YUVYExt, word ptr 0

        mov     eax, 0           ; indicate it is normalBLT

YUV_ret:
        pop_1   esi
        pop_1   edi
        pop_1   ebx
        pop_1   ebp
	leave_1	<ESPOFFSET>      ;clean up stack frame
	ret	24               ;we're done.  it's time to go home.

YUVBlt ENDP

ENDIF ; USE_ASM

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\bltp.h ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1996, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         bltP.h
*
* DESCRIPTION:  Private declarations for DDraw blt code
*
* REVISION HISTORY:
*
* $Log:   X:\log\laguna\ddraw\inc\bltp.h  $
* 
*    Rev 1.11   06 Jan 1998 14:19:44   xcong
* Access pDriverData locally for multi-monitor support.
* 
*    Rev 1.10   03 Oct 1997 14:25:34   RUSSL
* Removed some defines
*
*    Rev 1.9   03 Oct 1997 14:15:58   RUSSL
* Initial changes for use of hw clipped blts
* All changes wrapped in #if ENABLE_CLIPPEDBLTS/#endif blocks and
* ENABLE_CLIPPEDBLTS defaults to 0 (so the code is disabled)
*
*    Rev 1.8   24 Jul 1997 10:02:00   RUSSL
* Added some defines
*
*    Rev 1.7   14 Jul 1997 14:47:28   RUSSL
* Added function prototypes for DIR_DrvStrBlt65 and DL_DrvStrBlt65
*
*    Rev 1.6   03 Apr 1997 15:03:08   RUSSL
* Added PFN_DRVDSTMBLT typedef, global var decl, DIR_DrvDstMBlt and
* DL_DrvDstMBlt function prototypes
*
*    Rev 1.5   26 Mar 1997 13:52:06   RUSSL
* Added PFN_DRVSRCMBLT typedef, global var decl, DIR_DrvSrcMBlt and
* DL_DrvSrcMBlt function prototypes
*
*    Rev 1.4   20 Jan 1997 14:46:40   bennyn
* Moved inline code to ddinline.h
*
*    Rev 1.3   15 Jan 1997 11:06:54   RUSSL
* Added global function ptr vars for Win95
* Moved inline functions from ddblt.c: DupColor, EnoughFifoForBlt & DupZFill
* Added function prototypes for TransparentStretch & StretchColor
*
*    Rev 1.2   05 Dec 1996 08:48:24   SueS
* Added real DD_LOG define for NT.
*
*    Rev 1.1   25 Nov 1996 16:12:42   bennyn
* Added #define DD_LOG for NT
*
*    Rev 1.0   25 Nov 1996 15:04:34   RUSSL
* Initial revision.
*
*    Rev 1.1   01 Nov 1996 13:01:42   RUSSL
* Merge WIN95 & WINNT code for Blt32
*
*    Rev 1.0   01 Nov 1996 09:28:16   BENNYN
* Initial revision.
*
*    Rev 1.0   25 Oct 1996 10:47:50   RUSSL
* Initial revision.
*
***************************************************************************
***************************************************************************/
// If WinNT 3.5 skip all the source code
#if defined WINNT_VER35      // WINNT_VER35

#else


#ifndef _BLTP_H_
#define _BLTP_H_

/***************************************************************************
* D E F I N E S
****************************************************************************/

#ifndef ENABLE_CLIPPEDBLTS
#ifdef WINNT_VER40
#define ENABLE_CLIPPEDBLTS    0
#else // Win95
#define ENABLE_CLIPPEDBLTS    0
#endif
#endif

#define ROP_OP0_copy    0xAA
#define ROP_OP1_copy    0xCC
#define ROP_OP2_copy    0xF0

#ifdef DEBUG
#define INLINE
#else
#define INLINE  __inline
#endif

/***************************************************************************
* T Y P E D E F S
****************************************************************************/

#ifdef WINNT_VER40
   // Note: there's no if LOG_CALLS here because it's not defined yet
   #define DD_LOG(x)      \
   {                      \
      DDFormatLogFile x ; \
      WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);	\
   }

typedef void (*PFN_DELAY9BLT)(struct _PDEV*,struct _DRIVERDATA*,BOOL);
typedef void (*PFN_EDGEFILLBLT)(struct _PDEV*,struct _DRIVERDATA*,int,int,int,int,DWORD,BOOL);
typedef void (*PFN_MEDGEFILLBLT)(struct _PDEV*,struct _DRIVERDATA*,int,int,int,int,DWORD,BOOL);
typedef void (*PFN_DRVDSTBLT)(struct _PDEV*,struct _DRIVERDATA*,DWORD,DWORD,DWORD,DWORD);
typedef void (*PFN_DRVDSTMBLT)(struct _PDEV*,struct _DRIVERDATA*,DWORD,DWORD,DWORD,DWORD);
typedef void (*PFN_DRVSRCBLT)(struct _PDEV*,struct _DRIVERDATA*,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD);
typedef void (*PFN_DRVSRCMBLT)(struct _PDEV*,struct _DRIVERDATA*,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD);
typedef void (*PFN_DRVSTRBLT)(struct _PDEV*,struct _DRIVERDATA*,struct _autoblt_regs*);
typedef void (*PFN_DRVSTRMBLT)(struct _PDEV*,struct _DRIVERDATA*,struct _autoblt_regs*);
typedef void (*PFN_DRVSTRMBLTY)(struct _PDEV*,struct _DRIVERDATA*,struct _autoblt_regs*);
typedef void (*PFN_DRVSTRMBLTX)(struct _PDEV*,struct _DRIVERDATA*,struct _autoblt_regs*);
typedef void (*PFN_DRVSTRBLTY)(struct _PDEV*,struct _DRIVERDATA*,struct _autoblt_regs*);
typedef void (*PFN_DRVSTRBLTX)(struct _PDEV*,struct _DRIVERDATA*,struct _autoblt_regs*);

#if ENABLE_CLIPPEDBLTS
typedef void (*PFN_CLIPPEDDRVDSTBLT)(struct _PDEV*,struct _DRIVERDATA*,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPRECT);
typedef void (*PFN_CLIPPEDDRVDSTMBLT)(struct _PDEV*,struct _DRIVERDATA*,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPRECT);
typedef void (*PFN_CLIPPEDDRVSRCBLT)(struct _PDEV*,struct _DRIVERDATA*,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPRECT);
#endif

#else
typedef void (*PFN_DELAY9BLT)(LPGLOBALDATA,BOOL);
typedef void (*PFN_EDGEFILLBLT)(LPGLOBALDATA,ULONG,ULONG,ULONG,ULONG,DWORD,BOOL);
typedef void (*PFN_MEDGEFILLBLT)(LPGLOBALDATA,ULONG,ULONG,ULONG,ULONG,DWORD,BOOL);
typedef void (*PFN_DRVDSTBLT)(LPGLOBALDATA,DWORD,DWORD,DWORD,DWORD);
typedef void (*PFN_DRVDSTMBLT)(LPGLOBALDATA,DWORD,DWORD,DWORD,DWORD);
typedef void (*PFN_DRVSRCBLT)(LPGLOBALDATA,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD);
typedef void (*PFN_DRVSRCMBLT)(LPGLOBALDATA,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD);
typedef void (*PFN_DRVSTRBLT)(LPGLOBALDATA,autoblt_ptr);
typedef void (*PFN_DRVSTRMBLT)(LPGLOBALDATA,autoblt_ptr);
typedef void (*PFN_DRVSTRMBLTY)(LPGLOBALDATA,autoblt_ptr);
typedef void (*PFN_DRVSTRMBLTX)(LPGLOBALDATA,autoblt_ptr);
typedef void (*PFN_DRVSTRBLTY)(LPGLOBALDATA,autoblt_ptr);
typedef void (*PFN_DRVSTRBLTX)(LPGLOBALDATA,autoblt_ptr);

#if ENABLE_CLIPPEDBLTS
typedef void (*PFN_CLIPPEDDRVDSTBLT)(LPGLOBALDATA,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPRECT);
typedef void (*PFN_CLIPPEDDRVDSTMBLT)(LPGLOBALDATA,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPRECT);
typedef void (*PFN_CLIPPEDDRVSRCBLT)(LPGLOBALDATA,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPRECT);
#endif

#endif  // !WINNT_VER40

#if ENABLE_CLIPPEDBLTS
typedef struct _DDRECTL
{
  REG32   loc;
  REG32   ext;
} DDRECTL;
#endif

/***************************************************************************
* G L O B A L   V A R I A B L E S
****************************************************************************/

#ifndef WINNT_VER40

extern PFN_DELAY9BLT    pfnDelay9BitBlt;
extern PFN_EDGEFILLBLT  pfnEdgeFillBlt;
extern PFN_MEDGEFILLBLT pfnMEdgeFillBlt;
extern PFN_DRVDSTBLT    pfnDrvDstBlt;
extern PFN_DRVDSTMBLT   pfnDrvDstMBlt;
extern PFN_DRVSRCBLT    pfnDrvSrcBlt;
extern PFN_DRVSRCMBLT   pfnDrvSrcMBlt;
extern PFN_DRVSTRBLT    pfnDrvStrBlt;
extern PFN_DRVSTRMBLT   pfnDrvStrMBlt;
extern PFN_DRVSTRMBLTY  pfnDrvStrMBltY;
extern PFN_DRVSTRMBLTX  pfnDrvStrMBltX;
extern PFN_DRVSTRBLTY   pfnDrvStrBltY;
extern PFN_DRVSTRBLTX   pfnDrvStrBltX;

#if ENABLE_CLIPPEDBLTS
extern PFN_CLIPPEDDRVDSTBLT   pfnClippedDrvDstBlt;
extern PFN_CLIPPEDDRVDSTMBLT  pfnClippedDrvDstMBlt;
extern PFN_CLIPPEDDRVSRCBLT   pfnClippedDrvSrcBlt;
#endif

#endif

/***************************************************************************
* F U N C T I O N   P R O T O T Y P E S
****************************************************************************/

// functions in ddblt.c
extern void TransparentStretch
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  int   xDst,
  int   yDst,
  int   cxDst,
  int   cyDst,
  int   xSrc,
  int   ySrc,
  int   cxSrc,
  int   cySrc,
  DWORD ColorKey
);

extern void StretchColor
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  int   xDst,
  int   yDst,
  int   cxDst,
  int   cyDst,
  int   xSrc,
  int   ySrc,
  int   cxSrc,
  int   cySrc,
  DWORD ColorKey
);

// Direct Programming blts in blt_dir.c
extern void DIR_Delay9BitBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  BOOL        ninebit_on
);

extern void DIR_EdgeFillBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  int         xFill,
  int         yFill,
  int         cxFill,
  int         cyFill,
  DWORD       FillValue,
  BOOL        ninebit_on
);

extern void DIR_MEdgeFillBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  int         xFill,
  int         yFill,
  int         cxFill,
  int         cyFill,
  DWORD       FillValue,
  BOOL        ninebit_on
);

extern void DIR_DrvDstBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents
);

extern void DIR_DrvDstMBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents
);

extern void DIR_DrvSrcBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents
);

extern void DIR_DrvSrcMBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents
);

extern void DIR_DrvStrBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

extern void DIR_DrvStrBlt65
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

extern void DIR_DrvStrMBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

extern void DIR_DrvStrMBltY
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

extern void DIR_DrvStrMBltX
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

extern void DIR_DrvStrBltY
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

extern void DIR_DrvStrBltX
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

#if ENABLE_CLIPPEDBLTS
extern void DIR_HWClippedDrvDstBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
);

extern void DIR_HWClippedDrvDstMBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
);

extern void DIR_HWClippedDrvSrcBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwSrcBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
);
extern void DIR_SWClippedDrvDstBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
);

extern void DIR_SWClippedDrvDstMBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
);

extern void DIR_SWClippedDrvSrcBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwSrcBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
);
#endif

// Display List Programming blts in blt_dl.c
extern void DL_Delay9BitBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  BOOL        ninebit_on
);

extern void DL_EdgeFillBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  int         xFill,
  int         yFill,
  int         cxFill,
  int         cyFill,
  DWORD       FillValue,
  BOOL        ninebit_on
);

extern void DL_MEdgeFillBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  int         xFill,
  int         yFill,
  int         cxFill,
  int         cyFill,
  DWORD       FillValue,
  BOOL        ninebit_on
);

extern void DL_DrvDstBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents
);

extern void DL_DrvDstMBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents
);

extern void DL_DrvSrcBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents
);

extern void DL_DrvSrcMBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents
);

extern void DL_DrvStrBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

extern void DL_DrvStrBlt65
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

extern void DL_DrvStrMBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

extern void DL_DrvStrMBltY
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

extern void DL_DrvStrMBltX
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

extern void DL_DrvStrBltY
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

extern void DL_DrvStrBltX
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

#if ENABLE_CLIPPEDBLTS
extern void DL_HWClippedDrvDstBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
);

extern void DL_HWClippedDrvDstMBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
);

extern void DL_HWClippedDrvSrcBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwSrcBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
);
extern void DL_SWClippedDrvDstBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
);

extern void DL_SWClippedDrvDstMBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
);

extern void DL_SWClippedDrvSrcBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwSrcBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
);
#endif

#endif /* _BLTP_H_ */
#endif // WINNT_VER35
/* Don't write below this endif */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\5465bw.h ===
/**********************************************************
* Copyright Cirrus Logic, 1997. All rights reserved.
***********************************************************
*
*  5465BW.H - Bandwidth function header for CL-GD5465
*
***********************************************************
*
*  Author: Rick Tillery
*  Date:   03/20/97
*
*  Revision History:
*  -----------------
*  WHO             WHEN            WHAT/WHY/HOW
*  ---             ----            ------------
*
***********************************************************/
// If WinNT 3.5 skip all the source code
#if defined WINNT_VER35      // WINNT_VER35

#else


#ifndef _5465BW_H
#define _5465BW_H

#ifndef WINNT_VER40
#include <Windows.h>
#endif

#ifdef DEBUGSTRINGS
  #ifndef ODS
extern void __cdecl Msg( LPSTR szFormat, ... );

    #define ODS Msg
  #endif // ODS
#else
  #ifndef ODS
    #define ODS (void)
  #endif // ODS
#endif  // DEBUGSTRINGS

#ifdef _DEBUG
  #define BREAK1  _asm int 01h
  #define BREAK3  _asm int 03h
#else
  #define BREAK1
  #define BREAK3
#endif  // _DEBUG

#include "BW.h"

#include <stdlib.h>


//
// CL-GD5465 specifications
//
#define FIFOWIDTH   64                // Bits

#define BLTFIFOSIZE 32                // QWORDS
#define CAPFIFOSIZE 16                // QWORDS
#define GFXFIFOSIZE 64                // QWORDS
#define VIDFIFOSIZE 32                // QWORDS

#define NORM_RANDOM     14            // MCLKs for random access
#ifndef OLDONE
#define CONC_RANDOM      8            // MCLKs for concurrent random access
#define CONC_HIT_LATENCY (8 - 2)      // MCLKs for concurrent hit minus
#else
#define CONC_RANDOM      10            // MCLKs for concurrent random access
#define CONC_HIT_LATENCY 8             // MCLKs for concurrent hit minus
#endif
#define NORM_HIT_LATENCY (4 - 2)      // MCLKs for hit minus MCLK/VCLK sync
                                      //  MCLK/VCLK sync
#define RIF_SAVINGS      4            // MCLKs savings for sequential randoms
#define SYNCDELAY        3            // MCLKs for synchronization delay to
                                      //  account for VCLK/MCLK sync, state
                                      //  machine and RIF delays
#define DISP_LATENCY     6ul            // Max delay through display arbitraion
                                        //  pipeline.
#define ONEVIDLEVELFILL 2             // MCLKs to fill one video FIFO level
#define ONELEVEL        1
#define ARBSYNC       5               // Arbitration sync (pipelining)

#define CURSORFILL    2
#define BLTFILL       (BLTFIFOSIZE / 2) // MCLKs to burst fill BLT FIFO
#define CAPFILL       (CAPFIFOSIZE / 2) // MCLKs to burst fill capture FIFO
#define VIDFILL       (VIDFIFOSIZE / 2) // MCLKs to burst fill video FIFO
#define VID420FILL    (VIDFIFOSIZE / 4) // 4:2:0 divides FIFO into two

#define REF_XTAL  (14318182ul)        // Crystal reference frequency (Hz)
#define TVO_XTAL  (27000000ul)        // TV-Out reference freq.

typedef struct BWREGS_
{
  BYTE MISCOutput;      // 0x0080
  BYTE VCLK3Denom;      // 0x0084
  BYTE VCLK3Num;        // 0x0088
  WORD DispThrsTiming;  // 0x00EA
  WORD GfVdFormat;      // 0x00C0  
  WORD RIFControl;      // 0x0200
  BYTE BCLK_Mult;       // 0x02C0
  BYTE BCLK_Denom;      // 0x02C1
  WORD Control2;        // 0x0418
  BYTE CR1;             // 0x4  Get Screen Width from these registers
  BYTE CR1E;            // 0x78
}BWREGS, FAR *LPBWREGS;

#ifdef WINNT_VER40
// Be sure to synchronize the following structures with the one
// in i386\Laguna.inc!
//
typedef struct PROGREGS_
{
  WORD VW0_FIFO_THRSH;
  WORD DispThrsTiming;
}PROGREGS, FAR *LPPROGREGS;

#else
typedef struct PROGREGS_
{
  WORD VW0_FIFO_THRSH;
  WORD DispThrsTiming;
}PROGREGS, FAR *LPPROGREGS;
#endif

static int ScaleMultiply(DWORD, DWORD, LPDWORD);
DWORD ChipCalcTileWidth(LPBWREGS);
BOOL ChipCalcMCLK(LPBWREGS, LPDWORD);
BOOL ChipCalcVCLK(LPBWREGS, LPDWORD);
BOOL ChipGetMCLK
(
#ifdef WINNT_VER40
  PDEV  *,
#endif
  LPDWORD
);
BOOL ChipGetVCLK
(
#ifdef WINNT_VER40
  PDEV  *,
#endif
  LPDWORD
);
BOOL ChipIsEnoughBandwidth(LPPROGREGS, LPVIDCONFIG, LPBWREGS);


#endif // _5465BW_H
#endif // WINNT_VER35

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\i386\text.asm ===
;===============================================================================
;
;       $Workfile:   TEXT.ASM  $
;
;       Contents:
;       This file contains the assembly code for the text output routine.
;
;       Copyright (c) 1996, Cirrus Logic, Inc.
;
;       $Log:   //uinac/log/log/laguna/nt35/displays/cl546x/i386/TEXT.ASM  $
; 
;    Rev 1.23   Jun 22 1998 11:07:36   frido
; PDR#11546. Fixed save/restore in clipping BugLoop and also
; the register increments in DrawLoop.
; 
;    Rev 1.22   Mar 04 1998 15:47:14   frido
; Added more shadowing.
; 
;    Rev 1.21   Jan 21 1998 17:12:36   frido
; Added SWAT6 switches to stripe the opaque rectangles.
; 
;    Rev 1.20   Jan 20 1998 11:45:12   frido
; Added shadowing for DRAWBLTDEF and BGCOLOR registers.
; 
;    Rev 1.19   Dec 11 1997 16:02:46   frido
; Oops...
; 
;    Rev 1.18   Dec 11 1997 15:41:18   frido
; PDR#10875: There was a very weird instruction in the DrawGlyph
; routine with clipped non-cacheable glyphs.
; 
;    Rev 1.17   Nov 03 1997 17:41:58   frido
; Added REQUIRE macros.
; 
;    Rev 1.16   08 Aug 1997 17:22:32   FRIDO
; Added SWAT7 switches for 8-bpp hardware bug.
; 
;    Rev 1.15   29 Apr 1997 16:29:40   noelv
; Merged in new SWAT code.
; SWAT: 
; SWAT:    Rev 1.3   24 Apr 1997 10:45:54   frido
; SWAT: NT140b09 merge.
; SWAT: 
; SWAT:    Rev 1.2   19 Apr 1997 16:31:54   frido
; SWAT: Added automatic include file dependencies for BUILD.EXE.
; 
;    Rev 1.14   08 Apr 1997 11:48:24   einkauf
; 
; add call to SYNC_W_3D for MCD coordination
; 
;    Rev 1.13   21 Mar 1997 10:10:20   noelv
; Synced PDEV between C code and ASM code.
; Added macro to log QFREE data.
; Consolidated do_flag and sw_test_flag into a single pointer_switch flag.
; 
;    Rev 1.12   07 Mar 1997 09:41:02   SueS
; Added NULL_TEXTOUT flag to assembly code.  Changed order of include files.
; 
;    Rev 1.11   05 Mar 1997 10:37:32   noelv
; 
; Marked where to put tests for QFREE
; 
;    Rev 1.10   04 Feb 1997 12:19:28   SueS
; Added support for hardware clipping for the 5465.
; 
;    Rev 1.9   20 Aug 1996 11:28:52   noelv
; Bugfix release from Frido 8-19-96
; 
;    Rev 1.0   14 Aug 1996 17:14:38   frido
; Initial revision.
; 
;    Rev 1.8   25 Jul 1996 15:49:52   bennyn
; Modified to support DirectDraw
; 
;    Rev 1.7   03 May 1996 15:24:24   noelv
; 
; Added switch to turn font caching on and off.
; 
;    Rev 1.6   01 May 1996 11:06:46   bennyn
; 
; Modified for NT 4.0
; 
;    Rev 1.5   04 Apr 1996 13:22:18   noelv
; Frido version 26
;       
;          Rev 1.14   28 Mar 1996 23:38:52   frido
;       Fixed drawing of partially left-clipped glyphs.
;       
;          Rev 1.13   04 Mar 1996 20:23:50   frido
;       Cached grCONTROL register.
;       
;          Rev 1.12   29 Feb 1996 20:21:32   frido
;       Fixed some pointer updates.
;       
;          Rev 1.11   28 Feb 1996 22:40:22   frido
;       Added Optimize.h.
;       
;          Rev 1.10   27 Feb 1996 23:52:40   frido
;       Removed bug in DrawGlyph with non clipped characters.
;       
;          Rev 1.9   27 Feb 1996 16:39:54   frido
;       Added device bitmap store/restore.
;       
;          Rev 1.8   24 Feb 1996 01:22:58   frido
;       Added device bitmaps.
;       
;          Rev 1.7   19 Feb 1996 06:24:28   frido
;       Removed extraneous debugging code.
;       Added comments.
;       
;          Rev 1.6   17 Feb 1996 21:46:44   frido
;       Changed FIFO_CHECK into broken_FIFO.
;       
;          Rev 1.5   08 Feb 1996 00:03:54   frido
;       Added i386\ to include files.
;       
;          Rev 1.4   06 Feb 1996 16:13:16   frido
;       Added check for invalid rectangle during clippped opaquing.
;       
;          Rev 1.3   03 Feb 1996 12:17:28   frido
;       Added text clipping.
;       
;          Rev 1.2   25 Jan 1996 22:14:10   frido
;       Removed extraneous push/pop instructions.
;       
;          Rev 1.1   25 Jan 1996 12:42:38   frido
;       Added reinitialization of font cache after mode switch.
;       
;          Rev 1.0   24 Jan 1996 23:13:44   frido
;       Initial release.
;
;===============================================================================

.386
.MODEL FLAT, STDCALL

.NOLIST
INCLUDE i386\Macros.inc
INCLUDE i386\WinNT.inc
INCLUDE i386\Font.inc
INCLUDE Optimize.h
INCLUDE i386\Laguna.inc
INCLUDE Swat.h
COMMENT !		;automatic include file dependencies for BUILD.EXE
#include "i386\Macros.inc"
#include "i386\WinNT.inc"
#include "i386\Font.inc"
#include "Optimize.h"
#include "i386\Laguna.inc"
#include "SWAT.h"
!
.LIST

IF USE_ASM

.DATA

IF POINTER_SWITCH_ENABLED
EXTERN pointer_switch: DWORD 
ENDIF

IF LOG_QFREE
EXTERN QfreeData: DWORD 
ENDIF

 .CODE

;
; Function prototypes.
;
AddToFontCacheChain     PROTO           PROC,
                ppdev           :DWORD,
                pfo             :DWORD,
                pfc             :DWORD
AllocGlyph      PROTO           PROC,
                pfc             :DWORD,
                pgb             :DWORD,
                pgc             :DWORD
i386DrvTextOut  PROTO           PROC,
                pso             :DWORD,
                pstro           :DWORD,
                pfo             :DWORD,
                pco             :DWORD,
                prclExtra       :DWORD,
                prclOpaque      :DWORD,
                pboFore         :DWORD,
                pboOpaque       :DWORD,
                pptlBrush       :DWORD,
                mix             :DWORD
EngTextOut      PROTO           PROC,
                pso             :DWORD,
                pstro           :DWORD,
                pfo             :DWORD,
                pco             :DWORD,
                prclExtra       :DWORD,
                prclOpaque      :DWORD,
                pboFore         :DWORD,
                pboOpaque       :DWORD,
                pptlBrush       :DWORD,
                mix             :DWORD
DrvDestroyFont  PROTO           PROC,
                pfo             :DWORD
bCreateScreenFromDib PROTO      PROC,
                ppdev           :DWORD,
                pdsurf          :DWORD
StripePatBlt	PROTO		PROC,
		ppdev		:DWORD,
		x		:DWORD,
		y		:DWORD,
		nWidth		:DWORD,
		nHeight		:DWORD
ifdef WINNT_VER40
Sync_w_3d_proc  	PROTO		PROC,
		ppdev		:PTR PDEV
endif


;
; Stack frame for DrvTextOut.
;
espPTR          =       0
frmPTR          =       0
pso_            TEXTEQU <DWORD PTR [esp + 4 + espPTR]>
pstro_          TEXTEQU <DWORD PTR [esp + 8 + espPTR]>
pfo_            TEXTEQU <DWORD PTR [esp + 12 + espPTR]>
pco_            TEXTEQU <DWORD PTR [esp + 16 + espPTR]>
prclExtra_      TEXTEQU <DWORD PTR [esp + 20 + espPTR]>
prclOpaque_     TEXTEQU <DWORD PTR [esp + 24 + espPTR]>
pboFore_        TEXTEQU <DWORD PTR [esp + 28 + espPTR]>
pboOpaque_      TEXTEQU <DWORD PTR [esp + 32 + espPTR]>
pptlBrush_      TEXTEQU <DWORD PTR [esp + 36 + espPTR]>
mix_            TEXTEQU <DWORD PTR [esp + 40 + espPTR]>

OPTION  PROLOGUE:None
OPTION  EPILOGUE:None

DrvTextOut PROC PUBLIC,
        pso             :DWORD,
        pstro           :DWORD,
        pfo             :DWORD,
        pco             :DWORD,
        prclExtra       :DWORD,
        prclOpaque      :DWORD,
        pboFore         :DWORD,
        pboOpaque       :DWORD,
        pptlBrush       :DWORD,
        mix             :DWORD

IF NULL_TEXTOUT
	cmp	pointer_switch, 0		; Has the cursor been moved to (0,0)?
	je	NotNull			; No - continue on
	mov	eax, 1			; Make GDI think we succeeded
	ret	40			; Return and release stack frame
NotNull:
ENDIF

        push_   edi
        mov     edi, [pfo_]             ;EDI holds pointer to font
        ASSUME  edi:PTR FONTOBJ
        mov     ecx, [pso_]             ;ECX holds pointer to destination
        ASSUME  ecx:PTR SURFOBJ
        push_   esi
        push_   ebp
        push_   ebx
        save_   1                       ;save current stack state
        mov     edx, [pstro_]           ;EDX holds pointer to string
        ASSUME  edx:PTR STROBJ
        mov     ebx, [ecx].dhsurf       ;get the pointer to the device bitmap
        ASSUME  ebx:PTR DSURF
        mov     esi, [edi].pvConsumer   ;ESI holds pointer to font cache
        ASSUME  esi:PTR FONTCACHE
        cmp     [ecx].iType, STYPE_DEVBITMAP
                                        ;are we drawing in a device bitmap?
        mov     ebp, [ecx].dhpdev       ;EBP holds pointer to device
        ASSUME  ebp:PTR PDEV
        jne     @F                      ;no

ifdef WINNT_VER40
;SYNC_W_3D macro equivalent
    cmp [ebp].NumMCDContexts, 0 ; is MCD alive?
	jle	Sync_end    			; no
    push    ecx                 ; save
    push    edx                 ; save
    push    ebp                 ; input to Sync_w_3d_proc
    call Sync_w_3d_proc         
    pop     edx                 ; restore
    pop     ecx                 ; restore
Sync_end:
endif

        mov     ebx, [ebx].pso          ;get the handle to the DIB
        or      ebx, ebx                ;is the device bitmap a DIB?
        jz      @F                      ;no
        INVOKE  bCreateScreenFromDib,   ;copy the DIB to off-screen
                        ebp,
                        ebx
        or      eax, eax
        jz      Simulate                ;failure
@@:     cmp     [ebp].UseFontCache, 0   ;Is font caching enabled?
        je      FontNotCached           ;no, use C code.
        or      esi, esi                ;is font cache allocated?
        jz      NewFont                 ;no, new font
        cmp     esi, -1                 ;is font uncacheable?
        je      FontNotCached           ;yes
        cmp     [esi].ppdev, ebp        ;font cached in current device?
        mov     eax, [ebp].ulFontCount
        jne     FontNotCached           ;no
        cmp     [esi].ulFontCount, eax  ;device count still matches?
        jne     DestroyFont             ;no, recache font

;
; We have a font that is still cached.
;
FontCached:
        mov     ebx, [pco_]             ;EBX holds pointer to clip object
        ASSUME  ebx:PTR CLIPOBJ
        mov     eax, [pboFore_]         ;EAX has foreground brush
        ASSUME  eax:PTR BRUSHOBJ
        mov     edx, [pboOpaque_]       ;EDX has background brush
        ASSUME  edx:PTR BRUSHOBJ
        or      ebx, ebx                ;clip object present?
        jz      @F                      ;no
        cmp     [ebx].iDComplexity, DC_TRIVIAL
                                        ;trivial clipping?
        jne     CheckClipping           ;no, check for clipping
@@:     cmp     [ebp].iBytesPerPixel, 2
	mov	ebx, ebp		;store pointer to PDEV structure
        mov     ebp, [ebp].pLgREGS_real ;EBP holds pointer to Laguna registers
        ASSUME  ebp:NOTHING
        mov     eax, [eax].iSolidColor  ;get foreground color
        ASSUME  eax:NOTHING
        mov     edx, [edx].iSolidColor  ;get background color
        ASSUME  edx:NOTHING
        ja      @F                      ;no color translation needed
        je      Xlate16                 ;16-bpp
        mov     ah, al                  ;expand 8-bpp into 16-bit
        mov     dh, dl
Xlate16:
        mov     ecx, eax                ;expand 16-bpp into 32-bit
        shl     eax, 16
        mov     esi, edx
        shl     edx, 16
        or      eax, ecx
        or      edx, esi

@@:     ASSUME	ebx:PTR PDEV
	REQUIRE	4, ebx
	cmp	[ebx].shadowFGCOLOR, eax
	je	@F
	mov     [ebp + grOP_opFGCOLOR], eax
	mov	[ebx].shadowFGCOLOR, eax;store foreground color in Laguna
@@:	mov     eax, [pso_]             ;EAX holds pointer to destination
        ASSUME  eax:PTR SURFOBJ
	cmp	[ebx].shadowBGCOLOR, edx
	je	@F
        mov     [ebp + grOP_opBGCOLOR], edx
	mov	[ebx].shadowBGCOLOR, edx;store background color in Laguna
@@:	xor     edx, edx                ;zero x/y offset
        cmp     [eax].iType, STYPE_DEVBITMAP
        mov     eax, [eax].dhsurf       ;get pointer to device bitmap
        ASSUME  eax:PTR DSURF
        jne     @F                      ;target is not a device bitmap
        mov     edx, [eax].packedXY     ;get packed x/y offset of device bitmap
@@:     mov     eax, [prclOpaque_]      ;EAX holds opaquing rectangle
        ASSUME  eax:PTR RECTL
        mov     [mix_], edx             ;store x/y offset into mix variable
        test    eax, eax                ;opaquing rectangle present?
        jz      SkipOpaque              ;no
	ASSUME	ebx:PTR PDEV
        REQUIRE 7, ebx
	cmp	[ebx].shadowDRAWBLTDEF, SOLID_COLOR_FILL
	je	@F
        mov     DWORD PTR [ebp + grDRAWBLTDEF], SOLID_COLOR_FILL
	mov	[ebx].shadowDRAWBLTDEF, SOLID_COLOR_FILL
@@:					;use solid background fill
        mov     edi, [eax].left         ;get rectangle coordinates
        mov     ecx, [eax].top
        mov     edx, [eax].right
        mov     eax, [eax].bottom
        sub     edx, edi                ;convert to size
        sub     eax, ecx
IF SWAT6
	push_	ebx
	mov	ebx, [mix_]
	and	ebx, 0000FFFFh
	add	edi, ebx
	mov	ebx, [mix_]
	shr	ebx, 16
	add	ecx, ebx
	pop_	ebx
	INVOKE	StripePatBlt, ebx, edi, ecx, edx, eax
ELSE
        shl     ecx, 16                 ;pack x/y
        add     edi, [mix_]             ;add x/y offset to left
        shl     eax, 16
        add     ecx, edi
        or      eax, edx
        mov     [ebp + grOP0_opRDRAM], ecx
                                        ;draw rectangle
        mov     [ebp + grBLTEXT_EX], eax
ENDIF

SkipOpaque:
        mov     ax, [ebp + grCONTROL]
        mov     edi, [pfo_]             ;EDI holds pointer to font
        ASSUME  edi:PTR FONTOBJ
        or      eax, SWIZ_CNTL          ;enable bit mirroring
	cmp	[ebx].shadowDRAWBLTDEF, CACHE_EXPAND_XPAR
	je	@F
        mov     DWORD PTR [ebp + grDRAWBLTDEF], CACHE_EXPAND_XPAR
	mov	[ebx].shadowDRAWBLTDEF, CACHE_EXPAND_XPAR
@@:					;expand characters from cache
        mov     [ebp + grCONTROL], ax
	mov	edx, ebx		;store pointer to PDEV structure
        mov     ebx, [pstro_]           ;EBX holds pointer to string
        ASSUME  ebx:PTR STROBJ
        mov     edi, [edi].pvConsumer   ;EDI holds pointer to font cache
        ASSUME  edi:PTR FONTCACHE

;
; We are now ready to start the main font cache loop. We first determine if we
; need to enumerate the GLYPHPOS arrays or not. Then we start the main loop,
; which is a very short simple loop. For each glyph that falls in the caching
; range, we check if the glyph is cached. If so, we just copy the glyph from
; off-screen memory. If the glyph is not cached, we check if it is small enough
; to fit in a tile and if so, we cache it off-screen and than copy itto its
; destination. If the glyph is too large, we draw it directly on screen.
;
        enter_  16                      ;create stack frame
bMoreGlyphs_    TEXTEQU <DWORD PTR [esp + 0 + frmPTR]>
ulCharInc_      TEXTEQU <DWORD PTR [esp + 4 + frmPTR]>
dwControl_      TEXTEQU <DWORD PTR [esp + 8 + frmPTR]>
pdev_		TEXTEQU <DWORD PTR [esp + 12 + frmPTR]>
        save_   2                       ;store state of stack
	mov	[pdev_], edx

        mov     [dwControl_], eax
        mov     eax, [ebx].ulCharInc    ;copy ulCharInc from string object
        cmp     [ebx].pgp, 0
        mov     [ulCharInc_], eax
        je      Enumerate               ;there is more than one array
        mov     ecx, [ebx].cGlyphs      ;get number of glyphs to draw
        mov     ebx, [ebx].pgp          ;get pointer to glyph position array
        ASSUME  ebx:PTR GLYPHPOS
        mov     [bMoreGlyphs_], 0       ;no more glyphs to enumerate

MainLoop:
        or      ecx, ecx                ;any glyphs to draw?
        je      SkipLoop                ;no
        mov     eax, [ebx].ptl.x        ;get coordinates of first glyph
        mov     edx, [ebx].ptl.y
GlyphLoop:
        push_   ecx
        mov     ecx, [ebx].hg           ;get the glyph handle
        cmp     [ulCharInc_], 0         ;fixed font?
        jne     @F                      ;no
        mov     eax, [ebx].ptl.x        ;get coordinates for glyph
        mov     edx, [ebx].ptl.y
@@:     shl     ecx, 4                  ;build index into font cache array
        cmp     ecx, MAX_GLYPHS * 16    ;glyph out of range?
        jnl     DrawGlyph               ;yes, draw it directly
        save_   9
        mov     esi, [edi + ecx*1].aGlyphs.xyPos
                                        ;get off-screen location of glyph
        lea     ecx, [edi + ecx*1].aGlyphs
                                        ;load address of cache slot
        ASSUME  ecx:PTR GLYPHCACHE
        or      esi, esi                ;is the glyph already cached?
        jnz     @F                      ;yes
        mov     esi, [ebx].pgdf         ;cache the glyph
        ASSUME  esi:PTR GLYPHDEF
        push    eax
        push    edx
        push    ecx
        INVOKE  AllocGlyph,
                        edi,
                        [esi].pgb,
                        ecx
        pop     ecx
        pop     edx
        pop     eax
        mov     esi, [ecx].xyPos        ;get off-screen location of glyph
@@:     cmp     [ecx].cSize, 0          ;is this an empty glyph?
        jl      DrawGlyph               ;no, in fact it is non-cacheable
        jz      Increment               ;yes, skip it
        push_   edx
        push_   eax
        add     edx, [ecx].ptlOrigin.y  ;add origin of glyph to coordinates
        add     eax, [ecx].ptlOrigin.x
        shl     edx, 16                 ;pack coordinates
	or	edx, eax
	mov	eax, [pdev_]
	ASSUME	eax:PTR PDEV
        REQUIRE 7, eax
        mov     [ebp + grOP2_opMRDRAM], esi
                                        ;copy the glyph from off-screen memory
        mov     esi, [mix_]             ;get x/y offset
        mov     eax, [ecx].cSize
        add     edx, esi                ;add x/y offset
        mov     [ebp + grOP0_opRDRAM], edx
        mov     [ebp + grBLTEXT_EX], eax
        pop_    eax
        pop_    edx

Increment:
        add     eax, [ulCharInc_]       ;add the x-increment
        pop_    ecx
        add     ebx, SIZEOF GLYPHPOS    ;next glyph
        dec     ecx
        jnz     GlyphLoop
SkipLoop:
        cmp     [bMoreGlyphs_], 0       ;more arrays to draw?
        jne     Enumerate               ;yes
        mov     ecx, [dwControl_]
        leave_  16                      ;remove stack frame
        and     ecx, NOT SWIZ_CNTL      ;reset bit mirroring
        mov     eax, 1                  ;return TRUE
        mov     [ebp + grCONTROL], cx
        pop_    ebx
        pop_    ebp
        pop_    esi
        pop_    edi
        ret     40

;
; Draw the glyph directly to screen.
;
DrawGlyph:
        load_   9
        mov     esi, [ebx].pgdf         ;ESI holds pointer to GLYPHDEF
        ASSUME  esi:PTR GLYPHDEF
        push_   eax
        push_   edx
        mov     esi, [esi].pgb          ;ESI holds pointer to GLYPHBITS
        ASSUME  esi:PTR GLYPHBITS
        push_   edi
	push_	ebx
	mov	ebx, [pdev_]
	ASSUME	ebx:PTR PDEV

        mov     ecx, [esi].sizlBitmap._cy
                                        ;get height of glyph
        add     edx, [esi].ptlOrigin.y  ;add y-origin to coordinate
        shl     ecx, 16 
        jz      SkipDraw                ;if zero, skip
        shl     edx, 16
        add     eax, [esi].ptlOrigin.x  ;add x-origin to coordinate
        mov     edi, [esi].sizlBitmap._cx
                                        ;get width of glyph
        or      edx, eax
        or      ecx, edi
        add     edx, [mix_]             ;add x/y offset
        lea     esi, [esi].aj           ;ESI points to bits
        ASSUME  esi:NOTHING

IF SWAT7
	add	edi, 7			;convert width into byte delta
	REQUIRE 9, ebx
	cmp	[ebx].shadowDRAWBLTDEF, TEXT_EXPAND_XPAR
	je	@F
        mov     DWORD PTR [ebp + grDRAWBLTDEF], TEXT_EXPAND_XPAR
	mov	[ebx].shadowDRAWBLTDEF, TEXT_EXPAND_XPAR
@@:	shr	edi, 3
        mov     DWORD PTR [ebp + grOP2_opMRDRAM], 0
	cmp	cx, 64			;bug when doing 64 < width < 128
	jbe	SkipBug
	cmp	cx, 128
	jae	SkipBug
	push	ecx			;save registers
	push	edx
	push	esi
	mov	cx, 64			;1st passs, 64 pixels
	mov	[ebp + grOP0_opRDRAM], edx
	mov	[ebp + grBLTEXT_EX], ecx
	shr	ecx, 16			;get height into ECX
@@:	REQUIRE	2, ebx
	mov	eax, [esi][0]		;transfer 64 pixels
	mov	edx, [esi][4]
	mov	[ebp + grHOSTDATA][0], eax
	mov	[ebp + grHOSTDATA][4], edx
	add	esi, edi		;next glyph line
	dec	ecx
	jnz	@B
	pop	esi
	pop	edx
	add	esi, 64 / 8		;8 bytes already done
	pop	ecx
	add	edx, 64			;offset to next 64 pixels
	sub	ecx, 64
SkipBug:
	REQUIRE	5, ebx
        mov     [ebp + grOP0_opRDRAM], edx
	mov	edx, ecx		;get number of pixels into EDX
        mov     [ebp + grBLTEXT_EX], ecx
	and	edx, 0000FFFFh
        shr     ecx, 16                 ;get height back
	mov	ebx, [pdev_]
	ASSUME	ebx:PTR PDEV
        cmp     edx, 8                  ;test width
        jbe	Draw1Byte               ;glyph located in 1 byte
        cmp     edx, 16
        jbe	Draw2Bytes              ;glyph located in 2 bytes
        cmp     edx, 24
        jbe	Draw3Bytes              ;glyph located in 3 bytes
        cmp     edx, 32
        jbe	Draw4Bytes              ;glyph located in 4 bytes

DrawLoop:
	push	edx			;store pixel count
        push	esi			;store current byte offset
@@:     mov     eax, [esi]              ;get 4 bytes
        add     esi, 4
        REQUIRE	1, ebx
	mov     [ebp + grHOSTDATA], eax ;draw them
        sub     edx, 32			;32 pixels done
        jg      @B                      ;still more bytes to copy
	pop	esi			;restore byte offset
	pop	edx			;restore pixel count
	add	esi, edi		;next glyph row
        dec     ecx
        jnz     DrawLoop
        jmp     SkipDraw

Draw1Byte:
	mov     al, [esi]               ;get byte from glyph
        add	esi, edi
        REQUIRE	1, ebx
        mov     [ebp + grHOSTDATA], eax ;draw it
        dec     ecx                     ;next glyph row
        jnz     Draw1Byte
        jmp     SkipDraw

Draw2Bytes:
	mov     ax, [esi]               ;get 2 bytes from glyph
        add	esi, edi
	REQUIRE	1, ebx
        mov     [ebp + grHOSTDATA], eax ;draw them
        dec     ecx                     ;next glyph row
        jnz     Draw2Bytes
        jmp     SkipDraw

Draw4Bytes:
	mov     eax, [esi]              ;get 4 bytes from glyph
        add     esi, edi
	REQUIRE	1, ebx
        mov     [ebp + grHOSTDATA], eax ;draw them
        dec     ecx                     ;next glyph row
        jnz     Draw4Bytes
        jmp     SkipDraw

Draw3Bytes:
	mov	al, [esi + 2]		;get 3 bytes from glyph
	shl	eax, 16
	mov	ax, [esi + 0]
        add     esi, edi
	REQUIRE	1, ebx
        mov     [ebp + grHOSTDATA], eax	;draw them
	dec	ecx			;next glyph row
        jnz     Draw3Bytes
ELSE
	REQUIRE	7, ebx
	cmp	[ebx].shadowDRAWBLTDEF, TEXT_EXPAND_XPAR
	je	@F
        mov     DWORD PTR [ebp + grDRAWBLTDEF], TEXT_EXPAND_XPAR
	mov	[ebx].shadowDRAWBLTDEF, TEXT_EXPAND_XPAR
@@:					;expand glyph on-screen
        mov     [ebp + grOP0_opRDRAM], edx
        mov     DWORD PTR [ebp + grOP2_opMRDRAM], 0
        mov     [ebp + grBLTEXT_EX], ecx
        shr     ecx, 16                 ;get height back
        cmp     edi, 8                  ;test width
        jbe     Draw1Byte               ;glyph located in 1 byte
        cmp     edi, 16
        jbe     Draw2Bytes              ;glyph located in 2 bytes
        cmp     edi, 24
        jbe     Draw3Bytes              ;glyph located in 3 bytes
        cmp     edi, 32
        jbe     Draw4Bytes              ;glyph located in 4 bytes

        add     edi, 7                  ;byte adjust glyph width
        shr     edi, 3
DrawLoop:
        mov     edx, edi                ;get width
@@:     mov     eax, [esi]              ;get 4 bytes
        add     esi, 4
	REQUIRE	1, ebx
        mov     [ebp + grHOSTDATA], eax ;draw them
        sub     edx, 4                  ;4 bytes done
        jg      @B                      ;still more bytes to copy
        add     esi, edx                ;next glyph row
        dec     ecx
        jnz     DrawLoop
        jmp     SkipDraw

Draw1Byte:
@@:	mov     al, [esi]               ;get byte from glyph
        inc     esi
	REQUIRE 1, ebx
        mov     [ebp + grHOSTDATA], eax ;draw it
        dec     ecx                     ;next glyph row
        jnz     @B
        jmp     SkipDraw

Draw2Bytes:
@@:	mov     ax, [esi]               ;get 2 bytes from glyph
        add     esi, 2
	REQUIRE 1, ebx
        mov     [ebp + grHOSTDATA], eax ;draw them
        dec     ecx                     ;next glyph row
        jnz     @B
        jmp     SkipDraw

Draw4Bytes:
@@:	mov     eax, [esi]              ;get 4 bytes from glyph
        add     esi, 4
	REQUIRE	1, ebx
        mov     [ebp + grHOSTDATA], eax ;draw them
        dec     ecx                     ;next glyph row
        jnz     @B
        jmp     SkipDraw

Draw3Bytes:
@@:	mov     eax, [esi]              ;eax = 3210
        add     esi, 4
	REQUIRE 4, ebx
        mov     [ebp + grHOSTDATA], eax ;store 210
        dec     ecx
        jz      SkipDraw
        mov     edx, [esi]              ;edx = 7654
        add     esi, 4
        shrd    eax, edx, 24            ;eax = 6543
        dec     ecx
        mov     [ebp + grHOSTDATA], eax ;store 543
        jz      SkipDraw
        mov     eax, [esi]              ;eax = ba98
        add     esi, 4
        shrd    edx, eax, 16            ;edx = 9876
        dec     ecx
        mov     [ebp + grHOSTDATA], edx ;store 876
        jz      SkipDraw
        shr     eax, 8                  ;eax = xba9
        dec     ecx
        mov     [ebp + grHOSTDATA], eax ;store ba9
        jnz     @B
ENDIF
SkipDraw:
	REQUIRE	2, ebx
	cmp	[ebx].shadowDRAWBLTDEF, CACHE_EXPAND_XPAR
	je	@F
        mov     DWORD PTR [ebp + grDRAWBLTDEF], CACHE_EXPAND_XPAR
	mov	[ebx].shadowDRAWBLTDEF, CACHE_EXPAND_XPAR
@@:					;enable off-screen expansion
        pop_    ebx
        pop_    edi
        pop_    edx
        pop_    eax
        jmp     Increment

;
; Enumerate an array of glyphs.
;
Enumerate:
        load_   2
        push_   eax                     ;create room on stack for return
        push_   eax                     ;  parameters
        mov     eax, [pstro_]           ;get pointer to STROBJ
        mov     ebx, esp                ;ebx points to pgp parameter
        lea     ecx, [esp + 4]          ;ecx points to c parameter
        INVOKE  STROBJ_bEnum,
                        eax,
                        ecx,
                        ebx
        pop_    ebx                     ;load pgp from stack
        pop_    ecx                     ;load c from stack
        mov     [bMoreGlyphs_], eax
        jmp     MainLoop

;
; Remove the current font from the cache. EDI holds the pointer to the font
; object.
;
DestroyFont:
        load_   1                       ;retrieve stack state on entry
        INVOKE  DrvDestroyFont,         ;destroy font
                        edi
        jmp     @F
;
; We have a new font. See if the font fits into an off-screen tile by comparing
; the bounding box to 150% of the tile size. We use 150% since we might still
; be able to cache the lowercase glyphs of larger fonts.
;
NewFont:
        ASSUME  edx:PTR STROBJ
        mov     ebx, [edx].rclBkGround.bottom
                                        ;get height of font
        sub     ebx, [edx].rclBkGround.top
        cmp     ebx, LINES_PER_TILE * 3 / 2
                                        ;test if small enough to fit in tile
        jg      AbortFont               ;too big

ifdef WINNT_VER40
@@:     INVOKE  EngAllocMem,            ;allocate memory for font cache
                        FL_ZERO_MEMORY,
                        SIZEOF FONTCACHE,
                        'XGLC'
else
@@:     INVOKE  LocalAlloc,             ;allocate memory for font cache
                        LMEM_FIXED OR LMEM_ZEROINIT,
                        SIZEOF FONTCACHE
endif

        ASSUME  eax:PTR FONTCACHE
        or      eax, eax
        jz      AbortFont               ;error, not enough memory
        ASSUME  edi:PTR FONTOBJ
        mov     [edi].pvConsumer, eax   ;store pointer to font cache in font
        ASSUME  ebp:PTR PDEV
        mov     ebx, [ebp].ulFontCount
        mov     [eax].ppdev, ebp        ;store pointer to device
        mov     [eax].ulFontCount, ebx  ;store current device count
        INVOKE  AddToFontCacheChain,
                        ebp,
                        edi,
                        eax
        jmp     FontCached

AbortFont:
        ASSUME  edi:PTR FONTOBJ
        mov     [edi].pvConsumer, -1    ;mark the font as uncacheable
FontNotCached:
        pop_    ebx                     ;pass through non-cache font handler
        pop_    ebp
        pop_    esi
        pop_    edi
        jmp     i386DrvTextOut

Simulate:
        load_   1
        mov     [pso_], ebx             ;save new surface object
        pop     ebx                     ;pass through engine
        pop     ebp
        pop     esi
        pop     edi
        jmp     EngTextOut
;
; We only support simple rectangle clipping in assembly.
;
CheckClipping:
        ASSUME  ebx:PTR CLIPOBJ
        cmp     [ebx].iDComplexity, DC_RECT
        jne     FontNotCached
DrvTextOut ENDP

;
; Right now, EAX holds the foreground brush, EBX points to the clipping object,
; EDX holds the background brush, and EBP points to the device.
;
ClipTextOut PROC
        ASSUME  eax:PTR BRUSHOBJ
	ASSUME	ebx:PTR CLIPOBJ
        ASSUME  edx:PTR BRUSHOBJ
        ASSUME  ebp:PTR PDEV

        load_   1
        cmp     [ebp].iBytesPerPixel, 2
	push_	ebp
        mov     ebp, [ebp].pLgREGS_real ;EBP points to Laguna registers
        ASSUME  ebp:NOTHING
        mov     eax, [eax].iSolidColor  ;get foreground color
        ASSUME  eax:NOTHING
        mov     edx, [edx].iSolidColor  ;get background color
        ASSUME  edx:NOTHING
        ja      @F
        je      Xlate16
        mov     ah, al                  ;expand 8-bpp into 16-bit
        mov     dh, dl
Xlate16:
        mov     ecx, eax                ;expand 16-bpp into 32-bit
        shl     eax, 16
        mov     esi, edx
        shl     edx, 16
        or      eax, ecx
        or      edx, esi
@@:     pop_	ecx
	ASSUME	ecx:PTR PDEV
	REQUIRE	4, ecx
	cmp	[ecx].shadowFGCOLOR, eax
	je	@F
        mov     [ebp + grOP_opFGCOLOR], eax
	mov	[ecx].shadowFGCOLOR, eax;store foreground color
@@:	mov     eax, [pso_]             ;get pointer to destination
        ASSUME  eax:PTR SURFOBJ
	cmp	[ecx].shadowBGCOLOR, edx
	je	@F
        mov     [ebp + grOP_opBGCOLOR], edx
	mov	[ecx].shadowBGCOLOR, edx
@@:					;store background color
        xor     edx, edx                ;zero x/y offset
        cmp     [eax].iType, STYPE_DEVBITMAP
        mov     eax, [eax].dhsurf       ;get pointer to device bitmap
        ASSUME  eax:PTR DSURF
        jne     @F                      ;destination is not a device bitmap
        mov     edx, [eax].packedXY     ;get x/y offset of device bitmap
@@:     mov     eax, [prclOpaque_]      ;get pointer to opaquing rectangle
        ASSUME  eax:PTR RECTL
        mov     [mix_], edx             ;store x/y offset into mix variable
	push_	ecx
        test    eax, eax                ;do we have an opaquing rectangle?
        jz      SkipOpaque              ;no
	cmp	[ecx].shadowDRAWBLTDEF, SOLID_COLOR_FILL
	je	@F
	REQUIRE	2, ecx
        mov     DWORD PTR [ebp + grDRAWBLTDEF], SOLID_COLOR_FILL
	mov	[ecx].shadowDRAWBLTDEF, SOLID_COLOR_FILL
@@:					;use a solid fill
        mov     esi, [mix_]             ;get x/y offset
        mov     edi, [eax].left         ;get the rectangle coordinates
        mov     ecx, [eax].top
        mov     edx, [eax].right
        mov     eax, [eax].bottom
        cmp     edi, [ebx].rclBounds.left
                                        ;clip with clipping rectangle
        jg      @F
        mov     edi, [ebx].rclBounds.left
@@:     cmp     ecx, [ebx].rclBounds.top
        jg      @F
        mov     ecx, [ebx].rclBounds.top
@@:     cmp     edx, [ebx].rclBounds.right
        jl      @F
        mov     edx, [ebx].rclBounds.right
@@:     cmp     eax, [ebx].rclBounds.bottom
        jl      @F
        mov     eax, [ebx].rclBounds.bottom
@@:     sub     edx, edi
        jle     SkipOpaque              ;invalid width
        sub     eax, ecx
        jle     SkipOpaque              ;invalid height
IF SWAT6
	push	esi
	and	esi, 0000FFFFh
	add	edi, esi
	pop	esi
	shr	esi, 16
	add	ecx, esi
	mov	esi, [esp]
	INVOKE	StripePatBlt, esi, edi, ecx, edx, eax
ELSE
        shl     ecx, 16                 ;pack x/y
        add     edi, esi                ;add x/y offset
        shl     eax, 16
        add     ecx, edi
        or      eax, edx
	mov	edx, [esp]
	ASSUME	edx:PTR PDEV
	REQUIRE	5, edx
        mov     [ebp + grOP0_opRDRAM], ecx
                                        ;draw rectangle
        mov     [ebp + grBLTEXT_EX], eax
ENDIF
SkipOpaque:
	pop_	ecx
	ASSUME	ecx:PTR PDEV

        enter_  40                      ;create stack frame
bMoreGlyphs_    TEXTEQU <DWORD PTR [esp + 0 + frmPTR]>
ulCharInc_      TEXTEQU <DWORD PTR [esp + 4 + frmPTR]>
xBit_           TEXTEQU <DWORD PTR [esp + 8 + frmPTR]>
lDelta_         TEXTEQU <DWORD PTR [esp + 12 + frmPTR]>
dwControl_      TEXTEQU <DWORD PTR [esp + 16 + frmPTR]>
pdev_		TEXTEQU <DWORD PTR [esp + 20 + frmPTR]>
rclBounds_      TEXTEQU <RECTL PTR [esp + 24 + frmPTR]>
        save_   2
	mov	[pdev_], ecx

        mov     ax, [ebp + grCONTROL]
if DRIVER_5465 AND HW_CLIPPING
	cmp	[ecx].shadowDRAWBLTDEF, CACHE_EXPAND_XPAR + CLIPEN
	je	@F
	REQUIRE	2, ecx
        mov     DWORD PTR [ebp + grDRAWBLTDEF], CACHE_EXPAND_XPAR + CLIPEN
	mov	[ecx].shadowDRAWBLTDEF, CACHE_EXPAND_XPAR + CLIPEN
else
	cmp	[ecx].shadowDRAWBLTDEF, CACHE_EXPAND_XPAR
	je	@F
	REQUIRE	2, ecx
        mov     DWORD PTR [ebp + grDRAWBLTDEF], CACHE_EXPAND_XPAR
	mov	[ecx].shadowDRAWBLTDEF, CACHE_EXPAND_XPAR
endif
@@:					;enable off-screen expansion
        mov     [dwControl_], eax
        or      eax, SWIZ_CNTL          ;enable bit mirroring
        mov     edi, [pfo_]             ;EDI points to font object
        ASSUME  edi:PTR FONTOBJ
        mov     [ebp + grCONTROL], ax

        mov     eax, [ebx].rclBounds.left
                                        ;get clipping coordinates
        mov     ecx, [ebx].rclBounds.top
        mov     edx, [ebx].rclBounds.right
        mov     esi, [ebx].rclBounds.bottom

        mov     ebx, [pstro_]           ;EBX points to string
        ASSUME  ebx:PTR STROBJ
        mov     edi, [edi].pvConsumer   ;EDI points to font cache
        ASSUME  edi:PTR FONTCACHE
        mov     [rclBounds_].left, eax  ;store clipping coordinates
        mov     [rclBounds_].top, ecx
        mov     [rclBounds_].right, edx
        mov     [rclBounds_].bottom, esi

if DRIVER_5465 AND HW_CLIPPING
        ;; Set up hardware clipping
        shl     ecx, 16                 ; Top of clipping rect. in high word
        add     eax, ecx                ; Packed upper left coordinate
        add     eax, [mix_]
	mov	ecx, [pdev_]
	ASSUME	ecx:PTR PDEV
	REQUIRE	4, ecx
        mov     [ebp + grCLIPULE], eax  ; Set upper left clipping coordinate
        shl     esi, 16                 ; Bottom of clipping rect. in high word
        add     edx, esi                ; Packed lower right coordinate
        add     edx, [mix_]
        mov     [ebp + grCLIPLOR], edx  ; Set lower right clipping coordinate
endif

        mov     eax, [ebx].ulCharInc    ;copy ulCharInc
        cmp     [ebx].pgp, 0
        mov     [ulCharInc_], eax
        je      Enumerate               ;there is more than one array
        mov     ecx, [ebx].cGlyphs      ;get the number of glyphs
        mov     ebx, [ebx].pgp          ;EBX points to GLYPHPOS
        ASSUME  ebx:PTR GLYPHPOS
        mov     [bMoreGlyphs_], 0       ;no more glyph arrays

MainLoop:
        or      ecx, ecx                ;any glyphs to draw?
        je      SkipLoop                ;no
        mov     eax, [ebx].ptl.x        ;get coordinates of first glyph
        mov     edx, [ebx].ptl.y
GlyphLoop:
        push_   ecx
        mov     ecx, [ebx].hg           ;get the glyph handle
        cmp     [ulCharInc_], 0         ;fixed font?
        jne     @F                      ;no
        mov     eax, [ebx].ptl.x        ;get coordinates for glyph
        mov     edx, [ebx].ptl.y
@@:     shl     ecx, 4                  ;build index into font cache array
        cmp     ecx, MAX_GLYPHS * 16    ;glyph out of range?
        jnl     DrawGlyph               ;yes, draw it directly
        save_   3
        mov     esi, [edi + ecx*1].aGlyphs.xyPos
                                        ;get off-screen location of glyph
        lea     ecx, [edi + ecx*1].aGlyphs
                                        ;load address of cache slot
        ASSUME  ecx:PTR GLYPHCACHE
        or      esi, esi                ;is the glyph already cached?
        jnz     @F                      ;yes
        mov     esi, [ebx].pgdf         ;cache the glyph
        ASSUME  esi:PTR GLYPHDEF
        push    eax
        push    edx
        push    ecx
        INVOKE  AllocGlyph,
                        edi,
                        [esi].pgb,
                        ecx
        pop     ecx
        pop     edx
        pop     eax
        mov     esi, [ecx].xyPos        ;get off-screen location of glyph
@@:     cmp     [ecx].cSize, 0          ;is this an empty glyph?
        jl      DrawGlyph               ;no, in fact it is non-cacheable
        jz      Increment               ;yes, skip it
        push_   edx
        push_   eax
        push_   edi
        push_   ebx
        add     edx, [ecx].ptlOrigin.y  ;EDX = top
        mov     edi, [ecx].cSize        ;get packed width/height
        add     eax, [ecx].ptlOrigin.x  ;EAX = left
        mov     ecx, edi
        ASSUME  ecx:NOTHING
        shr     edi, 16                 ;EDI holds height
        and     ecx, 0000FFFFh          ;ECX holds width
        add     edi, edx                ;EDI = bottom
        add     ecx, eax                ;ECX = right

        mov     ebx, [rclBounds_].left  ;clip coordinates

ife (DRIVER_5465 AND HW_CLIPPING)
        cmp     ecx, [rclBounds_].right ; is the right edge clipped?
        jng     @F                      ; 
        mov     ecx, [rclBounds_].right ; yes - set new right 
endif
@@:     sub     ebx, eax                ; is the left edge clipped?
        jg      SpecialDraw             ; yes

        sub     ecx, eax                ; get delta x
        jng     SkipGlyph               ; right > left? - don't draw it
        mov     ebx, [rclBounds_].top

ife (DRIVER_5465 AND HW_CLIPPING)
        cmp     edi, [rclBounds_].bottom; is the bottom clipped?
        jng     @F
        mov     edi, [rclBounds_].bottom; yes - set new bottom
endif

@@:     sub     ebx, edx                ; is the top clipped?
        jng     @F
        shl     ebx, 16                 ; top is clipped
        mov     edx, [rclBounds_].top   ; adjust top
        add     esi, ebx                ; adjust off-screen top
@@:     sub     edi, edx                ; bottom > top?
        jng     SkipGlyph               ; no - skip it
        shl     edi, 16                 ; pack x/y
        add     eax, [mix_]             ; add x/y offset
        shl     edx, 16                 ; top << 16
        or      edi, ecx
        add     edx, eax                ; packed top left corner
	mov	ecx, [pdev_]
	ASSUME	ecx:PTR PDEV
        REQUIRE 7, ecx
        mov     [ebp + grOP0_opRDRAM], edx
                                        ;expand glyph from off-screen
        mov     [ebp + grOP2_opMRDRAM], esi
        mov     [ebp + grBLTEXT_EX], edi
SkipGlyph:
        pop_    ebx
        pop_    edi
        pop_    eax
        pop_    edx

Increment:
        add     eax, [ulCharInc_]       ;add x-increment
        pop_    ecx
        add     ebx, SIZEOF GLYPHPOS    ;next glyph
        dec     ecx
        jnz     GlyphLoop
SkipLoop:
        cmp     [bMoreGlyphs_], 0       ;more arrays of glypos?
        jne     Enumerate               ;yes
        mov     ecx, [dwControl_]
        leave_  40			;kill stack frame
        and     ecx, NOT SWIZ_CNTL      ;disable bit mirroring
        mov     eax, 1                  ;return TRUE
        mov     [ebp + grCONTROL], cx
        pop_    ebx
        pop_    ebp
        pop_    esi
        pop_    edi
        ret     40

Enumerate:
        load_   2
        push_   eax                     ;create room on stack for return
        push_   eax                     ;  parameters
        mov     eax, [pstro_]           ;get pointer to STROBJ
        mov     ebx, esp                ;ebx points to pgp parameter
        lea     ecx, [esp + 4]          ;ecx points to c parameter
        INVOKE  STROBJ_bEnum,
                        eax,
                        ecx,
                        ebx
        pop_    ebx                     ;load pgp from stack
        pop_    ecx                     ;load c from stack
        mov     [bMoreGlyphs_], eax
        jmp     MainLoop

;//frido BEGIN 28-Mar-96
SpecialDraw:
        pop_    ebx
        pop_    edi
        pop_    eax
        pop_    edx
;//frido END 28-Mar-96

;
; Draw a clipped glyph directly to screen.
;
DrawGlyph:
        load_   3
        mov     esi, [ebx].pgdf         ;ESI holds pointer to GLYPHDEF
        ASSUME  esi:PTR GLYPHDEF
        push_   eax
        push_   edx
        mov     esi, [esi].pgb          ;ESI holds pointer to GLYPHBITS
        ASSUME  esi:PTR GLYPHBITS
        push_   edi
        push_   ebx

        mov     edi, [esi].sizlBitmap._cx
                                        ;EDI = right
        mov     ecx, [esi].sizlBitmap._cy
                                        ;ECX = bottom
        add     eax, [esi].ptlOrigin.x  ;EAX = left
        add     edx, [esi].ptlOrigin.y  ;EDX = top
        lea     ebx, [edi + 7]          ;EBX = byte increment to next line
        add     edi, eax
        shr     ebx, 3
        add     ecx, edx
        lea     esi, [esi].aj           ;ESI holds pointer to bits
        ASSUME  esi:NOTHING
        mov     [xBit_], 0              ;zero bit offset
        mov     [lDelta_], ebx

        mov     ebx, [rclBounds_].left
        cmp     edi, [rclBounds_].right ;clip right
        jl      @F
        mov     edi, [rclBounds_].right
@@:     sub     ebx, eax                ;clip left
        jng     @F
        mov     eax, ebx                ;store bit offset
        shr     ebx, 3
        and     eax, 7
        add     esi, ebx
        mov     [xBit_], eax
        mov     eax, [rclBounds_].left
@@:     sub     edi, eax                ;EDI = width
        jng     GoIncrement

        mov     ebx, [rclBounds_].top
        cmp     ecx, [rclBounds_].bottom;clip bottom
        jl      @F
        mov     ecx, [rclBounds_].bottom
@@:     sub     ebx, edx                ;clip top
        jng     @F
        add     edx, ebx                ;store line offset
        imul    ebx, [lDelta_]
        add     esi, ebx
@@:     sub     ecx, edx                ;ECX = height
        jng     GoIncrement

        shl     edx, 16                 ;pack x,y
        mov     ebx, [xBit_]
        shl     ecx, 16
        or      edx, eax
        or      ecx, edi
        add     edx, [mix_]             ;add x/y offset
        lea     edi, [edi + ebx + 7]    ;EDI = adjusted width
IF broken_FIFO
        IDLE
ENDIF
	mov	eax, [pdev_]
	ASSUME	eax:PTR PDEV
	REQUIRE	4, eax
if DRIVER_5465 AND HW_CLIPPING
	cmp	[eax].shadowDRAWBLTDEF, TEXT_EXPAND_XPAR + CLIPEN
	je	@F
        mov     DWORD PTR [ebp + grDRAWBLTDEF], TEXT_EXPAND_XPAR + CLIPEN
	mov	[eax].shadowDRAWBLTDEF, TEXT_EXPAND_XPAR + CLIPEN
@@:					;enable on-screen expansion & clipping
else
	cmp	[eax].shadowDRAWBLTDEF, TEXT_EXPAND_XPAR
	je	@F
        mov     DWORD PTR [ebp + grDRAWBLTDEF], TEXT_EXPAND_XPAR
	mov	[eax].shadowDRAWBLTDEF, TEXT_EXPAND_XPAR
@@:					;enable on-screen expansion
endif
IF SWAT7
        mov     [ebp + grOP2_opMRDRAM], ebx
	cmp	cx, 64			;bug when doing 64 < width < 128
	jbe	SkipBug
	cmp	cx, 128
	jae	SkipBug
	push_	ecx			;save registers
	push_	edx
	push_	esi
	push_	edi
	mov	cx, 64			;1st passs, 64 pixels
	REQUIRE	5, eax
	mov	[ebp + grOP0_opRDRAM], edx
	mov	[ebp + grBLTEXT_EX], ecx
	shr	ecx, 16			;get height into ECX
	mov	edi, [lDelta_]		;get delta
BugLoop:
	mov	eax, [pdev_]
	REQUIRE	2, eax
	mov	eax, [esi][0]		;transfer 64 pixels
	mov	edx, [esi][4]
	mov	[ebp + grHOSTDATA][0], eax
	mov	[ebp + grHOSTDATA][4], edx
	or	ebx, ebx
	jz	@F
	mov	edx, [pdev_]
	ASSUME	edx:PTR PDEV
	mov	eax, [esi][8]
	REQUIRE	1, edx
	mov	[ebp + grHOSTDATA][8], eax
@@:	add	esi, [lDelta_]		;next glyph line
	dec	ecx
	jnz	BugLoop
	pop_	edi			;restore registers
	pop_	esi
	sub	edi, 64			;64 pixels less to do
	pop_	edx
	add	esi, 64 / 8		;8 bytes already done
	pop_	ecx
	add	edx, 64			;offset to next 64 pixels
	sub	ecx, 64
SkipBug:
	mov	eax, [pdev_]
	ASSUME	eax:PTR PDEV
	shr	edi, 3
	REQUIRE	5, eax
        mov     [ebp + grOP0_opRDRAM], edx
ELSE
	mov	eax, [pdev_]
	ASSUME	eax:PTR PDEV
        mov     [ebp + grOP0_opRDRAM], edx
	REQUIRE	5, eax
        mov     [ebp + grOP2_opMRDRAM], ebx
        shr     edi, 3
ENDIF
        mov     [ebp + grBLTEXT_EX], ecx
        shr     ecx, 16
        mov     edx, [lDelta_]
        mov	ebx, [pdev_]
	ASSUME	ebx:PTR PDEV
        cmp     edi, 2
        jb      Draw1Byte
        je      Draw2Bytes
        cmp     edi, 4
        jbe     Draw4Bytes

DrawLoop:
	push_	edi
	push_	esi
@@:     mov     eax, [esi]              ;get 4 bytes from glyph
        add     esi, 4
	REQUIRE	1, ebx
        mov     [ebp + grHOSTDATA], eax ;draw them
        sub     edi, 4                  ;4 bytes done
        jg      @B                      ;still more bytes to draw
	pop_	esi
	pop_	edi
        add	esi, edx
        dec     ecx                     ;next glyph row
        jnz     DrawLoop
        jmp     SkipDraw

Draw1Byte:
	mov     al, [esi]               ;get byte from glyph
        add     esi, edx
	REQUIRE	1, ebx
        mov     [ebp + grHOSTDATA], eax ;draw it
        dec     ecx                     ;next glyph line
        jnz     Draw1Byte
        jmp     SkipDraw

Draw2Bytes:
	mov     ax, [esi]               ;get two bytes from glyph
        add     esi, edx
	REQUIRE	1, ebx
        mov     [ebp + grHOSTDATA], eax ;draw them
        dec     ecx                     ;next glyph line
        jnz     Draw2Bytes
        jmp     SkipDraw

Draw4Bytes:
	mov     eax, [esi]              ;get four bytes from glyph
        add     esi, edx
	REQUIRE	1, ebx
        mov     [ebp + grHOSTDATA], eax ;draw them
        dec     ecx                     ;next glyph line
        jnz     Draw4Bytes

SkipDraw:
if DRIVER_5465 AND HW_CLIPPING
	cmp	[ebx].shadowDRAWBLTDEF, CACHE_EXPAND_XPAR + CLIPEN
	je	@F
	REQUIRE	2, ebx
        mov     DWORD PTR [ebp + grDRAWBLTDEF], CACHE_EXPAND_XPAR + CLIPEN
	mov	[ebx].shadowDRAWBLTDEF, CACHE_EXPAND_XPAR + CLIPEN
@@:                                     ;enable off-screen expansion & clipping
else
	cmp	[ebx].shadowDRAWBLTDEF, CACHE_EXPAND_XPAR
	je	@F
	REQUIRE	2, ebx
        mov     DWORD PTR [ebp + grDRAWBLTDEF], CACHE_EXPAND_XPAR
	mov	[ebx].shadowDRAWBLTDEF, CACHE_EXPAND_XPAR
@@:					;enable off-screen expansion
endif
GoIncrement:
        pop_    ebx
        pop_    edi
        pop_    edx
        pop_    eax
        jmp     Increment

ClipTextOut ENDP

ENDIF ; USE_ASM

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\clioctl.h ===
/****************************************************************************
*****************************************************************************
*
*                ******************************************
*                * Copyright (c) 1995, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:	Laguna I (CL-GD5462) - 
*
* FILE:		clioctl.h
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module contains the definitions of IOCTL commands
*           between the NT miniport and the display.
*
* MODULES:
*
* REVISION HISTORY:
*  $Log:   X:/log/laguna/nt35/displays/cl546x/CLIOCTL.H  $
* 
*    Rev 1.14   Mar 25 1998 17:56:54   frido
* Added IOCTL_STALL.
* 
*    Rev 1.13   Dec 10 1997 13:24:54   frido
* Merged from 1.62 branch.
* 
*    Rev 1.12.1.0   Nov 10 1997 11:25:14   phyang
* Added 5 IOCTL code for utilities to update registry values.
* 
*    Rev 1.12   Nov 03 1997 16:44:24   phyang
* Added IOCTL_GET_AGPDATASTREAMING.
* 
*    Rev 1.11   28 Aug 1997 15:16:06   noelv
* 
* Merged with miniport CLIOCTL.H.  Now we only use this one.
* 
*    Rev 1.10   23 Jul 1997 09:18:30   bennyn
* 
* Added IOCTL_GET_BIOS_VERSION
* 
*    Rev 1.9   21 Jul 1997 16:21:06   bennyn
* Added IOCTL for getting EDID data
* 
*    Rev 1.8   20 Jun 1997 13:33:18   bennyn
* 
* Added power manager data structure and #define
* 
*    Rev 1.7   23 Apr 1997 07:38:26   SueS
* Added IOCTL for enabling memory-mapped I/O access to PCI
* configuration registers.
* 
*    Rev 1.6   21 Mar 1997 13:41:20   noelv
* Combined LOG_CALLS, LOG_WRITES and LOG_QFREE into ENABLE_LOG_FILE
* 
*    Rev 1.5   18 Mar 1997 09:28:58   bennyn
* Added Intel DPMS support
* 
*    Rev 1.4   26 Nov 1996 10:15:24   SueS
* Added IOCTL for closing the log file.
* 
*    Rev 1.3   13 Nov 1996 17:06:58   SueS
* Added two IOCTL codes for notifying the miniport driver on
* file logging functions.
*   11/16/95     Benny Ng      Initial version
*
****************************************************************************
****************************************************************************/


//---------------------------------------------------------------------------
//
// The following macro(CTL_CODE) is defined in WINIOCTL.H. That file states
// that functions 2048-4095 are reserved for "customers". So I picked an 
// arbitrary value of 0x900=2304. 
//
#define IOCTL_CL_STRING_DISPLAY \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_CL_GET_COMMON_BUFFER \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x902, METHOD_BUFFERED, FILE_ANY_ACCESS)

#if ENABLE_LOG_FILE
  #define IOCTL_CL_CREATE_LOG_FILE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x903, METHOD_BUFFERED, FILE_ANY_ACCESS)

  #define IOCTL_CL_WRITE_LOG_FILE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x904, METHOD_BUFFERED, FILE_ANY_ACCESS)

  #define IOCTL_CL_CLOSE_LOG_FILE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x905, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

  #define IOCTL_VIDEO_ENABLE_PCI_MMIO \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x906, METHOD_BUFFERED, FILE_ANY_ACCESS)

  #define IOCTL_SET_HW_MODULE_POWER_STATE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x907, METHOD_BUFFERED, FILE_ANY_ACCESS)

  #define IOCTL_GET_HW_MODULE_POWER_STATE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x908, METHOD_BUFFERED, FILE_ANY_ACCESS)

  #define IOCTL_GET_AGPDATASTREAMING \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x90B, METHOD_BUFFERED, FILE_ANY_ACCESS)

  #define IOCTL_STALL \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x911, METHOD_BUFFERED, FILE_ANY_ACCESS)

// =====================================================================
// Define structure used for power manager
// =====================================================================
#ifndef __LGPWRMGR_H__
#define __LGPWRMGR_H__

#define  ENABLE           0x1
#define  DISABLE          0x0

#define  ACPI_D0          0x0
#define  ACPI_D1          0x1
#define  ACPI_D2          0x2
#define  ACPI_D3          0x3
#define  TOTAL_ACPI       4

#define  MOD_2D           0x0
#define  MOD_STRETCH      0x1
#define  MOD_3D           0x2
#define  MOD_EXTMODE      0x3
#define  MOD_VGA          0x4
#define  MOD_RAMDAC       0x5
#define  MOD_VPORT        0x6
#define  MOD_VW           0x7
#define  MOD_TVOUT        0x8
#define  TOTAL_MOD        MOD_TVOUT+1

typedef struct _LGPM_IN_STRUCT {
    ULONG arg1;
    ULONG arg2;
} LGPM_IN_STRUCT, *PLGPM_IN_STRUCT;

typedef struct _LGPM_OUT_STRUCT {
    BOOL  status;
    ULONG retval;
} LGPM_OUT_STRUCT, *PLGPM_OUT_STRUCT;

#endif  // #ifndef __LGPWRMGR_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\brush.h ===
/******************************Module*Header*******************************\
 *
 * Module Name: brush.h
 *
 * contains prototypes for the brush cache.
 *
 * Copyright (c) 1997 Cirrus Logic, Inc.
 *
 * $Log:   X:/log/laguna/nt35/displays/cl546x/brush.h  $
* 
*    Rev 1.2   26 Feb 1997 10:44:10   noelv
* 
* Fixed structure packing.
* 
*    Rev 1.1   19 Feb 1997 13:06:40   noelv
* Added vInvalidateBrushCache()
* 
*    Rev 1.0   06 Feb 1997 10:34:00   noelv
* Initial revision.
 *
\**************************************************************************/

#include "memmgr.h"

#ifndef _BRUSH_H_
#define _BRUSH_H_


//
// Brush Structures
// See BRUSH.C for comments about how brushes are realized and cached.
// Prototypes for brush handling functions are later on in this file.
//

/*
 * Be sure to synchronize these structures with those in i386\Laguna.inc!
 */

#pragma pack(1)

// A realized brush.  The brush must be cached before it is used.
typedef struct {
  ULONG   nPatSize;
  ULONG   iBitmapFormat;
  ULONG   ulForeColor;
  ULONG   ulBackColor;
  ULONG   iType;        // brush type
  ULONG   iUniq;        // unique value for brush
  ULONG   cache_slot;   // Slot number of cache table entry.
  ULONG   cache_xy;
  ULONG   cjMask;       // offset to mask bits in ajPattern[]
  BYTE    ajPattern[0]; // pattern bits followed by mask bits
} RBRUSH, *PRBRUSH;

#define BRUSH_MONO      1
#define BRUSH_4BPP      2
#define BRUSH_DITHER    3
#define BRUSH_COLOR     4

// An entry in the Brush caching table.
typedef struct {
  ULONG xy;
  PBYTE pjLinear;
  VOID *brushID;  // Address of realized brush structure if this 
                  // cache entry is used.  For verifying that a cache
                  // entry is still valid.
} BC_ENTRY;


#define XLATE_PATSIZE  32      // 8*8 16-color pattern
#define XLATE_COLORS   16      // 8*8 16-color pattern

// An entry in the mono cache table.
typedef struct
{
  ULONG xy;            // x,y location of brush
  PBYTE pjLinear;      // linear address of brush
  ULONG iUniq;         // unique value for brush
  BYTE  ajPattern[8];  // 8x8 monochrome pattern
} MC_ENTRY;

// An entry in the 4-bpp caching table.
typedef struct
{
  ULONG xy;            // x,y location of brush
  PBYTE pjLinear;      // linear address of brush
  ULONG iUniq;         // unique value for brush
  BYTE  ajPattern[XLATE_PATSIZE];  // 8x8 16-color pattern
  ULONG ajPalette[XLATE_COLORS];   // 16-color palette
} XC_ENTRY;

// An entry in the dither cache table.
typedef struct
{
  ULONG xy;        // x,y location of brush
  PBYTE pjLinear;  // linear address of brush
  ULONG ulColor;   // logical color of brush
} DC_ENTRY;


// Define the number of brushes to cache.
#define NUM_MONO_BRUSHES    32     // 2 lines
#define NUM_4BPP_BRUSHES    8      // 4, 8, or 16 lines
#define NUM_DITHER_BRUSHES  8      // 4 lines
#define NUM_COLOR_BRUSHES   32     // 16 lines
#define NUM_SOLID_BRUSHES   4      // 8 lines
#define NUM_8BPP_BRUSHES    (NUM_COLOR_BRUSHES)
#define NUM_16BPP_BRUSHES   (NUM_COLOR_BRUSHES/2)
#define NUM_TC_BRUSHES      (NUM_COLOR_BRUSHES/4)

//
// Brush routines.
//

void vInitBrushCache(
    struct _PDEV *ppdev);

void vInvalidateBrushCache(
    struct _PDEV *ppdev);

ULONG ExpandColor(
    ULONG iSolidColor, 
    ULONG ulBitCount);

BOOL SetBrush(
    struct _PDEV *ppdev,
    ULONG     *bltdef, 
    BRUSHOBJ* pbo, 
    POINTL*   pptlBrush);

BOOL CacheBrush(
    struct _PDEV *ppdev,
    PRBRUSH pRbrush);

VOID vDitherColor(ULONG rgb, ULONG *pul);

// restore default structure alignment
#pragma pack()

#endif // _BRUSH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\bw.h ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1997, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         bw.h
*
* DESCRIPTION:
*
* REVISION HISTORY:
*
* $Log:   X:/log/laguna/ddraw/inc/bw.h  $
* 
*    Rev 1.3   18 Sep 1997 16:05:28   bennyn
* 
* Fixed NT 3.51 compile/link problem
* 
*    Rev 1.2   12 Sep 1997 12:11:08   bennyn
* 
* Modified for NT DD overlay support.
* 
*    Rev 1.1   15 May 1997 15:51:06   XCONG
* 
* Change BWE flags for DDRAW
* 
*    Rev 1.0   14 Apr 1997 11:03:48   RUSSL
* PDC Release
*
***************************************************************************
***************************************************************************/

/**********************************************************
* Copyright Cirrus Logic, Inc. 1996. All rights reserved.
***********************************************************
*
* BW.H
*
* Contains common preprocessor definitions needed for
*  bandwidth equations.
*
***********************************************************
*
*  WHO WHEN     WHAT/WHY/HOW
*  --- ----     ------------
*  RT  11/07/96 Created.
*
***********************************************************/
// If WinNT 3.5 skip all the source code
#if defined WINNT_VER35      // WINNT_VER35

#else


#ifndef BW_H
#define BW_H

#ifdef DOSDEBUG
#include <stdio.h>
#endif // DOSDEBUG

#define VCFLG_CAP       0x00000001ul  // Capture enabled
#define VCFLG_DISP      0x00000002ul  // Display enabled
#define VCFLG_COLORKEY  0x00000004ul  // Color key (destination) enabled
#define VCFLG_CHROMAKEY 0x00000008ul  // Chroma key (source color key) enabled
#define VCFLG_420       0x00000010ul  // 4:2:0 video
#define VCFLG_PAN       0x00000020ul  // Panning display mode

#ifdef WINNT_VER40
// Be sure to synchronize the following structures with the one
// in i386\Laguna.inc!
//
typedef struct VIDCONFIG_
{
  SIZEL sizXfer;    // Size of xfered data in pixels by lines (after cropping)
  SIZEL sizCap;     // Size of data stored in memory in pixels by lines
  SIZEL sizSrc;     // Size of data read from memory in pixels by lines
  SIZEL sizDisp;    // Size of video window rectangle in pixels by lines
  UINT  uXferDepth; // Bits per transferred pixel
  UINT  uCapDepth;  // Bits per pixel stored in memory
  UINT  uSrcDepth;  // Bits per pixel read from memory
  UINT  uDispDepth; // Bits per pixel of video window
  UINT  uGfxDepth;  // Bits per pixel of graphics screen
  DWORD dwXferRate; // Peak pixels per second into video port
  DWORD dwFlags;
}VIDCONFIG, FAR *LPVIDCONFIG;

#else
typedef struct VIDCONFIG_
{
  SIZE  sizXfer;    // Size of xfered data in pixels by lines (after cropping)
  SIZE  sizCap;     // Size of data stored in memory in pixels by lines
  SIZE  sizSrc;     // Size of data read from memory in pixels by lines
  SIZE  sizDisp;    // Size of video window rectangle in pixels by lines
  UINT  uXferDepth; // Bits per transferred pixel
  UINT  uCapDepth;  // Bits per pixel stored in memory
  UINT  uSrcDepth;  // Bits per pixel read from memory
  UINT  uDispDepth; // Bits per pixel of video window
  UINT  uGfxDepth;  // Bits per pixel of graphics screen
  DWORD dwXferRate; // Peak pixels per second into video port
  DWORD dwFlags;
}VIDCONFIG, FAR *LPVIDCONFIG;
#endif

#ifndef ODS
# ifdef DOSDEBUG
#   define ODS printf
# else
#   define ODS (void)
# endif // DOSDEBUG
#endif // !ODS

#endif // BW_H
#endif // WINNT_VER35

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\config.h ===
/* config.h	
 * 	stuff here is meant to deal w/ portability issues
 * 	across architectur/platforms
 *
 *	ALL_HOST defined means do all work on host, as opposed to some on
 *		TI board
 *
 *	DIRECT_IO defined means the CPU running the code cas do direct file IO
 *
 *	NO_ADDR_CONST_EXPR defined means the compiler in use can't do address
 *		arithmetic in integer constant expressions, i.e. case statement
 */

#ifndef _CONFIG_H_
#define _CONFIG_H_

#ifdef sun
#define ALL_HOST		/* do all the work on the host */
#define DIRECT_IO		/* the CPU doing the graphics can do file IO */
/*#define NO_ADDR_CONST_EXPR */
#else /* def sun */
#define ALL_HOST		/* do all the work on the host */
#define DIRECT_IO		/* the CPU doing the graphics can do file IO */
#define NO_ADDR_CONST_EXPR
#endif /* def sun */

#ifndef FAR
#ifdef MSDOS
#define FAR far
#else
#define FAR
#endif
#endif

/* deal w/ the different pointer addressing, i.e. PR_SHIFT != 0 means bit
 * 	addressing 
 */
#ifdef MSDOS 
#define PR_SHIFT 0		/* Host code; byte addresses */
#elif sun
#define PR_SHIFT 0		/* Host code; byte addresses */
#else
#define PR_SHIFT 3		/* TI code; bit of byte addresses */
#endif /* MSDOS */

/* the following macros are for dealing w/ TI "asm" statement */
#ifdef ALL_HOST
#define DISABLE_INTERRUPT	
#define ENABLE_INTERRUPT	
#define ASM( a,b) b
#else /* ALL_HOST */
#define DISABLE_INTERRUPT	asm (" DINT")
#define ENABLE_INTERRUPT	asm (" EINT")
#define ASM( a,b) a
#endif /*  ALL_HOST */


#endif /* __CONFIG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\debug.h ===
/***************************************************************************\
* Module Name: debug.h
*
* Commonly used debugging macros.
*
* Copyright (c) 1992 Microsoft Corporation
\***************************************************************************/

extern
VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    ) ;

//  DDRAW uses DBG_MESSAGE instead of DISPDBG.
#define DBG_MESSAGE(x) DISPDBG((0,x))


// if we are in a debug environment, macros should

#if DBG
#define DISPDBG(arg) DebugPrint arg

#define RIP(x) { DebugPrint(0, x); }

#ifdef WINNT_VER40
#define ASSERTMSG(x,m) { if (!(x)) {RIP(m); EngDebugBreak();} }
#else
#define ASSERTMSG(x,m) { if (!(x)) {RIP(m); DebugBreak();} }
#endif

// if we are not in a debug environment, we want all of the debug
// information to be stripped out.

#else
#define DISPDBG(arg)
#define RIP(x)
#define ASSERTMSG(x,m)


#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\font.h ===
/******************************Module*Header*******************************\
 *
 * Module Name:  font.h
 *
 * Author:    Frido Garritsen
 *
 * Purpose:    Define the font cache structures.
 *
 * Copyright (c) 1996 Cirrus Logic, Inc.
 *
 * $Log:   X:/log/laguna/nt35/displays/cl546x/FONT.H  $
* 
*    Rev 1.5   20 Aug 1996 11:04:56   noelv
* Bugfix release from Frido 8-19-96
* 
*    Rev 1.0   14 Aug 1996 17:16:36   frido
* Initial revision.
* 
*    Rev 1.4   25 Jul 1996 15:53:12   bennyn
* 
* Modified for DirectDraw support
 * 
 *    Rev 1.3   05 Mar 1996 11:59:46   noelv
 * Frido version 19
 * 
 *    Rev 1.3   28 Feb 1996 22:39:06   frido
 * Removed bug in naming ulFontCountl.
 * 
 *    Rev 1.2   03 Feb 1996 12:22:20   frido
 * Added text clipping.
 * 
 *    Rev 1.1   25 Jan 1996 12:49:38   frido
 * Added font cache ID counter to FONTCACHE structure.
 * 
 *    Rev 1.0   23 Jan 1996 15:14:52   frido
 * Initial release.
 *
\**************************************************************************/

#define  BYTES_PER_TILE  128   // Number of bytes per tile line.
#define  LINES_PER_TILE  16    // Number of lines per tile.

#define CACHE_EXPAND_XPAR  0x105501F0  // DRAWBLTDEF register value.

// support routines

extern BYTE Swiz[];

void AddToFontCacheChain(PDEV*       ppdev,
                         FONTOBJ*    pfo,
                         PFONTCACHE  pfc);

VOID AllocGlyph(
  PFONTCACHE  pfc,    // Pointer to font cache.
  GLYPHBITS*  pgb,    // Pointer to glyph to cache.
  PGLYPHCACHE  pgc      // Pointer to glyph cache structure.
);

long GetGlyphSize(
  GLYPHBITS*  pgb,    // Pointer to glyph.
  POINTL*    pptlOrigin,  // Pointer to return origin in.
  DWORD*    pcSize    // Pointer to return size of glyph in.
);

BOOL AllocFontCache(
  PFONTCACHE  pfc,    // Pointer to font cache.
  long    cWidth,    // Width (in bytes) to allocate.
  long    cHeight,  // Height to allocate.
  POINTL*    ppnt    // Point to return cooridinate in.
);

VOID FontCache(
  PFONTCACHE  pfc,    // Pointer to font cache.
  STROBJ*    pstro    // Pointer to glyphs.
);

VOID ClipCache(
  PFONTCACHE  pfc,    // Pointer to font cache.
  STROBJ*    pstro,    // Pointer to glyphs.
  RECTL    rclBounds  // Clipping rectangle.
);

VOID DrawGlyph(
  PDEV*    ppdev,    // Pointer to physical device.
  GLYPHBITS*  pgb,    // Pointer to glyph to draw.
  POINTL    ptl      // Location of glyph.
);

VOID ClipGlyph(
  PDEV*    ppdev,    // Pointer to physical device.
  GLYPHBITS*  pgb,    // Pointer to glyph to draw.
  POINTL    ptl,    // Location of glyph.
  RECTL    rclBounds  // Clipping rectangle.
);

#define PACK_XY(x, y)    ((WORD)(x) | ((DWORD)(y) << 16))

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\hdtable.h ===
/*
* HDTABLE.H
* This provides a work around for the Laguna hostdata bug.
*
* Copyright (c) 1995 Cirrus Logic, Inc.
*/


/* the ExtraDwodTable is indexed by as follows (verilog notation)
*       index[15:00] =    bltext [10:0] dst_phase [2:0] src_phase [1:0]
*
*       index[15:05] =    bltext [10:00]
*       index[04:02] = dst_phase [02:00]
*       index[01:00] = src_phase [01:00]
*/
#if ! DRIVER_5465
#define MAKE_HD_INDEX(ext_x, src_phase, dst_x)  \
         (((((ext_x)     & 0x07FF) << 5) |      \
           (((dst_x)     & 0x07)  << 2)) |      \
            ((src_phase) & 0x03))

extern unsigned char ExtraDwordTable[];
#endif

//
// The table is actually defined in HDTABLE.C
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\ddinline.h ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1996, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         ddinline.h
*
* DESCRIPTION:  Private declarations for DDraw blt code
*
* REVISION HISTORY:
*
* $Log:   X:/log/laguna/ddraw/inc/ddinline.h  $
* 
*    Rev 1.5   Feb 16 1998 16:33:02   frido
* The previous fix should only happen for Windows 95.
* 
*    Rev 1.4   08 Jan 1998 12:38:12   eleland
* Added a SyncWithQueueManager call in CurrentVLine.  This fixes
* a PCI bus hang (PDR 10917).
* 
*    Rev 1.3   06 Jan 1998 14:20:42   xcong
* Access pDriverData locally for multi-monitor support.
* 
*    Rev 1.2   29 Aug 1997 17:46:34   RUSSL
* Needed a couple more defines for previous change
* 
*    Rev 1.1   29 Aug 1997 17:40:02   RUSSL
* Added CurrentVLine for 65 NT overlay
*
*    Rev 1.0   20 Jan 1997 14:42:42   bennyn
* Initial revision.
*
***************************************************************************
***************************************************************************/
// If WinNT 3.5 skip all the source code
#if defined WINNT_VER35      // WINNT_VER35

#else


#ifndef _DDINLINE_H_
#define _DDINLINE_H_

/***************************************************************************
* I N L I N E   F U N C T I O N S
****************************************************************************/

/***************************************************************************
*
* FUNCTION:     DupColor()
*
* DESCRIPTION:
*
****************************************************************************/

static __inline DWORD DupColor
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
//??  struct _DRIVERDATA  *lpDDHALData,
#else
   LPGLOBALDATA lpDDHALData,
#endif
  DWORD dwColor
)
{
  return (8 == BITSPERPIXEL) ?
         MAKELONG( MAKEWORD(dwColor,dwColor), MAKEWORD(dwColor,dwColor) )
         : (16 == BITSPERPIXEL) ?
         MAKELONG( dwColor, dwColor ) : // bpp must be 24 or 32.
         dwColor;
}

/***************************************************************************
*
* FUNCTION:     EnoughFifoForBlt()
*
* DESCRIPTION:
*
****************************************************************************/

/*
 * EnoughFifoForBlt should be replaced with a test to see if there is enough
 * room in the hardware fifo for a blt
 */
static __inline BOOL EnoughFifoForBlt
(
#ifdef WINNT_VER40
  struct _DRIVERDATA  *lpDDHALData
#else
  LPGLOBALDATA  lpDDHALData
#endif
)
{
  // This should probably be a little more specific to each call !!!
  // A (untiled) stretch blt actually needs 17 free entries.
  const BYTE QFREE = 16;

  PVGAR pREG = (PVGAR) lpDDHALData->RegsAddress;
  return (pREG->grQFREE >= QFREE);
}

/***************************************************************************
*
* FUNCTION:     DupZFill
*
* DESCRIPTION:  Gets the actual value for Z fills
*
****************************************************************************/
//JGO added for Laguna3D integration

static __inline DWORD DupZFill
(
#ifdef WINNT_VER40
  struct _PDEV  *ppdev,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD   dwFillValue,
  DWORD   zBpp
)
{

    return (8 == zBpp) ?
        MAKELONG( MAKEWORD(dwFillValue,dwFillValue),
                  MAKEWORD(dwFillValue,dwFillValue) )
         : (16 == BITSPERPIXEL) ?
        MAKELONG( dwFillValue, dwFillValue )
         : // bpp must be 24 or 32.
        dwFillValue;
}

#ifdef WINNT_VER40
#if DRIVER_5465 && defined(OVERLAY)

#define CSL           0x00C4
#define CSL_5464      0x0140

/***************************************************************************
*
* FUNCTION:     CurrentVLine
*
* DESCRIPTION:
*
****************************************************************************/
static __inline int CurrentVLine (PDEV* ppdev)
{
  WORD   cline;
  PBYTE  pMMReg = (PBYTE) ppdev->pLgREGS_real;
  PWORD  pCSL;
  BYTE   tmpb;

#ifndef WINNT_VER40
  SyncWithQueueManager(lpDDHALData);
#endif

  // on 5462 there is no CurrentScanLine register
  // on RevAA of 5465 it's busted
  if ((CL_GD5462 == ppdev->dwLgDevID) ||
     ((CL_GD5465 == ppdev->dwLgDevID) && (0 == ppdev->dwLgDevRev)))
     return 0;

  if (IN_VBLANK)
     return 0;

  // read current scanline
  if (ppdev->dwLgDevID == CL_GD5464)
     pCSL = (PWORD) (pMMReg + CSL_5464);
  else
     pCSL = (PWORD) (pMMReg + CSL);

  cline = *pCSL & 0x0FFF;

  // if scanline doubling is enabled, divide current scanline by 2
  tmpb = (BYTE) LLDR_SZ (grCR9);
  if (0x80 & tmpb)
     cline /= 2;

  // if current scanline is past end of visible screen return 0
  if (cline >= ppdev->cyScreen)
    return 0;
  else
    return cline;
}
#endif  // DRIVER_5465 && OVERLAY
#endif  // WINNT_VER40

#endif /* _DDINLINE_H_ */
#endif // WINNT_VER35
/* Don't write below this endif */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\l2d.h ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1996, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         l2d.h
*
* DESCRIPTION:
*
* REVISION HISTORY:
*
* $Log:   X:/log/laguna/ddraw/inc/L2D.H  $
* 
*    Rev 1.2   03 Oct 1997 14:04:04   RUSSL
* Added hw clip register defines
*
*    Rev 1.1   23 Jan 1997 17:16:04   bennyn
*
* Changed the register naming
*
*    Rev 1.0   25 Nov 1996 14:59:56   RUSSL
* Initial revision.
*
*    Rev 1.1   01 Nov 1996 13:02:46   RUSSL
* Merge WIN95 & WINNT code for Blt32
*
*    Rev 1.0   01 Nov 1996 09:28:32   BENNYN
* Initial revision.
*
*    Rev 1.0   25 Oct 1996 10:47:56   RUSSL
* Initial revision.
*
***************************************************************************
***************************************************************************/

/********************************************************************************
*
*   Module:     L2D.H           Header for 2D portion of the library
*
*   Revision:   1.00
*
*   Date:       04/10/96
*
*   Author:     Evan Leland
*
*********************************************************************************
*
*   Module Description:
*
*       This header file contais structures used in Laguna 2D
*       library.  This header is accessible to the user?
*
*   Note: do not change the values of these defines as some of them
*         are hard coded in the hardware
*
*********************************************************************************
*
*   Changes:
*
*   DATE     REV   DESCRIPTION OF CHANGES                 AUTHOR
* --------   ----  -----------------------------------   -----------
* 04/10/96   1.00  Original                              Evan Leland
* --------   ----  -----------------------------------   -----------
*********************************************************************************/

// If WinNT 3.5 skip all the source code
#if defined WINNT_VER35      // WINNT_VER35

#else


#ifndef _L2D_H_
#define _L2D_H_

//#if 0
//#include "l3d.h"                        // 3D definitions, functions
//#include "l3system.h"                   // low-level defs
//
//#define SSA_ARM     1
//#define VGA_FLIP    2
//
//#define misc_vga_ctrl     (*(BYTE  *)((BYTE *) LL_State.pRegs + 0x001a))
//#define vert_sync_end     (*(BYTE  *)((BYTE *) LL_State.pRegs + 0x0044))
//#define vert_disp_end     (*(BYTE  *)((BYTE *) LL_State.pRegs + 0x0048))
//#define vert_blnk_end     (*(BYTE  *)((BYTE *) LL_State.pRegs + 0x0058))
//#define cur_scnln_reg     (*(BYTE  *)((BYTE *) LL_State.pRegs + 0x0140))
//#define ssa_reg           (*(WORD  *)((BYTE *) LL_State.pRegs + 0x0144))
//#define mb_ctrl_reg       (*(BYTE  *)((BYTE *) LL_State.pRegs + 0x0148))
//#define pf_status_reg     (*(DWORD *)((BYTE *) LL_State.pRegs + 0x4424))
//#define host_3d_data_port (*(DWORD *)((BYTE *) LL_State.pRegs + 0x4800))
//
//typedef struct {                        // the following are cached:
//
//    DWORD   dwBGcolor;                  // background color register
//    DWORD   dwFGcolor;                  // foreground color register
//
//    BYTE    bCR1B;                      // vga extended display controls reg
//    BYTE    bCR1D;                      // vga screen start A extension reg
//
//    int     dPageFlip;                  // type of double buffering set
//
//} TSystem2D;
//
//typedef enum { BLT_MASTER_IO, BLT_Y15, BLT_LAGUNA1 } blt_type_t;
//
//// temp!
//void LL_DumpRegs();
//
//// constructor, destructor
//BOOL _InitLib_2D(LL_DeviceState *);
//BOOL _CloseLib_2D();
//
//DWORD SetColor_8bit  (LL_Color *pColor);
//DWORD SetColor_16bit (LL_Color *pColor);
//DWORD SetColor_15bit (LL_Color *pColor);
//DWORD SetColor_32bit (LL_Color *pColor);
//DWORD SetColor_Z24bit(LL_Color *pColor);
//
//// 2D operations using display list
//DWORD *fnColorFill(DWORD *dwNext, LL_Batch *pBatch);
//DWORD *fnCopyBuffer(DWORD *dwNext, LL_Batch *pBatch);
//DWORD *fnSetDisplayBuffer(DWORD *dwNext, LL_Batch *pBatch);
//DWORD *fnSetRenderBuffer(DWORD *dwNext, LL_Batch *pBatch);
//DWORD *fnSetFGColor(DWORD *dwNext, LL_Batch *pBatch);
//DWORD *fnSetBGColor(DWORD *dwNext, LL_Batch *pBatch);
//DWORD *fnCopyPattern(DWORD *dwNext, LL_Batch *pBatch);
//DWORD *fnMonoToColorExpand(DWORD *dwNext, LL_Batch *pBatch);
//DWORD *fnTransparentBLT(DWORD *dwNext, LL_Batch *pBatch);
//DWORD *fnZFill(DWORD *dwNext, LL_Batch *pBatch);
//DWORD *fnResizeBLT(DWORD *dwNext, LL_Batch *pBatch);
//DWORD *fnWaitForPageFlip(DWORD *dwNext, LL_Batch *pBatch);
//
////
//// TEMP: 5464 resize data formats
////
//#define LL_RESIZE_CLUT          0x0
//#define LL_RESIZE_1555          0x1
//#define LL_RESIZE_565           0x2
//#define LL_RESIZE_RGB           0x3
//#define LL_RESIZE_ARGB          0x4
//#define LL_RESIZE_YUV           0x9
//
//#define LL_X_INTERP             0x4
//#define LL_Y_INTERP             0x8
//
//// blt type INTERNAL identifiers
////
//
//#define LL_BLT_MONO_PATTERN     2
//#define LL_BLT_COLOR_PATTERN    3
//
//#define BLT_SRC_COPY            0
//#define BLT_MONO_EXPAND         1
//#define BLT_MONO_TRANSPARENCY   4
//#define BLT_COLOR_TRANSPARENCY  5
//#define BLT_RESIZE              6
//
//#define BLT_FF                  0x0     // blt frame-frame
//#define BLT_HF                  0x1     // blt host-frame
//#define BLT_FH                  0x2     // blt frame-host
//#define BLT_HH                  0x3     // blt host-host
//#endif

//
//  2D register (sub)set
//

#define COMMAND_2D              0x480
//#if 0
//#define CONTROL                 0x402
//#define BITMASK                 0x5E8
//#define BLTDEF                  0x586
//#define DRAWDEF                 0x584
//#define LNCNTL                  0x50E   // name conflicts with autoblt_regs!
//#define STRETCH                 0x510
//#define STATUS                  0x400
//
#define L2D_OP0_OPRDRAM           0x520
//#define L2D_OP1_OPRDRAM           0x540
//#define L2D_OP2_OPRDRAM           0x560
#define L2D_OP0_OPMRDRAM          0x524
//#define L2D_OP1_OPMRDRAM          0x544
//#define L2D_OP2_OPMRDRAM          0x564
//#define L2D_OP0_OPSRAM            0x528
//#define L2D_OP1_OPSRAM            0x548
//#define L2D_OP2_OPSRAM            0x568
//#define L2D_OP1_OPMSRAM           0x54A
//#define L2D_OP2_OPMSRAM           0x56A
//#define L2D_OP_BGCOLOR            0x5E4
//#define L2D_OP_FGCOLOR            0x5E0
//#endif

#define L2D_CLIPULE               0x590
#define L2D_CLIPLOR               0x594
#define L2D_MCLIPULE              0x598
#define L2D_MCLIPLOR              0x59C

#define L2D_BLTEXT_EX             0x700
#define L2D_MBLTEXT_EX            0x720
//#define BLTEXT_XEX              0x600
#define L2D_BLTEXTR_EX            0x708
#define L2D_MBLTEXTR_EX           0x728

#define L2D_CLIPULE_EX            0x760
#define L2D_CLIPLOR_EX            0x770
#define L2D_MCLIPULE_EX           0x780
#define L2D_MCLIPLOR_EX           0x790

//#if 0
//#define PATOFF                  0x52A   // name conflicts with autoblt_regs!
//#define SHRINKINC               0x582   // name conflicts with autoblt_regs!
//#define SRCX                    0x580   // name conflicts with autoblt_regs!
//#define MAJX                    0x50A
//#define MAJY                    0x502
//#define MINX                    0x508
//#define MINY                    0x500
//#define ACCUMX                  0x50c
//#define ACCUMY                  0x504
//#define ALPHA_AB                0x5e0
//#define CHROMA_CTL              0x512
//#define CHROMA_LOW              0x5f0
//#define CHROMA_UPR              0x5f4
//#define HOSTDATA                0x800
//
//#define OFFSET_2D               0x405
//#define TIMEOUT                 0x406
//#define TILE_CTRL               0x407
//#endif

//
//  the same 2D registers for use with COMMAND register burst writes
//

#define C_MINY                  0x0080
#define C_MAJY                  0x0081
#define C_ACCUMY                0x0082
#define C_MINX                  0x0084
#define C_MAJX                  0x0085
#define C_ACCUMX                0x0086
#define C_LNCNTL                0x0087
#define C_STRCTL                0x0088
#define C_CMPCNTL               0x0089
#define C_RX_0                  0x0090
#define C_RY_0                  0x0091
#define C_MRX_0                 0x0092
#define C_MRY_0                 0x0093
#define C_SRAM_0                0x0094
#define C_PATOFF                0x0095

#define C_RX_1                  0x00a0
#define C_RY_1                  0x00a1
#define C_MRX_1                 0x00a2
#define C_MRY_1                 0x00a3
#define C_SRAM_1                0x00a4
#define C_MSRAM_1               0x00a5

#define C_RX_2                  0x00b0
#define C_RY_2                  0x00b1
#define C_MRX_2                 0x00b2
#define C_MRY_2                 0x00b3
#define C_SRAM_2                0x00b4
#define C_MSRAM_2               0x00b5

#define C_SRCX                  0x00c0
#define C_SHINC                 0x00c1
#define C_DRWDEF                0x00c2
#define C_BLTDEF                0x00c3
#define C_MONOQW                0x00c4

#define C_BLTX                  0x0100
#define C_BLTY                  0x0101
#define C_MBLTX                 0x0110

#define C_EX_BLT                0x0200
#define C_EX_FBLT               0x0201
#define C_EX_RBLT               0x0202
#define C_EX_LINE               0x0203
#define C_FG_L                  0x00f0
#define C_FG_H                  0x00f1
#define C_BG_L                  0x00f2
#define C_BG_H                  0x00f3
#define C_BITMSK_L              0x00f4
#define C_BITMSK_H              0x00f5
#define C_PTAG                  0x00f6
#define C_CHROMAL_L             0x00f8
#define C_CHROMAL_H             0x00f9
#define C_CHROMAU_L             0x00fa
#define C_CHROMAU_H             0x00fb

#define C_CLIPULE_X             0x00c8
#define C_CLIPULE_Y             0x00c9
#define C_CLIPLOR_X             0x00ca
#define C_CLIPLOR_Y             0x00cb

#define C_MCLIPULE_X            0x00cc
#define C_MCLIPULE_Y            0x00cd
#define C_MCLIPLOR_X            0x00ce
#define C_MCLIPLOR_Y            0x00cf

#define C_BLTEXT_X              0x008c
#define C_BLTEXT_Y              0x008d
#define C_MBLTEXT_X             0x008e
#define C_MBLTEXT_Y             0x008f

//
// VGA registers
//

#define VGA_REG140              0x0140
#define VGA_SCANLINE_COMPARE    0x0142
#define VGA_SSA_REG             0x0144
#define VGA_MB_CTRL             0x0148

#define VGA_HTOTAL              0x0000
#define VGA_HDISP_END           0x0004
#define VGA_HBLNK_START         0x0008
#define VGA_HBLNK_END           0x000C
#define VGA_HSYNC_START         0x0010
#define VGA_HSYNC_END           0x0014

#define VGA_VTOTAL              0x0018
#define VGA_VDISP_END           0x0048
#define VGA_VBLNK_START         0x0054
#define VGA_VBLNK_END           0x0058
#define VGA_VSYNC_START         0x0040
#define VGA_VSYNC_END           0x0044

#define VGA_SSA_H               0x0030
#define VGA_SSA_L               0x0034
#define VGA_CR1B                0x006C
#define VGA_CR1D                0x0074
#define VGA_PAL_ADDR_READ       0x00A4
#define VGA_PAL_ADDR_WRITE      0x00A8
#define VGA_PIXEL_DATA          0x00AC
#define VGA_CLUT_LOAD           0x009c
#define VGA_CURSOR_PRESET       0x00E4
#define VGA_MISC_CONTROL        0x00e6
#define VGA_CURSOR_ADDR         0x00e8
#define VGA_CURSOR_X            0x00e0
#define VGA_CURSOR_Y            0x00e2
#define VGA_PAL_STATE           0x00b0

#define DTTR                    0xEA
#define CONTROL                 0x402

//
// host data port: in host data device
//
#define HD_PORT                 0x800

//
// 2D versions of some 3D registers shadowed in l3d.h:
// Most register defines are divided by four so that they can be added correctly
// to the global register file pointer, LL_State.pRegs, which is a dword pointer.
// Some 2D operations need these registers defined in their full glory for use
// with write_dev_regs:

///////////////////////////////////////////////////////
//  HostXY Unit Registers - Must use WRITE_DEV_REGS  //
///////////////////////////////////////////////////////

#define HXY_BASE0_ADDRESS_PTR   0x4200
#define HXY_BASE0_START_XY      0x4204
#define HXY_BASE0_EXTENT_XY     0x4208
#define HXY_BASE1_ADDRESS_PTR   0x4210
#define HXY_BASE1_OFFSET0       0x4214
#define HXY_BASE1_OFFSET1       0x4218
#define HXY_BASE1_LENGTH        0x421C
#define HXY_HOST_CTRL           0x4240

//
// Laguna Format 1 instruction useful defines
//

#define DEV_VGAMEM              0x00000000
#define DEV_VGAFB               0x00200000
#define DEV_VPORT               0x00400000
#define DEV_LPB                 0x00600000
#define DEV_MISC                0x00800000
#define DEV_ENG2D               0x00A00000
#define DEV_HD                  0x00C00000
#define DEV_FB                  0x00E00000
#define DEV_ROM                 0x01000000
#define DEV_ENG3D               0x01200000
#define DEV_HOSTXY              0x01400000
#define DEV_HOSTDATA            0x01600000

#define F1_ADR_MASK             0x0001FFC0
#define F1_CNT_MASK             0x0000003f
#define F1_STL_MASK             0x04000000
#define F1_ADR_SHIFT            6
#define F1_STL_SHIFT            26
#define F1_BEN_SHIFT            17
#define F1_BEN_MASK             0x001e0000

//
// Laguna Format 2 instruction useful defines
//

#define F2_STL_SHIFT            26
#define F2_ADR_SHIFT            2
#define F2_STL_MASK             0x04000000
#define F2_ADR_MASK             0x003ffffc
#define F2_INC_MASK             0x00000001

//
// Laguna events for Format 4 instructions
//

#define EV_VBLANK               0x00000001
#define EV_EVSYNC               0x00000002
#define EV_LINE_COMPARE         0x00000004
#define EV_BUFFER_SWITCH        0x00000008
#define EV_Z_BUFFER_COMPARE     0x00000010
#define EV_POLY_ENG_NOT_BUSY    0x00000020
#define EV_EXEC_ENG_3D_NOT_BUSY 0x00000040
#define EV_XY_ENG_NOT_BUSY      0x00000080
#define EV_BLT_ENG_NOT_BUSY     0x00000100
#define EV_BLT_WF_NOT_EMPTY     0x00000200
#define EV_DL_READY_STATUS      0x00000400

#define EV_FETCH_MODE           0x00000800
//
// Format 4 masks
//

#define F4_STL_SHIFT    26
#define F4_NOT_MASK     0x01000000
#define F4_STL_MASK     0x04000000
#define F4_EVN_MASK     0x000007ff

//
// Emulator macros for building Laguna operations in display list
//

#define write_dev_regs(dev, ben, adr, cnt, stl) \
    (WRITE_DEV_REGS                         |   \
  (((stl) << F1_STL_SHIFT) & F1_STL_MASK)   |   \
    (dev)                                   |   \
  (((ben) << F1_BEN_SHIFT) & F1_BEN_MASK)   |   \
  (((adr) << F1_ADR_SHIFT) & F1_ADR_MASK)   |   \
   ((cnt)                  & F1_CNT_MASK))

#define read_dev_regs(dev, adr, cnt, stl)       \
    (READ_DEV_REGS                          |   \
  (((stl) << F1_STL_SHIFT) & F1_STL_MASK)   |   \
    (dev)                                   |   \
  (((adr) << F1_ADR_SHIFT) & F1_ADR_MASK)   |   \
   ((cnt)                  & F1_CNT_MASK))

#define write_dest_addr(adr, inc, stl)          \
    (WRITE_DEST_ADDR                        |   \
  (((stl) << F2_STL_SHIFT) & F2_STL_MASK)   |   \
  (((adr) << F2_ADR_SHIFT) & F2_ADR_MASK)   |   \
   ((inc)                  & F2_INC_MASK))

#define wait_3d(evn, stl)                       \
    (WAIT                                   |   \
  (((stl) << F4_STL_SHIFT) & F4_STL_MASK)   |   \
   ((evn)                  & F4_EVN_MASK))

#define nwait_3d(evn, stl)                      \
    (WAIT                                   |   \
  (((stl) << F4_STL_SHIFT) & F4_STL_MASK)   |   \
                             F4_NOT_MASK    |   \
   ((evn)                  & F4_EVN_MASK))

// opcode common to the control instructions
//
#define CONTROL_OPCODE  0x68000000
#define NOP_SUB_OPCODE  0x00800000

#define nop_3d(stl)                             \
    (CONTROL_OPCODE | NOP_SUB_OPCODE | (stl << 26))

//#if 0
////  useful macros:
////
////  setreg, no cache: do not cache state for this register
////
//#define SETREGB_NC(reg, value)                                                      \
//    (*((BYTE *) ((BYTE *) LL_State.pRegs + reg)) = value)
//
//#define SETREGW_NC(reg, value)                                                      \
//    (*((WORD *) ((BYTE *) LL_State.pRegs + reg)) = value)
//
//#define SETREGD_NC(reg, value)                                                      \
//    (*((DWORD *) ((BYTE *) LL_State.pRegs + reg)) = value)
//
//#define SETREG_3D(reg, value)                                                       \
//    (*((DWORD *) (LL_State.pRegs + reg)) = value)
//
//// set 2d reg with cache
////
//#define SETREGD_2D(offset, reg, value)                                              \
//    (*((DWORD *) ((BYTE *) LL_State.pRegs + (offset))) = LL_State2D.reg = (value))
//
//// wait for events in coprocessor mode
////
//#if 0
//#define wait_and_3d(event)                                                          \
//    {                                                                               \
//        DWORD   status;                                                             \
//        while ((status = (*((DWORD *)LL_State.pRegs + PF_STATUS_3D)) & event)) {};  \
//    }
//#else
//#define wait_and_3d(event)                                                          \
//    {                                                                               \
//        while ((*((DWORD *)LL_State.pRegs + PF_STATUS_3D)) & event) {};             \
//    }
//#endif
//
//#define host_host(src, dst)                         \
//    ((src->dwFlags & BUFFER_IN_SYSTEM) &&           \
//     (dst->dwFlags & BUFFER_IN_SYSTEM))
//
//#define host_frame(src, dst)                        \
//    ((src->dwFlags & BUFFER_IN_SYSTEM) &&           \
//    !(dst->dwFlags & BUFFER_IN_SYSTEM))
//
//#define frame_host(src, dst)                        \
//    (!(src->dwFlags & BUFFER_IN_SYSTEM) &&          \
//      (dst->dwFlags & BUFFER_IN_SYSTEM))
//
//#define frame_frame(src, dst)                       \
//    (!(src->dwFlags & BUFFER_IN_SYSTEM) &&          \
//     !(dst->dwFlags & BUFFER_IN_SYSTEM))
//
//#define GetColor(pixel_mode, pColor, which)                         \
//    switch (pixel_mode)                                             \
//    {                                                               \
//        case PIXEL_MODE_332:                                        \
//            pColor->r =  LL_State2D.which & 0xe0;                   \
//            pColor->g = (LL_State2D.which & 0x1c) << 3;             \
//            pColor->b = (LL_State2D.which & 0x02) << 6;             \
//            break;                                                  \
//        case PIXEL_MODE_555:                                        \
//            pColor->r = (LL_State2D.which & 0x7c00) >> 7;           \
//            pColor->g = (LL_State2D.which & 0x03e0) >> 2;           \
//            pColor->b = (LL_State2D.which & 0x001f) << 3;           \
//            break;                                                  \
//        case PIXEL_MODE_565:                                        \
//            pColor->r = (LL_State2D.which & 0xf800) >> 8;           \
//            pColor->g = (LL_State2D.which & 0x07e0) >> 3;           \
//            pColor->b = (LL_State2D.which & 0x001f) << 3;           \
//            break;                                                  \
//        case PIXEL_MODE_A888:                                       \
//        case PIXEL_MODE_Z888:                                       \
//            pColor->r = (LL_State2D.which & 0xff0000) >> 16;        \
//            pColor->g = (LL_State2D.which & 0x00ff00) >> 8;         \
//            pColor->b = (LL_State2D.which & 0x0000ff);              \
//            break;                                                  \
//        default:                                                    \
//            pColor->r = 0;                                          \
//            pColor->g = 0;                                          \
//            pColor->b = 0;                                          \
//            break;                                                  \
//    }
//
//#define blt_buf_set_bpp(pBuf, bpp)                                  \
//    if (pBuf == LL_State.pBufZ)                                     \
//    {                                                               \
//        bpp = LL_State.Control0.Z_Stride_Control ? 8 : 16;          \
//    }                                                               \
//    else                                                            \
//    {                                                               \
//        bpp = LL_State.wBpp;                                        \
//    }
//
//#define blt_buf_set_pix_mode(pBuf, pmode)                           \
//    if (pBuf == LL_State.pBufZ)                                     \
//    {                                                               \
//        pmode = LL_State.Control0.Z_Stride_Control ?                \
//                PIXEL_MODE_332 : PIXEL_MODE_565;                    \
//    }                                                               \
//    else                                                            \
//    {                                                               \
//        pmode = LL_State.Control0.Pixel_Mode;                       \
//    }
//
//// pixels per dword
////
//#define px_per_dw(bpp)  (32 / (bpp))
//
//// bytes per pixel ... NOTE: don't use with 1 bpp!!
////
//#define by_per_px(bpp)  (bpp / 8)
//
//#define set_color(color, _r, _g, _b)    \
//        color.r = _r;                   \
//        color.g = _g;                   \
//        color.b = _b;
//
//#define set_vert(vert, _x, _y)          \
//        vert.x = _x;                    \
//        vert.y = _y;
//
//#define set_rect(rect, x1, y1, x2, y2)  \
//        rect.left   = x1;               \
//        rect.top    = y1;               \
//        rect.right  = x2;               \
//        rect.bottom = y2;
//
//#define print_2d_status(i)              \
//        printf("status register %d: %04x\n", i, *(WORD *)((BYTE *)LL_State.pRegs + STATUS))
//
//#define get_2d_status()                 \
//        (* (WORD *) ( (BYTE *) LL_State.pRegs + STATUS ) )
//#endif

#endif // _L2D_H_
#endif // WINNT_VER35
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\l3d.h ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1997, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         l3d.h
*
* DESCRIPTION:  546X 3D engine defines and structures
*
* AUTHOR:       Goran Devic, Mark Einkauf
*
***************************************************************************
***************************************************************************/
#ifndef _L3D_H_
#define _L3D_H_

/*********************************************************************
*   Defines and basic types
**********************************************************************/
#ifndef OPENGL_MCD	// LL3D's type.h redundant with basic type definitions in other DDK/msdev headers
#include "type.h"                   /* Include basic types           */
#endif // ndef OPENGL_MCD

/*********************************************************************
*
*   Library initialization defines
*
**********************************************************************/
#define LL_USE_BUFFER_B     0x0001  /* Use double buffering          */
#define LL_USE_BUFFER_Z     0x0002  /* Use Z buffer                  */
#define LL_BUFFER_Z_8BPP    0x0004  /* Use 8bpp instead of 16bpp Z   */
#define LL_BUFFER_Z888      0x0008  /* Only in 32bpp use Z888        */
#define LL_8BPP_INDEXED     0x0010  /* Only in 8bpp - indexed mode   */
#define LL_HARDWARE_CURSOR  0x0020  /* Use hardware cursor           */

/*********************************************************************
*
*   Buffer identification numbers and Z stride info. 
*
*   Used with LL_InitLib()
*
**********************************************************************/
#define LL_ID_BUFFER_A      0       /* ID of the primary buffer      */
#define LL_ID_BUFFER_B      1       /* ID of the secondary buffer    */
#define LL_ID_BUFFER_Z      2       /* ID of the Z buffer in RDRAM   */


/*********************************************************************
*
*   Destination defines for the objects
*
*   Used with LL_SetZBuffer
*
**********************************************************************/
#define LL_IN_RDRAM         0       /* Object is in the RDRAM memory */
#define LL_IN_HOST          1       /* Object is in Host memory      */


/*********************************************************************
*
*   Rendering mode
*
*   Used with LL_SetRenderingMode
*
**********************************************************************/
#define LL_PROCESSOR_MODE   0       /* Use processor mode            */
#define LL_COPROCESSOR_MODE 1       /* Use coprocessor indirect mode */


/*********************************************************************
*
*   Texture flag values
*
*   Used with LL_RegisterTexture
*
**********************************************************************/
#define LL_SYSTEM_ONLY      1       /* Put texture in system memory  */
#define LL_VIDEO_ONLY       2       /* Put texture in video memory   */
#define LL_DEFAULT          0       /* Try video, then system        */

/*********************************************************************
*
*   Texture types
*
*   Used with LL_RegisterTexture
*
**********************************************************************/
#define LL_TEX_4BPP         0       /* 4 Bpp indexed                 */
#define LL_TEX_8BPP         2       /* 8 Bpp indexed                 */
#define LL_TEX_332          3       /* 3:3:2 true color              */
#define LL_TEX_565          4       /* 5:6:5 true color              */
#define LL_TEX_1555         5       /* (mask):5:5:5 true color       */
#define LL_TEX_1888         6       /* (mask):8:8:8 true color       */
#define LL_TEX_8_ALPHA     10       /* alpha only                    */
#define LL_TEX_4444        12       /* 4:4:4:4 true color            */
#define LL_TEX_8888        14       /* 8:8:8:8 true color            */


/*********************************************************************
*
*   Cursor modes 
*
*   Used with LL_SetCursor        
*
**********************************************************************/
#define LL_CUR_DISABLE      0       /* Turn off cursor               */
#define LL_CUR_32x3         1       /* 32x32 cursor, 3 colors/t      */
#define LL_CUR_32x2         2       /* 32x32 cursor, 2 colors        */
#define LL_CUR_32x2H        3       /* 32x32 cursor, 2 colors+hghlt  */
#define LL_CUR_64x3         5       /* 64x64 cursor, 3 colors/t      */
#define LL_CUR_64x2         6       /* 64x64 cursor, 2 colors        */
#define LL_CUR_64x2H        7       /* 64x64 cursor, 2 colors+hghlt  */

//These are new for CGL 1.70, and are defined in CGL as:
#define LL_ALT_32x3         0x09
#define LL_ALT_32x2H        0x0A
#define LL_ALT_32x2         0x0B
#define LL_ALT_64x3         0x0D
#define LL_ALT_64x2H        0x0E
#define LL_ALT_64x2         0x0F

#define NEED_MOUSE_UPDATE   0x01 //if the coordinates of cursor need updated
#define MOUSE_IS_UPDATED    0x00 //if the coordinates have been updated

/*********************************************************************
*
*   Z Compare modes:
*
*   Used with LL_SetZCompareMode(mode), LL_GetZCompareMode()
*
**********************************************************************/
#define LL_Z_WRITE_GREATER_EQUAL   0x00000000  /* True if new >= old */
#define LL_Z_WRITE_GREATER         0x00000001  /* True if new >  old */
#define LL_Z_WRITE_LESS_EQUAL      0x00000002  /* True if new <= old */
#define LL_Z_WRITE_LESS            0x00000003  /* True if new <  old */
#define LL_Z_WRITE_NOT_EQUAL       0x00000004  /* True if new <> old */
#define LL_Z_WRITE_EQUAL           0x00000005  /* True if new =  old */

/*********************************************************************
*
*   Functional Z modes:
*
*   Used with LL_SetZMode(mode), LL_GetZMode()
*
**********************************************************************/
#define LL_Z_MODE_NORMAL           0x00000000  /* Normal operation   */
#define LL_Z_MODE_MASK             0x00000001  /* Z not written      */
#define LL_Z_MODE_ALWAYS           0x00000002  /* Z, color always wrt*/
#define LL_Z_MODE_ONLY             0x00000003  /* Color not written  */
#define LL_Z_MODE_HIT              0x00000004  /* collision dtct only*/



/*********************************************************************
*
*   Color compare controls
*
*   Used with LL_ColorBoundsControl( dwControl)
*
**********************************************************************/
#define LL_COLOR_SATURATE_ENABLE   0x00000040  /* for indexed mode   */
#define LL_COLOR_SATURATE_DISABLE  0x00000000  /* (default)          */

#define LL_COLOR_COMPARE_INCLUSIVE 0x00000400  /* tc modes           */
#define LL_COLOR_COMPARE_EXCLUSIVE 0x00000000  /* tc modes (default) */
#define LL_COLOR_COMPARE_BLUE      0x00000200  /* blue (default off) */
#define LL_COLOR_COMPARE_GREEN     0x00000100  /* green (default off)*/
#define LL_COLOR_COMPARE_RED       0x00000080  /* red (default off)  */


/*********************************************************************
*
*   Notes on Alpha blending and Lighting section:
*
*   If used separately, every combination of alpha mode and destination
*   is valid.  Note that if LL_ALPHA_DEST_INTERP or LL_LIGHTING_INTERP_RGB
*   are selected, color interpolators may not be used.
*
*   When using alpha blending and lighting at the same time, be careful
*   not to use Polyeng or LA-interpolators more than once.
*
**********************************************************************/
/*********************************************************************
*
*   Alpha mode:  Magnitude of alpha blending will be taken from
*       - constant alpha, use LL_SetConstantAlpha(src/new,dest/old)
*           this mode uses LA-interpolators
*       - interpolated, variable alpha from LA-interpolators
*           this mode also uses LA-interpolators
*       - alpha field from the frame buffer
*
*   Used with LL_SetAlphaMode(mode), LL_GetAlphaMode()
*
**********************************************************************/
#define LL_ALPHA_CONST             0x00000000  /* Constant alpha     */
#define LL_ALPHA_TEXTURE           0x00000001  /* Texture  alpha     */
#define LL_ALPHA_INTERP            0x00000002  /* Using LA interp.   */
#define LL_ALPHA_FRAME             0x00000003  /* Using frame values */

/*********************************************************************
*
*   Alpha destination: Selects where the second color input to the 
*       alpha multiplier comes from
*       - color from the frame buffer ("normal" alpha blending)
*       - constant color (also called fog) from COLOR0 register
*       - interpolated, shaded color from the polygon engine (also fog)
*           also LL_GOURAUD must be set in the flags
*           this mode uses Polyengine color registers
*
*   Fog: Use aliases LL_FOG_CONST and LL_FOG_INTERP to avoid fetching
*       colors from the frame and to set the fog color.
*
*   Used with LL_SetAlphaDestColor(mode), LL_GetAlphaDestColor()
*
**********************************************************************/
#define LL_ALPHA_DEST_FRAME        0x00000000  /* Using frame color  */
#define LL_ALPHA_DEST_CONST        0x00000001  /* Constant color     */
#define LL_ALPHA_DEST_INTERP       0x00000002  /* Using poly engine  */

#define LL_FOG_CONST               0x00000001  /* Constant fog       */
#define LL_FOG_INTERP              0x00000002  /* Using poly engine  */

/*********************************************************************
*
*   Lighting source: Selects the value for the lighting multiplier
*       - interpolated light from the polygon engine
*           load lighting values as r,g,b components
*           also LL_GOURAUD must be set in the flags
*           this mode uses Polyengine color registers
*       - interpolated light from the alpha interpolator
*           load lighting values as alpha components
*           this mode uses LA-interpolators
*       - constant light from the COLOR1 register
*
*   Used with LL_SetLightingSource(mode), LL_GetLightingSource()
*
**********************************************************************/
#define LL_LIGHTING_INTERP_RGB     0x00000000  /* Using poly engine  */
#define LL_LIGHTING_INTERP_ALPHA   0x00000001  /* Using LA interp.   */
#define LL_LIGHTING_CONST          0x00000002  /* Constant light     */
#define LL_LIGHTING_TEXTURE        0x00000003  /* FrameScaling Mode  */


/*********************************************************************
*
*   Rendering instruction modifiers
*
*   Used in dwFlags field with LL_POINT...LL_INDEXED_POLY
*
**********************************************************************/
#define LL_SAME_COLOR   0x00008000  /* Use previously loaded color   */
#define LL_Z_BUFFER     0x00002000  /* Use Z buffer                  */
#define LL_ALPHA        0x00000001  /* Do Alpha blending             */
#define LL_LIGHTING     0x00040000  /* Do lighting                   */
#define LL_STIPPLE      0x00080000  /* Enable stipple or             */
#define LL_PATTERN      0x00100000  /* Enable pattern or             */
#define LL_DITHER       0x00200000  /* Enable dither,use PATTERN_RAM */
#define LL_GOURAUD      0x00001000  /* Enable Gouraud shading        */
#define LL_TEXTURE      0x00020000  /* Use texture mapping           */
#define LL_PERSPECTIVE  0x00010000  /* Perspective corrected texture */
#define LL_TEX_FILTER   0x40000000  /* Filtered textures             */
#define LL_TEX_SATURATE 0x20000000  /* Texture saturation (opp wrap) */
#define LL_TEX_DECAL    0x10000000  /* Texture masking (1555,1888)   */
#define LL_TEX_DECAL_INTERP 0x18000000  /*Texture masking (1555,1888)*/

//positions in TxCtl0_3D register
#define CLMCD_TEX_FILTER       0x00040000  /* Filtered textures             */
#define CLMCD_TEX_U_SATURATE   0x00000008  /* Texture saturation (opp wrap) */
#define CLMCD_TEX_V_SATURATE   0x00000080  /* Texture saturation (opp wrap) */
#define CLMCD_TEX_DECAL        0x00200000  /* Texture masking (1555,1888)   */
#define CLMCD_TEX_DECAL_INTERP 0x00400000  /* Texture masking (1555,1888)   */
#define CLMCD_TEX_DECAL_POL    0x00100000  /* Texture masking (1555,1888)   */


/*********************************************************************
*
*   Type of the line mesh:
*       - lines are concatenated, each reusing the predecessor's
*         vertex as its first vertex
*       - first vertex defines the center of a "wheel" structure with
*         each succesive vertex defining the outer point
*       - list of independent pairs of vertices
*
**********************************************************************/
#define LL_LINE_STRIP   0x02000000  /* Line strip mesh of lines      */
#define LL_LINE_FAN     0x01000000  /* Line fan mesh of lines        */
#define LL_LINE_LIST    0x00000000  /* Line list mesh of lines       */


/*********************************************************************
*
*   Type of the polygon mesh:
*       - triangles are concatenated, each reusing the predecessor's
*         last two vertices as its own first two
*       - first vertex defines the center of a "wheel" structure with
*         each succesive vertex pair defining the outer points
*       - list of independent triplets of vertices
*
**********************************************************************/
#define LL_POLY_STRIP   0x02000000  /* Poly strip mesh of triangles  */
#define LL_POLY_FAN     0x01000000  /* Poly fan mesh of triangles    */
#define LL_POLY_LIST    0x00000000  /* Poly list mesh of triangles   */


/**************************************************************************
*
*   Commands for the bOp field of a batch cell
*
***************************************************************************/
#define LL_IDLE                     0x00 /* Stops Laguna execution        */
#define LL_NOP                      0x01 /* Does nothing                  */
                                    
#define LL_POINT                    0x02 /* Point primitive(s)            */
#define LL_LINE                     0x03 /* Line primitive(s)             */
#define LL_POLY                     0x04 /* Triangle primitive(s)         */
                                    
#define LL_SET_COLOR0               0x08 /* Sets color0 register w/dwFlags*/
#define LL_SET_COLOR1               0x09 /* Sets color1 register w/dwFlags*/

#define LL_SET_DEST_COLOR_BOUNDS    0x0B /* Sets the color bounds regs    */
#define LL_SET_CLIP_REGION          0x0C /* Sets clip region and flags    */
#define LL_SET_Z_MODE               0x0D /* Sets the Z functional mode    */
#define LL_SET_Z_BUFFER             0x0E /* Sets the location of the Zbuf */
#define LL_SET_Z_COMPARE_MODE       0x0F /* Sets the Z compare mode       */
#define LL_SET_ALPHA_MODE           0x10 /* Sets the alpha blending mode  */
#define LL_SET_CONSTANT_ALPHA       0x11 /* Sets the constants for alpha  */
#define LL_SET_ALPHA_DEST_COLOR     0x12 /* Sets the alpha destination col*/
#define LL_SET_LIGHTING_SOURCE      0x13 /* Sets the lighting source      */
#define LL_AALINE                   0x14 /* Anti-aliased True Color Line(s*/
#define LL_RAW_DATA                 0x15 /* Copy data into d-list         */
#define LL_QUALITY                  0x16 /* Sets the speed/quality dial   */
#define LL_SET_TEXTURE_COLOR_BOUNDS 0x17 /* Sets the texture color bounds */
#define LL_SET_PATTERN              0x18 /* Sets pattern registers */


/*********************************************************************
*
*   LL_Vert structure defines a vertex with its X,Y,Z coordinates.
*   Also, the coordinates on the texture that may be associated with
*   it are also stored in this structure as (U,V) fields.  If the 
*   texture is perspective corrected, the vertex' W factor is used.
*
*   The pixel on the screen that is associated with this vertex has
*   color 'index' (if THE indexed mode is used), or (r,g,b) if a true
*   color mode is used.
*
*   If alpha blending is used, alpha value is stored in the 'a' field.
*
*   Add DWORD values are fixed point 16:16.
*
**********************************************************************/
typedef struct                      /* Vertex structure              */
{
    DWORD  x;                       /* X screen coordinate           */
    DWORD  y;                       /* Y screen coordinate           */
    DWORD  z;                       /* Z coordinate                  */
    DWORD  u;                       /* Texture u coordinate          */
    DWORD  v;                       /* Texture v coordinate          */
    float  w;                       /* Perspective w factor          */

    union
    {
        BYTE index;                 /* Indexed color value           */
        struct
        {
            BYTE r;                 /* Red component                 */
            BYTE g;                 /* Green component               */
            BYTE b;                 /* Blue component                */
            BYTE a;                 /* Alpha component               */
        };
    };

} LL_Vert;


/*********************************************************************
*
*   LL_Batch structure holds the operation that is being requested,
*   along with its parameters.
*
*   The array of the vertices used in the current operation
*   is pointed to by pVert pointer.
*
**********************************************************************/
typedef struct                      /* Batch cell structure          */
{
    BYTE     bOp;                   /* Operation requested           */
    BYTE     bRop;                  /* Raster operation for 2D       */
    WORD     wBuf;                  /* Texture / Buffer designator   */
    WORD     wCount;                /* General purpose counter       */
    DWORD    dwFlags;               /* Operation flag modifiers      */
    LL_Vert *pVert;                 /* Pointer to the associated     */
                                    /*  array of vertices            */
} LL_Batch;


/*********************************************************************
*
*   LL_Pattern structure holds the pattern to be stored in the
*   PATTERN_RAM registers.  These values are used for pattern, 
*   dither or stipple (only one at a time).
*
**********************************************************************/
typedef struct                      /* pattern holding structure     */
{
    DWORD pat[ 8 ];                 /* 8 word pattern                */

} LL_Pattern;


/*********************************************************************
*
*   LL_Rect structure defines a general rectangular region
*
**********************************************************************/
typedef struct
{
    DWORD left;                     /* x1                            */
    DWORD top;                      /* y1                            */
    DWORD right;                    /* x2                            */
    DWORD bottom;                   /* y2                            */

} LL_Rect;


/*********************************************************************
*
*   LL_Color structure defines color by its components or index
*
**********************************************************************/
typedef struct
{
    union
    {
        struct                      /* If in true color mode,        */
        {
            BYTE r;                 /* Red component                 */
            BYTE g;                 /* Green component               */
            BYTE b;                 /* Blue component                */
        };
        BYTE index;                 /* Index if in 8bpp indexed mode */
    };

} LL_Color;

typedef struct {
    float   x;
    float   y;
    float   w;
    float   u;
    float   v;
} TEXTURE_VERTEX;


/*********************************************************************
*
*   LL_Texture structure defines a texture map
*
**********************************************************************/
typedef struct _LL_Texture
{
    void *pohTextureMap;            // control block for region containing map in offscreen memory
    MCDTEXTURE *pTex;               // ptr to texture in user memory
//  LL_Color * ColPalette;          /* Pointer to palette if indexed       */
//  BYTE  bMem;                     /* Index to the texture memory block   */
    DWORD dwTxCtlBits;
    float fWidth;                   /* Texture X dimension in texels       */
    float fHeight;                  /* Texture Y dimension in texels       */
    BYTE  bSizeMask;                /* Encoded size 0=16,... Y[7:4],X[3:0] */
    BYTE  bType;                    /* Texture type                        */
//  BYTE  fIndexed;                 /* True for indexed textures           */
//  BYTE  bLookupOffset;            /* Palette lookup offset (indexed only)*/
    WORD  wXloc;                    /* X offset location in bytes          */
    WORD  wYloc;                    /* Y offset location in lines          */
    float fLastDrvDraw;             /* time stamp, sort of */           

    BYTE  bAlphaInTexture;          
    BYTE  bNegativeMap;          
    BYTE  bMasking;          

    // doubly linked list pointers
   struct _LL_Texture*  prev;
   struct _LL_Texture*  next;

} LL_Texture;


/*********************************************************************
*
*   LL_DeviceState structure hold the information about the state 
*   of the graphics processor (hardware).
*
*   During the library initialization, the following fields have to
*   be initialized:
*
*       dwFlags with optional
*           LL_USE_BUFFER_B     or
*           LL_USE_BUFFER_Z     or
*           LL_BUFFER_Z_8BPP    or
*           LL_BUFFER_Z888      or
*           LL_8BPP_INDEXED     or
*           LL_HARDWARE_CURSOR 
*
*       dwDisplayListLen with the amount of memory to lock for the
*           physical graphics device display list (in bytes).
*
*       dwSystemTexturesLen with the total size for the system 
*           textures (in bytes)
*
**********************************************************************/
typedef struct
{
    /* These three fields may be set before calling the LL_InitLib function                */

    DWORD dwFlags;                  /* Init flags                                          */
    DWORD dwDisplayListLen;         /* Total size for the display lists in bytes           */
    DWORD dwSystemTexturesLen;      /* Total size for the system textures in bytes         */

    /* These variables may be used by the software                                         */

    DWORD *pRegs;                   /* Register apperture, pointer to memory mappped I/O   */
    BYTE  *pFrame;                  /* Frame apperture, pointer to the linear frame buffer */
    DWORD dwVRAM;                   /* Amount of video memory on the card in bytes         */
    WORD  wHoriz;                   /* Current horizontal resolution                       */
    WORD  wVert;                    /* Current vertical resolution                         */

} LL_DeviceState;


/*********************************************************************
*
*   LL_Point structure defines a general point coordinates
*
**********************************************************************/
typedef struct
{
    DWORD nX;                       /* x coordinate   */
    DWORD nY;                       /* y coordinate   */

} LL_Point;


/*********************************************************************
*
*   Font support structures and macros
*
**********************************************************************/
typedef struct                      // Font header structure
{
    WORD    nMinimum;               // Font minimum character code value
    WORD    nMaximum;               // Font maximum character code value
    WORD    nDefault;               // Font default character code value
    WORD    nHeight;                // Font height in pixels
    DWORD   nReserved;              // Font reserved data
    WORD    nIndex[];               // Font index array

} LL_FontHeader;


typedef struct                      // Font structure
{
    LL_FontHeader   *pHeader;       // Pointer to font header
    BYTE            *pBitmap;       // Pointer to font bitmap
    int             nID;            // Font buffer ID value
    char            cBreak;         // Break character value
    int             nExtra;         // Current break extra in pixels
    int             nLast;          // Previous break extra in pixels
    int             nSpace;         // Current font spacing in pixels
    int             nPrevious;      // Previous font spacing in pixels
    int             nAverage;       // Average font width in pixels
    int             nMaximum;       // Maximum font width in pixels

} LL_Font;

#define Y_EXTENT(Extent)    ((unsigned) (Extent) >> 16)
#define X_EXTENT(Extent)    ((Extent) & 0xFFFF)

#define TEX_MASK_EN					0x00200000
#define TEX_HIPRECISION_2NDORDER    0x00800000  // 8.24 vs. 16.16 2nd order terms

#ifdef CGL // Goran will have equivalent soon??...

#define LL_PIXEL_MASK_DISABLE		0x00000000
#define LL_PIXEL_MASK_ENABLE	   	0x00000001  

// TX_CTL0_3D values
#define LL_TEX_U_OVF_SAT_EN 		0x00000004
#define LL_TEX_V_OVF_SAT_EN 		0x00000080
#define LL_TEXMODE_A888				0x00000600	
#define LL_TEXMODE_A555				0x00000500
#define LL_TEXMODE_565				0x00000400	// not used by CGL
#define LL_TEXMODE_332				0x00000300
#define LL_TEXMODE_8MAP				0x00000200
#define LL_TEXMODE_4MAP				0x00000000	// not used by CGL

#define TEX_MASK_FUNC				0x00400000
#define TEX_MASK_EN					0x00200000
#define TEX_MASK_POL				0x00100000
#define TEX_HIPRECISION_2NDORDER    0x00800000  // 8.24 vs. 16.16 2nd order terms

#define LL_TEX_FILTER_ENABLE		0x00040000

// TX_CTL1_3D values
#define CCOMP_INCLUSIVE				0x08000000
#define TX_BLU_COMP					0x04000000
#define TX_GRN_COMP					0x02000000
#define TX_RED_COMP					0x01000000

#define ABS(a)		(((a) < 0) ? -(a) : (a))

#endif // CGL

// BEGIN Chris' additions                          //
typedef unsigned long ULONG;					   //
typedef ULONG * PULONG ;						   //
typedef unsigned short UWORD ;					   //
typedef UWORD * PUWORD ;						   //
typedef unsigned char UBYTE;					   //
typedef UBYTE * PUBYTE;							   //
typedef struct {								   //
 unsigned char bBlue,bGreen,bRed,bAlpha;		   //
} LL_COLOR_ST;//this mimics the CGL_COLOR_ST.Should we include CGL in this library instead of mimicing this struct?//
#define num_of_regs     42                         //
#define num_of_insignificant_regs 46               //
#define num_of_modes    70						   //

#define LL_DISABLE   	  0x00
#define LL_32x32x3   	  0x01
#define LL_32x32x2HL 	  0x02
#define LL_32x32x2   	  0x03
#define LL_64x64x3   	  0x05
#define LL_64x64x2HL 	  0x06
#define LL_64x64x2   	  0x07

// following was moved here from setmode.c
#ifdef B4_REALHW
/* Defines the code for the 5462 chip that is the underlying         */
/* hardware for the testing before 5464 comes out.  This code should */
/* then be modified to reflect real code returned by the BIOS        */
/* function 12h subfunction 80h (Inquire VGA type)                   */
#define EBIOS_CLGD5462      0x60    /* BIOS Laguna 1 signature       */
#define EBIOS_CLGD5464      0xD4    /* BIOS Laguna 3D signature      */
#define EBIOS_CLGD5464B     0xD0    /* BIOS Laguna 3D alt signature  */
#else
/* Defines the code for the 5462 chip that is the underlying         */
/* hardware for the testing before 5464 comes out.  This code should */
/* then be modified to reflect real code returned by the BIOS        */
/* function 12h subfunction 80h (Inquire VGA type)                   */
#define EBIOS_CLGD5462      0x60    /* BIOS Laguna 1 signature       */
#define EBIOS_CLGD5464      0x64    /* BIOS Laguna 3D signature      */
#define EBIOS_CLGD5464B     0x61    /* BIOS Laguna 3D alt signature  */
#endif

// END Chris' additions


/*********************************************************************
*
*   Error codes
*
**********************************************************************/
#define LL_OK                   0x0000  // There was no error
#define LL_ERROR            0xffffffff  // Generic error prefix

#define LLE_PCX_FILE_OPEN       0x0002  // Error opening file
#define LLE_PCX_READ_HEADER     0x0003  // Error reading the header
#define LLE_PCX_NOT_SUITABLE    0x0004  // Not a suitable PCX file
#define LLE_PCX_PALETTE_READ    0x0005  // Error reading the palette
#define LLE_PCX_PALETTE_SEEK    0x0006  // Error seeking the palette
#define LLE_PCX_ALLOC_PALETTE   0x0007  // Error allocating memory

#define LLE_TEX_ALLOC           0x0008  // Texture memory allocation failure
#define LLE_TEX_BAD_ID          0x0009  // Invalid texture ID
#define LLE_TEX_TOO_MANY        0x000a  // Too many textures
#define LLE_TEX_DIMENSION       0x000b  // Invalid texture dimensions
#define LLE_TEX_TYPE            0x000c  // Invalid texture type
#define LLE_TEX_STORAGE         0x000d  // Invalid storage type
#define LLE_TEX_LOCKED          0x000e  // Use of locked texture
#define LLE_TEX_NOT_LOCKED      0x000f  // Unlocking of unlocked texture

#define LLE_BUF_CONFIG          0x0010  // Wrong buffers configuration
#define LLE_BUF_PITCH           0x0011  // Invalid buffer pitch
#define LLE_BUF_NUM             0x0012  // Too many buffers
#define LLE_BUF_ALLOC           0x0013  // Error allocating buffer
#define LLE_BUF_BAD_ID          0x0014  // Invalid buffer ID
#define LLE_BUF_FREE            0x0015  // Buffer already free
#define LLE_BUF_FREE_VIDEO      0x0016  // Cannot free a buffer in vram
#define LLE_BUF_NOT_ALLOC       0x0017  // Buffer was not allocated

#define LLE_INI_NOT_LAGUNA      0x0018  // Wrong hardware (from extended BIOS)
#define LLE_INI_MODE            0x0019  // Invalid graphcs mode
#define LLE_INI_DL_LEN          0x001a  // Invalid display list size
#define LLE_INI_ALLOC_DL        0x001b  // D-list allocation error
#define LLE_INI_Z_BUFFER        0x001c  // Invalid Z buffer placement

#define LLE_FON_LOAD            0x001d  // Error loading font
#define LLE_FON_ALLOC           0x001e  // Error allocating font memory


/*********************************************************************
*
*   Function prototypes
*
**********************************************************************/

// Init/Execute Functions
//
extern DWORD LL_InitLib( VOID *ppdev );
#ifndef CGL // modemon way (mode.ini)
extern DWORD LL_InitGraph( LL_DeviceState *DC, char *sController, char *sMode );
#else // cgl's dll (embedded mode tables)
extern DWORD LL_InitGraph( LL_DeviceState *DC, char *sController, int Mode );
#endif
extern DWORD LL_CloseGraph( LL_DeviceState *DC );
extern void LL_QueueOp( LL_Batch *pBatch );
extern void LL_Execute( LL_Batch * pBatch );
extern void LL_Wait();
extern void LL_SetRenderingMode( DWORD dwMode );
#ifndef CGL // CGL has own version as of 6/24/96 - ChrisS may merge
extern void LL_SetPalette( LL_Color * Col, BYTE first, int count );
#endif
extern BYTE LL_SpeedQualityDial( int SpeedQuality );

// Buffer Functions
//
extern DWORD LL_AllocSystemBuffer( DWORD Xdim, DWORD Ydim, DWORD pitch );
extern DWORD LL_RegisterUserBuffer( BYTE * pMem, DWORD Xdim, DWORD Ydim, DWORD pitch );
extern DWORD LL_FreeSystemBuffer( DWORD dwBufID );

// Texture Management Functions
//
#ifndef CGL
extern DWORD LL_RegisterTexture( DWORD dwFlags, WORD wWidth, WORD wHeight, BYTE bType );
#else
extern DWORD LL_RegisterTexture( DWORD dwFlags, WORD wWidth, WORD wBufWidth, WORD wHeight, BYTE bType, DWORD dwAddress );
#endif
extern DWORD LL_FreeTexture( DWORD dwID );
extern LL_Texture * LL_LockTexture( DWORD dwID );
extern DWORD LL_UnLockTexture( DWORD dwID );
extern DWORD LL_SetTexturePaletteOffset( DWORD dwID, BYTE bOffset );
extern void UpdateTextureInfo();


// Control Functions
//
extern void LL_SetZBuffer( DWORD buf_num );
extern void LL_SetZCompareMode( DWORD dwZCompareMode );
extern DWORD LL_GetZCompareMode();
extern void LL_SetZMode( DWORD dwZMode );
extern DWORD LL_GetZMode();
extern void LL_SetAlphaMode( DWORD dwAlphaMode );
extern DWORD LL_GetAlphaMode();
extern void LL_SetAlphaDestColor( DWORD dwAlphaDestColor );
extern DWORD LL_GetAlphaDestColor();
extern void LL_SetLightingSource( DWORD dwLighting );
extern DWORD LL_GetLightingSource();
extern void LL_SetClipRegion( LL_Rect * rect );
extern void LL_GetClipRegion( LL_Rect * rect );
extern void LL_SetPattern( LL_Pattern *Pattern );
extern void LL_GetPattern( LL_Pattern *Pattern );
extern void LL_SetPatternOffset( BYTE bOffsetX, BYTE bOffsetY );
extern void LL_GetPatternOffset( BYTE * pbOffsetX, BYTE * pbOffsetY );

extern void LL_SetTextureColorBounds( DWORD dwControl, LL_Color * Min, LL_Color * Max );
extern void LL_SetDestColorBounds( DWORD dwControl, LL_Color * Min, LL_Color * Max );

extern void LL_SetColor0( DWORD dwColor0 );
extern void LL_SetColor1( DWORD dwColor1 );
extern void LL_GetColorRegisters( DWORD * pdwColor0, DWORD * pdwColor1 );
extern void LL_SetConstantAlpha( WORD wSource, WORD wDestination );

// Hardware cursor / Mouse functions
//
#ifndef CGL // CGL has own version as of 6/24/96 - ChrisS may merge
extern void LL_SetCursor( BYTE bMode, LL_Color * pColor, BYTE * pbCursor);
extern void LL_SetCursorPos( WORD wX, WORD wY );
#endif // CGL
extern void LL_GetMouseStatus( WORD * pwX, WORD * pwY, WORD * pwButtons );
extern void LL_SetMouseCallback( void (far *fnCallback)( WORD wX, WORD wY, WORD wButtons ) );
extern void LL_SetCursorHotSpot( BYTE bX, BYTE bY );

// Font functions
//
extern LL_Font * LL_FontLoad( char * pName );
extern LL_Font * LL_FontUnload( LL_Font * pFont );
extern int LL_FontExtent( LL_Font * pFont, char * pString );
extern int LL_FontWrite( LL_Font * pFont, LL_Point * pPoint, LL_Rect * pClip, char *pString );

// Support Functons
//
extern void DumpDisplayList( DWORD *pPtr, DWORD dwLen );
extern DWORD LL_PCX_Load( LL_Texture * pTex, char * sName, WORD wAlphaIndex );
extern DWORD LL_PCX_Load_Buffer( DWORD dwBufID, char * sName, WORD wAlphaIndex, BYTE bType );
extern char * LL_ErrorStr( DWORD error_code );



#endif // _L3D_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\driver.h ===
/******************************Module*Header*******************************\
 *
 * Module Name: driver.h
 *
 * contains prototypes for the driver.
 *
 * Copyright (c) 1992 Microsoft Corporation
 * Copyright (c) 1995 Cirrus Logic, Inc.
 *
 * Cirrus extensions by Noel VanHook
 *
 * $Log:   X:/log/laguna/nt35/displays/cl546x/DRIVER.H  $
* 
*    Rev 1.70   Mar 25 1998 16:33:54   frido
* Added dwOverlayCount and dwCONTROL2Save variables.
* 
*    Rev 1.69   Mar 04 1998 14:42:26   frido
* Added shadowFGCOLOR.
* 
*    Rev 1.68   Feb 27 1998 17:01:14   frido
* Added shadowQFREE register.
* 
*    Rev 1.67   Jan 20 1998 11:41:52   frido
* Changed fDataStreaming into dwDataStreaming.
* Added shadow variables for BGCOLOR and DRAWBLTDEF registers.
* 
*    Rev 1.66   Jan 16 1998 14:07:38   frido
* Changed SOLID_COLOR_FILL so it uses the pattern.
* 
*    Rev 1.65   Nov 03 1997 15:53:44   frido
* Added fDataStreaming variable to PDEV structure.
* 
*    Rev 1.64   16 Oct 1997 09:47:38   bennyn
* Added bPrevModeDDOutOfVideoMem to PDEV
* 
*    Rev 1.63   18 Sep 1997 16:12:02   bennyn
* 
* Fixed NT 3.51 compile/link problem
* 
*    Rev 1.62   12 Sep 1997 12:04:14   bennyn
* 
* Added DD overlay support
* 
*    Rev 1.61   29 Aug 1997 17:08:36   RUSSL
* Added overlay support
*
*    Rev 1.60   18 Aug 1997 09:17:50   FRIDO
* Added fields for bitmap filter.
*
*    Rev 1.59   11 Aug 1997 14:11:00   bennyn
*
* Enabled GetScanLine support
*
*    Rev 1.58   08 Aug 1997 14:46:20   FRIDO
* Added support for new memory manager.
*
*    Rev 1.57   22 Jul 1997 12:31:10   bennyn
* Added dwLgVenID to PDEV
*
*    Rev 1.56   02 Jul 1997 15:13:02   noelv
*
* Added prototype for LgMatchDriverToChip()
*
*    Rev 1.55   20 Jun 1997 13:27:34   bennyn
*
* Eliminated power manager data area from PDEV
*
*    Rev 1.54   23 May 1997 15:40:16   noelv
* Added chip revision to PDEV
*
*    Rev 1.53   29 Apr 1997 16:26:26   noelv
* Added SWAT code.
* SWAT:
* SWAT:    Rev 1.6   24 Apr 1997 12:05:22   frido
* SWAT: Fixed compiler bugs.
* SWAT:
* SWAT:    Rev 1.5   24 Apr 1997 10:39:50   frido
* SWAT: NT140b09 merge.
* SWAT: Removed memory manager changes for now.
*
*    Rev 1.52   22 Apr 1997 11:03:22   noelv
* Added forward compatible chip ids.
* SWAT:
* SWAT:    Rev 1.4   18 Apr 1997 17:21:26   frido
* SWAT: Fixed a typo (OFM_HandleChain).
* SWAT:
* SWAT:    Rev 1.3   17 Apr 1997 23:16:20   frido
* SWAT: NT140b07 merge.
*
*    Rev 1.51   16 Apr 1997 10:52:18   bennyn
*
* Should use PFN_DRVSRCMBLT instead of PFN_DRVSTRBLTX for pfnDrvSrcMBlt.
* SWAT:
* SWAT:    Rev 1.2   11 Apr 1997 12:38:22   frido
* SWAT: Added OFM_HandleChain.
* SWAT:
* SWAT:    Rev 1.1   09 Apr 1997 17:34:30   frido
* SWAT: Added fPreAllocate and nPages.
* SWAT: Added FONTCELL structure and variables.
*
*    Rev 1.50   08 Apr 1997 11:38:02   einkauf
* pdev adds to complete mcd
*
*    Rev 1.49   04 Apr 1997 16:51:26   noelv
*
* Added pointer for new Direct Draw functions.
*
*    Rev 1.48   27 Mar 1997 14:31:54   noelv
*
* Added new DDRAW function.
*
*    Rev 1.47   21 Mar 1997 13:38:40   noelv
*
* Synced PDEV with LAGUNA.INC
*
*    Rev 1.46   26 Feb 1997 13:21:26   noelv
* Disabel MCD code for NT 3.5x
*
*    Rev 1.45   26 Feb 1997 10:45:38   noelv
* Added OpenGL MCD code from ADC.
*
*    Rev 1.44   19 Feb 1997 13:08:38   noelv
* Added translation table cache
*
*    Rev 1.43   06 Feb 1997 10:36:10   noelv
*
* Moved MEMMGR andBRUSH stuff to their own header files.
*
*    Rev 1.42   23 Jan 1997 17:13:02   bennyn
*
* Modified to support 5465 DD
*
*    Rev 1.41   20 Jan 1997 14:49:34   bennyn
*
* Added blt65 prototypes
*
*    Rev 1.40   16 Jan 1997 11:35:16   bennyn
*
* Added power manager variables to PDEV
*
*    Rev 1.39   17 Dec 1996 16:44:54   SueS
* Changed parameters in CloseLogFile prototype.
*
*    Rev 1.38   10 Dec 1996 13:28:08   bennyn
* Added ulFreq to PDEV
*
*    Rev 1.37   05 Dec 1996 08:51:58   SueS
* Added function to help with formatting strings for DirectDraw logging.
* Added defines if logging is turned off.
*
*    Rev 1.36   27 Nov 1996 11:32:36   noelv
* Disabled Magic Bitmap.  Yeah!!!
*
*    Rev 1.35   26 Nov 1996 10:22:56   SueS
* Added new function parameters and variables for logging with buffering.
*
*    Rev 1.34   18 Nov 1996 10:15:20   bennyn
*
* Added grFormat to PDEV
*
*    Rev 1.33   13 Nov 1996 17:06:10   SueS
* Added function prototypes for file logging functions.
*
*    Rev 1.32   12 Nov 1996 15:18:34   bennyn
*
* Added handle for DD blt scratch buffer
*
*    Rev 1.31   07 Nov 1996 16:13:40   bennyn
*
* Added support to alloc offscn mem in DD createsurface
*
*    Rev 1.30   01 Nov 1996 09:20:40   BENNYN
* Added support for shareable DD blt code
*
*    Rev 1.29   31 Oct 1996 11:14:42   noelv
*
* Split common buffer into two buffers.
*
*    Rev 1.28   25 Oct 1996 11:52:14   noelv
* added second common buffer
*
*    Rev 1.27   24 Oct 1996 14:27:32   noelv
* Added common buffer for bus mastering.
*
*    Rev 1.26   23 Oct 1996 14:39:04   BENNYN
* Added YUV cursor variables to PDEV
*
*    Rev 1.25   04 Oct 1996 16:50:46   bennyn
*
* Added DirectDraw YVU support
*
*    Rev 1.24   18 Sep 1996 13:57:44   bennyn
* Modified to support DD stretchBLT
*
*    Rev 1.23   22 Aug 1996 18:14:48   noelv
* Frido bug fix release 8-22.
*
*    Rev 1.22   20 Aug 1996 11:04:54   noelv
* Bugfix release from Frido 8-19-96
*
*    Rev 1.2   17 Aug 1996 13:40:28   frido
* New release from Bellevue.
*
*    Rev 1.1   15 Aug 1996 11:35:08   frido
* Changed to conform to the precompiled header.
*
*    Rev 1.0   14 Aug 1996 17:16:36   frido
* Initial revision.
*
*    Rev 1.20   25 Jul 1996 15:52:56   bennyn
* Modified for DirectDraw
*
*    Rev 1.19   16 Jul 1996 14:26:04   BENNYN
*
*    Rev 1.18   11 Jul 1996 15:53:24   bennyn
*
* Added DirectDraw support
 *
 *    Rev 1.17   23 May 1996 16:22:16   BENNYN
 * Added SubFreeQ declarations
 *
 *    Rev 1.16   17 May 1996 12:04:52   bennyn
 * Added #define DBGBREAKPOINT
 *
 *    Rev 1.15   08 May 1996 17:02:04   noelv
 * preallocated device bitmap.
 *
 *    Rev 1.14   03 May 1996 15:06:34   noelv
 *
 * Added flag to turn font cache on and off
 *
 *    Rev 1.13   01 May 1996 10:58:44   bennyn
 *
 * Modified for NT4.0
 *
 *    Rev 1.12   25 Apr 1996 22:42:52   noelv
 * Cleaned up data logging some.
 *
 *    Rev 1.11   10 Apr 1996 14:15:42   NOELV
 *
 * Frido release 27
 *
 *    Rev 1.20   07 Apr 1996 17:12:26   frido
 * Added solid brush cache.
 *
 *    Rev 1.19   01 Apr 1996 13:58:18   frido
 * Changed layout of brush cache.
 *
 *    Rev 1.18   28 Mar 1996 19:57:38   frido
 * New Bellevue release.
 *
 *    Rev 1.8   25 Mar 1996 18:57:52   noelv
 * Added define for turning cursor bug fix on and off.
 *
 *    Rev 1.7   14 Mar 1996 09:36:22   andys
 * Added dcTileWidth and dcSRAMWidth
 *
 *    Rev 1.6   12 Mar 1996 15:46:42   noelv
 * Added support file Stroke and Fill
 *
 *    Rev 1.5   11 Mar 1996 11:54:20   noelv
 *
 * Added log file pointer to PDEV
 *
 *    Rev 1.4   07 Mar 1996 18:21:52   bennyn
 *
 *
 *    Rev 1.3   05 Mar 1996 11:59:38   noelv
 * Frido version 19
 *
 *    Rev 1.13   29 Feb 1996 19:56:40   frido
 * Added bEnable to PDEV structure.
 *
 *    Rev 1.12   27 Feb 1996 16:38:34   frido
 * Changed DSURF structure.
 * Added device bitmap store/restore.
 *
 *    Rev 1.11   26 Feb 1996 23:38:18   frido
 * Added function pointers for ScreenToHost and HostToScreen.
 *
 *    Rev 1.10   24 Feb 1996 01:24:26   frido
 * Added device bitmaps.
 *
 *    Rev 1.9   17 Feb 1996 21:45:30   frido
 *
 *
 *    Rev 1.8   13 Feb 1996 16:51:10   frido
 * Changed the layout of the PDEV structure.
 * Changed the layout of all brush caches.
 * Changed the number of brush caches.
 *
 *    Rev 1.7   10 Feb 1996 21:42:26   frido
 * Split monochrome and colored translation brushes.
 *
 *    Rev 1.6   08 Feb 1996 00:18:38   frido
 * Changed number of XLATE caches to 8.
 *
 *    Rev 1.5   05 Feb 1996 17:35:52   frido
 * Added translation cache.
 *
 *    Rev 1.4   03 Feb 1996 13:38:32   frido
 * Use the compile switch "-Dfrido=0" to disable my extensions.
 *
 *    Rev 1.3   25 Jan 1996 12:46:54   frido
 * Added font counter ID to PDEV structure.
 *
 *    Rev 1.2   20 Jan 1996 22:13:44   frido
 * Added dither cache.
 *
\**************************************************************************/

#include "swat.h"
#include "debug.h"
#include "laguna.h"
#include "optimize.h"
#include "memmgr.h"
#include "brush.h"
#include "xlate.h"
#if MEMMGR
#include "mmCore.h"    // new memory manager
#endif

#if DRIVER_5465 && defined(OVERLAY)
#include "overlay.h"
#include "5465bw.h"
#include "bw.h"
#endif

#ifdef WINNT_VER40
#define ALLOC_TAG 'XGLC'		// Memory Tag

#define DBGBREAKPOINT()   EngDebugBreak()
#define MEM_ALLOC(FLAGS, SIZE, TAG) EngAllocMem((FLAGS), (SIZE), (TAG))
#define MEMORY_FREE(pMEM) EngFreeMem(pMEM)
#define DEVICE_IO_CTRL(A, B, C, D, E, F, G, H) (EngDeviceIoControl((A), (B), (C), (D), (E), (F), (G)) == 0)

#else

#define DBGBREAKPOINT()   DbgBreakPoint()
#define MEM_ALLOC(FLAGS, SIZE) LocalAlloc((FLAGS), (SIZE))
#define MEMORY_FREE(pMEM) LocalFree(pMEM)
#define DEVICE_IO_CTRL(A, B, C, D, E, F, G, H) DeviceIoControl((A), (B), (C), (D), (E), (F), (G), (H))

#endif


#ifndef frido
  #define frido 1
#endif

#if WINBENCH96
    #define MAGIC_SIZEX  400
    #define MAGIC_SIZEY  90
#endif

#define S2H_USE_ENGINE 0	// ScreenToHost flag
                           //	0 - Use direct access to screen buffer
                           //	1 - Use hardware


//
// These specify how much the desktop should be shrunk to allow off screen
// memory to be visible on screen.
// For example: if OFFSCREEN_LINES is 100, the desktop height will be reduced
// by 100 lines, and the bottom 100 screen lines will be the first 100 lines
// of off screen memory.  This allows us to view and debug cached brushes, etc.
//
#define OFFSCREEN_LINES 0
#define OFFSCREEN_COLS 0


typedef BOOL COPYFN(SURFOBJ *psoTrg, SURFOBJ *psoSrc, XLATEOBJ *pxlo,
                    RECTL *prclTrg, POINTL *pptlSrc, ULONG ulDRAWBLTDEF);




/*
 *	Be sure to synchronize these structures with those in i386\Laguna.inc!
 */

#pragma pack(1)

/*****************************************************************************\
 * DirectDraw
\*****************************************************************************/
enum SSREGNAMES
{
  ACCUM,
  MAJ,
  MIN,
  MAX_REGS
};

// Allocate offscreen memory for DD in createsurface instead of
// DD enable
#define ALLOC_IN_CREATESURFACE

//#define DDDRV_GETSCANLINE
#define RDRAM_8BIT

// Stuff for tidying up access to grFormat
#define FMT_VCLK_DIV2   0x4000
#define FMT_GRX_MASK    0x3e00  // Mask for the Graphics depth & format fields
#define FMT_GRX_GAMMA   0x0800
#define FMT_VID_MASK    0x003e  // Mask for the Vide depth & video format fields
#define FMT_VID_GAMMA   0x0001

#define FMT_8BPP        0
#define FMT_16BPP       1
#define FMT_24BPP       2
#define FMT_32BPP       3

#define FMT_VID_COLORDEPTH_SHIFT  4
#define FMT_VID_8BPP        (FMT_8BPP  << FMT_VID_COLORDEPTH_SHIFT)
#define FMT_VID_16BPP       (FMT_16BPP << FMT_VID_COLORDEPTH_SHIFT)
#define FMT_VID_24BPP       (FMT_24BPP << FMT_VID_COLORDEPTH_SHIFT)
#define FMT_VID_32BPP       (FMT_32BPP << FMT_VID_COLORDEPTH_SHIFT)

#define FMT_GRX_COLORDEPTH_SHIFT  12
#define FMT_GRX_8BPP        (FMT_8BPP  << FMT_GRX_COLORDEPTH_SHIFT)
#define FMT_GRX_16BPP       (FMT_16BPP << FMT_GRX_COLORDEPTH_SHIFT)
#define FMT_GRX_24BPP       (FMT_24BPP << FMT_GRX_COLORDEPTH_SHIFT)
#define FMT_GRX_32BPP       (FMT_32BPP << FMT_GRX_COLORDEPTH_SHIFT)

#define FMT_PALETTIZED  0
#define FMT_GREYSCALE   1
#define FMT_RGB         2
#define FMT_ACCUPAK     4
#define FMT_YUV422      5
#define FMT_YUV444      6

#define FMT_VID_FORMAT_SHIFT  1
#define FMT_VID_PALETTIZED  (FMT_PALETTIZED << FMT_VID_FORMAT_SHIFT)
#define FMT_VID_GREYSCALE   (FMT_GREYSCALE  << FMT_VID_FORMAT_SHIFT)
#define FMT_VID_RGB         (FMT_RGB        << FMT_VID_FORMAT_SHIFT)
#define FMT_VID_ACCUPAK     (FMT_ACCUPAK    << FMT_VID_FORMAT_SHIFT)
#define FMT_VID_YUV422      (FMT_YUV422     << FMT_VID_FORMAT_SHIFT)
#define FMT_VID_YUV444      (FMT_YUV444     << FMT_VID_FORMAT_SHIFT)

#define FMT_GRX_FORMAT_SHIFT  9
#define FMT_GRX_PALETTIZED  (FMT_PALETTIZED << FMT_GRX_FORMAT_SHIFT)
#define FMT_GRX_GREYSCALE   (FMT_GREYSCALE  << FMT_GRX_FORMAT_SHIFT)
#define FMT_GRX_RGB         (FMT_RGB        << FMT_GRX_FORMAT_SHIFT)
#define FMT_GRX_ACCUPAK     (FMT_ACCUPAK    << FMT_GRX_FORMAT_SHIFT)
#define FMT_GRX_YUV422      (FMT_YUV422     << FMT_GRX_FORMAT_SHIFT)
#define FMT_GRX_YUV444      (FMT_YUV444     << FMT_GRX_FORMAT_SHIFT)

// STOP_BLT_[1,2,3] Register Fields
#define ENABLE_VIDEO_WINDOW   0x80
#define ENABLE_VIDEO_FORMAT   0x40

// External Overlay Control Register Fields
#define ENABLE_RAMBUS_9TH_BIT 0x01

#define SET_DRVSEM_YUV()    (pDriverData->DrvSemaphore |=  DRVSEM_YUV_ON)
#define CLR_DRVSEM_YUV()    (pDriverData->DrvSemaphore &= ~DRVSEM_YUV_ON)

// IN_VBLANK tests to see if the hardware is currently in the vertical blank.
#define IN_VBLANK         (_inp(0x3da) & 8)
#define IN_DISPLAY        (!IN_VBLANK)

// IN_DISPLAYENABLE tests to see if the display is enable
#define IN_DISPLAYENABLE  (_inp(0x3da) & 1)

#define BITSPERPIXEL   (ppdev->ulBitCount)
#define BYTESPERPIXEL  (BITSPERPIXEL / 8)

#define BYTE1FROMDWORD(dw)  ((BYTE)dw)
#define BYTE2FROMDWORD(dw)  ((BYTE)((DWORD)dw >> 8))
#define BYTE3FROMDWORD(dw)  ((BYTE)((DWORD)dw >> 16))
#define BYTE4FROMDWORD(dw)  ((BYTE)((DWORD)dw >> 24))

// Bits defined in DrvSemaphore
//	Be sure to synchronize these structures with those in i386\Laguna.inc!
#define DRVSEM_CURSOR_REMOVED_BIT   0
#define DRVSEM_HW_CURSOR_BIT        1
#define DRVSEM_IN_USE_BIT           2
#define DRVSEM_NEW_CURSOR_XY_BIT    3
#define DRVSEM_CHECK_CURSOR_BIT     4
#define DRVSEM_CURSOR_IN_USE_BIT    5
#define DRVSEM_CURSOR_CHANGED_BIT   6
#define DRVSEM_3D_BUSY_BIT          7
#define DRVSEM_MISSED_SET_BIT       8
#define DRVSEM_YUV_ON_BIT           9
#define DRVSEM_DISABLE_SETS_BIT     10
#define DRVSEM_YUV_RECT_VALID_BIT   11

// the corresponding mask values
//	Be sure to synchronize these structures with those in i386\Laguna.inc!
#define DRVSEM_CHECK_CURSOR         (1 << DRVSEM_CHECK_CURSOR_BIT)
#define DRVSEM_NEW_CURSOR_XY        (1 << DRVSEM_NEW_CURSOR_XY_BIT)
#define DRVSEM_IN_USE               (1 << DRVSEM_IN_USE_BIT)
#define DRVSEM_CURSOR_REMOVED       (1 << DRVSEM_CURSOR_REMOVED_BIT)
#define DRVSEM_HW_CURSOR            (1 << DRVSEM_HW_CURSOR_BIT)
#define DRVSEM_CURSOR_IN_USE        (1 << DRVSEM_CURSOR_IN_USE_BIT)
#define DRVSEM_CURSOR_CHANGED       (1 << DRVSEM_CURSOR_CHANGED_BIT)
#define DRVSEM_3D_BUSY              (1 << DRVSEM_3D_BUSY_BIT)
#define DRVSEM_MISSED_SET           (1 << DRVSEM_MISSED_SET_BIT)
#define DRVSEM_YUV_ON               (1 << DRVSEM_YUV_ON_BIT)
#define DRVSEM_DISABLE_SETS         (1 << DRVSEM_DISABLE_SETS_BIT)
#define DRVSEM_YUV_RECT_VALID       (1 << DRVSEM_YUV_RECT_VALID_BIT)

#define ROUND_UP_TO_64K(x)  (((ULONG)(x) + 0x10000 - 1) & ~(0x10000 - 1))

#define mmioFOURCC( ch0, ch1, ch2, ch3 )                           \
           ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
           ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )

#define FOURCC_UYVY mmioFOURCC('U', 'Y', 'V', 'Y')

typedef volatile GAR * PVGAR;

typedef struct offscr_yuv {
  RECTL SrcRect;
  WORD  nInUse;
  WORD  ratio;
} OFFSCR_YUV, * POFFSCR_YUV;


#if DRIVER_5465 && defined(OVERLAY)

#ifndef ENABLE_MIRRORING
#define ENABLE_MIRRORING    0
#endif

#ifndef ENABLE_YUVPLANAR
#define ENABLE_YUVPLANAR    0
#endif

// Be sure to synchronize the following structures with the one
// in i386\Laguna.inc!
#define MAX_FOURCCS   3
#define MAX_VIDEO_WINDOWS   8

#endif

// This DRIVERDATA structure is similar to GLOBALDATA structure in Win95
// DirectDraw and declares for compartible reason.
//
// Be sure to synchronize this structure with the one in i386\Laguna.inc!
//
typedef struct  _DRIVERDATA
{
  DWORD    PTAGFooPixel;      // ptag workaround pixel
  WORD     fNineBitRDRAMS;    // flag to indicate if 9bit RDRAMS present
  BOOL     fReset;
  PBYTE    ScreenAddress;     // base of screen memory (Same as pjScreen in PDEV)
  PBYTE    VideoBase;         // base of video memory (Same as pjScreen in PDEV)
  volatile GAR *RegsAddress;  // base address of Laguna MMIO regs
  WORD     DrvSemaphore;
  WORD     EdgeTrim;

  // Coordinate of the YUV rectange
  WORD     YUVTop;
  WORD     YUVLeft;
  WORD     YUVXExt;
  WORD     YUVYExt;

  // Video Format semaphores, you must set the VIDEO_FORMAT bit in
  // VideoSemaphore before making changes to CurrentVideoFormat and
  // NumVideoSurfaces. After you are done making changes, you must
  // clear the VIDEO_FORMAT bit in VideoSemaphore.
  //
  // Once you've SET the VIDEO_FORMAT bit, you can increment or decrement
  // the NumVideoSurfaces if CurrentVideoFormat is the same type.  You can
  // only change the CurrentVideoFormat, if the NumVideoSurfaces is zero.
  // Therefore if the NumVideoSurfaces is not zero and CurrentVideoFormat
  // is not the type of surface you want to create, you MUST FAIL the surface
  // creation request! After changing the video format you must program the
  // FORMAT register with the new video format.
  // When you are done making changes, CLEAR the VIDEO_FORMAT bit!
  WORD    VideoSemaphore;     // semaphores to control interaction between
                              // DCI's & VPM's use of video hardware
  WORD    CurrentVideoFormat; // value of current video format YUV422, etc.
                              // Same as low byte of FORMAT register
  WORD    NumVideoSurfaces;   // number of surfaces currently in use with
                              // CurrentVideoFormat
  DWORD   ScratchBufferOrg;

#ifdef WINNT_VER40
#if DRIVER_5465 && defined(OVERLAY)
  BOOL                fOverlaySupport;
  OVERLAYTABLE        OverlayTable;
  DWORD				  dwOverlayCount;
  DWORD				  dwCONTROL2Save;

  // Win95 5465over.c static vars
  BOOL                bUseBWEqn;
  BOOL                bNoOverlayInThisMode;

  PDD_SURFACE_LOCAL   lpHardwareOwner[MAX_VIDEO_WINDOWS];
  PDD_SURFACE_LOCAL   lpColorSurfaceVW[MAX_VIDEO_WINDOWS];
  PDD_SURFACE_LOCAL   lpSrcColorSurfaceVW[MAX_VIDEO_WINDOWS];

  RECTL               grOverlaySrc[MAX_VIDEO_WINDOWS];
  RECTL               grOverlayDest[MAX_VIDEO_WINDOWS];
  DWORD               gdwFourccVW[MAX_VIDEO_WINDOWS];
  BOOL                bIsVWMirrored[MAX_VIDEO_WINDOWS];

  DWORD               gdwAvailVW;                 // Next available video window
  DWORD               gdwColorKey;
  DWORD               gdwSrcColorKeyLow;
  DWORD               gdwSrcColorKeyHigh;
  DWORD               gdwDestColorKeyOwnerVW;     // DstColorKey owner (NULL or FLG_VWX)
  DWORD               gdwSrcColorKeyOwnerVW;      // SrcColorKey owner (NULL or FLG_VWX)

  int                 giOvlyCnt[MAX_VIDEO_WINDOWS];
  int                 giPlanarCnt;                // with other overlay surfaces
  BOOL                bCLPLLobotomyMode;

  // Win95 5465over.c global vars
  OVERLAYFLIPRECORD   gsOverlayFlip;

  PROGREGS            gsProgRegs;

  VIDCONFIG           gvidConfig;

  WORD                gwNormalDTTR;
  DWORD               dwNumVideoWindows;

  BOOL                bEnableCLPL;

  // NT only data
  DWORD     dwMaxOverlayStretch;
  DWORD     dwMinOverlayStretch;

  DWORD     dwFourCC[MAX_FOURCCS];
#else
  DWORD     dwFourCC;
#endif  // #if DRIVER_5465 && defined(OVERLAY)
#endif // WINNT_VER40

  DWORD   signature;      // Expected value: 0x9abcdef0;

} DRIVERDATA, *PDRIVERDATA;


// FLIPRECORD structure keeps track of when the last page flip occurred
typedef struct  _FLIPRECORD
{
#ifdef WINNT_VER40
  FLATPTR   fpFlipFrom;             // Surface we last flipped from
#endif // WINNT_VER40
  LONGLONG  liFlipTime;             // Time at which last flip
                                    //   occured
  LONGLONG  liFlipDuration;         // Precise amount of time it
                                    //   takes from vblank to vblank
  BOOL      bFlipFlag;              // True if we think a flip is
  BOOL      bHaveEverCrossedVBlank; // True if we noticed that we
                                    //   switched from inactive to
                                    //   vblank
  BOOL      bWasEverInDisplay;      // True if we ever noticed that
                                    //   we were inactive
  WORD      dwFlipScanLine;
} FLIPRECORD, *PFLIPRECORD;


/*****************************************************************************\
 * DSURF structure - Device Bitmaps
\*****************************************************************************/
typedef struct _DSURF
{
  struct _PDEV*    ppdev;   // pointer to pdev structure
  struct _OFMHDL*  pofm;    // pointer to off-screen memory handle
  SURFOBJ*         pso;     // pointer to surface object
  POINTL           ptl;     // x,y offset of bitmap
  SIZEL           sizl;     // size of device bitmap
  DWORD           packedXY; // packed x,y offset of bitmap
} DSURF, *PDSURF;


#define TMP_BUFFER_SIZE    8192  // Size in bytes of 'pvTmpBuffer. Has to be
                                 // at least enough to store an entire scan
                                 // line (i.e., 6400 for 1600x1200x32).



//
// For cursor/pointer
//
#define DEF_CURSOR              0       // GDI support cursor
#define HW_CURSOR               1       // Use HW cursor
#define SW_CURSOR               2       // Use SW cursor
#define HW_POINTER_DIMENSION    64      // Maximum dimension of default


// Font structures
#define  MAX_GLYPHS      256   // Maximum number of glyphs per font.
typedef struct _FONTMEMORY
{
  POFMHDL   pTile;             // Handle to tile.
  ULONG     ulLastX;           // Last allocated column.
  struct _FONTMEMORY*  pNext;  // Hointer to next structure.
} FONTMEMORY, *PFONTMEMORY;

typedef struct _GLYPHCACHE
{
  DWORD   xyPos;               // Off-screen x,y position of glyph.
  DWORD   cSize;               // Width and height of glyph.
  POINTL  ptlOrigin;           // Origin of glyph.
  // If xyPos == 0 then the glyph is not yet cached.
  // If cSize == 0 then the glyph is empty.
  // If cSize == -1 then the glyph is uncacheable.
} GLYPHCACHE, *PGLYPHCACHE;

// SWAT3 changes for font cache allocation scheme start here.
typedef struct _FONTCELL *PFONTCELL;
typedef struct _FONTCACHE *PFONTCACHE;
typedef struct _PDEV *PPDEV;

typedef struct _FONTCACHE
{
	PPDEV		ppdev;				 // Pointer to physical device.
	PFONTMEMORY	pFontMemory;		 // Pointer to font cache memory.
	PFONTCELL	pFontCell;			 // Pointer to first font cell.
	ULONG		ulFontCount;		 // Font cache ID counter.
	GLYPHCACHE	aGlyphs[MAX_GLYPHS]; // Array of cached glyphs.
	FONTOBJ*	pfo;				 // Pointer to FONTOBJ for this cache.
	PFONTCACHE	pfcPrev;			 // Pointer to previous FONTCACHE structure.
	PFONTCACHE	pfcNext;			 // Pointer to next FONTCACHE structure.
} FONTCACHE, *PFONTCACHE;

typedef struct _FONTCELL
{
	LONG		x;			// X location of this cell (in bytes).
	LONG		y;			// Y location of this cell (in bytes).
	PFONTCACHE	pfc;		// Pointer to FONTCACHE occupying this cell.
	ULONG		ulLastX;	// Last allocated column.
	PFONTCELL	pNext;		// Pointer to next font cell for this font cache.
} FONTCELL, *PFONTCELL;
// end SWAT3 changes.



typedef POFMHDL (WINAPI *ALLOCOFFSCNMEMFUNC)();
typedef BOOL    (WINAPI *FREEOFFSCNMEMFUNC)();
typedef VOID    (WINAPI *ASSERTMODEMCDFUNC)();

/*
 *  Be sure to synchronize this structure with the one in i386\Laguna.inc!
 */
typedef struct  _PDEV
{
  HANDLE  hDriver;                    // Handle to \Device\Screen
  HDEV    hdevEng;                    // Engine's handle to PDEV
  HSURF   hsurfEng;                   // Engine's handle to surface
  HPALETTE hpalDefault;               // Handle to the default palette for device.
  PBYTE   pjScreen;                   // This is pointer to base screen address
  ULONG   cxScreen;                   // Visible screen width
  ULONG   cyScreen;                   // Visible screen height
  ULONG   cxMemory;                   // Width  of Video RAM

  ULONG   cyMemory;                   // Height of Video RAM
                        // v-normmi   // this is bogus if pitch is not power of two
                        // v-normmi
  ULONG   cyMemoryReal;               // this includes extra rectangle at
                                      // bottom left if being used



  ULONG   ulMode;                     // Mode the mini-port driver is in.
  ULONG   ulFreq;                     // Frequency
  LONG    lDeltaScreen;               // Distance from one scan to the next.
  FLONG   flRed;                      // For bitfields device, Red Mask
  FLONG   flGreen;                    // For bitfields device, Green Mask
  FLONG   flBlue;                     // For bitfields device, Blue Mask
  ULONG   cPaletteShift;              // number of bits the 8-8-8 palette must
                                      // be shifted by to fit in the hardware
                                      // palette.
  POINTL  ptlHotSpot;                 // adjustment for pointer hot spot
  ULONG   cPatterns;                  // Count of bitmap patterns created
  HBITMAP ahbmPat[HS_DDI_MAX];        // Engine handles to standard patterns

  PALETTEENTRY *pPal;                 // If this is pal managed, this is the pal

  PBYTE   pjOffScreen;                // This is pointer to start of off screen memory
  ULONG   iBitmapFormat;
  ULONG   ulBitCount;                 // # of bits per pel 8,16,24,32 are only supported.
  ULONG   iBytesPerPixel;

  autoblt_regs PtrABlt[3];            // auto BLT tables

#ifdef WINNT_VER40
  HSEMAPHORE  CShsem;                 // Critical Section Handle to Semaphore
#else
  CRITICAL_SECTION  PtrCritSec;       // Pointer critical section
#endif

  RECTL   prcl;                       // Cursor rectange
  BOOL    PtrBusy;
  BOOL    fHwCursorActive;            // Are we currently using the hw cursor
  BOOL    CursorHidden;               // Indicate the cursor is hidden
  POFMHDL PtrMaskHandle;              // Pointer mask handle.
  POFMHDL PtrImageHandle;             // Pointer image save area handle.
  POFMHDL PtrABltHandle;              // Pointer auto BLT handle.
  ULONG   PtrXHotSpot;                // X & Y position of the pointer hot spot
  ULONG   PtrYHotSpot;
  ULONG   PtrX;                       // X & Y position of the pointer
  ULONG   PtrY;
  ULONG   PtrSzX;                     // Pointer dimensions
  ULONG   PtrSzY;
  LONG    PointerUsage;               // DEF_CURSOR - GDI support cursor.
                                      // HW_CURSOR  - Use HW cursor.
                                      // SW_CURSOR  - Use SW cursor.

  DWORD   grCONTROL;
  DWORD   grFORMAT;
  DWORD   grVS_CONTROL;

  // For offscreen memory manager
  LONG    lOffset_2D;                 // Offset-2D register value.
  LONG    lTileSize;                  // Selected tile size.
  LONG    lTotalMem;                  // Installed memory.
  BOOL    OFM_init;                   // TRUE InitOffScnMem() has been called.

#ifdef WINNT_VER40
  HSEMAPHORE  MMhsem;                 // Memory Manager Handle to Semaphore
#else
  HANDLE  MutexHdl;                   // Mutex handle
#endif

  BOOL    bDirectDrawInUse;           // DirectDraw InUse flag.
  POFMHDL ScrnHandle;                 // Active screen handle.
  POFMHDL OFM_UsedQ;                  // Off screen memory queues.
  POFMHDL OFM_FreeQ;
  POFMHDL OFM_SubFreeQ1;
  POFMHDL OFM_SubFreeQ2;
  FONTCACHE* pfcChain;                // Pointer to chain of FONTCACHE

  POFMHDL  Bcache;                    // This is the offscreen memory used to
                                      // cache the brush bits in.
  MC_ENTRY Mtable[NUM_MONO_BRUSHES];  //  Table to manage mono brush cache.
  XC_ENTRY Xtable[NUM_4BPP_BRUSHES];  //  Table to manage 4-bpp brush cache.
  DC_ENTRY Dtable[NUM_DITHER_BRUSHES]; //  Table to manage dither brush cache.
  BC_ENTRY Ctable[NUM_COLOR_BRUSHES]; //  Table to manage color brush cache.
  DC_ENTRY Stable[NUM_SOLID_BRUSHES];
  ULONG   SNext;
  ULONG   CLast;        // Last usable index in color cache table.
  ULONG   MNext;        // Where next mono brush will be cached.
  ULONG   XNext;        // Where next 4-bpp brush will be cached.
  ULONG   DNext;        // Where next dither brush will be cached.
  ULONG   CNext;        // Where next color brush will be cached.

  ULONG   ulFontCount;     // Font cache counter.
  ULONG   UseFontCache;    // Flag to turn on and off.

  POINTL  ptlOffset;    // x,y offset (for device bitmaps).
  BOOL  bEnable;        // Hardware enabled flag.

  COPYFN  *pfnHostToScreen;    // HostToScreen routine.
  COPYFN  *pfnScreenToHost;    // ScreenToHost routine.

  // Here we have the pointer to the memory mapped registers.  For
  // analysis reasons we sometimes want to 'null' out the hardware
  // by aiming the register pointer at blank memory.  We keep two
  // pointers to registers. pLgREGS_real and pLgREGS usually both point
  // to the registers, but we can set flags in LAGUNA.H to cause pLgREGS
  // to point to 'buffer' instead.  This is useful for testing which
  // parts of the driver are software bound and which are hardware bound.

  volatile GAR *pLgREGS_real; // Always points to the memory mapped registers.
  volatile GAR *pLgREGS;      // May point registers, may point to buffer.

  WORD  dcTileWidth;       // Number of Pixels in Current Tile Size
  WORD  dcSRAMWidth;       // Number of Pixels that will fit into SRAM

  // These were added to support stroke and fill with the least amount of
  // changes.
  ULONG uBLTDEF;
  ULONG uRop;
  PVOID pvTmpBuffer; // General purpose temporary buffer, TMP_BUFFER_SIZE in
                     // size (Remember to synchronize if you use this for
                     // device bitmaps or async pointers)


  #if ENABLE_LOG_FILE
    void *pmfile;
    char  TxtBuff[0x1000];
    DWORD TxtBuffIndex;
  #endif

  #if NULL_HW
    char *buffer[0x8000];   // Empty memory used to "null" the registers.
  #endif


  //
  // Reserve a little space for device bitmaps.
  //
  #if WINBENCH96
      POFMHDL pofmMagic;
      ULONG   bMagicUsed;
  #endif

// SWAT1 changes.
	BOOL		fPreAllocate;
	int			nPages;
// SWAT3 changes.
	#define 	FONTCELL_COUNT	64			// Number of font cells
	#define 	FONTCELL_X		128			// Width in bytes of a font cell
	#define 	FONTCELL_Y		16			// Height of a font cell
	POFMHDL		pofmFontCache;				// Font cache allocation heap
	FONTCELL	fcGrid[FONTCELL_COUNT];		// Array of font cache cells
#if MEMMGR
// MEMMGR changes.
	IIMEMMGR	mmMemMgr;
	LONG		must_have_width;
	BOOL		fBitmapFilter;
	SIZEL		szlBitmapMin;
	SIZEL		szlBitmapMax;
#endif

   //
   // For DirectDraw
   //
	BOOL		   bPrevModeDDOutOfVideoMem;
   POFMHDL     DirectDrawHandle;           // DirectDraw handle.
   FLIPRECORD  flipRecord;
   DRIVERDATA  DriverData;
   OFFSCR_YUV  offscr_YUV;
   DWORD       dwDDLinearCnt;              // Ref count of active DD locks
   PBYTE       pPtrMaskHost;

   BOOL        bYUVuseSWPtr;
   DWORD       dwLgVenID;                  // PCI Vendor ID
   DWORD       dwLgDevID;                  // PCI Device ID
   DWORD       dwLgDevRev;                 // PCI Device Revision
   BOOL        bYUVSurfaceOn;

   LONG        lRegVals[2][MAX_REGS];
   LONG        sShrinkInc;
   ULONG       usLnCntl;
   ULONG       usStretchCtrl;

#ifdef WINNT_VER40
   // DirectDraw display list pointer
   PFN_DELAY9BLT    pfnDelay9BitBlt;
   PFN_EDGEFILLBLT  pfnEdgeFillBlt;
   PFN_MEDGEFILLBLT pfnMEdgeFillBlt;
   PFN_DRVDSTBLT    pfnDrvDstBlt;
   PFN_DRVDSTBLT    pfnDrvDstMBlt;
   PFN_DRVSRCBLT    pfnDrvSrcBlt;
   PFN_DRVSRCMBLT   pfnDrvSrcMBlt;
   PFN_DRVSTRBLT    pfnDrvStrBlt;
   PFN_DRVSTRMBLT   pfnDrvStrMBlt;
   PFN_DRVSTRMBLTY  pfnDrvStrMBltY;
   PFN_DRVSTRMBLTX  pfnDrvStrMBltX;
   PFN_DRVSTRBLTY   pfnDrvStrBltY;
   PFN_DRVSTRBLTX   pfnDrvStrBltX;
#endif

   POFMHDL  DDScratchBufHandle;     // DirectDraw scratch buffer handle.
   PDDOFM   DDOffScnMemQ;           // DirectDraw offscreen mem queue.

   #ifdef BUS_MASTER
   BYTE*	Buf1VirtAddr;
   BYTE*	Buf2VirtAddr;

   BYTE*	Buf1PhysAddr;
   BYTE*	Buf2PhysAddr;

   ULONG	BufLength;
   #endif

   #ifndef WINNT_VER35
   // START OpenGL MCD additions (based on MGA driver in NT4.0 DDK)
   HANDLE      hMCD;                   // Handle to MCD engine dll
   MCDENGESCFILTERFUNC pMCDFilterFunc; // MCD engine filter function
   LONG        cDoubleBufferRef;       // Reference count for current number
                                       //   of RC's that have active double-
   LONG        cZBufferRef;            // Reference count for current number
                                       //   of RC's that have active z-buffers
   POFMHDL pohBackBuffer;              // ofscreen pools
   POFMHDL pohZBuffer;

   DWORD temp_DL_chunk[SIZE_TEMP_DL];       // temporary mem for display lists

   TSystem LL_State;

   ALLOCOFFSCNMEMFUNC   pAllocOffScnMem;
   FREEOFFSCNMEMFUNC    pFreeOffScnMem;
   ASSERTMODEMCDFUNC    pAssertModeMCD;

   // recip table to support up to 2K x 2K resolution
   #define LAST_FRECIP 2048
   float   frecips[LAST_FRECIP+1];

   ULONG    pLastDevRC;
   DWORD    NumMCDContexts;

   ULONG    iUniqueness;

   // pointer to first and last entries in linked list of texture control blocks
   LL_Texture   *pFirstTexture;
   LL_Texture   *pLastTexture;
   // END OpenGL MCD additions
   #endif

    // Translation table cache.
    POFMHDL XlateCache;
    ULONG   XlateCacheId;
    WORD    CachedChromaCtrl;
    WORD    CachedStretchCtrl;

    DWORD   signature;         // Expected value: 0x12345678;

#if DATASTREAMING
	DWORD	dwDataStreaming;
	DWORD	shadowFGCOLOR;
	DWORD	shadowBGCOLOR;
	DWORD	shadowDRAWBLTDEF;
	BYTE	shadowQFREE;
#endif

} PDEV, *PPDEV;


// MCD Prototypes (MCD_TEMP??)
#ifndef WINNT_VER35
BOOL MCDrvGetEntryPoints(MCDSURFACE *pMCDSurface, MCDDRIVER *pMCDDriver);
#endif

DWORD getAvailableModes(HANDLE, PVIDEO_MODE_INFORMATION *, DWORD *);
BOOL bInitPDEV(PPDEV, PDEVMODEW, GDIINFO *, DEVINFO *);
BOOL bInitSURF(PPDEV, BOOL);
BOOL bInitPaletteInfo(PPDEV, DEVINFO *);
VOID InitPointer(PPDEV);
BOOL bInit256ColorPalette(PPDEV);
BOOL bInitPatterns(PPDEV, ULONG);
VOID vDisablePalette(PPDEV);
VOID vDisablePatterns(PPDEV);
VOID vDisableSURF(PPDEV);
BOOL LgMatchDriverToChip(PPDEV ppdev);



#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))


//
// Pointer routines
//
VOID RestoreSaveShowCursor(PPDEV ppdev, LONG  x, LONG  y);
ULONG ConvertMaskBufToLinearAddr(PPDEV ppdev);


#ifdef WINNT_VER40
// GrabVideoFormat will set & test the VIDEO_FORMAT bit of
// pDriverData->VideoSemaphore if the bit was already set it
// will loop until the bit wasn't set at that point nobody else
// is modifying pDriverData->CurrentVideoFormat and/or
// pDriverData->NumVideoSurfaces so the caller is free to make
// their changes
void __inline GRAB_VIDEO_FORMAT_SEMAPHORE (WORD *pVideoSemaphore )
{
  _asm
  {
    mov     edi,pVideoSemaphore
    waitloop:
    bts     word PTR [edi],0
    jc      waitloop
  }
}

void __inline UNGRAB_VIDEO_FORMAT_SEMAPHORE (WORD *pVideoSemaphore)
{
  _asm
  {
    mov     edi,pVideoSemaphore
    btr     word PTR [edi],0
  }
}
/*
 * DrawEngineBusy should be replaced by a test to see the bltter is still
 * busy drawing
 */
static __inline BOOL DrawEngineBusy(DRIVERDATA* pDriverData)
{
  PVGAR pREG = (PVGAR) pDriverData->RegsAddress;

  return  ( pREG->grSTATUS != 0 );
}

// Convert offset into X, Y coordinate
static __inline DWORD cvlxy(LONG pitch, DWORD dwOffset, unsigned nBytesPixel)
{
  // Convert a linear frame buffer offset into a XY DWORD.
  // Offset mod pitch div bytes/pixel  = X
  // Offset div pitch          = Y
  return (MAKELONG((dwOffset % pitch) / nBytesPixel, (dwOffset / pitch)));
}

//
// DirectDraw function prototypes
//
void BltInit (PDEV* ppdev,  BOOL bEnableDisplayListBlts );
VOID vGetDisplayDuration(PFLIPRECORD pflipRecord);
HRESULT vUpdateFlipStatus(PFLIPRECORD pflipRecord, FLATPTR fpVidMem);
DWORD DdBlt(PDD_BLTDATA lpBlt);
DWORD Blt65(PDD_BLTDATA pbd);
DWORD DdFlip(PDD_FLIPDATA lpFlip);
DWORD DdLock(PDD_LOCKDATA lpLock);
DWORD DdUnlock(PDD_UNLOCKDATA lpUnlock);
DWORD DdGetBltStatus(PDD_GETBLTSTATUSDATA lpGetBltStatus);
DWORD DdGetFlipStatus(PDD_GETFLIPSTATUSDATA lpGetFlipStatus);
DWORD DdWaitForVerticalBlank(PDD_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank);
void SetGamma(PDEV* ppdev, DRIVERDATA* pDriverData);

DWORD CanCreateSurface (PDD_CANCREATESURFACEDATA lpInput);
DWORD CreateSurface (PDD_CREATESURFACEDATA lpInput);
DWORD DestroySurface (PDD_DESTROYSURFACEDATA lpInput);

//#ifdef  DDDRV_GETSCANLINE
DWORD GetScanLine(PDD_GETSCANLINEDATA lpGetScanLine);
//#endif

#endif  // WINNT_VER40 DirectDraw

//
// Determines the size of the DriverExtra information in the DEVMODE
// structure passed to and from the display driver.
//

#define DRIVER_EXTRA_SIZE 0



//
// Clipping Control Stuff
// Holds a list of clipping rectangles.  We give this structure to GDI, and
// GDI fills it in.
//

typedef struct {
  ULONG   c;
  RECTL   arcl[8];
} ENUMRECTS8;

typedef ENUMRECTS8 *PENUMRECTS8;

#define MIN(a, b) ((a) < (b) ? (a) : (b))
#define MAX(a, b) ((a) > (b) ? (a) : (b))



//
//////////////////////////////////////////////////////////////////////
// Text stuff
//

// DRAWBLTDEF values
#define TEXT_EXPAND_XPAR        0x106601F0
#define TEXT_EXPAND_OPAQUE      0x100600F0
#define SOLID_COLOR_FILL        0x100700F0

typedef struct _XLATECOLORS {       // Specifies foreground and background
ULONG   iBackColor;                 //   colours for faking a 1bpp XLATEOBJ
ULONG   iForeColor;
} XLATECOLORS;                      /* xlc, pxlc */

BOOL bEnableText(PDEV*);
VOID vDisableText(PDEV*);
VOID vAssertModeText(PDEV*, BOOL);

/*
  Function prototypes for device bitmap saving/restoring.
*/
BOOL bCreateDibFromScreen(PPDEV ppdev, PDSURF pdsurf);
BOOL bCreateScreenFromDib(PPDEV ppdev, PDSURF pdsurf);


#if ENABLE_LOG_FILE
// Function prototypes for logging information to disk

    HANDLE CreateLogFile(
        HANDLE hDriver,
        PDWORD Index);

    BOOL WriteLogFile(
        HANDLE hDriver,
        LPVOID lpBuffer,
        DWORD BytesToWrite,
        PCHAR TextBuffer,
        PDWORD Index);

    BOOL CloseLogFile(
        HANDLE hDriver,
        PCHAR TextBuffer,
        PDWORD Index);

    void DDFormatLogFile(
        LPSTR szFormat, ...);


#else
   #define CreateLogFile(a, b)
   #define WriteLogFile(a, b, c, d, e)
   #define CloseLogFile(a)
   #define DDFormatLogFile // turn it into a comment
#endif

// restore default structure alignment
#pragma pack()



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\lgddmsg.h ===
/****************************************************************************
******************************************************************************
*
*                ******************************************
*                * Copyright (c) 1995, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:	Laguna I (CL-GD546x) - 
*
* FILE:		lgddmsg.h
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*   This is the header file which will define the custom message between
*   the NT app and display driver.
*
* MODULES:
*
* REVISION HISTORY:
*   11/15/95     Benny Ng      Initial version
*
****************************************************************************
****************************************************************************/

#define  READ_OPR        1
#define  WRITE_OPR       2

#define  BYTE_ACCESS     1
#define  WORD_ACCESS     2
#define  DWORD_ACCESS    3


// =====================================================================
// Define structure used to call the BIOS int 10 function
// =====================================================================
typedef struct _VIDEO_X86_BIOS_ARGUMENTS {
    ULONG Eax;
    ULONG Ebx;
    ULONG Ecx;
    ULONG Edx;
    ULONG Esi;
    ULONG Edi;
    ULONG Ebp;
} VIDEO_X86_BIOS_ARGUMENTS, *PVIDEO_X86_BIOS_ARGUMENTS;


typedef struct _MMREG_ACCESS {
    ULONG Offset;
    ULONG ReadVal;
    ULONG WriteVal;
    ULONG RdWrFlag;     // 1=Read, 2=Write
    ULONG AccessType;   // 1=Byte, 2=Word,  3=Dword
} MMREG_ACCESS, *PMMREG_ACCESS;

// =====================================================================
// Define structure used for power manager
// =====================================================================
#ifndef __LGPWRMGR_H__
#define __LGPWRMGR_H__

#define  ENABLE           0x1
#define  DISABLE          0x0

#define  MOD_2D           0x0
#define  MOD_STRETCH      0x1
#define  MOD_3D           0x2
#define  MOD_EXTMODE      0x3
#define  MOD_VGA          0x4
#define  MOD_RAMDAC       0x5
#define  MOD_VPORT        0x6
#define  MOD_VW           0x7
#define  MOD_TVOUT        0x8
#define  TOTAL_MOD        MOD_TVOUT+1

typedef struct _LGPM_IN_STRUCT {
    ULONG arg1;
    ULONG arg2;
} LGPM_IN_STRUCT, *PLGPM_IN_STRUCT;

typedef struct _LGPM_OUT_STRUCT {
    BOOL  status;
    ULONG retval;
} LGPM_OUT_STRUCT, *PLGPM_OUT_STRUCT;

#endif  // #ifndef __LGPWRMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\l3system.h ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1997, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         l3system.h
*
* DESCRIPTION:  546X 3D engine defines and structures
*
* AUTHOR:       Goran Devic, Mark Einkauf
*
* REVISION HISTORY:
*
* $Log:   W:/log/laguna/ddraw/inc/l3system.h  $
* 
*    Rev 1.4   01 Jul 1997 09:58:18   einkauf
* 
* add dither x,y offsets, to fix bexact.c OpenGL conformance test
* 
*    Rev 1.3   08 Apr 1997 12:42:14   einkauf
* cleanup TSystem struct; misc to complete MCD code
* 
*    Rev 1.2   05 Mar 1997 02:32:02   KENTL
* 
* Attempted to merge Rev 1.0 with Rev 1.1. The most recent check-in was
* severely incompatible with the Win95 build of DirectDraw. For some reason,
* only a tiny section of this file is used or even compatible with the
* Win95 build. Revision 1.0 had vast sections of the file commented out.
* Apparently, those sections are required for the WinNT build. I wrapped
* those sections in a couple of huge #ifdef WINNT_VER40, but I haven't
* tested this in an NT build. It seems to work for Win95, though.
* 
*    Rev 1.0   25 Nov 1996 15:00:40   RUSSL
* Initial revision.
* 
****************************************************************************
***************************************************************************/

#ifndef _L3SYSTEM_H_
#define _L3SYSTEM_H_

#ifdef WINNT_VER40

#define OPENGL_MCD


/*********************************************************************
*   Include types and debug info
**********************************************************************/
#ifndef OPENGL_MCD	// LL3D's type.h redundant with basic type definitions in other DDK/msdev headers
#include "type.h"
#endif // ndef OPENGL_MCD

#include "l3d.h"						    

#define	TRUE                1
#define FALSE               0

/*********************************************************************
*   Local Variables and defines
**********************************************************************/
#define KB                  1024        // Defines a kilobyte
#define MAX_DL_SIZE         (512 * KB)  // Maximum size of display list
#define NUM_DL              2           // Number of display lists
#define NUM_BUFFERS         32          // Number of allocation buffers; 
                                        //  video, system memory and user
#define NUM_TEXTURES        512         // Number of textures
#define NUM_TEX_MEM         4           // Number of system texture memory 
                                        //  chunks (each chunk is 4Mb)
#define EXTRA_FRACT         4           // Texture params functions may use 
                                        //  some extra bit for precision


// MCD_TEMP - support for temporary dlist of 2K only
#define SIZE_TEMP_DL    2048

#define DL_START_OFFSET		20			

/*********************************************************************
*   Buffer flags in LL_State structure (dont change!)
**********************************************************************/
#define BUFFER_IN_RDRAM         0
#define BUFFER_IN_SYSTEM        1
#define Z_BUFFER                2
#define BUFFER_USER             4
#define BUFFER_FREE             0x80000000

/*********************************************************************
*   Textures flags in LL_State structure (dont change!)
**********************************************************************/
#define TEX_FREE            0x80000000  // Free slot for the texture
#define TEX_NOT_LOADED      0x40000000  // Texture just registered
#define TEX_IN_SYSTEM       0x20000000  // Currently located in system mem
#define TEX_TILED           0x10000000  // Texture is in tiled form
#define TEX_LOCKED          0x08000000  // Texture is locked

#define TEX_MAX_PRIORITY    0xfffffffe  // Priority level
#define TEX_DEFAULT_PRIORITY         1  // Default texture priority level


/*********************************************************************
*
*   Registers in the form suitable for adding to a pointer to a
*   double word.
*
**********************************************************************/

///////////////////////////////////////////////////////
//  3D Rendering Registers                           // 
///////////////////////////////////////////////////////

#define X_3D                          (0x4000/4)
#define Y_3D                          (0x4004/4)
#define R_3D                          (0x4008/4)
#define G_3D                          (0x400C/4)
#define B_3D                          (0x4010/4)
#define DX_MAIN_3D                    (0x4014/4)
#define Y_COUNT_3D                    (0x4018/4)
#define WIDTH1_3D                     (0x401C/4)
#define WIDTH2_3D                     (0x4020/4)
#define DWIDTH1_3D                    (0x4024/4)
#define DWIDTH2_3D                    (0x4028/4)
#define DR_MAIN_3D                    (0x402C/4)
#define DG_MAIN_3D                    (0x4030/4)
#define DB_MAIN_3D                    (0x4034/4)
#define DR_ORTHO_3D                   (0x4038/4)
#define DG_ORTHO_3D                   (0x403C/4)
#define DB_ORTHO_3D                   (0x4040/4)
#define Z_3D                          (0x4044/4)
#define DZ_MAIN_3D                    (0x4048/4)
#define DZ_ORTHO_3D                   (0x404C/4)
#define V_3D                          (0x4050/4)
#define U_3D                          (0x4054/4)
#define DV_MAIN_3D                    (0x4058/4)
#define DU_MAIN_3D                    (0x405C/4)
#define DV_ORTHO_3D                   (0x4060/4)
#define DU_ORTHO_3D                   (0x4064/4)
#define D2V_MAIN_3D                   (0x4068/4)
#define D2U_MAIN_3D                   (0x406C/4)
#define D2V_ORTHO_3D                  (0x4070/4)
#define D2U_ORTHO_3D                  (0x4074/4)
#define DV_ORTHO_ADD_3D               (0x4078/4)
#define DU_ORTHO_ADD_3D               (0x407C/4)

#define A_3D                          (0x40C0/4)
#define DA_MAIN_3D                    (0x40C4/4)
#define DA_ORTHO_3D                   (0x40C8/4)


///////////////////////////////////////////////////////
//  3D Control registers                             // 
///////////////////////////////////////////////////////

#define CONTROL_MASK_3D               (0x4100/4)
#define CONTROL0_3D                   (0x4104/4)
#define COLOR_MIN_BOUNDS_3D           (0x4108/4)
#define COLOR_MAX_BOUNDS_3D           (0x410C/4)
#define CONTROL1_3D                   (0x4110/4)
#define BASE0_ADDR_3D                 (0x4114/4)
#define BASE1_ADDR_3D                 (0x4118/4)

#define TX_CTL0_3D                    (0x4120/4)
#define TX_XYBASE_3D                  (0x4124/4)
#define TX_CTL1_3D                    (0x4128/4)
#define TX_CTL2_3D                    (0x412C/4)
#define COLOR0_3D                     (0x4130/4)
#define COLOR1_3D                     (0x4134/4)
#define Z_COLLIDE_3D                  (0x4138/4)
#define STATUS0_3D                    (0x413C/4)
#define PATTERN_RAM_0_3D              (0x4140/4)
#define PATTERN_RAM_1_3D              (0x4144/4)
#define PATTERN_RAM_2_3D              (0x4148/4)
#define PATTERN_RAM_3_3D              (0x414C/4)
#define PATTERN_RAM_4_3D              (0x4150/4)
#define PATTERN_RAM_5_3D              (0x4154/4)
#define PATTERN_RAM_6_3D              (0x4158/4)
#define PATTERN_RAM_7_3D              (0x415C/4)
#define X_CLIP_3D                     (0x4160/4)
#define Y_CLIP_3D                     (0x4164/4)
#define TEX_SRAM_CTRL_3D              (0x4168/4)


///////////////////////////////////////////////////////
//  HostXY Unit Registers - Must use WRITE_DEV_REGS  //
///////////////////////////////////////////////////////

#define HXY_BASE0_ADDRESS_PTR_3D      (0x4200/4)
#define HXY_BASE0_START_XY_3D         (0x4204/4)
#define HXY_BASE0_EXTENT_XY_3D        (0x4208/4)

#define HXY_BASE1_ADDRESS_PTR_3D      (0x4210/4)
#define HXY_BASE1_OFFSET0_3D          (0x4214/4)
#define HXY_BASE1_OFFSET1_3D          (0x4218/4)
#define HXY_BASE1_LENGTH_3D           (0x421C/4)

#define HXY_HOST_CTRL_3D              (0x4240/4)

#define MAILBOX0_3D                   (0x4260/4)
#define MAILBOX1_3D                   (0x4264/4)
#define MAILBOX2_3D                   (0x4268/4)
#define MAILBOX3_3D                   (0x426C/4)


///////////////////////////////////////////////////////
//  The 3D Prefetch Unit Registers                   //
///////////////////////////////////////////////////////

#define PF_BASE_ADDR_3D               (0x4400/4)
#define PF_CTRL_3D                    (0x4404/4)
#define PF_DEST_ADDR_3D               (0x4408/4)
#define PF_FB_SEG_3D                  (0x440C/4)

#define PF_INST_ADDR_3D               (0x4420/4)
#define PF_STATUS_3D                  (0x4424/4)

#define HOST_MASTER_CTRL_3D           (0x4440/4)

#define PF_INST_3D                    (0x4480/4)

#define HOST_3D_DATA_PORT             (0x4800/4)


/*********************************************************************
*
*   Device select for the WRITE_DEV_REGS instruction
*
**********************************************************************/
#define VGAMEM                        (0x00000000 << 21)
#define VGAFB                         (0x00000001 << 21)
#define VPORT                         (0x00000002 << 21)
#define LPB                           (0x00000003 << 21)
#define MISC                          (0x00000004 << 21)
#define ENG2D                         (0x00000005 << 21)
#define HD                            (0x00000006 << 21)
#define FB                            (0x00000007 << 21)
#define ROM                           (0x00000008 << 21)
#define ENG3D                         (0x00000009 << 21)
#define HOST_XY                       (0x0000000A << 21)
#define HDATA_3D                      (0x0000000B << 21)


#endif // WINNT_VER40
/*********************************************************************
*
*   Laguna 3D Micro Instruction Set
*
**********************************************************************/

#define OPCODE_MASK                    0xF8000000
#define POINT                          0x00000000
#define LINE                           0x08000000
#define POLY                           0x10000000
#define WRITE_REGISTER                 0x18000000
#define READ_REGISTER                  0x20000000
#define WRITE_DEV_REGS                 0x28000000
#define READ_DEV_REGS                  0x30000000
#define BRANCH                         0x38000000
#define C_BRANCH                       0x40000000
#define NC_BRANCH                      0x48000000
#define CALL                           0x50000000
#define WRITE_DEST_ADDR                0x58000000

#define IDLE                           0x68000000
#define CLEAR                          0x69400000
#define WAIT                           0x72000000
#define WAIT_AND                       0x72000000
#define NWAIT_AND                      0x73000000
#define WAIT_OR                        0x70000000
#define NWAIT_OR                       0x71000000
#define CLEAR_INT                      0x78000000
#define SET_INT                        0x7A000000
#define TEST                           0x80000000
#define TEST_AND                       0x82000000
#define NTEST_AND                      0x83000000
#define TEST_OR                        0x80000000
#define NTEST_OR                       0x81000000
#define WRITE_PREFETCH_CONTROL         0x88000000

#ifdef WINNT_VER40     // Not WINNT_VER40

/*********************************************************************
*
*   Prefetch status flags (Almost the same as events)
*
**********************************************************************/
#define ST_VBLANK                      0x00000001
#define ST_EVSYNC                      0x00000002
#define ST_LINE_COMPARE                0x00000004
#define ST_BUFFER_SWITCH               0x00000008
#define ST_Z_BUFFER_COMPARE            0x00000010
#define ST_POLY_ENG_BUSY               0x00000020
#define ST_EXEC_ENG_3D_BUSY            0x00000040
#define ST_XY_ENG_BUSY                 0x00000080
#define ST_BLT_ENG_BUSY                0x00000100
#define ST_BLT_WF_EMPTY                0x00000200
#define ST_DL_READY_STATUS             0x00000400


/*********************************************************************
*
*   Defines for pixel modes (Control0 register)
*
**********************************************************************/
#define PIXEL_MODE_INDEXED             0
#define PIXEL_MODE_332                 1
#define PIXEL_MODE_565                 2
#define PIXEL_MODE_555                 3
#define PIXEL_MODE_A888                4
#define PIXEL_MODE_Z888                5

/*********************************************************************
*
*   Macros for building the instruction opcodes
*
**********************************************************************/
//#define make_point( imodif, count )  (POINT | imodif | count)

#define mk_reg( reg )                  (((reg)-0x1000) << 6)
#define mk_dev_reg( reg )              ((((reg)-0x1080)*4) << 6)

#define write_register( reg, count ) \
( WRITE_REGISTER | mk_reg(reg) | count )

#define write_dev_register( device, reg, count ) \
( WRITE_DEV_REGS | device | mk_dev_reg(reg) | count )

// Set the register and the cache in LL_State to a specific value
#define SETREG(Offset,Reg,Value) \
    *(ppdev->LL_State.pRegs + (Offset)) = ppdev->LL_State.Reg = (Value); /*inp(0x80); inp(0x80)*/

// setreg, no cache: do not cache state for this register
#define SETREG_NC(reg, value)     \
    (*(ppdev->LL_State.pRegs + reg) = value); /*inp(0x80); inp(0x80)*/

// Clears the range of registers
#define CLEAR_RANGE( StartReg, EndReg ) \
    memset( (void *)(ppdev->LL_State.pRegs + (StartReg)), 0, ((EndReg) - (StartReg)+1)*4 )



#ifndef OPENGL_MCD
// The polling for the 3d engine busy bit is done inline to avoid Watcom
// optimization of accessing a byte instead of a dword of that register.
//
#pragma aux Poll3DEngineBusy =   \
"lp:    test dword ptr [eax], 2" \
"       jnz  lp"                 \
parm caller [eax];
#endif // ndef OPENGL_MCD


// Instruction modifier set
//
#define STALL                          0x04000000
#define GOURAUD                        0x00001000
#define Z_ON                           0x00002000
#define SAME_COLOR                     0x00008000
#define TEXTURE_LINEAR                 0x00020000
#define TEXTURE_PERSPECTIVE            0x00030000
#define LIGHTING                       0x00040000
#define STIPPLE                        0x00080000
#define PATTERN                        0x00100000
#define DITHER                         0x00200000
#define ALPHA                          0x00400000
#define FETCH_COLOR                    0x00800000
#define WARP_MODE                      0x01000000
#define MODIFIER_EXPANSION             0x02000000


/*********************************************************************
*
*   Speed / Quality decision values
*
**********************************************************************/
#define LLQ_POLY_SUBPIXEL   192   // When poly param will use fp / subpixels
#define LLQ_POLY_FLOAT      64    // Polys start to use fp
#define LLQ_LINE_SUBPIXEL   128   // When lines will consider subpixel addressing


/*********************************************************************
*
*   Control0_3d register bitfields
*
**********************************************************************/
typedef struct
{
DWORD Pixel_Mode            : 3;  // Color frame buffer drawing mode
DWORD Res1                  : 1;  // Reserved
DWORD Pixel_Mask_Enable     : 1;  // Enables pixel masking
DWORD Pixel_Mask_Polarity   : 1;  // Polarity of the pixel masks
DWORD Color_Saturate_En     : 1;  // Enables saturation in indexed mode
DWORD Red_Color_Compare_En  : 1;  // Enables compare to bounds for red
DWORD Green_Color_Compare_En: 1;  // Enables compare to bounds for green
DWORD Blue_Color_Compare_En : 1;  // Enables compare to bounds for blue
DWORD Color_Compare_Mode    : 1;  // Mask inclusive/exclusive to bounds
DWORD Alpha_Mode            : 2;  // Selects alpha blending mode
DWORD Alpha_Dest_Color_Sel  : 2;  // Selects the DEST_RGB input to alpha
DWORD Alpha_Blending_Enable : 1;  // Enables alpha blending
DWORD Z_Stride_Control      : 1;  // 16/8 bit Z depth
DWORD Frame_Scaling_Enable  : 1;  // Enables frame scaling (multiply src*dest)
DWORD Res2                  : 2;  // Reserved
DWORD Z_Compare_Mode        : 4;  // Different Z compare function
DWORD Z_Collision_Detect_En : 1;  // Enables Z collision detection
DWORD Light_Src_Sel         : 2;  // Selects the lighting source input
DWORD Res3                  : 1;  // Reserved
DWORD Z_Mode                : 3;  // Controls Z and color update method
DWORD Res4                  : 1;  // Reserved

} TControl0Reg;


/*********************************************************************
*
*   Base0_addr_3d register bitfields
*
**********************************************************************/
typedef struct
{
DWORD Res1                  : 6;  // Reserved
DWORD Color_Buffer_X_Offset : 7;  // Offset to color buffer X address
DWORD Color_Buffer_Location : 1;  // For drawing: 0-rdram, 1-host
DWORD Z_Buffer_Location     : 1;  // For drawing: 0-rdram, 1-host
DWORD Texture_Location      : 1;  // For drawing: 0-rdram, 1-host
DWORD Pattern_Y_Offset      : 4;  // Pattern lookup offset for y address
DWORD Res2                  : 4;  // Reserved
DWORD Pattern_X_Offset      : 4;  // Pattern lookup offset for x address
DWORD Res3                  : 4;  // Reserved

} TBase0Reg;


/*********************************************************************
*
*   Base1_addr_3d register bitfields
*
**********************************************************************/
typedef struct
{
DWORD Res1                  : 5;  // Reserved
DWORD Color_Buffer_Y_Offset : 8;  // Y offset from the color space Y base
DWORD Res2                  : 8;  // Reserved
DWORD Z_Buffer_Y_Offset     : 8;  // Y offset from the color space Y base
DWORD Res3                  : 3;  // Reserved

} TBase1Reg;

/*********************************************************************
*
*   Tx_Ctl0_3d register bitfields
*
**********************************************************************/
#define TX_CTL0_MASK (~0x0C08F000)// All the reserved bits
typedef struct
{
DWORD Tex_U_Address_Mask    : 3;  // Texture width (U space)
DWORD Tex_U_Ovf_Sat_En      : 1;  // Texture saturation enable for U
DWORD Tex_V_Address_Mask    : 3;  // Texture height (V space)
DWORD Tex_V_Ovf_Sat_En      : 1;  // Texture saturation enable for V
DWORD Texel_Mode            : 4;  // Texture type
DWORD Res1                  : 4;  // Reserved
DWORD Texel_Lookup_En       : 1;  // Use texel data as lookup index
DWORD Tex_As_Src            : 1;  // Specifies texture as source
DWORD Fil_Tex_En            : 1;  // Enables filtering
DWORD Res2                  : 1;  // Reserved
DWORD Tex_Mask_Polarity     : 1;  // Polarity of the masking bit
DWORD Tex_Mask_Enable       : 1;  // Enables texture masking
DWORD Tex_Mask_Function     : 1;  // Texture masking function 
DWORD UV_Precision          : 1;  // UV_Precision 8.24
DWORD Address_Mux           : 2;  // Texel UV Mux Select
DWORD Res4                  : 2;  // Reserved
DWORD CLUT_Offset           : 4;  // Color Lookup Table offset for 4, 8 bpp

} TTxCtl0Reg;


/*********************************************************************
*
*   Tx_Ctl1_3d register bitfields
*
**********************************************************************/
typedef struct
{
DWORD Tex_Min_Blue_Color          : 8;
DWORD Tex_Min_Green_Color         : 8;
DWORD Tex_Min_Red_Color           : 8;
DWORD Tex_Red_Color_Compare       : 1;
DWORD Tex_Green_Color_Compare     : 1;
DWORD Tex_Blue_Color_Compare      : 1;
DWORD Tex_Color_Compare_Mode      : 1;
DWORD Res                         : 4;

} TTxCtl1Reg;

/*********************************************************************
*
*   Tx_Ctl2_3d register bitfields
*
**********************************************************************/
typedef struct
{
DWORD Tex_Max_Blue_Color          : 8;
DWORD Tex_Max_Green_Color         : 8;
DWORD Tex_Max_Red_Color           : 8;
DWORD Tex_Fraction_Mask           : 3;
DWORD En_Cont_Bilinear            : 1;
DWORD En_Step_Bilinear            : 1;
DWORD Mask_Threshold              : 3;

} TTxCtl2Reg;


/*********************************************************************
*
*   Tx_XYBase_3d register bitfields
*
**********************************************************************/
typedef struct
{
WORD  Tex_X_Base_Addr;            // Texture base X coordinate
WORD  Tex_Y_Base_Addr;            // Texture base Y coordinate

} TTxXYBaseReg;


/*********************************************************************
*
*   HXY_Host_Ctrl_3d register bitfields
*
**********************************************************************/
typedef struct
{
DWORD  HostXYEnable  :  1;         // Host XY enable bit
DWORD  Res1          :  7;         // Reserved
DWORD  HostYPitch    :  6;         // Host Y Pitch of the system
DWORD  Res2          : 18;         // Reserved

} THXYHostCtrlReg;


/*********************************************************************
*
*   TMem structure defines a memory block
*
**********************************************************************/
typedef struct
{
    DWORD  hMem;                    // Memory handle
    DWORD *dwAddress;               // Linear address
    DWORD  dwSize;                  // Size of the buffer
    DWORD  dwPhyPtr;                // Physical / page table address

} TMem;


/*********************************************************************
*
*   Buffer information structure (buffers A, B, Z, ...)
*
**********************************************************************/
typedef struct
{
    DWORD dwFlags;                  // Buffer flags
    DWORD dwAddress;                // Buffer start byte address (absolute linear)
    DWORD dwPhyAdr;                 // Buffer physical address (system)
    DWORD dwPitchCode;              // Pitch code of a buffer (system)
    DWORD dwPitchBytes;             // Pitch of a buffer in bytes
    DWORD hMem;                     // Internal memory handle (system)
    LL_Rect Extent;                 // Buffer location offsets (video)

} TBuffer;


/*********************************************************************
*
*   TDisplayList structure defines a display list.
*
**********************************************************************/
typedef struct
{
    // pdwNext points to the next available location within this 
    // display list to fill in the Laguna instruction.
    // It is used for parametarization routines that postincrement
    // this variable.
    //
    DWORD *pdwNext;

    // Memory handle for this display list as optained from the
    // internal memory allocation function
    //
    DWORD hMem;

    // Linear address of the display list
    //
    DWORD *pdwLinPtr;

    // Linear address of the display list
    //
    DWORD *pdwStartOutPtr;  //ME - next word to be output

    // Physical address for a display list is next; it may also
    // be the address to the page table.  This address has the
    // appropriate format to be stored in the BASE* class registers
    //
    DWORD dwPhyPtr;

    // The length of a display list in bytes
    //
    DWORD dwLen;

    // Safety margin for building the display list
    //
    DWORD dwMargin;

} TDisplayList;


/*********************************************************************
*
*   TTextureState structure defines a texture state
*
**********************************************************************/
typedef struct
{
    LL_Texture Tex[ NUM_TEXTURES ]; // Array of texture information
    TMem Mem[ NUM_TEX_MEM ];        // Allocated memory information
    DWORD dwMemBlocks;              // Number of Mem entries used
    LL_Texture *pLastTexture;          // Used to cache textures

} TTextureState;


/*********************************************************************
*
*   TTextureRegs structure defines a texture registers
*
**********************************************************************/
typedef struct
{
    DWORD dv_main;
    DWORD du_main;
    DWORD dv_ortho;
    DWORD du_ortho;
    DWORD d2v_main;
    DWORD d2u_main;
    DWORD d2v_ortho;
    DWORD d2u_ortho;
    DWORD dv_ortho_add;
    DWORD du_ortho_add;

} TTextureRegs;


/*********************************************************************
*
*   System State Structure
*
**********************************************************************/
typedef struct
{
    DWORD rColor_Min_Bounds;        // Color compare min bounds
    DWORD rColor_Max_Bounds;        // Color compare max bounds

    DWORD AlphaConstSource;         // Constant source alpha (9:16)
    DWORD AlphaConstDest;           // Constant destination alpha (9:16)

    // Display lists management
    TDisplayList DL[ NUM_DL ];      // Array of d-list segments
    TDisplayList *pDL;              // Current display list to build
    DWORD dwCdl;                    // Index of the current d-list

    // Information from the init / current graphics mode
    DWORD *pRegs;                   // Register apperture
    BYTE  *pFrame;                  // Frame apperture

    unsigned 	int		pattern_ram_state;
	LL_Pattern	dither_array;

    WORD    dither_x_offset; 
    WORD    dither_y_offset; 

} TSystem;

typedef struct                      // MOUSE header structure
{
    WORD wX_Position;
    WORD wY_Position;
    WORD wStatus; //assigned to NEED_MOUSE_UPDATE or MOUSE_IS_UPDATED

} TMouseInfo;

extern void _TriFillTex(
                int right2left,
                int hiprecision_2ndorder,
                TTextureRegs * r,
                TEXTURE_VERTEX *vmin,
                TEXTURE_VERTEX *vmid,
                TEXTURE_VERTEX *vmax,
                float frecip_vm_y,
                float frecip_del_x_mid );


void _RunLaguna( );

#ifndef OPENGL_MCD // from here down, structs are more specific to LL3D

/*********************************************************************
*   Global Variables
**********************************************************************/

extern TSystem LL_State;
extern TMouseInfo LL_MouseInfo;


/*********************************************************************
*   External Functions
**********************************************************************/

extern BYTE *  GetLagunaApperture( int base );

/*********************************************************************
*   From PAGETBL.C:
**********************************************************************/

extern DWORD   AllocSystemMemory( DWORD dwSize );
extern void    FreeSystemMemory( DWORD hHandle );
extern DWORD   GetLinearAddress( DWORD hHandle );
extern DWORD   GetPhysicalAddress( DWORD hHandle );
extern DWORD * GetRegisterApperture();

/*********************************************************************
*   Extern functions: l3d.c, control.c, points.c, lines.c, polys.c
**********************************************************************/

extern DWORD * fnInvalidOp( DWORD *, LL_Batch * );
extern DWORD * fnNop( DWORD *, LL_Batch * );

extern DWORD * fnPoint( DWORD *, LL_Batch * );
extern DWORD * fnAALine( DWORD *, LL_Batch * );
extern DWORD * fnLine( DWORD *, LL_Batch * );
extern DWORD * fnPoly( DWORD *, LL_Batch * );
extern DWORD * fnNicePoly( DWORD *, LL_Batch * );
extern DWORD * fnPolyFast( DWORD *, LL_Batch * );

extern DWORD * fnSetClipRegion( DWORD *, LL_Batch * );
extern DWORD * fnSetZBuffer( DWORD *, LL_Batch * );
extern DWORD * fnSetZCompareMode( DWORD *, LL_Batch * );
extern DWORD * fnSetZMode( DWORD *, LL_Batch * );
extern DWORD * fnSetAlphaMode( DWORD *, LL_Batch * );
extern DWORD * fnSetAlphaDestColor( DWORD *, LL_Batch * );
extern DWORD * fnSetLightingSource( DWORD *, LL_Batch * );
extern DWORD * fnSetColor0( DWORD *, LL_Batch * );
extern DWORD * fnSetColor1( DWORD *, LL_Batch * );
extern DWORD * fnSetConstantAlpha( DWORD *, LL_Batch * );
extern DWORD * fnSetPattern(DWORD *dwNext, LL_Batch *pBatch);

extern DWORD * fnQuality( DWORD *, LL_Batch * );

extern DWORD * fnSetTextureColorBounds( DWORD *, LL_Batch * );
extern DWORD * fnSetDestColorBounds( DWORD *, LL_Batch * );

extern void    LL_ControlInit();
extern void    _ShutDown( char * szMsg, ... );

/*********************************************************************
*   From displist.c
**********************************************************************/

extern DWORD * (* fnList[256])( DWORD *, LL_Batch * );
extern DWORD * _RunLaguna( DWORD *pdwNext );

/*********************************************************************
*   From textures.c
**********************************************************************/

extern int     _InitTextures();
extern void    _CloseTextures();

/*********************************************************************
*   From mem.c
**********************************************************************/

extern void    _InitKmem( BYTE *, DWORD );
extern DWORD * _kmalloc( const DWORD * pBlock, int );
extern void    _kfree( const DWORD * pBlock, void * );

/*********************************************************************
*   From texparm.c
**********************************************************************/

typedef union
{
    float    f;
    long     i; 
} PTEXTURE;

#define CGL_XYZ DWORD

extern void _TriFillTex( int dir_flag, int dx_main, TTextureRegs * r,
#ifdef B4_PERF
    LL_Vert * vmin, LL_Vert * vmid, LL_Vert * vmax,
#else
    CGL_XYZ *pV1, PTEXTURE *pT1,
    CGL_XYZ *pV2, PTEXTURE *pT2,
    CGL_XYZ *pV3, PTEXTURE *pT3,
#endif
    int recip_vm_y, int recip_vd_y, int del_x_mid );


/*********************************************************************
*
*   Debug defines that are used to determine the specific file
*   for inclusion of debug information.  For definition, see makefile.
*
**********************************************************************/
#define DEBUG_L3D       0x0001    /* Enable debug info in L3d.c      */
#define DEBUG_PAGETBL   0x0002    /* Enable debug info in pagetbl.c  */
#define DEBUG_CONTROL   0x0004    /* Enable debug info in control.c  */
#define DEBUG_MEM       0x0008    /* Enable debug info in mem.c      */
#define DEBUG_TEX       0x0010    /* Enable debug info in textures.c */
#define DEBUG_PCX       0x0020    /* Enable debug info in pcx.c      */
#define DEBUG_BUFFERS   0x0040    /* Enable debug info in buffers.c  */

#ifdef CGL // added for CGL DLL 
#define L3D_MALLOC  dpmiAlloc
#define L3D_FREE    dpmiFree
#else
#define L3D_MALLOC  malloc
#define L3D_FREE    free
#endif

#endif // ndef OPENGL_MCD

#endif //  _L3SYSTEM_H_
#endif // WINNT_VER40
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\laguna.h ===
/******************************************************************************\
*
* $Workfile:   LAGUNA.H  $
*
* This file to be included by all host programs.
* 
* Copyright (c) 1995,1997 Cirrus Logic, Inc. 
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/LAGUNA.H  $
* 
*    Rev 1.38   Mar 04 1998 16:13:30   frido
* Removed a warning message for the 5462/5464 chips in the REQUIRE
* macro.
* 
*    Rev 1.37   Mar 04 1998 16:08:50   frido
* Removed an invalid break.
* 
*    Rev 1.36   Mar 04 1998 14:54:48   frido
* Added contional REQUIRE in the new shadow macros.
* 
*    Rev 1.35   Mar 04 1998 14:52:54   frido
* Added new shadowing macros.
* 
*    Rev 1.34   Feb 27 1998 17:02:16   frido
* Changed REQUIRE and WRITE_STRING macros for new
* shadowQFREE register.
* 
*    Rev 1.33   Jan 20 1998 11:42:46   frido
* Changed REQUIRE and WRITESTRING macros to support the new
* scheme for GBP on.
* Added shadowing of BGCOLOR and DRAWBLTDEF registers.
* 
*    Rev 1.32   Jan 16 1998 09:50:38   frido
* Changed the way the GBP OFF handles WRITE_STRING macros.
* 
*    Rev 1.31   Dec 10 1997 13:24:58   frido
* Merged from 1.62 branch.
* 
*    Rev 1.30.1.0   Nov 18 1997 18:09:00   frido
* Changed WRITE_STRING macro so it will work when
* DATASTREAMING is turned of.
* Changed FUDGE to 0, we are not using DMA inside NT.
* 
*    Rev 1.30   Nov 04 1997 19:01:18   frido
* Changed HOSTDATA size from 0x800 DWORDs into 0x800 BYTEs. Silly me!
* 
*    Rev 1.29   Nov 04 1997 09:17:30   frido
* Added Data Streaming macros (REQUIRE and WRITE_STRING).
*
\******************************************************************************/

#ifndef _LAGUNA_H 
#define _LAGUNA_H 

#include "optimize.h"
#include "config.h"
#include "lgregs.h"


//
// PCI ID for Laguna chips.
//
#define CL_GD5462       0x00D0     // 5462
#define CL_GD5464       0x00D4     // 5464
#define CL_GD5464_BD    0x00D5     // 5464 BD
#define CL_GD5465       0x00D6     // 5465

//
// These chips don't exist yet, but we're FORWARD COMPATIBLE
// so we'll define them anyway.  I've been GUARENTEED that they
// will look and feel just like 5465 chips.
//
#define CL_GD546x_F7       0x00D7
#define CL_GD546x_F8       0x00D8
#define CL_GD546x_F9       0x00D9
#define CL_GD546x_FA       0x00DA
#define CL_GD546x_FB       0x00DB
#define CL_GD546x_FC       0x00DC
#define CL_GD546x_FD       0x00DD
#define CL_GD546x_FE       0x00DE
#define CL_GD546x_FF       0x00DF


//
// CHIP BUG: For certian values in PRESET register cursor enable/disable
// causes scanlines to be duplicated at the cursor hot spot.  (Seen
// as screen jump.)  There are lots of ways around this.  The easiest 
// is to turn the cursor on and leave it on.  Enable/Disable is handled by
// moving the cursor on/off the visable screen.
//
#define HW_PRESET_BUG 1



// The 5465 (to at least AC) has a problem when PCI configuration space
// is accessible in memory space.  On 16-bit writes, a 32-bit write is
// actually performed, so the next register has garbage written to it.
// We get around this problem by clearing bit 0 of the Vendor Specific
// Control register in PCI configuration space.  When this bit is set
// to 0, PCI configuration registers are not available through memory
// mapped I/O.  Since some functions, such as power management, require
// access to PCI registers, the display driver must post a message to
// the miniport to enable this bit when needed.
//
#define  VS_CONTROL_HACK 1


#if ENABLE_LOG_FILE
    extern long lg_i;
    extern char lg_buf[256];
#endif

#if POINTER_SWITCH_ENABLED
    extern int pointer_switch;
#endif



// The definitions are not portable. 486 / PC only !!!
typedef struct {
	BYTE	b;
	BYTE	g;
	BYTE	r;
	} pix24;

typedef	struct {
	BYTE u;
	BYTE y1;
	BYTE v;
	BYTE y2;
	} yuv_422;

typedef	struct {
	unsigned int v : 6;
	unsigned int u : 6;
	unsigned int y0: 5;
	unsigned int y1: 5;
	unsigned int y2: 5;
	unsigned int y3: 5;
	} yuv_411;

typedef	struct {
	unsigned int b : 5;
	unsigned int g : 5;
	unsigned int r : 5;
	} rgb_555;

typedef	struct {
	unsigned int b : 5;
	unsigned int g : 6;
	unsigned int r : 5;
	} rgb_565;


typedef union {
	DWORD	p32;
	yuv_422	yuv422;
	yuv_411	yuv411;
	pix24	p24;
	rgb_555	rgb555;
	rgb_565	rgb565;
	WORD	p16[2];
	BYTE	p8[4];
	} pixel;


#define FALSE 0
#ifndef TRUE
    #define TRUE (~FALSE)
#endif

/* from struct.h */
#define	fldoff(str, fld)	((int)&(((struct str *)0)->fld))
#define	fldsiz(str, fld)	(sizeof(((struct str *)0)->fld))

#define HPRR(pr_reg)      (_AP_direct_read(PADDR(pr_reg),fldsiz(PLUTOREGS,pr_reg), (ul)0))
#define RPR(pr_reg)       HPRR(pr_reg)
#define EHIST             (*(EXHIST*)excepttion) /* Exception History buffer      */
#define STAMP             (*(bytearray*)0x0)     /* time date stamp               */
#define HISTORYBUFFERADDR (ul)&history           /* 34020 address of recording    */


/* External functions the host program can call */

/*-------------------------------------------------------------------------*/

/* Function prototypes for emulator. Functions defined in host_if.c */
int     _cdecl _AP_init(int mode, void * frame_buf);
void    _cdecl _AP_write(ul addr, int size, ul data);
ul      _cdecl _AP_read(ul addr,int size);
void    _cdecl _AP_run(void);
boolean _cdecl _AP_busy();
boolean _cdecl _AP_done();
boolean _cdecl _AP_rfifo_empty();
boolean _cdecl _AP_require(int size);
ul      _cdecl _AP_direct_read(ul addr,int size);
void    _cdecl _AP_fb_write(ul offset, pixel data, ul size);
pixel   _cdecl _AP_fb_read(ul offset, ul size);


#if LOG_QFREE

    #define START_OF_BLT() \
    do{ \
        CHECK_QFREE(); \
    } while(0)

    #define END_OF_BLT() \
    do{ \
    } while(0)
        
#else
    #define START_OF_BLT()
    #define END_OF_BLT()
#endif





//
// This waits for the chip to go idle
//
#define WAIT_FOR_IDLE()                  \
    do {                                 \
        while (LLDR_SZ (grSTATUS) != 0); \
    } while (0)



//
// Macro to require a certian number of free queue entries.
//
#if DATASTREAMING
    #define FUDGE 2
    #define REQUIRE(n)														\
    {																		\
		if (ppdev->dwDataStreaming & 0x80000000)							\
		{																	\
			if (ppdev->shadowQFREE < ((n) + FUDGE))							\
			{																\
				while (ppdev->shadowQFREE < (n) + FUDGE)					\
				{															\
					ppdev->shadowQFREE = LLDR_SZ(grQFREE);					\
				}															\
			}																\
			ppdev->shadowQFREE -= (BYTE) n;									\
		}																	\
		else if (ppdev->dwDataStreaming)									\
		{																	\
			if (LLDR_SZ(grQFREE) < ((n) + FUDGE))							\
			{																\
				while (LLDR_SZ(grSTATUS) & 0x8005) ;						\
				ppdev->dwDataStreaming = 0;									\
			}																\
		}																	\
	}
	#define ENDREQUIRE()													\
	{																		\
		ppdev->dwDataStreaming |= 1;										\
	}
	#define WRITE_STRING(src, dwords)										\
	{																		\
		ULONG nDwords, nTotal = (ULONG) (dwords);							\
		PULONG data = (PULONG) (src);										\
		if (ppdev->dwDataStreaming & 0x80000000)							\
		{																	\
			while (nTotal > 0)												\
			{																\
				nDwords = (ULONG) ppdev->shadowQFREE;						\
				if (nDwords > FUDGE)										\
				{															\
					nDwords = min(nDwords - FUDGE, nTotal);					\
					memcpy((LPVOID) ppdev->pLgREGS->grHOSTDATA, data, nDwords * 4);	\
					data += nDwords;										\
					nTotal -= nDwords;										\
				}															\
				ppdev->shadowQFREE = LLDR_SZ(grQFREE);						\
			}																\
		}																	\
		else																\
		{																	\
			if ( ppdev->dwDataStreaming && (LLDR_SZ(grQFREE) < nTotal) )	\
			{																\
				while (LLDR_SZ(grSTATUS) & 0x8005) ;						\
				ppdev->dwDataStreaming = 0;									\
			}																\
			while (nTotal > 0)												\
			{																\
				nDwords = min(nTotal, 0x200);								\
				memcpy((LPVOID) ppdev->pLgREGS->grHOSTDATA, data, nDwords * 4);	\
				data += nDwords;											\
				nTotal -= nDwords;											\
			}																\
		}																	\
	}
#else
    #define REQUIRE(n)
	#define ENDREQUIRE()
	#define WRITE_STRING(src, dwords)										\
	{																		\
		ULONG nDwords, nTotal = (ULONG) (dwords);							\
		PULONG data = (PULONG) (src);										\
		while (nTotal > 0)													\
		{																	\
			nDwords = min(nTotal, 0x200);									\
			memcpy((LPVOID) ppdev->pLgREGS->grHOSTDATA, data, nDwords * 4);	\
			data += nDwords;												\
			nTotal -= nDwords;												\
		}																	\
	}
#endif

// 
// Macros to read Laguna registers.
//
#define LADDR(pr_reg) fldoff(GAR,pr_reg)

// #define LLDR(pr_reg,pr_siz)   _AP_direct_read((ul)LADDR(pr_reg),pr_siz)
#define LLDR(pr_reg,pr_siz)   (ppdev->pLgREGS_real->pr_reg)
#define LLDR_SZ(pr_reg)  LLDR(pr_reg, fldsiz(GAR,pr_reg))

// #define LLR(pr_reg,pr_siz)   _AP_read((ul)LADDR(pr_reg),pr_siz)
#define LLR(pr_reg,pr_siz)   LLDR(pr_reg,pr_siz)
#define LLR_SZ(pr_reg)   LLR(pr_reg, fldsiz(GAR,pr_reg))


#if LOG_WRITES
    #define LG_LOG(reg,val) 	  					     	\
    do {								     	\
	    lg_i = sprintf(lg_buf,"LL\t%4X\t%08X\r\n", 			     	\
            ((DWORD)(&ppdev->pLgREGS->reg) - (DWORD)(&ppdev->pLgREGS->grCR0)),	\
	    (val));							     	\
            WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);	\
    } while(0)
#else
    #define LG_LOG(reg,val) 
#endif

//
// Macros to write Laguna registers.
// 
// This is an amazingly, incredibly hairy macro that, believe it or not,
// will be greatly reduced by a good compiler.  The "if" can be 
// pre-determined by the compiler. 
// The purpose of this is to ensure that exactly the right number of bytes
// is written to the chip.  If the programmer writes, say, a BYTE to a 
// DWORD sized register, we need to be sure that the byte is zero extended
// and that a full DWORD gets written. 
//
#define LRWRITE(pr_reg,pr_siz,value) 					\
do { 									\
  LG_LOG(pr_reg,(value));						\
  if (sizeof(ppdev->pLgREGS->pr_reg) == sizeof(BYTE)) 			\
     {									\
        *(volatile BYTE *)(&ppdev->pLgREGS->pr_reg) = (BYTE)(value); 	\
     }									\
  else if (sizeof(ppdev->pLgREGS->pr_reg) == sizeof(WORD)) 		\
     {									\
	*(volatile WORD *)(&ppdev->pLgREGS->pr_reg) = (WORD)(value); 	\
	*(volatile WORD *)(&ppdev->pLgREGS->grBOGUS) = (WORD)(value); 	\
	LG_LOG(grBOGUS,(value));					\
     }									\
  else  								\
     {									\
	 *(volatile DWORD *)(&ppdev->pLgREGS->pr_reg) = (DWORD)(value); \
     }									\
} while(0)

#define LL(pr_reg,value) LRWRITE(pr_reg, fldsiz(GAR,pr_reg), value)




// ----------------------------------------------------------------------------
//
// Certian registers have been giving us problems.  We provide special
// write macros for them.
//

//
// Writes any 8 bit register.
//
#define LL8(pr_reg,value)                                               \
    do {                                                                \
        LG_LOG(pr_reg,(value));                                         \
        (*(volatile BYTE *)(&ppdev->pLgREGS->pr_reg) = (BYTE)(value));  \
    } while(0)



//
// Writes any 16 bit register.
//
#define LL16(pr_reg,value) 						\
    do { 								\
        LG_LOG(pr_reg,(value));						\
        (*(volatile WORD *)(&ppdev->pLgREGS->pr_reg) = (WORD)(value));  \
    } while(0)



//
// Double writes any 16 bit register.
//
#define LL16d(pr_reg,value) 						\
    do { 								\
        (*(volatile WORD *)(&ppdev->pLgREGS->pr_reg) =  (WORD)(value)); \
        LG_LOG(pr_reg,(value));						\
        (*(volatile WORD *)(&ppdev->pLgREGS->grBOGUS) = (WORD)(value)); \
        LG_LOG(grBOGUS,(value));					\
    } while(0)

	 

//
// Writes any 32 bit register.
//
#define LL32(pr_reg,value)													\
{																			\
	*(volatile DWORD *)(&ppdev->pLgREGS->pr_reg) = (DWORD)(value);			\
}

//
// MACROS FOR BLTEXT REGISTER.
//

    #define LL_BLTEXT(x,y) \
    LL32 (grBLTEXT_EX.dw, (((DWORD)(y) << 16) | ((DWORD)(x))))

#if ! DRIVER_5465
    #define LL_MBLTEXT(x,y) \
        do {                                \
            LL16 (grMBLTEXT_EX.pt.X,  x);   \
            LL16 (grBLTEXT_EX.pt.Y,  y);    \
        } while(0)
#else
    #define LL_MBLTEXT(x,y) \
    LL32 (grMBLTEXT_EX.dw, (((DWORD)(y) << 16) | ((DWORD)(x))))
#endif

    #define LL_BLTEXTR(x,y) \
    LL32 (grBLTEXTR_EX.dw, (((DWORD)(y) << 16) | ((DWORD)(x))))

    #define LL_BLTEXT_EXT(x,y) \
    LL32 (grBLTEXT.dw, (((DWORD)(y) << 16) | ((DWORD)(x))))

    #define LL_MBLTEXT_EXT(x,y) 		\
    LL32 (grMBLTEXT.dw, (((DWORD)(y) << 16) | ((DWORD)(x))))


    // Launch a BLT using the color translation features of the 
    // resize engine. (1:1 resize)
    #define LL_BLTEXT_XLATE(src_bpp, x, y) \
        do {\
                LL16 (grMIN_X, (~((x)-1)));\
                LL16 (grMAJ_X, (x));\
                LL16 (grACCUM_X, ((x)-1));\
                LL16 (grMIN_Y, (~((y)-1)));\
                LL16 (grMAJ_Y, (y));\
                LL16 (grACCUM_Y, ((y)-1));\
                LL16 (grSRCX, (((x)*(src_bpp)) >> 3) );\
                LL_BLTEXTR((x), (y));\
        } while(0)



//
// MACROS FOR CLIPULE/CLIPLOR REGISTERS.
//
    #define LL_CLIPULE(x,y)                                         \
    LL32 (grCLIPULE.dw, (((DWORD)(y) << 16) | ((DWORD)(x))));

    #define LL_MCLIPULE(x,y)                                        \
    LL32 (grMCLIPULE.dw, (((DWORD)(y) << 16) | ((DWORD)(x))));

    #define LL_CLIPLOR(x,y)                                         \
    LL32 (grCLIPLOR.dw, (((DWORD)(y) << 16) | ((DWORD)(x))));

    #define LL_MCLIPLOR(x,y)                                        \
    LL32 (grMCLIPLOR.dw, (((DWORD)(y) << 16) | ((DWORD)(x))));

    #define LL_CLIPULE_EX(x,y)                                      \
    LL32 (grCLIPULE_EX.dw, (((DWORD)(y) << 16) | ((DWORD)(x))));

    #define LL_MCLIPULE_EX(x,y)                                     \
    LL32 (grMCLIPULE_EX.dw, (((DWORD)(y) << 16) | ((DWORD)(x))));

    #define LL_CLIPLOR_EX(x,y)                                      \
    LL32 (grCLIPLOR_EX.dw, (((DWORD)(y) << 16) | ((DWORD)(x))));

    #define LL_MCLIPLOR_EX(x,y)                                     \
    LL32 (grMCLIPLOR_EX.dw, (((DWORD)(y) << 16) | ((DWORD)(x))));



//
// MACROS FOR OP0_opRDRAM REGISTER.
//
    #define LL_OP0(x,y) \
    LL32 (grOP0_opRDRAM.dw, (((DWORD)(y) << 16) | ((DWORD)(x))))

    #define LL_OP0_MONO(x,y) \
    LL32 (grOP0_opMRDRAM.dw, (((DWORD)(y) << 16) | ((DWORD)(x))))




//
// MACROS FOR OP1_opRDRAM REGISTER.
//
    #define LL_OP1(x,y) \
    LL32 (grOP1_opRDRAM.dw, (((DWORD)(y) << 16) | ((DWORD)(x))))

    #define LL_OP1_MONO(x,y) \
    LL32 (grOP1_opMRDRAM.dw, (((DWORD)(y) << 16) | ((DWORD)(x))))




//
// MACROS FOR OP2_opRDRAM REGISTER.
//
    #define LL_OP2(x,y) \
    LL32 (grOP2_opRDRAM.dw, (((DWORD)(y) << 16) | ((DWORD)(x))))

    #define LL_OP2_MONO(x,y) \
    LL32 (grOP2_opMRDRAM.dw, (((DWORD)(y) << 16) | ((DWORD)(x))))




//
// -- End of special write macros --------------------------------------------
//




/*  HPR is the copy of REGISTER_STRUCTURE that the host reads and writes from.
    PR is the actual register state after the information has gone
    through the FIFO.  Immediate registers are kept up-to-date in HPR.
    These structures are allocated in the link file.  */

extern GAR PR;		/* the emulator working copy */
extern GAR HPR[4];		/* the "host" copy */

#define LAGUNA_SRAM_SIZE	32  /* dwords */

#define IS_SRC 0x03		/* Source mask. */

struct _vid_mode {
	BYTE	Bpp;		// Bytes per pixel (8 / 16 / 24 / 32)
	WORD	Xextent;	// Display rsolution in pixels eg 1280
	WORD	Yextent;	// Vertical display resolution
	WORD	Xpitch;		// Offset in bytes from line 0 to line 1
	int		Vesa_Mode;	// Mode number for VESA ( if supported by S3 )
	};

typedef struct _vid_mode vid_mode;
typedef vid_mode *vid_ptr;


/***************************************************************************
*
* MACRO:        SYNC_W_3D
*
* DESCRIPTION:  If 3d context(s) active, wait until 3d engine idle
*                or until 1,000,000 checks have failed
*
****************************************************************************/

#if WINNT_VER40 && DRIVER_5465     // WINNT_VER40

    #define SYNC_3D_CONDITIONS (ST_POLY_ENG_BUSY|ST_EXEC_ENG_3D_BUSY|ST_XY_ENG_BUSY|/*ST_BLT_ENG_BUSY|*/ST_BLT_WF_EMPTY)

    #define ENSURE_3D_IDLE(ppdev)                                                                               \
    {                                                                                                           \
      if (ppdev->pLgREGS != NULL)                                                                               \
      {                                                                                                         \
         int num_syncs=2;                                                                                       \
         /* there is a slight chance of a window in which all bits go off while engine fetching */              \
         /*   next command - double read should catch that                                      */              \
         while (num_syncs--)                                                                                    \
         {                                                                                                      \
             int status;                                                                                        \
             volatile int wait_count=0;                                                                         \
             do                                                                                                 \
             {                                                                                                  \
                 status = (*((volatile *)((DWORD *)(ppdev->pLgREGS) + PF_STATUS_3D)) & 0x3FF) ^ SYNC_3D_CONDITIONS; \
                 /* do something to give bus a breather, and to prevent eternal stall */                        \
                 wait_count++;                                                                                  \
             } while(((status & SYNC_3D_CONDITIONS) != SYNC_3D_CONDITIONS) && wait_count<1000000);              \
         }                                                                                                      \
      }                                                                                                         \
    }

    #define SYNC_W_3D(ppdev)                                                                                    \
    {                                                                                                           \
        if (ppdev->NumMCDContexts > 0)                                                                          \
        {                                                                                                       \
            ENSURE_3D_IDLE(ppdev);                                                                              \
        }                                                                                                       \
    }

#else // WINNT_VER40 && DRIVER_5465

    // no 3D on NT before NT4.0.  No 3D on 62 and not used on 64.
    #define ENSURE_3D_IDLE(ppdev)    {}
    #define SYNC_W_3D(ppdev)    {}

#endif // WINNT_VER40

//
// New shadowing macros.
//
#define LL_FGCOLOR(color, r)												\
{																			\
	if ((DWORD) (color) != ppdev->shadowFGCOLOR)							\
	{																		\
		if (r) REQUIRE(r);													\
		LL32(grOP_opFGCOLOR, ppdev->shadowFGCOLOR = (DWORD) (color));		\
	}																		\
}

#define LL_BGCOLOR(color, r)												\
{																			\
	if ((DWORD) (color) != ppdev->shadowBGCOLOR)							\
	{																		\
		if (r) REQUIRE(r);													\
		LL32(grOP_opBGCOLOR, ppdev->shadowBGCOLOR = (DWORD) (color));		\
	}																		\
}

#define LL_DRAWBLTDEF(drawbltdef, r)										\
{																			\
	if ((DWORD) (drawbltdef) != ppdev->shadowDRAWBLTDEF)					\
	{																		\
		if (r) REQUIRE(r);													\
		LL32(grDRAWBLTDEF, ppdev->shadowDRAWBLTDEF = (DWORD) (drawbltdef));	\
	}																		\
}

#endif /* ndef _LAGUNA_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\lines.h ===
/******************************Module*Header*******************************\
* Module Name: lines.h
*
* Line drawing constants and structures.
*
* NOTE: This file mirrors LINES.INC.  Changes here must be reflected in
* the .inc file!
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

typedef struct _PDEV PDEV;      // Handy forward declaration

// We have to be careful that we don't overflow any registers when using
// the hardware to draw lines (as opposed to going through the strips
// routines, which will never overflow).  We accomplish this by simply
// checking the bounds of the path; if it is so large that any of the
// hardware terms may overflow, we punt the entire path to the strips
// code (should be pretty rare).

#define MAX_INTEGER_BOUND  (1535)   // S3's line length term is limited to
#define MIN_INTEGER_BOUND  (-512)   //   a maximum value of 2047

// We have special strip routines when all strips have at most this many
// pixels:

#define MAX_SHORT_STROKE_LENGTH 15

// # of strip drawers in every group:

#define NUM_STRIP_DRAW_DIRECTIONS 4

// # of strip drawers for doing either solid lines or styled lines:

#define NUM_STRIP_DRAW_STYLES 8

typedef LONG STYLEPOS;

#define STYLE_MAX_COUNT     16
#define STYLE_MAX_VALUE     0x3fffL
#define RUN_MAX             20
#define STRIP_MAX           100
#define STYLE_DENSITY       3

// Flip and round flags:

#define FL_H_ROUND_DOWN         0x00000080L     // .... .... 1... ....
#define FL_V_ROUND_DOWN         0x00008000L     // 1... .... .... ....

#define FL_FLIP_D               0x00000005L     // .... .... .... .1.1
#define FL_FLIP_V               0x00000008L     // .... .... .... 1...
#define FL_FLIP_SLOPE_ONE       0x00000010L     // .... .... ...1 ....
#define FL_FLIP_HALF            0x00000002L     // .... .... .... ..1.
#define FL_FLIP_H               0x00000200L     // .... ..1. .... ....

#define FL_ROUND_MASK           0x0000001CL     // .... .... ...1 11..
#define FL_ROUND_SHIFT          2

#define FL_RECTLCLIP_MASK       0x0000000CL     // .... .... .... 11..
#define FL_RECTLCLIP_SHIFT      2

#define FL_STRIP_MASK           0x00000003L     // .... .... .... ..11
#define FL_STRIP_SHIFT          0

#define FL_SIMPLE_CLIP          0x00000020      // .... .... ..1. ....
#define FL_COMPLEX_CLIP         0x00000040      // .... .... .1.. ....
#define FL_CLIP                (FL_SIMPLE_CLIP | FL_COMPLEX_CLIP)

#define FL_STYLED               0x00000400L     // .... .1.. .... ....
#define FL_ALTERNATESTYLED      0x00001000L     // ...1 .... .... ....

#define FL_STYLE_MASK           0x00000400L
#define FL_STYLE_SHIFT          10

#define FL_LAST_PEL_INCLUSIVE   0x00002000L     // ..1. .... .... ....

// Miscellaneous DDA defines:

#define LROUND(x, flRoundDown) (((x) + F/2 - ((flRoundDown) > 0)) >> 4)
#define F                     16
#define FLOG2                 4
#define LFLOOR(x)             ((x) >> 4)
#define FXFRAC(x)             ((x) & (F - 1))

////////////////////////////////////////////////////////////////////////////
// NOTE: The following structures must exactly match those declared in
//       lines.inc!

typedef struct _STRIP {
    LONG   cStrips;               // # of strips in array
    LONG   flFlips;               // Indicates if line goes up or down
    POINTL ptlStart;             // first point
    LONG   alStrips[STRIP_MAX];   // Array of strips
} STRIP;

typedef struct _LINESTATE {
    STYLEPOS*       pspStart;       // Pointer to start of style array
    STYLEPOS*       pspEnd;         // Pointer to end of style array
    STYLEPOS*       psp;            // Pointer to current style entry

    STYLEPOS        spRemaining;    // To go in current style
    STYLEPOS        spTotal;        // Sum of style array
    STYLEPOS        spTotal2;       // Twice sum of style array
    STYLEPOS        spNext;         // Style state at start of next line
    STYLEPOS        spComplex;      // Style state at start of complex clip line

    STYLEPOS*       aspRtoL;        // Style array in right-to-left order
    STYLEPOS*       aspLtoR;        // Style array in left-to-right order

    ULONG           ulStyleMask;    // Are we working on a gap in the style?
                                    // 0xff if yes, 0x0 if not
    ULONG           xyDensity;      // Density of style
    ULONG           cStyle;         // Size of style array

    ULONG           ulStyleMaskLtoR;// Original style mask, left-to-right order
    ULONG           ulStyleMaskRtoL;// Original style mask, right-to-left order

    BOOL            ulStartMask;    // Determines if first element in style
                                    // array is for a gap or a dash

} LINESTATE;                        /* ls */

// Strip drawer prototype:

typedef VOID (*PFNSTRIP)(PDEV*, STRIP*, LINESTATE*);
extern PFNSTRIP gapfnStrip[];

// Strip drawers:

VOID vssSolidHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vssSolidVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vssSolidDiagonalHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidDiagonalHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vssSolidDiagonalVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidDiagonalVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vStripStyledHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vStripStyledVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

// External calls:

BOOL bLines(PDEV*, POINTFIX*, POINTFIX*, RUN* prun, ULONG,
            LINESTATE*, RECTL*, PFNSTRIP*, FLONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\lgregs.h ===
/****************************************************************************
*****************************************************************************
*
*                ******************************************
*                * Copyright (c) 1995, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:           Laguna I - Emulator
*
* FILE:              lgregs.h
*
* AUTHOR:            Austin Watson / Martin Barber.
*
* DESCRIPTION:       Register layout for Laguna Access.
*
* MODULES:
*
* REVISION HISTORY:
*                    5/10/95 agw - added all V1.5 memory mapped regs.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/LGREGS.H  $
* 
*    Rev 1.16   Dec 10 1997 13:25:02   frido
* Merged from 1.62 branch.
* 
*    Rev 1.15.1.0   Nov 18 1997 15:17:54   frido
* Always have the 3D registers available for the 5465 chip.
* Added mailbox registers for hardware debugging.
* 
*    Rev 1.15   Nov 04 1997 11:44:24   frido
* Fixed a typo in grCONTROL2 register.
* 
*    Rev 1.14   29 Aug 1997 17:08:52   RUSSL
* Added overlay support
*
*    Rev 1.13   29 Apr 1997 16:26:32   noelv
* Added SWAT code.
* SWAT:
* SWAT:    Rev 1.2   24 Apr 1997 10:10:12   frido
* SWAT: NT140b09 merge.
*
*    Rev 1.12   06 Feb 1997 10:34:22   noelv
*
* Added 5465 registers.
*
*    Rev 1.11   28 Jan 1997 14:32:38   SueS
* Added CHROMA_CNTL, BLTEXT, and MBLTEXT for the 65.
*
*    Rev 1.10   24 Jan 1997 08:29:48   SueS
* Added some more clipping registers for the 5465.
*
*    Rev 1.9   23 Jan 1997 17:15:18   bennyn
*
* Modified to support 5465 DD
*
*    Rev 1.8   16 Jan 1997 11:40:18   bennyn
*
* Added VS_CLK_CONTROL register
*
*    Rev 1.7   01 Nov 1996 09:25:18   BENNYN
*
*
*    Rev 1.6   25 Oct 1996 11:54:08   noelv
*
* Added ifdef around new '64 registers
*
*    Rev 1.5   24 Oct 1996 14:27:14   noelv
*
* Added some 3d registers.
*
*    Rev 1.4   20 Aug 1996 11:05:06   noelv
* Bugfix release from Frido 8-19-96
*
*    Rev 1.0   14 Aug 1996 17:16:38   frido
* Initial revision.
*
*    Rev 1.3   05 Mar 1996 11:59:54   noelv
* Frido version 19
 *
 *    Rev 1.0   17 Jan 1996 12:53:24   frido
 * Checked in from initial workfile by PVCS Version Manager Project Assistant.
*
*    Rev 1.1   11 Oct 1995 14:49:20   NOELV
*
* Added BOGUS register at address 5FC.
*
*    Rev 1.0   28 Jul 1995 14:03:20   NOELV
* Initial revision.
*
*    Rev 1.1   29 Jun 1995 13:23:18   NOELV
*
*
****************************************************************************
****************************************************************************/

#ifndef _LGREGS_
#define _LGREGS_

#include "lgtypes.h"
#include "optimize.h"

#if DRIVER_5465 && defined(OVERLAY)
/* 5465 Video Window registers data type */
#define MAX_VIDEO_WINDOWS       8   // space for eight video windows in MMIO regs

typedef struct tagVIDEOWINDOWSTRUCT
{
  WORD  grVW_HSTRT;                         // Base of VW + 0x0000
  BYTE  grPAD1_VW[0x0004-0x0002];
  WORD  grVW_HEND;                          // Base of VW + 0x0004
  WORD  grVW_HSDSZ;                         // Base of VW + 0x0006
  DWORD grVW_HACCUM_STP;                    // Base of VW + 0x0008
  DWORD grVW_HACCUM_SD;                     // Base of VW + 0x000C
  WORD  grVW_VSTRT;                         // Base of VW + 0x0010
  WORD  grVW_VEND;                          // Base of VW + 0x0012
  DWORD grVW_VACCUM_STP;                    // Base of VW + 0x0014
  DWORD grVW_VACCUM_SDA;                    // Base of VW + 0x0018
  DWORD grVW_VACCUM_SDB;                    // Base of VW + 0x001C
  DWORD grVW_PSD_STRT_ADDR;                 // Base of VW + 0x0020
  DWORD grVW_SSD_STRT_ADDR;                 // Base of VW + 0x0024
  DWORD grVW_PSD_UVSTRT_ADDR;               // Base of VW + 0x0028
  DWORD grVW_SSD_UVSTRT_ADDR;               // Base of VW + 0x002C
  BYTE  grPAD2_VW[0x0040-0x0030];
  WORD  grVW_SD_PITCH;                      // Base of VW + 0x0040
  BYTE  grPAD3_VW[0x0044-0x0042];
  DWORD grVW_CLRKEY_MIN;                    // Base of VW + 0x0044
  DWORD grVW_CLRKEY_MAX;                    // Base of VW + 0x0048
  DWORD grVW_CHRMKEY_MIN;                   // Base of VW + 0x004C
  DWORD grVW_CHRMKEY_MAX;                   // Base of VW + 0x0050
  WORD  grVW_BRIGHT_ADJ;                    // Base of VW + 0x0054
  BYTE  grPAD4_VW[0x00D4-0x0056];
  BYTE  grVW_Z_ORDER;                       // Base of VW + 0x00D4
  BYTE  grPAD5_VW[0x00D8-0x00D5];
  WORD  grVW_FIFO_THRSH;                    // Base of VW + 0x00D8
  BYTE  grPAD6_VW[0x00E0-0x00DA];
  DWORD grVW_CONTROL1;                      // Base of VW + 0x00E0
  DWORD grVW_CONTROL0;                      // Base of VW + 0x00E4
  DWORD grVW_CAP1;                          // Base of VW + 0x00E8
  DWORD grVW_CAP0;                          // Base of VW + 0x00EC
  DWORD grVW_TEST0;                         // Base of VW + 0x00F0
  BYTE  grPAD7_VW[0x0100-0x00F4];
} VIDEOWINDOWSTRUCT;
#endif	// DRIVER_5465 && OVERLAY

/*  Registers to be added. */
/*  5.3   PCI Configuration Registers */
/*  5.4   IO Registers */
/*        5.4.1 General VGA Registers */
/*        5.4.2 VGA Sequencer Registers */
/*        5.4.3 CRT Controller Registers */
/*        5.4.4 VGA Graphics Controller Registers */
/*        5.4.5 Attribute Controller Registers */
/*        5.4.6 Host Control Registers */

/*  Laguna Graphics Accelerator Registers data type. */

typedef struct GAR {

/*  5.5   Memory Mapped Registers */
/*  5.5.1 Memory Mapped VGA Regsiters */
  BYTE grCR0;      /* 0h */
  BYTE grPADCR0[3];
  BYTE grCR1;      /* 04h */
  BYTE grPADCR1[3];
  BYTE grCR2;      /* 08h */
  BYTE grPADCR2[3];
  BYTE grCR3;      /* 0Ch */
  BYTE grPADCR3[3];
  BYTE grCR4;      /* 010h */
  BYTE grPADCR4[3];
  BYTE grCR5;      /* 014h */
  BYTE grPADCR5[3];
  BYTE grCR6;      /* 018h */
  BYTE grPADCR[3];
  BYTE grCR7;      /* 01Ch */
  BYTE grPADCR7[3];
  BYTE grCR8;      /* 020h */
  BYTE grPADCR8[3];
  BYTE grCR9;      /* 024h */
  BYTE grPADCR9[3];
  BYTE grCRA;      /* 028h */
  BYTE grPADCRA[3];
  BYTE grCRB;      /* 02Ch */
  BYTE grPADCRB[3];
  BYTE grCRC;      /* 030h */
  BYTE grPADCRC[3];
  BYTE grCRD;      /* 034h */
  BYTE grPADCRD[3];
  BYTE grCRE;      /* 038h */
  BYTE grPADCRE[3];
  BYTE grCRF;      /* 03Ch */
  BYTE grPADCRF[3];
  BYTE grCR10;    /* 040h */
  BYTE grPADCR10[3];
  BYTE grCR11;    /* 044h */
  BYTE grPADCR11[3];
  BYTE grCR12;    /* 048h */
  BYTE grPADCR12[3];
  BYTE grCR13;    /* 04Ch */
  BYTE grPADCR13[3];
  BYTE grCR14;    /* 050h */
  BYTE grPADCR14[3];
  BYTE grCR15;    /* 054h */
  BYTE grPADCR15[3];
  BYTE grCR16;    /* 058h */
  BYTE grPADCR16[3];
  BYTE grCR17;    /* 05Ch */
  BYTE grPADCR17[3];
  BYTE grCR18;    /* 060h */
  BYTE grPADCR18[3];
  BYTE grCR19;    /* 064h */
  BYTE grPADCR19[3];
  BYTE grCR1A;    /* 068h */
  BYTE grPADCR1A[3];
  BYTE grCR1B;    /* 06Ch */
  BYTE grPADCR1B[0x74-0x6D];

  BYTE grCR1D;    /* 074h */
  BYTE grPADCR1D[3];
  BYTE grCR1E;    /* 078h */
  BYTE grPADCR1E[0x80-0x79];

  BYTE grMISC;    /* 080h */
  BYTE grPADMISC[3];
  BYTE grSRE;      /* 084h */
  BYTE grPADSRE[3];
  BYTE grSR1E;    /* 088h */
  BYTE grPADSR1E[3];
  BYTE grBCLK_Numerator;    /* 08Ch */
  BYTE grPADBCLK_Numerator[3];

  BYTE grSR18;    /* 090h */
  BYTE grPADSR18[3];
  BYTE grSR19;    /* 094h */
  BYTE grPADSR19[3];
  BYTE grSR1A;    /* 098h */
  BYTE grPADSR1A[0xA0-0x99];

  BYTE grPalette_Mask;        /* 0A0h */
  BYTE grPADPalette_Mask[3];
  BYTE grPalette_Read_Address;    /* 0A4h */
  BYTE grPADPalette_Read_Address[3];
#define  grPalette_State_Read_Only grPalette_Read_Address
  BYTE grPalette_Write_Address;    /* 0A8h */
  BYTE grPADPalette_Write_Address[3];
  BYTE grPalette_Data;        /* 0ACh */
  BYTE grPADPalette_Data[0xB0-0xAD];

/*  5.5.2 Video Pipeline Registers */

  BYTE grPalette_State;   /* 0B0h */
  BYTE grPADPalette_State[0xB4 - 0xB1];

  BYTE grExternal_Overlay;/* 0B4h */
  BYTE grPADExternal_Overlay[0xB8- 0xB5];

  BYTE grColor_Key;       /* 0B8h */
  BYTE grPADColor_Key[0xBC- 0xB9];

  BYTE grColor_Key_Mask;  /* 0BCh */
  BYTE grPADColor_Key_Mask[0xC0- 0xBD];

  WORD grFormat;          /* 0C0h */
  BYTE grPADFormat[0xCA- 0xC2];

  BYTE grStart_BLT_3;     /* 0CAh */
  BYTE grStop_BLT_3;      /* 0CBh */
  WORD grX_Start_2;       /* 0CCh */
  WORD grY_Start_2;       /* 0CEh */
  WORD grX_End_2;         /* 0D0h */
  WORD grY_End_2;         /* 0D2h */
  BYTE grStart_BLT_2;     /* 0D4h */
  BYTE grStop_BLT_2;      /* 0D5h */
  BYTE grPADStop_BLT_2[0xDE- 0xD6];

  BYTE grStart_BLT_1;     /* 0DEh */
  BYTE grStop_BLT_1;      /* 0DFh */
  WORD grCursor_X;        /* 0E0h */
  WORD grCursor_Y;        /* 0E2h */
  WORD grCursor_Preset;   /* 0E4h */
  WORD grCursor_Control;  /* 0E6h */
  WORD grCursor_Location; /* 0E8h */
  WORD grDisplay_Threshold_and_Tiling;  /* 0EAh */
  BYTE grPADDisplay_Thr[0xF0- 0xEC];

  WORD grTest;            /* 0F0h */
  WORD grTest_HT;         /* 0F2h */
  WORD grTest_VT;         /* 0F4h */

  BYTE  grPADTest_VT[0x100 - 0x00F6];

/*  5.5.3 VPort Registers */

  WORD  grX_Start_Odd;    /* 100h */
  WORD  grX_Start_Even;   /* 102h */
  WORD  grY_Start_Odd;    /* 104h */
  WORD  grY_Start_Even;   /* 106h */
  WORD  grVport_Width;    /* 108h */
  BYTE  grVport_Height;   /* 10Ah */
  BYTE  grPADVport_Height;
  WORD  grVport_Mode;     /* 10Ch */

  BYTE  grVportpad[0x180 - 0x10E];

/*  5.5.4 LPB Registers */

  BYTE  grLPB_Data[0x1F8-0x180];    /* 180h */
  BYTE  grPADLPB[0x1FC - 0x1F8];
  WORD  grLPB_Config;     /* 1FCh */
  WORD  grLPB_Status;     /* 1FEh */

#define grLPB_Data_0 grLPB_Data[0]
#define grLPB_Data_1 grLPB_Data[1]
#define grLPB_Data_2 grLPB_Data[2]
#define grLPB_Data_3 grLPB_Data[3]
#define grLPB_Data_4 grLPB_Data[4]
#define grLPB_Data_5 grLPB_Data[5]
#define grLPB_Data_6 grLPB_Data[6]
#define grLPB_Data_7 grLPB_Data[7]
#define grLPB_Data_8 grLPB_Data[8]
#define grLPB_Data_9 grLPB_Data[9]
#define grLPB_Data_10 grLPB_Data[10]
#define grLPB_Data_11 grLPB_Data[11]
#define grLPB_Data_12 grLPB_Data[12]
#define grLPB_Data_13 grLPB_Data[13]
#define grLPB_Data_14 grLPB_Data[14]
#define grLPB_Data_15 grLPB_Data[15]
#define grLPB_Data_16 grLPB_Data[16]
#define grLPB_Data_17 grLPB_Data[17]
#define grLPB_Data_18 grLPB_Data[18]
#define grLPB_Data_19 grLPB_Data[19]
#define grLPB_Data_20 grLPB_Data[20]
#define grLPB_Data_21 grLPB_Data[21]
#define grLPB_Data_22 grLPB_Data[22]
#define grLPB_Data_23 grLPB_Data[23]
#define grLPB_Data_24 grLPB_Data[24]
#define grLPB_Data_25 grLPB_Data[25]
#define grLPB_Data_26 grLPB_Data[26]
#define grLPB_Data_27 grLPB_Data[27]
#define grLPB_Data_28 grLPB_Data[28]
#define grLPB_Data_29 grLPB_Data[29]
#define grLPB_Data_30 grLPB_Data[30]
#define grLPB_Data_31 grLPB_Data[31]

/*  5.5.5 RAMBUS Registers */
/*  RAMBUS Registers for BIOS Simulation */

  WORD   grRIF_CONTROL;    /* 200 */
  WORD   grRAC_CONTROL;    /* 202 */
  WORD   grRAMBUS_TRANS;   /* 204 */
  BYTE   grPADRAMBUS_TRANS[0x240 - 0x206];
  REG32  grRAMBUS_DATA;   /* 240 */
  BYTE   grPADRAMBUS_DATA[0x280 - 0x244];

/*  5.5.6 Miscellaneous Registers */
  WORD   grSerial_BusA;					/* 0280h */
  WORD   grSerial_BusB;    				/* 0282h */
  BYTE   grPADMiscellaneous_1[0x2C0 - 0x284];
  BYTE	 grBCLK_Multiplier;				/* 0x2C0 */
  BYTE	 grBCLK_Denominator;			/* 0x2C1 */
  BYTE   grPADMiscellaneous_2[0x2C4 - 0x2C2];
  WORD	 grTiling_Control;				/* 0x2C4 */
  BYTE   grPADMiscellaneous_3[0x2C8 - 0x2C6];
  WORD   grFrame_Buffer_Cache_Control;	/* 0x2C8 */
  BYTE	 grPADMiscellaneous_4[0x300 - 0x2CA];

/*  5.5.7 PCI Configuration Registers */
  WORD   grVendor_ID;      /* 0300h */
  WORD   grDevice_ID;      /* 0302h */
  WORD   grCommand;        /* 0304h */
  WORD   grStatus;         /* 0306h */
  BYTE   grRevision_ID;    /* 0308h */
  BYTE   grClass_Code;     /* 0309h */
  BYTE   grPADClass_Code[0x30E - 0x30A];

  BYTE   grHeader_Type;    /* 030Eh */
  BYTE   grPADHeader_Type[0x310 - 0x30F];

  REG32  grBase_Address_0;      /* 0310h */
  REG32  grBase_Address_1;      /* 0314h */
  BYTE   grPADBase_Address_1[0x32C - 0x318];

  WORD   grSubsystem_Vendor_ID; /* 032Ch */
  WORD   grSubsystem_ID;        /* 032Eh */
  REG32  grExpansion_ROM_Base;  /* 0330h */
  BYTE   grPADExpansion_ROM_Base[0x33C - 0x334];

  BYTE   grInterrupt_Line;    /* 033Ch */
  BYTE   grInterrupt_Pin;     /* 033Dh */
//#if DRIVER_5465
  BYTE   grPADInterrupt_Pin[0x3F4 - 0x33E];
  DWORD  grVS_Clk_Control;   /* 03F4h */
//#else
//  BYTE   grPADInterrupt_Pin[0x3F8 - 0x33E];
//#endif

  REG32  grVGA_Shadow;       /* 03F8h */
  DWORD  grVS_Control;       /* 03FCh */

/*  5.5.8 Graphics Accelerator Registers */

/*  The 2D Engine control registers */

  WORD   grSTATUS;           /* 400 */
  WORD   grCONTROL;          /* 402 */
  BYTE   grQFREE;            /* 404 */
  BYTE   grOFFSET_2D;        /* 405 */
  BYTE   grTIMEOUT;          /* 406 */
  BYTE   grTILE_CTRL;        /* 407 */
  REG32  grRESIZE_A_opRDRAM; /* 408 */
  REG32  grRESIZE_B_opRDRAM; /* 40C */
  REG32  grRESIZE_C_opRDRAM; /* 410 */
  WORD	 grSWIZ_CNTL;		 /* 414 */
  WORD	 pad99;
  WORD	 grCONTROL2;		 /* 418 */
  BYTE   pad2[0x480 - 0x41A];
  REG32  grCOMMAND;          /* 480 */
  BYTE   pad3[0x500 - 0x484];
  WORD   grMIN_Y;            /* 500 */
  WORD   grMAJ_Y;            /* 502 */
  WORD   grACCUM_Y;          /* 504 */
  BYTE   pad3A[0x508 - 0x506];
  WORD   grMIN_X;            /* 508 */
  WORD   grMAJ_X;            /* 50A */
  WORD   grACCUM_X;          /* 50C */
  REG16  grLNCNTL;           /* 50E */
  REG16  grSTRETCH_CNTL;     /* 510 */
  REG16  grCHROMA_CNTL;      /* 512 */
  BYTE   pad3B[0x518 - 0x514];
  REG32  grBLTEXT;           /* 518 */
  REG32  grMBLTEXT;          /* 51C */
  REG32  grOP0_opRDRAM;      /* 520 */
  REG32  grOP0_opMRDRAM;     /* 524 */
  WORD   grOP0_opSRAM;       /* 528 */
  REG16  grPATOFF;           /* 52A */
  BYTE   pad4[0x540 - 0x52C];
  REG32  grOP1_opRDRAM;      /* 540 */
  REG32  grOP1_opMRDRAM;     /* 544 */
  WORD   grOP1_opSRAM;       /* 548 */
  WORD   grOP1_opMSRAM;      /* 54A */
  BYTE   pad5[0x560 - 0x54C];
  REG32  grOP2_opRDRAM;      /* 560 */
  REG32  grOP2_opMRDRAM;     /* 564 */
  WORD   grOP2_opSRAM;       /* 568 */
  WORD   grOP2_opMSRAM;      /* 56A */
  BYTE   pad6[0x580 - 0x56C];
  WORD   grSRCX;             /* 580 */
  REG16  grSHRINKINC;        /* 582 */

  REG32  grDRAWBLTDEF;       /* 584 */
#define  grDRAWDEF grDRAWBLTDEF.LH.LO   /* 584 */
#define  grBLTDEF  grDRAWBLTDEF.LH.HI   /* 586 */

  REG16  grMONOQW;           /* 588 */
  WORD   pad6a;              /* 58A */
  WORD   grPERFORMANCE;      /* 58C */
  WORD   pad7;               /* 58E */
  REG32  grCLIPULE;          /* 590 */
  REG32  grCLIPLOR;          /* 594 */
  REG32  grMCLIPULE;         /* 598 */
  REG32  grMCLIPLOR;         /* 59C */
  BYTE   pad7a[0x5e0 - 0x5A0];

  REG32  grOP_opFGCOLOR;     /* 5E0 */
  REG32  grOP_opBGCOLOR;     /* 5E4 */
  REG32  grBITMASK;          /* 5E8 */
  WORD   grPTAG;             /* 5EC */
  BYTE   pad8[0x5FC - 0x5ee];
  WORD   grBOGUS;            /* 5FC */
  REG32  grBLTEXT_XEX;       /* 600 */
  REG32  grBLTEXTFF_XEX;     /* 604 */
  REG32  grBLTEXTR_XEX;      /* 608 */
  WORD   grBLTEXT_LN_EX;     /* 60C */
  BYTE   pad9[0x620 - 0x60E];
  REG32  grMBLTEXT_XEX;      /* 620 */
  BYTE   pad9a[0x628 - 0x624];
  REG32  grMBLTEXTR_XEX;     /* 628 */
  BYTE   pad9b[0x700 - 0x62C];
  REG32  grBLTEXT_EX;        /* 700 */
  REG32  grBLTEXTFF_EX;      /* 704 */
  REG32  grBLTEXTR_EX;       /* 708 */
  BYTE   pad10[0x720 - 0x70c];
  REG32  grMBLTEXT_EX;       /* 720 */
  BYTE   pad10a[0x728 - 0x724];
  REG32  grMBLTEXTR_EX;      /* 728 */
  BYTE   pad10b[0x760 - 0x72C];
  REG32  grCLIPULE_EX;       /* 760 */
  BYTE   pad10c[0x770 - 0x764];
  REG32  grCLIPLOR_EX;       /* 770 */
  BYTE   pad10d[0x780 - 0x774];
  REG32  grMCLIPULE_EX;      /* 780 */
  BYTE   pad10e[0x790 - 0x784];
  REG32  grMCLIPLOR_EX;      /* 790 */
  BYTE   pad10f[0x7fc - 0x794];
  WORD   RECORD;             /*  7fc dummy for emulator */
  WORD   BREAKPOINT;         /*  7fe dummy for harware sim */
  DWORD  grHOSTDATA[0x800];  /* 800 thru 27ff  */

#if DRIVER_5465
  BYTE   pad23[0x413C - 0x2800];

  DWORD  grSTATUS0_3D;       /* 413C*/

  BYTE   pad24[0x4200 - 0x4140];

  DWORD  grHXY_BASE0_ADDRESS_PTR_3D;     /* 4200 */
  REG32  grHXY_BASE0_START_3D;           /* 4204 */
  REG32  grHXY_BASE0_EXTENT_3D;          /* 4208 */

  DWORD  pad25;            /* 420C */

  DWORD  grHXY_BASE1_ADDRESS_PTR_3D;     /* 4210 */
  DWORD  grHXY_BASE1_OFFSET0_3D;         /* 4214 */
  DWORD  grHXY_BASE1_OFFSET1_3D;         /* 4218 */
  DWORD  grHXY_BASE1_LENGTH_3D;          /* 421C */

  DWORD  pad27[8];               /* 4220 thru 423C */

  DWORD  grHXY_HOST_CRTL_3D;     /* 4240 */
  BYTE   pad3x[0x4260 - 0x4244];
  DWORD  grMAILBOX0_3D;			 /* 4260 */
  DWORD  grMAILBOX1_3D;			 /* 4264 */
  DWORD  grMAILBOX2_3D;			 /* 4268 */
  DWORD  grMAILBOX3_3D;			 /* 426C */
  BYTE   pad30[0x4424 - 0x4270];
  DWORD  grPF_STATUS_3D;         /* 4424 */

  BYTE   pad50[0x8000 - 0x4428];
#if defined(OVERLAY)
  /* Video Window Registers (CL_GD5465) */
  struct tagVIDEOWINDOWSTRUCT   VideoWindow[MAX_VIDEO_WINDOWS];
#endif
#endif

} Graphics_Accelerator_Registers_Type, * pGraphics_Accelerator_Registers_Type, GAR;

/*  Status Register values */

#define STATUS_FIFO_NOT_EMPTY 0x0001
#define STATUS_PIPE_BUSY 0x0002
#define STATUS_DATA_AVAIL 0x8000

#define STATUS_IDLE ( STATUS_PIPE_BUSY | STATUS_FIFO_NOT_EMPTY )

/*  Control register values */
#define WFIFO_SIZE_32 0x0100
#define HOST_DATA_AUTO 0x0200
#define SWIZ_CNTL 0x0400
/*  bits 12:11 define tile size */
#define TILE_SIZE_128 0x0000
#define TILE_SIZE_256 0x0800
#define TILE_SIZE_2048 0x1800
/*  bits 14:13 define bits per pixel for graphics modes */
#define CNTL_8_BPP 0x0000
#define CNTL_16_BPP 0x2000
#define CNTL_24_BPP 0x4000
#define CNTL_32_BPP 0x6000

/*  Tile_ctrl register */
/*  bits 7:6 interleave memory */
#define ILM_1_WAY 0x00
#define ILM_2_WAY 0x40
#define ILM_4_WAY 0x80
/*  bits 5:0 define BYTE pitch of display memory in conjunction with TILE_SIZE */
/*  from Control register */


/*
 * DRAWDEF contents
*/
#define DD_ROP      0x0000
#define DD_TRANS    0x0100      /*  transparent */
#define DD_TRANSOP  0x0200
#define DD_PTAG     0x0400
#define DD_CLIPEN   0x0800

/*  These bits moved to LNCNTL */
/* #define DD_INTERP    0x0800 */
/* #define DD_XSHRINK    0x1000 */
/* #define DD_YSHRINK    0x2000 */

#define DD_SAT_2    0x4000
#define DD_SAT_1    0x8000


/*  LN_CNTL fields */

#define LN_XINTP_EN    0x0001
#define LN_YINTP_EN    0x0002
#define LN_XSHRINK    0x0004
#define LN_YSHRINK    0x0008

/* These are the autoblt control bits */

#define LN_RESIZE 0x0100
#define LN_CHAIN_EN 0x0200

/*  These are the yuv411 output average control bits */
#define  LN_LOWPASS 0x1000
#define LN_UVHOLD 0x2000

/* This extracts the data format field from LNCNTL */

#define LN_FORMAT 0x00F0
#define LN_YUV_SHIFT 4

#define LN_8BIT  0x0000
#define LN_RGB555 0x0001
#define LN_RGB565 0x0002
#define LN_YUV422 0x0003
#define LN_24ARGB 0x0004
#define LN_24PACK 0x0005
#define LN_YUV411 0x0006
/*  7 - 15 are reserved */

/*
 * pmBLTDEF contents
 */

#define BD_OP2    0x0001  /*  start of OP2 field 3:0 */
#define BD_OP1    0x0010  /*  start of OP1 field 7:4 */
#define BD_OP0    0x0100  /*  start of OP0 field 8:8 */
#define BD_TRACK_X  0x0200  /*  Track OP ptrs in X 9:9 (when implemented) */
#define BD_TRACK_Y  0x0400  /*  Track OP ptrs in Y 10:10 (when implemented) */
#define BD_SAME    0x0800  /*  common operand field 11:11 */
#define BD_RES    0x1000  /*  start of RES field 14:12 */
#define BD_YDIR    0x8000  /*  y direction bit 15: */

/*
 * Field values for BD_OP? and BD_res.
 * LL( grBLTDEF,  (BD_OP1 * IS_HOST_MONO) +
 *      (BD_OP2 * (IS_VRAM + IS_PATTERN )) +
 *      (BD_RES * IS_VRAM) );
 */

#define IS_SRAM    0x0000
#define IS_VRAM    0x0001
#define IS_HOST    0x0002
#define IS_SOLID  0x0007
#define IS_SRAM_MONO  0x0004
#define IS_VRAM_MONO  0x0005
#define IS_HOST_MONO  0x0006
#define IS_PATTERN  0x0008
#define IS_MONO    0x0004

/*  these are for BD_RES only */
#define IS_SRAM0  0x0004
#define IS_SRAM1  0x0005
#define IS_SRAM2  0x0006
#define IS_SRAM12  0x0007

/*  these are for BD_SAME */
#define NONE  0x0000


// Be sure to synchronize this structure with the one in i386\Laguna.inc!
typedef struct _autoblt_regs {
  REG16  LNCNTL;
  REG16  SHRINKINC;
  REG32  DRAWBLTDEF;
  REG32  FGCOLOR;
  REG32  BGCOLOR;
  REG32  OP0_opRDRAM;
  WORD   MAJ_Y;
  WORD   MIN_Y;
  REG32  OP1_opRDRAM;
  WORD   ACCUM_Y;
  REG16  PATOFF;
  REG32  OP2_opRDRAM;
  WORD   MAJ_X;
  WORD   MIN_X;
  REG32  BLTEXT;
  WORD   ACCUM_X;
  WORD   OP0_opSRAM;
  WORD   SRCX;
  WORD   OP2_opSRAM;
  REG32  BLTEXTR_EX;
  REG32  MBLTEXTR_EX;
  REG32  OP0_opMRDRAM;
  REG32  OP1_opMRDRAM;
  REG16  STRETCH_CNTL;
  REG16  RESERVED;       // Needs this to make it into DWORD boundary
  REG32  CLIPULE;
  REG32  CLIPLOR;
  REG32  NEXT_HEAD;      /*  XY address of next in chain if LNCTL chain set */
} autoblt_regs, *autoblt_ptr;


#endif   /*  _LGREGS_ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\memmgr.h ===
/******************************Module*Header*******************************\
 *
 * Module Name: memmgr.h
 *
 * contains prototypes for the memory manager.
 *
 * Copyright (c) 1997 Cirrus Logic, Inc.
 *
 * $Log:   X:/log/laguna/nt35/displays/cl546x/memmgr.h  $
* 
*    Rev 1.4   18 Sep 1997 16:13:28   bennyn
* 
* Fixed NT 3.51 compile/link problem
* 
*    Rev 1.3   12 Sep 1997 12:06:32   bennyn
* 
* Modified for DD overlay support.
* 
*    Rev 1.2   08 Aug 1997 14:34:10   FRIDO
* Added SCREEN_ALLOCATE and MUST_HAVE flags.
* 
*    Rev 1.1   26 Feb 1997 10:46:08   noelv
* Added OpenGL MCD code from ADC.
* 
*    Rev 1.0   06 Feb 1997 10:34:10   noelv
* Initial revision.
 *
\**************************************************************************/

#ifndef _MEMMGR_H_
#define _MEMMGR_H_    

/*
 * Be sure to synchronize these structures with those in i386\Laguna.inc!
 */

#pragma pack(1)

//
// For offscreen memory manager
//
typedef VOID (*POFM_CALLBACK)();

#define NO_X_TILE_AlIGN       0x1
#define NO_Y_TILE_AlIGN       0x2
#define PIXEL_AlIGN           0x4
#define DISCARDABLE_FLAG      0x8
#define SAVESCREEN_FLAG	      0x10
#define SCREEN_ALLOCATE       0x4000
#define MUST_HAVE             0x8000

#define MCD_NO_X_OFFSET         0x20    //MCD - allows forcing AllocOffScnMem to get block with x=0
#define MCD_Z_BUFFER_ALLOCATE   0x40    //MCD - force 16 bpp allocate for Z on 32 scanline boundary
#define MCD_DRAW_BUFFER_ALLOCATE 0x80   //MCD - force allocate for 3d backbuffer on 32 scanline boundary
                                        
#define MCD_TEXTURE8_ALLOCATE   0x100   //MCD - force  8 bpp block for texture map 
#define MCD_TEXTURE16_ALLOCATE  0x200   //MCD - force 16 bpp block for texture map 
#define MCD_TEXTURE32_ALLOCATE  0x400   //MCD - force 32 bpp block for texture map 

#define EIGHT_BYTES_ALIGN       0x800   // Align in 8 bytes boundary

#define MCD_TEXTURE_ALLOCATE    (MCD_TEXTURE8_ALLOCATE|MCD_TEXTURE16_ALLOCATE|MCD_TEXTURE32_ALLOCATE)
#define MCD_TEXTURE_ALLOC_SHIFT 8       //num bits to shift alignflag to get numbytes per texel

typedef struct _OFMHDL
{
  ULONG  x;                   // actual X, Y position
  ULONG  y;
  ULONG  aligned_x;           // aligned X, Y position
  ULONG  aligned_y;
  LONG   sizex;               // Allocated X & Y sizes (in bytes)
  LONG   sizey;
  ULONG  alignflag;           // Alignment flag
  ULONG  flag;                // Status flag
  POFM_CALLBACK  pcallback;   // callback function pointer
  struct _OFMHDL *prevhdl;
  struct _OFMHDL *nexthdl;
  struct _OFMHDL *subprvhdl;
  struct _OFMHDL *subnxthdl;
  struct _OFMHDL *prvFonthdl;
  struct _OFMHDL *nxtFonthdl;
  struct _DSURF *pdsurf;       // If this offscreen memory block holds a 
                               // device bitmap, then this is it. 
} OFMHDL, *POFMHDL;


#if DRIVER_5465 && defined(OVERLAY) && defined(WINNT_VER40)
#else
typedef struct _DDOFM
{
  struct _DDOFM   *prevhdl;
  struct _DDOFM   *nexthdl;
  POFMHDL         phdl;
} DDOFM, *PDDOFM;
#endif



//
// Offscreen memory manager function prototypes
//
BOOL InitOffScnMem(struct _PDEV *ppdev);
POFMHDL AllocOffScnMem(struct _PDEV *ppdev, PSIZEL surf, ULONG alignflag, POFM_CALLBACK pcallback);
BOOL FreeOffScnMem(struct _PDEV *ppdev, POFMHDL psurf);
void CloseOffScnMem(struct _PDEV *ppdev);
PVOID ConvertToVideoBufferAddr(struct _PDEV *ppdev, POFMHDL psurf);
POFMHDL DDOffScnMemAlloc(struct _PDEV *ppdev);
void  DDOffScnMemRestore(struct _PDEV *ppdev);

// restore default structure alignment
#pragma pack()

#endif // _MEMMGR_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\mmcore.h ===
;/* Oh no - A polymorphic include file!
COMMENT ~ */
/******************************************************************************\
*
* $Workfile:   mmCore.h  $
*
* This is a polymorphic include file for the memory manager.
*
* Copyright (c) 1997, Cirrus Logic, Inc.
* All Rights Reserved.
*
* $Log:   X:/log/laguna/nt35/include/mmCore.h  $
* 
*    Rev 1.2   Oct 24 1997 10:39:22   frido
* Copied from WIndows 95 tree.
* 
*    Rev 1.4   23 Oct 1997 09:34:20   frido
* Removed changes from RandyS.
* Merged file with 161 tree.
* 
*    Rev 1.2.1.0   15 Oct 1997 12:54:16   frido
* Changed back to 200 nodes.
* Added function prototypes for new roll back functions.
* Added debugging macros.
* 
*    Rev 1.2   01 Oct 1997 10:17:02   frido
* Increased the number of nodes to 250 (fixes PDR 10650).
* 
*    Rev 1.1   14 Aug 1997 16:57:58   FRIDO
* mmco
* Added mmFlags field to DEVMEM structure.
* Added NOTE_... status values.
* 
*    Rev 1.0   07 Aug 1997 17:40:36   FRIDO
* Initial revision.
* SWAT: 
* SWAT:    Rev 1.0   17 Jun 1997 17:12:24   frido
* SWAT: Combined Windows 95 and NT versions together.
* SWAT: 
* SWAT:    Rev 1.5   16 Jun 1997 23:20:20   frido
* SWAT: More combined Windows 95 / NT stuff build in.
* SWAT: 
* SWAT:    Rev 1.4   21 May 1997 14:55:10   frido
* SWAT: Changed debug routines.
* SWAT: 
* SWAT:    Rev 1.3   16 May 1997 23:05:10   frido
* SWAT: Moved TILE_ALIGNMENT to SWAT.inc.
* SWAT: 
* SWAT:    Rev 1.2   06 May 1997 17:57:50   frido
* SWAT: Added tile alignment.
* SWAT: 
* SWAT:    Rev 1.1   03 May 1997 14:23:26   frido
* SWAT: A brand new interface.
* SWAT: 
* SWAT:    Rev 1.0   22 Apr 1997 15:26:52   frido
* SWAT: Copied to WN140b18 release.
* 
*    Rev 1.8   21 Mar 1997 14:03:46   frido
* Moved old memory manager core back to root.
* 
*    Rev 1.4.1.0   19 Mar 1997 13:45:40   frido
* Old memory core.
* 
*    Rev 1.4   06 Mar 1997 00:23:36   frido
* Added memory mover.
* 
*    Rev 1.3   27 Feb 1997 22:26:10   frido
* New memory manager core.
* 
*    Rev 1.2   18 Feb 1997 12:13:34   frido
* Changed WORD into UINT and pascal into PASCAL for Win32 debugging.
* 
*    Rev 1.1   13 Feb 1997 18:03:22   frido
* Added memory packer.
* 
*    Rev 1.0   13 Feb 1997 11:19:44   frido
* Ported from test case.
*
\******************************************************************************/

/******************************************************************************\
*																			   *
*								   C   P A R T								   *
*																			   *
\******************************************************************************/

#ifndef _MMCORE_H_
#define _MMCORE_H_

#define	TILE_ALIGNMENT	0		// align device bitmaps so there are as few tile
								//   crosses as possible
#define	DEBUG_HEAP		0		// enable debugging of heaps
#define	MM_NUM_HANDLES	200		// number of handles in each array

#ifdef WIN95 /* Windows 95 */
	typedef unsigned int UINT;
	typedef unsigned long ULONG;
	#define MUL(n1, n2) 		mmMultiply(n1, n2)
	#define MM_MOVEABLE(pdm)	( (pdm->client != NULL) && \
								  (pdm->client->mem_moved != NULL) )
	#define MM_HOSTIFYABLE(pdm)	(pdm->client->evict_single != NULL)
	#define MM_HOSTIFY(pdm)		pdm->client->evict_single(pdm)

#else /* Windows NT */
	#define MUL(n1, n2)			(ULONG)((UINT)(n1) * (UINT)(n2))
	#define MM_MOVEABLE(pdm)	( (pdm->ofm.pdsurf != NULL) && \
								  !(pdm->ofm.alignflag & DISCARDABLE_FLAG) )
	#define MM_HOSTIFYABLE(pdm)	(pdm->ofm.pcallback != NULL)
	#define MM_HOSTIFY(pdm)		((FNMMHOSTIFY)(pdm->ofm.pcallback))(pdm)

	/*
		GXPOINT structure required for memory manager.
	*/
	typedef union _GXPOINT
	{
		struct
		{
			UINT	x;
			UINT	y;
		} pt;

	} GXPOINT;

	/*
		The DEVMEM structure is a wrapper around the NT off-screen memory node.
	*/
	typedef struct _DEVMEM *PDEVMEM;
	typedef struct _DEVMEM
	{
		OFMHDL	ofm;					// NT structure
		GXPOINT	cbAddr;					// address in bytes of this node
		GXPOINT	cbSize;					// size in bytes of this node
		GXPOINT	cbAlign;				// alignment in bytes of this node
		PDEVMEM	next;					// pointer to next DEVMEM structure
		PDEVMEM	prev;					// pointer to previous DEVMEM structure
		DWORD	mmFlags;				// flags

	} DEVMEM;
#endif

#define	NODE_AVAILABLE	0
#define	NODE_FREE		1
#define	NODE_USED		2

typedef enum
{
	NO_NODES,
	SINGLE_NODE,
	MULTIPLE_NODES

} REMOVE_METHOD;

typedef struct _HANDLES *PHANDLES;
typedef struct _HANDLES
{
	PHANDLES	pNext;
	DEVMEM		dmArray[MM_NUM_HANDLES];

} HANDLES;

typedef struct _IIMEMMGR
{
	UINT		mmTileWidth;			// width of tile in bytes
	UINT		mmHeapWidth;			// width of heap
	UINT		mmHeapHeight;			// height of heap
	BOOL		mmDebugHeaps;			// debug flag

	PDEVMEM		pdmUsed;				// used list
	PDEVMEM		pdmFree;				// free list (unpacked)
	PDEVMEM 	pdmHeap;				// heap list (packed)
	PDEVMEM 	pdmHandles;				// handles list

	PHANDLES	phArray;				// array of handles
	
} IIMEMMGR, * PIIMEMMGR;

typedef struct _GXRECT
{
	UINT	left;
	UINT	top;
	UINT	right;
	UINT	bottom;
	ULONG	area;

} GXRECT, FAR* LPGXRECT;

typedef void (*FNMMCOPY)(PDEVMEM pdmNew, PDEVMEM pdmOld);
typedef UINT (*FNMMCALLBACK)(PDEVMEM pdm);
typedef BOOL (*FNMMHOSTIFY)(PDEVMEM pdm);

BOOL FAR mmInit(PIIMEMMGR pmm);

BOOL mmAllocArray(PIIMEMMGR pmm);
PDEVMEM mmAllocNode(PIIMEMMGR pmm);
void mmFreeNode(PIIMEMMGR pmm, PDEVMEM pdm);

PDEVMEM mmAlloc(PIIMEMMGR pmm, GXPOINT size, GXPOINT align);
PDEVMEM mmAllocGrid(PIIMEMMGR pmm, GXPOINT size, GXPOINT align, UINT count);
PDEVMEM mmAllocLargest(PIIMEMMGR pmm, GXPOINT align);
void mmFree(PIIMEMMGR pmm, PDEVMEM pdm);

void mmPack(PIIMEMMGR pmm);
PDEVMEM mmMove(PIIMEMMGR pmm, GXPOINT size, GXPOINT align, FNMMCOPY fnCopy);

void mmInsertInList(PDEVMEM FAR* pdmRoot, PDEVMEM pdm);
void mmRemoveFromList(PDEVMEM FAR* pdmRoot, PDEVMEM pdm);
BOOL FAR far_mmAddRectToList(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot,
							 LPGXRECT lpRect);
BOOL mmAddRectToList(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot, LPGXRECT lpRect,
					 BOOL fRollBack);
PDEVMEM mmRemoveRectFromList(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot,
							 LPGXRECT lpRect, REMOVE_METHOD fMethod);
void mmCombine(PIIMEMMGR pmm, PDEVMEM pdmRoot);
void mmRollBackAdd(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot, LPGXRECT lpRect,
				   LPGXRECT rectList, UINT nCount);
void mmRollBackRemove(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot,
					  PDEVMEM FAR* pdmList);

BOOL mmFindRect(PIIMEMMGR pmm, LPGXRECT lpRect, GXPOINT size, GXPOINT align);
UINT mmGetLeft(PIIMEMMGR pmm, PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT size,
			   GXPOINT align);
UINT mmGetRight(PIIMEMMGR pmm, PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT size,
				GXPOINT align);
UINT mmGetBottom(PIIMEMMGR pmm, PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT size,
				 GXPOINT align);
ULONG mmGetBest(PIIMEMMGR pmm, PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT size,
				GXPOINT align);
ULONG mmGetLargest(PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT align);
UINT mmAlignX(PIIMEMMGR pmm, UINT x, UINT size, UINT align, BOOL fLeft);

#ifdef WIN95
UINT mmFindClient(PIIMEMMGR pmm, PCLIENT pClient, FNMMCALLBACK fnCallback);
ULONG mmMultiply(UINT n1, UINT n2);
#endif

#if DEBUG_HEAP
	void mmBreak();
	void mmDumpList(PDEVMEM pdmRoot, LPCSTR lpszMessage);
	ULONG mmDebugList(PDEVMEM pdmRoot, BOOL fCheckSort);
	void mmDebug(LPCSTR lpszFormat, ...);
	#define mmTRACE(s) //Debug s
	#define mmASSERT(c,s) if (c) { mmDebug s; mmBreak(); }
#else
	#define mmBreak()
	#define mmDebugList(pdmRoot, fCheckSort)
	#define mmTRACE(s)
	#define mmASSERT(c,s)
#endif

#endif /* _MMCORE_H_ */

/******************************************************************************\
*																			   *
*							A S S E M B L Y   P A R T						   *
*																			   *
\******************************************************************************/
/*~ END COMMENT
MM_NUM_HANDLES		EQU			200

GXPOINT UNION
	STRUCT pt
		x			UINT		?
		y			UINT		?
	ENDS
GXPOINT ENDS

PDEVMEM				TYPEDEF		PTR DEVMEM
DEVMEM STRUCT
	ofm				OFMHDL		{}
	cbAddr			GXPOINT		{}
	cbSize			GXPOINT		{}
	cbAlign			GXPOINT		{}
	next			PDEVMEM		?
	prev			PDEVMEM		?
DEVMEM ENDS

PHANDLES			TYPEDEF		PTR HANDLES
HANDLES STRUCT
	pNext			PHANDLES	?
	dmArray			DEVMEM		MM_NUM_HANDLES DUP({})
HANDLES ENDS

IIMEMMGR STRUCT
	mmTileWidth		UINT		?
	mmHeapWidth		UINT		?
	mmHeapHeight	UINT		?
	mmDebugHeaps	BOOL		?

	pdmUsed			PDEVMEM		?
	pdmFree			PDEVMEM		?
	pdmHeap			PDEVMEM		?
	pdmHandles		PDEVMEM		?

	phArray			PHANDLES	?
IIMEMMGR ENDS

; end of polymorphic include file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\lgtypes.h ===
/*****************************************************************************\
*
*	(c) Copyright 1991, Appian Technology Inc.
*	(c) Copyright 1995, Cirrus Logic, Inc.
*
*	Project:	Laguna
*
*	Title:		lgtypes.h
*
*	Environment:	Independent
*
*	Adapter:	Independent
*
*	Description:	Common type definitions for Laguna SW in general.
*
\*****************************************************************************/

#ifndef _LGTYPES_H
#define _LGTYPES_H

/*  We use #define here instead of typedef to make it easier on systems
    where these same types are also defined elsewhere, i.e., it is possible
    to use #ifdef, #undef, etc. on these types.  */

#define BYTE unsigned char
#define WORD unsigned short
// MARKEINKAUF removed this - mcdmath.h couldn't tolerate since using DWORD in inline asm
//#define DWORD unsigned long 
#define STATIC static

typedef unsigned long ul;
typedef unsigned short word;
typedef unsigned char byte;
typedef unsigned char boolean;


typedef struct PT { 
	WORD	X;
	WORD	Y;
} PT;


/* #define LOHI struct LOHI mae*/
typedef struct LOHI {
    WORD	LO;
    WORD	HI;
} LOHI;


typedef union _reg32 {
	DWORD	dw;
	DWORD	DW;
	PT		pt;
	PT		PT;
	LOHI	lh;
	LOHI	LH;
} REG32;


typedef struct LOHI16 {
	BYTE	LO;
    BYTE	HI;
} LOHI16;

typedef struct PT16 { 
	BYTE	X;
	BYTE	Y;
} PT16;


typedef union _reg16 {
	WORD	w;
	WORD	W;
	PT16	pt;
	PT16	PT;
	LOHI16	lh;
	LOHI16	LH;
} REG16;

#endif	/* ndef _98TYPES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\setmode.h ===
//
// NT Miniport SetMode() header file.
//
//


//
// Default mode: VGA mode 3
//
#define DEFAULT_MODE                0

//
// The mode switch library exports these symbols to the miniport.
//


//
// Mode table structure
// Structure used for the mode table informations
//
typedef struct {
   BOOLEAN  ValidMode;        // TRUE: Mode is valid.
   ULONG    ChipType;         // Chips which support this mode.
   USHORT   fbType;           // color or monochrome, text or graphics,
                              // via VIDEO_MODE_COLOR and VIDEO_MODE_GRAPHICS
                              // and interlace or non-interlace via
                              // VIDEO_MODE_INTERLACED

   USHORT   Frequency;        // Frequency
   USHORT   BIOSModeNum;      // BIOS Mode number

   USHORT   BytesPerScanLine; // Bytes Per Scan Line
   USHORT   XResol;           // Horizontal resolution in pixels or char
   USHORT   YResol;           // Vertical  resolution in pixels or char
   UCHAR    XCharSize;        // Char cell width  in pixels
   UCHAR    YCharSize;        // Char cell height in pixels
   UCHAR    NumOfPlanes;      // Number of memory planes
   UCHAR    BitsPerPixel;     // Bits per pixel
   UCHAR    MonitorTypeVal;   // Monitor type setting bytes
   UCHAR    *SetModeString;   // Instructino string used by SetMode().

} MODETABLE, *PMODETABLE;

extern MODETABLE  ModeTable[];
extern ULONG      TotalVideoModes;
void SetMode(BYTE *, BYTE *, BYTE *);
unsigned long GetVmemSize(BYTE *Regs);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\overlay.h ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1997, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         overlay.h
*
* DESCRIPTION:
*
* REVISION HISTORY:
*
* $Log:   X:/log/laguna/ddraw/inc/overlay.h  $
* 
*    Rev 1.13   Mar 26 1998 09:52:50   frido
* Fixed a hangup in overlays when switching from DOS and Overfly.
* 
*    Rev 1.12   06 Jan 1998 13:26:50   xcong
* Access pDriverData locally for multi-monitor support.
* 
*    Rev 1.11   18 Sep 1997 16:10:42   bennyn
* 
* Fixed NT 3.51 compile/link problem
* 
*    Rev 1.10   12 Sep 1997 12:12:48   bennyn
* 
* Modified for NT DD overlay support
* 
*    Rev 1.9   29 Aug 1997 16:11:52   RUSSL
* Added support for NT
*
*    Rev 1.8   28 Jul 1997 09:13:06   RUSSL
* Added arg passed to pfnGetFlipStatus
* Added GetVideoWidowIndex inline function
* Added dwNumVideoWindows global var
*
*    Rev 1.7   20 Jun 1997 11:24:54   RUSSL
* Added CLPL fourcc code, added a linear bit flag in surface flags, and
* changed OVERLAYTABLE pfnCreateSurface function to return an HRESULT
*
*    Rev 1.6   15 May 1997 10:50:58   RUSSL
* Changed OVERLAYTABLE pfnCanCreateSurface function to return an HRESULT
*
*    Rev 1.5   14 May 1997 14:51:30   KENTL
* Added #define for FLG_PANNING
*
*    Rev 1.4   13 May 1997 10:33:54   RUSSL
* Added gsOverlayFlip to global vars
*
*    Rev 1.3   21 Feb 1997 11:30:46   RUSSL
* Added FLG_YUY2 define
*
*    Rev 1.2   27 Jan 1997 18:33:54   RUSSL
* Removed SetCaps from OVERLAYTABLE structure
* Added Set5465FlipDuration function prototype
* Moved GetFormatInfo function prototype to surface.h
*
*    Rev 1.1   21 Jan 1997 14:35:42   RUSSL
* Added FLG_VWx defines, etc.
* Added 5465 function prototypes
*
*    Rev 1.0   15 Jan 1997 11:01:50   RUSSL
* Initial revision.
*
***************************************************************************
***************************************************************************/

// If WinNT 3.5 skip all the source code
#if defined WINNT_VER35      // WINNT_VER35

#else


#ifndef _OVERLAY_H_
#define _OVERLAY_H_

/***************************************************************************
* D E F I N E S
****************************************************************************/

/* surface flags -----------------------------------------*/

#define FLG_BEGIN_ACCESS      (DWORD)0x00000001
#define FLG_ENABLED           (DWORD)0x00000002
//#define FLG_CONVERT_PACKJR    (DWORD)0x00000004
#define FLG_MUST_RASTER       (DWORD)0x00000008
#define FLG_TWO_MEG           (DWORD)0x00000010
#define FLG_CHECK             (DWORD)0x00000020
#define FLG_COLOR_KEY         (DWORD)0x00000040
#define FLG_INTERPOLATE       (DWORD)0x00000080
#define FLG_OVERLAY           (DWORD)0x00000100
#define FLG_YUV422            (DWORD)0x00000200
//#define FLG_PACKJR            (DWORD)0x00000400
#define FLG_USE_OFFSET        (DWORD)0x00000800
#define FLG_YUVPLANAR         (DWORD)0x00001000
#define FLG_SRC_COLOR_KEY     (DWORD)0x00002000
#define FLG_DECIMATE          (DWORD)0x00004000
#define FLG_CAPTURE           (DWORD)0x00008000

#define FLG_VW0               (DWORD)0x00010000
#define FLG_VW1               (DWORD)0x00020000
#define FLG_VW2               (DWORD)0x00040000
#define FLG_VW3               (DWORD)0x00080000
#define FLG_VW4               (DWORD)0x00100000
#define FLG_VW5               (DWORD)0x00200000
#define FLG_VW6               (DWORD)0x00400000
#define FLG_VW7               (DWORD)0x00800000
#define	FLG_PANNING           (DWORD)0x01000000

#define FLG_VW_MASK           (DWORD)0x00FF0000
#define FLG_VW_SHIFT          16

#define FLG_UYVY              FLG_YUV422
#define FLG_YUY2              (DWORD)0x40000000
#define FLG_DECIMATE4         (DWORD)0x80000000
#define FLG_LINEAR            (DWORD)0x10000000

#define MIN_OLAY_WIDTH        4

#define FOURCC_YUVPLANAR      mmioFOURCC('C','L','P','L')

/***************************************************************************
* T Y P E D E F S
****************************************************************************/

#ifdef WINNT_VER40

#include <memmgr.h>

typedef struct _PDEV PDEV;

// Be sure to synchronize the following structures with the one
// in i386\Laguna.inc!
//
typedef struct tagOVERLAYTABLE
{
  HRESULT (*pfnCanCreateSurface)(PDEV*, DWORD, DWORD);
  HRESULT (*pfnCreateSurface)(PDEV*, PDD_SURFACE_LOCAL, DWORD);
  VOID    (*pfnDestroySurface)(PDEV*, PDD_DESTROYSURFACEDATA);
  DWORD   (*pfnLock)(PDEV*, PDD_LOCKDATA);
  VOID    (*pfnUnlock)(PDEV*, PDD_UNLOCKDATA);
  VOID    (*pfnSetColorKey)(PDEV*, PDD_SETCOLORKEYDATA);
  DWORD   (*pfnFlip)(PDEV*, PDD_FLIPDATA);
  DWORD   (*pfnUpdateOverlay)(PDEV*, PDD_UPDATEOVERLAYDATA);
  DWORD   (*pfnSetOverlayPos)(PDEV*, PDD_SETOVERLAYPOSITIONDATA);
  DWORD   (*pfnGetFlipStatus)(PDEV*, FLATPTR,DWORD);
} OVERLAYTABLE, *LPOVERLAYTABLE;

// Be sure to synchronize the following structures with the one
// in i386\Laguna.inc!
//
typedef struct
{
  FLATPTR  fpFlipFrom;
  LONGLONG liFlipTime;

  DWORD    dwFlipDuration;
  DWORD    dwFlipScanline;
  BOOL     bFlipFlag;
  BOOL     bHaveEverCrossedVBlank;
  BOOL     bWasEverInDisplay;
} OVERLAYFLIPRECORD;

#else
typedef struct tagOVERLAYTABLE
{
  HRESULT (*pfnCanCreateSurface)(GLOBALDATA *,DWORD, DWORD);
  HRESULT (*pfnCreateSurface)(LPDDRAWI_DIRECTDRAWSURFACE, DWORD, LPGLOBALDATA);
  VOID    (*pfnDestroySurface)(LPDDHAL_DESTROYSURFACEDATA);
  DWORD   (*pfnLock)(LPDDHAL_LOCKDATA);
  VOID    (*pfnUnlock)(LPDDHAL_UNLOCKDATA);
  VOID    (*pfnSetColorKey)(LPDDHAL_SETCOLORKEYDATA);
  DWORD   (*pfnFlip)(LPDDHAL_FLIPDATA);
  DWORD   (*pfnUpdateOverlay)(LPDDHAL_UPDATEOVERLAYDATA);
  DWORD   (*pfnSetOverlayPos)(LPDDHAL_SETOVERLAYPOSITIONDATA);
  DWORD   (*pfnGetFlipStatus)(LPGLOBALDATA,FLATPTR,DWORD);
} OVERLAYTABLE, *LPOVERLAYTABLE;

typedef struct
{
  FLATPTR  fpFlipFrom;
  __int64  liFlipTime;
  DWORD    dwFlipDuration;
  DWORD    dwFlipScanline;
  BOOL     bFlipFlag;
  BOOL     bHaveEverCrossedVBlank;
  BOOL     bWasEverInDisplay;
} OVERLAYFLIPRECORD;
#endif

#ifdef WINNT_VER40

#if DRIVER_5465 && defined(OVERLAY)
#define   DDOFM     SURFACE_DATA
#define   PDDOFM    LP_SURFACE_DATA
#endif

//this structure is used to store information per surface
typedef struct surface_data
{
  // This is the inclusion of DDOFM structure.
  // When OVERLAY is defined, DDOFM structure will be map to this structure
  struct surface_data   *prevhdl;
  struct surface_data   *nexthdl;
  POFMHDL         phdl;

   //
   // Note: Not all fields will get used/set for all types of surfaces!
   //
//   PMEMBLK  pMemblk;
//   VOID*    pLinearAddr;      // Linear address of memory block if linear
//                              // memory allocated via dmAllocLinear.
//   LPVOID   lpTextureData;
   LPVOID   lpCLPLData;
//   DWORD    dwFlags;
   DWORD    dwOverlayFlags;
//   WORD     wMemtype;         // Memory type (if we allocated surface).
//   DWORD    dwBitsPerPixel;
//   DWORD    dwBytesPerPixel;  // Rounded to nearest byte!
//   DWORD    dwBaseLinearAddr; // Linear address of memory heap.
//   DWORD    dwBasePhysAddr;   // Physical address of memory heap.
//   DWORD    dwBaseOffset;     // Offset of surface from base of memory heap.
   DWORD    dwOverlayOffset;   // Offset of overlay surface by clipping
#if DDRAW_COMPAT >= 50
   DWORD    dwAutoBaseAddr1;  //Auto flip Vport surface 1 address
   DWORD    dwAutoBaseAddr2;  //Auto flip Vport surface 2 address

   DDPIXELFORMAT ddpfAltPixelFormat;  // if pixel fmt is different than
                              // we lead DDraw to believe it is
#endif
}SURFACE_DATA, *LP_SURFACE_DATA;
#endif

/***************************************************************************
* G L O B A L   V A R I A B L E S
****************************************************************************/

#ifndef WINNT_VER40
extern OVERLAYTABLE       OverlayTable;
extern OVERLAYFLIPRECORD  gsOverlayFlip;
extern DWORD              dwNumVideoWindows;
#endif

/***************************************************************************
* I N L I N E   F U N C T I O N S
****************************************************************************/

/***************************************************************************
*
* FUNCTION:     GetVideoWindowIndex
*
* DESCRIPTION:
*
****************************************************************************/

static __inline DWORD
GetVideoWindowIndex ( DWORD dwOverlayFlags )
{
  DWORD   dwVWIndex;
  DWORD   dwTemp;


  // Isn't there a better way to count the number of zeros to the right of
  // the FLG_VWx bit?
  dwTemp = (dwOverlayFlags & FLG_VW_MASK) >> FLG_VW_SHIFT;
  dwVWIndex = 0;
  if (dwTemp != 0)	// Only do the next loop if there is any bit set.
  while (0 == (dwTemp & 0x00000001))
  {
    dwTemp >>= 1;
    dwVWIndex++;
  }
  // if the video window index is larger than or equal to the number of video
  // windows implemented in the hardware, then this surface was assigned an
  // invalid video window!
//  ASSERT(dwNumVideoWindows > dwVWIndex);

  return dwVWIndex;
}

/***************************************************************************
* F U N C T I O N   P R O T O T Y P E S
****************************************************************************/

#ifdef WINNT_VER40
DWORD __stdcall UpdateOverlay32      ( PDD_UPDATEOVERLAYDATA );
DWORD __stdcall SetOverlayPosition32 ( PDD_SETOVERLAYPOSITIONDATA );
DWORD __stdcall SetColorKey32        ( PDD_SETCOLORKEYDATA );

BOOL QueryOverlaySupport ( PDEV*, DWORD );
VOID OverlayInit         ( PDEV*, DWORD, PDD_SURFACECALLBACKS, PDD_HALINFO );
VOID OverlayReInit       ( PDEV*, DWORD, PDD_HALINFO );

// 5465 function prototypes
VOID Init5465Overlay     ( PDEV*, DWORD, PDD_HALINFO, LPOVERLAYTABLE );
VOID Init5465Info        ( PDEV*, PDD_HALINFO );
VOID Set5465FlipDuration ( PDEV*, DWORD );
#else
DWORD __stdcall UpdateOverlay32      ( LPDDHAL_UPDATEOVERLAYDATA );
DWORD __stdcall SetOverlayPosition32 ( LPDDHAL_SETOVERLAYPOSITIONDATA );
DWORD __stdcall SetColorKey32        ( LPDDHAL_SETCOLORKEYDATA );

BOOL QueryOverlaySupport ( LPGLOBALDATA, DWORD);
VOID OverlayInit         ( DWORD, LPDDHAL_DDSURFACECALLBACKS, LPDDHALINFO, GLOBALDATA * );
VOID OverlayReInit       ( DWORD, LPDDHALINFO ,GLOBALDATA * );

// 5465 function prototypes
VOID Init5465Overlay     ( DWORD, LPDDHALINFO, LPOVERLAYTABLE, GLOBALDATA * );
VOID Init5465Info        ( LPDDHALINFO, GLOBALDATA * );
VOID Set5465FlipDuration ( DWORD );
#endif

#endif /* _OVERLAY_H_ */
#endif // WINNT_VER35
/* Don't write below this endif */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\optimize.h ===
;/*
COMMENT !

    USE_ASM
    -------
        0   use "C" code
        1   use "ASM" code for i386 CPU's

;*/
    #define USE_ASM         1   /*  C switch        !
            USE_ASM =       1   ;   Assembly switch */


;/*
COMMENT !

    USB_FIX    --------
        0   Disable USB fix
        1   Enable USB fix

;*/
    #define USB_FIX_ENABLED        0   /*  C switch        !
            USB_FIX_ENABLED =      0   ;   Assembly switch */


;/*
COMMENT !

    WINBENCH96
    --------
        0   Allocate all device bitmap sizes.
        1   Allocate only device bitmaps in the WinBench 96 size range.

;*/
    #define WINBENCH96        0   /*  C switch        !
            WINBENCH96 =      0   ;   Assembly switch */

;/*
COMMENT !

    INLINE_ASM
    ----------
        0   Don't use i386 inline assembly.
        1   Use i386 inline assembly.

;*/
    #define INLINE_ASM      1   /*  C switch        !
            INLINE_ASM =    1   ;   Assembly switch */



;/*
COMMENT !

    SOLID_CACHE
    -----------
        0   Don't use solid brush cache in special cases.
        1   Use solid brush cache in special places.

;*/
    #define SOLID_CACHE		1	/*  C switch        !
            SOLID_CACHE =	1	;   Assembly switch */



;/*
COMMENT !

    BUS_MASTER
    -----------
        0   Don't use bus mastering to transfer host data.
        1   Use bus mastering to transfer host data.

;*/
    #define BUS_MASTER      0   /*  C switch        !
            BUS_MASTER  =   0   ;   Assembly switch */



;/*
COMMENT !

    LOG_CALLS
    -----------
        0   Normal operation.
        1   Log GDI calls into the driver.
            This will disable USE_ASM.

;*/
    #define LOG_CALLS       0   /*  C switch        !
            LOG_CALLS   =   0   ;   Assembly switch */



;/*
COMMENT !

    HW_CLIPPING
    -----------
        0   Don't use hardware clipping.
        1   Use hardware clipping (5465 only).

;*/
    #define HW_CLIPPING         0   /*  C switch        !
            HW_CLIPPING     =   0   ;   Assembly switch */







;/* ========================== LOG_WRITES =================================
COMMENT !

    LOG_WRITES
    -----------
        0   Normal operation.
        1   Log writes to the chip.
            This will disable USE_ASM.

;*/
    #define LOG_WRITES      0   /*  C switch        !
            LOG_WRITES  =   0   ;   Assembly switch */



;/* ========================== LOG_QFREE =================================
COMMENT !

    LOG_QFREE
    -----------
        0   Normal operation.
        1   Log QFREE register at selected places.
;*/
    #define LOG_QFREE       0   /*  C switch        !
            LOG_QFREE   =   0   ;   Assembly switch */



;/* ========================== ENABLE_LOG_SWITCH =============================
COMMENT !

    ENABLE_LOG_SWITCH
    ------------------
        0   Continuous logging (when loggin is enabled above)
        1   Turn loggin on and off with pointer.
;*/
    #define ENABLE_LOG_SWITCH       0   /*  C switch        !
            ENABLE_LOG_SWITCH   =   0   ;   Assembly switch */




;/*  ================== ENABLE_LOG_FILE =================================
COMMENT !

 This enables the log file.

;*/

    //  C switches
    #define ENABLE_LOG_FILE (LOG_CALLS | LOG_WRITES | LOG_QFREE)
    /*  End of C switches !

    ;   Assembly switches
    ENABLE_LOG_FILE = (LOG_CALLS OR LOG_WRITES OR LOG_QFREE)
    ;   End of assembly switches */





;/* =========== INFINITE_OFFSCREEN_MEMORY =================================
COMMENT !

//
// This option causes DrvCreateDeviceBitmap to always succeed.
// It maps all device bitmaps to screen 0,0.  Thus we have an "infinite"
// supply of offscreen memory. 
//
// It is not necessary to set USE_ASM = 0 for this flag.
//
;*/
    #define INFINITE_OFFSCREEN_MEM      0   /*  C switch        !
            INFINITE_OFFSCREEN_MEM  =   0   ;   Assembly switch */





;/*  ================== NULL driver flags ================================
COMMENT !

 Once NULL driver capabilities are enabled, they are turned on and off 
 by moving the pointer to (0,0) which toggles do_flag on and off.
 See DrvMovePointer().

 These allow us to selectively 'short circuit' certain parts of the driver.
        0   Normal operation.
        1   Immediately return TRUE.

 It is not necessary to set USE_ASM = 0 for the null driver flags.

;*/

    //  C switches
    #define NULL_BITBLT 		0
    #define NULL_COPYBITS		0
    #define NULL_LINETO 		0
    #define NULL_PAINT  		0
    #define NULL_PATH   		0
    #define NULL_POINTER		0
    #define NULL_STRETCH		0
    #define NULL_STROKE 		0
    #define NULL_STROKEFILL		0
    #define NULL_TEXTOUT		0
    #define NULL_HW			0
    /*  End of C switches !

;   Assembly switches
        NULL_BITBLT	=   	0
        NULL_COPYBITS	=	0
        NULL_LINETO	=   	0
        NULL_PAINT	=   	0
        NULL_PATH	=   	0
        NULL_POINTER	=	0
        NULL_STRETCH	=	0
        NULL_STROKE	=   	0
        NULL_STROKEFILL	=	0
        NULL_TEXTOUT	=	0
        NULL_HW		=	0
;   End of assembly switches */




;/*  ================== POINTER_SWITCH ================================
COMMENT !

 This enables a global flag, or switch, that we can turn on and off by 
 moving the HW pointer to screen(0,0)

;*/

//  C switches
#define POINTER_SWITCH_ENABLED \
         (NULL_BITBLT | NULL_PAINT | NULL_COPYBITS | NULL_LINETO | \
          NULL_TEXTOUT | NULL_PATH | NULL_HW | NULL_STROKE | \
          NULL_STROKEFILL | NULL_STRETCH | NULL_POINTER | NULL_HW |\
          ENABLE_LOG_SWITCH | INFINITE_OFFSCREEN_MEM)

/*  End of C switches !

;   Assembly switches
        POINTER_SWITCH_ENABLED = \
         (NULL_BITBLT OR NULL_PAINT OR NULL_COPYBITS OR NULL_LINETO OR \
          NULL_TEXTOUT OR NULL_PATH OR NULL_HW OR NULL_STROKE OR \
          NULL_STROKEFILL OR NULL_STRETCH OR NULL_POINTER OR NULL_HW OR\
          ENABLE_LOG_SWITCH OR INFINITE_OFFSCREEN_MEM)

;   End of assembly switches */



;/*  ===================== DISABLE USE_ASM ====================================
COMMENT !

    Some of the switches above are incompatible with the assembly language
    part of the driver.

;*/

//  C switches
#if (LOG_CALLS || LOG_WRITES)
    #define USE_ASM 0
#endif
/*  End of C switches !

;   Assembly switches
IF (LOG_CALLS OR LOG_WRITES)
    USE_ASM = 0
ENDIF
;   End of assembly switches */



;/*  ===================== CHECK_QFREE ====================================
COMMENT !

    Log the value of the QFREE register.

;*/

//  C macro
#if LOG_QFREE
    extern unsigned long QfreeData[32];
    #define CHECK_QFREE() \
        do{ \
            register unsigned long temp; /* Because grQFREE is a volatile */ \
            temp = LLDR_SZ(grQFREE);     /* we must store it in a temp    */ \
            ++QfreeData[temp];           /* before using it as an index.  */ \
        } while(0)
#else
    #define CHECK_QFREE()
#endif

/*  End of C macro !

;   Assembly macro

IF LOG_QFREE
    EXTERN QfreeData: DWORD 
    CHECK_QFREE MACRO base:=<ebp> 
        push    eax                             ; Save eax and edx
        push    edx                             ; 

        xor     eax, eax                        ; Eax = 0
        mov     al, BYTE PTR [base + grQFREE]   ; Eax = QFREE
        mov     edx, DWORD PTR QfreeData[eax*4] ; Get histogram entry for QFREE
        inc     edx                             ;   increment it,
        mov     DWORD PTR QfreeData[eax*4], edx ;   and store it.

        pop     edx                             ; Restore edx and eax
        pop     eax                             ; 
    ENDM
ELSE
    CHECK_QFREE MACRO base:=<ebp> 
    ENDM
ENDIF

;   End of assembly macro */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\type.h ===
/******************************************************************************
*
*   Module:     TYPE.H          Generic Type Header Module
*
*   Revision:   1.00
*
*   Date:       April 14, 1994
*
*   Author:     Randy Spurlock
*
*******************************************************************************
*
*   Module Description:
*
*       This module contains generic type declarations.
*
*******************************************************************************
*
*   Changes:
*
*    DATE     REVISION  DESCRIPTION                             AUTHOR
*  --------   --------  -------------------------------------------------------
*  04/14/94     1.00    Original                                Randy Spurlock
*
*******************************************************************************
*   Constant Declarations
******************************************************************************/
#define TRUE            1               /* Define TRUE as the value 1        */
#define FALSE           0               /* Define FALSE as the value 0       */

/******************************************************************************
*   Type Definitions
******************************************************************************/
typedef int BOOL;                       /* Define a boolean as an integer    */

typedef unsigned char BYTE;             /* Define a byte data type           */
typedef unsigned short int WORD;        /* Define a word data type           */
typedef unsigned long DWORD;            /* Define a double word data type    */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\version.h ===
/*
*
* File: Include\Version.h
*
* This file is created by makefile.mak.
*
*/

#define NT_VER_DRIVER 100*1 + 71
#define VER_REV       7

#ifdef WINNT_VER35
    #define NT_VER_MAJOR  3
    #define NT_VER_MINOR  51
    #define NT_VER_BUILD  1057
    #define NT_VER_STRING "3.51.1057.171"
    #define VER_MAJ       3
    #define VER_MIN       5
#else
    #if _WIN32_WINNT >= 0x0500
        #define NT_VER_MAJOR  5
        #define NT_VER_MINOR  00
        #define NT_VER_BUILD  1907
        #define NT_VER_STRING "5.00.1907.001"
    #else
        #define NT_VER_MAJOR  4
        #define NT_VER_MINOR  00
        #define NT_VER_BUILD  1381
        #define NT_VER_STRING "4.00.1381.171"
    #endif
#endif

#define CL_VER_STRING NT_VER_STRING "5.00.1907.981017.001"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\pwrmgr.h ===
/***************************************************************************
*
*                ******************************************
*                * Copyright (c) 1997, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:  Laguna (CL-GD546X) - 
*
* FILE:     pwrmgr.h
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This is the include file for Power manager code.
*
* MODULES:
*
* REVISION HISTORY:
* $Log:   X:/log/laguna/powermgr/inc/pwrmgr.h  $
* 
*    Rev 1.2   20 Jun 1997 13:25:42   bennyn
* Moved power manager functions to Miniport
* 
*    Rev 1.1   23 Jan 1997 16:33:32   bennyn
* 
* 
*    Rev 1.0   16 Jan 1997 11:48:00   bennyn
* Initial revision.
* 
****************************************************************************
****************************************************************************/

#if defined WINNT_VER35      // WINNT_VER35
  // If WinNT 3.5 skip all the source code
#else

BOOL LgPM_SetHwModuleState (PPDEV ppdev, ULONG hwmod, ULONG state);
BOOL LgPM_GetHwModuleState (PPDEV ppdev, ULONG hwmod, ULONG* state);

#endif // WINNT_VER35

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\roptab.h ===
/******************************Module*Header**********************************\
* Module Name: ROPTAB.H
* Author: Noel VanHook
* Date: Apr 23, 1995
* Purpose: Table lookup for BLT operands.
*
* Copyright (c) 1995 Cirrus Logic, Inc.
*
\*****************************************************************************/
#ifndef _ROPTBL_H_
#define _ROPTBL_H_


//
// The table is indexed by rop code.  Each entry is a pointer to 
// which blt function to use for that rop code.
// BLT functions are selected based on what operands they use.
//
// Make sure BLT functions are prototyped before including this file.
//
//

BLTFN *RopTab[] = {
/* 00 */ op0BLT,     // BLACKNESS.
/* 01 */ op1op2BLT,
/* 02 */ op1op2BLT,
/* 03 */ op1op2BLT,
/* 04 */ op1op2BLT,
/* 05 */ op2BLT,     // DPon
/* 06 */ op1op2BLT,
/* 07 */ op1op2BLT,
/* 08 */ op1op2BLT,
/* 09 */ op1op2BLT,
/* 0A */ op2BLT,     // DPna
/* 0B */ op1op2BLT,
/* 0C */ op1op2BLT,
/* 0D */ op1op2BLT,
/* 0E */ op1op2BLT,
/* 0F */ op2BLT,     // Pn
/* 10 */ op1op2BLT,
/* 11 */ op1BLT,     // DSon
/* 12 */ op1op2BLT,
/* 13 */ op1op2BLT,
/* 14 */ op1op2BLT,
/* 15 */ op1op2BLT,
/* 16 */ op1op2BLT,
/* 17 */ op1op2BLT,
/* 18 */ op1op2BLT,
/* 19 */ op1op2BLT,
/* 1A */ op1op2BLT,
/* 1B */ op1op2BLT,
/* 1C */ op1op2BLT,
/* 1D */ op1op2BLT,
/* 1E */ op1op2BLT,
/* 1F */ op1op2BLT,
/* 20 */ op1op2BLT,
/* 21 */ op1op2BLT,
/* 22 */ op1BLT,      // DSna
/* 23 */ op1op2BLT,
/* 24 */ op1op2BLT,
/* 25 */ op1op2BLT,
/* 26 */ op1op2BLT,
/* 27 */ op1op2BLT,
/* 28 */ op1op2BLT,
/* 29 */ op1op2BLT,
/* 2A */ op1op2BLT,
/* 2B */ op1op2BLT,
/* 2C */ op1op2BLT,
/* 2D */ op1op2BLT,
/* 2E */ op1op2BLT,
/* 2F */ op1op2BLT,
/* 30 */ op1op2BLT,
/* 31 */ op1op2BLT,
/* 32 */ op1op2BLT,
/* 33 */ op1BLT,     // Sn    -- NOT SRC COPY
/* 34 */ op1op2BLT,
/* 35 */ op1op2BLT,
/* 36 */ op1op2BLT,
/* 37 */ op1op2BLT,
/* 38 */ op1op2BLT,
/* 39 */ op1op2BLT,
/* 3A */ op1op2BLT,
/* 3B */ op1op2BLT,
/* 3C */ op1op2BLT,
/* 3D */ op1op2BLT,
/* 3E */ op1op2BLT,
/* 3F */ op1op2BLT,
/* 40 */ op1op2BLT,
/* 41 */ op1op2BLT,
/* 42 */ op1op2BLT,
/* 43 */ op1op2BLT,
/* 44 */ op1BLT,     // SDna  -- SRC ERASE
/* 45 */ op1op2BLT,
/* 46 */ op1op2BLT,
/* 47 */ op1op2BLT,
/* 48 */ op1op2BLT,
/* 49 */ op1op2BLT,
/* 4A */ op1op2BLT,
/* 4B */ op1op2BLT,
/* 4C */ op1op2BLT,
/* 4D */ op1op2BLT,
/* 4E */ op1op2BLT,
/* 4F */ op1op2BLT,
/* 50 */ op2BLT,     // PDna
/* 51 */ op1op2BLT,
/* 52 */ op1op2BLT,
/* 53 */ op1op2BLT,
/* 54 */ op1op2BLT,
/* 55 */ op0BLT,     // DEST INVERT. Blinking things, like a text cursor.
/* 56 */ op1op2BLT,
/* 57 */ op1op2BLT,
/* 58 */ op1op2BLT,
/* 59 */ op1op2BLT,
/* 5A */ op2BLT,     // DPx   -- PAT INVERT
/* 5B */ op1op2BLT,
/* 5C */ op1op2BLT,
/* 5D */ op1op2BLT,
/* 5E */ op1op2BLT,
/* 5F */ op2BLT,     // DPan
/* 60 */ op1op2BLT,
/* 61 */ op1op2BLT,
/* 62 */ op1op2BLT,
/* 63 */ op1op2BLT,
/* 64 */ op1op2BLT,
/* 65 */ op1op2BLT,
/* 66 */ op1BLT,     // DSx   -- SRC INVERT
/* 67 */ op1op2BLT,
/* 68 */ op1op2BLT,
/* 69 */ op1op2BLT,
/* 6A */ op1op2BLT,
/* 6B */ op1op2BLT,
/* 6C */ op1op2BLT,
/* 6D */ op1op2BLT,
/* 6E */ op1op2BLT,
/* 6F */ op1op2BLT,
/* 70 */ op1op2BLT,
/* 71 */ op1op2BLT,
/* 72 */ op1op2BLT,
/* 73 */ op1op2BLT,
/* 74 */ op1op2BLT,
/* 75 */ op1op2BLT,
/* 76 */ op1op2BLT,
/* 77 */ op1BLT,     // DSan
/* 78 */ op1op2BLT,
/* 79 */ op1op2BLT,
/* 7A */ op1op2BLT,
/* 7B */ op1op2BLT,
/* 7C */ op1op2BLT,
/* 7D */ op1op2BLT,
/* 7E */ op1op2BLT,
/* 7F */ op1op2BLT,
/* 80 */ op1op2BLT,
/* 81 */ op1op2BLT,
/* 82 */ op1op2BLT,
/* 83 */ op1op2BLT,
/* 84 */ op1op2BLT,
/* 85 */ op1op2BLT,
/* 86 */ op1op2BLT,
/* 87 */ op1op2BLT,
/* 88 */ op1BLT,     // DSa   -- SRC AND
/* 89 */ op1op2BLT,
/* 8A */ op1op2BLT,
/* 8B */ op1op2BLT,
/* 8C */ op1op2BLT,
/* 8D */ op1op2BLT,
/* 8E */ op1op2BLT,
/* 8F */ op1op2BLT,
/* 90 */ op1op2BLT,
/* 91 */ op1op2BLT,
/* 92 */ op1op2BLT,
/* 93 */ op1op2BLT,
/* 94 */ op1op2BLT,
/* 95 */ op1op2BLT,
/* 96 */ op1op2BLT,
/* 97 */ op1op2BLT,
/* 98 */ op1op2BLT,
/* 99 */ op1BLT,     // DSa   -- SRC AND
/* 9A */ op1op2BLT,
/* 9B */ op1op2BLT,
/* 9C */ op1op2BLT,
/* 9D */ op1op2BLT,
/* 9E */ op1op2BLT,
/* 9F */ op1op2BLT,
/* A0 */ op2BLT,     // DPa
/* A1 */ op1op2BLT,
/* A2 */ op1op2BLT,
/* A3 */ op1op2BLT,
/* A4 */ op1op2BLT,
/* A5 */ op2BLT,     // DPxn
/* A6 */ op1op2BLT,
/* A7 */ op1op2BLT,
/* A8 */ op1op2BLT,
/* A9 */ op1op2BLT,
/* AA */ op0BLT,     // DEST = DEST.  
/* AB */ op1op2BLT,
/* AC */ op1op2BLT,
/* AD */ op1op2BLT,
/* AE */ op1op2BLT,
/* AF */ op2BLT,     // DPno
/* B0 */ op1op2BLT,
/* B1 */ op1op2BLT,
/* B2 */ op1op2BLT,
/* B3 */ op1op2BLT,
/* B4 */ op1op2BLT,
/* B5 */ op1op2BLT,
/* B6 */ op1op2BLT,
/* B7 */ op1op2BLT,
/* B8 */ op1op2BLT,
/* B9 */ op1op2BLT,
/* BA */ op1op2BLT,
/* BB */ op1BLT,     // DSno  -- MERGE PAINT
/* BC */ op1op2BLT,
/* BD */ op1op2BLT,
/* BE */ op1op2BLT,
/* BF */ op1op2BLT,
/* C0 */ op1op2BLT,
/* C1 */ op1op2BLT,
/* C2 */ op1op2BLT,
/* C3 */ op1op2BLT,
/* C4 */ op1op2BLT,
/* C5 */ op1op2BLT,
/* C6 */ op1op2BLT,
/* C7 */ op1op2BLT,
/* C8 */ op1op2BLT,
/* C9 */ op1op2BLT,
/* CA */ op1op2BLT,
/* CB */ op1op2BLT,
/* CC */ op1BLT,     // S     -- SRC COPY
/* CD */ op1op2BLT,
/* CE */ op1op2BLT,
/* CF */ op1op2BLT,
/* D0 */ op1op2BLT,
/* D1 */ op1op2BLT,
/* D2 */ op1op2BLT,
/* D3 */ op1op2BLT,
/* D4 */ op1op2BLT,
/* D5 */ op1op2BLT,
/* D6 */ op1op2BLT,
/* D7 */ op1op2BLT,
/* D8 */ op1op2BLT,
/* D9 */ op1op2BLT,
/* DA */ op1op2BLT,
/* DB */ op1op2BLT,
/* DC */ op1op2BLT,
/* DD */ op1BLT,     // SDno
/* DE */ op1op2BLT,
/* DF */ op1op2BLT,
/* E0 */ op1op2BLT,
/* E1 */ op1op2BLT,
/* E2 */ op1op2BLT,
/* E3 */ op1op2BLT,
/* E4 */ op1op2BLT,
/* E5 */ op1op2BLT,
/* E6 */ op1op2BLT,
/* E7 */ op1op2BLT,
/* E8 */ op1op2BLT,
/* E9 */ op1op2BLT,
/* EA */ op1op2BLT,
/* EB */ op1op2BLT,
/* EC */ op1op2BLT,
/* ED */ op1op2BLT,
/* EE */ op1BLT,     // DSo   -- SRC PAINT
/* EF */ op1op2BLT,
/* F0 */ op2BLT,     // P     -- PAT COPY.  Used for fills.
/* F1 */ op1op2BLT,
/* F2 */ op1op2BLT,
/* F3 */ op1op2BLT,
/* F4 */ op1op2BLT,
/* F5 */ op2BLT,     // PDno
/* F6 */ op1op2BLT,
/* F7 */ op1op2BLT,
/* F8 */ op1op2BLT,
/* F9 */ op1op2BLT,
/* FA */ op2BLT,     // DPo
/* FB */ op1op2BLT,
/* FC */ op1op2BLT,
/* FD */ op1op2BLT,
/* FE */ op1op2BLT,
/* FF */ op0BLT,     // WHITENESS.
};

#endif // _ROPTBL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\swat.h ===
;/* Oh no - a polymorphic include file!
COMMENT !
********************************************************************************
*
* Copyright (c) 1997, Cirrus Logic, Inc.
* All Rights Reserved.
*
* FILE:			$Workfile:   swat.h  $
*
* DESCRIPTION:	This file hols the SWAT optimization flags.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/swat.h  $
* 
*    Rev 1.14   Jan 07 1998 10:56:42   frido
* Removed LOWRES switch.
* 
*    Rev 1.13   Dec 10 1997 13:23:38   frido
* Merged from 1.62 branch.
* 
*    Rev 1.12.1.1   Nov 18 1997 15:18:48   frido
* Turned MULTI_CLOCK on.
* 
*    Rev 1.12.1.0   Nov 17 1997 11:00:38   frido
* Added MUTLI_CLOCK (defaults to off).
* 
*    Rev 1.12   Nov 04 1997 09:15:24   frido
* Added COLOR_TRANSLATE and LOWRES switches.
* 
*    Rev 1.11   Nov 03 1997 18:33:24   frido
* Turned DATASTREAMING switch on.
* 
*    Rev 1.10   Oct 24 1997 10:37:46   frido
* Added DATASTREAMING switch (default off).
* 
*    Rev 1.9   27 Aug 1997 10:39:28   noelv
* Enabled SWAT7 and MEMMGR
* 
*    Rev 1.8   19 Aug 1997 17:32:34   noelv
* Turned off SWAT7 for WHQL release.
* 
*    Rev 1.7   18 Aug 1997 13:59:12   noelv
* 
* Turned off MEMMGR for 8/20 WHQL release.  We'll turn it back on after WHQL
* 
*    Rev 1.6   14 Aug 1997 15:36:16   noelv
* Turn on the new memory manager
* 
*    Rev 1.5   08 Aug 1997 15:36:24   FRIDO
* Changed PREFETCH into SWAT7 (as it used to be).
* 
*    Rev 1.4   08 Aug 1997 14:46:10   FRIDO
* Added MEMMGR and PREFETCH switches.
* 
*    Rev 1.3   28 May 1997 12:33:16   noelv
* Fixed type in SWAT1.
* 
*    Rev 1.2   07 May 1997 13:55:10   noelv
* Turned all opts on except 4 for nt140b11f
* 
*    Rev 1.1   01 May 1997 10:42:24   noelv
* disabled SWAT for now.
* 
*    Rev 1.0   29 Apr 1997 16:27:56   noelv
* Initial revision.
* SWAT: 
* SWAT:    Rev 1.1   24 Apr 1997 12:23:30   frido
* SWAT: Removed SWAT5 switch (memory manager).
* SWAT: 
* SWAT:    Rev 1.0   19 Apr 1997 17:11:20   frido
* SWAT: First release.
*
********************************************************************************
END COMMENT ! ;*/

;/*
COMMENT !

	SWAT1 - Heap Pre-Allocation
	---------------------------

	WinBench 97 is a nice program but it has a flaw.  Since it will now create
	fonts and allocate device bitmaps during its test it is also measuring the
	performance of your system.  Every time memory is allocated for fonts,
	pens, brushes, or device bitmaps memory is being allocated and most likely
	Windows NT will swap memory to the hard disk to achieve this goal.  This is
	why putting in more memory will help to increase the score since there will
	be less hard disk swapping involved.  We need to counteract this behaviour
	and make WInBench 97 less dependend on the amount of system memory and hard
	disk speed.

	WinBench 97 uses 300x150 size bitmaps for its pause box.  The pause box is
	showed when WinBench 97 has disabled timing and is loading more playback
	data from the hard disk.  So here we have a way to do some stuff when which
	will not be timed.  What we will do is allocate enough heap memory for 8
	full-screen device bitmaps.  This will make the PowerPoint test very happy
	since it is allocating these 8 full-screen device bitmaps during the slide
	show.  The only drawback is that NT will swap memory to hard disk in the
	background.  This will lower the Access score which we don't want.  That is
	why we have added a counter.  The Access test uses 10 300x150 bitmaps so we
	count down until Access has passed.  Then we will start pre-allocating heap
	space during each 300x150 bitmap request.

	But this will drop the CorelDRAW test a little which *will* show up in the
	overall score.  So one extra allocation is requested.  We will pre-allocate
	the heap memory during every full-screen device bitmap (see SWAT2) when the
	count down counter has reached zero.

;*/
	#define	SWAT1					1	/*	C switch		!
			SWAT1				=	1	;	Assembly switch	*/

;/*
COMMENT !

	SWAT2 - Hostifying
	------------------

	WinBench 97 is creating and destroying two full-screen device bitmaps
	during the setup stage of every GDI playback test.  So this is a good time
	to hostify all device bitmaps in the off-screen memory heap to make room
	for more urgent device bitmaps.

;*/
	#define	SWAT2					1	/*	C switch		!
			SWAT2				=	1	;	Assembly switch	*/

;/*
COMMENT !

	SWAT3 - Font Cache
	------------------

	The old font cache was a fast font cache but it had one limitation.  It
	would allocate the memory for each font everywhere in the off-screen memory
	which means it would fragment the memory heap very much.

	During initialization a 128kB memory pool will be allocated in off-screen
	memory.  Each time the font cache needs to allocate a font tile (128x16)
	for a new font it will now be allocated from this pool, which will hold up
	to 64 font tiles.

;*/
	#define	SWAT3					1	/*	C switch		!
			SWAT3				=	1	;	Assembly switch	*/

;/*
COMMENT !

	SWAT4 - Hardware Optimization
	-----------------------------

	Set the following hardware options for the CL-GD5465 chip:

		1) Enable 4-way interleaving on 4MB and 8MB boards.
		2) Reduce Address Translate Delay to 3 clocks.
		3) On AC revision and higher enable 256-byte fetch.
		4) On AC revision and higher enable frame buffer bursting.

;*/
	#define	SWAT4					0	/*	C switch		!
			SWAT4				=	0	;	Assembly switch	*/

;/*
COMMENT !

	SWAT6 - Striping
	----------------

	Enable striping in the pattern blit functions.

;*/
	#define	SWAT6					1	/*	C switch		!
			SWAT6				=	1	;	Assembly switch	*/

;/*
COMMENT !

	MEMMGR
	------

	Enable new memory manager.

;*/
	#define	MEMMGR					1	/*	C switch		!
			MEMMGR				=	1	;	Assembly switch	*/

;/*
COMMENT !

	SWAT7 - Monochrome width cut-off
	--------------------------------

	Cut off monochrome source expansion to 896 pixels to fix the silicon bugs
	in 256-byte prefetch.

;*/
	#define	SWAT7					1	/*	C switch		!
			SWAT7				=	1	;	Assembly switch	*/

;/*
COMMENT !

	DATASTREAMING - PCI/AGP Data Streaming
	--------------------------------------

	Wait for enough FIFO slots before writing anything to the command FIFO of
	the chip.

;*/
	#define	DATASTREAMING			1	/*	C switch		!
			DATASTREAMING		=	1	;	Assembly switch	*/

;/*
COMMENT !

	COLOR_TRANSLATE - Hardware color translation
	--------------------------------------------

	Enable or disable hardwrae color translation.

;*/
	#define	COLOR_TRANSLATE			0	/*	C switch		!
			COLOR_TRANSLATE		=	0	;	Assembly switch	*/

;/*
COMMENT !

	MULTI_CLOCK - Multi RAMBUS clock
	--------------------------------

	Enable or disable multi clock support (e.g. 515MB/s and 600MB/s).

;*/
	#define	MULTI_CLOCK				1	/*	C switch		!
			MULTI_CLOCK			=	1	;	Assembly switch	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\include\xlate.h ===
/******************************Module*Header*******************************\
*
* Module Name: Xlate.h
* Author: Noel VanHook
* Purpose: Handles hardware color translation.
*
* Copyright (c) 1997 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/xlate.h  $
* 
*    Rev 1.3   15 Oct 1997 14:19:50   noelv
* Moved ODD to xlate.c
* 
*    Rev 1.2   15 Oct 1997 12:06:24   noelv
* 
* Added hostdata workaround for 65.
* 
*    Rev 1.1   19 Feb 1997 13:07:32   noelv
* Added translation table cache
* 
*    Rev 1.0   06 Feb 1997 10:35:48   noelv
* Initial revision.
*/

#ifndef _XLATE_H_
#pragma pack(1)

extern ULONG ulXlate[16];


//
// External functions.
//
BOOLEAN bCacheXlateTable(struct _PDEV *ppdev, 
                        unsigned long **ppulXlate,
                        SURFOBJ  *psoTrg,
                        SURFOBJ  *psoSrc,
                        XLATEOBJ *pxlo,
                        BYTE      rop);

void vInitHwXlate(struct _PDEV *ppdev);

void vInvalidateXlateCache(struct _PDEV *ppdev);



/*

In 16, 24, and 32 BPP HOSTDATA color translation may or may not work 
correctly on the 5465.
The following is an email from Gary describing how to tell a good BLT from
a bad BLT.

==========================================================================
Subject:   color translate L3DA lockups
    Date:  Fri, 10 Oct 97 09:50:03 PDT
    From:  garyru (Gary Rudolph)
       To: noelv, vernh, martinb
      CC:  garyru

Here is the function to determine if the wrong amount
of host data will be fetched for a color translate
when the source and dest bpp differ.  Add the least
significant three bits of the number of source bytes
to the least significant three bits of OP1 address
and use that value to determine if "Odd" is set using
the table below.  Then use the least significant
three bits of destination bytes plus the least significant
three bits of OP1 address and use that value to determine
if "Odd" is set.  If you come up with the same value for
"Odd" in both cases, then the right amount of host
data will be fetched.  If the values of "Odd" are 
different then the engine will fetch one too many
or one too few dwords of host data per line.


Add             Odd
---             ---
0000    0       0
0001    1       1
0010    2       1
0011    3       1
0100    4       1
0101    5       0
0110    6       0
0111    7       0
1000    8       0
1001    9       1
1010    10      1
1011    11      1
1100    12      1
1101    13      0
1110    14      0
1111    15      0


Example:  8 to 32 translate
bltx = 639 pixels
op1 = 0000

Source
639 = 0x27F 
        111
    +   000
                ---
                111  ---> Odd = 0

Dest
639 x 4 = 0x9FC
                100
        +   000
                ---
                100  ---> Odd = 1

It is the Dest value of "Odd" that is used, so the engine
only fetches one dWord of the last Qword incorrectly.

I think the fix for the L128 is to use the srcx value rather
than the byte converted blt extent to determine the number
of dWords of host data to fetch.


-Gary
===========================================================================

*/

// Declared in XLATE.C
extern char ODD[]; // = {0,1,1,1, 1,0,0,0, 0,1,1,1, 1,0,0,0};


#define XLATE_IS_BROKEN(width_in_bytes, bytes_per_pixel, phase)               \
(                                                                             \
 ODD [   ((width_in_bytes) & 7)  /* lowest three bits of source bytes */      \
       + ((phase) & 7 ) ]        /* plus lowest three bits of OP_1 */         \
            !=                                                                \
 ODD [ (((width_in_bytes)*(bytes_per_pixel)) & 7) /* low bits of dest bytes */\
      +((phase) & 7) ]         /* plus lowest three bits of OP_1 */           \
)                                                                             \







#endif // _XLATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\cl546x\clddc2b.c ===
/******************************************************************************
*
*                ******************************************
*                * Copyright (c) 1997, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:  Laguna I (CL-GD546x) - 
*
* FILE:     clddc2b.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module checks for a DDC monitor, and returns the 
*           established Timings value from the EDID if found.
*
****************************************************************************
****************************************************************************/

                                                       
/*----------------------------- INCLUDES ----------------------------------*/
#include "cirrus.h"


#define VOLATILE               volatile

#define I2COUT_PORT            0x280
#define I2CIN_PORT             0x281

#define OFF                    0
#define ON                     1

/*-------------------------------------------------------------------------*/
unsigned char InMemb(PHW_DEVICE_EXTENSION HwDeviceExtension, int offset)
{
  #undef LAGUNA_REGS
  #define LAGUNA_REGS HwDeviceExtension->RegisterAddress
  VOLATILE unsigned char *pByte = (unsigned char *)(LAGUNA_REGS + offset);

  return *pByte;
}

unsigned char OutMemb(PHW_DEVICE_EXTENSION HwDeviceExtension,
                      int offset,
                      unsigned char value)
{
  #undef LAGUNA_REGS
  #define LAGUNA_REGS HwDeviceExtension->RegisterAddress
  VOLATILE unsigned char *pByte = (unsigned char *)(LAGUNA_REGS + offset);

  *pByte = value;
  return *pByte;
}


// NOTE: HwDeviceExtension->I2Cflavor determines whether to invert the
//       output clock and data lines and is set in GetDDCInformation below

/*-------------------------------------------------------------------------*/
VOID WriteClockLine (PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR data)
{
  UCHAR ReadSEQDATA;

  ReadSEQDATA = InMemb(HwDeviceExtension, I2COUT_PORT);

  ReadSEQDATA = (ReadSEQDATA & 0x7F) | ((data^HwDeviceExtension->I2Cflavor) << 7);

  OutMemb(HwDeviceExtension, I2COUT_PORT, ReadSEQDATA);
}


/*-------------------------------------------------------------------------*/
VOID WriteDataLine (PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR data)
{
  UCHAR ReadSEQDATA;

  ReadSEQDATA = InMemb(HwDeviceExtension, I2COUT_PORT);

  ReadSEQDATA &= 0xFE;
  ReadSEQDATA |= (data^HwDeviceExtension->I2Cflavor) & 1;

  OutMemb(HwDeviceExtension, I2COUT_PORT, ReadSEQDATA);
}


/*-------------------------------------------------------------------------*/
BOOLEAN ReadClockLine (PHW_DEVICE_EXTENSION HwDeviceExtension)
{
  UCHAR ReadSEQDATA;

  ReadSEQDATA = InMemb(HwDeviceExtension, I2CIN_PORT);

  return (ReadSEQDATA >> 7);
}


/*-------------------------------------------------------------------------*/
BOOLEAN ReadDataLine (PHW_DEVICE_EXTENSION HwDeviceExtension)
{
  return (InMemb(HwDeviceExtension, I2CIN_PORT) & 1);
} 


/*-------------------------------------------------------------------------*/
VOID WaitVSync (PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    // not used
}


// callbacks for VideoPortDDCMonitorHelper

I2C_FNC_TABLE I2CFunctions =
{
    sizeof(struct _I2C_FNC_TABLE ),
    WriteClockLine,
    WriteDataLine,
    ReadClockLine,
    ReadDataLine,
    WaitVSync,
    NULL
};

BOOLEAN GetDDCInformation(
	PHW_DEVICE_EXTENSION HwDeviceExtension,
	PVOID QueryBuffer,
	ULONG BufferSize
)
{
    // Some cards invert the output clock and data bits.
    // (It's probably all 5465's but since I'm not sure so I will try
    // reading the DDC info first without inverting the output then with
    // instead of assuming it by chip type)

    HwDeviceExtension->I2Cflavor=0; // start non inverted
    if (!VideoPortDDCMonitorHelper (HwDeviceExtension,
                                   &I2CFunctions,
                                   QueryBuffer,
                                   BufferSize)
       )
    {
        HwDeviceExtension->I2Cflavor=0xff; // else try inverted
        if (!VideoPortDDCMonitorHelper (HwDeviceExtension,
                                    &I2CFunctions,
                                    QueryBuffer,
                                    BufferSize)
        )
            return FALSE;   
    }

    VideoPortMoveMemory(HwDeviceExtension->EDIDBuffer,
                        QueryBuffer,
                 sizeof(HwDeviceExtension->EDIDBuffer));
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\cl546x\logfile.c ===
/*****************************************************************************
******************************************************************************
*
*                ******************************************
*                * Copyright (c) 1996, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:  Laguna I (CL-GD546x) - 
*
* FILE:     logfile.c
*
* AUTHOR:   Sue Schell
*
* DESCRIPTION:
*           This file contains routines that create and write to 
*           the log file, used for debugging and testing purposes
*           only.
*
* MODULES:
*           CreateLogFile()
*           WriteLogFile()
*           CloseLogFile()
*
* REVISION HISTORY:
*
* $Log:   X:/log/laguna/nt35/miniport/cl546x/logfile.c  $
* 
*    Rev 1.2   03 Dec 1996 15:34:34   SueS
* When CreateLogFile is called, do not overwrite the existing file.  In the
* DirectDraw tests, DrvEnablePDEV is called numerous times, which wiped
* out the log file.  Also, open and append to the log file each time, instead
* of attaching to the creating process.
* 
*    Rev 1.1   26 Nov 1996 08:52:06   SueS
* When the log file is opened, get the system process that owns the handle.
* Switch to this process when writing to the file.  Otherwise, only the
* process that owns the handle can write to the file.
* 
*    Rev 1.0   13 Nov 1996 15:32:42   SueS
* Initial revision.
* 
****************************************************************************
****************************************************************************/


/////////////////////
//  Include Files  //
/////////////////////
#include <ntddk.h>          // various NT definitions
#include "type.h"
#include "logfile.h"


////////////////////////
//  Global Variables  //
////////////////////////
#if LOG_FILE

HANDLE LogFileHandle;                 // Handle for log file
UNICODE_STRING FileName;              // Unicode string name of log file
OBJECT_ATTRIBUTES ObjectAttributes;   // File object attributes
IO_STATUS_BLOCK IoStatus;             // Returned status information
LARGE_INTEGER MaxFileSize;            // File size
NTSTATUS Status;                      // Returned status

//////////////////////////
//  External Functions  //
//////////////////////////


///////////////////////////////////////////////////////////////////////////////
//
//  HANDLE CreateLogFile(void)
//
//  Parameters:
//      none
//
//  Return:
//      the handle of the just-opened log file
//
//  Notes:
//
//      This function uses kernel mode support routines to open the
//      log file, used to log activity in the display driver.
//
///////////////////////////////////////////////////////////////////////////////
HANDLE CreateLogFile(void)
{
HANDLE FileHandle;                    // Handle to opened file


    // Initialize a Unicode String containing the name of
    // the file to be opened and read.
    RtlInitUnicodeString(&FileName, L"\\DosDevices\\C:\\temp\\CL546x.LOG");

    // Initialize file attributes
    InitializeObjectAttributes(&ObjectAttributes,        // initialized attrib
                               &FileName,                // full file path name
                               OBJ_CASE_INSENSITIVE,     // attributes
                               NULL,                     // root directory
                               NULL);                    // security descriptor

    // Open the file, creating it if necessary
    MaxFileSize.QuadPart = 20000000;

    Status = ZwCreateFile(&FileHandle,                   // file handle
                          SYNCHRONIZE | FILE_APPEND_DATA,// desired access
                          &ObjectAttributes,             // object attributes
                          &IoStatus,                     // returned status
                          &MaxFileSize,                  // alloc size
                          FILE_ATTRIBUTE_NORMAL,         // file attributes
                          FILE_SHARE_READ,               // share access
                          FILE_OPEN_IF,                  // create disposition
                          FILE_SYNCHRONOUS_IO_NONALERT,  // create options
                          NULL,                          // eabuffer
                          0);                            // ealength

    ZwClose(FileHandle);

    if (NT_SUCCESS(Status))
        return(FileHandle);
    else
        return((HANDLE)-1);

}

                                

///////////////////////////////////////////////////////////////////////////////
//
//  BOOLEAN WriteLogFile(HANDLE FileHandle, PVOID InputBuffer,
//                       ULONG InputBufferLength)
//
//  Parameters:
//      FileHandle - the handle of the log file, already opened
//      InputBuffer - the data to be written to the log file
//      InputBufferLength - the length of the data
//
//  Return:
//      TRUE - the write operation was successful
//      FALSE - the write operation failed
//
//  Notes:
//
//      This function writes the supplied buffer to the open log file
//
///////////////////////////////////////////////////////////////////////////////
BOOLEAN WriteLogFile(
    HANDLE FileHandle,
    PVOID InputBuffer,
    ULONG InputBufferLength
)
{

    // Open the file for writing
    Status = ZwCreateFile(&FileHandle,                   // file handle
                          SYNCHRONIZE | FILE_APPEND_DATA,// desired access
                          &ObjectAttributes,             // object attributes
                          &IoStatus,                     // returned status
                          &MaxFileSize,                  // alloc size
                          FILE_ATTRIBUTE_NORMAL,         // file attributes
                          FILE_SHARE_READ,               // share access
                          FILE_OPEN_IF,                  // create disposition
                          FILE_SYNCHRONOUS_IO_NONALERT,  // create options
                          NULL,                          // eabuffer
                          0);                            // ealength

    // Write to the file
    Status = ZwWriteFile(FileHandle,         // handle from ZwCreateFile
                         NULL,               // NULL for device drivers
                         NULL,               // NULL for device drivers
                         NULL,               // NULL for device drivers
                         &IoStatus,          // returned status
                         InputBuffer,        // buffer with data to be written
                         InputBufferLength,  // size in bytes of buffer
                         NULL,               // write at current file position
                         NULL);              // NULL for device drivers

    ZwClose(FileHandle);

    if (NT_SUCCESS(Status))
        return(TRUE);
    else
        return(FALSE);


}


///////////////////////////////////////////////////////////////////////////////
//
//  void CloseLogFile(HANDLE FileHandle)
//
//  Parameters:
//      FileHandle - the handle of the open log file
//
//  Return:
//
//  Notes:
//      TRUE - the close operation was successful
//      FALSE - the close operation failed
//
//      This function closes the already open log file
//
///////////////////////////////////////////////////////////////////////////////
BOOLEAN CloseLogFile(HANDLE FileHandle)
{
NTSTATUS Status;


    // Close the log file
    Status = ZwClose(FileHandle);

    if (NT_SUCCESS(Status))
        return(TRUE);
    else
        return(FALSE);

}

#endif     // LOG_FILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\cl546x\logfile.h ===
/****************************************************************************
*****************************************************************************
*
*                ******************************************
*                * Copyright (c) 1996, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:    Laguna I (CL-GD546x) - 
*
* FILE:       logfile.h
*
* AUTHOR:     Sue Schell
*
* DESCRIPTION:
*           This file contains the definitions needed for the
*           log file option.
*
*
* REVISION HISTORY:
*
* $Log:   X:/log/laguna/nt35/miniport/cl546x/logfile.h  $
* 
*    Rev 1.1   26 Nov 1996 08:50:36   SueS
* Added function to close the log file.
* 
*    Rev 1.0   13 Nov 1996 15:33:10   SueS
* Initial revision.
* 
****************************************************************************
****************************************************************************/


///////////////
//  Defines  //
///////////////

//
// 0 = Normal operation
// 1 = Log information that display driver sends to us to a file.
//
#define LOG_FILE 0


#if LOG_FILE
///////////////////////////
//  Function Prototypes  //
///////////////////////////

    HANDLE CreateLogFile(void);

    BOOLEAN WriteLogFile(
        HANDLE FileHandle,
        PVOID InputBuffer,
        ULONG InputBufferLength
    );

    BOOLEAN CloseLogFile(
        HANDLE FileHandle
    );

#endif    // LOG_FILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\cl546x\mtbl.c ===
/****************************************************************************
******************************************************************************
*
*                ******************************************
*                * Copyright (c) 1995, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:	Laguna I (CL-GD5462) - 
*
* FILE:		mtbl.c
*
* AUTHOR: Andrew P. Sobczyk
*
* DESCRIPTION:* File Generated from Excel Mode Tables using bsv.l
*
* MODULES: None... Pure Data
*
* REVISION HISTORY:
*
* $Log:   //uinac/log/log/laguna/nt35/miniport/cl546x/MTBL.C  $
* 
*    Rev 1.22   Jun 17 1998 09:45:16   frido
* PDR#????? - Removed paging from data segment.
* 
*    Rev 1.21   27 Jun 1997 15:06:50   noelv
* 
* Yanked 32bpp modes for WHQL.
* 
*    Rev 1.20   17 Apr 1997 14:29:44   noelv
* Removed 1600x1200@80,85.  We'll let MODE.INI handle these modes.
* 
*    Rev 1.19   21 Jan 1997 14:40:26   noelv
* Added 1600x1200x8@65,70,75 and 85 to 5464
* 
*    Rev 1.18   21 Jan 1997 11:32:50   noelv
* Dropped 1280x1024x16@84 for 5464
* Added 1024x768x32@70,75,85 for 5462
* Added 1600x1200x8@65,70,75 for 5462
* 
*    Rev 1.17   14 Jan 1997 12:32:06   noelv
* Split MODE.INI by chip type
* 
*    Rev 1.16   30 Oct 1996 14:07:18   bennyn
* 
* Modified for pageable miniport
* 
*    Rev 1.15   30 Sep 1996 10:01:16   noelv
* Changed nam,e of interlaced modes from 87i to 43i.
* 
*    Rev 1.14   30 Aug 1996 14:50:56   noelv
* Enabled mode.ini for nt 3.51
* 
*    Rev 1.13   23 Aug 1996 12:45:38   noelv
* 
*    Rev 1.12   22 Aug 1996 16:35:18   noelv
* Changed for new mode.ini
* 
*    Rev 1.8   31 May 1996 11:15:12   noelv
* Removed 640x400 modes
* 
*    Rev 1.7   25 Mar 1996 19:07:30   noelv
* 
* disabled refresh rates above 60hz for 1023x768x32bpps
* 
*    Rev 1.6   21 Mar 1996 14:29:42   noelv
* Removed high refresh rates in 1600x1200 mode.
* 
*    Rev 1.5   02 Mar 1996 12:30:50   noelv
* Miniport now patches the ModeTable with information read from the BIOS
* 
*    Rev 1.4   10 Jan 1996 16:32:42   NOELV
* Undid rev 1.3
* 
*    Rev 1.2   18 Sep 1995 10:02:48   bennyn
* 
* 
*    Rev 1.1   22 Aug 1995 10:18:42   bennyn
* 
* Limited mode version
* 
*    Rev 1.0   24 Jul 1995 13:23:06   NOELV
* Initial revision.
*
****************************************************************************
****************************************************************************/
/*----------------------------- INCLUDES ----------------------------------*/

#include "cirrus.h"


//
// This file holds the mode table records for the NT driver.
// We can define modes in two places:  The BIOS, and MODE.INI.
//
// BIOS Modes:
// ------------
// Each mode/refresh-rate that the BIOS supports has a record in this table.
// The record include the BIOS mode number and the refresh index.
//
// MODE.INI modes:
// ---------------
// MODE.INI defines a bunch of modes, and instructions on how to set those modes.
// At compile time, the CGLMODE.EXE utility processes MODE.INI and produced two files:
// ModeStr.C = A C file that contains one record (just like the ones below) for
//             each mode in MODE.INI.  We '#include' ModeStr.C into this file (MTBL.C)
// ModeStr.H = Contains a "SetMode string" that we can pass to SetMode().
//             Note that for the BIOS modes below, we set this to NULL.
// 
//

#include "ModeStr.h"  // Include all the SetMode() strings for the MODE.INI modes.

#define WHQL_5462_PANIC_HACK 1

#define SUPPORT640x400  0

#if 0 // Stress test
#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGE")
#endif
#endif

//
// NOTE:
// The BytesPerScanLine values in this table are checked against the BIOS
// and updated if necessary.
// See CLValidateModes() in CIRRUS.C
//

MODETABLE ModeTable[]  = {

	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR,
	   0,		//// Frequency
	0x03,		//// Cirrus Logic Mode #
	 160,		//// BytesPerScanLine
	 640,		//// XResol
	 350,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   4,		//// NumofPlanes
	   1,		//// BitsPerPixel
	0x00,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR,
	   0,		//// Frequency
	0x03,		//// Cirrus Logic Mode #
	 160,		//// BytesPerScanLine
	 720,		//// XResol
	 400,		//// YResol
	   9,		//// XCharSize
	  16,		//// YCharSize
	   4,		//// NumofPlanes
	   1,		//// BitsPerPixel
	0x00,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  60,		//// Frequency
	0x12,		//// Cirrus Logic Mode #
	  80,		//// BytesPerScanLine
	 640,		//// XResol
	 480,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   4,		//// NumofPlanes
	   4,		//// BitsPerPixel
	0x00,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  72,		//// Frequency
	0x12,		//// Cirrus Logic Mode #
	  80,		//// BytesPerScanLine
	 640,		//// XResol
	 480,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   4,		//// NumofPlanes
	   4,		//// BitsPerPixel
	0x10,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  75,		//// Frequency
	0x12,		//// Cirrus Logic Mode #
	  80,		//// BytesPerScanLine
	 640,		//// XResol
	 480,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   4,		//// NumofPlanes
	   4,		//// BitsPerPixel
	0x20,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  85,		//// Frequency
	0x12,		//// Cirrus Logic Mode #
	  80,		//// BytesPerScanLine
	 640,		//// XResol
	 480,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   4,		//// NumofPlanes
	   4,		//// BitsPerPixel
	0x30,		//// Refresh Index
	   0,		//// ModeSetString
	},
#if SUPPORT640x400
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  60,		//// Frequency
	0x5E,		//// Cirrus Logic Mode #
	 640,		//// BytesPerScanLine
	 640,		//// XResol
	 400,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x00,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  60,		//// Frequency
	0x7A,		//// Cirrus Logic Mode #
	1280,		//// BytesPerScanLine
	 640,		//// XResol
	 400,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  16,		//// BitsPerPixel
	0x00,		//// Refresh Index
	   0,		//// ModeSetString
	},
#endif

    // 640 x 480 x 8 @ 60hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  60,		//// Frequency
	0x5F,		//// Cirrus Logic Mode #
	 640,		//// BytesPerScanLine
	 640,		//// XResol
	 480,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x00,		//// Refresh Index
	   0,		//// ModeSetString
	},

    // 640 x 480 x 8 @ 72hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  72,		//// Frequency
	0x5F,		//// Cirrus Logic Mode #
	 640,		//// BytesPerScanLine
	 640,		//// XResol
	 480,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x10,		//// Refresh Index
	   0,		//// ModeSetString
	},

    // 640 x 480 x 8 @ 75hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  75,		//// Frequency
	0x5F,		//// Cirrus Logic Mode #
	 640,		//// BytesPerScanLine
	 640,		//// XResol
	 480,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x20,		//// Refresh Index
	   0,		//// ModeSetString
	},

    // 640 x 480 x 8 @ 85hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  85,		//// Frequency
	0x5F,		//// Cirrus Logic Mode #
	 640,		//// BytesPerScanLine
	 640,		//// XResol
	 480,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x30,		//// Refresh Index
	   0,		//// ModeSetString
	},

    // 640 x 480 x 16 @ 60hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  60,		//// Frequency
	0x64,		//// Cirrus Logic Mode #
	1280,		//// BytesPerScanLine
	 640,		//// XResol
	 480,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  16,		//// BitsPerPixel
	0x00,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  72,		//// Frequency
	0x64,		//// Cirrus Logic Mode #
	1280,		//// BytesPerScanLine
	 640,		//// XResol
	 480,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  16,		//// BitsPerPixel
	0x10,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  75,		//// Frequency
	0x64,		//// Cirrus Logic Mode #
	1280,		//// BytesPerScanLine
	 640,		//// XResol
	 480,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  16,		//// BitsPerPixel
	0x20,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  85,		//// Frequency
	0x64,		//// Cirrus Logic Mode #
	1280,		//// BytesPerScanLine
	 640,		//// XResol
	 480,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  16,		//// BitsPerPixel
	0x30,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  60,		//// Frequency
	0x71,		//// Cirrus Logic Mode #
	2048,		//// BytesPerScanLine
	 640,		//// XResol
	 480,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  24,		//// BitsPerPixel
	0x00,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  72,		//// Frequency
	0x71,		//// Cirrus Logic Mode #
	2048,		//// BytesPerScanLine
	 640,		//// XResol
	 480,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  24,		//// BitsPerPixel
	0x10,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  75,		//// Frequency
	0x71,		//// Cirrus Logic Mode #
	2048,		//// BytesPerScanLine
	 640,		//// XResol
	 480,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  24,		//// BitsPerPixel
	0x20,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  85,		//// Frequency
	0x71,		//// Cirrus Logic Mode #
	2048,		//// BytesPerScanLine
	 640,		//// XResol
	 480,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  24,		//// BitsPerPixel
	0x30,		//// Refresh Index
	   0,		//// ModeSetString
	},
#if (! WHQL_5462_PANIC_HACK) 

	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  60,		//// Frequency
	0x76,		//// Cirrus Logic Mode #
	2560,		//// BytesPerScanLine
	 640,		//// XResol
	 480,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  32,		//// BitsPerPixel
	0x00,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  72,		//// Frequency
	0x76,		//// Cirrus Logic Mode #
	2560,		//// BytesPerScanLine
	 640,		//// XResol
	 480,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  32,		//// BitsPerPixel
	0x10,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  75,		//// Frequency
	0x76,		//// Cirrus Logic Mode #
	2560,		//// BytesPerScanLine
	 640,		//// XResol
	 480,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  32,		//// BitsPerPixel
	0x20,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  85,		//// Frequency
	0x76,		//// Cirrus Logic Mode #
	2560,		//// BytesPerScanLine
	 640,		//// XResol
	 480,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  32,		//// BitsPerPixel
	0x30,		//// Refresh Index
	   0,		//// ModeSetString
	},
#endif
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  56,		//// Frequency
	0x5C,		//// Cirrus Logic Mode #
	1024,		//// BytesPerScanLine
	 800,		//// XResol
	 600,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x00,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  60,		//// Frequency
	0x5C,		//// Cirrus Logic Mode #
	1024,		//// BytesPerScanLine
	 800,		//// XResol
	 600,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x01,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  72,		//// Frequency
	0x5C,		//// Cirrus Logic Mode #
	1024,		//// BytesPerScanLine
	 800,		//// XResol
	 600,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x02,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  75,		//// Frequency
	0x5C,		//// Cirrus Logic Mode #
	1024,		//// BytesPerScanLine
	 800,		//// XResol
	 600,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x03,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  85,		//// Frequency
	0x5C,		//// Cirrus Logic Mode #
	1024,		//// BytesPerScanLine
	 800,		//// XResol
	 600,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x04,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  56,		//// Frequency
	0x65,		//// Cirrus Logic Mode #
	1664,		//// BytesPerScanLine
	 800,		//// XResol
	 600,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  16,		//// BitsPerPixel
	0x00,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  60,		//// Frequency
	0x65,		//// Cirrus Logic Mode #
	1664,		//// BytesPerScanLine
	 800,		//// XResol
	 600,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  16,		//// BitsPerPixel
	0x01,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  72,		//// Frequency
	0x65,		//// Cirrus Logic Mode #
	1664,		//// BytesPerScanLine
	 800,		//// XResol
	 600,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  16,		//// BitsPerPixel
	0x02,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  75,		//// Frequency
	0x65,		//// Cirrus Logic Mode #
	1664,		//// BytesPerScanLine
	 800,		//// XResol
	 600,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  16,		//// BitsPerPixel
	0x03,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  85,		//// Frequency
	0x65,		//// Cirrus Logic Mode #
	1664,		//// BytesPerScanLine
	 800,		//// XResol
	 600,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  16,		//// BitsPerPixel
	0x04,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  56,		//// Frequency
	0x78,		//// Cirrus Logic Mode #
	2560,		//// BytesPerScanLine
	 800,		//// XResol
	 600,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  24,		//// BitsPerPixel
	0x00,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  60,		//// Frequency
	0x78,		//// Cirrus Logic Mode #
	2560,		//// BytesPerScanLine
	 800,		//// XResol
	 600,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  24,		//// BitsPerPixel
	0x01,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  72,		//// Frequency
	0x78,		//// Cirrus Logic Mode #
	2560,		//// BytesPerScanLine
	 800,		//// XResol
	 600,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  24,		//// BitsPerPixel
	0x02,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  75,		//// Frequency
	0x78,		//// Cirrus Logic Mode #
	2560,		//// BytesPerScanLine
	 800,		//// XResol
	 600,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  24,		//// BitsPerPixel
	0x03,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  85,		//// Frequency
	0x78,		//// Cirrus Logic Mode #
	2560,		//// BytesPerScanLine
	 800,		//// XResol
	 600,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  24,		//// BitsPerPixel
	0x04,		//// Refresh Index
	   0,		//// ModeSetString
	},
#if (! WHQL_5462_PANIC_HACK) 
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  56,		//// Frequency
	0x72,		//// Cirrus Logic Mode #
	3328,		//// BytesPerScanLine
	 800,		//// XResol
	 600,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  32,		//// BitsPerPixel
	0x00,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  60,		//// Frequency
	0x72,		//// Cirrus Logic Mode #
	3328,		//// BytesPerScanLine
	 800,		//// XResol
	 600,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  32,		//// BitsPerPixel
	0x01,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  72,		//// Frequency
	0x72,		//// Cirrus Logic Mode #
	3328,		//// BytesPerScanLine
	 800,		//// XResol
	 600,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  32,		//// BitsPerPixel
	0x02,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  75,		//// Frequency
	0x72,		//// Cirrus Logic Mode #
	3328,		//// BytesPerScanLine
	 800,		//// XResol
	 600,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  32,		//// BitsPerPixel
	0x03,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  85,		//// Frequency
	0x72,		//// Cirrus Logic Mode #
	3328,		//// BytesPerScanLine
	 800,		//// XResol
	 600,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  32,		//// BitsPerPixel
	0x04,		//// Refresh Index
	   0,		//// ModeSetString
	},
#endif

// 1024 x 768 x 8  43 hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_INTERLACED,
	  43,		//// Frequency
	0x60,		//// Cirrus Logic Mode #
	1024,		//// BytesPerScanLine
	1024,		//// XResol
	 768,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x00,		//// Refresh Index
	   0,		//// ModeSetString
	},
// 1024 x 768 x 8  60 hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  60,		//// Frequency
	0x60,		//// Cirrus Logic Mode #
	1024,		//// BytesPerScanLine
	1024,		//// XResol
	 768,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x10,		//// Refresh Index
	   0,		//// ModeSetString
	},
// 1024 x 768 x 8  70 hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  70,		//// Frequency
	0x60,		//// Cirrus Logic Mode #
	1024,		//// BytesPerScanLine
	1024,		//// XResol
	 768,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x20,		//// Refresh Index
	   0,		//// ModeSetString
	},
// 1024 x 768 x 8  75 hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  75,		//// Frequency
	0x60,		//// Cirrus Logic Mode #
	1024,		//// BytesPerScanLine
	1024,		//// XResol
	 768,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x40,		//// Refresh Index
	   0,		//// ModeSetString
	},
// 1024 x 768 x 8  85 hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  85,		//// Frequency
	0x60,		//// Cirrus Logic Mode #
	1024,		//// BytesPerScanLine
	1024,		//// XResol
	 768,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x50,		//// Refresh Index
	   0,		//// ModeSetString
	},


	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_INTERLACED,
	  43,		//// Frequency
	0x74,		//// Cirrus Logic Mode #
	2048,		//// BytesPerScanLine
	1024,		//// XResol
	 768,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  16,		//// BitsPerPixel
	0x00,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  60,		//// Frequency
	0x74,		//// Cirrus Logic Mode #
	2048,		//// BytesPerScanLine
	1024,		//// XResol
	 768,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  16,		//// BitsPerPixel
	0x10,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  70,		//// Frequency
	0x74,		//// Cirrus Logic Mode #
	2048,		//// BytesPerScanLine
	1024,		//// XResol
	 768,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  16,		//// BitsPerPixel
	0x20,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  75,		//// Frequency
	0x74,		//// Cirrus Logic Mode #
	2048,		//// BytesPerScanLine
	1024,		//// XResol
	 768,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  16,		//// BitsPerPixel
	0x40,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  85,		//// Frequency
	0x74,		//// Cirrus Logic Mode #
	2048,		//// BytesPerScanLine
	1024,		//// XResol
	 768,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  16,		//// BitsPerPixel
	0x50,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_INTERLACED,
	  43,		//// Frequency
	0x79,		//// Cirrus Logic Mode #
	3328,		//// BytesPerScanLine
	1024,		//// XResol
	 768,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  24,		//// BitsPerPixel
	0x00,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  60,		//// Frequency
	0x79,		//// Cirrus Logic Mode #
	3328,		//// BytesPerScanLine
	1024,		//// XResol
	 768,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  24,		//// BitsPerPixel
	0x10,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  70,		//// Frequency
	0x79,		//// Cirrus Logic Mode #
	3328,		//// BytesPerScanLine
	1024,		//// XResol
	 768,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  24,		//// BitsPerPixel
	0x20,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  75,		//// Frequency
	0x79,		//// Cirrus Logic Mode #
	3328,		//// BytesPerScanLine
	1024,		//// XResol
	 768,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  24,		//// BitsPerPixel
	0x40,		//// Refresh Index
	   0,		//// ModeSetString
	},
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  85,		//// Frequency
	0x79,		//// Cirrus Logic Mode #
	3328,		//// BytesPerScanLine
	1024,		//// XResol
	 768,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  24,		//// BitsPerPixel
	0x50,		//// Refresh Index
	   0,		//// ModeSetString
	},

#if (! WHQL_5462_PANIC_HACK) 
    // 1024 x 768 x 32 @ 43i hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_INTERLACED,
	  43,		//// Frequency
	0x73,		//// Cirrus Logic Mode #
	4096,		//// BytesPerScanLine
	1024,		//// XResol
	 768,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  32,		//// BitsPerPixel
	0x00,		//// Refresh Index
	   0,		//// ModeSetString
	},

    // 1024 x 768 x 32 @ 60 hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  60,		//// Frequency
	0x73,		//// Cirrus Logic Mode #
	4096,		//// BytesPerScanLine
	1024,		//// XResol
	 768,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  32,		//// BitsPerPixel
	0x10,		//// Refresh Index
	   0,		//// ModeSetString
	},

    // 1024 x 768 x 32 @ 70 hz
	{
	   0,		//// Valid Mode
       LG_5462, //// The Laguna 5462 
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  70,		//// Frequency
	0x73,		//// Cirrus Logic Mode #
	4096,		//// BytesPerScanLine
	1024,		//// XResol
	 768,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  32,		//// BitsPerPixel
	0x20,		//// Refresh Index
	   0,		//// ModeSetString
	},

    // 1024 x 768 x 32 @ 75 hz
	{
	   0,		//// Valid Mode
       LG_5462, //// The Laguna 5462 
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  75,		//// Frequency
	0x73,		//// Cirrus Logic Mode #
	4096,		//// BytesPerScanLine
	1024,		//// XResol
	 768,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  32,		//// BitsPerPixel
	0x40,		//// Refresh Index
	   0,		//// ModeSetString
	},

    // 1024 x 768 x 32 @ 85 hz
	{
	   0,		//// Valid Mode
       LG_5462, //// The Laguna 5462 
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  85,		//// Frequency
	0x73,		//// Cirrus Logic Mode #
	4096,		//// BytesPerScanLine
	1024,		//// XResol
	 768,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  32,		//// BitsPerPixel
	0x50,		//// Refresh Index
	   0,		//// ModeSetString
	},
#endif

    // 1280 x 1024 x 8 @ 43i hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_INTERLACED,
	  43,		//// Frequency
	0x6D,		//// Cirrus Logic Mode #
	1280,		//// BytesPerScanLine
	1280,		//// XResol
	1024,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x00,		//// Refresh Index
	   0,		//// ModeSetString
	},

    // 1280 x 1024 x 8 @ 60hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  60,		//// Frequency
	0x6D,		//// Cirrus Logic Mode #
	1280,		//// BytesPerScanLine
	1280,		//// XResol
	1024,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x10,		//// Refresh Index
	   0,		//// ModeSetString
	},

    // 1280 x 1024 x 8 @ 71hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  71,		//// Frequency
	0x6D,		//// Cirrus Logic Mode #
	1280,		//// BytesPerScanLine
	1280,		//// XResol
	1024,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x20,		//// Refresh Index
	   0,		//// ModeSetString
	},

    // 1280 x 1024 x 8 @ 75hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  75,		//// Frequency
	0x6D,		//// Cirrus Logic Mode #
	1280,		//// BytesPerScanLine
	1280,		//// XResol
	1024,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x30,		//// Refresh Index
	   0,		//// ModeSetString
	},

    // 1280 x 1024 x 8 @ 85hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  85,		//// Frequency
	0x6D,		//// Cirrus Logic Mode #
	1280,		//// BytesPerScanLine
	1280,		//// XResol
	1024,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x40,		//// Refresh Index
	   0,		//// ModeSetString
	},

    // 1280 x 1024 x 16 @ 43ihz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_INTERLACED,
	  43,		//// Frequency
	0x75,		//// Cirrus Logic Mode #
	2560,		//// BytesPerScanLine
	1280,		//// XResol
	1024,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  16,		//// BitsPerPixel
	0x00,		//// Refresh Index
	   0,		//// ModeSetString
	},

    // 1280 x 1024 x 16 @ 60hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  60,		//// Frequency
	0x75,		//// Cirrus Logic Mode #
	2560,		//// BytesPerScanLine
	1280,		//// XResol
	1024,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  16,		//// BitsPerPixel
	0x10,		//// Refresh Index
	   0,		//// ModeSetString
	},

    // 1280 x 1024 x 16 @ 71hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  71,		//// Frequency
	0x75,		//// Cirrus Logic Mode #
	2560,		//// BytesPerScanLine
	1280,		//// XResol
	1024,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  16,		//// BitsPerPixel
	0x20,		//// Refresh Index
	   0,		//// ModeSetString
	},

    // 1280 x 1024 x 16 @ 75hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  75,		//// Frequency
	0x75,		//// Cirrus Logic Mode #
	2560,		//// BytesPerScanLine
	1280,		//// XResol
	1024,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  16,		//// BitsPerPixel
	0x30,		//// Refresh Index
	   0,		//// ModeSetString
	},

#if (! WHQL_5462_PANIC_HACK) 

    // 1280 x 1024 x 16 @ 85hz
	{
	   0,		//// Valid Mode
       LG_5462 | LG_5465,  //// The 5464 doesn't do this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  85,		//// Frequency
	0x75,		//// Cirrus Logic Mode #
	2560,		//// BytesPerScanLine
	1280,		//// XResol
	1024,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	  16,		//// BitsPerPixel
	0x40,		//// Refresh Index
	   0,		//// ModeSetString
	},
#endif

    // 1600 x 1280 x 8 @ 48ihz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_INTERLACED,
	  48,		//// Frequency
	0x7B,		//// Cirrus Logic Mode #
	1664,		//// BytesPerScanLine
	1600,		//// XResol
	1200,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x00,		//// Refresh Index
	   0,		//// ModeSetString
	},

    // 1600 x 1280 x 8 @ 60hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  60,		//// Frequency
	0x7B,		//// Cirrus Logic Mode #
	1664,		//// BytesPerScanLine
	1600,		//// XResol
	1200,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x01,		//// Refresh Index
	   0,		//// ModeSetString
	},

#if (! WHQL_5462_PANIC_HACK) 
    // 1600 x 1280 x 8 @ 65hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  65,		//// Frequency
	0x7B,		//// Cirrus Logic Mode #
	1664,		//// BytesPerScanLine
	1600,		//// XResol
	1200,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x02,		//// Refresh Index
	   0,		//// ModeSetString
	},

    // 1600 x 1280 x 8 @ 70hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  70,		//// Frequency
	0x7B,		//// Cirrus Logic Mode #
	1664,		//// BytesPerScanLine
	1600,		//// XResol
	1200,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x03,		//// Refresh Index
	   0,		//// ModeSetString
	},

    // 1600 x 1280 x 8 @ 75hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  75,		//// Frequency
	0x7B,		//// Cirrus Logic Mode #
	1664,		//// BytesPerScanLine
	1600,		//// XResol
	1200,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x04,		//// Refresh Index
	   0,		//// ModeSetString
	},
#endif
#if 0
    // 1600 x 1280 x 8 @ 80hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  80,		//// Frequency
	0x7B,		//// Cirrus Logic Mode #
	1664,		//// BytesPerScanLine
	1600,		//// XResol
	1200,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x05,		//// Refresh Index
	   0,		//// ModeSetString
	},

    // 1600 x 1280 x 8 @ 85hz
	{
	   0,		//// Valid Mode
       LG_ALL,  //// All laguna chips support this mode.
	   VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
	  85,		//// Frequency
	0x7B,		//// Cirrus Logic Mode #
	1664,		//// BytesPerScanLine
	1600,		//// XResol
	1200,		//// YResol
	   8,		//// XCharSize
	  16,		//// YCharSize
	   1,		//// NumofPlanes
	   8,		//// BitsPerPixel
	0x06,		//// Refresh Index
	   0,		//// ModeSetString
	},
#endif

#include "ModeStr.C" // Include ModeTable records for all the MODE.INI modes.

};
ULONG TotalVideoModes = sizeof(ModeTable)/sizeof(MODETABLE);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\cl546x\modestr.h ===
/******************************************************************************
*
*   Module:     ModeStr.H       NT Driver Mode Table Header File
*
*   Author:     Computer Generated (By CGLMode program version: 1.62.02)
*
*******************************************************************************
*
*   Module Description:
*
*       This module contains the mode tables used by the NT driver. This
*   header file is generated by the CGLMode program.
*
*******************************************************************************
*
*******************************************************************************
*   Include Files
******************************************************************************/
#include        "type.h"                /* Include type header file          */
#include        "modemon.h"             /* Include mode/monitor header file  */

BYTE t546x_Mode_640x480x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x3F, 0x00, 0x16, 0x88, 0x00, 0x6D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x9E, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE9, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE7, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_640x480x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE8, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE7, 0x00, 0x00, 0x00, 0xF3, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_640x480x8_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x9C, 0x00, 0x00, 0x00, 0xF2, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0xF2, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_640x480x8_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x33, 0x00, 0x16, 0x88, 0x00, 0x7E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0xFB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0xF9, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_640x480x8_1a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x3F, 0x00, 0x16, 0x88, 0x00, 0x6D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x9E, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE9, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE7, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_640x480x8_2a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE8, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE7, 0x00, 0x00, 0x00, 0xF3, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_640x480x8_3a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x9C, 0x00, 0x00, 0x00, 0xF2, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0xF2, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_640x480x8_4a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x33, 0x00, 0x16, 0x88, 0x00, 0x7E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0xFB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0xF9, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_320x200x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x42, 0x00, 0x16, 0x88, 0x00, 0x1D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t546x_Mode_320x240x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x42, 0x00, 0x16, 0x88, 0x00, 0x1D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t546x_Mode_320x240x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x14, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t546x_Mode_320x400x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x42, 0x00, 0x16, 0x88, 0x00, 0x1D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t546x_Mode_320x480x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x42, 0x00, 0x16, 0x88, 0x00, 0x1D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x24, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x91, 
				 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 0x00, 
				 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_320x480x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x14, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x24, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x91, 
				 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 0x00, 
				 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_360x400x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3C, 0x00, 0x16, 0x88, 0x00, 0x1E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
				 0x2C, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x94, 0x00, 0x00, 0x00, 0x2E, 0x00, 0x00, 0x00, 
				 0x92, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_360x400x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x32, 0x00, 0x16, 0x88, 0x00, 0x1F, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 
				 0x2C, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xBC, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xBC, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_400x300x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x45, 0x00, 0x16, 0x88, 0x00, 0x5F, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x00, 0x00, 
				 0x31, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_400x300x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x13, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x00, 0x00, 
				 0x31, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_512x384x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x1B, 0x00, 0x16, 0x88, 0x00, 0x3B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 
				 0x06, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xD0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_512x384x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x2A, 0x00, 0x16, 0x88, 0x00, 0x37, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4E, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 
				 0x06, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xD0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_512x480x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x35, 0x00, 0x16, 0x88, 0x00, 0x49, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 
				 0x08, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_512x480x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x29, 0x00, 0x16, 0x88, 0x00, 0x45, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4D, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 
				 0x09, 0x00, 0x00, 0x00, 0xF4, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0xF4, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_640x350x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xAF, 0x00, 0x16, 0x84, 0x00, 
				 0x33, 0x00, 0x16, 0x88, 0x00, 0x58, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5D, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_640x350x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xAF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5D, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_640x400x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x3F, 0x00, 0x16, 0x88, 0x00, 0x6D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xA1, 0x00, 0x00, 0x00, 
				 0xA3, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0xB9, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_640x400x8_1a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x3F, 0x00, 0x16, 0x88, 0x00, 0x6D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xA1, 0x00, 0x00, 0x00, 
				 0xA3, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0xB9, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_640x400x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x0B, 0x00, 0x16, 0x88, 0x00, 0x16, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t546x_Mode_640x400x8_2a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x0B, 0x00, 0x16, 0x88, 0x00, 0x16, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_640x400x8_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x0B, 0x00, 0x16, 0x88, 0x00, 0x16, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x84, 0x00, 
				 0x32, 0x00, 0x16, 0x88, 0x00, 0x61, 0x00, 0x13, 
				 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x91, 0x05, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 
				 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 
				 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 
				 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 
				 0x00, 0x00};

BYTE t546x_Mode_640x400x8_3a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x0B, 0x00, 0x16, 0x88, 0x00, 0x16, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x84, 0x00, 
				 0x32, 0x00, 0x16, 0x88, 0x00, 0x61, 0x00, 0x13, 
				 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 
				 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 
				 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 
				 0x04, 0x00, 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 
				 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_800x600x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3E, 0x00, 0x16, 0x88, 0x00, 0x4E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7B, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8A, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x02};

BYTE t546x_Mode_800x600x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3A, 0x00, 0x16, 0x88, 0x00, 0x51, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x02};

BYTE t546x_Mode_800x600x8_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3E, 0x00, 0x16, 0x88, 0x00, 0x6C, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9D, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7B, 0x00, 0x00, 0x00, 
				 0x81, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5F, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x02};

BYTE t546x_Mode_800x600x8_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x30, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x02};

BYTE t546x_Mode_800x600x8_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x1C, 0x00, 0x16, 0x88, 0x00, 0x37, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9E, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x02};

BYTE t546x_Mode_800x600x8_1a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3E, 0x00, 0x16, 0x88, 0x00, 0x4E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7B, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8A, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_800x600x8_2a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3A, 0x00, 0x16, 0x88, 0x00, 0x51, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_800x600x8_3a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3E, 0x00, 0x16, 0x88, 0x00, 0x6C, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9D, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7B, 0x00, 0x00, 0x00, 
				 0x81, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5F, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_800x600x8_4a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x30, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_800x600x8_5a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x1C, 0x00, 0x16, 0x88, 0x00, 0x37, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9E, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1024x768x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x2C, 0x00, 0x16, 0x88, 0x00, 0x45, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 
				 0x19, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x48, 0x00, 0x00, 
				 0x00, 0x51, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1024x768x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x1A, 0x00, 0x16, 0x88, 0x00, 0x3B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 
				 0x95, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1024x768x8_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x2A, 0x00, 0x16, 0x88, 0x00, 0x6E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA1, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x81, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 
				 0x95, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1024x768x8_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x10, 0x00, 0x16, 0x88, 0x00, 0x2C, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 
				 0x0F, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1024x768x8_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x21, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA7, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x87, 0x00, 0x00, 0x00, 0x87, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1024x768x8_1a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x2C, 0x00, 0x16, 0x88, 0x00, 0x45, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 
				 0x19, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x48, 0x00, 0x00, 
				 0x00, 0x51, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1024x768x8_2a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x1A, 0x00, 0x16, 0x88, 0x00, 0x3B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 
				 0x95, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1024x768x8_3a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x2A, 0x00, 0x16, 0x88, 0x00, 0x6E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA1, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x81, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 
				 0x95, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1024x768x8_4a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x10, 0x00, 0x16, 0x88, 0x00, 0x2C, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 
				 0x0F, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1024x768x8_5a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x21, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA7, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x87, 0x00, 0x00, 0x00, 0x87, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1152x864x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x21, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xB4, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x94, 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x8E, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5F, 0x00, 0x00, 0x00, 0x8E, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1152x864x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xC3, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0x07, 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5F, 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xF0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1152x864x8_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x04, 0x00, 0x16, 0x88, 0x00, 0x11, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0x07, 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5F, 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xF0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1280x960x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xDC, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x9C, 0x00, 0x00, 0x00, 0xAB, 0x00, 0x00, 0x00, 
				 0x19, 0x00, 0x00, 0x00, 0xE6, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xBF, 0x00, 0x00, 0x00, 0xE6, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xF0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1280x960x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x2C, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCD, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 
				 0x15, 0x00, 0x00, 0x00, 0xE6, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xBF, 0x00, 0x00, 0x00, 0xE6, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xF0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1280x960x8_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x10, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xD3, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0xA5, 0x00, 0x00, 0x00, 
				 0x19, 0x00, 0x00, 0x00, 0xF1, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xBF, 0x00, 0x00, 0x00, 0xF1, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xF0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1280x1024x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x04, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCF, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0xA9, 0x00, 0x00, 0x00, 
				 0x13, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 
				 0xB2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x67, 0x00, 0x00, 
				 0x00, 0x81, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1280x1024x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCE, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0xA7, 0x00, 0x00, 0x00, 
				 0x15, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1280x1024x8_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0C, 0x00, 0x16, 0x88, 0x00, 0x35, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCB, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0xA6, 0x00, 0x00, 0x00, 
				 0x1C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1280x1024x8_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0E, 0x00, 0x16, 0x88, 0x00, 0x42, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCE, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 
				 0x15, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0xF0, 0x00, 
				 0x1E, 0x01, 0x00, 0x10, 0x00, 0x00, 0x19, 0xF0, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0xD1, 0x05, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 
				 0x04, 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 
				 0x01, 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xC0, 0xFF, 0x00, 
				 0x00, 0x1E, 0x01, 0x16, 0x00, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x16, 0x02, 0x04, 
				 0x00, 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1280x1024x8_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x79, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xD3, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0xA7, 0x00, 0x00, 0x00, 
				 0x1B, 0x00, 0x00, 0x00, 0x2E, 0x00, 0x00, 0x00, 
				 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0xF0, 0x00, 
				 0x1E, 0x01, 0x00, 0x10, 0x00, 0x00, 0x19, 0xF0, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0xD1, 0x05, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 
				 0x04, 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 
				 0x01, 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xC0, 0xFF, 0x00, 
				 0x00, 0x1E, 0x01, 0x16, 0x00, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x16, 0x02, 0x04, 
				 0x00, 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1280x1024x8_1a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x04, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCF, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0xA9, 0x00, 0x00, 0x00, 
				 0x13, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 
				 0xB2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x67, 0x00, 0x00, 
				 0x00, 0x81, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1280x1024x8_2a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCE, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0xA7, 0x00, 0x00, 0x00, 
				 0x15, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1280x1024x8_3a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0C, 0x00, 0x16, 0x88, 0x00, 0x35, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCB, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0xA6, 0x00, 0x00, 0x00, 
				 0x1C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1280x1024x8_4a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0E, 0x00, 0x16, 0x88, 0x00, 0x42, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCE, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 
				 0x15, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0xF0, 0x00, 
				 0x1E, 0x01, 0x00, 0x10, 0x00, 0x00, 0x19, 0xF0, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0xD6, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 
				 0x04, 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 
				 0x01, 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 
				 0x16, 0x02, 0x04, 0x00, 0x08, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x17, 0x4C, 0x00, 0x40, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x00, 0x08};

BYTE t546x_Mode_1280x1024x8_5a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x79, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xD3, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0xA7, 0x00, 0x00, 0x00, 
				 0x1B, 0x00, 0x00, 0x00, 0x2E, 0x00, 0x00, 0x00, 
				 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0xF0, 0x00, 
				 0x1E, 0x01, 0x00, 0x10, 0x00, 0x00, 0x19, 0xF0, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0xD6, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 
				 0x04, 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 
				 0x01, 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 
				 0x16, 0x02, 0x04, 0x00, 0x08, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x17, 0x4C, 0x00, 0x40, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x00, 0x08};

BYTE t546x_Mode_1600x1200x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0F, 0x00, 0x16, 0x88, 0x00, 0x42, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0xC7, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0xCE, 0x00, 0x00, 0x00, 
				 0x06, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x85, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x84, 0x00, 0x00, 
				 0x00, 0x81, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1A, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x40, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1600x1200x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x14, 0x00, 0x16, 0x88, 0x00, 0x71, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0xC7, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0xD1, 0x00, 0x00, 0x00, 
				 0x09, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 
				 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xAF, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x8F, 0x00, 0x00, 0x00, 0x13, 0xF0, 0x00, 
				 0x1E, 0x01, 0x00, 0x10, 0x00, 0x00, 0x19, 0xF0, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x92, 0x0D, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 
				 0x04, 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 
				 0x01, 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xC0, 0xFF, 0x00, 
				 0x00, 0x1E, 0x01, 0x1A, 0x00, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x16, 0x02, 0x04, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_1600x1200x8_1a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0F, 0x00, 0x16, 0x88, 0x00, 0x42, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0xC7, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0xCE, 0x00, 0x00, 0x00, 
				 0x06, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x85, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x84, 0x00, 0x00, 
				 0x00, 0x81, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x9A, 0x1A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x1A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x13, 0xC0, 0x00, 0x1E, 
				 0x01, 0x00, 0x40, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x00, 0x00};

BYTE t546x_Mode_1600x1200x8_2a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x14, 0x00, 0x16, 0x88, 0x00, 0x71, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0xC7, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0xD1, 0x00, 0x00, 0x00, 
				 0x09, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 
				 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xAF, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x8F, 0x00, 0x00, 0x00, 0x13, 0xF0, 0x00, 
				 0x1E, 0x01, 0x00, 0x10, 0x00, 0x00, 0x19, 0xF0, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x9A, 0x1A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 
				 0x04, 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 
				 0x01, 0x1A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 
				 0x16, 0x02, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x00, 0x00};

BYTE t546x_Mode_320x200x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x42, 0x00, 0x16, 0x88, 0x00, 0x1D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x14, 0x00, 0x4C};

BYTE t546x_Mode_320x240x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x42, 0x00, 0x16, 0x88, 0x00, 0x1D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x14, 0x00, 0x4C};

BYTE t546x_Mode_320x240x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x14, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x14, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x80, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_320x400x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x42, 0x00, 0x16, 0x88, 0x00, 0x1D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_320x480x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x42, 0x00, 0x16, 0x88, 0x00, 0x1D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x24, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x91, 
				 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 0x00, 
				 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 0x20, 
				 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 
				 0x14, 0x00, 0x16};

BYTE t546x_Mode_320x480x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x14, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x24, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x91, 
				 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 0x00, 
				 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 0x20, 
				 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 
				 0x14, 0x00, 0x16};

BYTE t546x_Mode_360x400x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3C, 0x00, 0x16, 0x88, 0x00, 0x1E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
				 0x2C, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x94, 0x00, 0x00, 0x00, 0x2E, 0x00, 0x00, 0x00, 
				 0x92, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_360x400x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x32, 0x00, 0x16, 0x88, 0x00, 0x1F, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 
				 0x2C, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xBC, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xBC, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_400x300x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x45, 0x00, 0x16, 0x88, 0x00, 0x5F, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x00, 0x00, 
				 0x31, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_400x300x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x13, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x00, 0x00, 
				 0x31, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x80, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_512x384x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x1B, 0x00, 0x16, 0x88, 0x00, 0x3B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 
				 0x06, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xD0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x80, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_512x384x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x2A, 0x00, 0x16, 0x88, 0x00, 0x37, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4E, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 
				 0x06, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xD0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x80, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_512x480x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x35, 0x00, 0x16, 0x88, 0x00, 0x49, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 
				 0x08, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x80, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_512x480x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x29, 0x00, 0x16, 0x88, 0x00, 0x45, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4D, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 
				 0x09, 0x00, 0x00, 0x00, 0xF4, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0xF4, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x80, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_640x350x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xAF, 0x00, 0x16, 0x84, 0x00, 
				 0x33, 0x00, 0x16, 0x88, 0x00, 0x58, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5D, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_640x350x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xAF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5D, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_640x400x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x3F, 0x00, 0x16, 0x88, 0x00, 0x6D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xA1, 0x00, 0x00, 0x00, 
				 0xA3, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0xB9, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_640x480x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x3F, 0x00, 0x16, 0x88, 0x00, 0x6D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x9E, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE9, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE7, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_640x480x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE8, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE7, 0x00, 0x00, 0x00, 0xF3, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_640x480x16_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x9C, 0x00, 0x00, 0x00, 0xF2, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0xF2, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_640x480x16_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x33, 0x00, 0x16, 0x88, 0x00, 0x7E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0xFB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0xF9, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_800x600x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3E, 0x00, 0x16, 0x88, 0x00, 0x4E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7B, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8A, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xD0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_800x600x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3A, 0x00, 0x16, 0x88, 0x00, 0x51, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xD0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_800x600x16_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3E, 0x00, 0x16, 0x88, 0x00, 0x6C, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9D, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7B, 0x00, 0x00, 0x00, 
				 0x81, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5F, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xD0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_800x600x16_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x30, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xD0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_800x600x16_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x1C, 0x00, 0x16, 0x88, 0x00, 0x37, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9E, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xD0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_1024x768x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x2C, 0x00, 0x16, 0x88, 0x00, 0x45, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 
				 0x19, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x48, 0x00, 0x00, 
				 0x00, 0x51, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x28, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_1024x768x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x1A, 0x00, 0x16, 0x88, 0x00, 0x3B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 
				 0x95, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x28, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_1024x768x16_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x2A, 0x00, 0x16, 0x88, 0x00, 0x6E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA1, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x81, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 
				 0x95, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x28, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_1024x768x16_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x10, 0x00, 0x16, 0x88, 0x00, 0x2C, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 
				 0x0F, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x28, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_1024x768x16_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x21, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA7, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x87, 0x00, 0x00, 0x00, 0x87, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x28, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_1152x864x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x21, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xB4, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x94, 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x8E, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5F, 0x00, 0x00, 0x00, 0x8E, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 
				 0x14, 0x00, 0x16};

BYTE t546x_Mode_1152x864x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xC3, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0x07, 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5F, 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xF0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 
				 0x14, 0x00, 0x16};

BYTE t546x_Mode_1152x864x16_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x04, 0x00, 0x16, 0x88, 0x00, 0x11, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0x07, 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5F, 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xF0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 
				 0x14, 0x00, 0x16};

BYTE t546x_Mode_1280x960x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xDC, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x9C, 0x00, 0x00, 0x00, 0xAB, 0x00, 0x00, 0x00, 
				 0x19, 0x00, 0x00, 0x00, 0xE6, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xBF, 0x00, 0x00, 0x00, 0xE6, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xF0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 
				 0x14, 0x00, 0x16};

BYTE t546x_Mode_1280x960x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x2C, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCD, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 
				 0x15, 0x00, 0x00, 0x00, 0xE6, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xBF, 0x00, 0x00, 0x00, 0xE6, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xF0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 
				 0x14, 0x00, 0x16};

BYTE t546x_Mode_1280x960x16_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x10, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xD3, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0xA5, 0x00, 0x00, 0x00, 
				 0x19, 0x00, 0x00, 0x00, 0xF1, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xBF, 0x00, 0x00, 0x00, 0xF1, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xF0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x29, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x40, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_1280x1024x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x04, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCF, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0xA9, 0x00, 0x00, 0x00, 
				 0x13, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 
				 0xB2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x67, 0x00, 0x00, 
				 0x00, 0x81, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 
				 0x14, 0x00, 0x16};

BYTE t546x_Mode_1280x1024x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCE, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0xA7, 0x00, 0x00, 0x00, 
				 0x15, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 
				 0x14, 0x00, 0x16};

BYTE t546x_Mode_1280x1024x16_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0C, 0x00, 0x16, 0x88, 0x00, 0x35, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCB, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0xA6, 0x00, 0x00, 0x00, 
				 0x1C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 
				 0x14, 0x00, 0x16};

BYTE t546x_Mode_1280x1024x16_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0E, 0x00, 0x16, 0x88, 0x00, 0x42, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCE, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 
				 0x15, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0xF0, 0x00, 
				 0x1E, 0x01, 0x00, 0x10, 0x00, 0x00, 0x19, 0xF0, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0xA2, 0x14, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 
				 0x04, 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 
				 0x01, 0x14, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 
				 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 0x00, 
				 0x00, 0x16, 0x17, 0x4C, 0x00, 0x40, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t546x_Mode_640x400x24_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x3F, 0x00, 0x16, 0x88, 0x00, 0x6D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xA1, 0x00, 0x00, 0x00, 
				 0xA3, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0xB9, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x0D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0xC0};

BYTE t546x_Mode_640x400x24_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x0B, 0x00, 0x16, 0x88, 0x00, 0x16, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x0D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0xC0};

BYTE t546x_Mode_640x400x24_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x0B, 0x00, 0x16, 0x88, 0x00, 0x16, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x84, 0x00, 
				 0x32, 0x00, 0x16, 0x88, 0x00, 0x61, 0x00, 0x13, 
				 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 
				 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 
				 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 
				 0x01, 0x1E, 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 
				 0x16, 0xC0, 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t546x_Mode_640x480x24_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x3F, 0x00, 0x16, 0x88, 0x00, 0x6D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x9E, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE9, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE7, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x0D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t546x_Mode_640x480x24_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE8, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE7, 0x00, 0x00, 0x00, 0xF3, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x0D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t546x_Mode_640x480x24_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x9C, 0x00, 0x00, 0x00, 0xF2, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0xF2, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x0D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t546x_Mode_640x480x24_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x33, 0x00, 0x16, 0x88, 0x00, 0x7E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0xFB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0xF9, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x0D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t546x_Mode_800x600x24_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3E, 0x00, 0x16, 0x88, 0x00, 0x4E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7B, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8A, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0x40, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t546x_Mode_800x600x24_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3A, 0x00, 0x16, 0x88, 0x00, 0x51, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0x40, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t546x_Mode_800x600x24_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3E, 0x00, 0x16, 0x88, 0x00, 0x6C, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9D, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7B, 0x00, 0x00, 0x00, 
				 0x81, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5F, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0x40, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t546x_Mode_800x600x24_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x30, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0x40, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t546x_Mode_800x600x24_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x1C, 0x00, 0x16, 0x88, 0x00, 0x37, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9E, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0x40, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t546x_Mode_1024x768x24_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x2C, 0x00, 0x16, 0x88, 0x00, 0x45, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 
				 0x19, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x48, 0x00, 0x00, 
				 0x00, 0x51, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD9, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t546x_Mode_1024x768x24_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x1A, 0x00, 0x16, 0x88, 0x00, 0x3B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 
				 0x95, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD9, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t546x_Mode_1024x768x24_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x2A, 0x00, 0x16, 0x88, 0x00, 0x6E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA1, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x81, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 
				 0x95, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD9, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t546x_Mode_1024x768x24_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x10, 0x00, 0x16, 0x88, 0x00, 0x2C, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 
				 0x0F, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD9, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t546x_Mode_1024x768x24_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x21, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA7, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x87, 0x00, 0x00, 0x00, 0x87, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD9, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1E, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t546x_Mode_Reset[] =
				{0x14, 0xFC, 0x03, 0x1E, 0x00, 0xFF, 0xFF, 0xFF, 
				 0xEF, 0x1A, 0xFC, 0x03, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x08, 
				 0x1F, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_1600x1200x8_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x10, 0x00, 0x16, 0x88, 0x00, 0x31, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0xC7, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 
				 0x08, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 
				 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xAF, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x8F, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1A, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x40, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x00, 0x00};

BYTE t5464_Mode_1600x1200x8_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x21, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0xC7, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 
				 0x08, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 
				 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xAF, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x8F, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1A, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x40, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x00, 0x00};

BYTE t5464_Mode_1600x1200x8_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x1C, 0x00, 0x16, 0x88, 0x00, 0x63, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0xC7, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 
				 0x08, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 
				 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xAF, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x8F, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1A, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x40, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x00, 0x00};

BYTE t5464_Mode_1600x1200x8_6[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0xC7, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 
				 0x08, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 
				 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xAF, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x8F, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1A, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x40, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x00, 0x00};

BYTE t5464_Mode_1600x1200x8_7[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x04, 0x00, 0x16, 0x88, 0x00, 0x10, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0xC7, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 
				 0x08, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 
				 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xAF, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x8F, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1A, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x40, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x00, 0x00};

BYTE t5464_Mode_1600x1200x8_3a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x10, 0x00, 0x16, 0x88, 0x00, 0x31, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0xC7, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 
				 0x08, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 
				 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xAF, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x8F, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x9A, 0x1A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x1A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x13, 0xC0, 0x00, 0x1E, 
				 0x01, 0x00, 0x40, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x00, 0x40};

BYTE t5464_Mode_1600x1200x8_4a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x21, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0xC7, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 
				 0x08, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 
				 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xAF, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x8F, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x9A, 0x1A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x1A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x13, 0xC0, 0x00, 0x1E, 
				 0x01, 0x00, 0x40, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x00, 0x40};

BYTE t5464_Mode_1600x1200x8_5a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x1C, 0x00, 0x16, 0x88, 0x00, 0x63, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0xC7, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 
				 0x08, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 
				 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xAF, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x8F, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x9A, 0x1A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x1A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x13, 0xC0, 0x00, 0x1E, 
				 0x01, 0x00, 0x40, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x00, 0x40};

BYTE t5464_Mode_1600x1200x8_6a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0xC7, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 
				 0x08, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 
				 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xAF, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x8F, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x9A, 0x1A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x1A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x13, 0xC0, 0x00, 0x1E, 
				 0x01, 0x00, 0x40, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x00, 0x40};

BYTE t5464_Mode_1600x1200x8_7a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x04, 0x00, 0x16, 0x88, 0x00, 0x10, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0xC7, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 
				 0x08, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 
				 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xAF, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x8F, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x9A, 0x1A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x1A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x13, 0xC0, 0x00, 0x1E, 
				 0x01, 0x00, 0x40, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x00, 0x40};

BYTE t5464_Mode_320x200x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x42, 0x00, 0x16, 0x88, 0x00, 0x1D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x6C};

BYTE t5464_Mode_320x240x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x42, 0x00, 0x16, 0x88, 0x00, 0x1D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x6C};

BYTE t5464_Mode_320x240x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x14, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x14, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x80, 0x00, 
				 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_320x400x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x42, 0x00, 0x16, 0x88, 0x00, 0x1D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_320x480x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x42, 0x00, 0x16, 0x88, 0x00, 0x1D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x24, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x91, 
				 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 0x00, 
				 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 0x20, 
				 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x20};

BYTE t5464_Mode_320x480x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x14, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x24, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x91, 
				 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 0x00, 
				 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 0x20, 
				 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x20};

BYTE t5464_Mode_360x400x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3C, 0x00, 0x16, 0x88, 0x00, 0x1E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
				 0x2C, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x94, 0x00, 0x00, 0x00, 0x2E, 0x00, 0x00, 0x00, 
				 0x92, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_360x400x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x32, 0x00, 0x16, 0x88, 0x00, 0x1F, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 
				 0x2C, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xBC, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xBC, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_400x300x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x45, 0x00, 0x16, 0x88, 0x00, 0x5F, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x00, 0x00, 
				 0x31, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_400x300x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x13, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x00, 0x00, 
				 0x31, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x80, 0x00, 
				 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_512x384x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x1B, 0x00, 0x16, 0x88, 0x00, 0x3B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 
				 0x06, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xD0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x80, 0x00, 
				 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_512x384x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x2A, 0x00, 0x16, 0x88, 0x00, 0x37, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4E, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 
				 0x06, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xD0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x80, 0x00, 
				 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_512x480x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x35, 0x00, 0x16, 0x88, 0x00, 0x49, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 
				 0x08, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x80, 0x00, 
				 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_512x480x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x29, 0x00, 0x16, 0x88, 0x00, 0x45, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4D, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 
				 0x09, 0x00, 0x00, 0x00, 0xF4, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0xF4, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x80, 0x00, 
				 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_640x350x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xAF, 0x00, 0x16, 0x84, 0x00, 
				 0x33, 0x00, 0x16, 0x88, 0x00, 0x58, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5D, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_640x350x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xAF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5D, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_640x400x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x3F, 0x00, 0x16, 0x88, 0x00, 0x6D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xA1, 0x00, 0x00, 0x00, 
				 0xA3, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0xB9, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_640x400x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x0B, 0x00, 0x16, 0x88, 0x00, 0x16, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_640x400x15_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x0B, 0x00, 0x16, 0x88, 0x00, 0x16, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x84, 0x00, 
				 0x32, 0x00, 0x16, 0x88, 0x00, 0x61, 0x00, 0x13, 
				 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 
				 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 
				 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 
				 0x01, 0x12, 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 
				 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x6C};

BYTE t5464_Mode_640x480x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x3F, 0x00, 0x16, 0x88, 0x00, 0x6D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x9E, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE9, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE7, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_640x480x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE8, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE7, 0x00, 0x00, 0x00, 0xF3, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_640x480x15_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x9C, 0x00, 0x00, 0x00, 0xF2, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0xF2, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_640x480x15_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x33, 0x00, 0x16, 0x88, 0x00, 0x7E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0xFB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0xF9, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_800x600x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3E, 0x00, 0x16, 0x88, 0x00, 0x4E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7B, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8A, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xD0, 0x00, 
				 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_800x600x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3A, 0x00, 0x16, 0x88, 0x00, 0x51, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xD0, 0x00, 
				 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_800x600x15_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3E, 0x00, 0x16, 0x88, 0x00, 0x6C, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9D, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7B, 0x00, 0x00, 0x00, 
				 0x81, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5F, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xD0, 0x00, 
				 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_800x600x15_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x30, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xD0, 0x00, 
				 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_800x600x15_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x1C, 0x00, 0x16, 0x88, 0x00, 0x37, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9E, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xD0, 0x00, 
				 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_1024x768x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x2C, 0x00, 0x16, 0x88, 0x00, 0x45, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 
				 0x19, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x48, 0x00, 0x00, 
				 0x00, 0x51, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x28, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_1024x768x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x1A, 0x00, 0x16, 0x88, 0x00, 0x3B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 
				 0x95, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x28, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_1024x768x15_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x2A, 0x00, 0x16, 0x88, 0x00, 0x6E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA1, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x81, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 
				 0x95, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x28, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_1024x768x15_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x10, 0x00, 0x16, 0x88, 0x00, 0x2C, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 
				 0x0F, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x28, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_1024x768x15_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x21, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA7, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x87, 0x00, 0x00, 0x00, 0x87, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x28, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_1152x864x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x21, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xB4, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x94, 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x8E, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5F, 0x00, 0x00, 0x00, 0x8E, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x28};

BYTE t5464_Mode_1152x864x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xC3, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0x07, 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5F, 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xF0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x28};

BYTE t5464_Mode_1152x864x15_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x04, 0x00, 0x16, 0x88, 0x00, 0x11, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0x07, 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5F, 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xF0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x28};

BYTE t5464_Mode_1280x960x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xDC, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x9C, 0x00, 0x00, 0x00, 0xAB, 0x00, 0x00, 0x00, 
				 0x19, 0x00, 0x00, 0x00, 0xE6, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xBF, 0x00, 0x00, 0x00, 0xE6, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xF0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x28};

BYTE t5464_Mode_1280x960x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x2C, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCD, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 
				 0x15, 0x00, 0x00, 0x00, 0xE6, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xBF, 0x00, 0x00, 0x00, 0xE6, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xF0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x28};

BYTE t5464_Mode_1280x960x15_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x10, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xD3, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0xA5, 0x00, 0x00, 0x00, 
				 0x19, 0x00, 0x00, 0x00, 0xF1, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xBF, 0x00, 0x00, 0x00, 0xF1, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xF0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x29, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x40, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_1280x1024x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x04, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCF, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0xA9, 0x00, 0x00, 0x00, 
				 0x13, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 
				 0xB2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x67, 0x00, 0x00, 
				 0x00, 0x81, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x20};

BYTE t5464_Mode_1280x1024x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCE, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0xA7, 0x00, 0x00, 0x00, 
				 0x15, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x20};

BYTE t5464_Mode_1280x1024x15_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0C, 0x00, 0x16, 0x88, 0x00, 0x35, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCB, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0xA6, 0x00, 0x00, 0x00, 
				 0x1C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x20};

BYTE t5464_Mode_1280x1024x15_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0E, 0x00, 0x16, 0x88, 0x00, 0x42, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCE, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 
				 0x15, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0xF0, 0x00, 
				 0x1E, 0x01, 0x00, 0x10, 0x00, 0x00, 0x19, 0xF0, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0xA2, 0x14, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 
				 0x04, 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 
				 0x01, 0x14, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 
				 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 0x00, 
				 0x00, 0x16, 0x17, 0x4C, 0x00, 0x40, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x00, 0x00};

BYTE t5464_Mode_1600x1200x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0F, 0x00, 0x16, 0x88, 0x00, 0x42, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0xC7, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0xCE, 0x00, 0x00, 0x00, 
				 0x06, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x85, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x84, 0x00, 0x00, 
				 0x00, 0x81, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x9A, 0x1A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x1A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1E, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x16, 0x84, 0x00, 0x0E, 0x00, 0x00, 0x32};

BYTE t5464_Mode_1600x1200x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0F, 0x00, 0x16, 0x88, 0x00, 0x42, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0xC7, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0xCE, 0x00, 0x00, 0x00, 
				 0x06, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x85, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x84, 0x00, 0x00, 
				 0x00, 0x81, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x9A, 0x1A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x1A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1E, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x16, 0x84, 0x00, 0x0E, 0x00, 0x16, 0xC0, 
				 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t5464_Mode_320x200x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x42, 0x00, 0x16, 0x88, 0x00, 0x1D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x60, 0x16, 0xC0, 
				 0x00, 0x00, 0x34, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x00, 0x6C};

BYTE t5464_Mode_320x240x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x42, 0x00, 0x16, 0x88, 0x00, 0x1D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x60, 0x16, 0xC0, 
				 0x00, 0x00, 0x34, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x00, 0x6C};

BYTE t5464_Mode_320x240x32_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x14, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x60, 0x16, 0xC0, 
				 0x00, 0x00, 0x34, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x00, 0x6C};

BYTE t5464_Mode_320x400x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x42, 0x00, 0x16, 0x88, 0x00, 0x1D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x60, 0x16, 0xC0, 
				 0x00, 0x00, 0x34, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x00, 0x6C};

BYTE t5464_Mode_320x480x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x42, 0x00, 0x16, 0x88, 0x00, 0x1D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x24, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x91, 
				 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 0x00, 
				 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 0x00, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x16, 0x02, 0x04, 0x00, 0x60, 0x16, 0xC0, 0x00, 
				 0x00, 0x34, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x00, 0x84};

BYTE t5464_Mode_320x480x32_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x14, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x24, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x91, 
				 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 0x00, 
				 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 0x00, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x16, 0x02, 0x04, 0x00, 0x60, 0x16, 0xC0, 0x00, 
				 0x00, 0x34, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x00, 0x84};

BYTE t5464_Mode_360x400x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3C, 0x00, 0x16, 0x88, 0x00, 0x1E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
				 0x2C, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x94, 0x00, 0x00, 0x00, 0x2E, 0x00, 0x00, 0x00, 
				 0x92, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x15, 0x10, 0x00, 0x2F, 0x00, 0x12, 0x44, 
				 0x00, 0x1E, 0x01, 0x80, 0x00, 0x00, 0x00, 0x18, 
				 0x44, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x92, 0x0D, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 
				 0x07, 0x04, 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x1E, 0x01, 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 
				 0x04, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xC0, 0xFF, 
				 0x00, 0x00, 0x1E, 0x01, 0x1A, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x16, 0x02, 
				 0x04, 0x00, 0x60, 0x16, 0xC0, 0x00, 0x00, 0x34, 
				 0x17, 0x4C, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_360x400x32_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x32, 0x00, 0x16, 0x88, 0x00, 0x1F, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 
				 0x2C, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xBC, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xBC, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1A, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x60, 0x16, 0xC0, 
				 0x00, 0x00, 0x34, 0x17, 0x4C, 0x00, 0xD0, 0x00, 
				 0x00, 0x00, 0x00, 0x01};

BYTE t5464_Mode_400x300x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x45, 0x00, 0x16, 0x88, 0x00, 0x5F, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x00, 0x00, 
				 0x31, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x60, 0x16, 0xC0, 
				 0x00, 0x00, 0x34, 0x17, 0x4C, 0x00, 0xD0, 0x00, 
				 0x00, 0x00, 0x00, 0x01};

BYTE t5464_Mode_400x300x32_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x13, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x00, 0x00, 
				 0x31, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x60, 0x16, 0xC0, 
				 0x00, 0x00, 0x34, 0x17, 0x4C, 0x00, 0xD0, 0x00, 
				 0x00, 0x00, 0x00, 0x01};

BYTE t5464_Mode_512x384x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x1B, 0x00, 0x16, 0x88, 0x00, 0x3B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 
				 0x06, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xD0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x93, 0x10, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x10, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x60, 0x16, 0xC0, 0x00, 0x00, 0x34, 0x17, 0x4C, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x60};

BYTE t5464_Mode_512x384x32_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x2A, 0x00, 0x16, 0x88, 0x00, 0x37, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4E, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 
				 0x06, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xD0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x93, 0x10, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x10, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x60, 0x16, 0xC0, 0x00, 0x00, 0x34, 0x17, 0x4C, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x60};

BYTE t5464_Mode_512x480x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x35, 0x00, 0x16, 0x88, 0x00, 0x49, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 
				 0x08, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x0D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x16, 0xC0, 
				 0x00, 0x00, 0x34, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_512x480x32_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x29, 0x00, 0x16, 0x88, 0x00, 0x45, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4D, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 
				 0x09, 0x00, 0x00, 0x00, 0xF4, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0xF4, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x0E, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x16, 0xC0, 
				 0x00, 0x00, 0x34, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_640x350x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xAF, 0x00, 0x16, 0x84, 0x00, 
				 0x33, 0x00, 0x16, 0x88, 0x00, 0x58, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5D, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x0E, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x16, 0xC0, 
				 0x00, 0x00, 0x34, 0x17, 0x4C, 0x00, 0x40, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_640x350x32_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xAF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5D, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x0E, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x16, 0xC0, 
				 0x00, 0x00, 0x34, 0x17, 0x4C, 0x00, 0x40, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_640x400x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x3F, 0x00, 0x16, 0x88, 0x00, 0x6D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xA1, 0x00, 0x00, 0x00, 
				 0xA3, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0xB9, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x16, 0xC0, 
				 0x00, 0x00, 0x34, 0x17, 0x4C, 0x00, 0x40, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_640x400x32_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x0B, 0x00, 0x16, 0x88, 0x00, 0x16, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x16, 0xC0, 
				 0x00, 0x00, 0x34, 0x17, 0x4C, 0x00, 0x40, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_640x480x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x3F, 0x00, 0x16, 0x88, 0x00, 0x6D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x9E, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE9, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE7, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x16, 0xC0, 
				 0x00, 0x00, 0x34, 0x17, 0x4C, 0x00, 0x40, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_640x480x32_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE8, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE7, 0x00, 0x00, 0x00, 0xF3, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x16, 0xC0, 
				 0x00, 0x00, 0x34, 0x17, 0x4C, 0x00, 0x40, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_640x480x32_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x9C, 0x00, 0x00, 0x00, 0xF2, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0xF2, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x16, 0xC0, 
				 0x00, 0x00, 0x34, 0x17, 0x4C, 0x00, 0x40, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_640x480x32_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x33, 0x00, 0x16, 0x88, 0x00, 0x7E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0xFB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0xF9, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x16, 0xC0, 
				 0x00, 0x00, 0x34, 0x17, 0x4C, 0x00, 0x40, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_800x600x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3E, 0x00, 0x16, 0x88, 0x00, 0x4E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7B, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8A, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD9, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x16, 0xC0, 
				 0x00, 0x00, 0x34, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_800x600x32_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3A, 0x00, 0x16, 0x88, 0x00, 0x51, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD9, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x16, 0xC0, 
				 0x00, 0x00, 0x34, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_800x600x32_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3E, 0x00, 0x16, 0x88, 0x00, 0x6C, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9D, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7B, 0x00, 0x00, 0x00, 
				 0x81, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5F, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD9, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x16, 0xC0, 
				 0x00, 0x00, 0x34, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_800x600x32_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x30, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD9, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x16, 0xC0, 
				 0x00, 0x00, 0x34, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_800x600x32_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x1C, 0x00, 0x16, 0x88, 0x00, 0x37, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9E, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD9, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x16, 0xC0, 
				 0x00, 0x00, 0x34, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_1024x768x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x2C, 0x00, 0x16, 0x88, 0x00, 0x45, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 
				 0x19, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x48, 0x00, 0x00, 
				 0x00, 0x51, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xDE, 0x10, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x10, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x68, 0x16, 0xC0, 0x00, 0x00, 0x34, 0x17, 0x4C, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x74, 0x00, 