ter::NonDelegatingQueryInterface(riid, ppv);
    }

} // NonDelegatingQueryInterface


// -------------------------------------------------------------------------
// ISpecifyPropertyPages
// -------------------------------------------------------------------------

//
// GetPages
//
// Returns the clsid's of the property pages we support
STDMETHODIMP TVAudio::GetPages(CAUUID *pPages) {

    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }
    *(pPages->pElems) = CLSID_TVAudioFilterPropertyPage;

    return NOERROR;
}


// -------------------------------------------------------------------------
// IAMTVAudio 
// -------------------------------------------------------------------------

STDMETHODIMP
TVAudio::GetHardwareSupportedTVAudioModes( 
            /* [out] */ long __RPC_FAR *plModes)
{
    MyValidateWritePtr (plModes, sizeof(long), E_POINTER);
    
    if (!m_hDevice)
        return E_INVALIDARG;

    *plModes = m_Caps.Capabilities;

    return NOERROR;
}

STDMETHODIMP
TVAudio::GetAvailableTVAudioModes( 
            /* [out] */ long __RPC_FAR *plModes)
{
    KSPROPERTY_TVAUDIO_S Mode;
    BOOL        fOK;
    ULONG       cbReturned;
    
    MyValidateWritePtr (plModes, sizeof(long), E_POINTER);
    
    if (!m_hDevice)
        return E_INVALIDARG;

    Mode.Property.Set   = PROPSETID_VIDCAP_TVAUDIO;
    Mode.Property.Id    = KSPROPERTY_TVAUDIO_CURRENTLY_AVAILABLE_MODES;
    Mode.Property.Flags = KSPROPERTY_TYPE_GET;

    fOK = KsControl(m_hDevice, 
                (DWORD) IOCTL_KS_PROPERTY,
	            &Mode,
	            sizeof(Mode),
	            &Mode,
	            sizeof(Mode),
	            &cbReturned,
	            TRUE);

    if (fOK) {
        *plModes = Mode.Mode;
        return NOERROR;
    }
    else {
        return E_INVALIDARG;
    }
}
        
STDMETHODIMP
TVAudio::get_TVAudioMode( 
            /* [out] */ long __RPC_FAR *plMode)
{
    ULONG       cbReturned;
    BOOL        fOK;
    KSPROPERTY_TVAUDIO_S Mode;

    MyValidateWritePtr (plMode, sizeof(long), E_POINTER);

    if (!m_hDevice)
        return E_INVALIDARG;

    Mode.Property.Set   = PROPSETID_VIDCAP_TVAUDIO;
    Mode.Property.Id    = KSPROPERTY_TVAUDIO_MODE;
    Mode.Property.Flags = KSPROPERTY_TYPE_GET;

    fOK = KsControl(m_hDevice, 
                (DWORD) IOCTL_KS_PROPERTY,
	            &Mode,
	            sizeof(Mode),
	            &Mode,
	            sizeof(Mode),
	            &cbReturned,
	            TRUE);

    if (fOK) {
        *plMode = Mode.Mode;
        return NOERROR;
    }
    else {
        return E_INVALIDARG;
    }
}
        
STDMETHODIMP
TVAudio::put_TVAudioMode( 
            /* [in] */ long lMode)
{
    ULONG       cbReturned;
    BOOL        fOK;
    KSPROPERTY_TVAUDIO_S Mode;

    if (!m_hDevice)
        return E_INVALIDARG;

    Mode.Property.Set   = PROPSETID_VIDCAP_TVAUDIO;
    Mode.Property.Id    = KSPROPERTY_TVAUDIO_MODE;
    Mode.Property.Flags = KSPROPERTY_TYPE_SET;
    Mode.Mode           = lMode;

    fOK = KsControl(m_hDevice, 
                (DWORD) IOCTL_KS_PROPERTY,
	            &Mode,
	            sizeof(Mode),
	            &Mode,
	            sizeof(Mode),
	            &cbReturned,
	            TRUE);

    if (fOK) {
        SetDirty(TRUE);
        return NOERROR;
    }
    else {
        return E_INVALIDARG;
    }
}
        
STDMETHODIMP
TVAudio::RegisterNotificationCallBack( 
            /* [in] */ IAMTunerNotification __RPC_FAR *pNotify,
            /* [in] */ long lEvents)
{
    return E_NOTIMPL;
}
        
STDMETHODIMP
TVAudio::UnRegisterNotificationCallBack( 
            IAMTunerNotification __RPC_FAR *pNotify)
{
    return E_NOTIMPL;
}


int TVAudio::CreateDevice()
{
    HANDLE hDevice ;

    hDevice = CreateFile( m_pDeviceName,
		     GENERIC_READ | GENERIC_WRITE,
		     0,
		     NULL,
		     OPEN_EXISTING,
		     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
		     NULL ) ;

    if (hDevice == (HANDLE) -1) {
        DbgLog((LOG_TRACE, 0, TEXT("TVAUDIO::CreateDevice ERROR, unable to create device")));
	    return 0 ;
    } else {
	    m_hDevice = hDevice;
	    return 1;
    }
}

//
// GetPin
//
CBasePin *TVAudio::GetPin(int n) 
{
    if (n == 0) return m_pTVAudioInputPin;
    else return m_pTVAudioOutputPin;
}

//
// GetPinCount
//
int TVAudio::GetPinCount(void)
{
    return (m_hDevice ? 2 : 0);
}



//
// CreateInputPins
//
BOOL TVAudio::CreatePins()
{
    HRESULT hr = S_OK;

    m_pTVAudioInputPin = new TVAudioInputPin(NAME("TVAudio Input"), this,
					    &hr, L"TVAudio In");

    if (FAILED(hr) || m_pTVAudioInputPin == NULL) {
        return FALSE;
    }

    m_pTVAudioOutputPin = new TVAudioOutputPin(NAME("TVAudio Output"), this,
					    &hr, L"TVAudio Out");

    if (FAILED(hr) || m_pTVAudioOutputPin == NULL) {
        return FALSE;
    }

    ULONG       cbReturned;
    BOOL        fOK;

    m_Caps.Property.Set   = PROPSETID_VIDCAP_TVAUDIO;
    m_Caps.Property.Id    = KSPROPERTY_TVAUDIO_CAPS;
    m_Caps.Property.Flags = KSPROPERTY_TYPE_GET;

    fOK = KsControl(m_hDevice, 
                (DWORD) IOCTL_KS_PROPERTY,
	            &m_Caps,
	            sizeof(m_Caps),
	            &m_Caps,
	            sizeof(m_Caps),
	            &cbReturned,
	            TRUE);

    if (fOK) {
        m_pTVAudioInputPin->SetPinMedium (&m_Caps.InputMedium);
        m_pTVAudioOutputPin->SetPinMedium (&m_Caps.OutputMedium);
    }
    
    return TRUE;

} // CreatePins



//
// IPersistPropertyBag interface implementation for AMPnP support
//
STDMETHODIMP TVAudio::InitNew(void)
{
    return S_OK ;
}

STDMETHODIMP TVAudio::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    CAutoLock Lock(m_pLock) ;

    VARIANT var;
    VariantInit(&var);
    V_VT(&var) = VT_BSTR;

    // ::Load can succeed only once
    ASSERT(m_pPersistStreamDevice == 0); 

    HRESULT hr = pPropBag->Read(L"DevicePath", &var,0);
    if(SUCCEEDED(hr))
    {
        ULONG DeviceNameSize;

        if (m_pDeviceName) delete [] m_pDeviceName;	
        m_pDeviceName = new TCHAR [DeviceNameSize = (wcslen (V_BSTR(&var)) + 1)];
        if (!m_pDeviceName)
            return E_OUTOFMEMORY;

#ifndef _UNICODE
        WideCharToMultiByte(CP_ACP, 0, V_BSTR(&var), -1,
                            m_pDeviceName, DeviceNameSize, 0, 0);
#else
        lstrcpy(m_pDeviceName, V_BSTR(&var));
#endif
        VariantClear(&var);
        DbgLog((LOG_TRACE,2,TEXT("TVAudio::Load: use %s"), m_pDeviceName));

        if (CreateDevice() &&  CreatePins()) {
            hr = S_OK;
        }
        else {
            hr = E_FAIL ;
        }

        // save moniker with addref. ignore error if qi fails
        pPropBag->QueryInterface(IID_IPersistStream, (void **)&m_pPersistStreamDevice);

    }
    return hr;
}

STDMETHODIMP TVAudio::Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, 
                            BOOL fSaveAllProperties)
{
    return E_NOTIMPL ;
}

STDMETHODIMP TVAudio::GetClassID(CLSID *pClsid)
{
    return CBaseFilter::GetClassID(pClsid);
}

// -------------------------------------------------------------------------
// IPersistStream interface implementation for saving to a graph file
// -------------------------------------------------------------------------

#define CURRENT_PERSIST_VERSION 1

DWORD
TVAudio::GetSoftwareVersion(
    void
    )
/*++

Routine Description:

    Implement the CPersistStream::GetSoftwareVersion method. Returns
    the new version number rather than the default of zero.

Arguments:

    None.

Return Value:

    Return CURRENT_PERSIST_VERSION.

--*/
{
    return CURRENT_PERSIST_VERSION;
}

HRESULT TVAudio::WriteToStream(IStream *pStream)
{

    HRESULT hr = E_FAIL;

    if (m_pPersistStreamDevice) {

        hr = m_pPersistStreamDevice->Save(pStream, TRUE);
        if(SUCCEEDED(hr)) {
            long lMode;

            hr = get_TVAudioMode(&lMode);
            if (SUCCEEDED(hr)) {
                // Save the filter state
                hr =  pStream->Write(&lMode, sizeof(lMode), 0);
            }
        }
    }
    else {
        hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT TVAudio::ReadFromStream(IStream *pStream)
{
    DWORD dwJunk;
    HRESULT hr = S_OK;

    //
    // If there is a stream pointer, then IPersistPropertyBag::Load has already
    // been called, and therefore this instance already has been initialized
    // with some particular state.
    //
    if (m_pPersistStreamDevice)
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);

    // The first element in the serialized data is the version stamp.
    // This was read by CPersistStream and put into mPS_dwFileVersion.
    // The rest of the data is the tuner state stream followed by the
    // property bag stream.
    if (mPS_dwFileVersion > GetSoftwareVersion())
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

    if (0 == mPS_dwFileVersion) {
        // Before any kind of useful persistence was implemented,
        // another version ID was stored in the stream. This reads
        // that value (and basically ignores it).
        hr = pStream->Read(&dwJunk, sizeof(dwJunk), 0);
        if (SUCCEEDED(hr))
            SetDirty(TRUE); // force an update to the persistent stream
    }

    // If all went well, then access the property bag to load and initialize the device
    if(SUCCEEDED(hr))
    {
        IPersistStream *pMonPersistStream;
        hr = CoCreateInstance(CLSID_CDeviceMoniker, NULL, CLSCTX_INPROC_SERVER,
                              IID_IPersistStream, (void **)&pMonPersistStream);
        if(SUCCEEDED(hr)) {
            hr = pMonPersistStream->Load(pStream);
            if(SUCCEEDED(hr)) {
                IPropertyBag *pPropBag;
                hr = pMonPersistStream->QueryInterface(IID_IPropertyBag, (void **)&pPropBag);
                if(SUCCEEDED(hr)) {
                    hr = Load(pPropBag, 0);
                    if (SUCCEEDED(hr)) {
                        // Check if we have access to saved state
                        if (CURRENT_PERSIST_VERSION == mPS_dwFileVersion) {
                            long lMode;

                            // Get the filter state
                            hr = pStream->Read(&lMode, sizeof(lMode), 0);
                            if (SUCCEEDED(hr)) {
                                long lOrigMode;

                                // Compare it with the current hardware state and update if different
                                hr = get_TVAudioMode(&lOrigMode);
                                if (SUCCEEDED(hr) && lMode != lOrigMode)
                                    hr = put_TVAudioMode(lMode);
                            }
                        }
                    }
                    pPropBag->Release();
                }
            }

            pMonPersistStream->Release();
        }
    }

    return hr;
}

int TVAudio::SizeMax()
{

    ULARGE_INTEGER ulicb;
    HRESULT hr = E_FAIL;;

    if (m_pPersistStreamDevice) {
        hr = m_pPersistStreamDevice->GetSizeMax(&ulicb);
        if(hr == S_OK) {
            // space for the filter state
            ulicb.QuadPart += sizeof(long);
        }
    }

    return hr == S_OK ? (int)ulicb.QuadPart : 0;
}



//--------------------------------------------------------------------------;
// Input Pin
//--------------------------------------------------------------------------;

//
// TVAudioInputPin constructor
//
TVAudioInputPin::TVAudioInputPin(TCHAR *pName,
                           TVAudio *pTVAudio,
                           HRESULT *phr,
                           LPCWSTR pPinName) 
	: CBaseInputPin(pName, pTVAudio, pTVAudio, phr, pPinName)
    , CKsSupport (KSPIN_COMMUNICATION_SINK, reinterpret_cast<LPUNKNOWN>(pTVAudio))
	, m_pTVAudio(pTVAudio)
{
    ASSERT(pTVAudio);

    m_Medium.Set = GUID_NULL;
    m_Medium.Id = 0;
    m_Medium.Flags = 0;
}


//
// TVAudioInputPin destructor
//

TVAudioInputPin::~TVAudioInputPin()
{
    DbgLog((LOG_TRACE,2,TEXT("TVAudioInputPin destructor")));
}

//
// NonDelegatingQueryInterface
//
STDMETHODIMP TVAudioInputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv) {

    if (riid == __uuidof (IKsPin)) {
        return GetInterface((IKsPin *) this, ppv);
    }
    else if (riid == __uuidof (IKsPropertySet)) {
        return GetInterface((IKsPropertySet *) this, ppv);
    }
    else {
        return CBaseInputPin::NonDelegatingQueryInterface(riid, ppv);
    }

} // NonDelegatingQueryInterface


//
// CheckConnect
//
HRESULT TVAudioInputPin::CheckConnect(IPin *pReceivePin)
{
    HRESULT hr = NOERROR;
    IKsPin *KsPin;
    BOOL fOK = FALSE;

    hr = CBaseInputPin::CheckConnect(pReceivePin);
    if (FAILED(hr)) 
        return hr;

    // If the receiving pin supports IKsPin, then check for a match on the
    // Medium GUID, or check for a wildcard.
	if (SUCCEEDED (hr = pReceivePin->QueryInterface (
            __uuidof (IKsPin), (void **) &KsPin))) {

        PKSMULTIPLE_ITEM MediumList = NULL;
        PKSPIN_MEDIUM Medium;

        if (SUCCEEDED (hr = KsPin->KsQueryMediums(&MediumList))) {
            if ((MediumList->Count == 1) && 
                (MediumList->Size == (sizeof(KSMULTIPLE_ITEM) + sizeof(KSPIN_MEDIUM)))) {

				Medium = reinterpret_cast<PKSPIN_MEDIUM>(MediumList + 1);
                if (IsEqualGUID (Medium->Set, m_Medium.Set) && 
                        Medium->Id == m_Medium.Id &&
                        Medium->Flags == m_Medium.Flags) {
					fOK = TRUE;
				}
			}

            CoTaskMemFree(MediumList);
        }
        
        KsPin->Release();
    }
    else {
        if (IsEqualGUID (GUID_NULL, m_Medium.Set)) { 
            fOK = TRUE;
        }
    }
    
    return fOK ? NOERROR : E_INVALIDARG;

} // CheckConnect




//
// CheckMediaType
//
HRESULT TVAudioInputPin::CheckMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);

    if (*(pmt->Type()) != MEDIATYPE_AnalogAudio ) {
        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    return NOERROR;

} // CheckMediaType


//
// SetMediaType
//
HRESULT TVAudioInputPin::SetMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);
    HRESULT hr = NOERROR;

    // Make sure that the base class likes it
    hr = CBaseInputPin::SetMediaType(pmt);
    if (FAILED(hr))
        return hr;

    ASSERT(m_Connected != NULL);
    return NOERROR;

} // SetMediaType


//
// BreakConnect
//
HRESULT TVAudioInputPin::BreakConnect()
{
    return NOERROR;
} // BreakConnect


//
// Receive
//
HRESULT TVAudioInputPin::Receive(IMediaSample *pSample)
{
    CAutoLock lock_it(m_pLock);

    // Check that all is well with the base class
    HRESULT hr = NOERROR;
    hr = CBaseInputPin::Receive(pSample);
    if (hr != NOERROR)
        return hr;

    return NOERROR;

} // Receive


//
// Completed a connection to a pin
//
HRESULT TVAudioInputPin::CompleteConnect(IPin *pReceivePin)
{
    HRESULT hr = CBaseInputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr)) {
        return hr;
    }

    return S_OK;
}

//--------------------------------------------------------------------------;
// Output Pin
//--------------------------------------------------------------------------;

//
// TVAudioOutputPin constructor
//
TVAudioOutputPin::TVAudioOutputPin(TCHAR *pName,
                             TVAudio *pTVAudio,
                             HRESULT *phr,
                             LPCWSTR pPinName) 
	: CBaseOutputPin(pName, pTVAudio, pTVAudio, phr, pPinName) 
    , CKsSupport (KSPIN_COMMUNICATION_SINK, reinterpret_cast<LPUNKNOWN>(pTVAudio))
	, m_pTVAudio(pTVAudio)
{
    ASSERT(pTVAudio);

    m_Medium.Set = GUID_NULL;
    m_Medium.Id = 0;
    m_Medium.Flags = 0;
}


//
// TVAudioOutputPin destructor
//
TVAudioOutputPin::~TVAudioOutputPin()
{
}

//
// NonDelegatingQueryInterface
//
STDMETHODIMP TVAudioOutputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv) {

    if (riid == __uuidof (IKsPin)) {
        return GetInterface((IKsPin *) this, ppv);
    }
    else if (riid == __uuidof (IKsPropertySet)) {
        return GetInterface((IKsPropertySet *) this, ppv);
    }
    else {
        return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }

} // NonDelegatingQueryInterface

//
// CheckConnect
//
HRESULT TVAudioOutputPin::CheckConnect(IPin *pReceivePin)
{
    HRESULT hr = NOERROR;
    IKsPin *KsPin;
    BOOL fOK = FALSE;

    hr = CBaseOutputPin::CheckConnect(pReceivePin);
    if (FAILED(hr)) 
        return hr;

    // If the receiving pin supports IKsPin, then check for a match on the
    // Medium GUID, or check for a wildcard.
	if (SUCCEEDED (hr = pReceivePin->QueryInterface (
            __uuidof (IKsPin), (void **) &KsPin))) {

        PKSMULTIPLE_ITEM MediumList = NULL;
        PKSPIN_MEDIUM Medium;

        if (SUCCEEDED (hr = KsPin->KsQueryMediums(&MediumList))) {
            if ((MediumList->Count == 1) && 
                (MediumList->Size == (sizeof(KSMULTIPLE_ITEM) + sizeof(KSPIN_MEDIUM)))) {

				Medium = reinterpret_cast<PKSPIN_MEDIUM>(MediumList + 1);
                if (IsEqualGUID (Medium->Set, m_Medium.Set) && 
                        Medium->Id == m_Medium.Id &&
                        Medium->Flags == m_Medium.Flags) {
					fOK = TRUE;
				}
			}

            CoTaskMemFree(MediumList);
        }
        
        KsPin->Release();
    }
    else {
        if (IsEqualGUID (GUID_NULL, m_Medium.Set)) { 
            fOK = TRUE;
        }
    }
    
    return fOK ? NOERROR : E_INVALIDARG;

} // CheckConnect

//
// CheckMediaType
//
HRESULT TVAudioOutputPin::CheckMediaType(const CMediaType *pmt)
{
    if (*(pmt->Type()) != MEDIATYPE_AnalogAudio)	{
        return E_INVALIDARG;
	}

    return S_OK;  // This format is acceptable.

} // CheckMediaType


//
// EnumMediaTypes
//
STDMETHODIMP TVAudioOutputPin::EnumMediaTypes(IEnumMediaTypes **ppEnum)
{
    CAutoLock lock_it(m_pLock);
    ASSERT(ppEnum);

    return CBaseOutputPin::EnumMediaTypes (ppEnum);

} // EnumMediaTypes


#if 1
//
// EnumMediaTypes
//
HRESULT TVAudioOutputPin::GetMediaType(int iPosition,CMediaType *pMediaType)
{
    CAutoLock lock_it(m_pLock);

    if (iPosition < 0) 
        return E_INVALIDARG;
    if (iPosition >= 1)
	    return VFW_S_NO_MORE_ITEMS;

    pMediaType->SetFormatType(&GUID_NULL);
    pMediaType->SetType(&MEDIATYPE_AnalogAudio);
    pMediaType->SetTemporalCompression(FALSE);
    pMediaType->SetSubtype(&GUID_NULL);

    return NOERROR;
} // EnumMediaTypes

#endif


//
// SetMediaType
//
HRESULT TVAudioOutputPin::SetMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);

    // Make sure that the base class likes it
    HRESULT hr;

    hr = CBaseOutputPin::SetMediaType(pmt);
    if (FAILED(hr))
        return hr;

    return NOERROR;

} // SetMediaType


//
// CompleteConnect
//
HRESULT TVAudioOutputPin::CompleteConnect(IPin *pReceivePin)
{
    CAutoLock lock_it(m_pLock);
    ASSERT(m_Connected == pReceivePin);
    HRESULT hr = NOERROR;

    hr = CBaseOutputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr))
        return hr;

    // If the type is not the same as that stored for the input
    // pin then force the input pins peer to be reconnected

    return NOERROR;

} // CompleteConnect


HRESULT TVAudioOutputPin::DecideBufferSize(IMemAllocator *pAlloc,
                                       ALLOCATOR_PROPERTIES *pProperties)
{
    CAutoLock lock_it(m_pLock);
    ASSERT(pAlloc);
    ASSERT(pProperties);
    HRESULT hr = NOERROR;

    // Just one buffer of 1 byte in length
    // "Buffers" are used for format change notification only,
    // that is, if a tuner can produce both NTSC and PAL, a
    // buffer will only be sent to notify the receiving pin
    // of the format change

    pProperties->cbBuffer = 1;
    pProperties->cBuffers = 1;

    // Ask the allocator to reserve us the memory

    ALLOCATOR_PROPERTIES Actual;
    hr = pAlloc->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        return hr;
    }

    // Is this allocator unsuitable

    if (Actual.cbBuffer < pProperties->cbBuffer) {
        return E_FAIL;
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\xbar\xbar.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef __XBAR__
#define __XBAR__

#define MyValidateWritePtr(p,cb, ret) \
        {if(IsBadWritePtr((PVOID)p,cb) == TRUE) \
            return ret;}

#define IsAudioPin(Pin) (Pin->GetXBarPinType() >= PhysConn_Audio_Tuner)
#define IsVideoPin(Pin) (Pin->GetXBarPinType() <  PhysConn_Audio_Tuner)

class XBar;
class XBarOutputPin;
class XBarInputPin;

// Global functions

long WideStringFromPinType (WCHAR *pc, int nSize, long lType, BOOL fInput);
long StringFromPinType (TCHAR *pc, int nSize, long lType, BOOL fInput, int i);
BOOL KsControl(
           HANDLE hDevice,
           DWORD dwIoControl,
           PVOID pvIn,
           ULONG cbIn,
           PVOID pvOut,
           ULONG cbOut,
           PULONG pcbReturned,
           BOOL fSilent);

// class for the XBar filter's Input pin

class XBarInputPin 
	: public CBaseInputPin
	, public CKsSupport
{
    class CChangeInfo
    {
    public:
        CChangeInfo() {
            m_ChangeInfo.dwFlags = 0;
            m_ChangeInfo.dwCountryCode = static_cast<DWORD>(-1);
            m_ChangeInfo.dwAnalogVideoStandard = static_cast<DWORD>(-1);
            m_ChangeInfo.dwChannel = static_cast<DWORD>(-1);
        }

        void GetChangeInfo(KS_TVTUNER_CHANGE_INFO *ChangeInfo) {
            memcpy(ChangeInfo, &m_ChangeInfo, sizeof(KS_TVTUNER_CHANGE_INFO));
        }
        void SetChangeInfo(KS_TVTUNER_CHANGE_INFO *ChangeInfo) {
            memcpy(&m_ChangeInfo, ChangeInfo, sizeof(KS_TVTUNER_CHANGE_INFO));
        }

    private:
        KS_TVTUNER_CHANGE_INFO m_ChangeInfo;
    } m_ChangeInfo;

protected:
    long            m_Index;            // Index of pin
    XBar           *m_pXBar;            // Main filter object
    int             m_IndexRelatedPin;  // Audio goes with video
    long            m_lType;            // PhysConn_
	KSPIN_MEDIUM	m_Medium;           // Describes physical connection

public:

    // Constructor and destructor
    XBarInputPin(TCHAR *pObjName,
                 XBar *pXBar,
                 HRESULT *phr,
                 LPCWSTR pPinName,
                 long Index);

    ~XBarInputPin();

	STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    void GetChangeInfo(KS_TVTUNER_CHANGE_INFO *ChangeInfo) { m_ChangeInfo.GetChangeInfo(ChangeInfo); }
    void SetIndexRelatedPin (int i)     {m_IndexRelatedPin = i;};
    int  GetIndexRelatedPin ()          {return m_IndexRelatedPin;};
    void SetXBarPinType (long lType)    {m_lType = lType;};
    long GetXBarPinType ()              {return m_lType;};
    void SetXBarPinMedium (const KSPIN_MEDIUM *Medium)    
            {
                if (Medium == NULL) {
                    m_Medium.Set = GUID_NULL;
                    m_Medium.Id = 0;
                    m_Medium.Flags = 0;
                }
                else {
                    m_Medium = *Medium;
                }
                SetKsMedium (&m_Medium);
            };

    // Used to check the input pin connection
    HRESULT CheckConnect (IPin *pReceivePin);
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT BreakConnect();

    // Reconnect outputs if necessary at end of completion
    virtual HRESULT CompleteConnect(IPin *pReceivePin);

    // Handles the next block of data from the stream
    STDMETHODIMP Receive(IMediaSample *pSample);

    STDMETHODIMP QueryInternalConnections(
        IPin* *apPin,     // array of IPin*
        ULONG *nPin);     // on input, the number of slots
                          // on output  the number of pins
    
};


// Class for the XBar filter's Output pins.

class XBarOutputPin 
	: public CBaseOutputPin
	, public CKsSupport
{
    friend class XBarInputPin;
    friend class XBar;

protected:
    long            m_Index;                // Index of this pin
    XBar           *m_pXBar;                // Main filter object pointer
    XBarInputPin   *m_pConnectedInputPin;
    int             m_IndexRelatedPin;
    long            m_lType;                // PhysConn_
	KSPIN_MEDIUM	m_Medium;               // Describes physical connection
    BOOL            m_Muted;                // True if muted due to tuning change
    long            m_PreMuteRouteIndex;    // connection before mute

public:

    // Constructor and destructor

    XBarOutputPin(TCHAR *pObjName,
                   XBar *pXBar,
                   HRESULT *phr,
                   LPCWSTR pPinName,
                   long Index);

    ~XBarOutputPin();

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    void SetIndexRelatedPin (int i)     {m_IndexRelatedPin = i;};
    int  GetIndexRelatedPin ()          {return m_IndexRelatedPin;};
    void SetXBarPinType (long lType)    {m_lType = lType;};
    long GetXBarPinType ()              {return m_lType;};
    void SetXBarPinMedium (const KSPIN_MEDIUM *Medium)    
            {
                if (Medium == NULL) {
                    m_Medium.Set = GUID_NULL;
                    m_Medium.Id = 0;
                    m_Medium.Flags = 0;
                }
                else {
                    m_Medium = *Medium;
                }
                SetKsMedium (&m_Medium);
            };

    STDMETHODIMP Mute (BOOL Mute);
    
    HRESULT DecideBufferSize(IMemAllocator * pAlloc,ALLOCATOR_PROPERTIES * ppropInputRequest);

    // Override to enumerate media types
    STDMETHODIMP EnumMediaTypes(IEnumMediaTypes **ppEnum);
    HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);

    // Check that we can support an output type
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);

    // Overriden to create and destroy output pins
    HRESULT CheckConnect (IPin *pReceivePin);
    HRESULT CompleteConnect(IPin *pReceivePin);
    HRESULT BreakConnect();

    STDMETHODIMP QueryInternalConnections(
        IPin* *apPin,     // array of IPin*
        ULONG *nPin);     // on input, the number of slots
                          // on output  the number of pins

};


// Class for the XBar filter

class XBar: 
    public CCritSec, 
    public IAMCrossbar,
    public CBaseFilter,
    public CPersistStream,
    public IPersistPropertyBag,
    public ISpecifyPropertyPages
{

public:

    DECLARE_IUNKNOWN;

    // Basic COM - used here to reveal our property interface.
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // Function needed for the class factory
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME tStart);

    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);

    STDMETHODIMP RouteInternal( 
            /* [in] */ long OutputPinIndex,
            /* [in] */ long InputPinIndex,
            /* [in] */ BOOL fOverridePreMuteRouting);

    HRESULT DeliverChangeInfo(DWORD dwFlags, XBarInputPin *pInPin, XBarOutputPin *OutPin);

    // IAMCrossbar methods
    
    STDMETHODIMP get_PinCounts( 
            /* [out] */ long *OutputPinCount,
            /* [out] */ long *InputPinCount);
        
    STDMETHODIMP CanRoute( 
            /* [in] */ long OutputPinIndex,
            /* [in] */ long InputPinIndex);
        
    STDMETHODIMP Route( 
            /* [in] */ long OutputPinIndex,
            /* [in] */ long InputPinIndex);
        
    STDMETHODIMP get_IsRoutedTo( 
            /* [in] */ long OutputPinIndex,
            /* [out] */ long *InputPinIndex);
        
    STDMETHODIMP get_CrossbarPinInfo( 
            /* [in] */ BOOL IsInputPin,
            /* [in] */ long PinIndex,
            /* [out] */ long *PinIndexRelated,
            /* [out] */ long *PhysicalType);


    // --- IPersistPropertyBag ---
    STDMETHODIMP InitNew(void) ;
    STDMETHODIMP Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog) ;
    STDMETHODIMP Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties) ;
    STDMETHODIMP GetClassID(CLSID *pClsId) ;

    //
    // --- CPersistStream ---
    //

    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    DWORD GetSoftwareVersion(void);
    int SizeMax();

    //
    // --- ISpecifyPropertyPages ---
    //

    STDMETHODIMP GetPages(CAUUID *pPages);



private:

    // Let the pins access our internal state
    friend class XBarInputPin;
    friend class XBarOutputPin;
    typedef CGenericList <XBarOutputPin> COutputList;
    typedef CGenericList <XBarInputPin> CInputList;

    INT m_NumInputPins;             // Input pin count
    CInputList m_InputPinsList;     // List of the input pins

    INT m_NumOutputPins;            // Output pin count
    COutputList m_OutputPinsList;   // List of the output pins

    // KS Stuff.
    HANDLE m_hDevice;              
    TCHAR *m_pDeviceName;
    int CreateDevice(void);


    XBar(TCHAR *pName,LPUNKNOWN pUnk,HRESULT *hr);
    ~XBar();

    CBasePin *GetPin(int n);

    int GetPinCount(void);

    int GetDevicePinCount(void);

    // The following manage the lists of input and output pins

    HRESULT CreateInputPins();
    void DeleteInputPins();
    XBarInputPin *GetInputPinNFromList(int n);
    int FindIndexOfInputPin (IPin *pPin);

    HRESULT CreateOutputPins();
    void DeleteOutputPins();
    XBarOutputPin *GetOutputPinNFromList(int n);
    int FindIndexOfOutputPin (IPin *pPin);

    BOOL IsRouted (IPin * pOutputPin, IPin *pInputPin);

    // persist stream saved from  IPersistPropertyBag::Load
    IPersistStream *m_pPersistStreamDevice;
};

#endif // __XBAR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avidest\test\mkfile.c ===
#include <windows.h>
#include <winbase.h>

int main(int argc, char **argv)
{
  __int64 size;
  HANDLE h;
  char c;
  DWORD dw;
  LONG low, high;
  

  if(argc == 3)
  {
    size = atoi(argv[2]) * 1024 * 1024 -1;
  }
  else
  {
    printf("usage: mkfile filename meg ");
    exit(1);
  }

  h = CreateFile(argv[1], GENERIC_WRITE, 0, 0, OPEN_ALWAYS, 0, 0);
  if(h == INVALID_HANDLE_VALUE)
  {
    printf("open failed.\n");
    exit(1);
  }

  low = (LONG)(size & 0xffffffff);
  high = (LONG)(size >> 32);

  if(SetFilePointer(h, low, &high, FILE_BEGIN) == 0xffffffff &&
     GetLastError() != NO_ERROR)
  {
    printf("set failed.\n");
    exit(1);
  }

  if(WriteFile(h, &c, 1, &dw, 0) == 0)
  {
    printf("write failed.\n");
    exit(1);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avidest\test\srcfltr\ball.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// CBall
//
// Provides the ball that bounces.

#include <streams.h>

#include "ball.h"


//
// CBall::Constructor
//
// The default arguments provide a reasonable image and ball size.
CBall::CBall(int iImageWidth, int iImageHeight, int iBallSize)
    : m_iImageWidth(iImageWidth)
    , m_iImageHeight(iImageHeight)
    , m_iBallSize(iBallSize)
    , m_iAvailableWidth(iImageWidth - iBallSize)	// precompute these here for code clarity
    , m_iAvailableHeight(iImageHeight - iBallSize)
    , m_x(0)		// start the ball in the bottom left...
    , m_y(0)
    , m_xDir(RIGHT)	// ... and travelling to the top right
    , m_yDir(UP) {

    // Check we have some (arbitrary) space to bounce in.
    ASSERT(iImageWidth > 2*iBallSize);
    ASSERT(iImageHeight > 2*iBallSize);

    // random position for showing off a video mixer
    m_iRandX = rand();
    m_iRandY = rand();

}


//
// PlotBall
//
// assumes the image buffer is arranged row 1,row 2,row 3,...,row n in memory and
// that the data is contiguous.
void CBall::PlotBall(BYTE pFrame[], BYTE BallPixel[], int iPixelSize) {

    ASSERT(m_x >= 0);			// the ball is in the frame, allowing for its width
    ASSERT(m_x <= m_iAvailableWidth);	//
    ASSERT(m_y >= 0);			//
    ASSERT(m_y <= m_iAvailableHeight);	//

    BYTE *pBack =   pFrame;		// The current byte of interest in the frame

    // Plot the ball into the correct location
    BYTE *pBall =   pFrame 					// Set pBall to the first pixel
    		  + ( m_y * m_iImageWidth * iPixelSize) 	// of the ball to plot
    		  + m_x * iPixelSize;

    for (int row = 0; row < m_iBallSize; row++) {

        for (int col = 0; col < m_iBallSize; col++) {

            for (int i = 0; i < iPixelSize; i++) {	// For each byte in the pixel,
         						// fill its value from BallPixel[]
                if (WithinCircle(col, row)) {
                    *pBall = BallPixel[i];
                }
                pBall++;
	    }
	}

	pBall += m_iAvailableWidth * iPixelSize;
    }
}


//
// BallPosition
//
// Return the 1-dimensional position of the ball at time t millisecs
// millisecs runs out after about a month
int CBall::BallPosition( int iPixelTime  // millisecs per pixel
                       , int iLength     // distance between the bounce points
                       , int time        // time in millisecs
                       , int iOffset     // for a bit of randomness
                       ) {
    // Calculate the position of an unconstrained ball (no walls)
    // then fold it back and forth to calculate the actual position

    int x = time / iPixelTime;
    x += iOffset;
    x %= 2*iLength;
//    x += iLength/2;	// adjust for ball starting mid frame

    if (x>iLength) {	// check it is still in bounds
        x = 2*iLength - x;
    }

    return x;
}



//
// MoveBall
//
// Set (m_x, m_y) to the new position of the ball.  move diagonally
// with speed m_v in each of x and y directions.
// Guarantees to keep the ball in valid areas of the frame.
// When it hits an edge the ball bounces in the traditional manner!.
// The boundaries are (0..m_iAvailableWidth, 0..m_iAvailableHeight)
void CBall::MoveBall(CRefTime rt) {

    m_x = BallPosition( 10, m_iAvailableWidth, rt.Millisecs(), m_iRandX );
    m_y = BallPosition( 10, m_iAvailableHeight, rt.Millisecs(), m_iRandY );
}


//
// WithinCircle
//
// return TRUE if (x,y) is within a circle radius S/2, centre (S/2, S/2)
//                                         where S is m_iBallSize
// else return FALSE
inline BOOL CBall::WithinCircle(int x, int y) {

    unsigned int r = m_iBallSize / 2;

    if ( (x-r)*(x-r) + (y-r)*(y-r)  < r*r) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\xbar\xbar.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include <initguid.h>
#include <tchar.h>
#include <stdio.h>

#include <initguid.h>
#include <olectl.h>

#include <amtvuids.h>     // GUIDs  

#include <devioctl.h>

#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include "amkspin.h"

#include "kssupp.h"
#include "xbar.h"
#include "pxbar.h"
#include "tvaudio.h"
#include "ptvaudio.h"

// Using this pointer in constructor
#pragma warning(disable:4355)

CFactoryTemplate g_Templates [] = {
    { L"WDM Analog Crossbar"
    , &CLSID_CrossbarFilter
    , XBar::CreateInstance
    , NULL
    , NULL },

    { L"WDM Analog Crossbar Property Page"
    , &CLSID_CrossbarFilterPropertyPage
    , CXBarProperties::CreateInstance
    , NULL
    , NULL } ,

    { L"WDM TVAudio"
    , &CLSID_TVAudioFilter
    , TVAudio::CreateInstance
    , NULL
    , NULL },

    { L"WDM TVAudio Property Page"
    , &CLSID_TVAudioFilterPropertyPage
    , CTVAudioProperties::CreateInstance
    , NULL
    , NULL } ,

};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

//
// WideStringFromPinType
//

long WideStringFromPinType (WCHAR *pc, int nSize, long lType, BOOL fInput, int index)
{
    WCHAR *pcT;


    if (index == -1) {
        pcT = L"Mute";
    }
    else {
        switch (lType) {
    
        case PhysConn_Video_Tuner:              pcT = L"Video Tuner";           break;
        case PhysConn_Video_Composite:          pcT = L"Video Composite";       break;
        case PhysConn_Video_SVideo:             pcT = L"Video SVideo";          break;
        case PhysConn_Video_RGB:                pcT = L"Video RGB";             break;
        case PhysConn_Video_YRYBY:              pcT = L"Video YRYBY";           break;
        case PhysConn_Video_SerialDigital:      pcT = L"Video SerialDigital";   break;
        case PhysConn_Video_ParallelDigital:    pcT = L"Video ParallelDigital"; break;
        case PhysConn_Video_SCSI:               pcT = L"Video SCSI";            break;
        case PhysConn_Video_AUX:                pcT = L"Video AUX";             break;
        case PhysConn_Video_1394:               pcT = L"Video 1394";            break;
        case PhysConn_Video_USB:                pcT = L"Video USB";             break;
        case PhysConn_Video_VideoDecoder:       pcT = L"Video Decoder";         break;
        case PhysConn_Video_VideoEncoder:       pcT = L"Video Encoder";         break;
    
        case PhysConn_Audio_Tuner:              pcT = L"Audio Tuner";           break;
        case PhysConn_Audio_Line:               pcT = L"Audio Line";            break;
        case PhysConn_Audio_Mic:                pcT = L"Audio Mic";             break;
        case PhysConn_Audio_AESDigital:         pcT = L"Audio AESDigital";      break;
        case PhysConn_Audio_SPDIFDigital:       pcT = L"Audio SPDIFDigital";    break;
        case PhysConn_Audio_SCSI:               pcT = L"Audio SCSI";            break;
        case PhysConn_Audio_AUX:                pcT = L"Audio AUX";             break;
        case PhysConn_Audio_1394:               pcT = L"Audio 1394";            break;
        case PhysConn_Audio_USB:                pcT = L"Audio USB";             break;
        case PhysConn_Audio_AudioDecoder:       pcT = L"Audio Decoder";         break;
    
        default:
            pcT = L"Unknown";
            break;
    
        }
    }
    return swprintf (pc, fInput ? L"%d: %s In" : L"%d: %s Out", index, pcT);
                  
};


//
// StringFromPinType
//

long StringFromPinType (TCHAR *pc, int nSize, long lType, BOOL fInput, int j)
{
    WCHAR wName[MAX_PATH];
    long l;

    l = WideStringFromPinType (wName, nSize, lType, fInput, j);

#ifdef _UNICODE
    lstrcpyn (pc, wName, nSize);
#else    
    l = wcstombs (pc, wName, nSize);
#endif                  
    return l;
};

//
// This should be in a library, or helper object
//

BOOL
KsControl
(
   HANDLE hDevice,
   DWORD dwIoControl,
   PVOID pvIn,
   ULONG cbIn,
   PVOID pvOut,
   ULONG cbOut,
   PULONG pcbReturned,
   BOOL fSilent
)
{
   BOOL fResult;
   OVERLAPPED ov;

   RtlZeroMemory( &ov, sizeof( OVERLAPPED ) ) ;
   if (NULL == (ov.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL )))
        return FALSE ;

    fResult =
        DeviceIoControl( hDevice,
		       dwIoControl,
		       pvIn,
		       cbIn,
		       pvOut,
		       cbOut,
		       pcbReturned,
		       &ov ) ;


    if (!fResult) {
        if (ERROR_IO_PENDING == GetLastError()) {
	        WaitForSingleObject(ov.hEvent, INFINITE) ;
	        fResult = TRUE ;
        } 
        else {
	        fResult = FALSE ;
	        if(!fSilent)
	            MessageBox(NULL, TEXT("DeviceIoControl"), TEXT("Failed"), MB_OK);
        }
   }

   CloseHandle(ov.hEvent) ;

   return fResult ;
}

//
// CreateInstance
//
// Creator function for the class ID
//
CUnknown * WINAPI XBar::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new XBar(NAME("Analog Crossbar"), pUnk, phr);
}


//
// Constructor
//
XBar::XBar(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) :
    m_InputPinsList(NAME("XBar Input Pins list")),
    m_NumInputPins(0),
    m_OutputPinsList(NAME("XBar Output Pins list")),
    m_NumOutputPins(0),
    m_pPersistStreamDevice(NULL),
    m_hDevice(NULL),
    m_pDeviceName(NULL),
    CBaseFilter(NAME("Crossbar filter"), pUnk, this, CLSID_CrossbarFilter),
    CPersistStream(pUnk, phr)
{
    ASSERT(phr);

}


//
// Destructor
//
XBar::~XBar()
{
    POSITION pos;
    XBarOutputPin *Pin;

    //
    // Mute all of the output pins on destruction
    //

    TRAVERSELIST(m_OutputPinsList, pos) {
        if (Pin = m_OutputPinsList.Get(pos)) {
            Pin->Mute (TRUE);
        }
    }

    DeleteInputPins();
    DeleteOutputPins();

    // close the device
    if(m_hDevice) {
	    CloseHandle(m_hDevice);
    }

    if(m_pDeviceName) {
        delete [] m_pDeviceName;
    }

    if (m_pPersistStreamDevice) {
       m_pPersistStreamDevice->Release();
    }
}

//
// NonDelegatingQueryInterface
//
STDMETHODIMP XBar::NonDelegatingQueryInterface(REFIID riid, void **ppv) {

    if (riid == IID_IAMCrossbar) {
        return GetInterface((IAMCrossbar *) this, ppv);
    }
    else if (riid == IID_ISpecifyPropertyPages) {
        return GetInterface((ISpecifyPropertyPages *) this, ppv);
    }
    else if (riid == IID_IPersistPropertyBag) {
        return GetInterface((IPersistPropertyBag *) this, ppv);
    }
    else if (riid == IID_IPersistStream) {
        return GetInterface((IPersistStream *) this, ppv);
    }
    else {
        return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }

} // NonDelegatingQueryInterface


// -------------------------------------------------------------------------
// ISpecifyPropertyPages
// -------------------------------------------------------------------------

//
// GetPages
//
// Returns the clsid's of the property pages we support
STDMETHODIMP XBar::GetPages(CAUUID *pPages) {

    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }
    *(pPages->pElems) = CLSID_CrossbarFilterPropertyPage;

    return NOERROR;
}

// We can't Cue!

STDMETHODIMP XBar::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    HRESULT hr = CBaseFilter::GetState(dwMSecs, State);
    
    if (m_State == State_Paused) {
        hr = ((HRESULT)VFW_S_CANT_CUE); // VFW_S_CANT_CUE;
    }
    return hr;
};


// -------------------------------------------------------------------------
// IAMCrossbar 
// -------------------------------------------------------------------------
STDMETHODIMP 
XBar::get_PinCounts( 
            /* [out] */ long *OutputPinCount,
            /* [out] */ long *InputPinCount)
{
    MyValidateWritePtr (OutputPinCount, sizeof(long), E_POINTER);
    MyValidateWritePtr (InputPinCount, sizeof(long), E_POINTER);

    *OutputPinCount = m_NumOutputPins;
    *InputPinCount  = m_NumInputPins;

    return S_OK;
}


STDMETHODIMP 
XBar::CanRoute( 
            /* [in] */ long OutputPinIndex,
            /* [in] */ long InputPinIndex)
{
    KSPROPERTY_CROSSBAR_ROUTE_S Route;
    BOOL fOK;
    ULONG cbReturned;

    // TODO:  Verify validity of indices

    Route.Property.Set   = PROPSETID_VIDCAP_CROSSBAR;
    Route.Property.Id    = KSPROPERTY_CROSSBAR_CAN_ROUTE;
    Route.Property.Flags = KSPROPERTY_TYPE_GET;

    Route.IndexInputPin  = InputPinIndex;
    Route.IndexOutputPin = OutputPinIndex;
    Route.CanRoute = FALSE;

    if (Route.IndexOutputPin == -1) {
        return S_FALSE;
    }

    fOK = KsControl(m_hDevice, 
            (DWORD) IOCTL_KS_PROPERTY,
	    &Route,
	    sizeof(Route),
	    &Route,
	    sizeof(Route),
	    &cbReturned,
	    TRUE);

    return Route.CanRoute ? S_OK : S_FALSE;
};


STDMETHODIMP 
XBar::Route ( 
            /* [in] */ long OutputPinIndex,
            /* [in] */ long InputPinIndex)
{
    return RouteInternal ( 
                    OutputPinIndex,
                    InputPinIndex,
                    TRUE);
};

STDMETHODIMP 
XBar::RouteInternal ( 
            /* [in] */ long OutputPinIndex,
            /* [in] */ long InputPinIndex,
            /* [in] */ BOOL fOverridePreMuteRouting)
{
    KSPROPERTY_CROSSBAR_ROUTE_S Route;
    BOOL fOK;
    HRESULT hr = S_OK;
    ULONG cbReturned;

    if (CanRoute (OutputPinIndex, InputPinIndex) == S_FALSE) {
        return S_FALSE;
    }

    // Only need OutPin to continue
    XBarOutputPin *OutPin = GetOutputPinNFromList(OutputPinIndex);
    if (OutPin)
    {
        XBarInputPin *InPin = GetInputPinNFromList(InputPinIndex);

        Route.Property.Set   = PROPSETID_VIDCAP_CROSSBAR;
        Route.Property.Id    = KSPROPERTY_CROSSBAR_ROUTE;
        Route.Property.Flags = KSPROPERTY_TYPE_SET;

        Route.IndexInputPin  = InputPinIndex;
        Route.IndexOutputPin = OutputPinIndex;

        if (IsVideoPin(OutPin))
        {
            DeliverChangeInfo(KS_TVTUNER_CHANGE_BEGIN_TUNE, InPin, OutPin);

            fOK = KsControl(m_hDevice, 
                    (DWORD) IOCTL_KS_PROPERTY,
	            &Route,
	            sizeof(Route),
	            &Route,
	            sizeof(Route),
	            &cbReturned,
	            TRUE);

            DeliverChangeInfo(KS_TVTUNER_CHANGE_END_TUNE, InPin, OutPin);
        }
        else
        {
            fOK = KsControl(m_hDevice, 
                    (DWORD) IOCTL_KS_PROPERTY,
	            &Route,
	            sizeof(Route),
	            &Route,
	            sizeof(Route),
	            &cbReturned,
	            TRUE);
        }

        if (fOK)
        {
            SetDirty(TRUE);

            OutPin->m_pConnectedInputPin = InPin;

            if (fOverridePreMuteRouting)
            {
                OutPin->m_PreMuteRouteIndex = InputPinIndex;
                OutPin->m_Muted = (InputPinIndex == -1) ? TRUE : FALSE;
            }
        }
        else
            hr = S_FALSE;
    }

    return hr;
};

HRESULT
XBar::DeliverChangeInfo(DWORD dwFlags, XBarInputPin *pInPin, XBarOutputPin *pOutPin)
{
    CAutoLock Lock(m_pLock);
    IMediaSample *pMediaSample = NULL;

    if (pOutPin == NULL || !pOutPin->IsConnected())
        return S_OK;

    HRESULT hr = pOutPin->GetDeliveryBuffer(&pMediaSample, NULL, NULL, 0);
    if (!FAILED(hr) && pMediaSample != NULL)
    {
        if (pMediaSample->GetSize() >= sizeof(KS_TVTUNER_CHANGE_INFO))
        {
            KS_TVTUNER_CHANGE_INFO *ChangeInfo;
    
            // Get the sample's buffer pointer
            hr = pMediaSample->GetPointer(reinterpret_cast<BYTE**>(&ChangeInfo));
            if (!FAILED(hr))
            {
                pMediaSample->SetActualDataLength(sizeof(KS_TVTUNER_CHANGE_INFO));

                // Check for an input pin to grab the ChangeInfo from
                if (!pInPin)
                {
                    ChangeInfo->dwCountryCode = static_cast<DWORD>(-1);
                    ChangeInfo->dwAnalogVideoStandard = static_cast<DWORD>(-1);
                    ChangeInfo->dwChannel = static_cast<DWORD>(-1);
                }
                else
                    pInPin->GetChangeInfo(ChangeInfo);

                ChangeInfo->dwFlags = dwFlags;

                DbgLog(( LOG_TRACE, 4, TEXT("Delivering change info on route change (channel = %d)"), ChangeInfo->dwChannel));

                hr = pOutPin->Deliver(pMediaSample);
            }
        }

        pMediaSample->Release();

        // Perform the mute operation on a related audio pin
        pOutPin->Mute(dwFlags & KS_TVTUNER_CHANGE_BEGIN_TUNE);
    }

    return hr;
}

STDMETHODIMP 
XBar::get_IsRoutedTo ( 
            /* [in] */  long OutputPinIndex,
            /* [out] */ long *InputPinIndex)
{
    KSPROPERTY_CROSSBAR_ROUTE_S Route;
    BOOL fOK;
    ULONG cbReturned;

    MyValidateWritePtr (InputPinIndex, sizeof(long), E_POINTER);

    Route.Property.Set   = PROPSETID_VIDCAP_CROSSBAR;
    Route.Property.Id    = KSPROPERTY_CROSSBAR_ROUTE;
    Route.Property.Flags = KSPROPERTY_TYPE_GET;

    Route.IndexOutputPin = OutputPinIndex;

    if (Route.IndexOutputPin == -1) {
        return S_FALSE;
    }

    fOK = KsControl(m_hDevice, 
            (DWORD) IOCTL_KS_PROPERTY,
	    &Route,
	    sizeof(Route),
	    &Route,
	    sizeof(Route),
	    &cbReturned,
	    TRUE);

    *InputPinIndex = Route.IndexInputPin;

    // TODO:  Verify validity of indices

    return fOK ? S_OK : S_FALSE;
};

STDMETHODIMP 
XBar::get_CrossbarPinInfo( 
            /* [in] */ BOOL IsInputPin,
            /* [in] */ long PinIndex,
            /* [out] */ long *PinIndexRelated,
            /* [out] */ long *PhysicalType)
{
    XBarOutputPin * pOutPin;
    XBarInputPin * pInPin;

    MyValidateWritePtr (PinIndexRelated, sizeof(long), E_POINTER);
    MyValidateWritePtr (PhysicalType, sizeof(long), E_POINTER);

    *PinIndexRelated = -1;
    *PhysicalType = 0;

    // TODO:  Verify validity of indices

    if (IsInputPin) {
        if (pInPin = GetInputPinNFromList (PinIndex)) {
            *PinIndexRelated = pInPin->GetIndexRelatedPin();
            *PhysicalType = pInPin->GetXBarPinType ();
        }
    } 
    else {
        if (pOutPin = GetOutputPinNFromList (PinIndex)) {
            *PinIndexRelated = pOutPin->GetIndexRelatedPin();
            *PhysicalType = pOutPin->GetXBarPinType ();
        }
    }

    return (*PhysicalType != 0) ? S_OK : S_FALSE;
};

int XBar::CreateDevice()
{
    HANDLE hDevice ;

    hDevice = CreateFile( m_pDeviceName,
		     GENERIC_READ | GENERIC_WRITE,
		     0,
		     NULL,
		     OPEN_EXISTING,
		     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
		     NULL ) ;

    if (hDevice == (HANDLE) -1) {
	    MessageBox(NULL, m_pDeviceName, TEXT("Error: Can't CreateFile device"), MB_OK);
	    return 0 ;
    } else {
	    m_hDevice = hDevice;
	    return 1;
    }
}



//
// GetPin
//
CBasePin *XBar::GetPin(int n) 
{
    if (n < m_NumInputPins)
        return GetInputPinNFromList (n);
    else
        return GetOutputPinNFromList (n - m_NumInputPins);
}

//
// GetPinCount
//
int XBar::GetPinCount(void)
{
    return m_NumInputPins + m_NumOutputPins;
}


//
// GetPinCount
//
int XBar::GetDevicePinCount(void)
{
    KSPROPERTY_CROSSBAR_CAPS_S Caps;
    ULONG       cbReturned;
    BOOL        fOK;

    if(!m_hDevice)
	return 0;

    Caps.Property.Set   = PROPSETID_VIDCAP_CROSSBAR;
    Caps.Property.Id    = KSPROPERTY_CROSSBAR_CAPS;
    Caps.Property.Flags = KSPROPERTY_TYPE_GET;
    Caps.NumberOfInputs = Caps.NumberOfOutputs = 0;

    fOK = KsControl(m_hDevice, 
                (DWORD) IOCTL_KS_PROPERTY,
	            &Caps,
	            sizeof(Caps),
	            &Caps,
	            sizeof(Caps),
	            &cbReturned,
	            TRUE);

    m_NumInputPins = Caps.NumberOfInputs;
    m_NumOutputPins = Caps.NumberOfOutputs;

    return m_NumInputPins + m_NumOutputPins;
}

//
// CreateInputPins
//
HRESULT XBar::CreateInputPins()
{
    WCHAR szbuf[64];            // Temporary scratch buffer
    HRESULT hr = NOERROR;
    int i;
    KSPROPERTY_CROSSBAR_PININFO_S PinInfo;
    BOOL fOK;
    ULONG cbReturned;

    for (i = 0; SUCCEEDED(hr) && i < m_NumInputPins; i++)
    {
        ZeroMemory (&PinInfo, sizeof (PinInfo));

        PinInfo.Property.Set   = PROPSETID_VIDCAP_CROSSBAR;
        PinInfo.Property.Id    = KSPROPERTY_CROSSBAR_PININFO;
        PinInfo.Property.Flags = KSPROPERTY_TYPE_GET;
        PinInfo.Direction      = KSPIN_DATAFLOW_IN;

        PinInfo.Index = i;

        fOK = KsControl(m_hDevice, 
                (DWORD) IOCTL_KS_PROPERTY,
	            &PinInfo,
	            sizeof(PinInfo),
	            &PinInfo,
	            sizeof(PinInfo),
	            &cbReturned,
	            TRUE);
        if (fOK)
        {
            WideStringFromPinType(szbuf, sizeof(szbuf)/sizeof(WCHAR), PinInfo.PinType, TRUE /*fInput*/, i);

            XBarInputPin *pPin = new XBarInputPin(NAME("XBar Input"), this,
					            &hr, szbuf, i);
            if (pPin)
            {
                if (SUCCEEDED(hr))
                {
                    pPin->SetIndexRelatedPin (PinInfo.RelatedPinIndex);
                    pPin->SetXBarPinType (PinInfo.PinType);

                    pPin->SetXBarPinMedium (&PinInfo.Medium);

                    m_InputPinsList.AddTail (pPin);
                }
                else
                    delete pPin;
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
            hr = E_FAIL;
    }

    return hr;
} // CreateInputPins

//
// CreateOutputPins
//
HRESULT XBar::CreateOutputPins()
{
    WCHAR szbuf[64];            // Temporary scratch buffer
    HRESULT hr = NOERROR;
    long i, k;
    KSPROPERTY_CROSSBAR_PININFO_S PinInfo;
    BOOL fOK;
    ULONG cbReturned;

    for (i = 0; SUCCEEDED(hr) && i < m_NumOutputPins; i++)
    {
        ZeroMemory (&PinInfo, sizeof (PinInfo));

        PinInfo.Property.Set   = PROPSETID_VIDCAP_CROSSBAR;
        PinInfo.Property.Id    = KSPROPERTY_CROSSBAR_PININFO;
        PinInfo.Property.Flags = KSPROPERTY_TYPE_GET;
        PinInfo.Direction      = KSPIN_DATAFLOW_OUT;

        PinInfo.Index = i;

        fOK = KsControl(m_hDevice, 
                (DWORD) IOCTL_KS_PROPERTY,
	            &PinInfo,
	            sizeof(PinInfo),
	            &PinInfo,
	            sizeof(PinInfo),
	            &cbReturned,
	            TRUE);
        if (fOK)
        {
            WideStringFromPinType(szbuf, sizeof(szbuf)/sizeof(WCHAR), PinInfo.PinType, FALSE /*fInput*/, i);

            XBarOutputPin *pPin = new XBarOutputPin(NAME("XBar Output"), this,
					            &hr, szbuf, i);
            if (pPin)
            {
                if (SUCCEEDED(hr))
                {
                    pPin->SetIndexRelatedPin (PinInfo.RelatedPinIndex);
                    pPin->SetXBarPinType (PinInfo.PinType);

                    pPin->SetXBarPinMedium (&PinInfo.Medium);


                    m_OutputPinsList.AddTail (pPin);
                }
                else
                    delete pPin;
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
            hr = E_FAIL;
    }

    if (SUCCEEDED(hr)) {
        //
        // Now establish the default connections,
        //   ie which input is connected to each
        //   output
        //
        for (i = 0; i < m_NumOutputPins; i++) {
            hr = get_IsRoutedTo (i, &k);
            if (S_OK == hr) {
                GetOutputPinNFromList(i)->m_pConnectedInputPin = 
                    GetInputPinNFromList(k);
            }
            else {
                GetOutputPinNFromList(i)->m_pConnectedInputPin =
                    NULL;
            }

        }
        hr = S_OK;  // hide any failures from this operation
    }

    return hr;
} // CreateOutputPins



//
// DeleteInputPins
//
void XBar::DeleteInputPins (void)
{
    XBarInputPin *pPin;

    while (pPin = m_InputPinsList.RemoveHead()) {
        delete pPin;
    }

} // DeleteInputPins


//
// DeleteOutputPins
//
void XBar::DeleteOutputPins (void)
{
    XBarOutputPin *pPin;


    while (pPin = m_OutputPinsList.RemoveHead()) {
        delete pPin;
    }

} // DeleteOutputPins



HRESULT XBar::Stop()
{
    return CBaseFilter::Stop();
}

HRESULT XBar::Pause()
{
    POSITION       pos;
    XBarOutputPin *Pin;

    //
    // Mute all of the output pins on Run to Pause
    //
    if (m_State == State_Running) {
        TRAVERSELIST(m_OutputPinsList, pos) {
            if (Pin = m_OutputPinsList.Get(pos)) {
                Pin->Mute (TRUE);
            }
        }
    }
    return CBaseFilter::Pause();
}

HRESULT XBar::Run(REFERENCE_TIME tStart)
{
    POSITION       pos;
    XBarOutputPin *Pin;

    //
    // UnMute all of the output pins
    //
    TRAVERSELIST(m_OutputPinsList, pos) {
        if (Pin = m_OutputPinsList.Get(pos)) {
            Pin->Mute (FALSE);
        }
    }

    return CBaseFilter::Run(tStart);
}




//
// GetInputPinNFromList
//
XBarInputPin *XBar::GetInputPinNFromList(int n)
{
    // Validate the position being asked for
    if ((n >= m_NumInputPins) || (n < 0))
        return NULL;

    // Get the head of the list
    POSITION pos = m_InputPinsList.GetHeadPosition();
    XBarInputPin *pInputPin = m_InputPinsList.GetHead();

    // GetNext really returns the current object, THEN updates pos to the next item
    while ( n >= 0 ) {
        pInputPin = m_InputPinsList.GetNext(pos);
        n--;
    }
    return pInputPin;

} // GetInputPinNFromList


//
// GetOutputPinNFromList
//
XBarOutputPin *XBar::GetOutputPinNFromList(int n)
{
    // Validate the position being asked for
    if ((n >= m_NumOutputPins) || (n < 0))
        return NULL;

    // Get the head of the list
    POSITION pos = m_OutputPinsList.GetHeadPosition();
    XBarOutputPin *pOutputPin = m_OutputPinsList.GetHead();

    // GetNext really returns the current object, THEN updates pos to the next item
    while ( n >= 0 ) {
        pOutputPin = m_OutputPinsList.GetNext(pos);
        n--;
    }
    return pOutputPin;

} // GetOutputPinNFromList

// 
// Find the Index of the pin in the list, or -1 on failure
// 
int XBar::FindIndexOfInputPin (IPin * pPin)
{
    int j = 0;
    POSITION pos;
    int index = -1;

    TRAVERSELIST(m_InputPinsList, pos) {
        if ((IPin *) m_InputPinsList.Get(pos) == pPin) {
            index = j;
            break;
        }
        j++;
    }
 
    return index;
};

// 
// Find the Index of the pin in the list, or -1 on failure
// 
int XBar::FindIndexOfOutputPin (IPin * pPin)
{
    int j = 0;
    POSITION pos;
    int index = -1;

    TRAVERSELIST(m_OutputPinsList, pos) {
        if ((IPin *) m_OutputPinsList.Get(pos) == pPin) {
            index = j;
            break;
        }
        j++;
    }
 
    return index;
};

// 
// Check whether an output pin is connected to an input pin
// 
BOOL XBar::IsRouted (IPin * pOutputPin, IPin *pInputPin)
{
    long OutputIndex, InputIndex, InputTestIndex;
    HRESULT hr;

    InputIndex = FindIndexOfInputPin (pInputPin);
    OutputIndex = FindIndexOfOutputPin (pOutputPin);

    hr = get_IsRoutedTo ( 
                    OutputIndex,
                    &InputTestIndex);

    return (InputTestIndex == InputIndex);
};



//
// IPersistPropertyBag interface implementation for AMPnP support
//
STDMETHODIMP XBar::InitNew(void)
{
    return S_OK ;
}

STDMETHODIMP 
XBar::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    CAutoLock Lock(m_pLock) ;

    VARIANT var;
    VariantInit(&var);
    V_VT(&var) = VT_BSTR;

    // ::Load can succeed only once
    ASSERT(m_pPersistStreamDevice == 0); 
    
    HRESULT hr = pPropBag->Read(L"DevicePath", &var,0);
    if(SUCCEEDED(hr))
    {
        ULONG DeviceNameSize;

        if (m_pDeviceName) delete [] m_pDeviceName;	
        m_pDeviceName = new TCHAR [DeviceNameSize = (wcslen(V_BSTR(&var)) + 1)];
        if (!m_pDeviceName)
            return E_OUTOFMEMORY;

#ifndef _UNICODE
        WideCharToMultiByte(CP_ACP, 0, V_BSTR(&var), -1,
                            m_pDeviceName, DeviceNameSize, 0, 0);
#else
        lstrcpy(m_pDeviceName, V_BSTR(&var));
#endif
        VariantClear(&var);
        DbgLog((LOG_TRACE,2,TEXT("XBar::Load: use %s"), m_pDeviceName));

        if (CreateDevice()) {
            GetDevicePinCount();
            hr = CreateInputPins();
            if (FAILED(hr))
                return hr;
            hr = CreateOutputPins();
            if (FAILED(hr))
                return hr;
        }
        else {
            return E_FAIL ;
        }

        // save moniker with addref. ignore error if qi fails
        hr = pPropBag->QueryInterface(IID_IPersistStream, (void **)&m_pPersistStreamDevice);

        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP XBar::Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, 
                            BOOL fSaveAllProperties)
{
    return E_NOTIMPL ;
}

STDMETHODIMP XBar::GetClassID(CLSID *pClsid)
{
    return CBaseFilter::GetClassID(pClsid);
}

// -------------------------------------------------------------------------
// IPersistStream interface implementation for saving to a graph file
// -------------------------------------------------------------------------

#define ORIGINAL_DEFAULT_PERSIST_VERSION    0

// Insert obsolete versions above with new names
// Keep the following name, and increment the value if changing the persist stream format

#define CURRENT_PERSIST_VERSION             1

DWORD
XBar::GetSoftwareVersion(
    void
    )
/*++

Routine Description:

    Implement the CPersistStream::GetSoftwareVersion method. Returns
    the new version number rather than the default of zero.

Arguments:

    None.

Return Value:

    Return CURRENT_PERSIST_VERSION.

--*/
{
    return CURRENT_PERSIST_VERSION;
}

HRESULT XBar::WriteToStream(IStream *pStream)
{

    HRESULT hr = E_FAIL;

    if (m_pPersistStreamDevice) {

        hr = m_pPersistStreamDevice->Save(pStream, TRUE);
        if(SUCCEEDED(hr)) {
            long temp = m_NumOutputPins;

            // Save the number of output pins (for sanity check when reading the stream later)
            hr = pStream->Write(&temp, sizeof(temp), 0);

            // Save state of each output pin
            for (long i = 0; SUCCEEDED(hr) && i < m_NumOutputPins; i++) {

                // Get a pointer to the pin object
                XBarOutputPin *OutPin = GetOutputPinNFromList(i);
                if (OutPin) {
                    long k = -1;

                    // Get the route index
                    get_IsRoutedTo(i, &k);

                    // Save the route index, the muted state, and the pre-mute route index
                    hr = pStream->Write(&k, sizeof(long), 0);
                    if (FAILED(hr))
                        break;

                    hr = pStream->Write(&OutPin->m_Muted, sizeof(BOOL), 0);
                    if (FAILED(hr))
                        break;

                    hr = pStream->Write(&OutPin->m_PreMuteRouteIndex, sizeof(long), 0);
                }
                else {
                    hr = E_UNEXPECTED;
                }
            } // for each output pin index
        }
    }
    else {
        hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT XBar::ReadFromStream(IStream *pStream)
{
    DWORD dwJunk;
    HRESULT hr = S_OK;

    //
    // If there is a stream pointer, then IPersistPropertyBag::Load has already
    // been called, and therefore this instance already has been initialized
    // with some particular state.
    //
    if (m_pPersistStreamDevice)
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);

    // The first element in the serialized data is the version stamp.
    // This was read by CPersistStream and put into mPS_dwFileVersion.
    // The rest of the data is the tuner state stream followed by the
    // property bag stream.
    if (mPS_dwFileVersion > GetSoftwareVersion())
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

    if (ORIGINAL_DEFAULT_PERSIST_VERSION == mPS_dwFileVersion)
    {
        // Before any kind of useful persistence was implemented,
        // another version ID was stored in the stream. This reads
        // that value (and basically ignores it).
        hr = pStream->Read(&dwJunk, sizeof(dwJunk), 0);
        if (SUCCEEDED(hr))
            SetDirty(TRUE); // force an update to the persistent stream
    }

    // If all went well, then access the property bag to load and initialize the device
    if(SUCCEEDED(hr))
    {
        IPersistStream *pMonPersistStream;
        hr = CoCreateInstance(CLSID_CDeviceMoniker, NULL, CLSCTX_INPROC_SERVER,
                              IID_IPersistStream, (void **)&pMonPersistStream);
        if(SUCCEEDED(hr)) {
            hr = pMonPersistStream->Load(pStream);
            if(SUCCEEDED(hr)) {
                IPropertyBag *pPropBag;
                hr = pMonPersistStream->QueryInterface(IID_IPropertyBag, (void **)&pPropBag);
                if(SUCCEEDED(hr)) {
                    hr = Load(pPropBag, 0);
                    if(SUCCEEDED(hr)) {

                        // Check if we have access to saved state
                        if (CURRENT_PERSIST_VERSION == mPS_dwFileVersion) {
                            long lNumOutputPins;

                            // Get the output pin count from the stream
                            hr = pStream->Read(&lNumOutputPins, sizeof(lNumOutputPins), 0);
                            if (SUCCEEDED(hr)) {

                                // Something's wrong if these don't match, but
                                // the following code will work regardless
                                ASSERT(m_NumOutputPins == lNumOutputPins);

                                // Read each output pin's connected state
                                for (long i = 0; i < lNumOutputPins; i++) {
                                    long RouteIndex, PreMuteRouteIndex;
                                    BOOL Muted;

                                    // Get the route index, the muted state, and the pre-mute route index
                                    hr = pStream->Read(&RouteIndex, sizeof(long), 0);
                                    if (FAILED(hr))
                                        break;

                                    hr = pStream->Read(&Muted, sizeof(BOOL), 0);
                                    if (FAILED(hr))
                                        break;

                                    hr = pStream->Read(&PreMuteRouteIndex, sizeof(long), 0);
                                    if (FAILED(hr))
                                        break;

                                    // Get a pointer to the pin
                                    XBarOutputPin *OutPin = GetOutputPinNFromList(i);
                                    if (OutPin) {
                                        long temp = -1;

                                        // Check to see if a route request is necessary
                                        get_IsRoutedTo(i, &temp);
                                        if (RouteIndex != temp) {
                                            RouteInternal(i, RouteIndex, FALSE);
                                        }

                                        OutPin->m_Muted = Muted;
                                        OutPin->m_PreMuteRouteIndex = PreMuteRouteIndex;
                                    }
                                } // for each output pin index
                            }
                        }
                    }
                    pPropBag->Release();
                }
            }

            pMonPersistStream->Release();
        }
    }

   return hr;
}

int XBar::SizeMax()
{

    ULARGE_INTEGER ulicb;
    HRESULT hr = E_FAIL;;

    if (m_pPersistStreamDevice) {
        hr = m_pPersistStreamDevice->GetSizeMax(&ulicb);
        if(hr == S_OK) {
            // space for the filter state (output pin count + state of output pins)
            ulicb.QuadPart +=
                sizeof(long) +
                (sizeof(long) + sizeof(BOOL) + sizeof(long)) * m_NumOutputPins
                ;
        }
    }

    return hr == S_OK ? (int)ulicb.QuadPart : 0;
}



//--------------------------------------------------------------------------;
// Input Pin
//--------------------------------------------------------------------------;

//
// XBarInputPin constructor
//
XBarInputPin::XBarInputPin(TCHAR *pName,
                           XBar *pXBar,
                           HRESULT *phr,
                           LPCWSTR pPinName,
                           LONG Index) 
	: CBaseInputPin(pName, pXBar, pXBar, phr, pPinName)
    , CKsSupport (KSPIN_COMMUNICATION_SINK, reinterpret_cast<LPUNKNOWN>(pXBar))
	, m_pXBar(pXBar)
    , m_Index(Index)
{
    ASSERT(pXBar);

    m_Medium.Set = GUID_NULL;
    m_Medium.Id = 0;
    m_Medium.Flags = 0;
}


//
// XBarInputPin destructor
//

XBarInputPin::~XBarInputPin()
{
    DbgLog((LOG_TRACE,2,TEXT("XBarInputPin destructor")));
}

//
// NonDelegatingQueryInterface
//
STDMETHODIMP XBarInputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv) {

    if (riid == __uuidof (IKsPin)) {
        return GetInterface((IKsPin *) this, ppv);
    }
    else if (riid == __uuidof (IKsPropertySet)) {
        return GetInterface((IKsPropertySet *) this, ppv);
    }
    else {
        return CBaseInputPin::NonDelegatingQueryInterface(riid, ppv);
    }

} // NonDelegatingQueryInterface


//
// CheckConnect
//
HRESULT XBarInputPin::CheckConnect(IPin *pReceivePin)
{
    HRESULT hr = NOERROR;
    IKsPin *KsPin;
    BOOL fOK = FALSE;
    PIN_INFO ConnectPinInfo;
    PIN_INFO ReceivePinInfo;

    hr = CBaseInputPin::CheckConnect(pReceivePin);
    if (FAILED(hr)) 
        return hr;

    // Ensure that these pins don't belong to the same filter
    if (SUCCEEDED(QueryPinInfo(&ConnectPinInfo))) {

        if (SUCCEEDED(pReceivePin->QueryPinInfo(&ReceivePinInfo))) {

            if (ConnectPinInfo.pFilter == ReceivePinInfo.pFilter) {
                hr = VFW_E_CIRCULAR_GRAPH;
            }
            QueryPinInfoReleaseFilter(ReceivePinInfo);
        }
        QueryPinInfoReleaseFilter(ConnectPinInfo);
    }
    if (FAILED(hr))
        return hr;

    // If the receiving pin supports IKsPin, then check for a match on the
    // Medium GUID

	if (SUCCEEDED (hr = pReceivePin->QueryInterface (
            __uuidof (IKsPin), (void **) &KsPin))) {

        PKSMULTIPLE_ITEM MediumList = NULL;
        PKSPIN_MEDIUM Medium;

        if (SUCCEEDED (hr = KsPin->KsQueryMediums(&MediumList))) {
            if ((MediumList->Count == 1) && 
                (MediumList->Size == (sizeof(KSMULTIPLE_ITEM) + sizeof(KSPIN_MEDIUM)))) {

				Medium = reinterpret_cast<PKSPIN_MEDIUM>(MediumList + 1);
                if (IsEqualGUID (Medium->Set, m_Medium.Set) && 
                        Medium->Id == m_Medium.Id &&
                        Medium->Flags == m_Medium.Flags) {
					fOK = TRUE;
				}
			}

            CoTaskMemFree(MediumList);
        }
        
        KsPin->Release();
    }
    else {
        if (IsEqualGUID (GUID_NULL, m_Medium.Set)) { 
            fOK = TRUE;
        }
    }
    
    return fOK ? NOERROR : E_INVALIDARG;

} // CheckConnect

//
// DisplayMediaType -- (DEBUG ONLY)
//
void DisplayMediaType(TCHAR *pDescription,const CMediaType *pmt)
{
#ifdef DEBUG

    // Dump the GUID types and a short description

    DbgLog((LOG_TRACE,2,TEXT("")));
    DbgLog((LOG_TRACE,2,TEXT("%s"),pDescription));
    DbgLog((LOG_TRACE,2,TEXT("")));
    DbgLog((LOG_TRACE,2,TEXT("Media Type Description")));
    DbgLog((LOG_TRACE,2,TEXT("Major type %s"),GuidNames[*pmt->Type()]));
    DbgLog((LOG_TRACE,2,TEXT("Subtype %s"),GuidNames[*pmt->Subtype()]));
    DbgLog((LOG_TRACE,2,TEXT("Subtype description %s"),GetSubtypeName(pmt->Subtype())));
    DbgLog((LOG_TRACE,2,TEXT("Format size %d"),pmt->cbFormat));

    // Dump the generic media types */

    DbgLog((LOG_TRACE,2,TEXT("Fixed size sample %d"),pmt->IsFixedSize()));
    DbgLog((LOG_TRACE,2,TEXT("Temporal compression %d"),pmt->IsTemporalCompressed()));
    DbgLog((LOG_TRACE,2,TEXT("Sample size %d"),pmt->GetSampleSize()));

#endif

} // DisplayMediaType

#if 1
//
// GetMediaType
//
HRESULT XBarInputPin::GetMediaType(int iPosition,CMediaType *pMediaType)
{
    CAutoLock lock_it(m_pLock);

    if (iPosition < 0) 
        return E_INVALIDARG;
    if (iPosition >= 1)
	    return VFW_S_NO_MORE_ITEMS;

    if (m_lType >= KS_PhysConn_Audio_Tuner) {
        pMediaType->SetFormatType(&GUID_NULL);
        pMediaType->SetType(&MEDIATYPE_AnalogAudio);
        pMediaType->SetTemporalCompression(FALSE);
        pMediaType->SetSubtype(&GUID_NULL);
    }
    else {

        ANALOGVIDEOINFO avi;

        pMediaType->SetFormatType(&FORMAT_AnalogVideo);
        pMediaType->SetType(&MEDIATYPE_AnalogVideo);
        pMediaType->SetTemporalCompression(FALSE);
        pMediaType->SetSubtype(&KSDATAFORMAT_SUBTYPE_NONE);

        SetRect (&avi.rcSource, 0, 0, 
                720, 480);
        SetRect (&avi.rcTarget, 0, 0,
                720, 480);
        avi.dwActiveWidth  = 720;
        avi.dwActiveHeight =  480;
        avi.AvgTimePerFrame = 0;

        pMediaType->SetFormat ((BYTE *) &avi, sizeof (avi));
    }

    return NOERROR;


} // EnumMediaTypes

#endif

//
// CheckMediaType
//
HRESULT XBarInputPin::CheckMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);

    // If we are already inside checkmedia type for this pin, return NOERROR
    // It is possble to hookup two of the XBar filters and some other filter
    // like the video effects sample to get into this situation. If we don't
    // detect this situation, we will carry on looping till we blow the stack

    HRESULT hr = NOERROR;

    // Display the type of the media for debugging perposes
    DisplayMediaType(TEXT("Input Pin Checking"), pmt);

    if ((*(pmt->Type()) != MEDIATYPE_AnalogAudio ) && 
        (*(pmt->Type()) != MEDIATYPE_AnalogVideo)) {
        return VFW_E_TYPE_NOT_ACCEPTED;
    }


    // The media types that we can support are entirely dependent on the
    // downstream connections. If we have downstream connections, we should
    // check with them - walk through the list calling each output pin

    int n = m_pXBar->m_NumOutputPins;
    POSITION pos = m_pXBar->m_OutputPinsList.GetHeadPosition();

    while(n) {
        XBarOutputPin *pOutputPin = m_pXBar->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            if (m_pXBar->IsRouted (pOutputPin, this)) {      
                // The pin is connected, check its peer
                if (pOutputPin->IsConnected()) {
                    hr = pOutputPin->m_Connected->QueryAccept(pmt);
                
                    if (hr != NOERROR) {
                        return VFW_E_TYPE_NOT_ACCEPTED;
                    }
                }
            }
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }

    return NOERROR;

} // CheckMediaType


//
// SetMediaType
//
HRESULT XBarInputPin::SetMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);
    HRESULT hr = NOERROR;

    // Make sure that the base class likes it
    hr = CBaseInputPin::SetMediaType(pmt);
    if (FAILED(hr))
        return hr;

    ASSERT(m_Connected != NULL);
    return NOERROR;

} // SetMediaType


//
// BreakConnect
//
HRESULT XBarInputPin::BreakConnect()
{
    return CBaseInputPin::BreakConnect();
} // BreakConnect


//
// Receive
//
HRESULT XBarInputPin::Receive(IMediaSample *pSampleIn)
{
    CAutoLock lock_it(m_pLock);
    BYTE *pBufIn;

    // Check that all is well with the base class
    HRESULT hr = NOERROR;
    hr = CBaseInputPin::Receive(pSampleIn);
    if (hr != NOERROR)
        return hr;

    // Get the input sample's buffer pointer, and if not the expected size, just return success
    hr = pSampleIn->GetPointer(&pBufIn);
    if (hr != NOERROR || pSampleIn->GetActualDataLength() != sizeof(KS_TVTUNER_CHANGE_INFO))
        return hr;

    DbgLog(( LOG_TRACE, 4, TEXT("Caching change info (channel = %d)"), reinterpret_cast<KS_TVTUNER_CHANGE_INFO*>(pBufIn)->dwChannel));

    // Save the change info for use during route changes
    m_ChangeInfo.SetChangeInfo(reinterpret_cast<KS_TVTUNER_CHANGE_INFO*>(pBufIn));

    // Walk through the output pins list, 
    // delivering to each in turn if connected

    // JayBo made the following comment when writing this code:
    // "What about audio mute notifications?"
    // Don't know exactly what this means, but if it ever needs
    // to be addressed, this may be the place to do it.

    int n = m_pXBar->m_NumOutputPins;
    POSITION pos = m_pXBar->m_OutputPinsList.GetHeadPosition();

    while(n) {
        XBarOutputPin *pOutputPin = m_pXBar->m_OutputPinsList.GetNext(pos);
        
        if (pOutputPin != NULL) {
            if (m_pXBar->IsRouted(pOutputPin, this)) {
                IMediaSample *pSampleOut;

                // Allocate a new mediasample on the output pin and 
                // deliver it a copy of the change notification

                hr = pOutputPin->GetDeliveryBuffer(&pSampleOut, NULL, NULL, 0);
                
                if (!FAILED(hr)) {

                    BYTE *pBufOut;

                    // Get the output sample's buffer pointer
                    hr = pSampleOut->GetPointer(&pBufOut);
                    if (SUCCEEDED (hr)) {

                        hr = pSampleOut->SetActualDataLength(sizeof(KS_TVTUNER_CHANGE_INFO));
                        if (SUCCEEDED(hr)) {

                            DbgLog(( LOG_TRACE, 4, TEXT("Forwarding change info (channel = %d)"), reinterpret_cast<KS_TVTUNER_CHANGE_INFO*>(pBufIn)->dwChannel));

                            /* Copy the ChangeInfo structure into the media sample
                             */
                            memcpy(pBufOut, pBufIn, sizeof(KS_TVTUNER_CHANGE_INFO));
                            hr = pOutputPin->Deliver(pSampleOut);
                        }
                    }

                    pSampleOut->Release();

                    //
                    // Perform the mute operation on a related audio pin
                    //
                    pOutputPin->Mute (
                                ((PKS_TVTUNER_CHANGE_INFO) pBufIn)->dwFlags &
                                KS_TVTUNER_CHANGE_BEGIN_TUNE);
                }
            }
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return NOERROR;

} // Receive


//
// Completed a connection to a pin
//
HRESULT XBarInputPin::CompleteConnect(IPin *pReceivePin)
{
    HRESULT hr = CBaseInputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr)) {
        return hr;
    }

    // Force any output pins to use our type

    int n = m_pXBar->m_NumOutputPins;
    POSITION pos = m_pXBar->m_OutputPinsList.GetHeadPosition();

    while(n) {
        XBarOutputPin *pOutputPin = m_pXBar->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            // Check with downstream pin
            if (m_pXBar->IsRouted (pOutputPin, this)) {
                if (m_mt != pOutputPin->m_mt) {
                    hr = m_pXBar->m_pGraph->Reconnect(pOutputPin);
                    if (FAILED (hr)) {
                        DbgLog((LOG_TRACE,0,TEXT("XBar::CompleteConnect: hr= %ld"), hr));
                    }
                }
            }
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return S_OK;
}

//
// Return a list of IPin * connected to a given pin
//

STDMETHODIMP XBarInputPin::QueryInternalConnections(
        IPin* *apPin,     // array of IPin*
        ULONG *nPin)      // on input, the number of slots
                          // on output  the number of pins
{
    HRESULT     hr;
    int         j, k; 
    ULONG       NumberConnected = 0;
    IPin       *pPin;

    // First count the number of connections

    for (j = 0; j < m_pXBar->m_NumOutputPins; j++) {
        if (m_pXBar->IsRouted (m_pXBar->GetOutputPinNFromList (j), (IPin *) this)) {
            NumberConnected++;
        }
    }

    //
    // if caller only want the count of the number of connected pins
    // the array pointer will be NULL
    //

    if (apPin == NULL) {
        hr = S_OK;
    }
    else if (*nPin >= NumberConnected) {
        for (j = k = 0; j < m_pXBar->m_NumOutputPins; j++) {
            if (m_pXBar->IsRouted (pPin = m_pXBar->GetOutputPinNFromList (j), (IPin *) this)) {
                pPin->AddRef();
                apPin[k] = pPin;
                k++;
            }
        }
        hr = S_OK;        
    }
    else {
        hr = S_FALSE;
    }

    *nPin = NumberConnected;

    return hr;
}

//--------------------------------------------------------------------------;
// Output Pin
//--------------------------------------------------------------------------;

//
// XBarOutputPin constructor
//
XBarOutputPin::XBarOutputPin(TCHAR *pName,
                             XBar *pXBar,
                             HRESULT *phr,
                             LPCWSTR pPinName,
                             long Index) 
	: CBaseOutputPin(pName, pXBar, pXBar, phr, pPinName) 
    , CKsSupport (KSPIN_COMMUNICATION_SOURCE, reinterpret_cast<LPUNKNOWN>(pXBar))
    , m_Index(Index)
	, m_pXBar(pXBar)
    , m_Muted (FALSE)
{
    ASSERT(pXBar);

    m_Medium.Set = GUID_NULL;
    m_Medium.Id = 0;
    m_Medium.Flags = 0;
}


//
// XBarOutputPin destructor
//
XBarOutputPin::~XBarOutputPin()
{
}

//
// NonDelegatingQueryInterface
//
STDMETHODIMP XBarOutputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv) {

    if (riid == __uuidof (IKsPin)) {
        return GetInterface((IKsPin *) this, ppv);
    }
    else if (riid == __uuidof (IKsPropertySet)) {
        return GetInterface((IKsPropertySet *) this, ppv);
    }
    else {
        return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }

} // NonDelegatingQueryInterface

//
// CheckConnect
//
HRESULT XBarOutputPin::CheckConnect(IPin *pReceivePin)
{
    HRESULT hr = NOERROR;
    IKsPin *KsPin;
    BOOL fOK = FALSE;
    PIN_INFO ConnectPinInfo;
    PIN_INFO ReceivePinInfo;

    hr = CBaseOutputPin::CheckConnect(pReceivePin);
    if (FAILED(hr)) 
        return hr;

    // Ensure that these pins don't belong to the same filter
    if (SUCCEEDED(QueryPinInfo(&ConnectPinInfo))) {

        if (SUCCEEDED(pReceivePin->QueryPinInfo(&ReceivePinInfo))) {

            if (ConnectPinInfo.pFilter == ReceivePinInfo.pFilter) {
                hr = VFW_E_CIRCULAR_GRAPH;
            }
            QueryPinInfoReleaseFilter(ReceivePinInfo);
        }
        QueryPinInfoReleaseFilter(ConnectPinInfo);
    }
    if (FAILED(hr))
        return hr;

    // If the receiving pin supports IKsPin, then check for a match on the
    // Medium GUID

	if (SUCCEEDED (hr = pReceivePin->QueryInterface (
            __uuidof (IKsPin), (void **) &KsPin))) {

        PKSMULTIPLE_ITEM MediumList = NULL;
        PKSPIN_MEDIUM Medium;

        if (SUCCEEDED (hr = KsPin->KsQueryMediums(&MediumList))) {
            if ((MediumList->Count == 1) && 
                (MediumList->Size == (sizeof(KSMULTIPLE_ITEM) + sizeof(KSPIN_MEDIUM)))) {

				Medium = reinterpret_cast<PKSPIN_MEDIUM>(MediumList + 1);
                if (IsEqualGUID (Medium->Set, m_Medium.Set) && 
                        Medium->Id == m_Medium.Id &&
                        Medium->Flags == m_Medium.Flags) {
					fOK = TRUE;
				}
			}

            CoTaskMemFree(MediumList);
        }
        
        KsPin->Release();
    }
    else {
        if (IsEqualGUID (GUID_NULL, m_Medium.Set)) { 
            fOK = TRUE;
        }
    }
    
    return fOK ? NOERROR : E_INVALIDARG;

} // CheckConnect

//
// CheckMediaType
//
HRESULT XBarOutputPin::CheckMediaType(const CMediaType *pmt)
{
    // Display the type of the media for debugging purposes
    DisplayMediaType(TEXT("Output Pin Checking"), pmt);

    if (m_lType >= KS_PhysConn_Audio_Tuner) {
        if (*(pmt->Type()) != MEDIATYPE_AnalogAudio)	{
        	return E_INVALIDARG;
		}
    }
    else {
        if (*(pmt->Type()) != MEDIATYPE_AnalogVideo) {
        	return E_INVALIDARG;
    	}
	}

    return S_OK;  // This format is acceptable.

#if 0

    // Make sure that our input pin peer is happy with this
    hr = m_pXBar->m_Input.m_Connected->QueryAccept(pmt);
    if (hr != NOERROR) {
        m_bInsideCheckMediaType = FALSE;
        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    // Check the format with the other outpin pins

    int n = m_pXBar->m_NumOutputPins;
    POSITION pos = m_pXBar->m_OutputPinsList.GetHeadPosition();

    while(n) {
        XBarOutputPin *pOutputPin = m_pXBar->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL && pOutputPin != this) {
            if (pOutputPin->m_Connected != NULL) {
                // The pin is connected, check its peer
                hr = pOutputPin->m_Connected->QueryAccept(pmt);
                if (hr != NOERROR) {
                    m_bInsideCheckMediaType = FALSE;
                    return VFW_E_TYPE_NOT_ACCEPTED;
                }
            }
        }
        n--;
    }
    m_bInsideCheckMediaType = FALSE;

    return NOERROR;

#endif

} // CheckMediaType


//
// EnumMediaTypes
//
STDMETHODIMP XBarOutputPin::EnumMediaTypes(IEnumMediaTypes **ppEnum)
{
    CAutoLock lock_it(m_pLock);
    ASSERT(ppEnum);

    return CBaseOutputPin::EnumMediaTypes (ppEnum);

} // EnumMediaTypes



//
// GetMediaType
//
HRESULT XBarOutputPin::GetMediaType(int iPosition,CMediaType *pMediaType)
{
    CAutoLock lock_it(m_pLock);

    if (iPosition < 0) 
        return E_INVALIDARG;
    if (iPosition >= 1)
	    return VFW_S_NO_MORE_ITEMS;

    if (m_lType >= KS_PhysConn_Audio_Tuner) {
        pMediaType->SetFormatType(&GUID_NULL);
        pMediaType->SetType(&MEDIATYPE_AnalogAudio);
        pMediaType->SetTemporalCompression(FALSE);
        pMediaType->SetSubtype(&GUID_NULL);
    }
    else {

        ANALOGVIDEOINFO avi;

        pMediaType->SetFormatType(&FORMAT_AnalogVideo);
        pMediaType->SetType(&MEDIATYPE_AnalogVideo);
        pMediaType->SetTemporalCompression(FALSE);
        pMediaType->SetSubtype(&KSDATAFORMAT_SUBTYPE_NONE);

        SetRect (&avi.rcSource, 0, 0, 
                720, 480);
        SetRect (&avi.rcTarget, 0, 0,
                720, 480);
        avi.dwActiveWidth  = 720;
        avi.dwActiveHeight =  480;
        avi.AvgTimePerFrame = 0;

        pMediaType->SetFormat ((BYTE *) &avi, sizeof (avi));
    }

    return NOERROR;


} // EnumMediaTypes


//
// SetMediaType
//
HRESULT XBarOutputPin::SetMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);

    // Display the format of the media for debugging purposes
    DisplayMediaType(TEXT("Output pin type agreed"), pmt);

    // Make sure that the base class likes it
    HRESULT hr = NOERROR;
    hr = CBaseOutputPin::SetMediaType(pmt);
    if (FAILED(hr))
        return hr;

    return NOERROR;

} // SetMediaType


//
// CompleteConnect
//
HRESULT XBarOutputPin::CompleteConnect(IPin *pReceivePin)
{
    CAutoLock lock_it(m_pLock);
    ASSERT(m_Connected == pReceivePin);
    HRESULT hr = NOERROR;

    hr = CBaseOutputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr))
        return hr;

    // If the type is not the same as that stored for the input
    // pin then force the input pins peer to be reconnected

    return NOERROR;

} // CompleteConnect


HRESULT XBarOutputPin::DecideBufferSize(IMemAllocator *pAlloc,
                                       ALLOCATOR_PROPERTIES *pProperties)
{
    CAutoLock lock_it(m_pLock);
    ASSERT(pAlloc);
    ASSERT(pProperties);
    HRESULT hr = NOERROR;


    // "Buffers" are used for format change notification only,
    // that is, if a tuner can produce both NTSC and PAL, a
    // buffer will only be sent to notify the receiving pin
    // of the format change

    pProperties->cbBuffer = sizeof (KS_TVTUNER_CHANGE_INFO);
    pProperties->cBuffers = 1;

    // Ask the allocator to reserve us the memory

    ALLOCATOR_PROPERTIES Actual;
    hr = pAlloc->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        return hr;
    }

    // Is this allocator unsuitable

    if (Actual.cbBuffer < pProperties->cbBuffer) {
        return E_FAIL;
    }
    return NOERROR;
}

//
// Return a list of IPin * connected to a given pin
//

STDMETHODIMP XBarOutputPin::QueryInternalConnections(
        IPin* *apPin,     // array of IPin*
        ULONG *nPin)      // on input, the number of slots
                          // on output  the number of pins
{
    HRESULT     hr;
    int         j, k; 
    ULONG       NumberConnected = 0;
    IPin       *pPin;

    // First count the number of connections

    for (j = 0; j < m_pXBar->m_NumInputPins; j++) {
        if (m_pXBar->IsRouted (m_pXBar->GetInputPinNFromList (j), (IPin *) this)) {
            NumberConnected++;
        }
    }

    //
    // if caller only want the count of the number of connected pins
    // the array pointer will be NULL
    //

    if (apPin == NULL) {
        hr = S_OK;
    }
    else if (*nPin >= NumberConnected) {
        for (j = k = 0; j < m_pXBar->m_NumInputPins; j++) {
            if (m_pXBar->IsRouted (pPin = m_pXBar->GetInputPinNFromList (j), (IPin *) this)) {
                pPin->AddRef();
                apPin[k] = pPin;
                k++;
            }
        }
        hr = S_OK;        
    }
    else {
        hr = S_FALSE;
    }

    *nPin = NumberConnected;

    return hr;
}

//
// BreakConnect
//
HRESULT XBarOutputPin::BreakConnect()
{
    Mute (TRUE);

    return CBaseOutputPin::BreakConnect();
} // BreakConnect

//
// Given a pin, mute or unmute
//

STDMETHODIMP 
XBarOutputPin::Mute (
    BOOL Mute
)
{
    HRESULT hr = S_OK;

    // In case we get called twice (ie. during filter destruction)

    if (m_Muted == Mute) {
        return hr;
    }

    m_Muted = Mute;

    if (IsVideoPin (this)) {
        XBarOutputPin * RelatedPin = m_pXBar->GetOutputPinNFromList (m_IndexRelatedPin);

        if (RelatedPin) {
            if (IsAudioPin (RelatedPin)) {
                RelatedPin->Mute (Mute);
            }
        }
    }
    else if (IsAudioPin (this)) {
        if (Mute) {
            m_pXBar->get_IsRoutedTo (m_Index, &m_PreMuteRouteIndex);
            m_pXBar->RouteInternal (m_Index, -1, FALSE);
        }
        else {
            m_pXBar->RouteInternal (m_Index, m_PreMuteRouteIndex, FALSE);
        }
    }
    else {
        ASSERT (FALSE);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\xbar\tvaudio.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1997  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef __TVAUDIO__
#define __TVAUDIO__

#define MODE_MONO_STEREO_MASK (KS_TVAUDIO_MODE_MONO | KS_TVAUDIO_MODE_STEREO)
#define MODE_LANGUAGE_MASK (KS_TVAUDIO_MODE_LANG_A | KS_TVAUDIO_MODE_LANG_B | KS_TVAUDIO_MODE_LANG_C )

class TVAudio;
class TVAudioOutputPin;
class TVAudioInputPin;

// class for the TVAudio filter's Input pin

class TVAudioInputPin 
	: public CBaseInputPin
	, public CKsSupport
{
protected:
    TVAudio     *m_pTVAudio;                  // Main filter object
	KSPIN_MEDIUM m_Medium;

public:

    // Constructor and destructor
    TVAudioInputPin(TCHAR *pObjName,
                 TVAudio *pTVAudio,
                 HRESULT *phr,
                 LPCWSTR pPinName);

    ~TVAudioInputPin();

	STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);


    // Used to check the input pin connection
    HRESULT CheckConnect (IPin *pReceivePin);
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT BreakConnect();

    // Reconnect outputs if necessary at end of completion
    virtual HRESULT CompleteConnect(IPin *pReceivePin);

    // Handles the next block of data from the stream
    STDMETHODIMP Receive(IMediaSample *pSample);

    void SetPinMedium (const KSPIN_MEDIUM *Medium)    
            {
                if (Medium == NULL) {
                    m_Medium.Set = GUID_NULL;
                    m_Medium.Id = 0;
                    m_Medium.Flags = 0;
                }
                else {
                    m_Medium = *Medium;
                }
                SetKsMedium (&m_Medium);
            };
};


// Class for the TVAudio filter's Output pins.

class TVAudioOutputPin 
	: public CBaseOutputPin
	, public CKsSupport
{
    friend class TVAudioInputPin;
    friend class TVAudio;

protected:
    TVAudio     *m_pTVAudio;                          // Main filter object pointer
	KSPIN_MEDIUM m_Medium;

public:

    // Constructor and destructor

    TVAudioOutputPin(TCHAR *pObjName,
                   TVAudio *pTVAudio,
                   HRESULT *phr,
                   LPCWSTR pPinName);

    ~TVAudioOutputPin();

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);


    HRESULT DecideBufferSize(IMemAllocator * pAlloc,ALLOCATOR_PROPERTIES * ppropInputRequest);

    // Override to enumerate media types
    STDMETHODIMP EnumMediaTypes(IEnumMediaTypes **ppEnum);
    HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);

    // Check that we can support an output type
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);

    // Overriden to create and destroy output pins
    HRESULT CheckConnect (IPin *pReceivePin);
    HRESULT CompleteConnect(IPin *pReceivePin);

    void SetPinMedium (const KSPIN_MEDIUM *Medium)    
            {
                if (Medium == NULL) {
                    m_Medium.Set = GUID_NULL;
                    m_Medium.Id = 0;
                    m_Medium.Flags = 0;
                }
                else {
                    m_Medium = *Medium;
                }
                SetKsMedium (&m_Medium);
            };

};


// Class for the TVAudio filter

class TVAudio: 
    public CCritSec, 
    public IAMTVAudio,
    public CBaseFilter,
    public CPersistStream,
    public IPersistPropertyBag,
    public ISpecifyPropertyPages
{

public:

    DECLARE_IUNKNOWN;

    // Basic COM - used here to reveal our property interface.
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // Function needed for the class factory
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    //
    // --- IAMTVAudio ---
    //
    STDMETHODIMP GetHardwareSupportedTVAudioModes( 
            /* [out] */ long __RPC_FAR *plModes);

    STDMETHODIMP GetAvailableTVAudioModes( 
            /* [out] */ long __RPC_FAR *plModes);
        
    STDMETHODIMP  get_TVAudioMode( 
            /* [out] */ long __RPC_FAR *plMode);
        
    STDMETHODIMP  put_TVAudioMode( 
            /* [in] */ long lMode);
        
    STDMETHODIMP  RegisterNotificationCallBack( 
            /* [in] */ IAMTunerNotification __RPC_FAR *pNotify,
            /* [in] */ long lEvents);
        
    STDMETHODIMP  UnRegisterNotificationCallBack( 
            IAMTunerNotification __RPC_FAR *pNotify);


    // --- IPersistPropertyBag ---
    STDMETHODIMP InitNew(void) ;
    STDMETHODIMP Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog) ;
    STDMETHODIMP Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties) ;
    STDMETHODIMP GetClassID(CLSID *pClsId) ;

    //
    // --- CPersistStream ---
    //

    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    DWORD GetSoftwareVersion(void);
    int SizeMax();

    //
    // --- ISpecifyPropertyPages ---
    //

    STDMETHODIMP GetPages(CAUUID *pPages);



private:

    // Let the pins access our internal state
    friend class TVAudioInputPin;
    friend class TVAudioOutputPin;

    TVAudioInputPin            *m_pTVAudioInputPin;
    TVAudioOutputPin           *m_pTVAudioOutputPin;
    KSPROPERTY_TVAUDIO_CAPS_S   m_Caps;
    KSPROPERTY_TVAUDIO_S        m_Mode;

    // KS Stuff.
    HANDLE m_hDevice;              
    TCHAR *m_pDeviceName;
    int CreateDevice(void);
    BOOL CreatePins ();

    TVAudio(TCHAR *pName,LPUNKNOWN pUnk,HRESULT *hr);
    ~TVAudio();

    CBasePin *GetPin(int n);

    int GetPinCount(void);

    int GetDevicePinCount(void);

    // persist stream saved from  IPersistPropertyBag::Load
    IPersistStream *m_pPersistStreamDevice;

};

#endif // __TVAUDIO__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avidest\test\srcfltr\ball.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// CBall
//
// Plots a ball into a supplied image buufer.

// The buffer is DIB byte array.


class CBall {
public:

    CBall(int iImageWidth = 320, int iImageHeight = 240, int iBallSize = 10);

    // Plots the square ball in the image buffer, at the current location.
    // Use BallPixel[] as pixel value for the ball.
    // Plots zero in all 'background' image locations.
    // iPixelSize - the number of bytes in a pixel (size of BallPixel[])
    void PlotBall(BYTE pFrame[], BYTE BallPixel[], int iPixelSize);

    // Moves the ball 1 pixel in each of the x and y directions
    void MoveBall(CRefTime rt);

private:

    int m_iImageHeight, m_iImageWidth;		// the image dimentions
    int m_iAvailableHeight, m_iAvailableWidth;	// the dimentions we can plot in, allowing for the width of the ball
    int m_iBallSize;				// the diameter of the ball

    // For a bit of randomness
    int m_iRandX, m_iRandY;


    int m_x;	// the x position, in pixels, of the ball in the frame. 0 < x < m_iAvailableWidth
    int m_y;	// the y position, in pixels, of the ball in the frame. 0 < y < m_iAvailableHeight

    enum xdir { LEFT = -1, RIGHT = 1 };
    enum ydir { UP = 1, DOWN = -1 };

    xdir m_xDir;	// the direction the ball is currently heading in
    ydir m_yDir;	//

    // Return the 1-dimensional position of the ball at time t millisecs
    int  BallPosition(int iPixelTime, int iLength, int time, int iOffset);

    /// tests a given pixel to see if it should be plotted
    BOOL WithinCircle(int x, int y);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avidest\test\srcfltr\ballprop.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// ballprop.cpp
//

#include <streams.h>
#include <olectl.h>
#include <memory.h>

#include "resource.h"
#include "balluids.h"
#include "ball.h"
#include "fball.h"
#include "ballprop.h"

// *
// * CBallProperties
// *


//
// CreateInstance
//
CUnknown *CBallProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CBallProperties(lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
}


//
// CBallProperties::Constructor
//
// initialise a CBallProperties object.
CBallProperties::CBallProperties(LPUNKNOWN lpunk, HRESULT *phr)
    : CUnknown(NAME("Ball Property Page"), lpunk)
    , m_hwnd(NULL) {

}


//
// NonDelegatingQueryInterface
//
// Reveal our property page
STDMETHODIMP CBallProperties::NonDelegatingQueryInterface(REFIID riid, void **ppv) {

    if (riid == IID_IPropertyPage) {
        return GetInterface((IPropertyPage *) this, ppv);
    } else {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


//
// GetPageInfo
//
// set the page info so that the page site can size itself, etc
STDMETHODIMP CBallProperties::GetPageInfo(LPPROPPAGEINFO pPageInfo) {

    WCHAR szTitle[] = L"Bouncing Ball";

    LPOLESTR pszTitle = (LPOLESTR) CoTaskMemAlloc(sizeof(szTitle));
    memcpy(pszTitle, &szTitle, sizeof(szTitle));

    pPageInfo->cb		= sizeof(PROPPAGEINFO);
    pPageInfo->pszTitle		= pszTitle;
    pPageInfo->size.cx		= 90;
    pPageInfo->size.cy		= 40;
    pPageInfo->pszDocString	= NULL;
    pPageInfo->pszHelpFile	= NULL;
    pPageInfo->dwHelpContext	= 0;

    return NOERROR;

}


//
// DialogProc
//
// Handles the messages for our property window
BOOL CALLBACK CBallProperties::DialogProc( HWND hwnd
					 , UINT uMsg
					 , WPARAM wParam
					 , LPARAM lParam) {
    switch (uMsg) {
    case WM_INITDIALOG:
        return TRUE;	// I don't call setfocus...
    default:
        return FALSE;

    }
}


//
// Activate
//
// Create the window we will use to edit properties
STDMETHODIMP CBallProperties::Activate(HWND hwndParent, LPCRECT prect, BOOL fModal) {

    m_hwnd = CreateDialog( g_hInst
    			 , MAKEINTRESOURCE(IDD_BALLPROP)
			 , hwndParent
			 , DialogProc
			 );

    if (m_hwnd == NULL) {
        DWORD dwErr = GetLastError();
        DbgLog((LOG_ERROR, 1, TEXT("Could not create window: 0x%x"), dwErr));
        return E_FAIL;
    }

    return Move(prect);
}


//
// Show
//
// Display the property dialog
STDMETHODIMP CBallProperties::Show(UINT nCmdShow) {

    if (m_hwnd == NULL) {
        return E_UNEXPECTED;
    }

    ShowWindow(m_hwnd, nCmdShow);
    InvalidateRect(m_hwnd, NULL, TRUE);

    return NOERROR;
}


//
// Deactivate
//
// Destroy the dialog
STDMETHODIMP CBallProperties::Deactivate(void) {

    if (m_hwnd == NULL) {
        return E_UNEXPECTED;
    }

    if (DestroyWindow(m_hwnd)) {
        m_hwnd = NULL;
        return NOERROR;
    }
    else {
        return E_FAIL;
    }
}


//
// Move
//
// put the property page over its home in the parent frame.
STDMETHODIMP CBallProperties::Move(LPCRECT prect) {

    if (m_hwnd == NULL) {
        return(E_UNEXPECTED);
    }

    if (prect == NULL) {
        return(E_POINTER);
    }

    if (MoveWindow( m_hwnd
                  , prect->left
                  , prect->top
                  , prect->right - prect->left
                  , prect->bottom - prect->top
                  , TRUE		// send WM_PAINT
                  ) ) {
        return NOERROR;
    }
    else {
        return E_FAIL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avidest\test\srcfltr\ballprop.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// BallProp.h
//
//
// CBallProperties
//
class CBallProperties : public CUnknown,
			public IPropertyPage {

public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    DECLARE_IUNKNOWN;

    // override this to reveal our property interface
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    STDMETHODIMP SetPageSite(LPPROPERTYPAGESITE pPageSite)	{ return NOERROR; }
    STDMETHODIMP Activate(HWND hwndParent, LPCRECT prect, BOOL fModal);
    STDMETHODIMP Deactivate(void);
    STDMETHODIMP GetPageInfo(LPPROPPAGEINFO pPageInfo);
    STDMETHODIMP SetObjects(ULONG cObjects, LPUNKNOWN FAR* ppunk)	{ return NOERROR; }
    STDMETHODIMP Show(UINT nCmdShow);
    STDMETHODIMP Move(LPCRECT prect);
    STDMETHODIMP IsPageDirty(void) 			{ return S_FALSE; }
    STDMETHODIMP Apply(void)				{ return NOERROR; }
    STDMETHODIMP Help(LPCWSTR lpszHelpDir)		{ return E_NOTIMPL; }
    STDMETHODIMP TranslateAccelerator(LPMSG lpMsg)	{ return E_NOTIMPL; }

private:

    CBallProperties(LPUNKNOWN lpunk, HRESULT *phr);

    static BOOL CALLBACK DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HWND		m_hwnd;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avidest\test\srcfltr\fball.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// Bouncing Ball Source filter...
//

// Uses CSource & CSourceStream to generate a movie on the fly of a
// bouncing ball...

class CBallStream; // The class managing the output pin.

//
// CBouncingBall
//
// CBouncingBall manages filter level stuff
class CBouncingBall : public ISpecifyPropertyPages,
		      public CSource {

public:

    // The only allowed way to create Bouncing ball's!
    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
    ~CBouncingBall();

    DECLARE_IUNKNOWN;

    // override this to reveal our property interface
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // --- ISpecifyPropertyPages ---

    // return our property pages
    STDMETHODIMP GetPages(CAUUID * pPages);

    // setup helper
    LPAMOVIESETUP_FILTER GetSetupData();

private:

    // it is only allowed to to create these objects with CreateInstance
    CBouncingBall(LPUNKNOWN lpunk, HRESULT *phr);

};


//
// CBallStream
//
// CBallStream manages the data flow from the output pin.
class CBallStream : public CSourceStream {

public:

    CBallStream(HRESULT *phr, CBouncingBall *pParent, LPCWSTR pPinName);
    ~CBallStream();

    // plots a ball into the supplied video frame.
    HRESULT FillBuffer(IMediaSample *pms);

    // Ask for buffers of the size appropriate to the agreed media type.
    HRESULT DecideBufferSize(IMemAllocator *pIMemAlloc,
                             ALLOCATOR_PROPERTIES *pProperties);

    // Set the agreed media type, and set up the necessary ball
    // parameters that depend on the media type, ie BallPixel[], iPixelSize, etc.
    HRESULT SetMediaType(const CMediaType *pMediaType);

    // because we calculate the ball there is no reason why we can't calculate it in
    // any one of a set of formats...
    HRESULT CheckMediaType(const CMediaType *pMediaType);
    HRESULT GetMediaType(int iPosition, CMediaType *pmt);

    // resets the stream time to zero.
    HRESULT OnThreadCreate(void);

    // Quality control notifications sent to us
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);

private:

    // Access to this state information should be serialized with the filters
    // critical section (m_pFilter->pStateLock())

    int m_iImageHeight;	// the current image dimentions
    int m_iImageWidth;	//
    int m_iRepeatTime;  // Time in msec between frames
    const int m_iDefaultRepeatTime; // Initial m_iRepeatTime

    enum Colour {Red, Blue, Green, Yellow};
    HRESULT SetPaletteEntries(Colour colour);	// set up the palette appropriately

    BYTE	m_BallPixel[4];	// The byte array that represents one ball coloured pixel in the frame
    int		m_iPixelSize;	// The pixel size in bytes - the number of valid entries in m_BallPixel
    PALETTEENTRY	m_Palette[iPALETTE_COLORS];	// The optimal palette for the image.


    CCritSec	m_cSharedState;	// use this to lock access to m_rtSampleTime and m_Ball which are
    				// shared with the worker thread.


    BOOL m_bZeroMemory;             // do we need to clear the output buffer

    CRefTime 	m_rtSampleTime;	// The time to be stamped on each sample
    CBall	*m_Ball;	// the current ball.
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avidest\test\srcfltr\balluids.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// uuids.h


// ball interface i'ds

//CLSID_BouncingBall
//{fd501041-8ebe-11ce-8183-00aa00577da1}
DEFINE_GUID(CLSID_BouncingBall,
0xfd501041, 0x8ebe, 0x11ce, 0x81, 0x83, 0x00, 0xaa, 0x00, 0x57, 0x7d, 0xa1);


// CLSID_BallPropertyPage
// {fd501042-8ebe-11ce-8183-00aa00577da1}
DEFINE_GUID(CLSID_BallPropertyPage,
0xfd501042, 0x8ebe, 0x11ce, 0x81, 0x83, 0x00, 0xaa, 0x00, 0x57, 0x7d, 0xa1);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avidest\test\srcfltr\resource.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// Used by ballprop.rc
//
#define IDD_BALLPROP                    101
#define IDS_STATIC                      -1
#define IDS_VERSION                     102
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avidest\test\srcfltr\fball.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// Bouncing Ball Source filter
//

// Uses CSource & CSourceStream to generate a movie on the fly of a
// bouncing ball...

#include <streams.h>
#include <olectl.h>
#include <initguid.h>
#include <olectlid.h>

#include "balluids.h"
#include "ball.h"
#include "fball.h"
#include "ballprop.h"

// setup data

AMOVIESETUP_MEDIATYPE sudOpPinTypes = { &MEDIATYPE_Video      // clsMajorType
                                      , &MEDIASUBTYPE_NULL }; // clsMinorType

AMOVIESETUP_PIN sudOpPin = { L"Output"          // strName
                           , FALSE              // bRendered
                           , TRUE               // bOutput
                           , FALSE              // bZero
                           , FALSE              // bMany
                           , &CLSID_NULL        // clsConnectsToFilter
                           , NULL               // strConnectsToPin
                           , 1                  // nTypes
                           , &sudOpPinTypes };  // lpTypes

AMOVIESETUP_FILTER sudBallax = { &CLSID_BouncingBall  // clsID
                                , L"Bouncing Ball"    // strName
                                , MERIT_UNLIKELY      // dwMerit
                                , 1                   // nPins
                                , &sudOpPin };        // lpPin

// COM global table of objects in this dll
CFactoryTemplate g_Templates[] = {
  { L"Bouncing Ball"     , &CLSID_BouncingBall    , CBouncingBall::CreateInstance },
  { L"Ball Property Page", &CLSID_BallPropertyPage, CBallProperties::CreateInstance }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);


// exported entry points for registration and
// unregistration (in this case they only call
// through to default implmentations).
//
STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer();
}

STDAPI DllUnregisterServer()
{
  return AMovieDllUnregisterServer();
}


//
// CreateInstance
//
// The only allowed way to create Bouncing ball's!
CUnknown *CBouncingBall::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CBouncingBall(lpunk, phr);
    if (punk == NULL) {

        *phr = E_OUTOFMEMORY;
    }

    return punk;
}


//
// CBouncingBall::Constructor
//
// initialise a CBallStream object so that we have a pin.
CBouncingBall::CBouncingBall(LPUNKNOWN lpunk, HRESULT *phr)
    : CSource(NAME("Bouncing ball Filter"),lpunk, CLSID_BouncingBall, phr) {

    CAutoLock l(&m_cStateLock);

    m_paStreams    = (CSourceStream **) new CBallStream*[1];
    if (m_paStreams == NULL) {
        *phr = E_OUTOFMEMORY;
	return;
    }

    m_paStreams[0] = new CBallStream(phr, this, L"A Bouncing Ball!");
    if (m_paStreams[0] == NULL) {
        *phr = E_OUTOFMEMORY;
	return;
    }

    MessageBeep(0xffffffff);

}


//
// CBouncingBall::Destructor
//
CBouncingBall::~CBouncingBall(void) {
    //
    //  Base class will free our pins
    //
}


//
// NonDelegatingQueryInterface
//
// Reveal our property pages
STDMETHODIMP CBouncingBall::NonDelegatingQueryInterface(REFIID riid, void **ppv) {

    CAutoLock l(&m_cStateLock);

    if (riid == IID_ISpecifyPropertyPages)
        return GetInterface((ISpecifyPropertyPages *) this, ppv);

    return CSource::NonDelegatingQueryInterface(riid, ppv);
}


//
// GetPages
//
STDMETHODIMP CBouncingBall::GetPages(CAUUID * pPages) {

    CAutoLock l(&m_cStateLock);

    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }
    *(pPages->pElems) = CLSID_BallPropertyPage;

    return NOERROR;

}


//
// GetSetupData
//
LPAMOVIESETUP_FILTER CBouncingBall::GetSetupData()
{
  return &sudBallax;
}

// *
// * CBallStream
// *


//
// CBallStream::Constructor
//
// Create a default ball
CBallStream::CBallStream(HRESULT *phr, CBouncingBall *pParent, LPCWSTR pPinName)
    : CSourceStream(NAME("Bouncing Ball output pin manager"),phr, pParent, pPinName)
    , m_iImageWidth(320)
    , m_iImageHeight(240)
    , m_iDefaultRepeatTime(33) { // 30 frames per second

    CAutoLock l(&m_cSharedState);

    m_Ball = new CBall(m_iImageWidth, m_iImageHeight);
    if (m_Ball == NULL) {
        *phr = E_OUTOFMEMORY;
        return;
    }
}


//
// CBallStream::Destructor
//
CBallStream::~CBallStream(void) {

    CAutoLock l(&m_cSharedState);

    delete m_Ball;
}


//
// FillBuffer
//
// plots a ball into the supplied video buffer
HRESULT CBallStream::FillBuffer(IMediaSample *pms) {

    BYTE	*pData;
    long	lDataLen;

    pms->GetPointer(&pData);
    lDataLen = pms->GetSize();

    if( m_bZeroMemory )
        // If true then we clear the output buffer and don't attempt to
        // erase a previous drawing of the ball
        ZeroMemory( pData, lDataLen );

    {
        CAutoLock lShared(&m_cSharedState);

        // If we haven't just cleared the buffer delete the old
        // ball and move the ball on

        if( !m_bZeroMemory ){
            BYTE aZeroes[ 4 ] = { 0, 0, 0, 0 };

            m_Ball->PlotBall(pData, aZeroes, m_iPixelSize);
            m_Ball->MoveBall(m_rtSampleTime - (LONG) m_iRepeatTime);
        }

        m_Ball->PlotBall(pData, m_BallPixel, m_iPixelSize);

        CRefTime rtStart  = m_rtSampleTime;		// the current time is the sample's start
        m_rtSampleTime   += (LONG)m_iRepeatTime;        // increment to find the finish time
                                                        // (adding mSecs to ref time)
        pms->SetTime((REFERENCE_TIME *) &rtStart,
                     (REFERENCE_TIME *) &m_rtSampleTime);

    }

    m_bZeroMemory = FALSE;

    pms->SetSyncPoint(TRUE);
    // pms->SetDiscontinuity(FALSE);
    // pms->SetPreroll(FALSE);

    return NOERROR;
}


//
// Notify
//
// Alter the repeat rate.  Wind it up or down according to the flooding level
// Skip forward if we are notified of Late-ness
STDMETHODIMP CBallStream::Notify(IBaseFilter * pSender, Quality q) {

    // Adjust the repeat rate.
    if (q.Proportion<=0) {

        m_iRepeatTime = 1000;        // We don't go slower than 1 per second
    }
    else {

        m_iRepeatTime = m_iRepeatTime*1000/q.Proportion;
        DbgLog(( LOG_TRACE, 1, TEXT("New time: %d, Proportion: %d")
               , m_iRepeatTime, q.Proportion));

        if (m_iRepeatTime>1000) {
            m_iRepeatTime = 1000;    // We don't go slower than 1 per second
        }
        else if (m_iRepeatTime<10) {
            m_iRepeatTime = 10;      // We don't go faster than 100/sec
        }
    }

    // skip forwards
    if (q.Late > 0) {
        m_rtSampleTime += q.Late;
    }

    return NOERROR;
}



//
// Format Support
//
// I _prefer_ 5 formats - 8, 16 (*2), 24 or 32 bits per pixel and
// I will suggest these with an image size of 320x240. However
// I can accept any image size which gives me some space to bounce.
//
// A bit of fun: 8 bit displays see a red ball, 16 bit displays get blue,
// 24bit see green and 32 bit see yellow!



//
// GetMediaType
//
// Prefered types should be ordered by quality, zero as highest quality
// Therefore iPosition =
// 0	return a 32bit mediatype
// 1	return a 24bit mediatype
// 2	return 16bit RGB565
// 3	return a 16bit mediatype (rgb555)
// 4	return 8 bit palettised format
// iPostion > 4 is invalid.
//
// this test filter returns prefers 16 bit. less bandwidth to test file
// writer with.
//
HRESULT CBallStream::GetMediaType(int iPosition, CMediaType *pmt) {

    CAutoLock l(m_pFilter->pStateLock());

    if (iPosition<0) {
        return E_INVALIDARG;
    }
    if (iPosition>4) {
        return VFW_S_NO_MORE_ITEMS;
    }

    VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *) pmt->AllocFormatBuffer(sizeof(VIDEOINFOHEADER) + sizeof(TRUECOLORINFO));
    if (NULL == pvi) {
	return(E_OUTOFMEMORY);
    }
    ZeroMemory(pvi, sizeof(VIDEOINFOHEADER) + sizeof(TRUECOLORINFO));

    switch (iPosition) {
    case 4: {	// return our highest quality 32bit format

        // Place the RGB masks as the first 3 doublewords in the palette area
        for (int i = 0; i < 3; i++)
	    pvi->TrueColorInfo.dwBitMasks[i] = bits888[i];

        SetPaletteEntries(Yellow);

	pvi->bmiHeader.biCompression = BI_BITFIELDS;
	pvi->bmiHeader.biBitCount    = 32;
	}
	break;

    case 1: {	// return our 24bit format

        SetPaletteEntries(Green);
	pvi->bmiHeader.biCompression = BI_RGB;
	pvi->bmiHeader.biBitCount    = 24;

        }
	break;

    case 0: {   // 16 bit RGB565 - note that the red element is the same for both 16bit formats

        // Place the RGB masks as the first 3 doublewords in the palette area
        for (int i = 0; i < 3; i++)
	    pvi->TrueColorInfo.dwBitMasks[i] = bits565[i];

        SetPaletteEntries(Blue);

	pvi->bmiHeader.biCompression = BI_BITFIELDS;
	pvi->bmiHeader.biBitCount    = 16;
	}
        break;

    case 3: {	// 16 bits per pixel - RGB555

        // Place the RGB masks as the first 3 doublewords in the palette area
        for (int i = 0; i < 3; i++)
	    pvi->TrueColorInfo.dwBitMasks[i] = bits555[i];

        SetPaletteEntries(Blue);
	pvi->bmiHeader.biCompression = BI_BITFIELDS;
	pvi->bmiHeader.biBitCount    = 16;

        }
	break;

    case 2: {	// 8 bits palettised

        SetPaletteEntries(Red);

        pvi->bmiHeader.biCompression = BI_RGB;
	pvi->bmiHeader.biBitCount    = 8;

        }
	break;
    }
    // Adjust the parameters common to all formats.

    // put the optimal palette in place
    for (int i = 0; i < iPALETTE_COLORS; i++) {
        pvi->TrueColorInfo.bmiColors[i].rgbRed      = m_Palette[i].peRed;
        pvi->TrueColorInfo.bmiColors[i].rgbBlue     = m_Palette[i].peBlue;
        pvi->TrueColorInfo.bmiColors[i].rgbGreen    = m_Palette[i].peGreen;
        pvi->TrueColorInfo.bmiColors[i].rgbReserved = 0;
    }

    pvi->bmiHeader.biSize		= sizeof(BITMAPINFOHEADER);
    pvi->bmiHeader.biWidth		= m_iImageWidth;
    pvi->bmiHeader.biHeight		= m_iImageHeight;
    pvi->bmiHeader.biPlanes		= 1;
    pvi->bmiHeader.biSizeImage		= GetBitmapSize(&pvi->bmiHeader);
    pvi->bmiHeader.biClrUsed		= iPALETTE_COLORS;
    pvi->bmiHeader.biClrImportant	= 0;

    SetRectEmpty(&(pvi->rcSource));	// we want the whole image area rendered.
    SetRectEmpty(&(pvi->rcTarget));	// no particular destination rectangle

    pmt->SetType(&MEDIATYPE_Video);
    pmt->SetFormatType(&FORMAT_VideoInfo);
    pmt->SetTemporalCompression(FALSE);

    // Work out the GUID for the subtype from the header info.
    const GUID SubTypeGUID = GetBitmapSubtype(&pvi->bmiHeader);
    pmt->SetSubtype(&SubTypeGUID);
    pmt->SetSampleSize(pvi->bmiHeader.biSizeImage);

    return NOERROR;
}


//
// CheckMediaType
//
// We will accept 8, 16, 24 or 32 bit video formats, in any
// image size that gives room to bounce.
// Returns E_INVALIDARG if the mediatype is not acceptable, S_OK if it is
HRESULT CBallStream::CheckMediaType(const CMediaType *pMediaType)
{

    CAutoLock l(m_pFilter->pStateLock());

    if (   (*(pMediaType->Type()) != MEDIATYPE_Video)	// we only output video!
	|| !(pMediaType->IsFixedSize()) ) {		// ...in fixed size samples
        return E_INVALIDARG;
    }

    // Check for the subtypes we support
    const GUID *SubType = pMediaType->Subtype();
    if (   (*SubType != MEDIASUBTYPE_RGB8)
        && (*SubType != MEDIASUBTYPE_RGB565)
	&& (*SubType != MEDIASUBTYPE_RGB555)
 	&& (*SubType != MEDIASUBTYPE_RGB24)
	&& (*SubType != MEDIASUBTYPE_RGB32)
       ) {
        return E_INVALIDARG;
    }

    // Get the format area of the media type
    VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *) pMediaType->Format();

    if (pvi == NULL)
	return E_INVALIDARG;

    // Check the image size. As my default ball is 10 pixels big
    // look for at least a 20x20 image. This is an arbitary size constraint,
    // but it avoids balls that are bigger than the picture...
    if (   (pvi->bmiHeader.biWidth < 20)
        || (pvi->bmiHeader.biHeight < 20) ) {
	return E_INVALIDARG;
    }

    return S_OK;  // This format is acceptable.
}


//
// DecideBufferSize
//
// This will always be called after the format has been sucessfully
// negotiated. So we have a look at m_mt to see what size image we agreed.
// Then we can ask for buffers of the correct size to contain them.
HRESULT CBallStream::DecideBufferSize(IMemAllocator *pAlloc,
                                      ALLOCATOR_PROPERTIES *pProperties)
{
    CAutoLock l(m_pFilter->pStateLock());
    ASSERT(pAlloc);
    ASSERT(pProperties);
    HRESULT hr = NOERROR;

    VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *) m_mt.Format();
    pProperties->cBuffers = 1;
    pProperties->cbBuffer = pvi->bmiHeader.biSizeImage;

    ASSERT(pProperties->cbBuffer);

    // Ask the allocator to reserve us some sample memory, NOTE the function
    // can succeed (that is return NOERROR) but still not have allocated the
    // memory that we requested, so we must check we got whatever we wanted

    ALLOCATOR_PROPERTIES Actual;
    hr = pAlloc->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        return hr;
    }

    // Is this allocator unsuitable

    if (Actual.cbBuffer < pProperties->cbBuffer) {
        return E_FAIL;
    }

    // Make sure that we have only 1 buffer (we erase the ball in the
    // old buffer to save having to zero a 200k+ buffer every time
    // we draw a frame)

    ASSERT( Actual.cBuffers == 1 );

    return NOERROR;
}


//
// SetMediaType
//
// Overriden from CBasePin. Call the base class and then set the
// ball parameters that depend on media type - m_BallPixel[], m_BackPixel, iPixelSize, etc
HRESULT CBallStream::SetMediaType(const CMediaType *pMediaType) {

    CAutoLock l(m_pFilter->pStateLock());

    HRESULT hr;		// return code from base class calls

    // Pass the call up to my base class
    hr = CSourceStream::SetMediaType(pMediaType);
    if (SUCCEEDED(hr)) {

        VIDEOINFOHEADER * pvi = (VIDEOINFOHEADER *) m_mt.Format();
        switch (pvi->bmiHeader.biBitCount) {
        case 8:		// make a red pixel

            m_BallPixel[0] = 10;	// 0 is palette index of red
	    m_iPixelSize   = 1;
	    SetPaletteEntries(Red);
	    break;

        case 16:	// make a blue pixel

            m_BallPixel[0] = 0xf8;	// 00000000 00011111 is blue in rgb555 or rgb565
	    m_BallPixel[1] = 0x0;	// don't forget the byte ordering within the mask word.
	    m_iPixelSize   = 2;
	    SetPaletteEntries(Blue);
	    break;

        case 24:	// make a green pixel

            m_BallPixel[0] = 0x0;
	    m_BallPixel[1] = 0xff;
	    m_BallPixel[2] = 0x0;
	    m_iPixelSize   = 3;
	    SetPaletteEntries(Green);
	    break;

	case 32:	// make a yellow pixel

            m_BallPixel[0] = 0x0;
	    m_BallPixel[1] = 0x0;
	    m_BallPixel[2] = 0xff;
	    m_BallPixel[3] = 0xff;
	    m_iPixelSize   = 4;
            SetPaletteEntries(Yellow);
	    break;

        default:
            // We should never agree any other pixel sizes
	    ASSERT("Tried to agree inappropriate format");

        }
	return NOERROR;
    }
    else {
        return hr;
    }
}


//
// OnThreadCreate
//
// as we go active reset the stream time to zero
HRESULT CBallStream::OnThreadCreate(void) {

    CAutoLock lShared(&m_cSharedState);

    m_rtSampleTime = 0;

    // we need to also reset the repeat time in case the system
    // clock is turned off after m_iRepeatTime gets very big
    m_iRepeatTime = m_iDefaultRepeatTime;

    // Zero the output buffer on the first frame.
    m_bZeroMemory = TRUE;

    return NOERROR;
}


//
// SetPaletteEntries
//
// If we set our palette to the current system palette + the colour we want
// the system has the least amount of work to do whilst plotting our images,
// if this stream is rendered to the current display. The first 'spare'
// palette slot is at m_Palette[10], so put our colour there.
// Also guarantees that black is always represented by zero in the frame buffer.
HRESULT CBallStream::SetPaletteEntries(Colour colour) {

    CAutoLock l(m_pFilter->pStateLock());

    HDC hdc = GetDC(NULL);	// hdc for the current display.

    UINT res = GetSystemPaletteEntries(hdc, 0, iPALETTE_COLORS, (LPPALETTEENTRY) &m_Palette);

    ReleaseDC(NULL, hdc);

    if (res == 0) {
        return E_FAIL;
    }

    switch (colour) {
    case Red:
        m_Palette[10].peBlue  = 0;
        m_Palette[10].peGreen = 0;
        m_Palette[10].peRed   = 0xff;
        break;
    case Yellow:
        m_Palette[10].peBlue  = 0;
        m_Palette[10].peGreen = 0xff;
        m_Palette[10].peRed   = 0xff;
        break;
    case Blue:
        m_Palette[10].peBlue  = 0xff;
        m_Palette[10].peGreen = 0;
        m_Palette[10].peRed   = 0;
        break;
    case Green:
        m_Palette[10].peBlue  = 0;
        m_Palette[10].peGreen = 0xff;
        m_Palette[10].peRed   = 0;
        break;
    }

    m_Palette[10].peFlags = 0;

    return NOERROR;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avimsr\aviindex.cpp ===
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)

#include <streams.h>
#include "aviindex.h"

static const ULONG F_PALETTE_CHANGE_INTERNAL = 0x40000000;
static const ULONG F_SIZE_MASK_INTERNAL =      0x3fffffff;

// constructor for the new format index (indx)
CImplStdAviIndex::CImplStdAviIndex(
  unsigned stream,
  AVIMETAINDEX *pIndx,
  AVISTREAMHEADER *pStrh,
  RIFFCHUNK *pStrf,
  IAsyncReader *pAsyncReader,
  HRESULT *phr)
{
  _CImplStdAviIndex();

  m_pAsyncReader = pAsyncReader;
  pAsyncReader->AddRef();
  
  if(!FAILED(*phr)) {
     *phr = Initialize(
       stream,
       pIndx,
       pStrh,
       pStrf);
  }
}

CImplStdAviIndex::CImplStdAviIndex()
{
  _CImplStdAviIndex();
}

void CImplStdAviIndex::_CImplStdAviIndex()
{
  m_pAsyncReader = 0;
  m_pStdIndex = 0;
  m_cbStdIndexAllocated = 0;
  m_fWaitForIndex = FALSE;
}

CImplStdAviIndex::~CImplStdAviIndex()
{
  if(m_cbStdIndexAllocated != 0)
    delete[] m_pStdIndex;

  if(m_pAsyncReader)
    m_pAsyncReader->Release();
}

HRESULT CImplStdAviIndex::Initialize(
  unsigned stream,
  AVIMETAINDEX *pIndx,
  AVISTREAMHEADER *pStrh,
  RIFFCHUNK *pStrf)
{
  m_stream = stream;
  m_bValid = FALSE;
  m_pStrh = pStrh;
  m_pStrf = pStrf;

  HRESULT hr = S_OK;

  // the following are guaranteed by ParseHeader in the pin
  ASSERT(m_pStrh->dwRate != 0);
  ASSERT(m_pStrh->fccType != streamtypeAUDIO ||
         ((WAVEFORMAT *)GetStrf())->nBlockAlign != 0);

  ASSERT(pIndx != 0);

  switch(pIndx->bIndexType)
  {
    case AVI_INDEX_OF_CHUNKS:
      m_pSuperIndex = 0;
      m_pStdIndex = (AVISTDINDEX *)pIndx;
      hr = ValidateStdIndex(m_pStdIndex);
      break;

    case AVI_INDEX_OF_INDEXES:
      m_pSuperIndex = (AVISUPERINDEX *)pIndx;
      hr = ValidateSuperIndex(m_pSuperIndex);
      if(FAILED(hr))
        break;

      hr = AllocateStdIndex();
      if(FAILED(hr))
        break;

      hr = S_OK;
      break;

    default:
      hr = VFW_E_INVALID_FILE_FORMAT;
  }

  if(FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CImplStdAviIndex::Initialize: failed.")));
  }

  return hr;
}

// ------------------------------------------------------------------------
// IAviIndex

// SetPointer

HRESULT CImplStdAviIndex::SetPointer(LONGLONG llSrc)
{
  m_bValid = FALSE;

  if(m_pStrh->fccType == streamtypeVIDEO)
    llSrc += m_pStrh->dwInitialFrames;

  HRESULT hr;

  // dwStart not accounted for in index. so we have to subtract
  // dwStart from it
  DWORDLONG tick = llSrc;

  if(tick > m_pStrh->dwStart)
  {
      tick -= m_pStrh->dwStart;
  }
  else
  {
      tick = 0;
  }

  // what we use to track index position
  m_lliTick = tick;

  DbgLog((LOG_TRACE, 0x3f,
          TEXT("avi SetPointer: m_lliTick = %d, tick = %d"),
          (DWORD)m_lliTick, (DWORD)tick));


  // linear search through superindex to find subindex in range. !!!
  // we could start at the end if that's closer. or build an absolute
  // table and do a binary search. !!!
  if(m_pSuperIndex != 0)
  {
    for(DWORD dwi = 0;; dwi++)
    {
      if(dwi == m_pSuperIndex->nEntriesInUse)
      {
        DbgLog(( LOG_TRACE, 2,
                 TEXT("CImplStdAviIndex::SetPointer: past end.")));
        return AdvancePointerEnd();
      }

      if(m_pSuperIndex->aIndex[dwi].dwDuration > tick)
      {
          // tick contains the number of ticks in this entry we have
          // to skip. 
          
          break;
      }

      tick -= m_pSuperIndex->aIndex[dwi].dwDuration;
    }

    hr = LoadStdIndex(dwi, 0);
    if(FAILED(hr))
      return hr;

    ASSERT(m_iSuperIndex == dwi);
  }

  //
  // set the current std index entry
  //

  // since the number of ticks in an entry is unknown, must start from
  // beginning and count up. better to make an absolute index, do
  // binary search.

  // linear search through subindex chunk to find index entry
  // containing tick. !!! we could start searching at the end if
  // that's closer.
  for(m_iStdIndex = 0;; m_iStdIndex++)
  {
    ASSERT(m_iStdIndex <= m_pStdIndex->nEntriesInUse);
    if(m_iStdIndex == m_pStdIndex->nEntriesInUse)
    {
      if(m_pSuperIndex)
      {
        DbgLog(( LOG_ERROR, 2,
                 TEXT("SetPointer: std index differs from super.")));
        return VFW_E_INVALID_FILE_FORMAT;
      }
      else
      {
        DbgLog(( LOG_TRACE, 2, TEXT("SetPointer: off the end.")));
        return HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
      }
    }

    ULONG cTicksInEntry = GetTicksInEntry(m_iStdIndex);

    // landed in the middle of an index entry
    if(cTicksInEntry > tick)
    {
      m_lliTick -= tick;

      DbgLog((LOG_TRACE, 0x3f,
              TEXT("avi index: found iStdIndex =  %d, tick = %d, m_lliTick = %d"),
              (DWORD)m_iStdIndex, (DWORD)tick, (DWORD)m_lliTick));
      break;
    }

    tick -= cTicksInEntry;
  }

  m_bValid = TRUE;

  DbgLog((LOG_TRACE, 5, TEXT("SetPointer: tick = %d, iIdx %d-%d"),
          (DWORD)m_lliTick, (DWORD)m_iSuperIndex, (DWORD)m_iStdIndex));

  
  return S_OK;
}

HRESULT CImplStdAviIndex::MapByteToSampleApprox(
  LONGLONG *piSample,
  const LONGLONG &fileOffset,
  const LONGLONG &fileLength)
{
  ULONG cTicks = 0;
  if(m_pSuperIndex)
  {
    ASSERT(m_pSuperIndex->nEntriesInUse > 0); // from Validate call
    for(ULONG iEntry = 0;;)
    {
      // byte offset of last thing indexed by this sub index. use the
      // file length if we're at the end
      LONGLONG byteOffsetEnd = fileLength;
      if(iEntry + 1 < m_pSuperIndex->nEntriesInUse)
      {
        byteOffsetEnd = m_pSuperIndex->aIndex[iEntry + 1].qwOffset;
      }
          
      if(byteOffsetEnd > fileOffset)
      {
        // cTicks points to the beginning of the sub index. do a
        // linear interpolation with the byte offset

        ULONG cbIndexed = (ULONG)(byteOffsetEnd -
                                  m_pSuperIndex->aIndex[iEntry].qwOffset);
        ULONG cbCovered = (ULONG)(fileOffset -
                                  m_pSuperIndex->aIndex[iEntry].qwOffset);

        ASSERT(cbIndexed >= cbCovered);

        if(cbIndexed != 0)
        {
          cTicks += (ULONG)((LONGLONG)m_pSuperIndex->aIndex[iEntry].dwDuration  *
                            cbCovered / cbIndexed);
        }

        break;
      }


      cTicks += m_pSuperIndex->aIndex[iEntry].dwDuration;
      iEntry++;
      
      if(iEntry >= m_pSuperIndex->nEntriesInUse)
        break;
    }
  }
  else
  {
    ASSERT(m_pStdIndex->nEntriesInUse > 0); // from Validate call
    LONGLONG fileOffsetAdjusted = fileOffset; // shadow const 
    fileOffsetAdjusted -= m_pStdIndex->qwBaseOffset;
    for(ULONG iEntry = 0; ; )
    {
      if(iEntry + 1 < m_pStdIndex->nEntriesInUse)
        if((LONGLONG)m_pStdIndex->aIndex[iEntry + 1].dwOffset > fileOffsetAdjusted)
          break;

      cTicks += GetTicksInEntry(iEntry);
      iEntry++;

      if(iEntry >= m_pStdIndex->nEntriesInUse)
        break;
    }
  }

  *piSample = cTicks;
  return S_OK;
}

HRESULT CImplStdAviIndex::Reset()
{
  if(m_fWaitForIndex)
  {
    DbgLog((LOG_TRACE, 5, TEXT("CImplStdAviIndex: index cancelled") ));
  }
  m_fWaitForIndex = FALSE;
  return S_OK;
}

HRESULT CImplStdAviIndex::AdvancePointerForward(IxReadReq *pIrr)
{
  if(!m_bValid)
  {
    ASSERT(!"index pointer not in valid state");
    return E_FAIL;
  }
  ASSERT(!m_fWaitForIndex);

  ASSERT(m_iStdIndex < m_pStdIndex->nEntriesInUse);
  ASSERT(m_pStdIndex->nEntriesInUse > 0);
  ASSERT(!m_pSuperIndex || m_pSuperIndex->nEntriesInUse > 0);

  m_lliTick += GetTicksInEntry(m_iStdIndex);
  if(++m_iStdIndex == m_pStdIndex->nEntriesInUse)
  {
    if(m_pSuperIndex == 0)
    {
      m_bValid = FALSE;
      DbgLog(( LOG_TRACE, 2,
               TEXT("CImplStdAviIndex::AdvancePointer: EOF")));
      return HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
    }

    HRESULT hr = LoadStdIndex(m_iSuperIndex + 1, pIrr);
    if(FAILED(hr))
    {
      DbgLog(( LOG_ERROR, 2,
               TEXT("CImplStdAviIndex::AdvancePointer: LoadStdIndex")));
      return hr;
    }

    m_iStdIndex = 0;
  }
  if(m_fWaitForIndex)
  {
    ASSERT(!m_bValid);
    return S_FALSE;
  }
  else
  {
    m_bValid = TRUE;
    return S_OK;
  }
}

HRESULT CImplStdAviIndex::AdvancePointerBackward()
{
  if(!m_bValid)
  {
    ASSERT(!"index pointer not in valid state");
    return E_FAIL;
  }

  ASSERT(m_iStdIndex < m_pStdIndex->nEntriesInUse);
  ASSERT(m_pStdIndex->nEntriesInUse > 0);
  ASSERT(!m_pSuperIndex || m_pSuperIndex->nEntriesInUse > 0);

  if(m_iStdIndex-- == 0)
  {
    if(m_pSuperIndex == 0)
    {
      m_bValid = FALSE;
      return HRESULT_FROM_WIN32(ERROR_NEGATIVE_SEEK);
    }

    HRESULT hr = LoadStdIndex(m_iSuperIndex - 1, 0);
    if(FAILED(hr))
      return hr;

    m_iStdIndex = m_pStdIndex->nEntriesInUse - 1;
  }
  m_lliTick -= GetTicksInEntry(m_iStdIndex);
  m_bValid = TRUE;

  return S_OK;
}

HRESULT CImplStdAviIndex::AdvancePointerBackwardKeyFrame()
{
  if(!m_bValid)
  {
    ASSERT(!"index pointer not in valid state");
    return E_FAIL;
  }

  // otherwise look for a key frame. return an error if the first
  // thing isn't a key frame.
  while(!GetKey(m_pStdIndex->aIndex[m_iStdIndex]))
  {
    // drop frame at the beginning is ok
    if(m_lliTick == 0 && GetSize(m_pStdIndex->aIndex[m_iStdIndex]) == 0) {
      return S_OK;
    }
    
    HRESULT hr = AdvancePointerBackward();
    if(FAILED(hr))
    {
      DbgLog((LOG_ERROR, 1, TEXT("avi: couldn't find a key frame")));
      return hr;
    }
  }

  return S_OK;
}

HRESULT CImplStdAviIndex::AdvancePointerEnd()
{
  if(m_pSuperIndex)
  {
    HRESULT hr = LoadStdIndex(m_pSuperIndex->nEntriesInUse - 1, 0);
    if(FAILED(hr))
      return hr;
  }
  m_iStdIndex = m_pStdIndex->nEntriesInUse - 1;
  m_lliTick = m_pStrh->dwLength - GetTicksInEntry(m_iStdIndex);
  m_bValid = TRUE;

  return S_OK;
}

HRESULT CImplStdAviIndex::AdvancePointerStart()
{
  if(m_pSuperIndex)
  {
    HRESULT hr = LoadStdIndex(0, 0);
    if(FAILED(hr))
      return hr;
  }
  m_iStdIndex = 0;
  m_lliTick = 0;
  m_bValid = TRUE;

  return S_OK;
}

HRESULT CImplStdAviIndex::AdvancePointerBackwardPaletteChange()
{
  return S_FALSE;
}

HRESULT CImplStdAviIndex::AdvancePointerForwardPaletteChange()
{
  return S_FALSE;
}

HRESULT CImplStdAviIndex::GetEntry(IndexEntry *pEntry)
{
  if(!m_bValid)
  {
    DbgBreak("index pointer not in valid state");
    
    DbgLog(( LOG_ERROR, 2,
             TEXT("CImplStdAviIndex::GetEntry: !m_bValid.")));
    return E_FAIL;
  }

  AVISTDINDEX_ENTRY &rEntry = m_pStdIndex->aIndex[m_iStdIndex];

#ifdef DEBUG
    if(m_pStrh->fccType == streamtypeAUDIO)
    {
        if(GetSize(rEntry) % ((WAVEFORMAT *)GetStrf())->nBlockAlign)
        {
            if(m_lliTick + GetTicksInEntry(m_iStdIndex) != m_pStrh->dwLength )
            {
                DbgBreak("invalid audio but not signaling an error.");
            }
        }
    }
#endif
  


  pEntry->qwPos = m_pStdIndex->qwBaseOffset + rEntry.dwOffset;
  pEntry->dwSize = GetSize(rEntry);
  pEntry->bKey = GetKey(rEntry);
  pEntry->bPalChange = GetPalChange(rEntry);
  pEntry->llStart = m_lliTick + m_pStrh->dwStart;
  if(m_pStrh->fccType == streamtypeVIDEO)
    pEntry->llStart -= m_pStrh->dwInitialFrames;
  
  pEntry->llEnd = pEntry->llStart + GetTicksInEntry(m_iStdIndex);

  DbgLog((LOG_TRACE, 0x40, TEXT("GetEntry: %d-%d, tick = %d, iIdx %d-%d"),
          (DWORD)pEntry->llStart, (DWORD)pEntry->llEnd,
          (DWORD)m_lliTick, (DWORD)m_iSuperIndex, (DWORD)m_iStdIndex));

  return S_OK;
}

HRESULT CImplStdAviIndex::GetInfo(StreamInfo *pStreamInfo)
{
  HRESULT hr;

  BOOL bTemporalCompression = FALSE;

  // media type entries (bTemporalCompression) for audio are ignored
  if(m_pStrh->fccType == streamtypeVIDEO)
  {
    // check first ten frames to see if one is not a key frame
    hr = AdvancePointerStart();
    if(FAILED(hr))
      return hr;

    IndexEntry ie;
    for(unsigned i = 0; i < 10; i++)
    {
      hr = GetEntry(&ie);
      if(FAILED(hr))
        return hr;

      if(!ie.bKey)
      {
        bTemporalCompression = TRUE;
        break;
      }

      hr = AdvancePointerForward(0);
      if(hr == HRESULT_FROM_WIN32(ERROR_HANDLE_EOF))
      {
        break;
      }
      else if(FAILED(hr))
      {
        return hr;
      }
    }
  }

  pStreamInfo->bTemporalCompression = bTemporalCompression;
  pStreamInfo->dwStart = m_pStrh->dwStart;
  pStreamInfo->dwLength = m_pStrh->dwLength;
  return S_OK;
}

// return the largest index size, not the sample size
HRESULT CImplStdAviIndex::GetLargestSampleSize(ULONG *pcbSample)
{
  *pcbSample = 0;
  if(m_pSuperIndex == 0)
    return S_OK;
  
  ULONG cb = 0;
  for(ULONG i = 0; i < m_pSuperIndex->nEntriesInUse; i++)
    cb = max(cb, m_pSuperIndex->aIndex[i].dwSize);

  *pcbSample = cb;
  return S_OK;
}

HRESULT CImplStdAviIndex::IncomingIndex(BYTE *pb, ULONG cb)
{
  ASSERT(m_fWaitForIndex && !m_bValid);
  ASSERT(cb <= m_cbStdIndexAllocated);

  CopyMemory((BYTE *)m_pStdIndex, pb, cb);
  HRESULT hr = ValidateStdIndex(m_pStdIndex);
  if(hr != S_OK)
    return VFW_E_INVALID_FILE_FORMAT;

  m_bValid = TRUE;
  m_fWaitForIndex = FALSE;
  return S_OK;
}

// ------------------------------------------------------------------------
// catch things that would make us access memory out of bounds

HRESULT CImplStdAviIndex::ValidateStdIndex(AVISTDINDEX *pStdIndex)
{
  if(pStdIndex->wLongsPerEntry != sizeof(AVISTDINDEX_ENTRY) / sizeof(long))
    return VFW_E_INVALID_FILE_FORMAT;

  DWORD_PTR cb = ((BYTE *)(pStdIndex->aIndex + pStdIndex->nEntriesInUse) -
              (BYTE *)pStdIndex);
  cb -= sizeof(RIFFCHUNK);
  if(cb > pStdIndex->cb)
    return VFW_E_INVALID_FILE_FORMAT;

  if(pStdIndex->nEntriesInUse == 0)
    return VFW_E_INVALID_FILE_FORMAT;

  return S_OK;
}

HRESULT CImplStdAviIndex::ValidateSuperIndex(AVISUPERINDEX *pSuperIndex)
{
  if(pSuperIndex->wLongsPerEntry !=
     sizeof(AVISUPERINDEX::_avisuperindex_entry) / sizeof(long))
    return VFW_E_INVALID_FILE_FORMAT;

  DWORD_PTR cb = ((BYTE *)(pSuperIndex->aIndex + pSuperIndex->nEntriesInUse) -
              (BYTE *)pSuperIndex);
  cb -= sizeof(RIFFCHUNK);
  if(cb > pSuperIndex->cb)
    return VFW_E_INVALID_FILE_FORMAT;

  if(pSuperIndex->nEntriesInUse == 0)
    return VFW_E_INVALID_FILE_FORMAT;

  return S_OK;
}

// ------------------------------------------------------------------------
// AllocateStdIndex: find the largest subindex chunk size, and
// allocate that amount.

HRESULT CImplStdAviIndex::AllocateStdIndex()
{
  DWORD cbIndex = m_pSuperIndex->aIndex[0].dwSize;
  for(DWORD dwii = 0; dwii < m_pSuperIndex->nEntriesInUse; ++dwii)
    cbIndex = max(cbIndex, m_pSuperIndex->aIndex[dwii].dwSize);

  m_pStdIndex = (AVISTDINDEX*)new BYTE[cbIndex];
  if(m_pStdIndex == 0)
    return E_OUTOFMEMORY;
  m_cbStdIndexAllocated = cbIndex;

  return S_OK;
}

HRESULT CImplStdAviIndex::LoadStdIndex(DWORD iSuperIndex, IxReadReq *pIrr)
{
  if(m_pSuperIndex == 0)
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CImplStdAviIndex::LoadStdIndex: no super index.")));
    return E_FAIL;
  }

  if(m_bValid && iSuperIndex == m_iSuperIndex)
    return S_OK;

  m_bValid = FALSE;

  if(iSuperIndex >= m_pSuperIndex->nEntriesInUse)
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CImplStdAviIndex::LoadStdIndex: out of range.")));
    return HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
  }

  AVISUPERINDEX::_avisuperindex_entry &rEntry =
    m_pSuperIndex->aIndex[iSuperIndex];
  ASSERT(rEntry.dwSize <= m_cbStdIndexAllocated);
  HRESULT hr;

  if(pIrr == 0)
  {
    hr = m_pAsyncReader->SyncRead(
      rEntry.qwOffset,
      rEntry.dwSize,
      (BYTE*)m_pStdIndex);
  

    if(SUCCEEDED(hr))
    {
      m_iSuperIndex = iSuperIndex;
      hr = ValidateStdIndex(m_pStdIndex);
    }
  }
  else
  {
    m_iSuperIndex = iSuperIndex;
    pIrr->fileOffset = rEntry.qwOffset;
    pIrr->cbData = rEntry.dwSize;
    m_fWaitForIndex = TRUE;
    hr = S_FALSE;
  }

  return hr;
}

// number of ticks in the current index entry
//
ULONG CImplStdAviIndex::GetTicksInEntry(ULONG iEntry)
{
  ULONG cTicks;
  
  if(m_pStrh->fccType == streamtypeAUDIO)
  {
    DWORD dwSize = GetSize(m_pStdIndex->aIndex[iEntry]);
    DWORD nBlockAlign = ((WAVEFORMAT *)GetStrf())->nBlockAlign;
    cTicks =  (dwSize + nBlockAlign - 1) / nBlockAlign;
  }
  else if(m_pStrh->fccType == streamtypeVIDEO)
  {
    cTicks = GetPalChange(m_pStdIndex->aIndex[iEntry]) ? 0 : 1;
  }
  else
  {
    cTicks = 1;
  }

  return cTicks;
}

inline
BOOL CImplStdAviIndex::GetKey(AVISTDINDEX_ENTRY &rEntry)
{
  return !(rEntry.dwSize & AVISTDINDEX_DELTAFRAME) &&
    !GetPalChange(rEntry);
}

inline
BOOL CImplStdAviIndex::GetPalChange(AVISTDINDEX_ENTRY &rEntry)
{
  return rEntry.dwSize & F_PALETTE_CHANGE_INTERNAL;
}

inline
DWORD CImplStdAviIndex::GetSize(AVISTDINDEX_ENTRY &rEntry)
{
  return rEntry.dwSize & F_SIZE_MASK_INTERNAL;
}

inline
BYTE * CImplStdAviIndex::GetStrf()
{
  ASSERT(sizeof(*m_pStrf) == sizeof(RIFFCHUNK));
  return (BYTE *)(m_pStrf + 1);
}

// BOOL CImplStdAviIndex::IsSampleEntry(
//   DWORD dwIdMask,
//   DWORD fccStream,
//   DWORD idxChunkId)
// {
//   if((idxChunkId & 0xffff) != dwIdMask)
//     return FALSE;

//   // accept only anything but pc (palette change) for video, "wb" for
//   // audio
//   WORD w2cc = WORD(idxChunkId >> 16);
//   if((fccStream == streamtypeAUDIO && w2cc == 'bw') ||
//      (fccStream == streamtypeVIDEO && w2cc != 'cp') ||
//      (fccStream == streamtypeTEXT))
//   {
//     return TRUE;
//   }
//   return FALSE;
// }

BOOL CImplStdAviIndex::IsPaletteChange(
  DWORD dwIdMask,
  DWORD idxChunkId)
{
  if((idxChunkId & 0xffff) != dwIdMask)
    return FALSE;

  WORD w2cc = WORD(idxChunkId >> 16);
  if(w2cc == 'cp')
    return TRUE;

  return FALSE;
}

inline BOOL CImplStdAviIndex::IsStreamEntry(
  DWORD dwIdMask,
  DWORD idxChunkId)
{
  ASSERT((idxChunkId & 0xffff) == ((WORD *)&idxChunkId)[0]);

  if(((WORD *)&idxChunkId)[0] != dwIdMask)
    return FALSE;

  // !!! what about the no time flag.

  return TRUE;
}

// constructor for the old format index (idx1). creates a new format
// index (indx) from the idx1 chunk. two passes per stream over the
// entire index: extremely inefficient
CImplOldAviIndex::CImplOldAviIndex(
  unsigned stream,
  AVIOLDINDEX *pIdx1,
  DWORDLONG moviOffset,
  AVISTREAMHEADER *pStrh,
  RIFFCHUNK *pStrf,
  HRESULT *phr) :
    CImplStdAviIndex()
{
  m_cbLargestSampleSizeComputed = 0;

  // uncompressed video?
  BOOL fUncompressedVideo = FALSE;
  if(pStrh->fccType == streamtypeVIDEO)
  {
    BITMAPINFOHEADER *pbmi = (BITMAPINFOHEADER *)(pStrf + 1);
    if(pbmi->biCompression == BI_RGB || pbmi->biCompression == BI_BITFIELDS)
    {
      DbgLog((LOG_TRACE, 2, TEXT("aviindex: uncompressed video fixups.")));
      fUncompressedVideo = TRUE;
    }
  }

  if(!FAILED(*phr)) {

     // create the stream id used in the index (eg 01db)
     BYTE b0, b1;
     b0 = stream & 0x0F;
     b0 += (b0 <= 9) ? '0' : 'A' - 10;
     b1 = (stream & 0xF0) >> 4;
     b1 += (b1 <= 9) ? '0' : 'A' - 10;

     // little endian encoding of the stream id in the avioldindex entry
     DWORD dwIdMask = b1 + (b0 << 8);

     // count entries for this stream
     ULONG iIdx1Entry;
     ULONG cEntriesThisStream = 0;
     ULONG cEntriesIdx1 = pIdx1->cb / sizeof(AVIOLDINDEX::_avioldindex_entry);
     for(iIdx1Entry = 0; iIdx1Entry < cEntriesIdx1; iIdx1Entry++)
     {
       if(IsStreamEntry(dwIdMask, pIdx1->aIndex[iIdx1Entry].dwChunkId))
       {
         cEntriesThisStream++;
         if(pIdx1->aIndex[iIdx1Entry].dwSize > F_SIZE_MASK_INTERNAL)
         {
           *phr = VFW_E_INVALID_FILE_FORMAT;
           return;
         }
       }
     }

     // allocate std index
     m_cbStdIndexAllocated = cEntriesThisStream * sizeof(AVISTDINDEX_ENTRY) +
       sizeof(AVIMETAINDEX);
     m_pStdIndex = (AVISTDINDEX *)new BYTE[m_cbStdIndexAllocated];
     if(m_pStdIndex == 0)
     {
       *phr = E_OUTOFMEMORY;
       m_cbStdIndexAllocated = 0;

     } else {

        // copy entries over
        ULONG iIndxEntry = 0;
        for(iIdx1Entry = 0; iIdx1Entry < cEntriesIdx1; iIdx1Entry++)
        {
          AVIOLDINDEX::_avioldindex_entry &rOldEntry = pIdx1->aIndex[iIdx1Entry];
          AVISTDINDEX_ENTRY &rNewEntry = m_pStdIndex->aIndex[iIndxEntry];

          if(IsStreamEntry(dwIdMask, rOldEntry.dwChunkId))
          {
            rNewEntry.dwOffset = rOldEntry.dwOffset + sizeof(RIFFCHUNK);
            rNewEntry.dwSize = rOldEntry.dwSize;

            if(pStrh->fccType == streamtypeVIDEO &&
               IsPaletteChange(dwIdMask, rOldEntry.dwChunkId))
            {
              rNewEntry.dwSize |= F_PALETTE_CHANGE_INTERNAL;
            }
            else if(!((rOldEntry.dwFlags & AVIIF_KEYFRAME) ||
                      (pStrh->fccType != streamtypeAUDIO  && iIndxEntry == 0) ||
                      fUncompressedVideo))
            {
              // mark the delta frames. fixups for audio and text:
              // every frame is a key frame. fixup for video: first
              // frame is assumed to be keyframe (see
              // \\pigeon\avi\small.avi). fixup for uncompressed
              // video: every frame is a key frame.
              rNewEntry.dwSize |= (AVISTDINDEX_DELTAFRAME);
            }
            else
            {
              ASSERT(!(rNewEntry.dwSize & AVISTDINDEX_DELTAFRAME));
            }
            
            iIndxEntry++;
          }
        }

        ASSERT(iIndxEntry == cEntriesThisStream);

        m_pStdIndex->fcc            = FCC('indx');
        m_pStdIndex->cb             = m_cbStdIndexAllocated - sizeof(RIFFCHUNK);
        m_pStdIndex->wLongsPerEntry = sizeof(AVISTDINDEX_ENTRY) / sizeof(LONG);
        m_pStdIndex->bIndexSubType  = 0;
        m_pStdIndex->bIndexType     = AVI_INDEX_OF_CHUNKS;
        m_pStdIndex->nEntriesInUse  = cEntriesThisStream;
        m_pStdIndex->dwChunkId      = pIdx1->aIndex[0].dwChunkId;
        m_pStdIndex->dwReserved_3   = 0;

        // absolute index entries
        if(moviOffset + sizeof(RIFFLIST) == pIdx1->aIndex[0].dwOffset)
          m_pStdIndex->qwBaseOffset = 0;
        else
          m_pStdIndex->qwBaseOffset   = moviOffset + sizeof(RIFFCHUNK);

        *phr = Initialize(
          stream,
          (AVIMETAINDEX *)m_pStdIndex,
          pStrh,
          pStrf);
     }
  }
}

// linear search through all the other index entries for the previous
// palette entry. really should build a separate table of palette
// changes. also should check whether there are any palette changes in
// the file and bail immediately

HRESULT CImplOldAviIndex::AdvancePointerBackwardPaletteChange()
{
  if(!m_bValid)
  {
    ASSERT(!"index pointer not in valid state");
    return E_FAIL;
  }

  while(!GetPalChange(m_pStdIndex->aIndex[m_iStdIndex]))
  {
    HRESULT hr = AdvancePointerBackward();
    if(FAILED(hr))
      return hr;
  }

  return S_OK;
}

HRESULT CImplOldAviIndex::AdvancePointerForwardPaletteChange()
{
  return E_NOTIMPL;
}


HRESULT CImplOldAviIndex::GetLargestSampleSize(ULONG *pcbSample)
{

  if(m_cbLargestSampleSizeComputed != 0)
  {
    *pcbSample = m_cbLargestSampleSizeComputed;
    return S_OK;
  }

  *pcbSample = 0;

  // this method is a bit of a hack; we only need it for compatibility
  // files which don't know dwSuggestedBufferSize. we can't work with
  // the new format index since m_rpImplBuffer is not necessarily
  // created and set when this is called. !!! we should remember this
  // value and not recompute it.
  if(m_pAsyncReader == 0 && m_pSuperIndex != 0)
    return E_UNEXPECTED;

  // loop over all entries, remember the largest
  HRESULT hr = AdvancePointerStart();
  if(FAILED(hr))
    return hr;

  DWORD cbSize;
  ULONG cbLargest = 0;

  for(int i=0; ;++i)
  {
    cbSize = GetEntrySize();

    if(cbSize > cbLargest)
      cbLargest = cbSize;

    // for very large files this could take a significant time...
    hr = AdvancePointerForward(0);
    if(hr == HRESULT_FROM_WIN32(ERROR_HANDLE_EOF))
    {
      break;
    }
    if(FAILED(hr))
      return hr;
  }

  if(cbLargest)
  {
    *pcbSample = cbLargest;
    m_cbLargestSampleSizeComputed = cbLargest;
    return S_OK;
  }
  else
  {
    return VFW_E_INVALID_FILE_FORMAT;
  }
}

HRESULT CImplOldAviIndex::GetInfo(StreamInfo *pStreamInfo)
{
  HRESULT hr = CImplStdAviIndex::GetInfo(pStreamInfo);

  DWORD dwLength = 0;
  for(ULONG ie = 0; ie < m_pStdIndex->nEntriesInUse; ie++)
    dwLength += GetTicksInEntry(ie);

  if(m_pStrh->fccType == streamtypeVIDEO)
    dwLength -= m_pStrh->dwInitialFrames;

  pStreamInfo->dwLength = dwLength;

  if(dwLength != m_pStrh->dwLength)
    DbgLog((LOG_ERROR, 3,
            TEXT("CImplOldAviIndex:: length from header: %d from index: %d"),
            m_pStrh->dwLength, dwLength));
  return hr;
}

DWORD CImplOldAviIndex::GetEntrySize()
{
  AVISTDINDEX_ENTRY &rEntry = m_pStdIndex->aIndex[m_iStdIndex];
  return GetSize(rEntry);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avimsr\aviindex.h ===
// Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)

// aviindex.h. classes that provide an interface to accessing index
// entries for AVI files with std, old, or no index
//

#ifndef _AviIndex_H
#define _AviIndex_H

#include <aviriff.h>
#include "reader.h"

struct IndexEntry
{
  DWORD dwSize;
  DWORDLONG qwPos;
  BOOL bKey;
  BOOL bPalChange;
  LONGLONG llStart;
  LONGLONG llEnd;
};

struct StreamInfo
{
  BOOL bTemporalCompression;
  DWORD dwStart;
  DWORD dwLength;
};

// request async index reads with this
struct IxReadReq
{
  DWORDLONG fileOffset;
  ULONG cbData;
};

//
// interface for accessing the index
//
class IAviIndex
{
public:

  virtual ~IAviIndex() {}

  // set the current index entry. S_FALSE means it landed in a
  // discontinuity
  virtual HRESULT SetPointer(LONGLONG llSrc) = 0;

  //
  // methods to advance the current index entry
  //

  // use pIrr to use asynchronous reads. S_FALSE means it needs a read
  // queued
  virtual HRESULT AdvancePointerForward(IxReadReq *pIrr) = 0;
  virtual HRESULT AdvancePointerBackward() = 0;
  virtual HRESULT AdvancePointerBackwardKeyFrame() = 0;
  virtual HRESULT AdvancePointerEnd() = 0;
  virtual HRESULT AdvancePointerStart() = 0;
  virtual HRESULT AdvancePointerBackwardPaletteChange() = 0;
  virtual HRESULT AdvancePointerForwardPaletteChange() = 0;

  // return the current index entry
  virtual HRESULT GetEntry(IndexEntry *pEntry) = 0;

  // information gotten from the index
  virtual HRESULT GetInfo(StreamInfo *pStreamInfo) = 0;

  virtual HRESULT GetLargestSampleSize(ULONG *pcbSample) = 0;

  // notify read completed from IxReadReq above
  virtual HRESULT IncomingIndex(BYTE *pb, ULONG cb) = 0;

  // this is done here because we don't want to read the disk (we'll
  // just use super index for an approximation). otherwise the avimsr
  // pin could just instantiate another instance of the index and use
  // the existing methods to map a byte offset to a sample

  virtual HRESULT MapByteToSampleApprox(
    LONGLONG *piSample,
    const LONGLONG &fileOffset,
    const LONGLONG &fileLength) = 0;

  // restarting; cancel pending reads, etc.
  virtual HRESULT Reset() = 0;
};

//
// implementation of IAviIndex for files with the std format index
//

class CImplStdAviIndex : public IAviIndex
{
public:

  CImplStdAviIndex(
    unsigned stream,
    AVIMETAINDEX *pIndx,
    AVISTREAMHEADER *pStrh,     /* needed for stream length, rate */
    RIFFCHUNK *pStrf,           /* needed for audio streams */
    IAsyncReader *pAsyncReader,
    HRESULT *phr);

  // dummy constructor. _ cos vc gives it the wrong this pointer o/w.
  void _CImplStdAviIndex();
  CImplStdAviIndex();

  ~CImplStdAviIndex();


  HRESULT SetPointer(LONGLONG llSrc);

  HRESULT AdvancePointerForward(IxReadReq *pIrr);
  HRESULT AdvancePointerBackward();
  HRESULT AdvancePointerBackwardKeyFrame();
  HRESULT AdvancePointerEnd();
  HRESULT AdvancePointerStart();
  HRESULT AdvancePointerBackwardPaletteChange();
  HRESULT AdvancePointerForwardPaletteChange();
  HRESULT GetEntry(IndexEntry *pEntry);
  virtual HRESULT GetInfo(StreamInfo *pStreamInfo);
  HRESULT GetLargestSampleSize(ULONG *pcbSample);
  HRESULT IncomingIndex(BYTE *pb, ULONG cb);
  HRESULT MapByteToSampleApprox(
      LONGLONG *piSample,
      const LONGLONG &fileOffset,
      const LONGLONG &fileLength);
  HRESULT Reset();
  
protected:

  // called from all constructors
  HRESULT Initialize(
    unsigned stream,
    AVIMETAINDEX *pIndx,
    AVISTREAMHEADER *pStrh,     /* needed for stream length, rate */
    RIFFCHUNK *pStrf);          /* needed for audio streams */

  // BOOL IsSampleEntry(DWORD dwIdMask, DWORD fccStream, DWORD idxid);
  inline BOOL IsStreamEntry(DWORD dwIdMask, DWORD idxid);
  BOOL IsPaletteChange(DWORD dwIdMask, DWORD idxid);

  ULONG GetTicksInEntry(ULONG iEntry);

  BOOL m_bValid;                // index is in a valid state

  IAsyncReader *m_pAsyncReader;

  BOOL GetPalChange(AVISTDINDEX_ENTRY &rEntry);
  DWORD GetSize(AVISTDINDEX_ENTRY &rEntry);

  ULONG m_iStdIndex;            // current sub index entry
  AVISTDINDEX *m_pStdIndex;     // pointer to current std index
  ULONG m_cbStdIndexAllocated;  // how much allocated there

  AVISUPERINDEX *m_pSuperIndex;

  AVISTREAMHEADER *m_pStrh;

private:

  HRESULT ValidateStdIndex(AVISTDINDEX *pStdIndex);
  HRESULT ValidateSuperIndex(AVISUPERINDEX *pSuperIndex);

  HRESULT AllocateStdIndex();
  HRESULT LoadStdIndex(DWORD dwiSuperIndex, IxReadReq *pIrr);

  BOOL GetKey(AVISTDINDEX_ENTRY &rEntry);
  BYTE *GetStrf();

  unsigned m_stream;            // which stream this indexes

  RIFFCHUNK *m_pStrf;

  ULONG m_iSuperIndex;          // sub index that is loaded
  DWORDLONG m_lliTick;          // current `tick'

  BOOL m_fWaitForIndex;         // waiting for async index read
};

class CImplOldAviIndex : public CImplStdAviIndex
{
public:
  CImplOldAviIndex(
    unsigned stream,
    AVIOLDINDEX *pIdx1,
    DWORDLONG moviOffset,
    AVISTREAMHEADER *pStrh,     /* needed for stream length, rate */
    RIFFCHUNK *pStrf,           /* needed for audio streams */
    HRESULT *phr);

  HRESULT AdvancePointerBackwardPaletteChange();
  HRESULT AdvancePointerForwardPaletteChange();
  HRESULT GetLargestSampleSize(ULONG *pcbSample);

  // only for new format indexes
  HRESULT IncomingIndex(BYTE *pb, ULONG cb) { return E_UNEXPECTED; }

  // overriden because the dwLength field in old AVI files can't be
  // trusted
  HRESULT GetInfo(StreamInfo *pStreamInfo);

private:

  // return the size of a specific Index Entry
  DWORD GetEntrySize(void);

  ULONG m_cbLargestSampleSizeComputed;

};

#endif // _AviIndex_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avimsr\avimsr.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.

// AVI File parser built on CBaseMSRFilter. Plus a property bag
// implementation to read the copyright strings and such from the AVI
// file.
//
// The interesting things about it are
//
// 1. the index may be streamed in along with the data. The worker
// thread maintains this state and cannot queue new reads until the
// index is read off disk.
//
// 2. lots of customization to buffer things efficiently. tightly
// interleaved (1 to 1) files are handled differently.
//

#include <streams.h>
#include <mmreg.h>
#include "basemsr.h"
#include "avimsr.h"
#include <checkbmi.h>

// each stream works with 20 buffers if it's an interleaved file.
#define C_BUFFERS_INTERLEAVED 20

enum SampleDataType
{
  // zero means its a sample, so we can't use that value
  DATA_PALETTE = 1,
  DATA_INDEX = 2
};

// easier than computing structure sizes
static const UINT CB_STRH_SHORT = 0x24;
static const UINT CB_STRH_NORMAL = 0x30;
// and they can have 0x38 bytes if they have the rcFrame fields

// ------------------------------------------------------------------------
// setup data

const AMOVIESETUP_MEDIATYPE sudIpPinTypes =
{
  &MEDIATYPE_Stream,            // MajorType
  &MEDIASUBTYPE_Avi             // MintorType
};

const AMOVIESETUP_MEDIATYPE sudOpPinTypes =
{
  &MEDIATYPE_Video,             // MajorType
  &MEDIASUBTYPE_NULL            // MintorType
};

const AMOVIESETUP_PIN psudAvimsrPins[] =
{
  { L"Input",                     // strName
    FALSE,                        // bRendererd
    FALSE,                        // bOutput
    FALSE,                        // bZero
    FALSE,                        // bMany
    &CLSID_NULL,                  // connects to filter
    NULL,                         // connects to pin
    1,                            // nMediaTypes
    &sudIpPinTypes }              // lpMediaType
,
  { L"Output",                    // strName
    FALSE,                        // bRendererd
    TRUE,                         // bOutput
    FALSE,                        // bZero
    FALSE,                        // bMany
    &CLSID_NULL,                  // connects to filter
    NULL,                         // connects to pin
    1,                            // nMediaTypes
    &sudOpPinTypes }              // lpMediaType
};

const AMOVIESETUP_FILTER sudAvimsrDll =
{
  &CLSID_AviSplitter,           // clsID
  L"AVI Splitter",              // strName
  MERIT_NORMAL,                 // dwMerit
  2,                            // nPins
  psudAvimsrPins                // lpPin
};

// nothing to say about the output pin

#ifdef FILTER_DLL

CFactoryTemplate g_Templates[] = {
  { L"AVI Splitter"
  , &CLSID_AviSplitter
  , CAviMSRFilter::CreateInstance
  , NULL
  , &sudAvimsrDll }
  ,
  { L"CMediaPropertyBag",
    &CLSID_MediaPropertyBag,
    CMediaPropertyBag::CreateInstance,
    0,
    0
  }
};
int g_cTemplates = NUMELMS(g_Templates);

STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}

#endif // FILTER_DLL


CUnknown * CAviMSRFilter::CreateInstance (
  LPUNKNOWN pUnk,
  HRESULT* phr)
{
  if(FAILED(*phr))
    return 0;

  return new CAviMSRFilter(NAME("AVI File Reader"), pUnk, phr);
}

CAviMSRFilter::CAviMSRFilter(
  TCHAR *pName,
  LPUNKNOWN pUnk,
  HRESULT *phr) :
        CBaseMSRFilter(pName, pUnk, CLSID_AviSplitter, phr),
        m_pInfoList(0),
        m_fNoInfoList(false)
{
  m_pAviHeader = 0;
  m_pIdx1 = 0;
  m_cbMoviOffset = 0;
  m_fIsDV = false;

  if(FAILED(*phr))
    return;

  // base ctor can't do this for us.
  *phr = CreateInputPin(&m_pInPin);
}


CAviMSRFilter::~CAviMSRFilter()
{
  delete[] m_pAviHeader;
  delete[] m_pIdx1;
  ASSERT(m_pInfoList == 0);
  ASSERT(!m_fNoInfoList);
}


// ------------------------------------------------------------------------
// implementation of a virtual method. we need to find pins persisted
// by the 1.0 runtime AVI parser. tries the base class implementation
// first.

STDMETHODIMP
CAviMSRFilter::FindPin(
  LPCWSTR Id,
  IPin ** ppPin
  )
{
  CheckPointer(ppPin,E_POINTER);
  ValidateReadWritePtr(ppPin,sizeof(IPin *));

  //  We're going to search the pin list so maintain integrity
  CAutoLock lck(m_pLock);
  HRESULT hr = CBaseFilter::FindPin(Id, ppPin);
  if(hr != VFW_E_NOT_FOUND)
    return hr;

  for(UINT iStream = 0; iStream < m_cStreams; iStream++)
  {
    WCHAR wszPinName[20];
    wsprintfW(wszPinName, L"Stream %02x", iStream);
    if(0 == lstrcmpW(wszPinName, Id))
    {
      //  Found one that matches
      //
      //  AddRef() and return it
      *ppPin = m_rgpOutPin[iStream];
      (*ppPin)->AddRef();
      return S_OK;
    }
  }

  *ppPin = NULL;
  return VFW_E_NOT_FOUND;
}

HRESULT CAviMSRFilter::CreateOutputPins()
{
  ASSERT(m_pAviHeader == 0);
  ASSERT(m_pIdx1 == 0);
  ASSERT(m_cbMoviOffset == 0);

  // set in constructor and breakconnect
  ASSERT(!m_fIsDV);

  HRESULT hr = LoadHeaderParseHeaderCreatePins();
  return hr;
}

HRESULT CAviMSRFilter::NotifyInputDisconnected()
{
  CAutoLock lck(m_pLock);

  delete[] m_pAviHeader;
  m_pAviHeader = 0;

  delete[] m_pIdx1;
  m_pIdx1 = 0;

  m_cbMoviOffset = 0;
  m_fIsDV = false;

  delete[] (BYTE *)m_pInfoList;
  m_pInfoList = 0;
  m_fNoInfoList = false;

  return CBaseMSRFilter::NotifyInputDisconnected();
}

//
// read the old format index chunk if unread, return it
//
HRESULT CAviMSRFilter::GetIdx1(AVIOLDINDEX **ppIdx1)
{
  if(!(m_pAviMainHeader->dwFlags & AVIF_HASINDEX))
  {
    return VFW_E_NOT_FOUND;
  }

  HRESULT hr;
  if(!m_pIdx1)
  {
    ULONG cbIdx1;
    DWORDLONG qw;
    hr = Search(&qw, FCC('idx1'), sizeof(RIFFLIST), &cbIdx1);
    if(SUCCEEDED(hr))
    {
      hr = AllocateAndRead((BYTE **)&m_pIdx1, cbIdx1, qw);
      if(FAILED(hr))
        return hr == E_OUTOFMEMORY ? E_OUTOFMEMORY : VFW_E_INVALID_FILE_FORMAT;
    }
    else
    {
      return VFW_E_INVALID_FILE_FORMAT;
    }
  }

  ASSERT(m_pIdx1);
  *ppIdx1 = m_pIdx1;
  return S_OK;
}

// return byte offset of movi chunk
HRESULT CAviMSRFilter::GetMoviOffset(DWORDLONG *pqw)
{
  ULONG cbMovi;
  HRESULT hr = S_OK;

  if(m_cbMoviOffset == 0)
  {
    hr = SearchList(
      m_pAsyncReader,
      &m_cbMoviOffset, FCC('movi'), sizeof(RIFFLIST), &cbMovi);
  }
  if(SUCCEEDED(hr))
    *pqw = m_cbMoviOffset;
  else
    *pqw = 0;

  return SUCCEEDED(hr) ? S_OK : VFW_E_INVALID_FILE_FORMAT;
}

REFERENCE_TIME CAviMSRFilter::GetInitialFrames()
{
  return m_pAviMainHeader->dwInitialFrames *
    m_pAviMainHeader->dwMicroSecPerFrame *
    (UNITS / (MILLISECONDS * 1000));
}

HRESULT CAviMSRFilter::GetCacheParams(
  StreamBufParam *rgSbp,
  ULONG *pcbRead,
  ULONG *pcBuffers,
  int *piLeadingStream)
{
  HRESULT hr = CBaseMSRFilter::GetCacheParams(
    rgSbp,
    pcbRead,
    pcBuffers,
    piLeadingStream);
  if(FAILED(hr))
    return hr;

  // for tightly interleaved files, we try to read one record at a
  // time for cheap hardware that locks the machine if we read large
  // blocks
  if(IsTightInterleaved())
  {
    DbgLog((LOG_TRACE, 15, TEXT("CAviMSRFilter:GetCacheParams: interleaved")));

    for(UINT iStream = 0; iStream < m_cStreams; iStream++)
    {
      rgSbp[iStream].cSamplesMax = C_BUFFERS_INTERLEAVED;
    }

    // set leading stream to first audio stream. negative (from base
    // class) if we can't find one. indicates no leading stream.
    ASSERT(*piLeadingStream < 0);
    for(iStream = 0; iStream < m_cStreams; iStream++)
    {
      if(((CAviMSROutPin *)m_rgpOutPin[iStream])->GetStrh()->fccType ==
         streamtypeAUDIO)
      {
        *piLeadingStream = iStream;
        break;
      }
    }

    // one buffer per frame.
    ULONG cbRead = 0;
    for(iStream = 0; iStream < m_cStreams; iStream++)
      cbRead += m_rgpOutPin[iStream]->GetMaxSampleSize();
    *pcbRead = cbRead + 2048;   // 2k alignment in interleaved files
    if(m_pAviMainHeader->dwMicroSecPerFrame == 0)
    {
      // arbitrary number of buffers
      *pcBuffers = max(10, m_cStreams);
    }
    else
    {
      // buffers enough for .75 seconds
      *pcBuffers = max(
        ((LONG)UNITS / 10 * 3 / 4 / m_pAviMainHeader->dwMicroSecPerFrame),
        m_cStreams);
    }
  }
  else                          // not interleaved
  {
    DbgLog((LOG_TRACE, 15,
            TEXT("CAviMSRFilter:GetCacheParams: uninterleaved")));

    // no leading stream. base class sets this
    ASSERT(*piLeadingStream < 0);

    // target reading 64k at a time
    *pcbRead = 64 * 1024;

    // for files with audio after the video, we're trying to size each
    // buffer to contain one audio block and the corresponding
    // video. so for a file that looks like
    //
    // (15 v) a (15 v) a (15 v) a (15 v) a (15 v) a (15 v) a
    //
    // we need three buffers because the directsound renderer will
    // receive, copy, and release 2 buffers immediately (1 second of
    // buffering). and we need to keep from trying to read the 3rd
    // audio block into a reserve buffer.

    if(!m_fIsDV) {
        *pcBuffers = (m_cStreams > 1 ? 3 : 2);
    }
    else
    {
        // DV splitter needs to work with more than 2 buffers at once
        // and negotiating this is broken.
        *pcBuffers = 4;
    }


    // first need to find out what the largest sample in the file is.
    ULONG cbLargestSample = 0;
    ULONG cbSumOfLargestSamples = 0;
    for(UINT iStream = 0; iStream < m_cStreams; iStream++)
    {
      if(m_rgpOutPin[iStream]->GetMaxSampleSize() == 0)
        return VFW_E_INVALID_FILE_FORMAT;

      // really should add in the alignment here
      cbSumOfLargestSamples += m_rgpOutPin[iStream]->GetMaxSampleSize();

      cbLargestSample = max(
        m_rgpOutPin[iStream]->GetMaxSampleSize(),
        cbLargestSample);
    }

    if(m_cStreams > 1)
    {

      ULONG cInterleave = CountConsecutiveVideoFrames();

      // this number should be the number of video frames between audio
      // chunks
      *pcbRead = max(cbSumOfLargestSamples * cInterleave, *pcbRead);
    }
    else
    {
      // there may be some garbage around each frame (RIFF header,
      // sector alignment, etc.) so add in an extra 2k around each
      // frame.
      *pcbRead = (cbSumOfLargestSamples + 2048) * 2;
    }
  }

  return S_OK;
}

STDMETHODIMP
CAviMSRFilter::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if(riid == IID_IPersistMediaPropertyBag)
    {
        return GetInterface((IPersistMediaPropertyBag *)this, ppv);
    }
    else if(riid == IID_IAMMediaContent)
    {
        return GetInterface((IAMMediaContent *)this, ppv);
    }
    else
    {
        return CBaseMSRFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}


// ------------------------------------------------------------------------
// IPropertyBag

// ------------------------------------------------------------------------
// IPersistMediaPropertyBag

STDMETHODIMP CAviMSRFilter::Load(IMediaPropertyBag *pPropBag, LPERRORLOG pErrorLog)
{
    CheckPointer(pPropBag, E_POINTER);

    // the avi parser is read-only!
    HRESULT hr = STG_E_ACCESSDENIED;
    return hr;
}

HRESULT CAviMSRFilter::CacheInfoChunk()
{
    ASSERT(CritCheckIn(m_pLock));

    if(m_pInfoList) {
        return S_OK;
    }
    if(m_fNoInfoList) {
        return VFW_E_NOT_FOUND;
    }

    // !!! don't block waiting for progressive download

    // search the first RIFF list for an INFO list
    DWORDLONG dwlInfoPos;
    ULONG cbInfoList;
    HRESULT hr = SearchList(
      m_pAsyncReader,
      &dwlInfoPos, FCC('INFO'), sizeof(RIFFLIST), &cbInfoList);
    if(SUCCEEDED(hr))
    {
        hr = AllocateAndRead((BYTE **)&m_pInfoList, cbInfoList, dwlInfoPos);
    }

    if(FAILED(hr)) {
        ASSERT(!m_fNoInfoList);
        m_fNoInfoList = true;
    }

    return hr;

}

HRESULT ReadInfoChunk(RIFFLIST UNALIGNED *pInfoList, UINT iEntry, RIFFCHUNK UNALIGNED **ppRiff)
{
    HRESULT hr = VFW_E_NOT_FOUND;

    // alignment not guaranteed.
    RIFFCHUNK UNALIGNED * pRiff = (RIFFCHUNK *)(pInfoList + 1);// first entry

    // safe to use this limit because we know we allocated pInfoList->cb bytes.
    RIFFCHUNK * pLimit = (RIFFCHUNK *)((BYTE *)pRiff + pInfoList->cb);

    // enumerate elements of the INFO list
    while(pRiff + 1 < pLimit)
    {
        if( ((BYTE*)pRiff + pRiff->cb + sizeof(RIFFCHUNK)) > (BYTE*)pLimit )
        {
            hr = VFW_E_INVALID_FILE_FORMAT;
            break;
        }

        if(iEntry == 0)
        {
            *ppRiff = pRiff;
            hr = S_OK;
            break;
        }

        if(RIFFNEXT(pRiff) > pLimit)
        {
            hr = VFW_E_NOT_FOUND;
            break;
        }

        iEntry--;
        pRiff = RIFFNEXT(pRiff);
    }

    return hr;
}

HRESULT CAviMSRFilter::GetInfoString(DWORD dwFcc, BSTR *pbstr)
{
    *pbstr = 0;
    CAutoLock l(m_pLock);

    HRESULT hr = CacheInfoChunk();
    if(SUCCEEDED(hr)) {
        hr = GetInfoStringHelper(m_pInfoList, dwFcc, pbstr);
    }
    return hr;
}

HRESULT SaveInfoChunk(
    RIFFLIST UNALIGNED *pRiffInfo,
    IPropertyBag *pPropBag)
{
    RIFFCHUNK UNALIGNED * pRiff;
    HRESULT hr = S_OK;
    for(UINT ichunk = 0; SUCCEEDED(hr); ichunk++)
    {
        // ignore error when there are no more items
        HRESULT hrTmp = ReadInfoChunk(pRiffInfo, ichunk, &pRiff);
        if(FAILED(hrTmp)) {
            break;
        }
        if(pRiff->cb == 0) {
            DbgLog((LOG_ERROR, 0, TEXT("0 byte INFO chunk (bad file.)")));
            continue;
        }

        DWORD szProp[2];        // string dereferences as DWORD
        szProp[0] = pRiff->fcc;
        szProp[1] = 0;          // null terminate
        WCHAR wszProp[20];
        wsprintfW(wszProp, L"INFO/%hs", szProp);

        VARIANT var;
        var.vt = VT_BSTR;
        var.bstrVal = SysAllocStringLen(0, pRiff->cb);
        if(var.bstrVal)
        {
            char *sz = (char *)(pRiff + 1);
            sz[pRiff->cb - 1] = 0; // null terminate

            if(MultiByteToWideChar(
                CP_ACP, 0, sz, pRiff->cb, var.bstrVal, pRiff->cb))
            {
                hr = pPropBag->Write(wszProp, &var);
                DbgLog((LOG_TRACE, 10,
                        TEXT("CAviMSRFilter::Save: wrote %S to prop bag, hr = %08x"),
                        wszProp, hr));
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }
            SysFreeString(var.bstrVal);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

    } // for loop


    return hr;
}

HRESULT GetInfoStringHelper(RIFFLIST *pInfoList, DWORD dwFcc, BSTR *pbstr)
{
    HRESULT hr = S_OK;

    for(UINT ichunk = 0; SUCCEEDED(hr); ichunk++)
    {
        RIFFCHUNK UNALIGNED *pRiff;
        hr = ReadInfoChunk(pInfoList, ichunk, &pRiff);
        if(SUCCEEDED(hr) && pRiff->fcc == dwFcc)
        {
            *pbstr = SysAllocStringLen(0, pRiff->cb);
            if(*pbstr)
            {
                char *sz = (char *)(pRiff + 1);
                sz[pRiff->cb - 1] = 0; // null terminate

                MultiByteToWideChar(
                    CP_ACP, 0, sz, pRiff->cb, *pbstr, pRiff->cb);

                break;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}

// dump everything in the info and disp chunks into the caller's
// property bag. property names are "INFO/xxxx" and "DISP/nnnnnnnn"

STDMETHODIMP CAviMSRFilter::Save(
    IMediaPropertyBag *pPropBag,
    BOOL fClearDirty,
    BOOL fSaveAllProperties)
{
    CAutoLock lck(m_pLock);
    HRESULT hr = CacheInfoChunk();

    if(SUCCEEDED(hr))
    {
        hr = SaveInfoChunk(m_pInfoList, pPropBag);
    }


    hr = S_OK;                  // ignore errors

    // now the disp chunks
    ULONG cbDispChunk;
    DWORDLONG dwlStartPos = sizeof(RIFFLIST);
    DWORDLONG dwlDispPos;

    while(SUCCEEDED(hr) &&
          SUCCEEDED(Search(&dwlDispPos, FCC('DISP'), dwlStartPos, &cbDispChunk)))
    {
        RIFFCHUNK *pDispChunk;
        hr = AllocateAndRead((BYTE **)&pDispChunk, cbDispChunk, dwlDispPos);
        if(SUCCEEDED(hr))
        {

            // data in a disp chunk is a four byte identifier followed
            // by data
            if(pDispChunk->cb > sizeof(DWORD))
            {
                WCHAR wszProp[20];
                wsprintfW(wszProp, L"DISP/%010d", *(DWORD *)(pDispChunk + 1));


                unsigned int i;
                VARIANT var;
                SAFEARRAY * psa;
                SAFEARRAYBOUND rgsabound[1];
                rgsabound[0].lLbound = 0;
                rgsabound[0].cElements = pDispChunk->cb - sizeof(DWORD);

                psa = SafeArrayCreate(VT_UI1, 1, rgsabound);
                if(psa)
                {
                    BYTE *pbData;
                    EXECUTE_ASSERT(SafeArrayAccessData(psa, (void **)&pbData) == S_OK);
                    CopyMemory(pbData, (DWORD *)(pDispChunk + 1) + 1,
                               pDispChunk->cb - sizeof(DWORD));
                    EXECUTE_ASSERT(SafeArrayUnaccessData(psa) == S_OK);

                    VARIANT var;
                    var.vt = VT_UI1 | VT_ARRAY;
                    var.parray = psa;
                    hr = pPropBag->Write(wszProp, &var);

                    EXECUTE_ASSERT(SafeArrayDestroy(psa) == S_OK);

                    DbgLog((LOG_TRACE, 10,
                            TEXT("CAviMSRFilter::Save: wrote %S to prop bag, hr = %08x"),
                            wszProp, hr));
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            delete[] (BYTE *)pDispChunk;
        }

        dwlStartPos = dwlDispPos + cbDispChunk;
    }

    return hr;

}

STDMETHODIMP CAviMSRFilter::InitNew()
{
    return S_OK;
}

STDMETHODIMP CAviMSRFilter::GetClassID(CLSID *pClsID)
{
    return CBaseFilter::GetClassID(pClsID);
}




// ------------------------------------------------------------------------
// look for a block of video and count the consecutive video. doesn't
// work if there are two video streams.  easily fooled
ULONG CAviMSRFilter::CountConsecutiveVideoFrames()
{
  HRESULT hr;
  CAviMSROutPin *pPin;
  for(UINT i = 0; i < m_cStreams; i++)
  {
    pPin = (CAviMSROutPin *)m_rgpOutPin[i];
    if(pPin->m_pStrh->fccType == FCC('vids'))
      break;
  }
  if(i != m_cStreams)
  {

    IAviIndex *pIndx = pPin->m_pImplIndex;
    hr = pIndx->AdvancePointerStart();
    if(hr == S_OK)
    {

      DWORDLONG dwlLastOffset;

      IndexEntry ie;
      hr = pIndx->GetEntry(&ie);
      if(hr == S_OK)
      {

        // run of video frames
        ULONG cVideoRun = 1;

        for(UINT cTries = 0; cTries < 2; cTries++)
        {
          for(i = 1; i < 50; i++)
          {
            dwlLastOffset = ie.qwPos + ie.dwSize;

            hr = pIndx->AdvancePointerForward(0);
            if(hr != S_OK)
              goto Failed;

            hr = pIndx->GetEntry(&ie);
            if(hr != S_OK)
              goto Failed;

            if(ie.qwPos > dwlLastOffset + 2 * 1024)
            {
              cVideoRun = max(cVideoRun, i);
              break;
            }
          }
        } // cTries loop

        DbgLog((LOG_TRACE, 15, TEXT("avi: reporting interleaving at %d"),
                cVideoRun));

        return cVideoRun;
      }
    }
  }

Failed:

  DbgLog((LOG_ERROR, 3,
          TEXT("avi: couldn't CountConsecutiveVideoFrames. 4.")));
  return 4;
}

// parse the header (already in m_pAviHeader) and create streams
// based on the avi streams.
//
HRESULT CAviMSRFilter::ParseHeaderCreatePins()
{

  RIFFCHUNK * pRiff = (RIFFCHUNK *)m_pAviHeader;
  RIFFCHUNK * pLimit = (RIFFCHUNK *)(m_pAviHeader + m_cbAviHeader);
  while (pRiff < pLimit)
  {
    // sanity check.  chunks should be smaller than the remaining list
    // or they are not valid.
    //
    if (pRiff + 1 > pLimit || RIFFNEXT(pRiff) > pLimit)
    {
      m_cStreams = 0;
      return VFW_E_INVALID_FILE_FORMAT;
    }

    // find the main AVI header and count the stream headers
    // also make a note of the location of the odml list if any.
    //
    switch (pRiff->fcc)
    {
      case FCC('avih'):
        m_pAviMainHeader = (AVIMAINHEADER *)(void *)pRiff;
      break;

      case FCC('LIST'):
      {
        RIFFLIST * pRiffList = (RIFFLIST *)pRiff;
        if (pRiffList->fccListType == FCC('strl'))
          ++m_cStreams;
        else if (pRiffList->fccListType == FCC('odml'))
          m_pOdmlList = pRiffList;
      }
      break;
    }

    pRiff = RIFFNEXT(pRiff);
  }

  // we try to use less memory and read smaller blocks for tightly
  // interleaved files.
  m_fIsTightInterleaved = m_cStreams == 2 &&
     m_pAviMainHeader->dwFlags & AVIF_ISINTERLEAVED;

  // now know m_cStreams; create pins
  HRESULT hr = CreatePins();
  if(FAILED(hr))
    return hr;

  // parse streams
  pRiff = (RIFFCHUNK *)m_pAviHeader;
  UINT ii = 0;
  while (pRiff < pLimit)
  {
    ASSERT(pRiff + 1 <= pLimit); // from first pass
    ASSERT(RIFFNEXT(pRiff) <= pLimit);

    // parse the stream lists and find the interesting chunks
    // in each list.
    //
    RIFFLIST * pRiffList = (RIFFLIST *)pRiff;
    if (pRiffList->fcc == FCC('LIST') &&
        pRiffList->fccListType == FCC('strl'))
    {
      ASSERT(ii < m_cStreams);

      if ( ! ((CAviMSROutPin *)m_rgpOutPin[ii])->ParseHeader(pRiffList, ii))
      {
        // bit of a hack. we want to remove this stream which we
        // couldn't parse and collapse the remaining pins one slot. we
        // do this by releasing the last output pin and reusing the
        // current pin. we look only at m_cStream pins, so no one will
        // touch the pin we just released.
        ASSERT(m_cStreams > 0);
        --m_cStreams;
        m_rgpOutPin[m_cStreams]->Release();
        m_rgpOutPin[m_cStreams] = 0;
      }
      else
      {
        ++ii;
      }

    }

    pRiff = RIFFNEXT(pRiff);
  }

  // we dont expect to have fewer initialized streams than
  // allocated streams, but since it could happen, we deal with
  // it by seting the number of streams to be the number of
  // initialized streams
  //
  ASSERT (ii == m_cStreams);
  m_cStreams = ii;

  // if there are no streams, then this is obviously a problem.
  //
  if (m_cStreams <= 0)
  {
    return VFW_E_INVALID_FILE_FORMAT;
  }

  return S_OK;
}
HRESULT CAviMSRFilter::Search (
  DWORDLONG *qwPosOut,
  FOURCC fccSearchKey,
  DWORDLONG qwPosStart,
  ULONG *cb)
{
  HRESULT hr = S_OK;
  RIFFCHUNK rc;
  BYTE *pb = 0;
  *qwPosOut = 0;

  if(m_pAsyncReader == 0) 
    return E_FAIL;

  for(;;)
  {
    hr = m_pAsyncReader->SyncRead(qwPosStart, sizeof(rc), (BYTE*)&rc);
    if(hr != S_OK)
    {
      hr = VFW_E_INVALID_FILE_FORMAT;
      break;
    }

    if(rc.fcc == fccSearchKey)
    {
      *cb = rc.cb + sizeof(RIFFCHUNK);
      *qwPosOut = qwPosStart;
      return S_OK;
    }

    // handle running off the end of a preallocated file. the last
    // DWORD should be a zero.
    if(rc.fcc == 0)
    {
        hr = VFW_E_NOT_FOUND;
        break;
    }

    // AVI RIFF chunks need to be rounded up to word boundaries
    qwPosStart += sizeof(RIFFCHUNK) + ((rc.cb + 1) & 0xfffffffe);
  }

  return hr;
}

HRESULT SearchList(
  IAsyncReader *pAsyncReader,
  DWORDLONG *qwPosOut,
  FOURCC fccSearchKey,
  DWORDLONG qwPosStart,
  ULONG *cb)
{
  RIFFLIST rl;
  BYTE *pb = 0;
  HRESULT hr = S_OK;
  *qwPosOut = 0;

  if(pAsyncReader == 0)
    return E_FAIL;

  for(;;)
  {
    hr = pAsyncReader->SyncRead(qwPosStart, sizeof(rl), (BYTE*)&rl);
    if(hr != S_OK)
    {
      hr = VFW_E_INVALID_FILE_FORMAT;
      break;
    }

    if(rl.fcc == FCC('LIST') && rl.fccListType == fccSearchKey)
    {
      *cb = rl.cb + sizeof(RIFFCHUNK);
      *qwPosOut = qwPosStart;
      return S_OK;
    }

    // handle running off the end of a preallocated file. the last
    // DWORD should be a zero.
    if(rl.fcc == 0)
    {
        hr = VFW_E_NOT_FOUND;
        break;
    }

    qwPosStart += sizeof(RIFFCHUNK) + ((rl.cb + 1) & 0xfffffffe);
  }

  return hr;;
}

HRESULT CAviMSRFilter::LoadHeaderParseHeaderCreatePins()
{
  HRESULT hr;
  DbgLog((LOG_TRACE, 3, TEXT("CAviMSRFilter::LoadHeader()")));
  ASSERT(m_cStreams == 0);

  // read in the first 24 bytes of the file and check to see
  // if it is really an AVI file. if it is, determine the size
  // of the header
  //
  DWORD cbHeader = 0;

  {
    RIFFLIST * pRiffList;
    hr = AllocateAndRead((BYTE **)&pRiffList, sizeof(RIFFLIST)*2, 0);
    if(FAILED(hr))
      return hr == E_OUTOFMEMORY ? E_OUTOFMEMORY : VFW_E_INVALID_FILE_FORMAT;

    // read in the RIFF header for the avi file and for the 'hdrl' chunk.
    // by the way this code is written, we require that the 'hdrl' chunk be
    // first in the avi file, (which most readers require anyway)
    //
    if (pRiffList[0].fcc != FCC('RIFF') ||
        pRiffList[0].fccListType != FCC('AVI ') ||
        pRiffList[1].fcc != FCC('LIST') ||
        pRiffList[1].fccListType != FCC('hdrl') ||
        pRiffList[1].cb < 4)
    {
      delete[] ((LPBYTE)pRiffList);
      return VFW_E_INVALID_FILE_FORMAT;
    }

    // figure out the size of the aviheader rounded up to the next word boundary.
    // (it should really always be even, we are just being careful here)
    //
    cbHeader = pRiffList[1].cb + (pRiffList[1].cb&1) - 4;
    delete[] ((LPBYTE)pRiffList);
  }

  // now read in the entire header. if we fail to do that
  // give up and return failure.
  //
  m_cbAviHeader = cbHeader;
  ASSERT(m_pAviHeader == 0);
  hr = AllocateAndRead((BYTE **)&m_pAviHeader, cbHeader, sizeof(RIFFLIST) * 2);

  if(FAILED(hr))
    return hr == E_OUTOFMEMORY ? E_OUTOFMEMORY : VFW_E_INVALID_FILE_FORMAT;

  hr = ParseHeaderCreatePins();
  if(FAILED(hr))
  {
    delete[] m_pAviHeader;
    m_pAviHeader = 0;
  }

  return hr;
}

//
// allocate array of CAviStream

HRESULT CAviMSRFilter::CreatePins()
{
  UINT iStream;
  HRESULT hr = S_OK;

  ASSERT(m_cStreams);

  m_rgpOutPin = new CBaseMSROutPin*[m_cStreams];
  if(m_rgpOutPin == 0)
  {
    m_cStreams = 0;
    return E_OUTOFMEMORY;
  }

  for(iStream = 0; iStream < m_cStreams; iStream++)
    m_rgpOutPin[iStream] = 0;

  for(iStream = 0; iStream < m_cStreams; iStream++)
  {

    WCHAR wszPinName[20];
    wsprintfW(wszPinName, L"Stream %02x", iStream);

    m_rgpOutPin[iStream] = new CAviMSROutPin(
      this,
      this,
      iStream,
      m_pImplBuffer,
      &hr,
      wszPinName);

    if(m_rgpOutPin[iStream] == 0)
    {
      hr = E_OUTOFMEMORY;
      break;
    }

    if(FAILED(hr))
    {
      break;
    }
  }

  if(FAILED(hr))
  {
    if(m_rgpOutPin)
      for(iStream = 0; iStream < m_cStreams; iStream++)
        delete m_rgpOutPin[iStream];
    delete[] m_rgpOutPin;
    m_rgpOutPin =0;

    m_cStreams = 0;
    return hr;
  }

  for(iStream = 0; iStream < m_cStreams; iStream++)
    m_rgpOutPin[iStream]->AddRef();

  return hr;
}

HRESULT
CAviMSRFilter::CheckMediaType(const CMediaType* pmt)
{
  if(*(pmt->Type()) != MEDIATYPE_Stream)
    return E_INVALIDARG;

  if(*(pmt->Subtype()) != MEDIASUBTYPE_Avi)
    return E_INVALIDARG;

  return S_OK;
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

// ------------------------------------------------------------------------
// determine the index type and load the correct handler

HRESULT CAviMSROutPin::InitializeIndex()
{
  HRESULT hr = S_OK;

  if(m_pIndx)
  {

    m_pImplIndex = new CImplStdAviIndex(
      m_id,
      m_pIndx,
      m_pStrh,
      m_pStrf,
      m_pFilter->m_pAsyncReader,
      &hr);
  }
  else
  {
    AVIOLDINDEX *pIdx1;
    hr = ((CAviMSRFilter *)m_pFilter)->GetIdx1(&pIdx1);
    if(FAILED(hr))
      return hr;

    DWORDLONG qwMoviOffset;
    hr = ((CAviMSRFilter *)m_pFilter)->GetMoviOffset(&qwMoviOffset);
    if(FAILED(hr))
      return hr;

    m_pImplIndex = new CImplOldAviIndex(
      m_id,
      pIdx1,
      qwMoviOffset,
      m_pStrh,
      m_pStrf,
      &hr);
  }

  if(m_pImplIndex == 0)
    hr = E_OUTOFMEMORY;

  if(FAILED(hr))
  {
    delete m_pImplIndex;
    m_pImplIndex = 0;
    return hr;
  }

  return S_OK;
}

// set subtype and format type and block. deal with
// WAVEFORMATEXTENSIBLE and WAVEFORMATEX.

HRESULT SetAudioSubtypeAndFormat(CMediaType *pmt, BYTE *pbwfx, ULONG cbwfx)
{
    HRESULT hr = S_OK;
    bool fCustomSubtype = false;

    if (cbwfx < sizeof(WAVEFORMATEX))
    {
        // if the stream format in the avi file is smaller than a
        // waveformatex we need to deal with this by copying the
        // waveformat into a temporary waveformatex structure, then
        // using that to fill in the mediatype format
        //
        WAVEFORMATEX wfx;
        ZeroMemory(&wfx, sizeof(wfx));
        CopyMemory(&wfx, pbwfx, cbwfx);
        if(!pmt->SetFormat ((BYTE *)&wfx, sizeof(wfx))) {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        WAVEFORMATEX *pwfx = (WAVEFORMATEX *)(pbwfx);

        if(pwfx->wFormatTag == WAVE_FORMAT_EXTENSIBLE &&
           cbwfx >= sizeof(WAVEFORMATEXTENSIBLE))
        {
            WAVEFORMATEXTENSIBLE *pwfxe = (WAVEFORMATEXTENSIBLE *)(pbwfx);

            // we've chosen not to support any mapping of an extensible
            // format back to the old format.

            if(pmt->SetFormat (pbwfx, cbwfx))
            {
                fCustomSubtype = true;
                pmt->SetSubtype(&pwfxe->SubFormat);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            // format in the avifile is >= waveformatex, so just
            // copy it into the mediaformat buffer
            //
            if(!pmt->SetFormat (pbwfx, cbwfx)) {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        // some things refuse PCM with non-zero cbSize. zero cbSize
        // for PCM until this components are changed.
        //
        WAVEFORMATEX *pwfxNew = (WAVEFORMATEX *)(pmt->pbFormat);
        if(pwfxNew->wFormatTag == WAVE_FORMAT_PCM)
        {
            if(pwfxNew->cbSize != 0) {
                DbgLog((LOG_ERROR, 0, TEXT(
                    "SetAudioSubtypeAndFormat: pcm w/ non-zero cbSize")));
            }
            pwfxNew->cbSize = 0;
        }

        pmt->formattype = FORMAT_WaveFormatEx;

        if(!fCustomSubtype) {

            pmt->SetSubtype(
                &FOURCCMap(((WAVEFORMATEX *)pmt->pbFormat)->wFormatTag));
        }
    }

    return hr;
}

HRESULT CAviMSROutPin::BuildMT()
{
  // ParseHeader guarantees these
  ASSERT(m_pStrh && m_pStrf);

  FOURCCMap fccMapSubtype = m_pStrh->fccHandler;
  FOURCCMap fccMapType = m_pStrh->fccType;
  if(m_pStrh->fccType != FCC('al21'))
  {
      m_mtFirstSample.SetType(&fccMapType);
      // subtype corrected below
      m_mtFirstSample.SetSubtype(&fccMapSubtype);
  }
  else
  {
      m_mtFirstSample.SetType(&MEDIATYPE_AUXLine21Data);
      m_mtFirstSample.SetSubtype(&MEDIASUBTYPE_Line21_BytePair);
  }

  StreamInfo si;
  HRESULT hr = m_pImplIndex->GetInfo(&si);
  if(FAILED(hr))
    return hr;

  if(si.dwLength != m_pStrh->dwLength)
    m_pStrh->dwLength = si.dwLength;

  m_mtFirstSample.bTemporalCompression = si.bTemporalCompression;

  if(m_pStrh->cb >= CB_STRH_NORMAL && m_pStrh->dwSampleSize)
  {
    m_mtFirstSample.SetSampleSize (m_pStrh->dwSampleSize);
  }
  else
  {
    m_mtFirstSample.SetVariableSize ();
  }

  if((m_pStrh->fccType == FCC('iavs')) ||
     (m_pStrh->fccType == FCC('vids') &&
      (m_pStrh->fccHandler == FCC('dvsd') ||
       m_pStrh->fccHandler == FCC('dvhd') ||
       m_pStrh->fccHandler == FCC('dvsl'))))
  {
    ((CAviMSRFilter *)m_pFilter)->m_fIsDV = true;
  }

  if((m_pStrh->fccType == FCC('iavs')) &&
     (m_pStrh->fccHandler == FCC('dvsd') ||
      m_pStrh->fccHandler == FCC('dvhd') ||
      m_pStrh->fccHandler == FCC('dvsl')))
  {
    m_mtFirstSample.SetFormat ((BYTE *)(m_pStrf+1), m_pStrf->cb);
    m_mtFirstSample.formattype = FORMAT_DvInfo;
  }
  else if (m_pStrh->fccType == streamtypeAUDIO)
  {
      HRESULT hrTmp = SetAudioSubtypeAndFormat(
          &m_mtFirstSample, (BYTE  *)(m_pStrf + 1), m_pStrf->cb);
      if(FAILED(hrTmp)) {
          return hrTmp;
      }
  }
  else if (m_pStrh->fccType == FCC('vids'))
  {
    // the format info in an AVI is a subset of the videoinfo stuff so
    // we need to build up a videoinfo from stream header & stream
    // format chunks.
    //
    if (!ValidateBitmapInfoHeader((const BITMAPINFOHEADER *)GetStrf(),
                                  m_pStrf->cb)) {
        return E_INVALIDARG;
    }
    VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *)new BYTE[SIZE_PREHEADER+ m_pStrf->cb];
    if(pvi == 0)
      return E_OUTOFMEMORY;
    VIDEOINFOHEADER &vi = *pvi;

    ZeroMemory(pvi, SIZE_PREHEADER);
    CopyMemory(&vi.bmiHeader, GetStrf(), m_pStrf->cb);

    // probably a badly authored file if this isn't true
    if(m_pStrf->cb >= sizeof(BITMAPINFOHEADER))
    {
      // fixup for avi files broken in this way (nike301.avi)
      if((m_pStrh->fccHandler == FCC('RLE ') || m_pStrh->fccHandler == FCC('MRLE')) &&
         vi.bmiHeader.biCompression == BI_RGB &&
         vi.bmiHeader.biBitCount == 8)
      {
        vi.bmiHeader.biCompression = BI_RLE8;
        // o/w leave it as is. do the same fix for rle4?
      }

      // sometimes the biSizeImage field is set incorrectly.
      // work out what it should be - only OK for uncompressed images

      if (vi.bmiHeader.biCompression == BI_RGB ||
          vi.bmiHeader.biCompression == BI_BITFIELDS)
      {
        // the image is not compressed
        DWORD dwImageSize = vi.bmiHeader.biHeight * DIBWIDTHBYTES(vi.bmiHeader);

        // assume that biSizeImage is correct, or if not that it
        // might be OK to get biSizeImage from dwSuggestedBufferSize
        // This acts as a check that we only alter values when
        // there is a real need to do so, and that the new value
        // we insert is reasonable.
        ASSERT((dwImageSize == vi.bmiHeader.biSizeImage)  || (dwImageSize == GetMaxSampleSize()));
        if (dwImageSize != vi.bmiHeader.biSizeImage) {
          DbgLog((LOG_TRACE, 1,
                  "Set biSizeImage... to %d (was %d)  Width %d  Height %d (%d)",
                  dwImageSize, vi.bmiHeader.biSizeImage,
                  vi.bmiHeader.biWidth, vi.bmiHeader.biHeight,
                  vi.bmiHeader.biWidth * vi.bmiHeader.biHeight));
          vi.bmiHeader.biSizeImage = dwImageSize;
        }
      } else {
        DbgLog((LOG_TRACE, 4, "We have a compressed image..."));
      }

      if(m_pStrh->fccHandler == FCC('dvsd') ||
         m_pStrh->fccHandler == FCC('dvhd') ||
         m_pStrh->fccHandler == FCC('dvsl'))
      {
          FOURCCMap fcc(m_pStrh->fccHandler);
          m_mtFirstSample.SetSubtype(&fcc);
      }
      else
      {
          GUID subtype = GetBitmapSubtype(&vi.bmiHeader);
          m_mtFirstSample.SetSubtype(&subtype);
      }
    }

    SetRect(&vi.rcSource, 0, 0, 0, 0);
    SetRectEmpty(&vi.rcTarget);

    vi.dwBitRate = 0;
    vi.dwBitErrorRate = 0;

    // convert scale/rate (sec/tick) to avg 100ns ticks per frame
    vi.AvgTimePerFrame = ((LONGLONG)m_pStrh->dwScale * UNITS) /
      m_pStrh->dwRate;

    // put the format into the mediatype
    //
    m_mtFirstSample.SetFormat((BYTE *)&vi, FIELD_OFFSET(VIDEOINFOHEADER,bmiHeader) +
                          m_pStrf->cb);
    m_mtFirstSample.formattype = FORMAT_VideoInfo;

    delete[] pvi;
  }
  else
  {
    if(m_pStrf->cb != 0)
    {
      m_mtFirstSample.SetFormat ((BYTE *)(m_pStrf+1), m_pStrf->cb);
      // format type same as media type
      m_mtFirstSample.formattype = FOURCCMap(m_pStrh->fccType);
    }
    else
    {
      // probably not neccessary
      m_mtFirstSample.ResetFormatBuffer();
    }
  }

  return S_OK;
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

CAviMSRWorker::CAviMSRWorker(
  UINT stream,
  IMultiStreamReader *pReader,
  IAviIndex *pImplIndex) :
    CBaseMSRWorker(stream, pReader),
    m_pImplIndex(pImplIndex),
    m_fFixMPEGAudioTimeStamps(false)
{
  m_cbAudioChunkOffset = 0xffffffff;

#ifdef PERF
  char foo[1024];

  lstrcpy(foo, "pin00 avimsr index");
  foo[4] += m_id % 10;
  foo[3] += m_id / 10;

  m_perfidIndex = MSR_REGISTER(foo);
#endif
}

HRESULT CAviMSRWorker::PushLoopInit(
  LONGLONG *pllCurrentOut,
  ImsValues *pImsValues)
{
  m_IrrState = IRR_NONE;

  HRESULT hr;

  hr = m_pImplIndex->Reset();
  if(FAILED(hr))
    return hr;

  m_pStrh = ((CAviMSROutPin *)m_pPin)->GetStrh();

  m_fDeliverPaletteChange = false;

  // first thing delivered when thread is restarted is a discontinuity.
  m_fDeliverDiscontinuity = true;

  m_fFixMPEGAudioTimeStamps = false;

  if(m_pStrh->fccType == streamtypeVIDEO)
  {
    hr = m_pImplIndex->SetPointer(pImsValues->llTickStart);
    if(FAILED(hr))
    {
      DbgLog((LOG_ERROR, 5, TEXT("CAviMSRWorker::PLI: SetPointer %08x"), hr));
      return hr;
    }

    // locate right palette chunk
    if(m_pStrh->dwFlags & AVISF_VIDEO_PALCHANGES)
    {
      hr = m_pImplIndex->AdvancePointerBackwardPaletteChange();
      if(FAILED(hr))
      {
        // !!! IAviIndex should define proper errors
        if(hr != HRESULT_FROM_WIN32(ERROR_NEGATIVE_SEEK))
        {
          DbgLog((LOG_ERROR, 5, TEXT("CAviMSRWorker::APBPC: %08x"), hr));
          return hr;
        }


        m_fDeliverPaletteChange = true;
        hr = m_pPin->GetMediaType(0, &m_mtNextSample);
        ASSERT(SUCCEEDED(hr));

      }
      else
      {
        // need to read data for the palette. DoRunLoop insists on
        // starting with cPendingReads = 0, so use a synchronous read
        IndexEntry iePal;
        hr = m_pImplIndex->GetEntry(&iePal);
        ASSERT(SUCCEEDED(hr));
        ASSERT(iePal.bPalChange);

        if(iePal.dwSize < sizeof(LOGPALETTE))
        {
          DbgLog((LOG_ERROR, 1,
                  TEXT("CAviMSRWorker::PushLoopInit: bad pal change")));
          return VFW_E_INVALID_FILE_FORMAT;
        }

        // could do this in the memory we allocated in the media type
        // and transform in place.
        BYTE *pb = new BYTE[iePal.dwSize];
        if(pb == 0)
          return E_OUTOFMEMORY;
        hr = m_pReader->SynchronousRead(pb, iePal.qwPos, iePal.dwSize);
        if(FAILED(hr))
        {
          delete[] pb;
          return hr;
        }
        hr = HandlePaletteChange(pb, iePal.dwSize);
        delete[] pb;
        if(FAILED(hr))
          return hr;
      } // AdvancePointerBackwardPaletteChange succeeded
    } // palette changes in file?
  } // video?

  // set the index's notion of current time.
  hr = m_pImplIndex->SetPointer(pImsValues->llTickStart);
  if(FAILED(hr))
  {
    DbgLog((LOG_ERROR, 5, TEXT("CAviMSRWorker::PLI: SetPointer %08x"), hr));

    // obsoleted by code to not trust dwLength in header for old files
    // // supress this error for corrupt old format files. happens
    // // because the index has zero size index entries by mistake
    // if(m_pStrh->fccType == streamtypeAUDIO &&
    //    hr == HRESULT_FROM_WIN32(ERROR_HANDLE_EOF) &&
    //    ((CAviMSROutPin *)m_pPin)->m_pIndx == 0)
    // {
    //   DbgLog((LOG_ERROR, 5, TEXT("CAviMSRWorker: supressing error")));
    //   return VFW_S_NO_MORE_ITEMS;
    // }

    return hr;
  }

  *pllCurrentOut = pImsValues->llTickStart; // updated for video

  if(m_pStrh->fccType == streamtypeAUDIO)
  {
    // handle seeking into the middle of an audio chunk by computing
    // byte offset of first block

    IndexEntry indexEntry;
    hr = m_pImplIndex->GetEntry(&indexEntry);
    ASSERT(SUCCEEDED(hr));
    DbgLog(( LOG_TRACE, 5,
             TEXT("PushLoopInit: current entry %d %d %d"),
             (ULONG)indexEntry.llStart,
             (ULONG)pImsValues->llTickStart,
             (ULONG)indexEntry.llEnd
             ));

    CopyMemory(&m_wfx, ((CAviMSROutPin *)m_pPin)->GetStrf(), sizeof(PCMWAVEFORMAT));
    m_wfx.cbSize = 0;
    ULONG nBlockAlign = m_wfx.nBlockAlign;

    ULONG cbSkip;
    if(pImsValues->llTickStart >= indexEntry.llStart)
      cbSkip = (ULONG)(pImsValues->llTickStart - indexEntry.llStart) * nBlockAlign;
    else
      cbSkip = 0;

    if (m_wfx.wFormatTag == WAVE_FORMAT_MPEG ||
        m_wfx.wFormatTag == WAVE_FORMAT_MPEGLAYER3) {
        m_fFixMPEGAudioTimeStamps = true;
    }

    DbgLog(( LOG_TRACE, 5,
             TEXT("PushLoopInit: audio skip %d bytes"),
             cbSkip));

    m_cbAudioChunkOffset = cbSkip;
    *pllCurrentOut = max(pImsValues->llTickStart, indexEntry.llStart);
  }
  else if(m_pStrh->fccType != streamtypeAUDIO)
  {
    // go back to a key frame
    hr = m_pImplIndex->AdvancePointerBackwardKeyFrame();
    if(FAILED(hr))
    {
      DbgLog((LOG_ERROR, 5, TEXT("CAviMSRWorker::PLI: APBKF %08x"), hr));
      return VFW_E_INVALID_FILE_FORMAT;
    }

    IndexEntry indexEntry;

    hr = m_pImplIndex->GetEntry(&indexEntry);
    // cannot fail if the SetPointer or AdvancePointer succeeded
    ASSERT(SUCCEEDED(hr));

    // this is valid even if it's a palette change
    *pllCurrentOut = indexEntry.llStart;
  } // video ?

  return S_OK;
}

HRESULT CAviMSRWorker::TryQueueSample(
  LONGLONG &rllCurrent,         // current time updated
  BOOL &rfQueuedSample,         // [out] queued sample?
  ImsValues *pImsValues
  )
{
  HRESULT hr;
  rfQueuedSample = FALSE;
  CAviMSROutPin *pPin = (CAviMSROutPin *)m_pPin;

  if(m_IrrState == IRR_REQUESTED)
  {
    hr = QueueIndexRead(&m_Irr);
    if(hr == S_OK)
    {
      rfQueuedSample = TRUE;
      m_IrrState = IRR_QUEUED;
      return S_OK;
    }
    else
    {
      ASSERT(FAILED(hr) || hr == S_FALSE);
      return hr;
    }
  }
  else if(m_IrrState == IRR_QUEUED)
  {
    return S_FALSE;
  }

  BOOL fFinishedCurrentEntry = TRUE;

  // sample passed into QueueRead().
  CRecSample *pSampleOut = 0;

  IndexEntry currentEntry;
  hr = m_pImplIndex->GetEntry(&currentEntry);
  if(FAILED(hr)) {
    DbgBreak("avimsr: internal error with index.");
    return hr;
  }

  if(rllCurrent > pImsValues->llTickStop)
  {
    DbgLog((LOG_TRACE,5,TEXT("CAviMSRWorker::TryQSample: tCurrent > tStop")));
    return VFW_S_NO_MORE_ITEMS;
  }

// for video (and other non-audio) streams we may be able to deliver
// partial samples from the last frame, but for audio we can't handle
// partial samples. not special casing this means the code below will
// try to issue a zero byte read for audio.
//
//    else if (m_pStrh->fccType == streamtypeAUDIO &&
//             rllCurrent == pImsValues->llTickStop)
//    {
//      DbgLog((LOG_TRACE,5,TEXT("CAviMSRWorker::TryQSample: tCurrent == tStop, audio")));
//      return VFW_S_NO_MORE_ITEMS;
//    }

  // this number may be changed if we are not delivering an entire
  // audio chunk
  LONGLONG llEndDeliver = currentEntry.llEnd;

  DWORD dwSizeRead = 0;
  if(currentEntry.dwSize != 0)
  {
    // get an empty sample w/ no allocated space. ok if this blocks
    // because we configured it with more samples than there are
    // SampleReqs for this stream in the buffer. that means that if
    // it blocks it is because down stream filters have refcounts on
    // samples
    hr = m_pPin->GetDeliveryBufferInternal(&pSampleOut, 0, 0, 0);
    if(FAILED(hr))
    {
      DbgLog((LOG_TRACE, 5, TEXT("CAviMSRWorker::PushLoop: getbuffer failed")));
      return hr;
    }

    ASSERT(pSampleOut != 0);

    // set in our GetBuffer.
    ASSERT(pSampleOut->GetUser() == 0);

    DWORDLONG qwPosRead = currentEntry.qwPos;
    dwSizeRead = currentEntry.dwSize;

    if(m_pStrh->fccType == streamtypeVIDEO)
    {
      if(currentEntry.bPalChange)
      {
        DbgLog((LOG_TRACE, 5, TEXT("CAviMSRWorker::TryQueueSample: palette")));

        // reject palette changes that are too small to be valid
        if(dwSizeRead < sizeof(LOGPALETTE))
        {
          pSampleOut->Release();
          DbgLog((LOG_ERROR, 1,
                  TEXT("CAviMSRWorker::TryQueueSample: bad pal change")));
          return VFW_E_INVALID_FILE_FORMAT;
        }

        // many sample attributes unset. !!! if going backwards, want to
        // pick up the last palette change

        // indicate palette change.
        pSampleOut->SetUser(DATA_PALETTE);

        DbgLog((
          LOG_TRACE, 5,
          TEXT("CAviMSRWorker::TryQSample: queued pc: size=%5d, ms %08x"),
          dwSizeRead,
          (ULONG)qwPosRead ));

        // do not change rtCurrent

      } // palette change?
    } // video?
    else if(m_pStrh->fccType == streamtypeAUDIO)
    {
      // even though m_cbAudioChunkOffset may not be zero, the
      // rtCurrent time is right and is what we deliver.
      qwPosRead += m_cbAudioChunkOffset;
      dwSizeRead -= m_cbAudioChunkOffset;

      // may have to read a partial RIFF chunk if the end of the audio
      // selection is in the middle of the RIFF chunk.
      ASSERT(m_cbAudioChunkOffset % m_wfx.nBlockAlign == 0);
      if(llEndDeliver > pImsValues->llTickStop)
      {
          ULONG cTicksToTrim = (ULONG)(llEndDeliver - pImsValues->llTickStop);
          DbgLog((LOG_TRACE, 5, TEXT("avimsr: trimming audio: %d ticks"),
                  cTicksToTrim));
          dwSizeRead -= cTicksToTrim * m_wfx.nBlockAlign;

          // there are some cases where playing the audio sample where
          // the end time is on a riff chunk boundary or playing past
          // the end of the stream produces this assert
          if(dwSizeRead == 0) {
              DbgLog((LOG_ERROR, 0, TEXT("avi TryQueueSample: 0 byte read")));
          }
      }

      ULONG cbMaxAudio = pPin->m_cbMaxAudio;
      // oversized audio chunk?
      if(dwSizeRead > cbMaxAudio)
      {
        // adjust read
        ULONG nBlockAlign = m_wfx.nBlockAlign;
        dwSizeRead = cbMaxAudio;
        if(dwSizeRead % nBlockAlign != 0)
          dwSizeRead -= dwSizeRead % nBlockAlign;

        // adjust time stamps, end time
        llEndDeliver = rllCurrent + dwSizeRead / nBlockAlign;
        fFinishedCurrentEntry = FALSE;
      }
    } // audio?

    pSampleOut->SetPreroll(currentEntry.llEnd <= pImsValues->llTickStart);
    pSampleOut->SetSyncPoint(currentEntry.bKey);

    // first thing we send is discontinuous from the last thing they
    // receive.
    //
    // now we just look at the m_fDeliverDiscontinuity bit
    //
    ASSERT(rllCurrent != m_llPushFirst || m_fDeliverDiscontinuity);

    ASSERT(pSampleOut->IsDiscontinuity() != S_OK);
    if(m_fDeliverDiscontinuity) {
        pSampleOut->SetDiscontinuity(true);
    }

    hr = pSampleOut->SetActualDataLength(currentEntry.dwSize);
    ASSERT(SUCCEEDED(hr));      // !!!

    //
    // compute sample times and media times.
    //
    REFERENCE_TIME rtstStart, rtstEnd;

    // not using IMediaSelection or using samples or frames.
    if(m_Format != FORMAT_TIME)
    {
      LONGLONG llmtStart = rllCurrent, llmtEnd = llEndDeliver;

      // report media time as ticks
      llmtStart -= pImsValues->llTickStart;
      llmtEnd -= pImsValues->llTickStart;

      // report ref time as exact multiple of ticks
      rtstStart = m_pPin->ConvertInternalToRT(llmtStart);
      rtstEnd = m_pPin->ConvertInternalToRT(llmtEnd);
    }
    else
    {
      ASSERT(m_Format == FORMAT_TIME);

      rtstStart = m_pPin->ConvertInternalToRT(rllCurrent);
      rtstEnd = m_pPin->ConvertInternalToRT(llEndDeliver);

      // DbgLog((LOG_TRACE, 1, TEXT("unadjusted times: %d-%d"),
      //        (LONG)rtstStart, (LONG)rtstEnd));

      // use IMediaSelection value to handle playing less than one frame
      ASSERT(rtstStart <= pImsValues->llImsStop);
      rtstStart -= pImsValues->llImsStart;
      rtstEnd = min(rtstEnd, pImsValues->llImsStop) - pImsValues->llImsStart;
    }

    LONGLONG llmtStartAdjusted = rllCurrent;
    LONGLONG llmtEndAdjusted = llEndDeliver;
    pSampleOut->SetMediaTime(&llmtStartAdjusted, &llmtEndAdjusted);

    // adjust both times by Rate
    if(pImsValues->dRate != 0 && pImsValues->dRate != 1)
    {
      // scale up and divide?
      rtstStart = (REFERENCE_TIME)((double)rtstStart / pImsValues->dRate);
      rtstEnd = (REFERENCE_TIME)((double)rtstEnd / pImsValues->dRate);
    }

    pSampleOut->SetTime(&rtstStart, &rtstEnd);
    pSampleOut->SetMediaType(0);

    DbgLog((
      LOG_TRACE, 5,
      TEXT("CAviMSRWorker::queued cb=%5d, %07d-%07d%c ms %08x mt=%08d-%08d"),
      dwSizeRead,
      (ULONG)(rtstStart / (UNITS / MILLISECONDS)),
      (ULONG)(rtstEnd / (UNITS / MILLISECONDS)),
      currentEntry.llEnd <= pImsValues->llTickStart ? 'p' : ' ',
      (ULONG)qwPosRead,
      (ULONG) rllCurrent, (ULONG)llEndDeliver ));


    hr = m_pReader->QueueReadSample(
      qwPosRead,
      dwSizeRead,
      pSampleOut,
      m_id);

    pSampleOut->Release();
    pSampleOut = 0;

    if(hr == E_OUTOFMEMORY)
    {
      DbgLog((LOG_TRACE, 5,
              TEXT("CAviMSRWorker::TryQSample: q full (normal)") ));
      return S_FALSE;
    }

    if(FAILED(hr))
    {
      DbgLog((LOG_TRACE, 5, TEXT("CAviMSRWorker::TryQSample: QRS failed") ));

      if(hr == VFW_E_BUFFER_OVERFLOW)
        hr = VFW_E_INVALID_FILE_FORMAT;

      return hr;
    }

    ASSERT(SUCCEEDED(hr));
    rfQueuedSample = TRUE;
    m_fDeliverDiscontinuity = false; // reset after sample queued successfully

  } // zero byte?
  else
  {
    // zero byte sample (for dropped frame). do nothing.
    rfQueuedSample = FALSE;

    // hack: make dv splitter send discontinuity with dropped audio so
    // that the audio renderer plays silence
    if(m_pStrh->fccType == FCC('iavs')) {
        m_fDeliverDiscontinuity = true; // set discontinuity on next real sample
    }
  }

  rllCurrent = llEndDeliver;

  // reached the end?
  if(fFinishedCurrentEntry)
  {

    m_cbAudioChunkOffset = 0;
    hr = m_pImplIndex->AdvancePointerForward(&m_Irr);
    if(hr == HRESULT_FROM_WIN32(ERROR_HANDLE_EOF))
    {
      if(rllCurrent < m_pStrh->dwLength + m_pStrh->dwStart)
      {
        DbgLog((LOG_ERROR, 1,
                TEXT("CAviMSRWorker::TryQSample: index end -- invalid file")));
        return VFW_E_INVALID_FILE_FORMAT;
      }
      else
      {
        return VFW_S_NO_MORE_ITEMS;
      }
    }
    else if(FAILED(hr))
    {
      DbgLog((LOG_ERROR,2,
              TEXT("CAviMSRWorker::TryQSample: index error %08x"), hr));
      return hr;
    }
    else if(hr == S_FALSE)
    {
      ASSERT(m_IrrState == IRR_NONE);
      m_IrrState = IRR_REQUESTED;
    }
  }
  else
  {
    ASSERT(m_pStrh->fccType == streamtypeAUDIO);
    ASSERT(dwSizeRead != 0);
    m_cbAudioChunkOffset += dwSizeRead;
  }

  return S_OK;
}

HRESULT CAviMSRWorker::QueueIndexRead(IxReadReq *pIrr)
{
  CRecSample *pIxSample;
  HRESULT hr = m_pPin->GetDeliveryBufferInternal(&pIxSample, 0, 0, 0);
  if(FAILED(hr))
    return hr;

  ASSERT(pIxSample != 0);
  ASSERT(pIxSample->GetUser() == 0); // set in our GetBuffer.
  pIxSample->SetUser(DATA_INDEX);
  hr = pIxSample->SetActualDataLength(pIrr->cbData);
  if(FAILED(hr))
    goto Bail;

  // leave other fields empty

  DbgLog((LOG_TRACE, 5, TEXT("CAviMSRWorker: queueing index read")));

  DbgLog((
      LOG_TRACE, 5,
      TEXT("CAviMSRWorker::queued index cb=%5d@%08x, pSample=%08x"),
      pIrr->cbData,
      (ULONG)pIrr->fileOffset,
      pIxSample));


  hr = m_pReader->QueueReadSample(
    pIrr->fileOffset,
    pIrr->cbData,
    pIxSample,
    m_id,
    true);                      // out of order

  if(SUCCEEDED(hr))
    hr = S_OK;
  else if(hr == E_OUTOFMEMORY)
    hr = S_FALSE;
  else if(hr == VFW_E_BUFFER_OVERFLOW)
    hr = VFW_E_INVALID_FILE_FORMAT;

  if(hr == S_OK)
      MSR_START(m_perfidIndex);
Bail:
  pIxSample->Release();
  return hr;
}

HRESULT CAviMSRWorker::HandleData(IMediaSample *pSample, DWORD dwUser)
{
  BYTE *pb;
  HRESULT hr = pSample->GetPointer(&pb);
  ASSERT(SUCCEEDED(hr));
  LONG cbLength = pSample->GetActualDataLength();

  if(dwUser == DATA_PALETTE)
    return HandlePaletteChange(pb, cbLength);
  else if(dwUser == DATA_INDEX)
    return HandleNewIndex(pb, cbLength);

  DbgBreak("blah");
  return E_UNEXPECTED;
}

// palette data came in; prepare a new media type
HRESULT CAviMSRWorker::HandlePaletteChange(BYTE *pbChunk, ULONG cbChunk)
{
  m_mtNextSample = m_pPin->CurrentMediaType();
  VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *) m_mtNextSample.Format();

  // actual structure of palette
  struct AviPaletteInternal
  {
    BYTE bFirstEntry;           // first entry to change
    BYTE bNumEntries;           // # entries to change, 0 means 256
    WORD wFlags;                // mostly to preserve alignment
    PALETTEENTRY peNew[];       // new colors
  };
  AviPaletteInternal *pAp = (AviPaletteInternal *)pbChunk;

  if((pvi->bmiHeader.biClrUsed <= 0) || (pvi->bmiHeader.biBitCount != 8))
  {
    DbgLog(( LOG_ERROR, 1, TEXT("HandlePaletteChange: bad palette change")));
    return VFW_E_INVALID_FILE_FORMAT;
  }

  ULONG cPalEntries = pAp->bNumEntries == 0 ? 256 : pAp->bNumEntries;

  // make sure the palette chunk is not short
  if(cPalEntries * sizeof(PALETTEENTRY) > cbChunk - 2 * sizeof(WORD))
  {
    DbgLog((LOG_ERROR, 5, TEXT("bad palette")));
    return VFW_E_INVALID_FILE_FORMAT;
  }

  // make sure there's enough room in the palette. we seem to always
  // allocate 256, so this shouldn't be a problem.
  if(cPalEntries + pAp->bFirstEntry > pvi->bmiHeader.biClrUsed)
  {
    DbgBreak("avimsr: internal palette error? bailing.");
    DbgLog((LOG_ERROR, 5, TEXT("too many new colours")));
    return VFW_E_INVALID_FILE_FORMAT;
  }

  for (UINT i = 0; i < cPalEntries; i++)
  {
    RGBQUAD *pQuad = &(COLORS(pvi)[i + pAp->bFirstEntry]);
    pQuad->rgbRed   = pAp->peNew[i].peRed;
    pQuad->rgbGreen = pAp->peNew[i].peGreen;
    pQuad->rgbBlue  = pAp->peNew[i].peBlue;
    pQuad->rgbReserved = 0;
  }

  m_fDeliverPaletteChange = true;
  return S_OK;
}

// new index came in.
HRESULT CAviMSRWorker::HandleNewIndex(BYTE *pb, ULONG cb)
{
  DbgLog((LOG_TRACE, 10, TEXT("avimsr %d: new index came in."), m_id ));


  m_IrrState = IRR_NONE;
  MSR_STOP(m_perfidIndex);
  return m_pImplIndex->IncomingIndex(pb, cb);
}

HRESULT CAviMSRWorker::AboutToDeliver(IMediaSample *pSample)
{
  if(m_fDeliverPaletteChange)
  {
    m_fDeliverPaletteChange = false;
    HRESULT hr = pSample->SetMediaType(&m_mtNextSample);

    if (FAILED(hr))
        return hr;
  } else if (m_fFixMPEGAudioTimeStamps) {
    if (!FixMPEGAudioTimeStamps(pSample, m_cSamples == 0, &m_wfx)) {
        //  Don't use this one
        return S_FALSE;
    }
  }
  return CBaseMSRWorker::AboutToDeliver(pSample);
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------


CAviMSROutPin::CAviMSROutPin(
  CBaseFilter *pOwningFilter,
  CBaseMSRFilter *pFilter,
  UINT iStream,
  IMultiStreamReader *&rpImplBuffer,
  HRESULT *phr,
  LPCWSTR pName) :
    CBaseMSROutPin(
      pOwningFilter,
      pFilter,
      iStream,
      rpImplBuffer,
      phr,
      pName)
  ,m_pStrh (0)
  ,m_pStrf (0)
  ,m_pIndx (0)
  ,m_pImplIndex (0)
  ,m_cbMaxAudio (0)
  ,m_pStrn(0)
{
}

CAviMSROutPin::~CAviMSROutPin()
{
  delete m_pImplIndex;
}

STDMETHODIMP CAviMSROutPin::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
  if(riid == IID_IPropertyBag)
  {
    return GetInterface((IPropertyBag *)this, ppv);
  }
  return CBaseMSROutPin::NonDelegatingQueryInterface(riid, ppv);
}

REFERENCE_TIME CAviMSROutPin::GetRefTime(ULONG tick)
{
  ASSERT(m_pStrh->dwRate != 0);  // ParseHeader guarantees this
  LONGLONG rt = (LONGLONG)tick * m_pStrh->dwScale * UNITS / m_pStrh->dwRate;
  return rt;
}

ULONG CAviMSROutPin::GetMaxSampleSize()
{
  ULONG cb;

  // note could return the largest index size for new format index.
  HRESULT hr = m_pImplIndex->GetLargestSampleSize(&cb);
  if(FAILED(hr))
    return 0;

  // cannot trust dwSuggestedBufferSize in old format avi files. file
  // has new format index?
  if(m_pIndx != 0)
    return max(cb, m_pStrh->dwSuggestedBufferSize);

  if(m_pStrh->fccType == streamtypeAUDIO && cb > m_cbMaxAudio)
  {
    ASSERT(m_cbMaxAudio != 0);
    cb = m_cbMaxAudio;
  }

  return cb;
}

inline BYTE * CAviMSROutPin::GetStrf()
{
  ASSERT(sizeof(*m_pStrf) == sizeof(RIFFCHUNK));
  return (BYTE *)(m_pStrf + 1);
}

inline AVISTREAMHEADER *CAviMSROutPin::GetStrh()
{
  return m_pStrh;
}

// ------------------------------------------------------------------------

HRESULT CAviMSROutPin::GetDuration(LONGLONG *pllDur)
{
  *pllDur = ConvertFromTick(
    m_pStrh->dwLength + m_pStrh->dwStart,
    &m_guidFormat);

  return S_OK;
}

HRESULT CAviMSROutPin::GetAvailable(
  LONGLONG * pEarliest,
  LONGLONG * pLatest)
{
  HRESULT hr = S_OK;
  if(pEarliest)
    *pEarliest = 0;
  if(pLatest)
  {
    // ask the source file reader how much of the file is available
    LONGLONG llLength, llAvail;
    m_pFilter->m_pAsyncReader->Length(&llLength, &llAvail);

    // entries in index may not match length in header (or index), so
    // report the full length in this case
    if(llLength == llAvail)
    {
      *pLatest = GetStreamLength() + GetStreamStart();
    }
    else
    {
      hr = m_pImplIndex->MapByteToSampleApprox(pLatest, llAvail, llLength);

      // convert absolute sample number to tick
      if(m_pStrh->fccType == streamtypeVIDEO &&
         *pLatest >= m_pStrh->dwInitialFrames)
        *pLatest -= m_pStrh->dwInitialFrames;
    }


    // this has already been done for us in aviindex.cpp @ 614
    // *pLatest += GetStreamStart();

    if(m_guidFormat == TIME_FORMAT_MEDIA_TIME)
      *pLatest = ConvertInternalToRT(*pLatest);
  }
  return hr;
}

HRESULT CAviMSROutPin::RecordStartAndStop(
  LONGLONG *pCurrent, LONGLONG *pStop, REFTIME *pTime,
  const GUID *const pGuidFormat
  )
{
  if(pCurrent)
    m_llCvtImsStart = ConvertToTick(*pCurrent, pGuidFormat);

  if(pStop)
    m_llCvtImsStop = ConvertToTick(*pStop, pGuidFormat);

  if(pTime)
  {
    ASSERT(pCurrent);

    if(*pGuidFormat == TIME_FORMAT_MEDIA_TIME)
      *pTime = (double)*pCurrent / UNITS;
    else
      *pTime = ((double)ConvertFromTick(m_llCvtImsStart, &TIME_FORMAT_MEDIA_TIME)) / UNITS;
  }

  DbgLog((LOG_TRACE, 5, TEXT("CAviMSROutPin::RecordStartAndStop: %d-%d (%d ms)"),
          (long)m_llCvtImsStart,
          (long)m_llCvtImsStop,
          pTime ? (ULONG)(*pTime) : 0
          ));


  return S_OK;
}

HRESULT CAviMSROutPin::IsFormatSupported(const GUID *const pFormat)
{
  if(*pFormat == TIME_FORMAT_MEDIA_TIME)
  {
    return S_OK;
  }
  else if(*pFormat == TIME_FORMAT_SAMPLE && m_pStrh->fccType == streamtypeAUDIO &&
          ((WAVEFORMAT *)GetStrf())->wFormatTag == WAVE_FORMAT_PCM)
  {
    return S_OK;
  }
  else if(*pFormat == TIME_FORMAT_FRAME && m_pStrh->fccType != streamtypeAUDIO)
  {
    return S_OK;
  }
  else
  {
    return S_FALSE;
  }
}


// The rounding characteristics of ConvertToTick and ConvertFromTick MUST be
// complimentary.  EITHER one rounds up (away from zero) and one rounds down
// (towards zero) OR they both "round" in the traditional sense (add a half
// then truncate).  If both round up or if both round down, then we are likely
// to experiece BAD round trip integrity problems.

LONGLONG
CAviMSROutPin::ConvertToTick(
  const LONGLONG ll,
  const TimeFormat Format)
{
  LONGLONG Result = ll;  // Default value: good for Frames & Samples

  if(Format == FORMAT_TIME)
  {
    // Always round DOWN!
    Result = llMulDiv( ll, m_pStrh->dwRate, m_pStrh->dwScale * UNITS, 0 );
    const LONGLONG Max = m_pStrh->dwLength + m_pStrh->dwStart;
    if (Result > Max) Result = Max;
    if (Result < 0 ) Result = 0;
  }
  else if(Format == FORMAT_FRAME)
  {
    ASSERT(m_pStrh->fccType != streamtypeAUDIO);
    // one tick per frame
  }
  else if(Format == FORMAT_SAMPLE)
  {
    ASSERT(m_pStrh->fccType == streamtypeAUDIO ||
           m_pStrh->fccType == streamtypeMIDI);
    // one tick per sample for uncompressed audio at least
  }
  else
  {
    DbgBreak("CAviMSROutPin::ConvertToTick");
    Result = -1;
  }
  return Result;
}

LONGLONG
CAviMSROutPin::ConvertFromTick(
  const LONGLONG ll,
  const TimeFormat Format)
{
  // ASSERT( ll >= 0 );  This will fire if you've just fast forwarded or rewound!!
  // This is because we seek back to the last key-frame and send that plus the
  // frames between the key frame and the 'current' frame so that the codec can
  // build the display properly.  The key frame will have a negative relative-reference
  // time.


  // this assertion is invalid because this can be called from
  // external components.
  //
  // ASSERT( ll <= m_pStrh->dwStart + m_pStrh->dwLength );

  LONGLONG Result = ll;  // Good default for Samples & Frames
  if(Format == FORMAT_TIME)
  {
    // Round UP (to the nearest 100ns unit!).  the likelyhood is that 100ns will be
    // the finest grained unit we encounter (but possibly not for long :-(.
    Result = llMulDiv( ll, m_pStrh->dwScale * UNITS, m_pStrh->dwRate, m_pStrh->dwRate - 1 );
  }
  else if(Format == FORMAT_FRAME)
  {
    ASSERT(m_pStrh->fccType != streamtypeAUDIO);
    // one tick per frame
  }
  else if(Format == FORMAT_SAMPLE)
  {
    ASSERT(m_pStrh->fccType == streamtypeAUDIO);
    // one tick per sample, for uncompressed audio at least
  }
  else
  {
    DbgBreak("CAviMSROutPin::ConvertToTick");
    Result = -1;
  }
  return Result;
}

LONGLONG CAviMSROutPin::ConvertToTick(
  const LONGLONG ll,
  const GUID *const pFormat)
{
  return ConvertToTick(ll, CBaseMSRFilter::MapGuidToFormat(pFormat));
}

LONGLONG CAviMSROutPin::ConvertFromTick(
  const LONGLONG ll,
  const GUID *const pFormat)
{
  return ConvertFromTick(ll, CBaseMSRFilter::MapGuidToFormat(pFormat));
}


inline REFERENCE_TIME
CAviMSROutPin::ConvertInternalToRT(
  const LONGLONG llVal)
{
  return ConvertFromTick(llVal, FORMAT_TIME);
}

inline LONGLONG
CAviMSROutPin::ConvertRTToInternal(const REFERENCE_TIME rtVal)
{
  return ConvertToTick(rtVal, FORMAT_TIME);
}


// ------------------------------------------------------------------------

inline LONGLONG CAviMSROutPin::GetStreamStart()
{
  return m_pStrh->dwStart;
}

inline LONGLONG CAviMSROutPin::GetStreamLength()
{
  return m_pStrh->dwLength;
}

HRESULT CAviMSROutPin::GetMediaType(
  int iPosition,
  CMediaType *pMediaType)
{
    BOOL fRgb32 = (m_mtFirstSample.subtype == MEDIASUBTYPE_RGB32);

    if (iPosition == 0 || iPosition == 1 && fRgb32)
    {
        (*pMediaType) = m_mtFirstSample;
        if(fRgb32 && iPosition == 0) { // offer ARGB32 first
            pMediaType->subtype = MEDIASUBTYPE_ARGB32;
        }

        return S_OK;
    }

    return VFW_S_NO_MORE_ITEMS;
}

// parse 'strl' rifflist and keep track of the chunks found in
// the provided AVISTREAM structure.
//
BOOL CAviMSROutPin::ParseHeader (
  RIFFLIST * pRiffList,
  UINT      id)
{
  CAviMSRFilter *pFilter = (CAviMSRFilter *)m_pFilter;
  DbgLog((LOG_TRACE, 5,
          TEXT("CAviMSROutPin::ParseHeader(%08X,%08x,%d)"),
          this, pRiffList, id));

  RIFFCHUNK * pRiff = (RIFFCHUNK *)(pRiffList+1);
  RIFFCHUNK * pLimit = RIFFNEXT(pRiffList);

  ASSERT(m_id == id);

  m_pStrh      = NULL;
  m_pStrf      = NULL;
  m_pIndx      = NULL;

  while (pRiff < pLimit)
  {
    // sanity check.  chunks should never be smaller than the total
    // size of the list chunk
    //
    if (RIFFNEXT(pRiff) > pLimit)
      return FALSE;

    switch (pRiff->fcc)
    {
      case FCC('strh'):
        m_pStrh = (AVISTREAMHEADER *)pRiff;
        break;

      case FCC('strf'):
        m_pStrf = pRiff;
        break;

      case FCC('indx'):
        m_pIndx = (AVIMETAINDEX *)pRiff;
        break;

      case FCC('strn'):
        if(pRiff->cb > 0)
        {
          m_pStrn = (char *)pRiff + sizeof(RIFFCHUNK);

          // truncate if not null terminated
          if(m_pStrn[pRiff->cb - 1] != 0)
            m_pStrn[pRiff->cb - 1] = 0;
        }

        break;
    }

    pRiff = RIFFNEXT(pRiff);
  }

  // if we didn't find a stream header & format.  return failure.
  // (note that the INDX chunk is not required...)
  //

  if (!(m_pStrh && m_pStrf))
  {
    DbgLog((LOG_ERROR, 1, TEXT("one of strf, strh missing")));
    return FALSE;
  }

  // misc requirements to avoid division by zero
  if(m_pStrh->dwRate == 0)
  {
    DbgLog((LOG_ERROR, 1, TEXT("dwRate = 0")));
    return FALSE;
  }

  if(m_pStrh->fccType == streamtypeAUDIO &&
     ((WAVEFORMAT *)GetStrf())->nBlockAlign == 0)
  {
    DbgLog((LOG_ERROR, 1, TEXT("nBlockAlign = 0")));
    return FALSE;
  }

  // the strh chunk may only have the entries up to dwLength and not
  // have dwSuggestedBufferSize, dwQuality, dwSampleSize, rcFrame
  if(m_pStrh->cb < CB_STRH_SHORT)
    return FALSE;

  HRESULT hr = InitializeIndex();
  if(FAILED(hr))
    return FALSE;

  // dwInitialFrames computation for audio
  ULONG cbIf = 0;
  if(m_pStrh->fccType == streamtypeAUDIO)
  {
    // for audio we want to tell people how many bytes will give us
    // enough audio buffering for dwInitialFrames. This is typically
    // 750 ms.

    // Convert dwInitialFrames to time using main frame rate then to
    // to bytes using avgBytesPerSecond.

    // avoid delivering too much audio at once
    WAVEFORMAT *pwfx = (WAVEFORMAT *)GetStrf();
    m_cbMaxAudio = max(pwfx->nAvgBytesPerSec, pwfx->nBlockAlign);
    if(m_cbMaxAudio == 0)
    {
      m_cbMaxAudio = 0x3000;
    }
    else
    {
      // avoid delivering much more than a second of audio
      m_cbMaxAudio = m_cbMaxAudio + 10;

    }

    REFERENCE_TIME rtIf = pFilter->GetInitialFrames();
    if(rtIf == 0)
    {
      // file isn't 1:1 interleaved; ask for 1 second buffering. !!!
      // this seems to do worse with b.avi and mekanome.avi
      cbIf = ((WAVEFORMAT *)GetStrf())->nAvgBytesPerSec;
    }
    else
    {
      // bytes of audio ahead of video
      cbIf = (ULONG)((rtIf * ((WAVEFORMAT *)GetStrf())->nAvgBytesPerSec) /
                     UNITS);
    }

    DbgLog(( LOG_TRACE, 5, TEXT("audio offset = %dms = %d bytes"),
             (ULONG)(rtIf / (UNITS / MILLISECONDS)),
             cbIf));

    if(cbIf < 4096)
    {
      // file is probably not 1:1 interleaved
      cbIf = 4096;
    }
  }

  ALLOCATOR_PROPERTIES Request,Actual;

  // plus one so that there are more samples than samplereqs;
  // GetBuffer blocks
  ZeroMemory(&Request, sizeof(Request));

  // let the downstream filter hold on to more than buffer (even
  // though GetProperties reports 1 in this case). The worker thread
  // blocks in GetBuffer unless there is more than one CRecSample for
  // the downstream filter to hold on to. so add a few more for the
  // downstream filter to hold on to
  if(((CAviMSRFilter *)m_pFilter)->IsTightInterleaved())
  {
    Request.cBuffers = C_BUFFERS_INTERLEAVED + 3;
  }
  else
  {
    Request.cBuffers = m_pFilter->C_MAX_REQS_PER_STREAM + 10;
  }

  ULONG ulMaxSampleSize = GetMaxSampleSize();
  if( 0 == ulMaxSampleSize ) {
    return FALSE;
  }

  Request.cbBuffer = ulMaxSampleSize;
  Request.cbAlign = (LONG) 1;
  Request.cbPrefix = (LONG) 0;

  // m_pAllocator is not set, so use m_pRecAllocator
  hr = m_pRecAllocator->SetPropertiesInternal(&Request,&Actual);
  ASSERT(SUCCEEDED(hr));        // !!! really?

  if(cbIf != 0)
  {
    ULONG cbufReported = cbIf / ulMaxSampleSize;

    // capture files typically have audio after the video, so we want
    // to report as little audio as possible so that the throttling
    // code doesn't shout and so that the audio renderer doesn't
    // buffer too much data (because we have to have enough memory for
    // all the data between the audio and the video). a better thing
    // to do is to check for audio preroll in the file. !!! (a hack)
    if(pFilter->m_pAviMainHeader->dwFlags & AVIF_WASCAPTUREFILE)
      cbufReported = 1;

    cbufReported = max(cbufReported, 1);

    DbgLog(( LOG_TRACE, 5, TEXT("Avi stream %d: reporting %d buffers"),
             m_id, cbufReported ));
    hr = m_pRecAllocator->SetCBuffersReported(cbufReported);
    ASSERT(SUCCEEDED(hr));
  }
  else
  {
    // not audio. report something small in case some configures their
    // allocator with our values
    hr = m_pRecAllocator->SetCBuffersReported(1);
    ASSERT(SUCCEEDED(hr));
  }

  // ignore errors building the media type -- just means the
  // downstream filter may not be able to connect.
  BuildMT();

  if(m_pStrn)
  {
    ASSERT(m_pName);            // from pin creation
    delete[] m_pName;
    ULONG cc = lstrlenA(m_pStrn);

    // add a unique prefix so we can be persisted through FindPin and
    // QueryId in the base class
    const unsigned ccPrefix = 4;
    m_pName = new WCHAR[cc + 1 + ccPrefix];
    MultiByteToWideChar(GetACP(), 0, m_pStrn, -1, m_pName + ccPrefix, cc + 1);

    WCHAR szTmp[10];
    wsprintfW(szTmp, L"%02x", m_id);
    m_pName[0] = szTmp[0];
    m_pName[1] = szTmp[1];
    m_pName[2] = L')';
    m_pName[3] = L' ';
  }
  else if(m_pStrh->fccType == FCC('al21'))
  {
      ASSERT(lstrlenW(m_pName) >= 5); // from pin creation
      lstrcpyW(m_pName, L"~l21");
  }


  return TRUE;
}

HRESULT CAviMSROutPin::OnActive()
{
  if(!m_pWorker && m_Connected)
  {
    m_pWorker = new CAviMSRWorker(m_id, m_rpImplBuffer, m_pImplIndex);
    if(m_pWorker == 0)
      return E_OUTOFMEMORY;
  }

  return S_OK;
}

HRESULT CAviMSROutPin::Read(    /* [in] */ LPCOLESTR pszPropName,
                                /* [out][in] */ VARIANT *pVar,
                                /* [in] */ IErrorLog *pErrorLog)
{
  CheckPointer(pVar, E_POINTER);
  CheckPointer(pszPropName, E_POINTER);

  if(pVar->vt != VT_BSTR && pVar->vt != VT_EMPTY) {
      return E_FAIL;
  }

  CAutoLock l(m_pFilter);

  if(m_pStrn == 0 || lstrcmpW(pszPropName, L"name") != 0) {
      return E_INVALIDARG;
  }

  WCHAR wsz[256];
  MultiByteToWideChar(CP_ACP, 0, m_pStrn, -1, wsz, NUMELMS(wsz));

  pVar->vt = VT_BSTR;
  pVar->bstrVal = SysAllocString(wsz);

  return pVar->bstrVal ? S_OK : E_OUTOFMEMORY;
}


// helper function to return a fourcc code that contains the stream id
// of this stream combined with the supplied TwoCC code
//
// FOURCC CBaseMSROutPin::TwoCC(WORD tcc)
// {
//   FOURCC fcc = ((DWORD)tcc & 0xFF00) << 8 | ((DWORD)tcc & 0x00FF) << 24;
//   UCHAR  ch;

//   ch = m_id & 0x0F;
//   ch += (ch > 9) ? '0' : 'A' - 10;
//   fcc |= (DWORD)ch;

//   ch = (m_id & 0xF0) >> 4;
//   ch += (ch > 9) ? '0' : 'A' - 10;
//   fcc |= (DWORD)ch << 8;

//   return fcc;
// }

#ifdef DEBUG
ULONG get_last_error() { return GetLastError(); }
#endif // DEBUG

CMediaPropertyBag::CMediaPropertyBag(LPUNKNOWN pUnk) :
        CUnknown(NAME("CMediaPropertyBag"), pUnk),
        m_lstProp(NAME("CMediaPropertyBag list"), 10)
{
}

void DelPropPair(CMediaPropertyBag::PropPair *ppp)
{
    ASSERT(ppp);
    delete[] ppp->wszProp;
    EXECUTE_ASSERT(VariantClear(&ppp->var) == S_OK);
    delete ppp;
}

CMediaPropertyBag::~CMediaPropertyBag()
{
    PropPair *ppp;
    while(ppp = m_lstProp.RemoveHead(),
          ppp)
    {
        DelPropPair(ppp);
    }
}

STDMETHODIMP CMediaPropertyBag::NonDelegatingQueryInterface(
    REFIID riid, void ** ppv)
{
    HRESULT hr;

    if(riid == IID_IMediaPropertyBag)
    {
        hr = GetInterface((IMediaPropertyBag *)this, ppv);
    }
    else
    {
        hr = CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }

    return hr;
}

STDMETHODIMP CMediaPropertyBag::EnumProperty(
    ULONG iProperty, VARIANT *pvarName,
    VARIANT *pvarVal)
{
    CheckPointer(pvarName, E_POINTER);
    CheckPointer(pvarVal, E_POINTER);

    if((pvarName->vt != VT_BSTR && pvarName->vt != VT_EMPTY) ||
       (pvarVal->vt != VT_BSTR && pvarVal->vt != VT_EMPTY && pvarVal->vt != (VT_UI1 | VT_ARRAY)))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);

    POSITION pos = m_lstProp.GetHeadPosition();

    while(pos)
    {
        if(iProperty == 0)
        {
            PropPair *ppp = m_lstProp.Get(pos);
            pvarName->bstrVal = SysAllocString(ppp->wszProp);
            pvarName->vt = VT_BSTR;

            if(pvarName->bstrVal)
            {
                hr = VariantCopy(pvarVal, &ppp->var);
                if(FAILED(hr))
                {
                    SysFreeString(pvarName->bstrVal);
                    pvarName->vt = VT_EMPTY;
                    pvarName->bstrVal = 0;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            break;
        }

        iProperty--;
        pos = m_lstProp.Next(pos);
    }

    if(pos == 0)
    {
        ASSERT(hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
    }

    return hr;
}

HRESULT CMediaPropertyBag::Read(
    LPCOLESTR pszProp, LPVARIANT pvar,
    LPERRORLOG pErrorLog, POSITION *pPos
    )
{
    if(pvar && pvar->vt != VT_EMPTY && pvar->vt != VT_BSTR)
        return E_INVALIDARG;

    HRESULT hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    for(POSITION pos = m_lstProp.GetHeadPosition();
        pos;
        pos = m_lstProp.Next(pos))
    {
        PropPair *ppp = m_lstProp.Get(pos);

        if(lstrcmpW(ppp->wszProp, pszProp) == 0)
        {
            hr = S_OK;
            if(pvar)
            {
                hr = VariantCopy(pvar, &ppp->var);
            }

            if(pPos)
            {
                *pPos = pos;
            }

            break;
        }
    }

    if(pos == 0)
    {
        ASSERT(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
    }

    return hr;
}

STDMETHODIMP CMediaPropertyBag::Read(
    LPCOLESTR pszProp, LPVARIANT pvar,
    LPERRORLOG pErrorLog)
{
    CheckPointer(pszProp, E_POINTER);
    CheckPointer(pvar, E_POINTER);

    return Read(pszProp, pvar, pErrorLog, 0);
}

// write property to bag. remove property first if it exists. if
// bstrVal is null, don't write the new value in.

STDMETHODIMP CMediaPropertyBag::Write(
    LPCOLESTR pszProp, LPVARIANT pVar)
{
    CheckPointer(pszProp, E_POINTER);
    CheckPointer(pVar, E_POINTER);

    if(pVar->vt != VT_BSTR &&
       pVar->vt != (VT_UI1 | VT_ARRAY))
    {
        return E_INVALIDARG;
    }

    // remove existing entry in list with the same property name
    POSITION pos;
    HRESULT hr = S_OK;
    if(Read(pszProp, 0, 0, &pos) == S_OK)
    {
        PropPair *ppp = m_lstProp.Remove(pos);
        DelPropPair(ppp);
    }

    // non empty value to record?
    if((pVar->vt == VT_BSTR && pVar->bstrVal) ||
       (pVar->vt == (VT_UI1 | VT_ARRAY) && pVar->parray))
    {
        int cchProp = lstrlenW(pszProp) + 1;
        PropPair *ppp = new PropPair;
        WCHAR *wszProp = new OLECHAR[cchProp];
        VARIANT varVal;
        VariantInit(&varVal);

        if(ppp &&
           wszProp &&
           SUCCEEDED(VariantCopy(&varVal, pVar)) &&
           m_lstProp.AddTail(ppp))
        {
            ppp->wszProp = wszProp;
            lstrcpyW(ppp->wszProp, pszProp);
            ppp->var = varVal;

            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
            delete[] wszProp;
            EXECUTE_ASSERT(VariantClear(&varVal) == S_OK);
            delete ppp;
        }
    }

    return hr;
}

CUnknown *CMediaPropertyBag::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    CUnknown *pUnkRet = new CMediaPropertyBag(pUnk);
    return pUnkRet;
}

HRESULT CAviMSRFilter::get_Copyright(BSTR FAR* pbstrX)
{
    return GetInfoString(FCC('ICOP'), pbstrX);
}
HRESULT CAviMSRFilter::get_AuthorName(BSTR FAR* pbstrX)
{
    return GetInfoString(FCC('IART'), pbstrX);
}
HRESULT CAviMSRFilter::get_Title(BSTR FAR* pbstrX)
{
    return GetInfoString(FCC('INAM'), pbstrX);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avimsr\avimsr.h ===
#pragma warning(disable: 4097 4511 4512 4514 4705)

// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.

#ifndef _avimsr_h
#define _avimsr_h

#include "basemsr.h"
#include <aviriff.h>
#include "aviindex.h"
#include "qnetwork.h"

extern const AMOVIESETUP_FILTER sudAvimsrDll;

class CAviMSRFilter :
    public CBaseMSRFilter,
    public IAMMediaContent,
    public IPersistMediaPropertyBag
{

  DECLARE_IUNKNOWN;

public:
  // create a new instance of this class
  static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

  // want to find pins named "Stream 00" as well as usual names
  STDMETHODIMP FindPin(
    LPCWSTR Id,
    IPin ** ppPin
    );

  // helpers, accessed by pins
  HRESULT GetIdx1(AVIOLDINDEX **ppIdx1);
  HRESULT GetMoviOffset(DWORDLONG *pqw);
  REFERENCE_TIME GetInitialFrames();

  HRESULT GetCacheParams(
    StreamBufParam *rgSbp,
    ULONG *pcbRead,
    ULONG *pcBuffers,
    int *piLeadingStream);

  STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

  // IPersistMediaPropertyBag methods
  STDMETHODIMP InitNew();
  STDMETHODIMP Load(IMediaPropertyBag *pPropBag, LPERRORLOG pErrorLog);
  STDMETHODIMP Save(IMediaPropertyBag *pPropBag, BOOL fClearDirty,
                  BOOL fSaveAllProperties);
  STDMETHODIMP GetClassID(CLSID *pClsid);


private:

  friend class CAviMSROutPin;

  // constructors, etc.
  CAviMSRFilter(TCHAR *pszFilter, LPUNKNOWN pUnk, HRESULT *phr);
  ~CAviMSRFilter();

  ULONG CountConsecutiveVideoFrames();

  // pure CBaseMSRFilter overrides
  HRESULT CreateOutputPins();

  HRESULT NotifyInputDisconnected();

  // pure base override
  HRESULT CheckMediaType(const CMediaType* mtOut);

  // helpers, internal
  HRESULT Search(
    DWORDLONG *qwPosOut,
    FOURCC fccSearchKey,
    DWORDLONG qwPosStart,
    ULONG *cb);

  HRESULT CacheInfoChunk();
  HRESULT GetInfoString(DWORD dwFcc, BSTR *pbstr);

  inline bool IsTightInterleaved() { return m_fIsTightInterleaved; }

  HRESULT CreatePins();
  HRESULT ParseHeaderCreatePins();
  HRESULT LoadHeaderParseHeaderCreatePins();

  // IAMMediaContent

  STDMETHODIMP GetTypeInfoCount(THIS_ UINT FAR* pctinfo) { return E_NOTIMPL; }

  STDMETHODIMP GetTypeInfo(
    THIS_
    UINT itinfo,
    LCID lcid,
    ITypeInfo FAR* FAR* pptinfo) { return E_NOTIMPL; }

  STDMETHODIMP GetIDsOfNames(
    THIS_
    REFIID riid,
    OLECHAR FAR* FAR* rgszNames,
    UINT cNames,
    LCID lcid,
    DISPID FAR* rgdispid) { return E_NOTIMPL; }

  STDMETHODIMP Invoke(
    THIS_
    DISPID dispidMember,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS FAR* pdispparams,
    VARIANT FAR* pvarResult,
    EXCEPINFO FAR* pexcepinfo,
    UINT FAR* puArgErr) { return E_NOTIMPL; }

  STDMETHODIMP get_AuthorName(BSTR FAR* pbstrAuthorName);
  STDMETHODIMP get_Title(BSTR FAR* pbstrTitle);
  STDMETHODIMP get_Rating(BSTR FAR* pbstrRating) { return E_NOTIMPL; }
  STDMETHODIMP get_Description(BSTR FAR* pbstrDescription) { return E_NOTIMPL; }
  STDMETHODIMP get_Copyright(BSTR FAR* pbstrCopyright);
  STDMETHODIMP get_BaseURL(BSTR FAR* pbstrBaseURL) { return E_NOTIMPL; }
  STDMETHODIMP get_LogoURL(BSTR FAR* pbstrLogoURL) { return E_NOTIMPL; }
  STDMETHODIMP get_LogoIconURL(BSTR FAR* pbstrLogoIconURL) { return E_NOTIMPL; }
  STDMETHODIMP get_WatermarkURL(BSTR FAR* pbstrWatermarkURL) { return E_NOTIMPL; }
  STDMETHODIMP get_MoreInfoURL(BSTR FAR* pbstrMoreInfoURL) { return E_NOTIMPL; }
  STDMETHODIMP get_MoreInfoBannerURL(BSTR FAR* pbstrMoreInfoBannerURL) { return E_NOTIMPL; }
  STDMETHODIMP get_MoreInfoBannerImage(BSTR FAR* pbstrMoreInfoBannerImage) { return E_NOTIMPL; }
  STDMETHODIMP get_MoreInfoText(BSTR FAR* pbstrMoreInfoText) { return E_NOTIMPL; }

    

  // pointer to buffer containing all of AVI 'hdrl' chunk. (allocated)
  BYTE * m_pAviHeader;

  // size of avi header data (does not include size of riff header or
  // 'hdrl' bytes)
  UINT m_cbAviHeader;

  // pointer to main avi header within m_pAviHeader (not allocated)
  AVIMAINHEADER * m_pAviMainHeader;

  // pointer to odml list within m_pAviHeader or 0. (not allocated)
  RIFFLIST * m_pOdmlList;

  DWORDLONG m_cbMoviOffset;

  // allocated
  AVIOLDINDEX *m_pIdx1;

  bool m_fIsDV;
  bool m_fIsTightInterleaved;
  RIFFLIST *m_pInfoList;
  bool m_fNoInfoList;         // search failed; don't keep searching    
};

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

class CAviMSRWorker : public CBaseMSRWorker
{
public:
  // constructor
  CAviMSRWorker(
    UINT stream,
    IMultiStreamReader *pReader,
    IAviIndex *pImplIndex);

  // pure base overrides
  HRESULT PushLoopInit(LONGLONG *pllCurrentOut, ImsValues *pImsValues);

  HRESULT TryQueueSample(
    LONGLONG &rllCurrent,       // [in, out]
    BOOL &rfQueuedSample,       // [out]
    ImsValues *pImsValues
    );

  // build media type with palette change info
  HRESULT HandleData(IMediaSample *pSample, DWORD dwUser);

  // set new palette
  HRESULT AboutToDeliver(IMediaSample *pSample);

private:

  HRESULT QueueIndexRead(IxReadReq *pReq);
  IxReadReq m_Irr;
  enum IrrState { IRR_NONE, IRR_REQUESTED, IRR_QUEUED };
  IrrState m_IrrState;

  IAviIndex *m_pImplIndex;

  ULONG m_cbAudioChunkOffset;

  // new media type for next sample delivered
  bool m_fDeliverPaletteChange;
  bool m_fDeliverDiscontinuity; // !!! use dwflags for these flags

  // Fix MPEG audio timestamps
  bool m_fFixMPEGAudioTimeStamps;

  CMediaType m_mtNextSample;

  HRESULT HandlePaletteChange(BYTE *pb, ULONG cb);
  HRESULT HandleNewIndex(BYTE *pb, ULONG cb);

  // valid after PushLoopInit
  AVISTREAMHEADER *m_pStrh;
  WAVEFORMATEX m_wfx;

#ifdef PERF
  int m_perfidIndex;
#endif
};

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

class CAviMSROutPin :
    public CBaseMSROutPin,
    public IPropertyBag
{
public:
  CAviMSROutPin(    CBaseFilter *pOwningFilter,
                    CBaseMSRFilter *pFilter,
                    UINT iStream,
                    IMultiStreamReader *&rpImplBuffer,
                    HRESULT *phr,
                    LPCWSTR pName);

  ~CAviMSROutPin();

  DECLARE_IUNKNOWN;
  STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

  // base class overrides
  ULONG GetMaxSampleSize();
  HRESULT OnActive();

  // internal helper, called from the filter
  BOOL ParseHeader (RIFFLIST * pRiffList, UINT id);
  BYTE *GetStrf();
  AVISTREAMHEADER *GetStrh();

  // base class wants these for IMediaSelection
  HRESULT IsFormatSupported(const GUID *const pFormat);
  HRESULT GetDuration(LONGLONG *pDuration);
  HRESULT GetAvailable(LONGLONG *pEarliest, LONGLONG *pLatest);

  HRESULT RecordStartAndStop(
    LONGLONG *pCurrent,
    LONGLONG *pStop,
    REFTIME *pTime,
    const GUID *const pGuidFormat
    );

  // helpers
  LONGLONG ConvertToTick(const LONGLONG ll, const TimeFormat Format);
  LONGLONG ConvertFromTick(const LONGLONG ll, const TimeFormat Format);
  LONGLONG ConvertToTick(const LONGLONG ll, const GUID *const pFormat);
  LONGLONG ConvertFromTick(const LONGLONG ll, const GUID *const pFormat);

  REFERENCE_TIME ConvertInternalToRT(const LONGLONG llVal);
  LONGLONG ConvertRTToInternal(const REFERENCE_TIME llVal);

  // IPropertyBag
  STDMETHODIMP Read( 
    /* [in] */ LPCOLESTR pszPropName,
    /* [out][in] */ VARIANT *pVar,
    /* [in] */ IErrorLog *pErrorLog);
        
  STDMETHODIMP Write( 
    /* [in] */ LPCOLESTR pszPropName,
    /* [in] */ VARIANT *pVar) { return E_FAIL; } 

private:

  // base class overrides
  HRESULT GetMediaType(int iPosition, CMediaType* pt);
  LONGLONG GetStreamStart();
  LONGLONG GetStreamLength();

  REFERENCE_TIME GetRefTime(ULONG tick);

  // internal helpers
  HRESULT InitializeIndex();
  IAviIndex *m_pImplIndex;
  HRESULT BuildMT();

  // pointers to data allocated elsewhere. set in ParseHeader
  AVISTREAMHEADER *m_pStrh;
  RIFFCHUNK *m_pStrf;
  char *m_pStrn;
  AVIMETAINDEX *m_pIndx;

  CMediaType m_mtFirstSample;

  friend class CAviMSRWorker;
  friend class CAviMSRFilter;

  // never deliver more than this many bytes of audio. computed when
  // the file is parsed from nAvgBytesPerSecond. unset for video
  ULONG m_cbMaxAudio;
};

class CMediaPropertyBag :
    public IMediaPropertyBag,
    public CUnknown

{
    DECLARE_IUNKNOWN;

public:

    CMediaPropertyBag(LPUNKNOWN pUnk);
    ~CMediaPropertyBag();

    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);


    // IMediaPropertyBag

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    STDMETHODIMP Read(
        LPCOLESTR pszPropName, LPVARIANT pVar,
        LPERRORLOG pErrorLog);

    STDMETHODIMP Write(LPCOLESTR pszPropName, LPVARIANT pVar);

    STDMETHODIMP EnumProperty(
        ULONG iProperty, VARIANT *pvarName,
        VARIANT *pVarVal);

    struct PropPair
    {
        WCHAR *wszProp;
        VARIANT var;
    };

private:

    // same as read, but returns the internal list pointer
    HRESULT Read(
        LPCOLESTR pszPropName, LPVARIANT pVar,
        LPERRORLOG pErrorLog, POSITION *pPos);

    CGenericList<PropPair> m_lstProp;
};

// functions shared between avi parser and wav parser
HRESULT SearchList(
    IAsyncReader *pAsyncReader,
    DWORDLONG *qwPosOut, FOURCC fccSearchKey,
    DWORDLONG qwPosStart, ULONG *cb);

HRESULT SaveInfoChunk(
    RIFFLIST UNALIGNED *pRiffInfo, IPropertyBag *pbag);

HRESULT GetInfoStringHelper(RIFFLIST *pInfoList, DWORD dwFcc, BSTR *pbstr);

#endif // _avimsr_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avimsr\test\sink.h ===
//
// CTestSink
//


// test avi source

class CTestSink : public CUnknown, public CCritSec
{

public:
  CTestSink(LPUNKNOWN pUnk, HRESULT * phr, HWND hwnd);
  ~CTestSink();

  // methods called by the test app

  int TestConnect();
  int TestConnectSplitter(void);
  int TestDisconnect(void);
  int TestStop(void);
  int TestPause(void);
  int TestRun(void);
  int TestSetStart(REFTIME);
  int TestSetStop(REFTIME);
  int TestSetRate(double);
  int TestGetDuration(REFTIME *t);
  int TestSetFileName(TCHAR *sz);

  int TestGetFrameCount(LONGLONG *pc);
  int TestSetFrameSel(LONGLONG llStart, LONGLONG llEnd);
  int TestSetTimeSeeking();

  // log events via the test shell
  // iLogLevel can be TERSE or VERBOSE
  void Notify(UINT iLogLevel, LPTSTR szFormat, ...);

  LPTSTR GetSourceFileName(void);                 // returns the current name
  void SetSourceFileName(LPTSTR szSourceFile);    // sets a new name
  void SelectFile(void);                          // prompts user for a name

  // return handle of event signalled when a pin receives a block of data
  HEVENT  GetReceiveEvent(void);

  // --- nested classes ------



private:

  UINT CountPins(IBaseFilter *pFilter);
  IPin *GetInputPin(IBaseFilter *pFilter);

//   HRESULT LoadFile(LPCOLESTR szFilename);

  // window to which we notify interesting happenings
  HWND m_hwndParent;

  // task allocator
  IMalloc * m_pMalloc;

  // Name of the AVI file to use
  TCHAR m_szSourceFile[MAX_PATH];

  // event signalled whenever any of our pins receives a block of data
  HEVENT m_hReceiveEvent;

  IFilterGraph *m_pFg;
  // IBaseFilter *m_pSplitter;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avimsr\test\srctest.cpp ===
//--------------------------------------------------------------------------;
//
//  File: SrcTest.cpp
//
//  Copyright (c) 1993,1996 Microsoft Corporation.  All rights reserved
//
//  Abstract:
//
//  Contents:
//      tstGetTestInfo()
//      MenuProc()
//      InitOptionsMenu()
//      tstInit()
//      execTest()
//      tstTerminate()
//      tstAppWndProc()
//      SaveCustomProfile()
//      LoadCustomProfile()
//
//  History:
//      08/03/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//      22-Mar-95   v-mikere - added SaveCustomProfile(), LoadCustomProfile()
//
//--------------------------------------------------------------------------;

#include <streams.h>    // Streams architecture

#include <windows.h>    // Include file for windows APIs
#include <windowsx.h>   // Windows macros etc.
#include <vfw.h>        // Video for windows
#include <tstshell.h>   // Include file for the test shell's APIs
#include <testfuns.h>   // test functions
#include "sink.h"       // Test sink definition
#include "SrcTest.h"    // Various includes, constants, prototypes, globals


// Globals

HWND    ghwndTstShell;  // A handle to the main window of the test shell.
                        // It's not used here, but may be used by test apps.

HINSTANCE hinst;        // A handle to the running instance of the test
                        // shell.  It's not used here, but may be used by
                        // test apps.

HMENU   hmenuOptions;   // A handle to the options menu

CTestSink   *gpSink;    // Test sink object for all the tests


// App Name
#ifdef  _WIN32
LPTSTR          szAppName = TEXT("Quartz source filter tests - Win32");
#else
LPTSTR          szAppName = TEXT("Quartz source filter tests - Motown");
#endif

//--------------------------------------------------------------------------;
//
//  int tstGetTestInfo
//
//  Description:
//      Called by the test shell to get information about the test.  Also
//      saves a copy of the running instance of the test shell.
//
//      We also do most basic initialisation here (including instantiating
//      the test sink object) so that the custom profile handler can set
//      everything up when running automatically from a profile.
//
//  Arguments:
//      HINSTANCE hinstance: A handle to the running instance of the test
//          shell
//
//      LPSTR lpszTestName: Pointer to buffer of name for test.  Among
//          other things, it is used as a caption for the main window and
//          as the name of its class.  Always ANSI.
//
//      LPSTR lpszPathSection: Pointer to buffer of name of section in
//          win.ini in which the default input and output paths are
//          stored.  Always ANSI.
//
//      LPWORD wPlatform: The platform on which the tests are to be run,
//          which may be determined dynamically.  In order for a test to
//          be shown on the run list, it must have all the bits found in
//          wPlatform turned on.  It is enough for one bit to be turned off
//          to disqualify the test.  This also means that if this value is
//          zero, all tests will be run.  In order to make this more
//          mathematically precise, I shall give the relation which Test
//          Shell uses to decide whether a test with platform flags
//          wTestPlatform may run:  It may run if the following is TRUE:
//          ((wTestPlatform & wPlatform) == wPlatform)
//
//  Return (int):
//      The value which identifies the test list resouce (found in the
//      resource file).
//
//  History:
//      08/03/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//
//--------------------------------------------------------------------------;

int tstGetTestInfo
(
    HINSTANCE   hinstance,
    LPSTR       lpszTestName,
    LPSTR       lpszPathSection,
    LPWORD      wPlatform
)
{
    hinst = hinstance;      // Save a copy of a handle to the running instance

    CoInitialize(NULL);            // Initialise COM library
    DbgInitialise(hinst);

    // It might have been nice to have this a few lines earlier
    // - but we gotta do DbgInitialise first!
    DbgLog((LOG_TRACE, 1, TEXT("Entering tstInit")));

    // Create the test sink object

    HRESULT     hr;

    gpSink = new CTestSink(NULL, &hr, ghwndTstShell);
    ASSERT(gpSink);
    ASSERT(SUCCEEDED(hr));

    // initially it has a ref count of 0.
    gpSink->NonDelegatingAddRef();

    // test ourselves!
    ASSERT(TST_PASS == TestInterface("Sink filter", (LPUNKNOWN)gpSink));

    // Install profile handlers for custom data
    tstInstallWriteCustomInfo(SaveCustomProfile);
    tstInstallReadCustomInfo(LoadCustomProfile);

    // Pass app name to test shell
#ifdef UNICODE
    WideCharToMultiByte(CP_ACP, 0, szAppName, -1, lpszTestName, 100, NULL, NULL);
    WideCharToMultiByte(CP_ACP, 0, szAppName, -1, lpszPathSection, 100, NULL, NULL);
#else
    lstrcpy(lpszTestName, szAppName);
    lstrcpy(lpszPathSection, szAppName);
#endif

    *wPlatform = 0;         // The platform the test is running on, to be
                            // determined dynamically.
    return TEST_LIST;
} // tstGetTestInfo()



//--------------------------------------------------------------------------;
//
//  void InitOptionsMenu
//
//  Description:
//      Creates an additional app-specific menu.  Note that this
//      function is called from within tstInit as all menu installations
//      MUST be done in tstInit or else the app's behavior is undefined.
//      Also note the calls to tstInstallCustomTest which is a shell API
//      that allows custom installation of tests.  From tstshell version
//      2.0 on, it is possible to install menus the usual way and trap the
//      appropriate window messages, though the method presented here is
//      still the preferred one for Test Applications to use.
//
//      For the Quartz tests, complete menu structures and window procs
//      exist, so it is simpler to just load and append the existing menu
//      resources than to call tstInstallCustomTest once for each menu
//      option.  The window message handling is incorporated in
//      tstAppWndProc.
//
//  Arguments:
//      LRESULT (CALLBACK* MenuProc)(HWND,UINT,WPARAM,LPARAM):
//          The menu function (not used in the Quartz tests).
//
//  Return (BOOL):
//      TRUE if menu installation is successful, FALSE otherwise
//
//  History:
//      06/08/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//
//--------------------------------------------------------------------------;

BOOL InitOptionsMenu
(
    LRESULT (CALLBACK* MenuProc)(HWND, UINT, WPARAM, LPARAM)
)
{
    HMENU   hSrcTestMenu;

    if (NULL == (hSrcTestMenu = LoadMenu(hinst, TEXT("SrcTestMenu"))))
    {
        return(FALSE);
    }

    if
    (
        !AppendMenu(GetMenu(ghwndTstShell),
                    MF_POPUP,
                    (UINT) hSrcTestMenu,
                    TEXT("SrcTestMenu"))
    )
    {
        return(FALSE);
    }

    DrawMenuBar(ghwndTstShell);
    return TRUE;
}



//--------------------------------------------------------------------------;
//
//  BOOL tstInit
//
//  Description:
//      Called by the test shell to provide the test program with an
//      opportunity to do whatever initialization it needs to do before
//      user interaction is initiated.  It also provides the test program
//      with an opportunity to keep a copy of a handle to the main window,
//      if the test program needs it.  In order to use some of the more
//      advanced features of test shell, several installation must be done
//      here:
//
//      -- All menu installation must be done here by calling
//          tstInstallCustomTest (that is, all menus that the test
//          application wants to add).
//
//      -- If the test application wants to trap the window messages of
//          the main test shell window, it must install its default
//          window procedure here by calling tstInstallDefWindowProc.
//
//      -- If the test application would like to use the status bar for
//          displaying the name of the currently running test, it must
//          call tstDisplayCurrentTest here.
//
//      -- If the test application would like to change the stop key from
//          ESC to something else, it must do so here by calling
//          tstChangeStopVKey.
//
//      -- If the test application would like to add dynamic test cases
//          to the test list, it must first add their names to the
//          virtual string table using tstAddNewString (and add their
//          group's name too), and then add the actual tests using
//          tstAddTestCase.  The virtual string table is an abstraction
//          which behaves just like a string table from the outside with
//          the exception that it accepts dynamically added string.
//
//  Arguments:
//      HWND hwndMain: A handle to the main window
//
//  Return (BOOL):
//      TRUE if initialization went well, FALSE otherwise which will abort
//      execution.
//
//  History:
//      06/08/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//
//--------------------------------------------------------------------------;

BOOL tstInit
(
    HWND    hwndMain
)
{
   // Keep a copy of a handle to the main window
    ghwndTstShell = hwndMain;

    // Installs a default windows procedure which may handle messages
    // directed to Test Shell's main window.  It is vital to note that
    // this window function is substituted for DefWindowProc and not in
    // addition to it, and therefore DefWindowProc MUST be called from
    // within it in the default case (look at tstAppWndProc for an example).
    tstInstallDefWindowProc (tstAppWndProc);

    // Install the custom menus.  Look at InitOptionsMenu for more details.
    if (InitOptionsMenu(NULL)==FALSE)
        return FALSE;  // If menu installation failed, abort execution

    // This is a shell API which tells Test Shell to display the name of
    // the currenly executing API in its status bar.  It is a really nice
    // feature for test applications which do not use the toolbar for any
    // other purpose, as it comfortably notifies the user of the progress
    // of the tests.
    tstDisplayCurrentTest();

    // Change the stop key from ESC to SPACE
    tstChangeStopVKey (VSTOPKEY);

    // Add the names of the dynamic tests and dynamic groups to the
    // virtual string table.  Before the tests are added, it is important
    // to add their names, as the name ID is required by tstAddTestCase.
//    tstAddNewString (ID_TESTLAST + 1, (LPSTR) "The first test added dynamically");
//    tstAddNewString (GRP_LAST + 1, (LPSTR) "A dynamically added group");
//    tstAddNewString (ID_TESTLAST + 2, (LPSTR) "The first test in a dynamically added group");

    // Add test cases dynamically.  Note that these test cases will execute
    // on any platform, since they are added dynamically.  Real test
    // applications probably want to check the run environment and then
    // add dynamic test cases selectively.
//    tstAddTestCase (ID_TESTLAST + 1, TST_AUTOMATIC, FX_TEST1, GRP_ONE);
//    tstAddTestCase (ID_TESTLAST + 2, TST_AUTOMATIC, FX_TEST1, GRP_LAST + 1);

    DbgLog((LOG_TRACE,1, TEXT("Exiting tstInit")));
    return(TRUE);
} // tstInit()




//--------------------------------------------------------------------------;
//
//  int execTest
//
//  Description:
//      This is the actual test function which is called from within the
//      test shell.  It is passed various information about the test case
//      it is asked to run, and branches off to the appropriate test
//      function.  Note that it needs not switch on nFxID, but may also
//      use iCase or wID.
//
//  Arguments:
//      int nFxID: The test case identifier, also found in the third column
//          in the third column of the test list in the resource file
//
//      int iCase: The test case's number, which expresses the ordering
//          used by the test shell.
//
//      UINT wID: The test case's string ID, which identifies the string
//          containing the description of the test case.  Note that it is
//          also a good candidate for use in the switch statement, as it
//          is unique to each test case.
//
//      UINT wGroupID: The test case's group's string ID, which identifies
//          the string containing the description of the test case's group.
//
//  Return (int): Indicates the result of the test by using TST_FAIL,
//          TST_PASS, TST_OTHER, TST_ABORT, TST_TNYI, TST_TRAN, or TST_TERR
//
//  History:
//      06/08/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//
//--------------------------------------------------------------------------;

int execTest
(
    int     nFxID,
    int     iCase,
    UINT    wID,
    UINT    wGroupID
)
{
    int ret = TST_OTHER;

    tstBeginSection(" ");

    switch(nFxID)
    {
        //
        //  The test cases
        //

        case FX_TEST1:
            ret = execTest1();
            break;

        case FX_TEST2:
            ret = execTest2();
            break;

        case FX_TEST3:
            ret = execTest3();
            break;

        case FX_TEST4:
            ret = execTest4();
            break;

        case FX_TEST5:
            ret = execTest5();
            break;

        case FX_TEST6:
            ret = execTest6();
            break;

        case FX_TEST7:
            ret = execTest7();
            break;

        case FX_TEST8:
            ret = execTest8();
            break;

        case FX_TEST9:
            ret = execTest9();
            break;

        case FX_TEST10:
            ret = execTest10();
            break;

        default:
            break;
    }

    tstEndSection();

    return(ret);

//Abort:
    return(TST_ABORT);
} // execTest()




//--------------------------------------------------------------------------;
//
//  void tstTerminate
//
//  Description:
//      This function is called when the test series is finished to free
//      structures and do whatever cleanup work it needs to do.  If it
//      needs not do anything, it may just return.
//
//  Arguments:
//      None.
//
//  Return (void):
//
//  History:
//      06/08/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//
//--------------------------------------------------------------------------;

void tstTerminate
(
    void
)
{
    DbgLog((LOG_TRACE, 1, TEXT("Entering tstTerminate")));

    gpSink->NonDelegatingRelease();

    DbgTerminate();
    CoUninitialize();

    DbgLog((LOG_TRACE, 1, TEXT("Exiting tstTerminate")));
    return;
} // tstTerminate()




//--------------------------------------------------------------------------;
//
//  LRESULT tstAppWndProc
//
//  Description:
//      This shows how a test application can trap the window messages
//      received by the main Test Shell window.  It is installed in
//      in tstInit by calling tstInstallDefWindowProc, and receives
//      all window messages since.  This allows the test application to
//      be notified of certain event via a window without creating its
//      own hidden window or waiting in a tight PeekMessage() loop.  Note
//      that it is extremely important to call DefWindowProcA in the default
//      case as that is NOT done in tstshell's main window procedure if
//      tstInstallDefWindowProc is used.  DefWindowProcA has to be used as the
//      test shell main window is an ANSI window.
//
//  Arguments:
//      HWND hWnd: A handle to the window
//
//      UINT msg: The message to be processed
//
//      WPARAM wParam: The first parameters, meaning depends on msg
//
//      LPARAM lParam: The second parameter, meaning depends on msg
//
//  Return (LRESULT):
//
//  History:
//      08/03/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//
//--------------------------------------------------------------------------;

LRESULT FAR PASCAL tstAppWndProc
(
    HWND    hWnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    switch (msg)
    {
        case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {

            case IDM_DISCONNECT:
                gpSink->TestDisconnect();
                return 0;

            case IDM_CONNECT:
                gpSink->TestConnect();
                return 0;

            case IDM_SPLITTER:
                gpSink->TestConnectSplitter();
                return 0;

            case IDM_STOP:
                gpSink->TestStop();
                return 0;

            case IDM_PAUSE:
                gpSink->TestPause();
                return 0;

            case IDM_RUN:
                gpSink->TestRun();
                return 0;

            case IDM_SELECTFILE:
                gpSink->SelectFile();
                return 0;
        }
        break;
    }
    return DefWindowProcA (hWnd, msg, wParam, lParam);
}




/***************************************************************************\
*                                                                           *
*   void SaveCustomProfile                                                  *
*                                                                           *
*   Description:                                                            *
*       This function saves custom environment info into a profile.  It is  *
*       installed by calling tstInstallWriteCustomInfo from tstInit, and is *
*       called during normal profile handling in SaveProfile.               *
*                                                                           *
*       Assumes the profile file was created from scratch by the calling    *
*       function.                                                           *
*                                                                           *
*       Custom data for this app:                                           *
*           [test data]      - section for info relating to test data       *
*               SourceFile   - name of AVI file read by source filter       *
*                                                                           *
*   Arguments:                                                              *
*           LPCSTR szProfileName: name of profile file                      *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       16-Mar-95    v-mikere                                               *
*                                                                           *
\***************************************************************************/


VOID CALLBACK SaveCustomProfile
(
    LPCSTR pszProfileName
)
{
    HANDLE      hProfile;
    TCHAR       szLine[128];
    CHAR        szBuf[128];
    DWORD       dwNumberOfBytesWritten;
    LPCTSTR     tszProfileName;

#ifdef UNICODE
    WCHAR   wszProfileName[128];

    if (!MultiByteToWideChar(CP_ACP, 0, pszProfileName, -1,
                                                        wszProfileName, 128))
    {
        MessageBox(ghwndTstShell,
                   TEXT("Could not convert profile name to ANSI"),
                   szAppName,
                   MB_ICONEXCLAMATION | MB_OK);
        return;
    }

    tszProfileName = wszProfileName;
#else
    tszProfileName = pszProfileName;
#endif

    if (0 == lstrlen(gpSink->GetSourceFileName()))
    {
        return;     // No custom data to store
    }

    hProfile = CreateFile(tszProfileName,
                          GENERIC_WRITE,
                          0,
                          NULL,
                          OPEN_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL);

    if (INVALID_HANDLE_VALUE == hProfile)
    {
        wsprintf(szLine, TEXT("Cannot open %s for writing"), tszProfileName);
        MessageBox(ghwndTstShell, szLine, szAppName,
                                                MB_ICONEXCLAMATION | MB_OK);
        return;
    }

    if (0xFFFFFFFF == SetFilePointer(hProfile, 0, NULL, FILE_END))
    {
        wsprintf(szLine, TEXT("Could not seek to end of %s"), tszProfileName);
        MessageBox(ghwndTstShell, szLine, szAppName,
                                                MB_ICONEXCLAMATION | MB_OK);
        return;
    }

    wsprintfA(szBuf, "[test data]\r\n");
    WriteFile(hProfile, szBuf, lstrlenA(szBuf), &dwNumberOfBytesWritten, NULL);

#ifdef UNICODE
    wsprintfA(szBuf, "SourceFile=%ls\r\n", gpSink->GetSourceFileName());
#else
    wsprintfA(szBuf, "SourceFile=%hs\r\n", gpSink->GetSourceFileName());
#endif
    WriteFile(hProfile, szBuf, lstrlenA(szBuf), &dwNumberOfBytesWritten, NULL);

    CloseHandle(hProfile);

} /* end of SaveCustomProfile */




/***************************************************************************\
*                                                                           *
*   BOOL LoadCustomProfile                                                  *
*                                                                           *
*   Description:                                                            *
*       This function loads custom environment info from a profile.  It is  *
*       installed by calling tstInstallReadCustomInfo from tstInit, and is  *
*       called during normal profile handling in LoadProfile.               *
*                                                                           *
*       Custom data for this app:                                           *
*           [test data]      - section for info relating to test data       *
*               SourceFile   - name of AVI file read by source filter       *
*                                                                           *
*   Arguments:                                                              *
*           LPCSTR szProfileName: name of profile file                      *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       16-Mar-95    v-mikere                                               *
*                                                                           *
\***************************************************************************/

VOID CALLBACK LoadCustomProfile
(
    LPCSTR pszProfileName
)
{
    TCHAR       szBuf[128];
    HANDLE      hProfile;
    LPCTSTR     tszProfileName;


#ifdef UNICODE
    WCHAR   wszProfileName[128];

    if (!MultiByteToWideChar(CP_ACP, 0, pszProfileName, -1,
                                                        wszProfileName, 128))
    {
        MessageBox(ghwndTstShell,
                   TEXT("Could not convert profile name to ANSI"),
                   szAppName,
                   MB_ICONEXCLAMATION | MB_OK);
        return;
    }

    tszProfileName = wszProfileName;
#else
    tszProfileName = pszProfileName;
#endif

    hProfile = CreateFile(tszProfileName,
                          GENERIC_READ,
                          0,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL);

    if (INVALID_HANDLE_VALUE == hProfile)
    {
        wsprintf(szBuf, TEXT("Cannot open profile %hs"), pszProfileName);
        MessageBox(ghwndTstShell, szBuf, szAppName,
                                                MB_ICONEXCLAMATION | MB_OK);
        return;
    }

    CloseHandle(hProfile);


    if
    (
        GetPrivateProfileString(TEXT("test data"),
                                TEXT("SourceFile"),
                                gpSink->GetSourceFileName(),
                                szBuf,
                                sizeof(szBuf),
                                tszProfileName)
    )
    {
        gpSink->SetSourceFileName(szBuf);
    }
} /* end of LoadCustomProfile */



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avimux\alloc.cpp ===
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)

#include <streams.h>
#include "alloc.h"

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
//
// Implements CSfxAllocator
//

CSfxAllocator::CSfxAllocator(
  TCHAR *pName,
  LPUNKNOWN pUnk,
  HRESULT *phr) :
    CMemAllocator(pName, pUnk, phr),
    m_cbSuffix(0)
{
}

HRESULT
CSfxAllocator::SetPropertiesAndSuffix(
  ALLOCATOR_PROPERTIES *pRequest,
  ULONG cbSuffixReq,
  ALLOCATOR_PROPERTIES *pActual)
{
  HRESULT hr = CMemAllocator::SetProperties(
    pRequest, pActual);
  if(FAILED(hr))
    return hr;

  m_cbSuffix = cbSuffixReq;
  return S_OK;
}

STDMETHODIMP
CSfxAllocator::SetProperties(
    ALLOCATOR_PROPERTIES* pRequest,
    ALLOCATOR_PROPERTIES* pActual)
{
    CheckPointer(pRequest, E_POINTER);
    ALLOCATOR_PROPERTIES apreq_copy = *pRequest;
    apreq_copy.cbAlign = max(apreq_copy.cbAlign, m_lAlignment);
    apreq_copy.cbPrefix = max(apreq_copy.cbPrefix, m_lPrefix);
    return CMemAllocator::SetProperties(&apreq_copy, pActual);
}



// ------------------------------------------------------------------------
// allocate the memory, this code copied from CMemAllocator and
// changed for the suffix

HRESULT
CSfxAllocator::Alloc(void)
{

  CAutoLock lck(this);

  /* Check he has called SetProperties */
  HRESULT hr = CBaseAllocator::Alloc();
  if (FAILED(hr)) {
    return hr;
  }

  /* If the requirements haven't changed then don't reallocate */
  if (hr == S_FALSE) {
    ASSERT(m_pBuffer);
    return NOERROR;
  }
  ASSERT(hr == S_OK); // we use this fact in the loop below

  /* Free the old resources */
  if (m_pBuffer) {
    ReallyFree();
  }

  // this allocator's responsibility to make sure the end of the
  // suffix is aligned.
  ULONG cbSuffixAdjust = 0;
  if(m_cbSuffix != 0)
  {
    cbSuffixAdjust += max((ULONG)m_lAlignment, m_cbSuffix);
  }

  // note we don't handle suffixes larger than alignment (except 1)
  ASSERT(cbSuffixAdjust >= m_cbSuffix);

  /* Create the contiguous memory block for the samples
     making sure it's properly aligned (64K should be enough!)
     */
  ASSERT(m_lAlignment != 0 &&
         (m_lSize + m_lPrefix) % m_lAlignment == 0);

  ASSERT((m_lSize + m_lPrefix + cbSuffixAdjust) % m_lAlignment == 0);

  m_pBuffer = (PBYTE)VirtualAlloc(
    NULL,
    m_lCount * (m_lSize + m_lPrefix + cbSuffixAdjust),
    MEM_COMMIT,
    PAGE_READWRITE);

  if (m_pBuffer == NULL) {
    return E_OUTOFMEMORY;
  }

  LPBYTE pNext = m_pBuffer;
  CMediaSample *pSample;

  ASSERT(m_lAllocated == 0);

  // Create the new samples - we have allocated m_lSize bytes for each sample
  // plus m_lPrefix bytes per sample as a prefix. We set the pointer to
  // the memory after the prefix - so that GetPointer() will return a pointer
  // to m_lSize bytes.
  for (; m_lAllocated < m_lCount;
       m_lAllocated++, pNext += (m_lSize + m_lPrefix + cbSuffixAdjust))
  {
    pSample = new CMediaSample(
      NAME("Default memory media sample"),
      this,
      &hr,
      pNext + m_lPrefix,      // GetPointer() value
      m_lSize + cbSuffixAdjust - m_cbSuffix); // size less prefix and suffix

    ASSERT(SUCCEEDED(hr));
    if (pSample == NULL) {
      return E_OUTOFMEMORY;
    }

    // This CANNOT fail
    m_lFree.Add(pSample);
  }

  m_bChanged = FALSE;
  return NOERROR;
}

//
// Destructor frees our memory resources

CSfxAllocator::~CSfxAllocator()
{
}

CSampSample::CSampSample(
  TCHAR *pName,
  CBaseAllocator *pAllocator,
  HRESULT *phr) :
    CMediaSample(pName, pAllocator, phr),
    m_pSample(0)
{
}

HRESULT CSampSample::SetSample(
  IMediaSample *pSample,
  BYTE *pb,
  ULONG cb)
{
  ASSERT(m_pSample == 0);

  m_pSample = pSample;
  pSample->AddRef();

  HRESULT hr = SetPointer(pb, cb);
  ASSERT(hr == S_OK);

  return S_OK;
}

STDMETHODIMP_(ULONG) CSampSample::Release()
{
  IMediaSample *pSample = m_pSample;
  ULONG c = CMediaSample::Release();
  if(c == 0 && pSample != 0)
  {
    pSample->Release();
    // cannot zero m_pSample because CMediaSample::NonDelegatingRelease
    // might have deleted this
  }

  return c;
}

CSampAllocator::CSampAllocator(
  TCHAR *pName,
  LPUNKNOWN pUnk,
  HRESULT *phr) :
    CBaseAllocator(pName, pUnk, phr)
{
}

CSampAllocator::~CSampAllocator()
{
  Decommit();
  ReallyFree();
}

HRESULT CSampAllocator::Alloc()
{
  HRESULT hr = S_OK;
  if(m_lCount <= 0)
    return VFW_E_SIZENOTSET;

  for(int i = 0; i < m_lCount; i++, m_lAllocated++)
  {
    CSampSample *pSample = new CSampSample(
      NAME("samp sample"),
      this,
      &hr);
    if(pSample == 0)
      return E_OUTOFMEMORY;
    if(hr != S_OK)
      return hr;
    m_lFree.Add(pSample);
  }

  return S_OK;
}

void CSampAllocator::ReallyFree()
{
  ASSERT(m_lAllocated == m_lFree.GetCount());
  CSampSample *pSample;
  for (;;) {
    pSample = (CSampSample *)(m_lFree.RemoveHead());
    if (pSample != NULL) {
      delete pSample;
    } else {
      break;
    }
  }
  m_lAllocated = 0;
}

void CSampAllocator::Free()
{

}

STDMETHODIMP
CSampAllocator::SetProperties(
  ALLOCATOR_PROPERTIES* pRequest,
  ALLOCATOR_PROPERTIES* pActual)
{
  ZeroMemory(pActual, sizeof(ALLOCATOR_PROPERTIES));

  /* Can't do this if already committed, there is an argument that says we
     should not reject the SetProperties call if there are buffers still
     active. However this is called by the source filter, which is the same
     person who is holding the samples. Therefore it is not unreasonable
     for them to free all their samples before changing the requirements */

  if (m_bCommitted) {
    return VFW_E_ALREADY_COMMITTED;
  }

  /* Must be no outstanding buffers */

  if (m_lAllocated != m_lFree.GetCount()) {
    return VFW_E_BUFFERS_OUTSTANDING;
  }

  /* There isn't any real need to check the parameters as they
     will just be rejected when the user finally calls Commit */

  pActual->cbBuffer = m_lSize = pRequest->cbBuffer;
  pActual->cBuffers = m_lCount = pRequest->cBuffers;
  pActual->cbAlign = m_lAlignment = pRequest->cbAlign;
  pActual->cbPrefix = m_lPrefix = pRequest->cbPrefix;

  m_bChanged = TRUE;
  return NOERROR;
}

STDMETHODIMP CSampAllocator::GetBuffer(
  CSampSample **ppBuffer,
  REFERENCE_TIME * pStartTime,
  REFERENCE_TIME * pEndTime,
  DWORD dwFlags)
{
  IMediaSample *pSample;
  HRESULT hr = CBaseAllocator::GetBuffer(&pSample, pStartTime, pEndTime, dwFlags);
  *ppBuffer = (CSampSample *)pSample;
  if(SUCCEEDED(hr))
  {
    (*ppBuffer)->m_pSample = 0;
  }
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avimsr\test\sink.cpp ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved


//
// source filter test class
//

#include <streams.h>

// define the GUIDs for streams and my CLSID in this file
#include <initguid.h>
#include <wxdebug.h>

#include "sink.h"
#include <TstsHell.h>
#include <commdlg.h>    // Common dialog definitions
#include <testfuns.h>

#define EXAS(x) EXECUTE_ASSERT(SUCCEEDED(x))


// --- CTestSink methods --------------

CTestSink::CTestSink(LPUNKNOWN pUnk, HRESULT * phr, HWND hwnd)
    : CUnknown(NAME("Test sink"), pUnk)
{
  m_hwndParent = hwnd;
  m_pFg = 0;

  // need this for notify
  HRESULT hr = CoGetMalloc(MEMCTX_TASK, &m_pMalloc);
  if (FAILED(hr)) {
    *phr = hr;
    return;
  }
  ASSERT(m_pMalloc);

  // clear the file name
  lstrcpy(m_szSourceFile, TEXT("//pigeon/avi/ducky.avi"));

  m_hReceiveEvent = (HEVENT) CreateEvent(NULL, FALSE, FALSE, NULL);
  ASSERT(m_hReceiveEvent);

  // EXAS(CoCreateInstance(CLSID_AviSplitter, 0, CLSCTX_INPROC, IID_IBaseFilter, (void **)&m_pSplitter));
  // EXAS(CoCreateInstance(CLSID_FilterGraph, 0, CLSCTX_INPROC, IID_IFilterGraph, (void **)&m_pFg));
  // EXAS(m_pFg->AddFilter(m_pSplitter, L"avi splitter"));
}

CTestSink::~CTestSink()
{
  // delete all our pins and release the filter
  TestDisconnect();

  if (m_pMalloc) {
    m_pMalloc->Release();
  }

  if(m_pFg)
    m_pFg->Release();
  //   m_pSplitter->Release();
}


int
CTestSink::TestConnect()
{
  HRESULT hr;

  if(m_pFg)
    return TST_PASS;

  // disconnect anything still connected
  int tstResult = TestDisconnect();
  if (tstResult != TST_PASS) {
    return tstResult;
  }
  ASSERT(m_pFg == 0);
  EXAS(CoCreateInstance(CLSID_FilterGraph, 0, CLSCTX_INPROC, IID_IFilterGraph, (void **)&m_pFg));

  // create source filter and connect things
//   if(CountPins(m_pSplitter) != 1)
//   {
//     tstLog(TERSE, "disconnected splitter has output pins");
//     return TST_FAIL;
//   }

  if(lstrcmp(m_szSourceFile, TEXT("")) == 0)
    SelectFile();

  IGraphBuilder *pGb;
  EXAS(m_pFg->QueryInterface(IID_IGraphBuilder, (void **)&pGb));

#ifdef UNICODE
  hr = pGb->RenderFile(m_szSourceFile, 0);
#else
  OLECHAR wszSourceFile[MAX_PATH];
  MultiByteToWideChar(CP_ACP, 0, m_szSourceFile, -1, wszSourceFile, MAX_PATH);
  hr = pGb->RenderFile(wszSourceFile, 0);
#endif

  pGb->Release();
  if(FAILED(hr))
    return TST_FAIL;

//   if(CountPins(m_pSplitter) < 2)
//   {
//     tstLog(TERSE, "splitter has too few pins");
//     return TST_FAIL;
//   }

  return TST_PASS;
}

// count the first 20 pins
UINT CTestSink::CountPins(IBaseFilter *pFilter)
{
  IEnumPins *pEnum;
  ULONG cPins = 0;
  const UINT C_MAX_PINS = 20;
  IPin *rgpPin[C_MAX_PINS];
  ZeroMemory(rgpPin, sizeof(rgpPin));

  EXAS(pFilter->EnumPins(&pEnum));
  EXAS(pEnum->Reset());
  EXAS(pEnum->Next(C_MAX_PINS, rgpPin, &cPins));
  ASSERT(cPins < C_MAX_PINS);   // don't handle more

  for(UINT iPin = 0; iPin < cPins; iPin++)
    rgpPin[iPin]->Release();
  pEnum->Release();

  return cPins;
}

IPin *CTestSink::GetInputPin(IBaseFilter *pFilter)
{
  IEnumPins *pEnum;
  ULONG cPins = 0;
  const UINT C_MAX_PINS = 20;
  IPin *rgpPin[C_MAX_PINS];
  ZeroMemory(rgpPin, sizeof(rgpPin));

  EXAS(pFilter->EnumPins(&pEnum));
  EXAS(pEnum->Reset());
  EXAS(pEnum->Next(C_MAX_PINS, rgpPin, &cPins));
  ASSERT(cPins < C_MAX_PINS);   // don't handle more

  IPin *pInPin = 0;
  PIN_DIRECTION pindir;
  for(UINT iPin = 0; iPin < cPins; iPin++)
  {

    EXAS(rgpPin[iPin]->QueryDirection(&pindir));
    if(pindir == PINDIR_INPUT && pInPin == 0)
      pInPin = rgpPin[iPin];    // keep addref
    else
      rgpPin[iPin]->Release();
  }
  pEnum->Release();

  return pInPin;
}

int
CTestSink::TestDisconnect(void)
{
  TestStop();

//   // disconnect splitter's input pin
//   IPin *pPinIn, *pPinOut;

//   pPinIn = GetInputPin(m_pSplitter);
//   if(SUCCEEDED(pPinIn->ConnectedTo(&pPinOut)))
//   {
//     EXAS(m_pFg->Disconnect(pPinOut));

//     PIN_INFO pi;
//     EXAS(pPinOut->QueryPinInfo(&pi));
//     pPinOut->Release();
//     EXAS(m_pFg->RemoveFilter(pi.pFilter));
//   NOTE: if this code ever gets re-enabled then pi.pFilter will need
//         to be released - IF it exists
//     EXAS(m_pFg->Disconnect(pPinIn));
//   }
//   // pPinIn->Release(); !!!

//   Notify(VERBOSE, TEXT("Disconnected"));
//   if(CountPins(m_pSplitter) == 1)
//     return TST_PASS;
//   else
//     return TST_FAIL;

  if(m_pFg)
    m_pFg->Release();
  m_pFg = 0;
  return TST_PASS;
}

int
CTestSink::TestStop(void)
{
  if(m_pFg == 0)
    return TST_PASS;

  IMediaControl *pMc;
  EXAS(m_pFg->QueryInterface(IID_IMediaControl, (void **)&pMc));
  HRESULT hr = pMc->Stop();
  pMc->Release();

  return SUCCEEDED(hr) ? TST_PASS : TST_FAIL;
}

int CTestSink::TestSetFileName(TCHAR *sz)
{
  if(TestDisconnect() != TST_PASS)
    return TST_FAIL;
  lstrcpy(m_szSourceFile, sz);
  return TST_PASS;
}

int CTestSink::TestGetFrameCount(LONGLONG *pc)
{
  if(!m_pFg)
    if(TestConnect() != TST_PASS)
      return TST_FAIL;

  IMediaSeeking *pMs;
  EXAS(m_pFg->QueryInterface(IID_IMediaSeeking, (void **)&pMs));
  EXAS(pMs->SetTimeFormat(&TIME_FORMAT_FRAME));
  EXAS(pMs->GetDuration(pc));
  pMs->Release();
  return TST_PASS;
}

int CTestSink::TestSetFrameSel(LONGLONG llStart, LONGLONG llEnd)
{
  if(!m_pFg)
    if(TestConnect() != TST_PASS)
      return TST_FAIL;

  IMediaSeeking *pMs;
  EXAS(m_pFg->QueryInterface(IID_IMediaSeeking, (void **)&pMs));
  EXAS(pMs->SetTimeFormat(&TIME_FORMAT_FRAME));
  EXAS(pMs->SetPositions(&llStart, AM_SEEKING_AbsolutePositioning, &llEnd, AM_SEEKING_AbsolutePositioning));
  pMs->Release();
  return TST_PASS;
}

int CTestSink::TestSetTimeSeeking()
{
  if(!m_pFg)
    if(TestConnect() != TST_PASS)
      return TST_FAIL;

  IMediaSeeking *pMs;
  EXAS(m_pFg->QueryInterface(IID_IMediaSeeking, (void **)&pMs));
  EXAS(pMs->SetTimeFormat(&TIME_FORMAT_MEDIA_TIME));
  pMs->Release();
  return TST_PASS;
}

int
CTestSink::TestPause(void)
{
  if(!m_pFg)
    if(TestConnect() != TST_PASS)
      return TST_FAIL;
  IMediaControl *pMc;
  EXAS(m_pFg->QueryInterface(IID_IMediaControl, (void **)&pMc));
  HRESULT hr = pMc->Pause();

  OAFilterState fs;
  if(SUCCEEDED(hr))
    hr = pMc->GetState(INFINITE, &fs);

  pMc->Release();
  if(FAILED(hr) || hr == VFW_S_STATE_INTERMEDIATE)
    return TST_FAIL;
  if(fs != State_Paused)
    return TST_FAIL;

  return SUCCEEDED(hr) ? TST_PASS : TST_FAIL;
}

int
CTestSink::TestRun(void)
{
  if(!m_pFg)
    if(TestConnect() != TST_PASS)
      return TST_FAIL;

  IMediaControl *pMc;
  EXAS(m_pFg->QueryInterface(IID_IMediaControl, (void **)&pMc));
  IMediaEvent *pMe;
  EXAS(m_pFg->QueryInterface(IID_IMediaEvent, (void **)&pMe));
  HRESULT hr = pMc->Run();
  if(FAILED(hr))
  {
    pMe->Release();
    pMc->Release();
    return TST_FAIL;
  }

  long Ec;
  hr = pMe->WaitForCompletion(15 * 1000, &Ec);

  pMe->Release();
  pMc->Release();

  if(FAILED(hr) || Ec != EC_COMPLETE)
    return TST_FAIL;
  else
    return TST_PASS;
}

int
CTestSink::TestConnectSplitter(void)
{
  // disconnect anything still connected
  TestDisconnect();

  return TST_PASS;
}

//
//  Seek methods
//
int
CTestSink::TestSetStart(REFTIME t)
{
  if(!m_pFg)
    if(TestConnect() != TST_PASS)
      return TST_FAIL;

  IMediaPosition *pMp;
  EXAS(m_pFg->QueryInterface(IID_IMediaPosition, (void **)&pMp));
  EXAS(pMp->put_CurrentPosition(t));
  pMp->Release();

  return TST_PASS;
}

int
CTestSink::TestSetStop(REFTIME t)
{
  if(!m_pFg)
    if(TestConnect() != TST_PASS)
      return TST_FAIL;

  IMediaPosition *pMp;
  EXAS(m_pFg->QueryInterface(IID_IMediaPosition, (void **)&pMp));
  EXAS(pMp->put_StopTime(t));
  pMp->Release();

  return TST_PASS;
}

int
CTestSink::TestSetRate(double r)
{
  if(!m_pFg)
    if(TestConnect() != TST_PASS)
      return TST_FAIL;

  IMediaPosition *pMp;
  EXAS(m_pFg->QueryInterface(IID_IMediaPosition, (void **)&pMp));
  EXAS(pMp->put_Rate(r));
  pMp->Release();

  return TST_PASS;
}

int
CTestSink::TestGetDuration(REFTIME *t)
{
  if(!m_pFg)
    if(TestConnect() != TST_PASS)
      return TST_FAIL;

  IMediaPosition *pMp;
  EXAS(m_pFg->QueryInterface(IID_IMediaPosition, (void **)&pMp));
  EXAS(pMp->get_Duration(t));
  pMp->Release();

  return TST_PASS;
}

// log events to the test shell window, using tstLog
// N.B. tstLog accepts only ANSI strings
void
CTestSink::Notify(UINT iLogLevel, LPTSTR szFormat, ...)
{
    CHAR ach[256];
    va_list va;

    va_start(va, szFormat);

#ifdef UNICODE
    WCHAR awch[128];

    wvsprintf(awch, szFormat, va);
    WideCharToMultiByte(CP_ACP, 0, awch, -1, ach, 128, NULL, NULL);	
#else
    wvsprintf(ach, szFormat, va);
#endif

    tstLog(iLogLevel, ach);
    va_end(va);
}


// Return the current source file name

LPTSTR
CTestSink::GetSourceFileName(void)
{
    return m_szSourceFile;
}


// Set the current source file name

void
CTestSink::SetSourceFileName(LPTSTR pszSourceFile)
{
    lstrcpy(m_szSourceFile, pszSourceFile);
}


// Prompt user for name of the source filter's file

void
CTestSink::SelectFile(void)
{
  OPENFILENAME    ofn;

  // Initialise the data fields

  ZeroMemory (&ofn, sizeof ofn);
  m_szSourceFile[0] = 0;

  ofn.lStructSize = sizeof(OPENFILENAME);
  ofn.hwndOwner = m_hwndParent;
  ofn.lpstrFilter = TEXT("AVI Files\0*.avi\0\0");
  ofn.nFilterIndex = 1;
  ofn.lpstrFile = m_szSourceFile;
  ofn.nMaxFile = MAX_PATH;
  ofn.lpstrTitle = TEXT("Select avi file");
  ofn.Flags = OFN_FILEMUSTEXIST;

  // Get the user's selection

  if (!GetOpenFileName(&ofn))
  {
    ASSERT(0 == CommDlgExtendedError());
  }
}


// Return the handle of the receive event

HEVENT
CTestSink::GetReceiveEvent(void)
{
    return m_hReceiveEvent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avimux\alloc.h ===
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)


#ifndef _allocator_h
#define _allocator_h

//
// The suffix allocator implementation. this one gives us a suffix and
// a prefix on each buffer for AVI Riff chunks and junk chunks. The
// suffix is not reported in GetSize() on the sample.
//
class CSfxAllocator :
  public CMemAllocator
{
public:

  CSfxAllocator(
    TCHAR *,
    LPUNKNOWN,
    HRESULT *
    );
  
  ~CSfxAllocator();

  // internal method for the avi mux to record some values. fails if
  // it can't give the requested suffix.
  STDMETHODIMP SetPropertiesAndSuffix(
    ALLOCATOR_PROPERTIES *pRequest,
    ULONG cbSuffixReq,
    ALLOCATOR_PROPERTIES *pActual
    );

  // overridden not to reset certain values (alignment, prefix)
  STDMETHODIMP SetProperties(
    ALLOCATOR_PROPERTIES* pRequest,
    ALLOCATOR_PROPERTIES* pActual);
    

private:

  // overriden to allocate space for the suffix
  HRESULT Alloc(void);

  ULONG m_cbSuffix;
};

//
// another allocator implementaion which takes an IMediaSample and
// wraps it into a CSampSample. samples have their own sample times
// and media times.
//

class CSampSample : public CMediaSample
{
  friend class CSampAllocator;
  IMediaSample *m_pSample;

public:
  HRESULT SetSample(IMediaSample *pSample, BYTE *pb, ULONG cb);

  CSampSample(
    TCHAR *pName,
    CBaseAllocator *pAllocator,
    HRESULT *phr);

  STDMETHODIMP_(ULONG) Release();

};

class CSampAllocator : public CBaseAllocator
{
public:
  CSampAllocator(TCHAR *, LPUNKNOWN, HRESULT *);
  ~CSampAllocator();

  void Free(void);
  void ReallyFree(void);
  HRESULT Alloc(void);

  STDMETHODIMP SetProperties(
    ALLOCATOR_PROPERTIES* pRequest,
    ALLOCATOR_PROPERTIES* pActual);

  STDMETHODIMP GetBuffer(
    CSampSample **ppBuffer,
    REFERENCE_TIME * pStartTime,
    REFERENCE_TIME * pEndTime,
    DWORD dwFlags);
};


#endif // _allocator_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avimsr\test\tests.cpp ===
//--------------------------------------------------------------------------;
//
//  File: Tests.cpp
//
//  Copyright (c) 1993,1995 Microsoft Corporation.  All rights reserved
//
//  Abstract:
//      The test functions for the Quartz source filter test application
//
//  Contents:
//      YieldAndSleep()
//      YieldWithTimeout()
//      execTest1()
//      execTest2()
//      execTest3()
//      execTest4()
//      execTest5()
//      execTest6()
//      expect()
//
//  History:
//      08/03/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//      22-Mar-95   v-mikere - user selection of AVI file
//
//--------------------------------------------------------------------------;

#include <streams.h>    // Streams architecture

#include <windows.h>    // Include file for windows APIs
#include <windowsx.h>   // Windows macros etc.
#include <vfw.h>        // Video for windows
#include <tstshell.h>   // Include file for the test shell's APIs
#include "sink.h"       // Test sink definition
#include "SrcTest.h"    // Various includes, constants, prototypes, globals
#include <stdio.h>
#include <time.h>

#define DO_TEST(_x_) if (TST_PASS == result) { _x_; }

int giCurrentFile;

static TCHAR *grgszFileName[] =
{
  TEXT("//PIGEON/AVI/100_I4.AVI"), 
  TEXT("//PIGEON/AVI/157X119.AVI"), 
  TEXT("//PIGEON/AVI/1MOREMIN.AVI"), 
  TEXT("//PIGEON/AVI/BILL_CD.AVI"), 
  TEXT("//PIGEON/AVI/BOHEMIAN.AVI"), 
  TEXT("//PIGEON/AVI/BUGS.AVI"), 
  TEXT("//PIGEON/AVI/BUS.AVI"), 
  TEXT("//PIGEON/AVI/CANTOPEN.AVI"), 
  TEXT("//PIGEON/AVI/CBT.AVI"),
  TEXT("//PIGEON/AVI/CHERRYTK.AVI"),
  TEXT("//PIGEON/AVI/CLOCK.AVI"),
  TEXT("//PIGEON/AVI/CLOCKTXT.AVI"), 
  TEXT("//PIGEON/AVI/CONTRO16.AVI"), 
  TEXT("//PIGEON/AVI/CVID.AVI"), 
  TEXT("//PIGEON/AVI/DAFFY.AVI"), 
  TEXT("//PIGEON/AVI/DEF2.AVI"), 
  TEXT("//PIGEON/AVI/DEFINDEO.AVI"), 
  TEXT("//PIGEON/AVI/DITHER.AVI"), 
  TEXT("//PIGEON/AVI/DITHER2.AVI"), 
  TEXT("//PIGEON/AVI/DUCKY.AVI"), 
  TEXT("//PIGEON/AVI/EDEN.AVI"), 
  TEXT("//PIGEON/AVI/EFCTMNU.AVI"), 
  TEXT("//PIGEON/AVI/ESTRANGE.AVI"), 
  TEXT("//PIGEON/AVI/FULLFR.AVI"), 
  TEXT("//PIGEON/AVI/GOLF4.AVI"), 
  TEXT("//PIGEON/AVI/GROUCH.AVI"), 
  TEXT("//PIGEON/AVI/IV32.AVI"), 
  TEXT("//PIGEON/AVI/JAPAN8.AVI"), 
  TEXT("//PIGEON/AVI/JERKY.AVI"), 
  TEXT("//PIGEON/AVI/JERKY2.AVI"), 
  TEXT("//PIGEON/AVI/JULIA.AVI"), 
  TEXT("//PIGEON/AVI/KILL.AVI"), 
  TEXT("//PIGEON/AVI/MIDIHANG.AVI"), 
  TEXT("//PIGEON/AVI/MORPH.AVI"), 
  TEXT("//PIGEON/AVI/NED.AVI"), 
  TEXT("//PIGEON/AVI/NIRVANA.AVI"), 
  TEXT("//PIGEON/AVI/NOKEYS.AVI"), 
  TEXT("//PIGEON/AVI/NOVEMBER.AVI"), 
  TEXT("//PIGEON/AVI/NOVIDEO.AVI"), 
  TEXT("//PIGEON/AVI/OLDMAC.AVI"), 
  TEXT("//PIGEON/AVI/OLIVIER.AVI"), 
  TEXT("//PIGEON/AVI/OUCH.AVI"), 
  TEXT("//PIGEON/AVI/RAVEN.AVI"), 
  TEXT("//PIGEON/AVI/REM_I4.AVI"), 

  TEXT("//PIGEON/AVI/REMLYR.AVI"), 
  TEXT("//PIGEON/AVI/RGB.AVI"), 
  TEXT("//PIGEON/AVI/RHOODM.AVI"), 
  TEXT("//PIGEON/AVI/ROBMC.AVI"), 
  TEXT("//PIGEON/AVI/ROBOT.AVI"), 
  TEXT("//PIGEON/AVI/ROCKET.AVI"), 
  TEXT("//PIGEON/AVI/SAMPLE.AVI"), 
  TEXT("//PIGEON/AVI/SARAH.AVI"), 
  TEXT("//PIGEON/AVI/SESAME.AVI"), 
  TEXT("//PIGEON/AVI/SHATNER.AVI"), 
  TEXT("//PIGEON/AVI/SILENT.AVI"), 
  TEXT("//PIGEON/AVI/SKIJM16.AVI"), 
  TEXT("//PIGEON/AVI/SMALL.AVI"), 
  TEXT("//PIGEON/AVI/START2.AVI"), 
  TEXT("//PIGEON/AVI/STARTME.AVI"), 
  TEXT("//PIGEON/AVI/STEAM.AVI"), 
  TEXT("//PIGEON/AVI/STEAM1.AVI"), 
  TEXT("//PIGEON/AVI/STEAM2.AVI"), 
  TEXT("//PIGEON/AVI/STUDS.AVI"), 
  TEXT("//PIGEON/AVI/SYNCTSTM.AVI"), 
  TEXT("//PIGEON/AVI/SYNCTSTS.AVI"), 
  TEXT("//PIGEON/AVI/TESTC.AVI"), 
  TEXT("//PIGEON/AVI/THX3D.AVI"), 
  TEXT("//PIGEON/AVI/THXC.AVI"), 
  TEXT("//PIGEON/AVI/TORI.AVI"), 
  TEXT("//PIGEON/AVI/WHALE.AVI"), 
  TEXT("//PIGEON/AVI/WNDSURF1.AVI"), 
  TEXT("//PIGEON/AVI/WOMANINC.AVI"),

  TEXT("//DEEPSTR9/PUBLIC/MMSMOKE/CLOCKTXT.AVI"),
  TEXT("//DEEPSTR9/PUBLIC/MMSMOKE/CPAK1.AVI"),
  TEXT("//DEEPSTR9/PUBLIC/MMSMOKE/INDEO31.AVI"),
  TEXT("//DEEPSTR9/PUBLIC/MMSMOKE/INDEO32.AVI"),
  TEXT("//DEEPSTR9/PUBLIC/MMSMOKE/MSVC1.AVI"),
  TEXT("//DEEPSTR9/PUBLIC/MMSMOKE/RLE1.AVI"),
  TEXT("//DEEPSTR9/PUBLIC/MMSMOKE/SHIMY.AVI"),
  TEXT("//DEEPSTR9/PUBLIC/MMSMOKE/CVIDH30.AVI"),
  TEXT("//DEEPSTR9/PUBLIC/MMSMOKE/INDEO4.AVI"),

  TEXT("//BLUES/PUBLIC/OLANH/AVI/BD5.AVI"),
  TEXT("//BLUES/PUBLIC/OLANH/AVI/BLUANGEL.AVI"),
  TEXT("//BLUES/PUBLIC/OLANH/AVI/CVIDQ30Q.AVI"),
  TEXT("//BLUES/PUBLIC/OLANH/AVI/DUALIR32.AVI"),
  TEXT("//BLUES/PUBLIC/OLANH/AVI/HOOK640.AVI"),
  TEXT("//BLUES/PUBLIC/OLANH/AVI/IMOTO.AVI"),
  TEXT("//BLUES/PUBLIC/OLANH/AVI/PALETTE.AVI"),
  TEXT("//BLUES/PUBLIC/OLANH/AVI/T100061A.AVI"),
  TEXT("//BLUES/PUBLIC/OLANH/AVI/T109452A.AVI"),
  TEXT("//BLUES/PUBLIC/OLANH/AVI/CINE525A.AVI"),
  TEXT("//BLUES/PUBLIC/OLANH/AVI/CINE668A.AVI"),
  TEXT("//BLUES/PUBLIC/OLANH/AVI/INDEO7TV.AVI"),
  TEXT("//BLUES/PUBLIC/OLANH/AVI/INDEO8TV.AVI"),
  TEXT("//BLUES/PUBLIC/OLANH/AVI/MSV8.AVI"),
  TEXT("//BLUES/PUBLIC/OLANH/AVI/MSV8_2.AVI"),
  TEXT("//BLUES/PUBLIC/OLANH/AVI/RLE.AVI"),
  TEXT("//BLUES/PUBLIC/OLANH/AVI/RLE2.AVI"),

  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./NO_SOUND/NABPRES.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./NO_SOUND/NABDOWN.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/ASAHI.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/BILLARD.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/BUBLFACE.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/CHICKEN.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/COCOON.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/HUGGIES.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/INVASION.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/JESTRY.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/JOEBASK1.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/JOEBASK2.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/MENBIRDS1.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/LIBRARY.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/MANWBALL.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/JOEBASK3.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/MENBIRDS2.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/MICECONF.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/MICEHIST.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/MICETOUR.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/PENGUINS.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/PSYGNOS.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/ROBOTS.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/SOCRHORS.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/SOCCER.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/SILVRBAL.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/SPINS.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/WATRWOMN.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./IR32/WHALE.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/BAD/TAXEL1.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/BAD/MTI20.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/SIGCOMP.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/SIGALIEN.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/SIGMAKE.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/SIGWIDE.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/006.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/ANATOMY.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/BOYTOYS.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/BONDGRLS.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/DATE.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/HARRY.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/DESTROY.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/HOTGIRLS.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/THEDEAD.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/NIX.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/SEETHNGS.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/SEXY007.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/STUNTS.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/THEBEST.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/MALLRATS.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/UHOH.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/ULTIMATE.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/MTI08.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/MTI04.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/MTI05.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/MTI02.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/MTI13.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/MTI21.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./MS-CRAM/MTI24.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./CINEPAK/AEROSMTH.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./CINEPAK/2SHY.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./CINEPAK/CORPH.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./CINEPAK/ED604250.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./CINEPAK/NISEI.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./CINEPAK/OUBLIETTE.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./CINEPAK/SH604100.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./CINEPAK/THELIST.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./CINEPAK/TOYSTORY.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./CINEPAK/VASE.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./CINEPAK/XPR-595.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./CINEPAK/DEMO01.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./CINEPAK/KENOBI.AVI"),
  TEXT("//ACTIVEMOVIE/SAMPLES/INTERNET/AVI/./ROADRUN.AVI")  
};

//--------------------------------------------------------------------------;
//
//  void YieldAndSleep
//
//  Description:
//      Sleep using tstWinYield to allow other threads to log messages
//      in the main window.
//
//  Arguments:
//      DWORD  cMilliseconds:   sleep time in milliseconds
//
//  Return:
//      None.
//
//  History:
//      9-Mar-95    v-mikere
//
//--------------------------------------------------------------------------;

void FAR PASCAL YieldAndSleep
(
    DWORD  cMilliseconds                // sleep time in milliseconds
)
{
    DWORD   dwEndTime = GetTickCount() + cMilliseconds;
    DWORD   dwCurrentTime = GetTickCount();

    while
    (
        WAIT_TIMEOUT != MsgWaitForMultipleObjects(0,
                                                  NULL,
                                                  FALSE,
                                                  dwEndTime - dwCurrentTime,
                                                  QS_ALLINPUT)
    )
    {
        tstWinYield();
        if ((dwCurrentTime = GetTickCount()) >= dwEndTime)
        {
            return;
        }
    }
}



//--------------------------------------------------------------------------;
//
//  void YieldWithTimeout
//
//  Description:
//      Sleep using tstWinYield to allow other threads to log messages
//      in the main window.  Terminate if a specified event is not signalled
//      within a timeout period.
//
//      The purpose is to allow tests which play through a video of unknown
//      length.  The test can terminate after a selectable period of
//      inactivity (usually following the end of the video).
//
//  Arguments:
//      HEVENT  hEvent:          event to wait for
//      DWORD   cMilliseconds:   sleep time in milliseconds
//
//  Return:
//      None.
//
//  History:
//      22-Mar-95   v-mikere
//
//--------------------------------------------------------------------------;

void FAR PASCAL YieldWithTimeout
(
    HEVENT  hEvent,                 // event to wait for
    DWORD   cMilliseconds           // timeout period in milliseconds
)
{
    DWORD   dwEndTime = GetTickCount() + cMilliseconds;
    DWORD   dwCurrentTime = GetTickCount();
    DWORD   dwEventID;

    while
    (
        WAIT_TIMEOUT !=
           (dwEventID = MsgWaitForMultipleObjects(1,
                                                  (LPHANDLE) &hEvent,
                                                  FALSE,
                                                  dwEndTime - dwCurrentTime,
                                                  QS_ALLINPUT))
    )
    {
        // reset timeout if hEvent was signalled
        if (WAIT_OBJECT_0 == dwEventID)
        {
            dwEndTime = GetTickCount() + cMilliseconds;
        }
        else
        {
            tstWinYield();        // check the message queue
        }

        // check if we have now timed out
        if ((dwCurrentTime = GetTickCount()) >= dwEndTime)
        {
            return;
        }
    }
}



//--------------------------------------------------------------------------;
//
//  int execTest1
//
//  Description:
//      Test 1, connect and disconnect source
//
//  Arguments:
//      None.
//
//  Return (int): TST_PASS indicating success
//
//--------------------------------------------------------------------------;

int FAR PASCAL execTest1
(
    void
)
{
    int         result;                     // The result of the test

    tstLog (TERSE, "Entering connect/disconnect test");
    tstLogFlush();

    result = gpSink->TestConnect();
    if (result != TST_PASS)  {
        return result;
    }
    result = gpSink->TestDisconnect();
    if (result != TST_PASS)  {
        return result;
    }
    result = gpSink->TestConnect();
    if (result != TST_PASS)  {
        return result;
    }
    result = gpSink->TestDisconnect();
    if (result != TST_PASS)  {
        return result;
    }

    result = TST_PASS;  //!!!! how to know if this test is successful?
    tstLog (TERSE, "Exiting connect/disconnect test");
    tstLogFlush();
    return result;
} // execTest1()



//--------------------------------------------------------------------------;
//
//  int execTest2
//
//  Description:
//      Test 2, connect source, pause file and disconnect
//
//  Arguments:
//      None.
//
//  Return (int): TST_FAIL indicating failure
//
//--------------------------------------------------------------------------;

int FAR PASCAL execTest2
(
    void
)
{
    int         result;                     // The result of the test

    tstLog (TERSE, "Entering pause/stop test");
    tstLogFlush();

    if(gpSink->TestConnect() != TST_PASS)
      return TST_FAIL;

    for(int i = 0; i < 2; i++)
    {
      tstBeginSection("Pause");
      if(gpSink->TestPause() != TST_PASS) // waits
        return TST_FAIL;

      // Wait for the video clip to finish
      // YieldWithTimeout(gpSink->GetReceiveEvent(), 2000);

      tstEndSection();

      if(gpSink->TestStop() != TST_PASS)
        return TST_FAIL;
    }

    
    gpSink->TestDisconnect();

    result = TST_PASS;  //!!!! how to know if this test is successful?
    tstLog (TERSE, "Exiting pause test");
    tstLogFlush();
    return result;
} // execTest2()


//--------------------------------------------------------------------------;
//
//  int execTest3
//
//  Description:
//      Test 3, connect source, play file and disconnect
//
//  Arguments:
//      None.
//
//  Return (int): TST_PASS indicating success
//
//  History:
//      06/08/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//
//--------------------------------------------------------------------------;

int FAR PASCAL execTest3
(
    void
)
{
    int         result;                     // The result of the test

    tstLog (TERSE, "Entering play test");
    tstLogFlush();

    gpSink->TestConnect();

    for(UINT ii = 0; ii < 10; ii++)
    {
      tstLog(TERSE, "run");
      gpSink->TestRun();
      Sleep(100);
      tstLog(TERSE, "pause");
      gpSink->TestPause();
      Sleep(200);
      tstLog(TERSE, "run");
      gpSink->TestRun();
      Sleep(1000);
      tstLog(TERSE, "run");
      gpSink->TestRun();
      tstLog(TERSE, "pause");
      gpSink->TestPause();
      Sleep(50);
      tstLog(TERSE, "run");
      gpSink->TestRun();
      Sleep(30);
      tstLog(TERSE, "pause");
      gpSink->TestPause();
      tstLog(TERSE, "run");
      gpSink->TestRun();
      tstLog(TERSE, "pause");
      gpSink->TestPause();
      tstLog(TERSE, "pause");
      gpSink->TestPause();
    }
    
//     // Wait for the video clip to finish
//     YieldWithTimeout(gpSink->GetReceiveEvent(), 2000);

    gpSink->TestDisconnect();

    result = TST_PASS;  //!!!! how to know if this test is successful?
    tstLog (TERSE, "Exiting play test");
    tstLogFlush();
    return result;
} // execTest3()


//--------------------------------------------------------------------------;
//
//  int execTest4
//
//  Description:
//      Test 4, switch to random file
//
//  Arguments:
//      None.
//
//  Return (int): TST_PASS indicating success
//
//  History:
//      06/08/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//      22-Mar-95   v-mikere - user selection of AVI file
//
//--------------------------------------------------------------------------;

int FAR PASCAL execTest4
(
    void
)
{
    int         result;                     // The result of the test

    srand( (unsigned)time( NULL ) );

    giCurrentFile = rand() % (sizeof(grgszFileName) / sizeof(grgszFileName[1]));
    char sz[1024];
    sprintf(sz, "random switch to %s", grgszFileName[giCurrentFile]);

    tstLog (TERSE, sz);
    tstLogFlush();

    result = gpSink->TestSetFileName(grgszFileName[giCurrentFile]);
    return result;
} // execTest4()

//--------------------------------------------------------------------------;
//
//  int execTest5
//
//  Description:
//      Test 4, switch to next file
//
//  Arguments:
//      None.
//
//  Return (int): TST_PASS indicating success
//
//  History:
//      06/08/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//      22-Mar-95   v-mikere - user selection of AVI file
//
//--------------------------------------------------------------------------;

int FAR PASCAL execTest5
(
    void
)
{
    int         result;                     // The result of the test

    if(++giCurrentFile >= (sizeof(grgszFileName) / sizeof(grgszFileName[1])))
      giCurrentFile = 0;
    
    char sz[1024];
    sprintf(sz, "switch switch to %s", grgszFileName[giCurrentFile]);

    tstLog (TERSE, sz);
    tstLogFlush();

    result = gpSink->TestSetFileName(grgszFileName[giCurrentFile]);
    return result;
} // execTest4()

//--------------------------------------------------------------------------;
//
//  int execTest6
//
//  Description:
//      Test 6, paused seeks
//
//  Arguments:
//      None.
//
//  Return (int):
//
//  History:
//      06/08/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//      22-Mar-95   v-mikere - user selection of AVI file
//
//--------------------------------------------------------------------------;

int FAR PASCAL execTest6
(
    void
)
{
    int         result = TST_PASS; // The result of the test

    tstLog (TERSE, "Entering paused seeks test");
    tstLogFlush();

    REFTIME t;
    if(gpSink->TestGetDuration(&t) != TST_PASS)
      return TST_FAIL;

    if(gpSink->TestSetStart(0) != TST_PASS)
      return TST_FAIL;
    if(gpSink->TestSetStop(0) != TST_PASS)
      return TST_FAIL;
    if(gpSink->TestPause() != TST_PASS)
      return TST_FAIL;
    
    tstLog (TERSE, "seek middle");
    if(gpSink->TestStop() != TST_PASS)
      return TST_FAIL;
    if(gpSink->TestSetStart(t / 2) != TST_PASS)
      return TST_FAIL;
    if(gpSink->TestSetStop(t / 2) != TST_PASS)
      return TST_FAIL;
    if(gpSink->TestPause() != TST_PASS)
      return TST_FAIL;

    if(t > 1)
    {
      tstLog (TERSE, "seek end - 1");
      if(gpSink->TestStop() != TST_PASS)
        return TST_FAIL;
      if(gpSink->TestSetStart(t - 1) != TST_PASS)
        return TST_FAIL;
      if(gpSink->TestSetStop(t - 1) != TST_PASS)
        return TST_FAIL;
      if(gpSink->TestPause() != TST_PASS)
        return TST_FAIL;
    }

    tstLog (TERSE, "seek beginning");
    if(gpSink->TestStop() != TST_PASS)
      return TST_FAIL;
    if(gpSink->TestSetStart(0) != TST_PASS)
      return TST_FAIL;
    if(gpSink->TestSetStop(0) != TST_PASS)
      return TST_FAIL;
    if(gpSink->TestPause() != TST_PASS)
      return TST_FAIL;

    tstLog (TERSE, "seek end");
    if(gpSink->TestStop() != TST_PASS)
      return TST_FAIL;
    if(gpSink->TestSetStart(t) != TST_PASS)
      return TST_FAIL;
    if(gpSink->TestSetStop(t) != TST_PASS)
      return TST_FAIL;
    if(gpSink->TestPause() != TST_PASS)
      return TST_FAIL;

    if(gpSink->TestStop() != TST_PASS)
      return TST_FAIL;

    tstLog (TERSE, "Exiting paused seeks test");
    tstLogFlush();
    return result;
} // execTest6()

//--------------------------------------------------------------------------;
//
//  int execTest7
//
//  Description:
//      Test 7, connect source and Splitter, play subsets of file and disconnect
//
//  Arguments:
//      None.
//
//  Return (int):
//
//  History:
//
//--------------------------------------------------------------------------;

int FAR PASCAL execTest7
(

)
{
    int         result = TST_PASS; // The result of the test

    tstLog (TERSE, "Entering play subsets test");
    tstLogFlush();

    REFTIME t;
    if(gpSink->TestGetDuration(&t) != TST_PASS)
      return TST_FAIL;

    tstLog (TERSE, "play 0.1 - 0.5");

    if(gpSink->TestSetStart(0.1) != TST_PASS)
      return TST_FAIL;
    if(gpSink->TestSetStop(0.5) != TST_PASS)
      return TST_FAIL;
    if(gpSink->TestRun() != TST_PASS)
      return TST_FAIL;

    if(gpSink->TestStop() != TST_PASS)
      return TST_FAIL;

    if(t >= 0.5)
    {
      tstLog (TERSE, "play end - 0.5  -e nd");

      if(gpSink->TestSetStart(t - 0.5) != TST_PASS)
        return TST_FAIL;
      if(gpSink->TestSetStop(t) != TST_PASS)
        return TST_FAIL;
      if(gpSink->TestRun() != TST_PASS)
        return TST_FAIL;

      if(gpSink->TestStop() != TST_PASS)
        return TST_FAIL;
    }

    tstLog (TERSE, "play 0 - .1");

    if(gpSink->TestSetStart(0) != TST_PASS)
      return TST_FAIL;
    if(gpSink->TestSetStop(.1) != TST_PASS)
      return TST_FAIL;
    if(gpSink->TestRun() != TST_PASS)
      return TST_FAIL;

    if(gpSink->TestStop() != TST_PASS)
      return TST_FAIL;

    tstLog (TERSE, "end - end + 1");

    if(gpSink->TestSetStart(t) != TST_PASS)
      return TST_FAIL;
    if(gpSink->TestSetStop(t + 1) != TST_PASS)
      return TST_FAIL;
    if(gpSink->TestRun() != TST_PASS)
      return TST_FAIL;

    if(gpSink->TestStop() != TST_PASS)
      return TST_FAIL;

    tstLog (TERSE, "end + 1 - end + 1.1");

    if(gpSink->TestSetStart(t + 1) != TST_PASS)
      return TST_FAIL;
    if(gpSink->TestSetStop(t + 1.1) != TST_PASS)
      return TST_FAIL;
    if(gpSink->TestRun() != TST_PASS)
      return TST_FAIL;

    if(gpSink->TestStop() != TST_PASS)
      return TST_FAIL;

    tstLog (TERSE, "Exiting play subsets test");
    tstLogFlush();
    return result;
} // execTest7()

//--------------------------------------------------------------------------;
//
//  int execTest8
//
//  Description:
//      Test 8, connect source, play subsets of file and disconnect
//              (same as 7 but for source only)
//
//  Arguments:
//      None.
//
//  Return (int):
//
//  History:
//
//--------------------------------------------------------------------------;

int FAR PASCAL execTest8
(
    void
)
{
  int         result = TST_PASS; // The result of the test

  tstLog (TERSE, "Entering rates test");
  tstLogFlush();

  REFTIME t;
  if(gpSink->TestGetDuration(&t) != TST_PASS)
    return TST_FAIL;

  tstLog (TERSE, "play rate = 2");

  if(gpSink->TestSetStart(0) != TST_PASS)
    return TST_FAIL;
  if(gpSink->TestSetStop(3.5) != TST_PASS)
    return TST_FAIL;
  if(gpSink->TestSetRate(2.0) != TST_PASS)
    return TST_FAIL;
  if(gpSink->TestRun() != TST_PASS)
    return TST_FAIL;

  if(gpSink->TestStop() != TST_PASS)
    return TST_FAIL;

  tstLog (TERSE, "rate = 0.5");

  if(gpSink->TestSetStart(0) != TST_PASS)
    return TST_FAIL;
  if(gpSink->TestSetStop(0.5) != TST_PASS)
    return TST_FAIL;
  if(gpSink->TestSetRate(0.5) != TST_PASS)
    return TST_FAIL;
  if(gpSink->TestRun() != TST_PASS)
    return TST_FAIL;

  if(gpSink->TestStop() != TST_PASS)
    return TST_FAIL;

  if(gpSink->TestSetRate(1.0) != TST_PASS)
    return TST_FAIL;
  
  tstLog (TERSE, "Exiting rates test");
  tstLogFlush();
  return result;
} // execTest8()


//--------------------------------------------------------------------------;
//
//  int execTest9
//
//  Description:
//      Test 9, connect source, play file and disconnect using sync i/o
//
//  Arguments:
//      None.
//
//  Return (int): TST_PASS indicating success
//
//  History:
//      06/08/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//
//--------------------------------------------------------------------------;

int FAR PASCAL execTest9
(
    void
)
{
    int         result;                     // The result of the test

    tstLog (TERSE, "Entering frame-seeking test");
    tstLogFlush();

    if(gpSink->TestConnect() != TST_PASS)
      return TST_FAIL;

    LONGLONG cFrames;
    if(gpSink->TestGetFrameCount(&cFrames) != TST_PASS)
      return TST_FAIL;

    if(gpSink->TestSetFrameSel(0, 0) != TST_PASS)
      return TST_FAIL;
    if(gpSink->TestPause() != TST_PASS)
      return TST_FAIL;

    if(gpSink->TestStop() != TST_PASS)
      return TST_FAIL;

    if(gpSink->TestSetFrameSel(30, 60) != TST_PASS)
      return TST_FAIL;
    if(gpSink->TestPause() != TST_PASS)
      return TST_FAIL;
    if(gpSink->TestRun() != TST_PASS)
      return TST_FAIL;

    if(gpSink->TestStop() != TST_PASS)
      return TST_FAIL;

    result = TST_PASS;  //!!!! how to know if this test is successful?
    tstLog (TERSE, "Exiting frame-seeking test");
    tstLogFlush();
    return result;
} // execTest3()


//--------------------------------------------------------------------------;
//
//  int execTest10
//
//  Description:
//      Test 10, connect source, play subsets of file and disconnect
//              (same as 7 but for source only, using sync i/o)
//
//  Arguments:
//      None.
//
//  Return (int):
//
//  History:
//
//--------------------------------------------------------------------------;
int FAR PASCAL execTest10
(
    void
)
{
    int         result;                     // The result of the test

    tstLog (TERSE, "Entering corrupt file test");
    tstLogFlush();

    char szCorrupt[] = "c:/temp/corrupt.avi";

    if(GetFileAttributes(szCorrupt) == 0xFFFFFFFF)
    {
      tstLog(TERSE, "copying file.");
      if(!CopyFile(gpSink->GetSourceFileName(), szCorrupt, FALSE))
      {
        tstLog(TERSE, "copy failed.");
        return TST_FAIL;
      }
    }
    if(gpSink->TestSetFileName(grgszFileName[giCurrentFile]) != TST_PASS)
    {
      tstLog(TERSE, "TestSetFileName failed");
      return TST_FAIL;
    }

    for(;;)
    {
      result = gpSink->TestConnect();
      if (result != TST_PASS)  {
        tstLog(TERSE, "connect failed");
        return TST_PASS;
      }
      result = gpSink->TestDisconnect();
      if (result != TST_PASS)  {
        tstLog(TERSE, "disconnect failed");
        return result;
      }

      HANDLE hFile = CreateFile(
        szCorrupt,
        GENERIC_READ | GENERIC_WRITE,
        0,                      // dwShareMode
        0,                      // lpSecurityAttributes
        OPEN_EXISTING,
        0,                      // dwFlags,
        0);                     // hTemplateFile
      if(hFile == INVALID_HANDLE_VALUE)
      {
        tstLog(TERSE, "open failed");
        return TST_FAIL;
      }
      ULONG cbFile = GetFileSize(hFile, 0);
      if(cbFile == 0xFFFFFFFF)
      {
        tstLog(TERSE, "GetFileSize failed");
        CloseHandle(hFile);
        return TST_FAIL;
      }

      ULONG iOffset = rand() % cbFile;
      if(SetFilePointer(hFile, iOffset, 0, FILE_BEGIN) == 0xFFFFFFFF)
      {
        tstLog(TERSE, "SetFilePointer failed");
        CloseHandle(hFile);
        return TST_FAIL;
      }

      BYTE b;
      DWORD dwcbRead;
      if(!ReadFile(hFile, &b, 1, &dwcbRead, 0) || dwcbRead != 1)
      {
        tstLog(TERSE, "ReadFile failed");
        CloseHandle(hFile);
        return TST_FAIL;
      }

      UINT bit = 1 << (rand() % 8);
      char sz[1024];
      sprintf(sz, "flipping byte %d, bit %d", iOffset, bit);
      tstLog(TERSE, sz);

      b ^= bit;
      if(SetFilePointer(hFile, iOffset, 0, FILE_BEGIN) == 0xFFFFFFFF)
      {
        tstLog(TERSE, "SetFilePointer failed");
        CloseHandle(hFile);
        return TST_FAIL;
      }
      if(!WriteFile(hFile, &b, 1, &dwcbRead, 0) || dwcbRead != 1)
      {
        tstLog(TERSE, "WriteFile failed");
        CloseHandle(hFile);
        return TST_FAIL;
      }

      CloseHandle(hFile);
    }


    tstLog (TERSE, "Exiting corrupt file test");
    tstLogFlush();
    return TST_PASS;
} // execTest8()


//--------------------------------------------------------------------------;
//
//  int expect
//
//  Description:
//      Compares the expected result to the actual result.  Note that this
//      function is not at all necessary; rather, it is a convenient
//      method of saving typing time and standardizing output.  As an input,
//      you give it an expected value and an actual value, which are
//      unsigned integers in our example.  It compares them and returns
//      TST_PASS indicating that the test was passed if they are equal, and
//      TST_FAIL indicating that the test was failed if they are not equal.
//      Note that the two inputs need not be integers.  In fact, if you get
//      strings back, you can modify the function to use lstrcmp to compare
//      them, for example.  This function is NOT to be copied to a test
//      application.  Rather, it should serve as a model of construction to
//      similar functions better suited for the specific application in hand
//
//  Arguments:
//      UINT uExpected: The expected value
//
//      UINT uActual: The actual value
//
//      LPSTR CaseDesc: A description of the test case
//
//  Return (int): TST_PASS if the expected value is the same as the actual
//      value and TST_FAIL otherwise
//                                                                          *   History:
//      06/08/93    T-OriG (based on code by Fwong)
//
//--------------------------------------------------------------------------;

int expect
(
    UINT    uExpected,
    UINT    uActual,
    LPSTR   CaseDesc
)
{
    if(uExpected == uActual)
    {
        tstLog(TERSE, "PASS : %s",CaseDesc);
        return(TST_PASS);
    }
    else
    {
        tstLog(TERSE,"FAIL : %s",CaseDesc);
        return(TST_FAIL);
    }
} // Expect()


// check that an intermediate result was as expected - report failure only
// success only reported if verbose selected.
CheckLong(LONG lExpect, LONG lActual, LPSTR lpszCase)
{
    if (lExpect != lActual) {
        tstLog(TERSE, "FAIL: %s (was %ld should be %ld)",
                    lpszCase, lActual, lExpect);
        tstLogFlush();
        return FALSE;
    } else {
        return TRUE;
    }
}


// check that an intermediate HRESULT succeeded - report failure only
BOOL
CheckHR(HRESULT hr, LPSTR lpszCase)
{
    if (FAILED(hr)) {
        tstLog(TERSE, "FAIL: %s (HR=0x%x)", lpszCase, hr);
        tstLogFlush();
        return FALSE;
    } else {
        return TRUE;
    }
}

// check we have read access to memory
BOOL
ValidateMemory(BYTE * ptr, LONG cBytes)
{
    if (IsBadReadPtr(ptr, cBytes)) {
        tstLog(TERSE, "FAIL: bad read pointer 0x%x", ptr);
        tstLogFlush();
        return FALSE;
    } else {
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avimsr\test\srctest.h ===
/***************************************************************************\
*                                                                           *
*   File: SrcTest.h                                                         *
*                                                                           *
*   Copyright (c) 1993,1996 Microsoft Corporation.  All rights reserved     *
*                                                                           *
*   Abstract:                                                               *
*       This header file contains various constants and prototypes used     *
*       in the Quartz source filter tests - test shell version.             *
*                                                                           *
*   Contents:                                                               *
*                                                                           *
*   History:                                                                *
*       06/08/93    T-OriG   - sample code                                  *
*       9-Mar-95    v-mikere - adapted for Quartz source filter tests       *
*       22-Mar-95   v-mikere - deleted DPF, added custom profile handlers   *
*                                                                           *
\***************************************************************************/


// Prototypes

// From SrcTest.cpp
VOID CALLBACK SaveCustomProfile(LPCSTR pszProfileName);
VOID CALLBACK LoadCustomProfile(LPCSTR pszProfileName);
LRESULT SelectAVIFile(void);

extern LRESULT FAR PASCAL MenuProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
extern BOOL InitOptionsMenu (LRESULT (CALLBACK* ManuProc)(HWND, UINT, WPARAM, LPARAM));
extern LRESULT FAR PASCAL tstAppWndProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);



// From tests.c
extern int expect (UINT uExpected, UINT uActual, LPSTR CaseDesc);
extern int apiToTest (void);
extern int FAR PASCAL execTest1(void);
extern int FAR PASCAL execTest2(void);
extern int FAR PASCAL execTest3(void);
extern int FAR PASCAL execTest4(void);
extern int FAR PASCAL execTest5(void);
extern int FAR PASCAL execTest6(void);
extern int FAR PASCAL execTest7(void);
extern int FAR PASCAL execTest8(void);
extern int FAR PASCAL execTest9(void);
extern int FAR PASCAL execTest10(void);

// result check help functions
BOOL ValidateMemory(BYTE * ptr, LONG cBytes);
BOOL  CheckHR(HRESULT hr, LPSTR lpszCase);
BOOL CheckLong(LONG lExpect, LONG lActual, LPSTR lpszCase);





// Constants

// Stops the logging intensive test
#define VSTOPKEY            VK_SPACE

// The string identifiers for the group's names
#define GRP_CONNECT         100
#define GRP_RUN             101
#define GRP_SEEK            102
#define GRP_LAST            GRP_SEEK

// The string identifiers for the test's names
#define ID_TEST1           200
#define ID_TEST2           201
#define ID_TEST3           202
#define ID_TEST4           203
#define ID_TEST5           204
#define ID_TEST6           205
#define ID_TEST7           206
#define ID_TEST8           207
#define ID_TEST9           208
#define ID_TEST10          209
#define ID_TESTLAST        ID_TEST10

// The test case identifier (used in the switch statement in execTest)
#define FX_TEST1            300
#define FX_TEST2            301
#define FX_TEST3            302
#define FX_TEST4            303
#define FX_TEST5            304
#define FX_TEST6            305
#define FX_TEST7            306
#define FX_TEST8            307
#define FX_TEST9            308
#define FX_TEST10           309

// Menu identifiers
#define IDM_DISCONNECT      100
#define IDM_CONNECT         101
#define IDM_STOP            102
#define IDM_PAUSE           104
#define IDM_RUN             105
#define IDM_SPLITTER        106
#define IDM_CLEARLOG        107
#define IDM_SELECTFILE      108

// Identifies the test list section of the resource file
#define TEST_LIST           500

// Multiple platform support
#define PLATFORM1           1
#define PLATFORM2           2
#define PLATFORM3           4


// Global variables

extern HWND         ghwndTstShell;      // Handle to test shell main window
extern CTestSink    *gpSink;            // Test sink object for all the tests


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avimux\avidest.h ===
#pragma warning(disable: 4097 4511 4512 4514 4705)

//
// Avi dest (render filter)
//

#include "alloc.h"

#include <stdio.h>              // for FILENAME_MAX

extern const AMOVIESETUP_FILTER sudAviMux ;

const int C_MAX_INPUTS = 0x7f;

class CAviDest;

class CAviDestOutput :
  public CBaseOutputPin
{
  CAviDest *m_pFilter;
  CSampAllocator *m_pSampAllocator;
public:
  CAviDestOutput(
    TCHAR *pObjectName,         // Object description
    CAviDest *pFilter,          // Owning filter who knows about pins
    CCritSec *pLock,            // Object who implements the lock
    HRESULT *phr);              // General OLE return code
  ~CAviDestOutput();

  HRESULT CheckMediaType(const CMediaType *);
  STDMETHODIMP BeginFlush(void);
  STDMETHODIMP EndFlush(void);
  HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);
  HRESULT CompleteConnect(IPin *pReceivePin);
  HRESULT BreakConnect();
  HRESULT DecideBufferSize(
    IMemAllocator * pAlloc,
    ALLOCATOR_PROPERTIES * ppropInputRequest) {
    return E_NOTIMPL;
  }
  HRESULT DecideAllocator(IMemInputPin * pPin, IMemAllocator ** pAlloc);
};

class CAviDest : public CBaseFilter,
                 public IConfigInterleaving,
                 public IConfigAviMux,
                 public ISpecifyPropertyPages,
                 public IPersistMediaPropertyBag,
                 public CPersistStream,                 
                 public IMediaSeeking
{
  class CAviInput;

public:

  //
  // COM stuff
  //
  DECLARE_IUNKNOWN;
  STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
  
  //
  // filter creation
  //
  CAviDest(LPUNKNOWN pUnk, HRESULT *pHr);
  ~CAviDest();
  static CUnknown *CreateInstance(LPUNKNOWN punk, HRESULT *pHr);

  //
  // CBaseFilter overrides
  //
  CBasePin* GetPin(int n);
  int GetPinCount();

  //
  // IMediaFilter overrides
  //
  STDMETHODIMP Stop();
  STDMETHODIMP Pause();
  STDMETHODIMP Run(REFERENCE_TIME tStart);

  // for IAMStreamControl
  STDMETHODIMP SetSyncSource(IReferenceClock *pClock);
  STDMETHODIMP JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName);

  HRESULT Receive(
      int pinNum,
      IMediaSample *pSample,
      const AM_SAMPLE2_PROPERTIES *pSampProp);

  // IConfigInterleaving
  STDMETHODIMP put_Mode(InterleavingMode mode);
  STDMETHODIMP get_Mode(InterleavingMode *pMode);
  STDMETHODIMP put_Interleaving(
      const REFERENCE_TIME *prtInterleave,
      const REFERENCE_TIME *prtPreroll);
    
  STDMETHODIMP get_Interleaving(
      REFERENCE_TIME *prtInterleave,
      REFERENCE_TIME *prtPreroll);
  
  // IConfigAviMux
  STDMETHODIMP SetMasterStream(LONG iStream);
  STDMETHODIMP GetMasterStream(LONG *pStream);
  STDMETHODIMP SetOutputCompatibilityIndex(BOOL fOldIndex);
  STDMETHODIMP GetOutputCompatibilityIndex(BOOL *pfOldIndex);

  // CPersistStream
  HRESULT WriteToStream(IStream *pStream);
  HRESULT ReadFromStream(IStream *pStream);
  int SizeMax();

  //
  // implements ISpecifyPropertyPages interface
  //
  STDMETHODIMP GetPages(CAUUID * pPages);

  ULONG GetCFramesDropped();

  // IMediaSeeking. currently used for a progress bar (how much have
  // we written?)
  STDMETHODIMP IsFormatSupported(const GUID * pFormat);
  STDMETHODIMP QueryPreferredFormat(GUID *pFormat);
  STDMETHODIMP SetTimeFormat(const GUID * pFormat);
  STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);
  STDMETHODIMP GetTimeFormat(GUID *pFormat);
  STDMETHODIMP GetDuration(LONGLONG *pDuration);
  STDMETHODIMP GetStopPosition(LONGLONG *pStop);
  STDMETHODIMP GetCurrentPosition(LONGLONG *pCurrent);
  STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
  STDMETHODIMP CheckCapabilities( DWORD * pCapabilities );

  STDMETHODIMP ConvertTimeFormat(
    LONGLONG * pTarget, const GUID * pTargetFormat,
    LONGLONG    Source, const GUID * pSourceFormat );

  STDMETHODIMP SetPositions(
    LONGLONG * pCurrent,  DWORD CurrentFlags,
    LONGLONG * pStop,  DWORD StopFlags );

  STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );
  STDMETHODIMP GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest );
  STDMETHODIMP SetRate( double dRate);
  STDMETHODIMP GetRate( double * pdRate);
  STDMETHODIMP GetPreroll(LONGLONG *pPreroll);

  // IPersistMediaPropertyBag methods    
  STDMETHODIMP InitNew();
  STDMETHODIMP Load( IMediaPropertyBag *pPropBag, LPERRORLOG pErrorLog);
  STDMETHODIMP Save( IMediaPropertyBag *pPropBag, BOOL fClearDirty,
                  BOOL fSaveAllProperties);
  STDMETHODIMP GetClassID(CLSID *pClsid);

private:

  // number of inputs filter has currently
  unsigned m_cInputs;           // count of pins
  unsigned m_cActivePins;       // pins that haven't seen EOS
  unsigned m_cConnections;      // connected pins
  HRESULT AddNextPin(unsigned callingPin);
  void CompleteConnect();
  void BreakConnect();

  HRESULT ReconnectAllInputs();

  friend class CAviInput;
  friend class CImplFileSinkFilter;
  friend class CAviDestOutput;

  // critical section protecting filter state.
  CCritSec m_csFilter;

  // interface to writing the Avi file
  class CAviWrite *m_pAviWrite;

  BOOL m_fErrorSignaled;
  BOOL m_fIsDV;
  ULONG GetStreamDuration(IPin *pInputPin, CMediaType *pmt);

  // memory requirements of all allocators on this filter (all pins,
  // etc.)
  ULONG m_AlignReq, m_cbPrefixReq, m_cbSuffixReq;


  CAviDestOutput m_outputPin;

  //
  // input pin implementation
  //
  class CAviInput : public CBaseInputPin, public CBaseStreamControl,
                    public IPropertyBag
  {
    friend class CAviDest;

  public:

    CAviInput(
      CAviDest *pAviDest,       // used to enumerate pins
      HRESULT *pHr,             // OLE failure return code
      LPCWSTR szName,           // pin identification
      int numPin);              // number of this pin


    ~CAviInput();

    DECLARE_IUNKNOWN

    // to expose IAMStreamControl
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // for IAMStreamControl
    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();

    HRESULT CheckMediaType(const CMediaType *);
    STDMETHODIMP Receive(IMediaSample *pSample);

    // IMemInputPin
    STDMETHODIMP NotifyAllocator(IMemAllocator * pAllocator, BOOL bReadOnly);
    STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProp);
    STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator);

    HRESULT BreakConnect();
    HRESULT CompleteConnect(IPin *pReceivePin);
    STDMETHODIMP EndOfStream();

    HRESULT Active(void);
    HRESULT Inactive(void);

    HRESULT HandlePossibleDiscontinuity(IMediaSample* pSample);
    // check with CAviWrite class
    STDMETHODIMP QueryAccept(
        const AM_MEDIA_TYPE *pmt
    );
      

    BOOL WriteFromOurAllocator();

    // IPropertyBag
    STDMETHODIMP Read( 
      /* [in] */ LPCOLESTR pszPropName,
      /* [out][in] */ VARIANT *pVar,
      /* [in] */ IErrorLog *pErrorLog);
    
    STDMETHODIMP Write( 
      /* [in] */ LPCOLESTR pszPropName,
      /* [in] */ VARIANT *pVar);


  private:
    
    void Reset();

    // copy sample
    HRESULT Copy(IMediaSample *pDest, IMediaSample *pSource);

    CSfxAllocator *m_pOurAllocator;

    CAviDest *m_pFilter;        // filter that owns this pin
    BOOL m_bUsingOurAllocator;
    BOOL m_bCopyNecessary;      // allocator cannot meet requiments
    BOOL m_bConnected;          // CompleteConnect/BreakConnect pairs
    int m_numPin;               // pin number
    BOOL m_fLastSampleDiscarded;// for IAMStreamControl

    REFERENCE_TIME m_rtLastStop;
    REFERENCE_TIME m_rtSTime;   //Total time of silence inserted

    char *m_szStreamName;
  };

  // array of pointers to inputs
  CAviInput *m_rgpInput[C_MAX_INPUTS];

  enum TimeFormat
  {
    FORMAT_BYTES,
    FORMAT_TIME
  } m_TimeFormat;

 

  IMediaPropertyBag *m_pCopyrightProps;

  struct PersistVal
  {
    DWORD dwcb;
    InterleavingMode mode;
    REFERENCE_TIME rtInterleave;
    REFERENCE_TIME rtPreroll;
    LONG iMasterStream;
    BOOL fOldIndex;
  };
};

// ------------------------------------------------------------------------
// property page

class CAviMuxProp : public CBasePropertyPage
{
public:
  CAviMuxProp(LPUNKNOWN lpUnk, HRESULT *phr);
  static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

  HRESULT OnConnect(IUnknown *pUnknown);
  HRESULT OnDisconnect();

  HRESULT OnActivate(void);
  HRESULT OnDeactivate();
  
  HRESULT OnApplyChanges();
  
private:
  INT_PTR OnReceiveMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

  void UpdatePropPage();
  void UpdateValues();
  
  void SetDirty();
  IConfigInterleaving *m_pIl;
  InterleavingMode m_mode;
  REFERENCE_TIME m_rtPreroll;
  REFERENCE_TIME m_rtInterleaving;
};

class CAviMuxProp1 : public CBasePropertyPage
{
public:
  CAviMuxProp1(LPUNKNOWN lpUnk, HRESULT *phr);
  static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

  HRESULT OnConnect(IUnknown *pUnknown);
  HRESULT OnDisconnect();

  HRESULT OnDeactivate();
  HRESULT OnActivate(void);
    
  HRESULT OnApplyChanges();
  
private:
  INT_PTR OnReceiveMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

  void UpdatePropPage();
  void UpdateValues();
    
  void SetDirty();

  IConfigAviMux *m_pCfgAvi;
  LONG m_lMasterStream;
  BOOL m_fOldIndex;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avimux\avidest.cpp ===
#include <windows.h>
#include <streams.h>
#include <atlbase.h>

#include <olectl.h>
#include "resource.h"

#include <initguid.h>
#include "avidest.h"
#include "aviwrite.h"

static const C_WRITE_REQS = 32; // number duplicated in fio

#pragma warning(disable: 4097 4511 4512 4514 4705)

#define DbgFunc(a) DbgLog(( LOG_TRACE, 5, \
                            TEXT("CAviDest::%s"), TEXT(a) \
                            ));
#ifdef FILTER_DLL

CFactoryTemplate g_Templates[]= {
  {L"AVI mux", &CLSID_AviDest, CAviDest::CreateInstance, NULL, &sudAviMux},
  {L"AVI mux Property Page", &CLSID_AviMuxProptyPage, CAviMuxProp::CreateInstance, NULL, NULL},
  {L"AVI mux Property Page1", &CLSID_AviMuxProptyPage1, CAviMuxProp1::CreateInstance, NULL, NULL}
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

HRESULT DllRegisterServer()
{
  return AMovieDllRegisterServer2(TRUE);
}

HRESULT DllUnregisterServer()
{
  return AMovieDllRegisterServer2(FALSE);
}

#endif // FILTER_DLL

AMOVIESETUP_MEDIATYPE sudAVIMuxPinTypes =   {
  &MEDIATYPE_Stream,            // clsMajorType
  &MEDIASUBTYPE_Avi };          // clsMinorType

AMOVIESETUP_PIN psudAVIMuxPins[] =
{
  { L"Output"                   // strName
    , FALSE                     // bRendered
    , FALSE                     // bOutput
    , FALSE                     // bZero
    , FALSE                     // bMany
    , &CLSID_NULL               // clsConnectsToFilter
    , L""                       // strConnectsToPin
    , 1                         // nTypes
    , &sudAVIMuxPinTypes        // lpTypes
  }
};


const AMOVIESETUP_FILTER sudAviMux =
{
  &CLSID_AviDest                // clsID
  , L"AVI Mux"                  // strName
  , MERIT_DO_NOT_USE            // dwMerit
  , 1                           // nPins
  , psudAVIMuxPins              // lpPin
};


// ------------------------------------------------------------------------
// filter constructor

#pragma warning(disable:4355)
CAviDest::CAviDest(
  LPUNKNOWN pUnk,
  HRESULT *pHr) :
    CBaseFilter(NAME("Avi Dest"), pUnk, &m_csFilter, CLSID_AviDest),
    m_outputPin(NAME("demux out"), this, &m_csFilter, pHr),
    m_AlignReq(1),
    m_cInputs(0),
    m_cConnections(0),
    m_pAviWrite(0),
    m_cbPrefixReq(0),
    m_cbSuffixReq(0),
    m_pCopyrightProps(0),
    CPersistStream(pUnk, pHr),
    m_TimeFormat(FORMAT_TIME),
    m_fIsDV(FALSE)
{
  for(int i = 0; i < C_MAX_INPUTS; i++)
    m_rgpInput[i] = 0;

  if(FAILED(*pHr ))
    return ;

  *pHr = AddNextPin(0);
  if(FAILED(*pHr ))
    return ;


  DbgFunc("CAviDest: constructed");
}

// ------------------------------------------------------------------------
// destructor

CAviDest::~CAviDest()
{
  // free anything allocated

  for(unsigned i = 0; i < m_cInputs; i++)
    delete m_rgpInput[i];

  if(m_pCopyrightProps)
    m_pCopyrightProps->Release();



  DbgFunc("CAviDest: destructed");
}

//
// NonDelegatingQueryInterface
//
//
STDMETHODIMP
CAviDest::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
  if(riid == IID_ISpecifyPropertyPages)
  {
    return GetInterface((ISpecifyPropertyPages *)this, ppv);
  }
  else if(riid == IID_IConfigInterleaving)
  {
    return GetInterface((IConfigInterleaving *)this, ppv);
  }
  else if(riid == IID_IConfigAviMux)
  {
    return GetInterface((IConfigAviMux *)this, ppv);
  }
  else if(riid == IID_IMediaSeeking)
  {
    return GetInterface((IMediaSeeking *)this, ppv);
  }
  else if(riid == IID_IPersistMediaPropertyBag)
  {
    return GetInterface((IPersistMediaPropertyBag *)this, ppv);
  }
  else if(riid == IID_IPersistStream)
  {
    return GetInterface((IPersistStream *) this, ppv);
  }
  else
  {
    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
  }
}

// // overridden because pin

// STDMETHODIMP_(ULONG)
// CBaseMSROutPin::NonDelegatingRelease()
// {
// }

CUnknown *
CAviDest::CreateInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
  return new CAviDest(pUnk, phr);
}

// ------------------------------------------------------------------------
// CBaseFilter methods

CBasePin* CAviDest::GetPin(int n)
{
  if(n == 0)
    return &m_outputPin;
  else if(n - 1 < (int)m_cInputs && n - 1 >= 0)
    return m_rgpInput[n - 1];
  else
    return 0;
}

int CAviDest::GetPinCount()
{
  return m_cInputs + 1;
}

// tell CBaseStreamControl what sink to use
//
STDMETHODIMP CAviDest::JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName)
{
    HRESULT hr = CBaseFilter::JoinFilterGraph(pGraph, pName);
    if (hr == S_OK) {
        // tell our input pins' IAMStreamControl what sink to use
        for(unsigned i = 0; i < m_cInputs; i++) {
            m_rgpInput[i]->SetFilterGraph(m_pSink);
        }
    }
    return hr;
}

// ------------------------------------------------------------------------
// IMediaFilter


// tell CBaseStreamControl what clock to use
//
STDMETHODIMP CAviDest::SetSyncSource(IReferenceClock *pClock)
{
    // tell our input pins' IAMStreamControl what clock to use
    for(unsigned i = 0; i < m_cInputs; i++) {
        m_rgpInput[i]->SetSyncSource(pClock);
    }
    return CBaseFilter::SetSyncSource(pClock);
}

STDMETHODIMP CAviDest::Stop()
{
  CAutoLock lock(&m_csFilter);

  FILTER_STATE state = m_State;

  HRESULT hr = CBaseFilter::Stop();
  if(FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviDest::Stop: BaseMediaFilter::Stop failed.")));
    return hr;
  }


  if(state != State_Stopped &&
     m_pAviWrite != 0 &&
     m_outputPin.IsConnected())
  {
    hr = m_pAviWrite->Close();
  }

  // tell our input pins' IAMStreamControl what state we're in
  for(unsigned i = 0; i < m_cInputs; i++)
    {
      if(m_rgpInput[i]->IsConnected())
      {
        m_rgpInput[i]->NotifyFilterState(State_Stopped, 0);
      }
    }

  if(m_fErrorSignaled)
    return S_OK;



  return hr;
}

// STDMETHODIMP CAviDest::FindPin(LPCWSTR Id, IPin * *ppPin)
// {
//   ASSERT(!"!!! CAviDest::FindPin untested");

//   *ppPin = 0;
//   unsigned pin;

//   if(wcslen(Id) != 4)
//     return VFW_E_NOT_FOUND;

//   if(swscanf(Id + 2, L"%02x", &pin) != 1)
//     return VFW_E_NOT_FOUND;

//   if(pin >= C_MAX_INPUTS)
//     return VFW_E_NOT_FOUND;

//   if(m_rgpInput[pin] == 0)
//     return VFW_E_NOT_FOUND;

//   *ppPin = m_rgpInput[pin];
//   (*ppPin)->AddRef();
//   return NOERROR;
// }

// ------------------------------------------------------------------------
//

STDMETHODIMP CAviDest::Pause()
{
  CAutoLock lock(&m_csFilter);

  if(m_State == State_Stopped && m_outputPin.IsConnected())
  {
    m_fErrorSignaled = TRUE;

    if(m_pAviWrite == 0)
    {
      DbgLog(( LOG_ERROR, 2,
               TEXT("CAviDest::Pause: AviWrite wasn't initialized.")));
      return E_FAIL;
    }

    AviWriteStreamConfig rgAwsc[C_MAX_INPUTS];
    unsigned cActivePins = 0;
    for(unsigned i = 0; i < m_cInputs; i++)
    {
      if(m_rgpInput[i]->IsConnected())
      {

        rgAwsc[i].pmt = &m_rgpInput[i]->m_mt;
        rgAwsc[i].fOurAllocator = m_rgpInput[i]->WriteFromOurAllocator();
        rgAwsc[i].cSamplesExpected = GetStreamDuration(
          m_rgpInput[i], rgAwsc[i].pmt);
        rgAwsc[i].szStreamName = m_rgpInput[i]->m_szStreamName;

        cActivePins++;
      }
      else
      {
        rgAwsc[i].pmt = 0;
        rgAwsc[i].fOurAllocator = FALSE;
        rgAwsc[i].cSamplesExpected = 0;
        rgAwsc[i].szStreamName = 0;
      }
    }

    if(cActivePins == 0)
    {
      m_outputPin.DeliverEndOfStream();
    }

    m_cActivePins = cActivePins;
    ASSERT(m_cActivePins == m_cConnections);

    DbgLog(( LOG_TRACE, 2,
             TEXT("CAviDest::Pause: %i active streams."), m_cActivePins));

    HRESULT hr = m_pAviWrite->Initialize(m_cInputs, rgAwsc, m_pCopyrightProps);

    if(FAILED(hr))
    {
      DbgLog(( LOG_ERROR, 2,
               TEXT("CAviDest::Pause: aviwrite Initialize failed.")));
      return hr;
    }

    m_fErrorSignaled = FALSE;
  }

  // tell our input pins' IAMStreamControl what state we're in
  for(unsigned i = 0; i < m_cInputs; i++)
    {
      if(m_rgpInput[i]->IsConnected())
      {
        m_rgpInput[i]->NotifyFilterState(State_Paused, 0);
      }
    }

  return CBaseFilter::Pause();
}






STDMETHODIMP CAviDest::Run(REFERENCE_TIME tStart)
{
  CAutoLock lock(&m_csFilter);

  // tell our input pins' IAMStreamControl what state we're in
  for(unsigned i = 0; i < m_cInputs; i++)
    {
      if(m_rgpInput[i]->IsConnected())
      {
        m_rgpInput[i]->NotifyFilterState(State_Running, tStart);
      }
    }

  return CBaseFilter::Run(tStart);
}

// use IMediaSeeking to report how many samples an upstream pin will
// send us. zero if anything goes wrong.
//
ULONG CAviDest::GetStreamDuration(
  IPin *pInputPin,
  CMediaType *pmt)
{
  ULONG cFrames = 0;

  IPin *pPin;
  if(pInputPin->ConnectedTo(&pPin) == S_OK)
  {
    IMediaSeeking *pIms;
    HRESULT hr = pPin->QueryInterface(IID_IMediaSeeking, (void **)&pIms);
    if(SUCCEEDED(hr))
    {
      REFERENCE_TIME rtStart, rtStop;
      hr = pIms->GetPositions(&rtStart, &rtStop);
      if(SUCCEEDED(hr))
      {
        REFERENCE_TIME rtStartSample, rtStopSample;
        GUID guidTimeFormat;

        if(pmt->majortype == MEDIATYPE_Audio)
          guidTimeFormat = TIME_FORMAT_SAMPLE;
        else
          guidTimeFormat = TIME_FORMAT_FRAME;

        hr = pIms->ConvertTimeFormat(
          &rtStartSample, &guidTimeFormat,
          rtStart, 0);
        if(SUCCEEDED(hr))
        {
          hr = pIms->ConvertTimeFormat(
            &rtStopSample, &guidTimeFormat,
            rtStop, 0);
          if(SUCCEEDED(hr))
          {
            ASSERT(rtStopSample >= rtStartSample);
            cFrames = (ULONG)(rtStopSample - rtStartSample);
          }
        }
      }

      pIms->Release();
    }
    pPin->Release();
  }

  DbgLog((LOG_TRACE, 5, TEXT("Avimux: GetStreamDuration: %d"),
          cFrames));

  return cFrames;
}

// ------------------------------------------------------------------------
// filter Receive method. entered concurrently from pin->Receive()
//

HRESULT CAviDest::Receive(
    int pinNum,
    IMediaSample *pSample,
    const AM_SAMPLE2_PROPERTIES *pSampProp)
{
  if(m_State == State_Stopped)
  {
    DbgLog((LOG_ERROR,1, TEXT("avi mux: Receive when stopped!")));
    return VFW_E_NOT_RUNNING;
  }

  if(m_fErrorSignaled)
  {
    DbgLog((LOG_ERROR, 1,
            TEXT("avi mux: error signalled. S_FALSE to pin %d"), pinNum));
    return S_FALSE;
  }

  if(!m_outputPin.IsConnected())
  {
    DbgLog((LOG_ERROR, 1,
            TEXT("avi mux: no output pin. S_FALSE to pin %d"), pinNum));
    return S_FALSE;
  }

  // may block, so we can't lock the filter
  HRESULT hr = m_pAviWrite->Receive(pinNum, pSample, pSampProp);
  if(hr != S_OK)
  {
    DbgLog((LOG_ERROR, 1,
            TEXT("avimux: receive saw %08x on pin %d. refusing everything"),
            hr, pinNum));
    m_fErrorSignaled = TRUE;
    if(FAILED(hr))
    {
      NotifyEvent(EC_ERRORABORT, hr, 0);
      m_outputPin.DeliverEndOfStream();
    }
  }
  return hr;
}

// ------------------------------------------------------------------------
// IConfigAviMux methods

HRESULT CAviDest::put_Mode(InterleavingMode mode)
{
  CAutoLock lock(&m_csFilter);
  if(m_State != State_Stopped)
    return VFW_E_WRONG_STATE;

  HRESULT hr = m_pAviWrite->put_Mode(mode);
  if(SUCCEEDED(hr) && m_outputPin.IsConnected())
  {
    hr = m_pGraph->Reconnect(&m_outputPin);
    if(FAILED(hr))
      return hr;
  }
  return hr;
}

HRESULT CAviDest::get_Mode(InterleavingMode *pMode)
{
  CheckPointer(pMode, E_POINTER);

  return m_pAviWrite->get_Mode(pMode);
}

HRESULT CAviDest::put_Interleaving(
    const REFERENCE_TIME *prtInterleave,
    const REFERENCE_TIME * prtPreroll)
{
  CheckPointer(prtPreroll, E_POINTER);
  CheckPointer(prtInterleave, E_POINTER);

  CAutoLock lock(&m_csFilter);
  if(m_State != State_Stopped)
    return VFW_E_WRONG_STATE;

  return m_pAviWrite->put_Interleaving(prtInterleave, prtPreroll);
}

HRESULT CAviDest::get_Interleaving(
    REFERENCE_TIME *prtInterleave,
    REFERENCE_TIME *prtPreroll)
{
  CheckPointer(prtPreroll, E_POINTER);
  CheckPointer(prtInterleave, E_POINTER);

  return m_pAviWrite->get_Interleaving(prtInterleave, prtPreroll);
}

STDMETHODIMP CAviDest::GetPages(CAUUID * pPages)
{
  CAutoLock lock(&m_csFilter);
  pPages->cElems = 2;
  pPages->pElems =  (GUID *) CoTaskMemAlloc(sizeof(GUID) * 2);
  if (pPages->pElems == NULL)
    return E_OUTOFMEMORY;
  pPages->pElems[0] = CLSID_AviMuxProptyPage;
  pPages->pElems[1] = CLSID_AviMuxProptyPage1;

  return S_OK;
}

ULONG CAviDest::GetCFramesDropped()
{
  return m_pAviWrite ? m_pAviWrite->GetCFramesDropped() : 0;
}

// ------------------------------------------------------------------------
// IConfigureAviTemp

HRESULT CAviDest::SetMasterStream(LONG iStream)
{
  // postpone checking this until Pause because we may be called
  // before inputs are connected.
  if(iStream < -1)
  {
    DbgLog((LOG_ERROR, 1, TEXT("avimux: invalid master stream")));
    return E_INVALIDARG;
  }

  return m_pAviWrite->SetMasterStream(iStream);
}

HRESULT CAviDest::GetMasterStream(LONG *piStream)
{
  CheckPointer(piStream, E_POINTER);

  return m_pAviWrite->GetMasterStream(piStream);
}

HRESULT CAviDest::SetOutputCompatibilityIndex(BOOL fOldIndex)
{
  return m_pAviWrite->SetOutputCompatibilityIndex(fOldIndex);
}

HRESULT CAviDest::GetOutputCompatibilityIndex(BOOL *pfOldIndex)
{
  CheckPointer(pfOldIndex, E_POINTER);
  return m_pAviWrite->GetOutputCompatibilityIndex(pfOldIndex);
}

// IMediaSeeking

HRESULT CAviDest::IsFormatSupported(const GUID * pFormat)
{
  return *pFormat == TIME_FORMAT_MEDIA_TIME ||
    *pFormat == TIME_FORMAT_BYTE ? S_OK : S_FALSE;
}

HRESULT CAviDest::QueryPreferredFormat(GUID *pFormat)
{
  *pFormat = TIME_FORMAT_MEDIA_TIME;
  return S_OK;
}

HRESULT CAviDest::SetTimeFormat(const GUID * pFormat)
{
  HRESULT hr = S_OK;
  if(*pFormat == TIME_FORMAT_MEDIA_TIME)
    m_TimeFormat = FORMAT_TIME;
  else if(*pFormat == TIME_FORMAT_BYTE)
    m_TimeFormat = FORMAT_BYTES;
  else
    hr = E_INVALIDARG;

  return hr;
}

HRESULT CAviDest::IsUsingTimeFormat(const GUID * pFormat)
{
  HRESULT hr = S_OK;
  if (m_TimeFormat == FORMAT_TIME && *pFormat == TIME_FORMAT_MEDIA_TIME)
    ;
  else if (*pFormat == TIME_FORMAT_BYTE)
    ASSERT(m_TimeFormat == FORMAT_BYTES);
  else
    hr = S_FALSE;

  return hr;
}

HRESULT CAviDest::GetTimeFormat(GUID *pFormat)
{
  *pFormat = m_TimeFormat == FORMAT_TIME ?
    TIME_FORMAT_MEDIA_TIME : TIME_FORMAT_BYTE;

  return S_OK;
}

HRESULT CAviDest::GetDuration(LONGLONG *pDuration)
{
  HRESULT hr = S_OK;
  CAutoLock lock(&m_csFilter);

  if(m_TimeFormat == FORMAT_TIME)
  {
    *pDuration = 0;
    for(unsigned i = 0; i < m_cInputs; i++)
    {

      if(m_rgpInput[i]->IsConnected())
      {
        IPin *pPinUpstream;
        if(m_rgpInput[i]->ConnectedTo(&pPinUpstream) == S_OK)
        {
          IMediaSeeking *pIms;
          hr = pPinUpstream->QueryInterface(IID_IMediaSeeking, (void **)&pIms);
          if(SUCCEEDED(hr))
          {
            LONGLONG dur = 0;
            hr = pIms->GetDuration(&dur);

            if(SUCCEEDED(hr))
              *pDuration = max(dur, *pDuration);

            pIms->Release();
          }

          pPinUpstream->Release();
        }
      }

      if(FAILED(hr))
        break;
    }
  }
  else
  {
    *pDuration = 0;
    return E_UNEXPECTED;
  }

  return hr;
}

HRESULT CAviDest::GetStopPosition(LONGLONG *pStop)
{
  return E_NOTIMPL;
}

HRESULT CAviDest::GetCurrentPosition(LONGLONG *pCurrent)
{
  CheckPointer(pCurrent, E_POINTER);

  if(m_TimeFormat == FORMAT_TIME)
  {
    m_pAviWrite->GetCurrentTimePos(pCurrent);
  }
  else
  {
    ASSERT(m_TimeFormat == FORMAT_BYTES);
    m_pAviWrite->GetCurrentBytePos(pCurrent);
  }

  return S_OK;
}

HRESULT CAviDest::GetCapabilities( DWORD * pCapabilities )
{
  CAutoLock lock(&m_csFilter);
  *pCapabilities = 0;

  // for the time format, we can get a duration by asking the upstream
  // filters
  if(m_TimeFormat == FORMAT_TIME)
  {
    *pCapabilities |= AM_SEEKING_CanGetDuration;
    for(unsigned i = 0; i < m_cInputs; i++)
    {
      if(m_rgpInput[i]->IsConnected())
      {
        IPin *pPinUpstream;
        if(m_rgpInput[i]->ConnectedTo(&pPinUpstream) == S_OK)
        {
          IMediaSeeking *pIms;
          HRESULT hr = pPinUpstream->QueryInterface(IID_IMediaSeeking, (void **)&pIms);
          if(SUCCEEDED(hr))
          {
            hr = pIms->CheckCapabilities(pCapabilities);
            pIms->Release();
          }

          pPinUpstream->Release();
        }
      }
    }
  }

  // we always know the current position
  *pCapabilities |= AM_SEEKING_CanGetCurrentPos;

  return S_OK;
}

HRESULT CAviDest::CheckCapabilities( DWORD * pCapabilities )
{
  DWORD dwMask = 0;
  GetCapabilities(&dwMask);
  *pCapabilities &= dwMask;

  return S_OK;
}


HRESULT CAviDest::ConvertTimeFormat(
  LONGLONG * pTarget, const GUID * pTargetFormat,
  LONGLONG    Source, const GUID * pSourceFormat )
{
  return E_NOTIMPL;
}


HRESULT CAviDest::SetPositions(
  LONGLONG * pCurrent,  DWORD CurrentFlags,
  LONGLONG * pStop,  DWORD StopFlags )
{
  // not yet implemented. this might be how we append to a file. and
  // how we write less than an entire file.
  return E_NOTIMPL;
}


HRESULT CAviDest::GetPositions( LONGLONG * pCurrent, LONGLONG * pStop )
{
  return E_NOTIMPL;
}

HRESULT CAviDest::GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest )
{
  return E_NOTIMPL;
}

HRESULT CAviDest::SetRate( double dRate)
{
  return E_NOTIMPL;
}

HRESULT CAviDest::GetRate( double * pdRate)
{
  return E_NOTIMPL;
}

HRESULT CAviDest::GetPreroll(LONGLONG *pPreroll)
{
  return E_NOTIMPL;
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// IPersistMediaPropertyBag

STDMETHODIMP CAviDest::Load(IMediaPropertyBag *pPropBag, LPERRORLOG pErrorLog)
{
    CheckPointer(pPropBag, E_POINTER);

    CAutoLock lock(&m_csFilter);
    if(m_State != State_Stopped)
        return VFW_E_WRONG_STATE;


    HRESULT hr = S_OK;

    if(m_pCopyrightProps)
        m_pCopyrightProps->Release();

    m_pCopyrightProps = pPropBag;
    pPropBag->AddRef();
    return hr;
}

STDMETHODIMP CAviDest::Save(
    IMediaPropertyBag *pPropBag, BOOL fClearDirty,
    BOOL fSaveAllProperties)
{
    // E_NOTIMPL is not a valid return code as any object implementing
    // this interface must support the entire functionality of the
    // interface. !!!
    return E_NOTIMPL;
}

STDMETHODIMP CAviDest::InitNew()
{
    if(m_pCopyrightProps)
    {
        m_pCopyrightProps->Release();
        m_pCopyrightProps = 0;
    }

    return S_OK;
}

STDMETHODIMP CAviDest::GetClassID(CLSID *pClsid)
{
    return CBaseFilter::GetClassID(pClsid);
}




// ------------------------------------------------------------------------
// private methods

HRESULT CAviDest::AddNextPin(unsigned callingPin)
{
  CAutoLock lock(&m_csFilter);
  HRESULT hr;

  if(m_cConnections + 1 < m_cInputs)
    return S_OK;

  if(m_cInputs >= C_MAX_INPUTS)
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviDest::AddNextPin too many pins")));
    return E_FAIL;
  }

  WCHAR wsz[20];
  lstrcpyW(wsz, L"Input 00");
  wsz[6] = L'0' + (m_cInputs + 1) / 10;
  wsz[7] = L'0' + (m_cInputs + 1) % 10;

  hr = S_OK;
  m_rgpInput[m_cInputs] = new CAviInput(this, &hr, wsz, m_cInputs);
  if(m_rgpInput[m_cInputs] == 0)
    return  E_OUTOFMEMORY;

  if(FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviDest::AddNextPin create pin failed")));
    m_rgpInput[m_cInputs] = 0;
  }
  else
  {
    DbgLog(( LOG_TRACE, 2,
             TEXT("CAviDest::added 1 pin")));
    // now bring this pin up to date with all the stuff its IAMStreamControl
    // needs to know
    // our state better be STOPPED!
    m_rgpInput[m_cInputs]->SetFilterGraph(m_pSink);
    m_rgpInput[m_cInputs]->SetSyncSource(m_pClock);
    m_cInputs++;
  }

  ASSERT(m_cConnections < m_cInputs);

  return hr;
}

void CAviDest::CompleteConnect()
{
  CAutoLock lock(&m_csFilter);

  m_cConnections++;
  DbgLog(( LOG_TRACE, 2,
           TEXT("CAviDest::CompleteConnect %i"), m_cConnections ));

  ASSERT(m_cConnections <= m_cInputs);
}

void CAviDest::BreakConnect()
{
  CAutoLock lock(&m_csFilter);

  ASSERT(m_cConnections > 0);
  m_cConnections--;

  DbgLog(( LOG_TRACE, 2,
           TEXT("CAviDest::BreakConnect %i"), m_cConnections ));

}

HRESULT CAviDest::ReconnectAllInputs()
{
  DbgLog((LOG_TRACE, 5, TEXT("CAviDest::ReconnectAllInputs")));
  HRESULT hr;
  for(UINT i = 0; i < m_cInputs; i++)
  {
    if(m_rgpInput[i]->IsConnected())
    {
      hr = m_pGraph->Reconnect(m_rgpInput[i]);
      if(FAILED(hr))
        return hr;
    }
  }
  return S_OK;
}






// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Input pin implementation

// ------------------------------------------------------------------------
// constructor

CAviDest::CAviInput::CAviInput(
  CAviDest *pAviDest,
  HRESULT *pHr,
  LPCWSTR szName,
  int numPin
  )
    : CBaseInputPin(NAME("AVI Dest Input"), pAviDest,
                    &pAviDest->m_csFilter, pHr, szName)
{
  DbgFunc("CAviInput::constructor");
  m_pOurAllocator = 0;
  m_pAllocator = 0;
  m_rtLastStop = 0;
  m_szStreamName = NULL;

  Reset();


  m_pFilter = pAviDest;
  m_numPin = numPin;
}

STDMETHODIMP CAviDest::CAviInput::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IAMStreamControl) {
        return GetInterface((IAMStreamControl *)this, ppv);
    } else if (riid == IID_IPropertyBag) {
        return GetInterface(static_cast<IPropertyBag *>(this), ppv);
    } else {
        return CBaseInputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}


// necessary to support IAMStreamControl
STDMETHODIMP CAviDest::CAviInput::BeginFlush()
{
    Flushing(TRUE);
    return CBaseInputPin::BeginFlush();
}

// necessary to support IAMStreamControl
STDMETHODIMP CAviDest::CAviInput::EndFlush()
{
    Flushing(FALSE);
    return CBaseInputPin::EndFlush();
}

void CAviDest::CAviInput::Reset()
{
  m_bUsingOurAllocator = FALSE;
  m_bCopyNecessary = FALSE;
  m_bConnected = FALSE;

  if(m_pOurAllocator != 0)
    m_pOurAllocator->Release();
  m_pOurAllocator = 0;
}

CAviDest::CAviInput::~CAviInput()
{
  DbgFunc("CAviInput::destructor");
  Reset();
  delete[] m_szStreamName;
}

STDMETHODIMP CAviDest::CAviInput::EndOfStream()
{
  HRESULT hr;
  {
    CAutoLock lock(&m_pFilter->m_csFilter);

    if(m_bFlushing)
      return S_OK;

    if(m_pFilter->m_State == State_Stopped)
      return S_FALSE;

    DbgLog(( LOG_TRACE, 2,
             TEXT("CAviDest::CAviInput::EndOfStream %i active now"),
             m_pFilter->m_cActivePins ));

    hr = m_pFilter->m_pAviWrite->EndOfStream(m_numPin);
  }

  ASSERT(m_pFilter->m_cActivePins > 0);
  if(--m_pFilter->m_cActivePins == 0)
    m_pFilter->m_outputPin.DeliverEndOfStream();

  return hr;
}

HRESULT CAviDest::CAviInput::BreakConnect()
{



  if ((m_mt.subtype== MEDIASUBTYPE_dvsd )||(m_mt.subtype== MEDIASUBTYPE_dvhd  )
      ||(m_mt.subtype== MEDIASUBTYPE_dvsl  ))
  {
      m_pFilter->m_fIsDV = FALSE;
      DbgLog((LOG_TRACE,3,TEXT("Dv Video Pin Disc onnected")));
  }
  if(m_bConnected)
  {
    m_pFilter->BreakConnect();
    ASSERT(m_pFilter->m_cConnections < m_pFilter->m_cInputs);
  }
  m_bConnected = FALSE;

  if(m_pOurAllocator)
  {
    m_pOurAllocator->Release();
    m_pOurAllocator = 0;
  }



  return CBaseInputPin::BreakConnect();
}

HRESULT CAviDest::CAviInput::CompleteConnect(IPin *pReceivePin)
{
  HRESULT hr;

  DbgLog(( LOG_TRACE, 2,
           TEXT("CAviDest::CAviInput::CompleteConnect") ));

  hr = CBaseInputPin::CompleteConnect(pReceivePin);
  if(FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviDest::CAviInput::CompleteConnect CompleteConnect")));
    return hr;
  }

  if(!m_bConnected)
  {
    hr = m_pFilter->AddNextPin(m_numPin);
    if(FAILED(hr))
    {
      DbgLog(( LOG_ERROR, 2,
               TEXT("CAviDest::CAviInput::CompleteConnect AddNextPin failed")));
      return hr;
    }
    m_pFilter->CompleteConnect();
  }
  if ((m_mt.subtype== MEDIASUBTYPE_dvsd )||(m_mt.subtype== MEDIASUBTYPE_dvhd  )
      ||(m_mt.subtype== MEDIASUBTYPE_dvsl  ))
  {
      m_pFilter->m_fIsDV = TRUE;
      DbgLog((LOG_TRACE,3,TEXT("Dv Video Pin Connected")));
  }
  m_bConnected = TRUE;

  return hr;
}

// STDMETHODIMP CAviDest::CAviInput::QueryId(LPWSTR *Id)
// {
//   *Id = (LPWSTR)QzTaskMemAlloc(10);
//   if (*Id==NULL)
//     return E_OUTOFMEMORY;

//   swprintf(*Id, L"In%02X", m_numPin); // 10 bytes including unicode double-null.
//   return NOERROR;
// }

// ------------------------------------------------------------------------
// CheckMediaType

HRESULT CAviDest::CAviInput::CheckMediaType(
  const CMediaType *pMediaType
  )
{
  DbgFunc("CAviInput::CheckMediaType");

  // accept anything whose mediatype is a fourcc whose format type is
  // null or video with VIDEOINFO and audio with WAVEFORMATEX.

  const GUID *pMajorType = pMediaType->Type();
  const GUID *pFormatType = pMediaType->FormatType();

  FOURCC fcc = pMajorType->Data1;
  if(FOURCCMap(fcc) != *pMajorType &&
     *pMajorType != MEDIATYPE_AUXLine21Data)
  {
    return VFW_E_TYPE_NOT_ACCEPTED;
  }

  if(*pMajorType == MEDIATYPE_Audio)
  {
    if(*pFormatType != FORMAT_WaveFormatEx)
      return VFW_E_TYPE_NOT_ACCEPTED;

    // code later on divides by nBlockAlign. check for 0.
    WAVEFORMATEX *pwfx = (WAVEFORMATEX *)pMediaType->Format();
    if(pwfx->nBlockAlign == 0)
      return VFW_E_TYPE_NOT_ACCEPTED;
  }
  else if(*pMajorType == MEDIATYPE_Video)
  {
    if(*pFormatType != FORMAT_VideoInfo) {
      if (*pFormatType != FORMAT_DvInfo) {
          return VFW_E_TYPE_NOT_ACCEPTED;
      }
    } else {
        //  Check for negative heights and non-zero stride or
        //  offset weirdnesses
        //  Use the rcTarget rectangle as that describes the portion of
        //  the bitmap we're supposed to use
        const VIDEOINFOHEADER * const pvih =
            (const VIDEOINFOHEADER *const)pMediaType->pbFormat;
        if (pvih->bmiHeader.biHeight < 0 ||
            pvih->rcTarget.left != 0 ||
            pvih->rcTarget.right != 0 &&
                pvih->rcTarget.right != pvih->bmiHeader.biWidth) {
            return VFW_E_TYPE_NOT_ACCEPTED;
        }
    }
  }
  else if(*pMajorType == MEDIATYPE_Interleaved)
  {
    if(*pFormatType != FORMAT_DvInfo)
      return VFW_E_TYPE_NOT_ACCEPTED;
  }
  else
  {
    if(*pFormatType != GUID_NULL &&
       *pFormatType != FOURCCMap(pFormatType->Data1) &&
       *pFormatType != FORMAT_None)
    {{
      return VFW_E_TYPE_NOT_ACCEPTED;
    }}
  }

  return S_OK;
}

// ansi-only version of NAME macro (so that we don't need two
// CSilenceSample ctors.)
#ifdef DEBUG
#define NAME_A(x) (x)
#else
#define NAME_A(_x_) ((char *) NULL)
#endif


class CSilenceSample : public CMediaSample
{
public:
    CSilenceSample(BYTE *pBuffer, ULONG cbPrefix, ULONG cbBuffer, ULONG cbActual, HRESULT *phr) :
            CMediaSample(
                NAME_A("CSilenceSample"),
                (CBaseAllocator *)1, // keep assert from firing
                phr,
                0,                  // pbBuffer
                0)
        {
            m_nPrefix = cbPrefix;
            m_pBuffer = pBuffer;
            m_cbBuffer = cbBuffer;
            m_lActual = cbActual;
        }
    
    ~CSilenceSample() {
        VirtualFree( m_pBuffer - m_nPrefix, 0, MEM_RELEASE );
    }

        

    // overriden to avoid calling allocator since no allocator is used
    STDMETHODIMP_(ULONG) Release()
        {
            /* Decrement our own private reference count */
            LONG lRef = InterlockedDecrement(&m_cRef);

            ASSERT(lRef >= 0);

            DbgLog((LOG_MEMORY,3,TEXT("    Unknown %X ref-- = %d"),
                    this, m_cRef));

            /* Did we release our final reference count */
            if (lRef == 0) {
                delete this;
            }
            return (ULONG)lRef;
        }

    LONG m_nPrefix;
};

static inline DWORD AlignUp(DWORD dw, DWORD dwAlign) {
  // align up: round up to next boundary
  return (dw + (dwAlign -1)) & ~(dwAlign -1);
};


HRESULT CAviDest::CAviInput::HandlePossibleDiscontinuity(IMediaSample* pSample)
{
    HRESULT hr;
    REFERENCE_TIME rtStart;
    REFERENCE_TIME rtStop;
    pSample->GetTime(&rtStart,&rtStop);


    REFERENCE_TIME rtLastStop = m_rtLastStop;


     //if this is the first packet then we should not treat it as a discontinuity
    if (!rtLastStop)
        return NOERROR;

    REFERENCE_TIME rtDropTime = rtStart-rtLastStop;

    DbgLog((LOG_TRACE, 2, TEXT("New Sample Starts at %I64d, Last Stop: %I64d"),rtStart,rtLastStop));
    DbgLog((LOG_TRACE, 2, TEXT("Dropped interval: %I64d * 100 Nanoseconds"), rtDropTime));


    //Obtain a pointer to the Stream MediaType
    AM_MEDIA_TYPE * pmt= NULL;
    m_pFilter->m_pAviWrite->GetStreamInfo(m_numPin,&pmt);
    if (!pmt)
        return NOERROR;


    WAVEFORMATEX * pwfx =(WAVEFORMATEX *) pmt->pbFormat;
    //Calculate bytes of silence = (time difference in 100 ns) * (avg. bytes/ 100 ns)


    LONG cbSilence;

    if (rtLastStop < rtStart)
        cbSilence = (LONG) ((rtDropTime) *
            (((double)pwfx->nAvgBytesPerSec)    /   UNITS));
    else return NOERROR;

    if (cbSilence % pwfx->nBlockAlign)
        cbSilence-=cbSilence %pwfx->nBlockAlign;

    DbgLog((LOG_TRACE ,2, TEXT("Insert Silence: Total Bytes: %d"),cbSilence));

    m_rtSTime += rtDropTime;

    // use buffer size so as not to exceed allocator agreed
    // size. unfortunately this could be unreasonably small
    const cbMaxToSend = pSample->GetActualDataLength();

    // allocator negotiation may require we leave space for suffix and
    // prefix.
    const cbOurBuffer = AlignUp(cbMaxToSend + m_pFilter->m_cbPrefixReq + m_pFilter->m_cbSuffixReq,
                                m_pFilter->m_AlignReq);
    while( cbSilence )
    {
        // size equals remaining silence bytes or size of buffer whichever is less
        //
        DWORD cbToSend = min( cbSilence, cbMaxToSend );

        //compute time stamps
        REFERENCE_TIME rtSilenceSampleStart = rtLastStop;
        REFERENCE_TIME rtSilenceSampleStop = rtSilenceSampleStart + 
            ((UNITS * cbToSend) / pwfx->nAvgBytesPerSec);

        DbgLog((LOG_TRACE, 2, TEXT("InsertSilence: Start: %I64d, Stop: %I64d, Bytes: %d"),
            rtSilenceSampleStart, rtSilenceSampleStop, cbToSend ));

        // allocate the memory
        //
        BYTE * pBuffer = (PBYTE) VirtualAlloc(
            NULL,
            cbOurBuffer,
            MEM_COMMIT,
            PAGE_READWRITE );
        if( !pBuffer )
        {
            return E_OUTOFMEMORY;
        }
        // VirtualAlloc zeroes the memory (silence) and gives us 64k aligned pointers
        // ASSERT((DWORD)pBuffer % 65536 == 0);

        hr = S_OK;
        CSilenceSample * pSilence = new CSilenceSample(
            pBuffer + m_pFilter->m_cbPrefixReq,
            m_pFilter->m_cbPrefixReq,
            cbOurBuffer,
            cbToSend,
            &hr);
        if( !pSilence )
        {
            VirtualFree( pBuffer, 0, MEM_RELEASE );
            return E_OUTOFMEMORY;
        }
        ASSERT(hr == S_OK);     // nothing to fail
        pSilence->AddRef( );

        pSilence->SetTime(&rtSilenceSampleStart, &rtSilenceSampleStop);

        hr = Receive( pSilence );

        pSilence->Release( );

        if( hr != S_OK )
            return hr;

        DbgLog( ( LOG_TRACE, 2, "Send %ld silence bytes", cbToSend ) );

        rtLastStop = rtSilenceSampleStop;
        cbSilence -= cbToSend;
    }

    return S_OK;
}




// ------------------------------------------------------------------------
// Receive. copies sample if necessary and passes it to filter

HRESULT CAviDest::CAviInput::Receive(
  IMediaSample *pSample
  )
{
  //Check for discontinutiy and if true, we send silence packets to fill up the gap.
  //We try to do this early before receive does any processing on the current sample
  //We do not check for success because if it returns failure.  Whatever caused that will
  // be handled in the code below and I do not want to fail the receive function because
  // of a failure in silence insertion

  if (m_pFilter->m_fIsDV &&(m_mt.formattype == FORMAT_WaveFormatEx)
      &&( pSample->IsDiscontinuity() == S_OK))
  {
      HRESULT hrTmp = HandlePossibleDiscontinuity(pSample);
      if(FAILED(hrTmp)) {
          m_pFilter->m_fErrorSignaled = TRUE;
          m_pFilter->NotifyEvent(EC_ERRORABORT, hrTmp, 0);
          m_pFilter->m_outputPin.DeliverEndOfStream();
      }
  }

  HRESULT hr = CBaseInputPin::Receive(pSample);
  if(FAILED(hr))
    return hr;

  // is this pin on or off?  IAMStreamControl tells us whether or not to
  // deliver it.  The first sample after being off for a while is a
  // discontinuity.. otherwise don't touch the discontinuity bit
  int iStreamState = CheckStreamState(pSample);
  if (iStreamState == STREAM_FLOWING) {
    //DbgLog((LOG_TRACE,4,TEXT("MUX FLOWING")));
    if (m_fLastSampleDiscarded)
      pSample->SetDiscontinuity(TRUE);
    m_fLastSampleDiscarded = FALSE;
  } else {
    //DbgLog((LOG_TRACE,4,TEXT("MUX DISCARDING")));
    m_fLastSampleDiscarded = TRUE;        // next one is discontinuity
  }

    // Remember ending time of last packet
  REFERENCE_TIME rtstart= 0;
  REFERENCE_TIME rtstop = 0;
  pSample->GetTime(&rtstart,&rtstop);
  if (rtstop > m_rtLastStop)
      m_rtLastStop = rtstop;

  if(m_bCopyNecessary && iStreamState == STREAM_FLOWING)
  {
    // copy sample to our properly configured buffer
    IMediaSample *pNewSample;
    hr = m_pOurAllocator->GetBuffer(&pNewSample, 0, 0, 0);
    if(FAILED(hr))              // fails if allocator was decommited
      return hr;
    hr = Copy(pNewSample, pSample);
    if(FAILED(hr))
    {
      pNewSample->Release();
      return hr;
    }

    hr = m_pFilter->Receive(m_numPin, pNewSample, SampleProps());
    // filter will addref it if it needs to keep it
    pNewSample->Release();
  }
  else if (iStreamState == STREAM_FLOWING)
  {
    hr = m_pFilter->Receive(m_numPin, pSample, SampleProps());
  }
  return hr;
}

// ------------------------------------------------------------------------
// NotifyAllocator

STDMETHODIMP CAviDest::CAviInput::NotifyAllocator(IMemAllocator * pAllocator,
                                                    BOOL bReadOnly)
{
  HRESULT hr;
  hr = CBaseInputPin::NotifyAllocator(pAllocator, bReadOnly);
  if (FAILED(hr))
  {
    return hr;
  }
  ASSERT(m_pAllocator != 0);

  m_bUsingOurAllocator = m_bCopyNecessary = FALSE;

  CAutoLock cObjectLock(m_pLock);

  // determine whether source filter passed in our allocator or its
  // own; set m_bUsingOurAllocator
  if(m_pOurAllocator == 0)
  {
    // source filter didn't call GetAllocator, so our allocator wasn't
    // created, and source must be using its own allocator
    m_bUsingOurAllocator = FALSE;
  }
  else
  {
    m_bUsingOurAllocator = IsEqualObject(m_pOurAllocator, pAllocator);
  }

  if(!m_bUsingOurAllocator)
  {
    // get alignment and offset to see if it meets our requirements;
    // set m_bCopyNecessary

    ALLOCATOR_PROPERTIES upstreamProp;
    HRESULT hr = pAllocator->GetProperties(&upstreamProp);
    if(FAILED(hr))
      return hr;

    InterleavingMode ilm;
    m_pFilter->m_pAviWrite->get_Mode(&ilm);

    // since we are a sink and we always request the prefix we know
    // it's ours to use. I suppose the upstream filter can give more
    // prefix than requested
    m_bCopyNecessary = (
      upstreamProp.cbAlign < (long)m_pFilter->m_AlignReq ||
      upstreamProp.cbPrefix != (long)m_pFilter->m_cbPrefixReq ||
      bReadOnly && ilm != INTERLEAVE_FULL);

    // we modify the data to add riff headers and junk chunks. should
    // fix this to refuse to connect to read only streams
    if(!m_bCopyNecessary)
      ASSERT(!bReadOnly || ilm == INTERLEAVE_FULL);
  }

  // if we are copying to our allocator, make sure we have created our
  // allocator (it's not created if source filter does not call
  // GetAllocator, so then this calls GetAllocator)
  if(m_bCopyNecessary && m_pOurAllocator == 0)
  {
    IMemAllocator *pAllocator;
    HRESULT hr = GetAllocator(&pAllocator);
    if(FAILED(hr))
      return hr;                // maybe we ran out of memory.
    pAllocator->Release();      // didn't actually want an allocator
    ASSERT(m_pOurAllocator != 0);
  }

  if(m_pOurAllocator)
  {
      // so now we are responsible for configuring the Allocator with
      // some minimum values in case upstream filter didn't listen to
      // GetAllocatorRequirements
      ALLOCATOR_PROPERTIES Request, Actual;
      hr = m_pAllocator->GetProperties(&Request);
      if(FAILED(hr))
          return hr;

      Request.cbPrefix = m_pFilter->m_cbPrefixReq;
      Request.cbAlign = max((LONG)m_pFilter->m_AlignReq, Request.cbAlign);

      hr = m_pOurAllocator->SetPropertiesAndSuffix(
          &Request, m_pFilter->m_cbSuffixReq, &Actual);

      ASSERT(SUCCEEDED(hr));

      if (FAILED(hr))
          return hr;

      if ((Request.cbBuffer > Actual.cbBuffer) ||
          (Request.cBuffers > Actual.cBuffers) ||
          (Request.cbAlign > Actual.cbAlign))
          return E_FAIL;
  }

  DbgLog(( LOG_TRACE, 2,  TEXT("CAviDest::NotifyAllocator: ours? %i copy? %i"),
           m_bUsingOurAllocator, m_bCopyNecessary));
  ASSERT(!(m_bUsingOurAllocator && m_bCopyNecessary));
  ASSERT(!(m_bCopyNecessary && m_pAllocator == m_pOurAllocator));

  return S_OK;
}

// ------------------------------------------------------------------------
// GetAllocatorRequirements. report that we want stuff aligned and
// room for a riff chunk up front.

STDMETHODIMP
CAviDest::CAviInput::GetAllocatorRequirements(
  ALLOCATOR_PROPERTIES *pProp)
{
  CheckPointer(pProp, E_POINTER);

  // NotifyAllocator relies on this being set
  pProp->cbPrefix = sizeof(RIFFCHUNK);
  if(m_pFilter->m_AlignReq == 0)
    DbgLog((LOG_TRACE, 10, TEXT("CAviMux: alignment unknown. reporting 0")));
  pProp->cbAlign = m_pFilter->m_AlignReq;
  return S_OK;
}

// ------------------------------------------------------------------------
// GetAllocator
//
// based on filter.cpp: CBaseInput. NotifyInterface relies on
// particular behavior. This is the thing that creates the allocator
//



STDMETHODIMP CAviDest::CAviInput::GetAllocator(IMemAllocator ** ppAllocator)
{
  CheckPointer(ppAllocator, E_POINTER);
  /*  Create our allocator */
  CAutoLock cObjectLock(m_pLock);
    if (m_pOurAllocator == NULL)
  {
    HRESULT hr = S_OK;

    /* Create the new allocator object */

    CSfxAllocator *pMemObject = new CSfxAllocator(
      NAME("AVI dest allocator created by input pin"),
      NULL,
      &hr);

    if (pMemObject == NULL)
    {
      return E_OUTOFMEMORY;
    }

    if (FAILED(hr))
    {
      ASSERT(pMemObject);
      delete pMemObject;
      return hr;
    }

    m_pOurAllocator = pMemObject;
        /*  We AddRef() our own allocator */
    m_pOurAllocator->AddRef();
  }



  ASSERT(m_pOurAllocator != NULL);
  *ppAllocator = m_pOurAllocator;
  (*ppAllocator)->AddRef();
  return NOERROR;
}

HRESULT CreateAllocator (CSfxAllocator** ppSAlloc)
{

    HRESULT hr = S_OK;

    /* Create the new allocator object */

    CSfxAllocator *pMemObject = new CSfxAllocator(
      NAME("AVI dest allocator created by input pin"),
      NULL,
      &hr);

    if (pMemObject == NULL)
    {
      return E_OUTOFMEMORY;
    }

    if (FAILED(hr))
    {
      ASSERT(pMemObject);
      delete pMemObject;
      return hr;
    }

    *ppSAlloc = pMemObject;

    /*  We AddRef() our own allocator */
    (*ppSAlloc)->AddRef();
    return S_OK;

}


HRESULT CAviDest::CAviInput::Active()
{
  ASSERT(IsConnected());        // base class

  if(m_pAllocator == 0)
    return E_FAIL;
  m_rtSTime = 0;
  m_rtLastStop = 0;
  m_fLastSampleDiscarded = FALSE;        // reset for IAMStreamControl

  // commit and prepare our allocator. Needs to be done if he is not
  // using our allocator and we need to use our allocator
  if(m_bCopyNecessary)
  {
    ASSERT(m_pOurAllocator != 0);
    return m_pOurAllocator->Commit();
  }


  // for silence insertion but not needed any more
  if (!m_bUsingOurAllocator && !m_bCopyNecessary)
  {

        HRESULT hr;
        if (!m_pOurAllocator)
        {
            hr =CreateAllocator(&m_pOurAllocator);
            if (FAILED (hr))
                return hr;
        }
      //Need to set properties and commit

        ALLOCATOR_PROPERTIES Actual, Request;
        Request.cBuffers = 4;
        Request.cbBuffer=32000;
        Request.cbAlign = m_pFilter->m_AlignReq;
        Request.cbPrefix=sizeof(RIFFCHUNK);

        hr = m_pOurAllocator->SetProperties(&Request,&Actual);
        if (FAILED (hr))
            return hr;
        hr = m_pOurAllocator->Commit();
        if (FAILED (hr))
            return hr;
  }

  return S_OK;
}


HRESULT CAviDest::CAviInput::Inactive()
{
  ASSERT(IsConnected());        // base class

  if(m_bCopyNecessary)
  {
    ASSERT(m_pOurAllocator != 0);
    return m_pOurAllocator->Decommit();
  }
  else if (!m_bUsingOurAllocator)
  {   HRESULT hr;
      hr = m_pOurAllocator->Decommit();
      if (FAILED (hr))
         return hr;
  }
  DbgLog((LOG_TRACE, 2, TEXT("Total Interval of Silence inserted = %I64d *100 NanoSeconds"),m_rtSTime));


  return S_OK;
}

HRESULT CAviDest::CAviInput::QueryAccept(
    const AM_MEDIA_TYPE *pmt)
{
    HRESULT hr = CBaseInputPin::QueryAccept(pmt);
    CAutoLock lock(&m_pFilter->m_csFilter);

    // if running, ask for on-the-fly format change
    if(hr == S_OK && m_pFilter->m_pAviWrite &&
       m_pFilter->m_State != State_Stopped)
    {
        hr = m_pFilter->m_pAviWrite->QueryAccept(m_numPin, pmt);
    }

    return hr;
}


BOOL CAviDest::CAviInput::WriteFromOurAllocator()
{
  return m_bUsingOurAllocator || m_bCopyNecessary;
}

// IPropertyBag
STDMETHODIMP CAviDest::CAviInput::Read( 
    /* [in] */ LPCOLESTR pszPropName,
    /* [out][in] */ VARIANT *pVar,
    /* [in] */ IErrorLog *pErrorLog)
{
    CheckPointer(pVar, E_POINTER);
    CheckPointer(pszPropName, E_POINTER);
    if(pVar->vt != VT_BSTR && pVar->vt != VT_EMPTY) {
        return E_FAIL;
    }

    // serialize with Write
    CAutoLock lock(&m_pFilter->m_csFilter);

    if(m_szStreamName == 0 || lstrcmpW(pszPropName, L"name") != 0) {
        return E_INVALIDARG;
    }
    
    WCHAR wsz[256];
    MultiByteToWideChar(CP_ACP, 0, m_szStreamName, -1, wsz, NUMELMS(wsz));
    pVar->vt = VT_BSTR;
    pVar->bstrVal = SysAllocString(wsz);

    return pVar->bstrVal ? S_OK : E_OUTOFMEMORY;
}
    
STDMETHODIMP CAviDest::CAviInput::Write( 
    /* [in] */ LPCOLESTR pszPropName,
    /* [in] */ VARIANT *pVar)
{
    CheckPointer(pVar, E_POINTER);
    CheckPointer(pszPropName, E_POINTER);

    if(lstrcmpW(pszPropName, L"name") != 0) {
        return E_INVALIDARG;
    }
    if(pVar->vt != VT_BSTR && pVar->vt != VT_EMPTY) {
        return E_INVALIDARG;
    }

    CAutoLock lock(&m_pFilter->m_csFilter);

    // refuse new name while running -- CAviWrite won't see new name
    if(m_pFilter->m_State != State_Stopped) {
        VFW_E_WRONG_STATE;
    }

    HRESULT hr = S_OK;

    if(pVar->vt == VT_BSTR && pVar->bstrVal && *pVar->bstrVal)
    {
        int cch = lstrlenW(pVar->bstrVal) + 1;
        char *szName = new char[cch];
        if(szName) {
            WideCharToMultiByte(CP_ACP, 0, pVar->bstrVal, -1, szName, cch, 0, 0);
            delete[] m_szStreamName;
            m_szStreamName = szName;
        } else {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        delete[] m_szStreamName;
        m_szStreamName = 0;
    }

    return hr;
}


HRESULT CAviDest::CAviInput::Copy(
  IMediaSample *pDest,
  IMediaSample *pSource)
{
    // Copy the sample data
    {
        BYTE *pSourceBuffer, *pDestBuffer;
        long lSourceSize = pSource->GetActualDataLength();
        long lDestSize        = pDest->GetSize();

        // bug to receive samples larger than what was agreed in allocator
        // negotiation
        ASSERT(lDestSize >= lSourceSize);

        // but we need to fail properly to keep from faulting on bad data
        if(lSourceSize > lDestSize)
        {
            DbgBreak("sample too large.");
            // !!! this won't signal an error to the graph
            return E_UNEXPECTED;
        }

        pSource->GetPointer(&pSourceBuffer);
        pDest->GetPointer(&pDestBuffer);

        CopyMemory( (PVOID) pDestBuffer, (PVOID) pSourceBuffer, lSourceSize );

        // Copy the actual data length
        pDest->SetActualDataLength(lSourceSize);
    }

  {
    // copy the sample time

    REFERENCE_TIME TimeStart, TimeEnd;

    if (NOERROR == pSource->GetTime(&TimeStart, &TimeEnd)) {
        pDest->SetTime(&TimeStart, &TimeEnd);
    }
  }
  {
    // copy the media time

    REFERENCE_TIME TimeStart, TimeEnd;

    if (NOERROR == pSource->GetMediaTime(&TimeStart, &TimeEnd)) {
        pDest->SetMediaTime(&TimeStart, &TimeEnd);
    }
  }
  {
    // Copy the Sync point property

    HRESULT hr = pSource->IsSyncPoint();
    if (hr == S_OK)
    {
      pDest->SetSyncPoint(TRUE);
    }
    else if (hr == S_FALSE)
    {
      pDest->SetSyncPoint(FALSE);
    }
    else {        // an unexpected error has occured...
      return E_UNEXPECTED;
    }
  }
  {
    // Copy the media type

    AM_MEDIA_TYPE *pMediaType;
    pSource->GetMediaType(&pMediaType);
    pDest->SetMediaType(pMediaType);
    DeleteMediaType( pMediaType );
  }
  {
    // Copy the preroll property

    HRESULT hr = pSource->IsPreroll();
    if (hr == S_OK)
    {
      pDest->SetPreroll(TRUE);
    }
    else if (hr == S_FALSE)
    {
      pDest->SetPreroll(FALSE);
    }
    else {        // an unexpected error has occured...
      return E_UNEXPECTED;
    }
  }
//   {
//     // Copy the Discontinuity property

//     HRESULT hr = pSource->IsDiscontinuity();
//     if (hr == S_OK) {
//       pDest->SetDiscontinuity(TRUE);
//     }
//     else if (hr == S_FALSE) {
//       pDest->SetDiscontinuity(FALSE);
//     }
//     else {        // an unexpected error has occured...
//       return E_UNEXPECTED;
//     }
//   }

  return NOERROR;
}

// ------------------------------------------------------------------------
// output pin

CAviDestOutput::CAviDestOutput(
  TCHAR *pObjectName,
  CAviDest *pFilter,
  CCritSec *pLock,
  HRESULT *phr) :
    CBaseOutputPin(pObjectName, pFilter, pLock, phr, L"AVI Out"),
    m_pFilter(pFilter),
    m_pSampAllocator(0)
{
  if(FAILED(*phr))
    return;

  // init allocator
  m_pSampAllocator = new CSampAllocator(NAME("samp alloc"), GetOwner(), phr);
  if(m_pSampAllocator == 0)
  {
    *phr =  E_OUTOFMEMORY;
    return;
  }
  // reset the allocator since we call GetProperties on it
  ALLOCATOR_PROPERTIES apReq, apActual;
  ZeroMemory(&apReq, sizeof(apReq));
  m_pSampAllocator->SetProperties(&apReq, &apActual);

  ASSERT(m_pFilter->m_pAviWrite == 0);
  m_pFilter->m_pAviWrite = new CAviWrite(phr);
  if(m_pFilter->m_pAviWrite == 0)
  {
    *phr = E_OUTOFMEMORY;
    return;
  }
  if(FAILED(*phr ))
    return ;

  DbgLog((LOG_TRACE, 10, TEXT("CAviDestOutput::CAviDestOutput")));
}

CAviDestOutput::~CAviDestOutput()
{
  DbgLog((LOG_TRACE, 10, TEXT("CAviDestOutput::~CAviDestOutput")));
  delete m_pFilter->m_pAviWrite;
  delete m_pSampAllocator;
}

HRESULT CAviDestOutput::CheckMediaType(const CMediaType *pmt)
{
  if((MEDIATYPE_Stream == pmt->majortype ||
      pmt->majortype == GUID_NULL) &&
     (MEDIASUBTYPE_Avi == pmt->subtype ||
      pmt->subtype == GUID_NULL))
  {
    return S_OK;
  }
  else
  {
    return S_FALSE;
  }
}

// every we time we connect, reconfigure our allocator to reflect our
// interleaving mode. we reconnect every time we change interleaving
// mode
HRESULT CAviDestOutput::DecideAllocator(IMemInputPin * pPin, IMemAllocator ** pAlloc)
{
  ALLOCATOR_PROPERTIES apReq, apActual, apDownstream;
  m_pSampAllocator->GetProperties(&apReq);
  apReq.cBuffers = C_WRITE_REQS;

  HRESULT hr = pPin->GetAllocatorRequirements(&apDownstream);
  if(FAILED(hr))
    apDownstream.cbAlign = 1;

  InterleavingMode ilMode;
  hr = m_pFilter->get_Mode(&ilMode);
  if(FAILED(hr))
    return hr;

  if(ilMode == INTERLEAVE_FULL || ilMode == INTERLEAVE_NONE_BUFFERED)
    apReq.cbAlign = 1;
  else
    apReq.cbAlign = apDownstream.cbAlign;

  hr = m_pSampAllocator->SetProperties(&apReq, &apActual);
  ASSERT(hr == S_OK);
  if(apActual.cBuffers < C_WRITE_REQS)
  {
    DbgBreak("disobedient allocator");
    return E_UNEXPECTED;
  }

  hr = pPin->NotifyAllocator(m_pSampAllocator, TRUE);
  if(FAILED(hr))
  {
    DbgBreak("avidest: unexpected: allocator refused");
    return hr;
  }
  *pAlloc = m_pSampAllocator;
  m_pSampAllocator->AddRef();
  return S_OK;
}

HRESULT CAviDestOutput::CompleteConnect(IPin *pReceivePin)
{
  DbgLog((LOG_TRACE, 10, TEXT("CAviDestOutput::CompleteConnect")));

  HRESULT hr = CBaseOutputPin::CompleteConnect(pReceivePin);
  if(FAILED(hr))
    return hr;

  hr = m_pFilter->m_pAviWrite->Connect(m_pSampAllocator, m_pInputPin);
  if(FAILED(hr))
    return hr;

  m_pFilter->m_pAviWrite->GetMemReq(
    &m_pFilter->m_AlignReq,
    &m_pFilter->m_cbPrefixReq,
    &m_pFilter->m_cbSuffixReq);

  // need to reconnect all input pins if alignment requirements
  // changed.

  return m_pFilter->ReconnectAllInputs();
}

HRESULT CAviDestOutput::BreakConnect()
{
  DbgLog((LOG_TRACE, 10, TEXT("CAviDestOutput::BreakConnect")));

  HRESULT hr = m_pFilter->m_pAviWrite->Disconnect();

  return CBaseOutputPin::BreakConnect();
}

HRESULT CAviDestOutput::GetMediaType(
  int iPosition,
  CMediaType *pMediaType)
{
  if(iPosition == 0)
  {
    pMediaType->majortype = MEDIATYPE_Stream;
    pMediaType->subtype = MEDIASUBTYPE_Avi;
    return S_OK;
  }
  return S_FALSE;
}

STDMETHODIMP
CAviDestOutput::BeginFlush(void)
{
  DbgBreak("avi mux output flush");
  return E_UNEXPECTED;
}

STDMETHODIMP
CAviDestOutput::EndFlush(void)
{
  DbgBreak("avi mux output flush");
  return E_UNEXPECTED;
}



// ------------------------------------------------------------------------
// property page

CUnknown *WINAPI CAviMuxProp::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
  return new CAviMuxProp(lpunk, phr);
}

CAviMuxProp::CAviMuxProp(LPUNKNOWN lpunk, HRESULT *phr) :
    CBasePropertyPage(
      NAME("avi mux Property Page"),
      lpunk,
      IDD_DIALOG_AVIMUX, IDS_AVIMUXPROPNAME),
    m_pIl(0)
{
  // InitCommonControls();
}

HRESULT CAviMuxProp::OnConnect(IUnknown *pUnknown)
{
  ASSERT(m_pIl == NULL);

  // Ask the filter for it's control interface

  HRESULT hr = pUnknown->QueryInterface(IID_IConfigInterleaving,(void **)&m_pIl);
  if (FAILED(hr)) {
    DbgBreak("avidest: can't find IID_IConfigInterleaving");
    return E_NOINTERFACE;
  }
  ASSERT(m_pIl);

  UpdateValues();

  return NOERROR;
}

void CAviMuxProp::UpdatePropPage()
{
  HRESULT hr = m_pIl->get_Mode(&m_mode);
  ASSERT(hr == S_OK);
  hr = m_pIl->get_Interleaving(&m_rtInterleaving, &m_rtPreroll);
  ASSERT(hr == S_OK);

  int iRadioButton;
  if(m_mode == INTERLEAVE_NONE)
    iRadioButton = IDC_AVIMUX_RADIO_NONE;
  else if(m_mode == INTERLEAVE_CAPTURE)
    iRadioButton = IDC_AVIMUX_RADIO_CAPTURE;
  else if(m_mode == INTERLEAVE_NONE_BUFFERED)
    iRadioButton = IDC_AVIMUX_RADIO_NONE_BUFF;
  else
  {
    iRadioButton = IDC_AVIMUX_RADIO_FULL;
    ASSERT(m_mode == INTERLEAVE_FULL);
  }

  CheckRadioButton(m_hwnd, IDC_AVIMUX_RADIO_NONE, IDC_AVIMUX_RADIO_FULL, iRadioButton);
  SetDlgItemInt (
      m_hwnd, IDC_AVIMUX_EDIT_INTERLEAVING,
      (LONG)(m_rtInterleaving / (UNITS / MILLISECONDS)), TRUE);
  SetDlgItemInt (
    m_hwnd, IDC_AVIMUX_EDIT_PREROLL,
    (LONG)(m_rtPreroll / (UNITS / MILLISECONDS)), TRUE);

  // hack which relies on CAviDest being derived from
  // IConfigInterleaving
  CAviDest *pAviDest = (CAviDest *)m_pIl;
  SetDlgItemInt (m_hwnd, IDC_AVIMUX_FRAMES_DROPPED, pAviDest->GetCFramesDropped(), TRUE);

  {
    LONGLONG ibCurrent = 0;
    REFERENCE_TIME rtCurrent = 0;
    REFERENCE_TIME rtDur = 0;

    IMediaSeeking *pIms;
    hr = pAviDest->QueryInterface(IID_IMediaSeeking, (void **)&pIms);
    if(SUCCEEDED(hr))
    {
      hr = pIms->SetTimeFormat(&TIME_FORMAT_MEDIA_TIME);
      if(SUCCEEDED(hr))
      {
        pIms->GetDuration(&rtDur);
        pIms->GetCurrentPosition(&rtCurrent);
      }
      hr = pIms->SetTimeFormat(&TIME_FORMAT_BYTE);
      if(SUCCEEDED(hr))
      {
        pIms->GetCurrentPosition(&ibCurrent);
      }

      pIms->Release();
    }

    TCHAR szTempString[100];

    wsprintf(szTempString, TEXT("%02d:%02d:%02d"),
             (LONG)(rtDur / UNITS / 60 / 60),
             (LONG)(rtDur / UNITS / 60 % 60),
             (LONG)(rtDur / UNITS % 60));

    SetDlgItemText(m_hwnd, IDC_AVIMUX_DURATION, szTempString);

    wsprintf(szTempString, TEXT("%02d:%02d:%02d"),
             (LONG)(rtCurrent / UNITS / 60 / 60),
             (LONG)(rtCurrent / UNITS / 60 % 60),
             (LONG)(rtCurrent / UNITS % 60));

    SetDlgItemText(m_hwnd, IDC_AVIMUX_CURRENT_POS, szTempString);

    SetDlgItemInt(m_hwnd, IDC_AVIMUX_BYTES_WRITTEN, (LONG)(ibCurrent / 1024), FALSE);
  }
}

void CAviMuxProp::UpdateValues()
{
  m_pIl->get_Mode(&m_mode);
  m_pIl->get_Interleaving(&m_rtInterleaving, &m_rtPreroll);
}

HRESULT CAviMuxProp::OnActivate()
{
  UpdatePropPage();
  return S_OK;
}

HRESULT CAviMuxProp::OnDeactivate()
{
  UpdateValues();
  return S_OK;
}


//
// OnDisconnect
//
// Release the interface

HRESULT CAviMuxProp::OnDisconnect()
{

  // Release the interface
  if (m_pIl == NULL)
    return E_UNEXPECTED;

  m_pIl->Release();
  m_pIl = NULL;

  return S_OK;
}

INT_PTR CAviMuxProp::OnReceiveMessage(
  HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  UNREFERENCED_PARAMETER(lParam);
  switch (uMsg) {

    case WM_INITDIALOG:
      break;

    case WM_COMMAND:
      switch (LOWORD(wParam)) {
        case IDC_AVIMUX_RADIO_NONE:
          m_pIl->put_Mode(INTERLEAVE_NONE);
          SetDirty();
          break;

        case IDC_AVIMUX_RADIO_CAPTURE:
          m_pIl->put_Mode(INTERLEAVE_CAPTURE);
          SetDirty();
          break;

        case IDC_AVIMUX_RADIO_NONE_BUFF:
          m_pIl->put_Mode(INTERLEAVE_NONE_BUFFERED);
          SetDirty();
          break;

        case IDC_AVIMUX_RADIO_FULL:
          m_pIl->put_Mode(INTERLEAVE_FULL);
          SetDirty();
          break;

        case IDC_AVIMUX_EDIT_INTERLEAVING:
        {
          int iNotify = HIWORD (wParam);
          if (iNotify == EN_KILLFOCUS)
          {
            BOOL fOK;
            REFERENCE_TIME rtIl = GetDlgItemInt (hwnd, IDC_AVIMUX_EDIT_INTERLEAVING, &fOK, FALSE);
            REFERENCE_TIME currentIl, currentPreroll;
            rtIl *= (UNITS / MILLISECONDS);
            m_pIl->get_Interleaving(&currentIl, &currentPreroll);
            m_pIl->put_Interleaving(&rtIl, &currentPreroll);
            SetDirty();
          }
          break;
        }

        case IDC_AVIMUX_EDIT_PREROLL:
        {
          int iNotify = HIWORD (wParam);
          if (iNotify == EN_KILLFOCUS)
          {
            BOOL fOK;
            REFERENCE_TIME iPreroll = GetDlgItemInt (hwnd, IDC_AVIMUX_EDIT_PREROLL, &fOK, FALSE);
            REFERENCE_TIME currentIl, currentPreroll;
            iPreroll *= (UNITS / MILLISECONDS);
            m_pIl->get_Interleaving(&currentIl, &currentPreroll);
            m_pIl->put_Interleaving(&currentIl, &iPreroll);
            SetDirty();
          }
          break;
        }

      }
      break;

    default:
      return FALSE;

  }
  return TRUE;
}

void
CAviMuxProp::SetDirty()
{
  m_bDirty = TRUE;
  if(m_pPageSite)
    m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}

HRESULT CAviMuxProp::OnApplyChanges()
{
  UpdateValues();
  return S_OK;
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// 2nd property page

CUnknown *WINAPI CAviMuxProp1::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
  return new CAviMuxProp1(lpunk, phr);
}

CAviMuxProp1::CAviMuxProp1(LPUNKNOWN lpunk, HRESULT *phr) :
    CBasePropertyPage(
      NAME("avi mux Property Page1"),
      lpunk,
      IDD_DIALOG_AVIMUX1, IDS_AVIMUXPROPNAME1),
    m_pCfgAvi(0)
{
  // InitCommonControls();
}

HRESULT CAviMuxProp1::OnConnect(IUnknown *pUnknown)
{
  ASSERT(m_pCfgAvi == 0);

  // Ask the filter for it's control interface

  HRESULT hr = pUnknown->QueryInterface(IID_IConfigAviMux, (void **)&m_pCfgAvi);
  if(FAILED(hr))
  {
    DbgBreak("avidest: can't find IID_IConfigAviMux");
    return E_NOINTERFACE;
  }
  ASSERT(m_pCfgAvi);

  UpdateValues();

  return NOERROR;
}

void CAviMuxProp1::UpdatePropPage()
{
  if(m_lMasterStream != -1)
  {
    SetDlgItemInt (m_hwnd, IDC_AVIMUX_EDIT_MASTER_STREAM, m_lMasterStream, TRUE);
    CheckDlgButton (m_hwnd, IDC_AVIMUX_ENABLEFIXUPRATES, BST_CHECKED);
  }
  else
  {
    Edit_Enable(GetDlgItem(m_hwnd, IDC_AVIMUX_EDIT_MASTER_STREAM), FALSE);
    CheckDlgButton (m_hwnd, IDC_AVIMUX_ENABLEFIXUPRATES, BST_UNCHECKED);
  }

  CheckDlgButton(
    m_hwnd, IDC_AVIMUX_CHECK_OLDINDEX,
    m_fOldIndex ? BST_CHECKED : BST_UNCHECKED);
}

void CAviMuxProp1::UpdateValues()
{
  HRESULT hr = m_pCfgAvi->GetMasterStream(&m_lMasterStream);
  ASSERT(hr == S_OK);

  hr = m_pCfgAvi->GetOutputCompatibilityIndex(&m_fOldIndex);
  ASSERT(hr == S_OK);
}

HRESULT CAviMuxProp1::OnActivate()
{
  UpdatePropPage();
  return S_OK;
}

HRESULT CAviMuxProp1::OnDeactivate()
{
    // Remember values for next Activate() call
    UpdateValues();
    return S_OK;
}


//
// OnDisconnect
//
// Release the interface

HRESULT CAviMuxProp1::OnDisconnect()
{

  if(m_pCfgAvi == 0)
    return E_UNEXPECTED;

  m_pCfgAvi->Release();
  m_pCfgAvi = 0;

  return S_OK;
}

INT_PTR CAviMuxProp1::OnReceiveMessage(
  HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  UNREFERENCED_PARAMETER(lParam);
  switch (uMsg) {

    case WM_INITDIALOG:
      break;

    case WM_COMMAND:
      switch (LOWORD(wParam)) {
        case IDC_AVIMUX_EDIT_MASTER_STREAM:
        {
          int iNotify = HIWORD (wParam);
          if (iNotify == EN_KILLFOCUS)
          {
            HWND hButtonWnd = ::GetDlgItem(hwnd, IDC_AVIMUX_ENABLEFIXUPRATES);
            BOOL fMasterStream = ::SendMessage(hButtonWnd, BM_GETCHECK, 0, 0) == BST_CHECKED;
            Edit_Enable(GetDlgItem(hwnd, IDC_AVIMUX_EDIT_MASTER_STREAM), fMasterStream);
            if(fMasterStream)
            {
              BOOL fOK;
              int iStream = GetDlgItemInt (hwnd, IDC_AVIMUX_EDIT_MASTER_STREAM, &fOK, FALSE);
              m_pCfgAvi->SetMasterStream(iStream);
              SetDirty();
            }
          }
        };
        break;

        case IDC_AVIMUX_ENABLEFIXUPRATES:
        {
          HWND hButtonWnd = ::GetDlgItem(hwnd, IDC_AVIMUX_ENABLEFIXUPRATES);
          BOOL fMasterStream = ::SendMessage(hButtonWnd, BM_GETCHECK, 0, 0) == BST_CHECKED;
          Edit_Enable(GetDlgItem(hwnd, IDC_AVIMUX_EDIT_MASTER_STREAM), fMasterStream);
          if(fMasterStream)
          {
            BOOL fOK;
            int iStream = GetDlgItemInt (hwnd, IDC_AVIMUX_EDIT_MASTER_STREAM, &fOK, FALSE);
            HRESULT hr = m_pCfgAvi->SetMasterStream(iStream);
            // !!! what to do on failure.
          }
          else
          {
            HRESULT hr = m_pCfgAvi->SetMasterStream(-1);
            ASSERT(hr == S_OK);
          }

          SetDirty();
        };
        break;

        case IDC_AVIMUX_CHECK_OLDINDEX:
        {
          HWND hButtonWnd = ::GetDlgItem(hwnd, IDC_AVIMUX_CHECK_OLDINDEX);
          BOOL fOldIndex = ::SendMessage(hButtonWnd, BM_GETCHECK, 0, 0) == BST_CHECKED;
          HRESULT hr = m_pCfgAvi->SetOutputCompatibilityIndex(fOldIndex);
          ASSERT(hr == S_OK);
          SetDirty();
        };
        break;
      }
      break;

    default:
      return FALSE;

  }
  return TRUE;
}

void
CAviMuxProp1::SetDirty()
{
  m_bDirty = TRUE;
  if(m_pPageSite)
    m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}

HRESULT CAviMuxProp1::OnApplyChanges()
{
  UpdateValues();
  return S_OK;
}

HRESULT CAviDest::WriteToStream(IStream *pStream)
{
    PersistVal pv;
    pv.dwcb = sizeof(pv);
    HRESULT hr = S_OK;
    if((hr = get_Mode(&pv.mode), SUCCEEDED(hr)) &&
       (hr = get_Interleaving(&pv.rtInterleave, &pv.rtPreroll), SUCCEEDED(hr)) &&
       (hr = GetMasterStream(&pv.iMasterStream), SUCCEEDED(hr)) &&
       (hr = GetOutputCompatibilityIndex(&pv.fOldIndex), SUCCEEDED(hr)))
    {
        hr = pStream->Write(&pv, sizeof(pv), 0);
    }

    return hr;
}

HRESULT CAviDest::ReadFromStream(IStream *pStream)
{
  PersistVal pv;
  HRESULT hr = S_OK;

  hr = pStream->Read(&pv, sizeof(pv), 0);
  if(FAILED(hr))
    return hr;

  if(pv.dwcb != sizeof(pv))
      return VFW_E_INVALID_FILE_VERSION;


  hr = put_Mode(pv.mode);
  if(SUCCEEDED(hr))
  {
    hr = put_Interleaving(&pv.rtInterleave, &pv.rtPreroll);
    if(SUCCEEDED(hr))
    {
      hr = SetMasterStream(pv.iMasterStream);

      if(SUCCEEDED(hr))
      {
        hr = SetOutputCompatibilityIndex(pv.fOldIndex);

      }
    }
  }

   return hr;
}

int CAviDest::SizeMax()
{
    return sizeof(PersistVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avimux\aviutil.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)

//
// container classes, help functions. not necessarily thread-safe
//

#ifndef _util_h
#define _util_h

// ------------------------------------------------------------------------
// conversion from integers to two character hex and back (for AVI
// riff chunk ids)

inline unsigned int WFromHexrg2b(BYTE* rgb)
{
  unsigned high, low;

  low  = rgb[1] <= '9' && rgb[1] >= '0' ? rgb[1] - '0' : rgb[1] - 'A' + 0xa;
  high = rgb[0] <= '9' && rgb[0] >= '0' ? rgb[0] - '0' : rgb[0] - 'A' + 0xa;

  ASSERT((rgb[1] <= '9' && rgb[1] >= '0') || (rgb[1] <= 'F' && rgb[1] >= 'A'));
  ASSERT((rgb[0] <= '9' && rgb[0] >= '0') || (rgb[0] <= 'F' && rgb[0] >= 'A'));

  ASSERT(high <= 0xf && low <= 0xf);

  return low + 16 * high;
}

inline void Hexrg2bFromW(BYTE *rgbDest_, unsigned int wSrc_)
{
  ASSERT(wSrc_ <= 255);
  unsigned high = wSrc_ / 16, low = wSrc_ % 16;
  ASSERT(high <= 0xf && low <= 0xf);

  rgbDest_[1] = low  <= 9 && low  >= 0 ? low  + '0' : low - 0xa  + 'A';
  rgbDest_[0] = high <= 9 && high >= 0 ? high + '0' : high -0xa + 'A';

  ASSERT((rgbDest_[1] <= '9' && rgbDest_[1] >= '0') ||
         (rgbDest_[1] <= 'F' && rgbDest_[1] >= 'A'));
  ASSERT((rgbDest_[0] <= '9' && rgbDest_[0] >= '0') ||
         (rgbDest_[0] <= 'F' && rgbDest_[0] >= 'A'));
}

typedef unsigned __int64 ULONGLONG;

#ifdef DEBUG
#define DEBUG_EX(x) x
#else
#define DEBUG_EX(x)
#endif

#endif // _util_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avimux\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by avidest.rc

// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.
//
#define IDS_AVIMUXPROPNAME              801
#define IDD_DIALOG_AVIMUX               802
#define IDS_AVIMUXPROPNAME1             802
#define IDC_AVIMUX_RADIO_NONE           803
#define IDD_DIALOG_AVIMUX1              803
#define IDC_AVIMUX_RADIO_CAPTURE        804
#define IDC_AVIMUX_RADIO_FULL           805
#define IDC_AVIMUX_LIST1                806
#define IDC_AVIMUX_RADIO_NONE_BUFF      806
#define IDC_AVIMUX_EDIT_INTERLEAVING    807
#define IDC_AVIMUX_EDIT_PREROLL         808
#define IDC_AVIMUX_FRAMES_DROPPED       811
#define IDC_AVIMUX_EDIT_FIXUPRATES      812
#define IDC_AVIMUX_ENABLEFIXUPRATES     813
#define IDC_AVIMUX_EDIT_MASTER_STREAM   814
#define IDC_AVIMUX_CHECK_OLDINDEX       815
#define IDC_AVIMUX_BYTES_WRITTEN        817
#define IDC_AVIMUX_CURRENT_POS          818
#define IDC_AVIMUX_DURATION             819

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        811
#define _APS_NEXT_COMMAND_VALUE         810
#define _APS_NEXT_CONTROL_VALUE         820
#define _APS_NEXT_SYMED_VALUE           812
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avimux\aviwrite.h ===
#pragma warning(disable: 4097 4511 4512 4514 4705)

//
// CAviWrite class declaration. generates an AVI file from a stream of
// Quartz samples
//

#ifndef _AviWrite_h
#define _AviWrite_h

#include "alloc.h"
#include "aviriff.h"

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Aviwrite class and structures
//

// maximum number of streams in an AVI file. comes from the 2 digit
// hexadecimal stream id. and some AVI players don't like stream #s
// greater than 0x7f (signed character?), and we use 0x7f for junk
// index entries. so 00-7E are valid AVI streams.
const unsigned C_MAX_STREAMS = 0x7f;

// maximum outer riff chunks (1Gb each).
const unsigned C_OUTERMOST_RIFF = 512;

struct AviWriteStreamConfig
{
  BOOL fOurAllocator;           // our allocator with a suffix
  CMediaType *pmt;
  ULONG cSamplesExpected;
  char *szStreamName;
};

class CAviWrite
{
  class StreamInfo;
  struct SizeAndPosition
  {
    DWORDLONG pos;
    DWORD size;
  };
  
public:

  CAviWrite(HRESULT *phr);
  ~CAviWrite();

  void GetMemReq(ULONG* pAlignment, ULONG *pcbPrefix, ULONG *pcbSuffix);
  HRESULT Initialize(
    int cPins,
    AviWriteStreamConfig *rgAwsc,
    IMediaPropertyBag *pCopyrightInfo);

  HRESULT Close();

  HRESULT Connect(CSampAllocator *pAlloc, IMemInputPin *pInPin);
  HRESULT Disconnect();

  // returns S_FALSE - stop quietly; error - filter should signal
  // error
  HRESULT Receive(
      int pinNum,
      IMediaSample *pSample,
      const AM_SAMPLE2_PROPERTIES *pSampProp);
    
  HRESULT EndOfStream(int pinNum);
  HRESULT EndOfStream(StreamInfo *psi);

  HRESULT QueryAccept(
    int pinNum,
    const AM_MEDIA_TYPE *pmt
    );
    

  HRESULT put_Mode(InterleavingMode mode);
  HRESULT get_Mode(InterleavingMode *pMode);
  HRESULT put_Interleaving(
      const REFERENCE_TIME *prtInterleave,
      const REFERENCE_TIME *prtAudioPreroll);
    
  HRESULT get_Interleaving(
      REFERENCE_TIME *prtInterleave,
      REFERENCE_TIME *prtAudioPreroll);

  HRESULT SetIgnoreRiff(BOOL fNoRiff);
  HRESULT GetIgnoreRiff(BOOL *pfNoRiff);
  HRESULT SetMasterStream(LONG iStream);
  HRESULT GetMasterStream(LONG *pStream);
  HRESULT SetOutputCompatibilityIndex(BOOL fOldIndex);
  HRESULT GetOutputCompatibilityIndex(BOOL *pfOldIndex);

  static FOURCC MpVideoGuidSubtype_Fourcc(const GUID *pGuidSubtype);

  ULONG GetCFramesDropped() { return m_cDroppedFrames; }

  void GetCurrentBytePos(LONGLONG *pllcbCurrent);
  void GetCurrentTimePos(REFERENCE_TIME *prtCurrent);
  void GetStreamInfo(int PinNum, AM_MEDIA_TYPE ** ppmt);
  HRESULT SetStreamName(WCHAR *wsz);
  HRESULT GetStreamName(WCHAR **pwsz);
    
private:

  HRESULT HandleSubindexOverflow(
      unsigned stream);

  HRESULT IndexSample(
    unsigned stream,
    DWORDLONG dwlPos,
    ULONG ulSize,
    BOOL fSynchPoint);

  HRESULT DoFlushIndex(StreamInfo &rStreamInfo);

  HRESULT ScheduleWrites();
  HRESULT BlockReceive(StreamInfo *pStreamInfo);
  CAMEvent m_evBlockReceive;
    
  void AllocateIdx1(BOOL bStreaming);
  void DbgCheckFilePos();

  HRESULT UpdateSuperIndex(unsigned stream, DWORDLONG dwlPos);
  HRESULT FlushIx(unsigned stream);
  HRESULT NewRiffAvi_();

  POSITION GetNextActiveStream(POSITION pos);
  
  static void SampleCallback(void *pMisc);

  HRESULT IStreamWrite(DWORDLONG dwlFilePos, BYTE *pb, ULONG cb);
  HRESULT IStreamRead(DWORDLONG dwlFilePos, BYTE *pb, ULONG cb);
  HRESULT IleaveWrite(const DWORDLONG &dwlOffset, BYTE *pb, ULONG cb);
  HRESULT FlushILeaveWrite();

  
  HRESULT HandleFormatChange(
    StreamInfo *pStreamInfo,
    const AM_MEDIA_TYPE *pmt);

  // used for writes
  IStream *m_pIStream;
  IMemInputPin *m_pIMemInputPin;
  class CSampAllocator *m_pSampAlloc;

  DWORDLONG m_dwlFilePos;
  DWORDLONG m_dwlCurrentRiffAvi_; // outermost RIFF chunk
  DWORD m_cOutermostRiff;
  ULONG m_cIdx1Entries;
  SizeAndPosition m_rgOutermostRiff[C_OUTERMOST_RIFF];

  // default size of indx chunks and super index chunks
  // ULONG m_cbIndx, m_cbIx;

  // default number of entries allocated for super and sub indexes.
  ULONG m_cEntriesMaxSuperIndex, m_cEntriesMaxSubIndex;

  // size of outer Riff chunks (approx 1Gb)
  ULONG m_cbRiffMax;

  ULONG m_cbBuffer, m_cBuffers;

  // how much empty space the user wanted in the header for future
  // edits
  ULONG m_cbHeaderJunk;

  // output old/compatibility index?
  BOOL m_bOutputIdx1;

  bool m_bSawDeltaFrame; 
 

  // if writing a compatibility index, also make the audio streams
  // start at time=0 for compatibility. we cannot do this if there are
  // any keyframes.
  inline BOOL DoVfwDwStartHack() { return m_bOutputIdx1 && !m_bSawDeltaFrame; }

  // these aren't valid until GetMemReq is called
  ULONG m_cbAlign;
  ULONG m_cbPrefix;
  ULONG m_cbSuffix;

  LONG m_cDroppedFrames;

private:
  unsigned m_cStreams;
  StreamInfo **m_rgpStreamInfo;;
  CGenericList<StreamInfo> m_lActiveStreams;
  POSITION m_posCurrentStream;

  // keeps track of Initialize() and Close() calls
  BOOL m_bInitialized;

  // pointers to structures in the AVI header
  RIFFLIST *m_pAvi_, *m_pHdrl;
  AVIMAINHEADER *m_pAvih;
  RIFFLIST *m_pOdml;
  AVIEXTHEADER *m_pDmlh;
  RIFFLIST *m_pMovi;
  ULONG m_posIdx1;
  ULONG m_cbIdx1;
  ULONG m_posFirstIx;

  // memory to dump to disk for the header
  BYTE *m_rgbHeader;   // allocated w/ new
  ULONG m_cbHeader;

  ULONG m_mpPinStream[C_MAX_STREAMS];

  // on stop->pause
  HRESULT InitializeHeader(IMediaPropertyBag *pProp);
  HRESULT InitializeIndex();
  HRESULT InitializeStrl(ULONG& iPos);
  HRESULT InitializeOptions();
  HRESULT InitializeInterleaving();

  BOOL RegGetDword(HKEY hk, TCHAR *tsz, DWORD *dw);
  long GuessFrameRate() { return 15; }
  

  // on pause->stop
  HRESULT CloseHeader();
  HRESULT CloseMainAviHeader();
  HRESULT CloseStreamHeader();
  HRESULT CloseStreamName();
  HRESULT CloseStreamFormat();
  HRESULT CloseIndex();
  HRESULT CloseOuterRiff();
  HRESULT BuildIdx1();

  // helper functions
  AVISTREAMHEADER *GetStrh(unsigned stream);
  BYTE *GetStrf(unsigned stream);
  AVIMETAINDEX *GetIndx(unsigned stream);
  void SetFrameRateAndScale(AVISTREAMHEADER *pStrh, StreamInfo *pSi, double dScaleMasterStream);

  HRESULT InitIx(unsigned stream);
  ULONG GetIndexSize(AVIMETAINDEX *pIndex);
  AVISTDINDEX *GetCurrentIx(unsigned stream);

  void AddJunk(DWORD& rdwSize, DWORD dwAlign, BYTE *pb);
  void AddJunkOtherAllocator(
    DWORD& rdwSize,             // size, updated
    DWORD dwAlign,
    BYTE *pb,
    IMediaSample *pSample,
    BYTE **ppJunkSector);       // additional junk sector to write or null
  
  ULONG GetCbJunk(DWORD dwSize, DWORD dwAlign);

  // space for junk sectors partitioned JU.NKSIZE, JUNK.SIZE, JUNKSI.ZE
  BYTE *m_rgpbJunkSector[3];
  BYTE *m_rgbJunkSectors;

  BYTE *m_rgbIleave;
  ULONG m_ibIleave;
  DWORDLONG m_dwlIleaveOffset;
  
  void SetList(void *pList, FOURCC ckid, DWORD dwSize, FOURCC listid);
  void SetChunk(void *pChunk, FOURCC ckid, DWORD dwSize);
  
  void Cleanup();

#ifdef DEBUG
  // performance counters
  DWORD m_dwTimeInit, m_dwTimeInited, m_dwTimeStopStreaming;
  DWORD m_dwTimeFirstSample, m_dwTimeClose, m_dwTimeClosed;
#endif /* DEBUG */

private:
  IMemAllocator *m_pAllocator;
  CCritSec m_cs;

  InterleavingMode m_IlMode;
  REFERENCE_TIME m_rtAudioPreroll;
  REFERENCE_TIME m_rtInterleaving;

  // don't count ticks but look at time stamps to interleave
  BOOL m_fInterleaveByTime;

  // adjust rates of all streams for drift from master stream. -1
  // means disabled.
  LONG m_lMasterStream;

#ifdef PERF
  int m_idPerfDrop;
#endif // PERF


private:

  // information kept per active stream
  class StreamInfo
  {
  public:
    ULONG m_pin;                /* filter pin mapped to this stream */
    ULONG m_stream;
    ULONG m_posStrl;            // start position of strl chunk
    ULONG m_posIndx;            // location of super index
    ULONG m_posFirstSubIndex;
    ULONG m_posStrf;
    ULONG m_posStrn;
    ULONG m_cbStrf;
    CHAR *m_szStrn;
    CMediaType m_mt;
    FOURCC m_moviDataCkid;      // eg 00db
    FOURCC m_moviDataCkidCompressed; // eg 00dc

    ULONG m_cSamples;           // number of times Receive was called
    DWORDLONG m_dwlcBytes;      // total number of bytes received

    // for interleaved audio: # bytes of stream written when a new sub
    // index was started
    DWORDLONG m_dwlcBytesLastSuperIndex;

    // byte offset of current SubIndex chunk for tightly interleaved
    // files.
    DWORDLONG m_dwlOffsetCurrentSubIndex;
    ULONG m_cbLargestChunk;

    CRefTime m_refTimeStart;    // start of first sample stream sees
    CRefTime m_refTimeEnd;      // end of last sample stream sees
    CRefTime m_mtEnd;           // last media time recorded, -1 if unset
    CRefTime m_mtStart;         // first media time recorded, -1 if unset

    IMediaSample *m_pSampleStdIx; // current standard index (IMediaSample)
    ULONG m_cIx;

    // index sizes for this stream. these must be less than the
    // defaults due to memory allocated
    ULONG m_cEntriesSuperIndex, m_cEntriesSubIndex;

    LONG m_iCurrentTick;        // next tick to write
    LONG m_cTicksRemaining;     // ticks left to write in this chunk

    LONG m_cTicksPerChunk;      // used by stream if it's the leading stream
    ULONG m_cTicksExpected;     // adjust the index sizes accordingly
    POSITION m_posActiveStream; // pos in CAviWrite::m_lActiveStreams

    BOOL m_fOurAllocator;       // our allocator with suffix
    BOOL m_fEosSeen;

    REFERENCE_TIME m_rtPreroll;

#ifdef PERF
    int m_idPerfReceive;
#endif // PERF

    // used when interleaving.
    CGenericList<IMediaSample> m_lIncoming;
    void EmptyQueue();

    CAviWrite *m_pAviWrite;

    StreamInfo(
      UINT iStream,
      UINT iPin,
      AviWriteStreamConfig *pAwsc,
      CAviWrite *pAviWrite,
      HRESULT *phr);
    ~StreamInfo();              // not virtual for now

    // write given sample
    virtual HRESULT WriteSample(IMediaSample *pSample);

    // pull sample off queue, write it
    virtual HRESULT WriteSample();
    
    virtual HRESULT EndOfStream() { return S_OK; }

    virtual void GetCbWritten(DWORDLONG *pdwlcb) { *pdwlcb = m_dwlcBytes; }

    // good place to record dropped frames.
    virtual HRESULT NotifyNewSample(
      IMediaSample *pSample,
      ULONG *pcTicks) = 0;

    // unblock other streams that can write
    HRESULT NotifyWrote(long cTicks);

    virtual REFERENCE_TIME ConvertTickToTime(ULONG cTicks) = 0;
    virtual ULONG ConvertTimeToTick(REFERENCE_TIME rt) = 0;

    // samples between m_refTimeStart and m_refTimeEnd
    virtual ULONG CountSamples() = 0;

    // S_FALSE means skip the sample. error means signal an error.
    virtual HRESULT AcceptRejectSample(IMediaSample *pSample) { return S_OK; }

    // compute what size super and sub indexes we will use
    void ComputeAndSetIndexSize();

    // is this stream trying to write out exactly sized index chunks
    BOOL PrecomputedIndexSizes();

    // If in DoVfwDwStartHack() mode, this number tells us how many
    // video frames need to be deleted up front. Valid after
    // ::CloseStreamHeader only.
    ULONG m_cInitialFramesToDelete;

  protected:

    // accounting for processed samples (stream length, # of Receives)
    HRESULT NewSampleRecvd(IMediaSample *pSample);
  };

  class CFrameBaseStream : public StreamInfo
  {
  public:
    CFrameBaseStream(
        UINT iStream,
        UINT iPin,
        AviWriteStreamConfig *pAwsc,
        CAviWrite *pAviWrite,
        HRESULT *phr);
    
    virtual REFERENCE_TIME ConvertTickToTime(ULONG cTicks);
    virtual ULONG ConvertTimeToTick(REFERENCE_TIME rt);

    ULONG GetTicksWritten(ULONG cbSample);

    HRESULT NotifyNewSample(
      IMediaSample *pSample,
      ULONG *pcTicks);

    ULONG CountSamples() { return m_cSamples; }
    
  protected:
    BOOL m_bDroppedFrames;

    // used only if avgTimePerFrame is not set in the media type
    REFERENCE_TIME m_rtDurationFirstFrame;
  };

  class CVideoStream : public CFrameBaseStream
  {
  public:
    CVideoStream(
        UINT iStream,
        UINT iPin,
        AviWriteStreamConfig *pAwsc,
        CAviWrite *pAviWrite,
        HRESULT *phr);
    REFERENCE_TIME ConvertTickToTime(ULONG cTicks);
    ULONG ConvertTimeToTick(REFERENCE_TIME rt);
    virtual HRESULT AcceptRejectSample(IMediaSample *pSample);
  };

  class CAudioStream : public StreamInfo
  {
  protected:
    ULONG ConvertTickToBytes(ULONG cTicks);
    ULONG ConvertBytesToTicks(ULONG cBytes);

    ULONG GetTicksWritten(ULONG cbSample);

    HRESULT NotifyNewSample(
      IMediaSample *pSample,
      ULONG *pcTicks);

    // set when the sample length isn't a multiple of nBlockAlign
    // because we don't handle that properly unless it's at the end.
    bool m_bAudioAlignmentError;

  public:
    CAudioStream(
        UINT iStream,
        UINT iPin,
        AviWriteStreamConfig *pAwsc,
        CAviWrite *pAviWrite,
        HRESULT *phr);

    LONG GetTicksInSample(DWORDLONG cbSample);
    REFERENCE_TIME ConvertTickToTime(ULONG cTicks);
    ULONG ConvertTimeToTick(REFERENCE_TIME rt);
    ULONG CountSamples();
  };

  // with interleaving code
  class CAudioStreamI : public CAudioStream
  {
    BOOL m_fUnfinishedChunk;    // start a new chunk with new sample?
    DWORDLONG m_dwlOffsetThisChunk; // byte offset in file of this chunk
    LONG m_cbThisChunk;         // bytes written to disk for this chunk
    LONG m_cbThisSample;        // byte written out from current sample

    // bytes expected for this chunk. we write out a riff chunk with
    // the .cb field being the number of bytes we expect. if we get an
    // EOS before that we need to go back and fix up that number
    LONG m_cbInRiffChunk;
    HRESULT FlushChunk();

    DWORDLONG m_dwlcbWritten; // total number of bytes written

#ifdef DEBUG
    // paranoia: save disk offset across Receive calls
    DWORDLONG m_dwlOffsetRecv;
#endif
    
  public:
    CAudioStreamI(
        UINT iStream,
        UINT iPin,
        AviWriteStreamConfig *pAwsc,
        CAviWrite *pAviWrite,
        HRESULT *phr);
    HRESULT WriteSample(IMediaSample *pSample);
    HRESULT WriteSample();    
    HRESULT EndOfStream();

    void GetCbWritten(DWORDLONG *pdwlcb);
  };

  // code to propagate index forward
  class CWalkIndex
  {
  public:
    CWalkIndex(CAviWrite *pAviWrite, StreamInfo *pSi);
    HRESULT Init();
    ~CWalkIndex();

    HRESULT Peek(DWORDLONG *dwlPos, DWORD *dwSize, BOOL *pfSyncPoint);
    HRESULT Advance();
    HRESULT Close();

  private:
    HRESULT ReadStdIndex();

    StreamInfo *m_pSi;

    AVISUPERINDEX *m_pSuperIndex;
    AVISTDINDEX *m_pStdIndex;

    CAviWrite *m_pAviWrite;

    ULONG m_offsetSuper;
    ULONG m_offsetStd;
    DWORDLONG m_dwlFilePosLastStd;
  };

  friend class CWalkIndex;
  friend class CFrameBaseStream;
  friend class StreamInfo;
  friend class CAudioStream;
  friend class CAudioStreamI;
};

class CCopiedSample :
    public CMediaSample
{
public:
    CCopiedSample(
        const AM_SAMPLE2_PROPERTIES *pprop,
        REFERENCE_TIME *pmtStart, REFERENCE_TIME *pmtEnd,
        HRESULT *phr);
    ~CCopiedSample();

    STDMETHODIMP_(ULONG) Release();
};


#endif // _AviWrite_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\avi\avimux\aviwrite.cpp ===
#pragma warning(disable: 4097 4511 4512 4514 4705)

#include <streams.h>

#include <limits.h>
#include "AviWrite.h"
#include "alloc.h"

#ifdef FILTER_DLL
#include <initguid.h>
#endif

#ifdef DEBUG
#define DEBUG_EX(x) x
#else
#define DEBUG_EX(x)
#endif

// AVI prefix. each frame is preceded by a fourcc stream id and a
// DWORD size
static const unsigned CB_AVI_PREFIX = sizeof(RIFFCHUNK);

// the fourcc JUNK and the size (padding used to align the next chunk
// on a sector boundary).
static const unsigned CB_AVI_SUFFIX = 2 * sizeof(FOURCC);

// default size of super and sub indexes. sub index is rounded up to
// sector alignment for capture files. both are rounded down for
// interleaved files.
static const ULONG C_ENTRIES_SUPERINDEX = 2000;// 16 bytes each
static const ULONG C_ENTRIES_SUBINDEX = 4000; // 8 bytes each

// create a new RIFF chunk after this many bytes (+ a sample chunk and
// an index chunk). used if registry entry is not there.
static const ULONG CB_RIFF_MAX = 0x3fffffff;

// space to allow for sample chunk and index chunk above.
static const ULONG CB_NEW_RIFF_PADDING = 1024 * 1024 * 4;

static const ULONG CB_HEADER_JUNK = 0;

static const ULONG CB_BUFFER = 512 * 1024;
static const ULONG C_BUFFERS = 3;

static const BOOL g_B_OUTPUT_IDX1 = TRUE;
static const BOOL g_B_DROPPED_FRAMES = TRUE;

static const ULONG CB_SUBINDEX_OVERFLOW = MAXDWORD;

#define CB_ILEAVE_BUFFER (64 * 1024)

static inline unsigned int WFromHexrg2b(BYTE* rgb)
{
  unsigned high, low;

  low  = rgb[1] <= '9' && rgb[1] >= '0' ? rgb[1] - '0' : rgb[1] - 'A' + 0xa;
  high = rgb[0] <= '9' && rgb[0] >= '0' ? rgb[0] - '0' : rgb[0] - 'A' + 0xa;

  ASSERT((rgb[1] <= '9' && rgb[1] >= '0') || (rgb[1] <= 'F' && rgb[1] >= 'A'));
  ASSERT((rgb[0] <= '9' && rgb[0] >= '0') || (rgb[0] <= 'F' && rgb[0] >= 'A'));

  ASSERT(high <= 0xf && low <= 0xf);

  return low + 16 * high;
}

static inline void Hexrg2bFromW(BYTE *rgbDest_, unsigned int wSrc_)
{
  ASSERT(wSrc_ <= 255);
  unsigned high = wSrc_ / 16, low = wSrc_ % 16;
  ASSERT(high <= 0xf && low <= 0xf);

  rgbDest_[1] = (BYTE)(low  <= 9 ? low  + '0' : low - 0xa  + 'A');
  rgbDest_[0] = (BYTE)(high <= 9 ? high + '0' : high -0xa + 'A');

  ASSERT((rgbDest_[1] <= '9' && rgbDest_[1] >= '0') ||
         (rgbDest_[1] <= 'F' && rgbDest_[1] >= 'A'));
  ASSERT((rgbDest_[0] <= '9' && rgbDest_[0] >= '0') ||
         (rgbDest_[0] <= 'F' && rgbDest_[0] >= 'A'));
}

static inline DWORD AlignUp(DWORD dw, DWORD dwAlign) {
  // align up: round up to next boundary
  return (dw + (dwAlign -1)) & ~(dwAlign -1);
};

// return # bytes needed to hold a super index with cEntries entries
static inline const ULONG cbSuperIndex(ULONG cEntries)
{
  const cbIndex = FIELD_OFFSET(AVISUPERINDEX, aIndex);
  return cbIndex + sizeof(AVISUPERINDEX::_avisuperindex_entry) * cEntries;
}

// return # bytes needed to hold a sub-index with cEntries
// entries. caller may want to align up
static inline const ULONG cbSubIndex(ULONG cEntries)
{
  const cbIndex = FIELD_OFFSET(AVISTDINDEX, aIndex);
  return cbIndex + sizeof(_avistdindex_entry) * cEntries;
}

// return # of entries that can be put in sub index with size = cb
// bytes
static const ULONG cEntriesSubIndex(ULONG cb)
{
  const cbIndex = FIELD_OFFSET(AVISTDINDEX, aIndex);
  cb -= cbIndex;
  return cb / sizeof(_avistdindex_entry);
}

static const ULONG cEntriesSuperIndex(ULONG cb)
{
  const cbIndex = FIELD_OFFSET(AVISUPERINDEX, aIndex);
  cb -= cbIndex;
  return cb / sizeof(AVISUPERINDEX::_avisuperindex_entry);
}

// ------------------------------------------------------------------------
// constructor

CAviWrite::CAviWrite(HRESULT *phr) :
    m_lActiveStreams(NAME("aviwrite.cpp active stream list")),
    m_pIStream(0),
    m_IlMode(INTERLEAVE_NONE),
    m_rtAudioPreroll(0),
    m_rtInterleaving(UNITS),
    m_pIMemInputPin(0),
    m_pSampAlloc(0),
    m_cDroppedFrames(0),
    m_rgbIleave(0),
    m_lMasterStream(-1)
{
  DbgLog((LOG_TRACE, 10, TEXT("CAviWrite::CAviWrite")));
  // these are saved across Initialize() Close() pairs
  m_cbAlign = 0;
  m_cbPrefix = m_cbSuffix = 0;

  // pointers to allocated memory
  m_pAllocator = 0;
  m_rgbHeader = 0;
  m_rgpStreamInfo = 0;
  m_rgbJunkSectors = 0;
  m_cStreams = 0;

#ifdef PERF
  m_idPerfDrop = Msr_Register("aviwrite drop frame written");
#endif // PERF

  // the rest
  Cleanup();

  if(FAILED(*phr))
    return;

  *phr = InitializeOptions();
  if(FAILED(*phr))
    return;

}

// ------------------------------------------------------------------------
// cleanup values that should not be saved across a stop -> pause/run
// -> stop transition.

void CAviWrite::Cleanup()
{
  DbgLog((LOG_TRACE, 10, TEXT("CAviWrite::Cleanup")));
  m_dwlFilePos = 0;
  m_dwlCurrentRiffAvi_ = 0;
  m_cOutermostRiff = 0;
  m_cIdx1Entries = 0;
  ASSERT(m_lActiveStreams.GetCount() == 0);
  m_bInitialized = FALSE;

  m_pAvi_ = m_pHdrl = 0;
  m_pAvih = 0;
  m_pOdml = 0;
  m_pDmlh = 0;
  m_pMovi = 0;
  m_posIdx1 = 0;
  m_cbIdx1 = 0;
  m_posFirstIx = 0;
  m_bSawDeltaFrame = false;

  delete[] m_rgbJunkSectors;
  m_rgbJunkSectors = 0;

  delete[] m_rgbIleave;
  m_rgbIleave = 0;

  delete[] m_rgbHeader;
  m_rgbHeader = 0;
  for(UINT i = 0; i < m_cStreams; i++)
    delete m_rgpStreamInfo[i];
  m_cStreams = 0;
  delete[] m_rgpStreamInfo;
  m_rgpStreamInfo = 0;

  // this is the allocator for index chunks
  if(m_pAllocator != 0)
  {
    m_pAllocator->Decommit();
    m_pAllocator->Release();
    m_pAllocator = 0;
  }
}

CAviWrite::~CAviWrite()
{
  DbgLog((LOG_TRACE, 10, TEXT("CAviWrite::~CAviWrite")));
  Cleanup();

  ASSERT(m_pIStream == 0);
  ASSERT(m_pIMemInputPin == 0);
  if(m_pSampAlloc)
    m_pSampAlloc->Release();
}


// ------------------------------------------------------------------------
// initialize (on stop->pause transition). creates the file, writes
// out space for the AVI header, prepares to stream. SetFilename needs
// to have been called

HRESULT CAviWrite::Initialize(
  int cPins,
  AviWriteStreamConfig *rgAwsc,
  IMediaPropertyBag *pPropBag)
{
  HRESULT hr;

  Cleanup();

  DEBUG_EX(m_dwTimeInit = GetTickCount());
  ASSERT(m_cStreams == 0 &&
         m_rgpStreamInfo == 0 &&
         m_rgbHeader == 0 &&
         !m_bInitialized);

  if(cPins > C_MAX_STREAMS)
    return E_INVALIDARG;

  m_rgpStreamInfo = new StreamInfo*[cPins];
  if(m_rgpStreamInfo == 0)
    return E_OUTOFMEMORY;

  m_cDroppedFrames = 0;
  ASSERT(m_cStreams == 0);

  m_cEntriesMaxSuperIndex = cEntriesSuperIndex(
      AlignUp(cbSuperIndex(C_ENTRIES_SUPERINDEX), m_cbAlign));

  m_cEntriesMaxSubIndex = cEntriesSubIndex(
      AlignUp(cbSubIndex(C_ENTRIES_SUBINDEX), m_cbAlign));

  ASSERT(cbSubIndex(m_cEntriesMaxSubIndex) % m_cbAlign == 0);
  ASSERT(cbSuperIndex(m_cEntriesMaxSuperIndex) % m_cbAlign == 0);


  // create the pin -> stream mapping
  for(int i = 0; i < cPins; i++)
  {
    hr = S_OK;
    if(rgAwsc[i].pmt != 0)
    {
      m_mpPinStream[i] = m_cStreams;
      if(rgAwsc[i].pmt->majortype == MEDIATYPE_Audio &&
         m_IlMode != INTERLEAVE_FULL)
      {
        m_rgpStreamInfo[m_cStreams] =
          new CAudioStream(m_cStreams, i, &rgAwsc[i], this, &hr);
        // error checked below
      }
      else if(rgAwsc[i].pmt->majortype == MEDIATYPE_Audio &&
              m_IlMode == INTERLEAVE_FULL)
      {
        m_rgpStreamInfo[m_cStreams] =
          new CAudioStreamI(m_cStreams, i, &rgAwsc[i], this, &hr);
        // error checked below
      }
      else if(rgAwsc[i].pmt->majortype == MEDIATYPE_Video &&
              rgAwsc[i].pmt->formattype == FORMAT_VideoInfo)
      {
        m_rgpStreamInfo[m_cStreams] =
          new CVideoStream(m_cStreams, i, &rgAwsc[i], this, &hr);
        // error checked below
      }
      else
      {
        m_rgpStreamInfo[m_cStreams] =
          new CFrameBaseStream(m_cStreams, i, &rgAwsc[i], this, &hr);
        // error checked below
      }

      if(m_rgpStreamInfo[m_cStreams] == 0)
      {
        Cleanup();
        return E_OUTOFMEMORY;
      }
      if(FAILED(hr))
      {
        delete m_rgpStreamInfo[m_cStreams];
        m_rgpStreamInfo[m_cStreams] = 0;

        Cleanup();
        return hr;
      }

      m_cStreams++;
    }
  }

  // note that m_bInitialized is false if there are zero streams
  if(m_cStreams == 0)
    return S_OK;

  if((ULONG)m_lMasterStream >= m_cStreams && m_lMasterStream != -1)
  {
    DbgLog((LOG_ERROR, 1, TEXT("avimux: invalid master stream")));
    Cleanup();
    return E_INVALIDARG;
  }

  for(UINT iStream = 0; iStream < m_cStreams; iStream++)
  {
    StreamInfo *pSi = m_rgpStreamInfo[iStream];
    pSi->ComputeAndSetIndexSize();
  }


  if(hr = InitializeHeader(pPropBag), FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviWrite::Initialize:: InitializeHeader failed.")));
    Cleanup();
    return hr;
  }

  if(hr = InitializeIndex(), FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviWrite::Initialize:: InitializeIndex failed.")));
    Cleanup();
    return hr;
  }

  if(hr = InitializeInterleaving(), FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviWrite::Initialize:: Interleaving failed.")));
    Cleanup();
    return hr;
  }

  //
  // setup junk chunks. if a sample delivered ends between 2 and 6
  // bytes before the end of the allocated buffer, we need to write
  // another sample with bits of the junk chunk.
  //
  if(m_cbAlign > 2)
  {
    // !!! don't allocator memory if all streams use our allocator
    delete[] m_rgbJunkSectors;
    m_rgbJunkSectors = new BYTE[m_cbAlign * 4];
    if(m_rgbJunkSectors == 0)
    {
      Cleanup();
      return E_OUTOFMEMORY;
    }
    ZeroMemory(m_rgbJunkSectors, m_cbAlign * 4);

    m_rgpbJunkSector[0] =
      (BYTE*)((DWORD_PTR) (m_rgbJunkSectors + m_cbAlign - 1) & ~((DWORD_PTR)m_cbAlign - 1));

    m_rgpbJunkSector[0][0] = 'N';
    m_rgpbJunkSector[0][1] = 'K';
    *(UNALIGNED DWORD *)&(m_rgpbJunkSector[0][2]) = m_cbAlign - 2 - sizeof(DWORD);

    m_rgpbJunkSector[1] = m_rgpbJunkSector[0] + m_cbAlign;
    *(DWORD *)m_rgpbJunkSector[1] = m_cbAlign - sizeof(DWORD);

    m_rgpbJunkSector[2] = m_rgpbJunkSector[1] + m_cbAlign;
    *(WORD *)m_rgpbJunkSector[2] = (WORD)(((m_cbAlign - 2) >> 16) & 0xffff);
  }

  if(m_IlMode == INTERLEAVE_FULL)
  {
      ASSERT(m_cbAlign == 1);

      m_rgbIleave = new BYTE[CB_ILEAVE_BUFFER];
      if(m_rgbIleave == 0)
      {
          Cleanup();
          return E_OUTOFMEMORY;
      }
      m_ibIleave = 0;
      m_dwlIleaveOffset = 0;

      ASSERT(m_pIStream == 0);

      hr = m_pIMemInputPin->QueryInterface(
          IID_IStream, (void **)&m_pIStream);
      if(FAILED(hr)) {
          Cleanup();
          return hr;
      }
  }

  DEBUG_EX(m_dwTimeInited = GetTickCount());

  m_bInitialized = TRUE;
  return S_OK;
}

HRESULT CAviWrite::Connect(CSampAllocator *pAlloc, IMemInputPin *pInPin)
{
  m_pSampAlloc = pAlloc;
  pAlloc->AddRef();

  m_pIMemInputPin = pInPin;
  m_pIMemInputPin->AddRef();

  ASSERT(m_pIStream == 0);

  return S_OK;
}

HRESULT CAviWrite::Disconnect()
{
  if(m_pIStream)
    m_pIStream->Release();
  m_pIStream = 0;
  if(m_pIMemInputPin)
    m_pIMemInputPin->Release();
  m_pIMemInputPin = 0;

  if(m_pSampAlloc)
    m_pSampAlloc->Release();
  m_pSampAlloc = 0;

  return S_OK;
}

// ------------------------------------------------------------------------
// finish writing the file, update the index, write the header, close
// the file and reset so that Initialize can be called again

HRESULT CAviWrite::Close()
{
  HRESULT hrIStream = S_OK;
  HRESULT hr = S_OK;
  if(m_pIStream == 0)
  {
    hrIStream = m_pIMemInputPin->QueryInterface(IID_IStream, (void **)&m_pIStream);
    if(FAILED(hrIStream))
    {
      DbgLog((LOG_ERROR, 1, ("aviwrite: couldn't get istream. !!! unhandled")));
      // do some small amount of clean up then return
    }
  }

  DEBUG_EX(m_dwTimeClose = GetTickCount());

  CAutoLock lock(&m_cs);

  for(UINT iStream = 0; iStream < m_cStreams; iStream++)
  {
    StreamInfo *pSi = m_rgpStreamInfo[iStream];
    pSi->EmptyQueue();

    if(!pSi->m_fEosSeen)
    {
       // will not block because we just emptied the queue
       hr = EndOfStream(pSi);
    }
  }

  if(FAILED(hrIStream))
    return hrIStream;
  if(FAILED(hr)) {
    return hr;
  }

  if(m_bInitialized)
  {
    DEBUG_EX(m_dwTimeStopStreaming = GetTickCount());

    hr = CloseHeader();
    if(FAILED(hr))
      DbgLog(( LOG_ERROR, 2, TEXT("CAviWrite::Close: CloseHeader failed.")));

    HRESULT hrTmp = IStreamWrite(0, m_rgbHeader, m_posFirstIx);
    if(FAILED(hrTmp))
      DbgLog(( LOG_ERROR, 2, TEXT("CAviWrite::Close: Write failed.")));

    hr = FAILED(hr) ? hr : hrTmp;

    // null terminate file if we didn't truncate the data
    RIFFCHUNK rc;
    if(SUCCEEDED(hr))
    {
      // test for someone elses data after our data
      hr = IStreamRead(m_dwlFilePos, (BYTE*) &rc, 1);
      if(SUCCEEDED(hr))
      {
        rc.fcc = 0;
        rc.cb = 0;
        hr = IStreamWrite(
          m_dwlFilePos,
          (BYTE*)&rc,
          sizeof(RIFFCHUNK));
      }
      else
      {
        hr = S_OK;
      }
    }
  }

  DEBUG_EX(m_dwTimeClosed = GetTickCount());

#ifdef DEBUG
  if(m_dwTimeStopStreaming != m_dwTimeFirstSample)
  {
    DbgLog((LOG_TRACE, 2, TEXT("m_dwTimeInit:          %9d"),
            m_dwTimeInit - m_dwTimeInit));

    DbgLog((LOG_TRACE, 2, TEXT("m_dwTimeInited:        %9d"),
            m_dwTimeInited - m_dwTimeInit));

    DbgLog((LOG_TRACE, 2, TEXT("m_dwTimeFirstSample:   %9d"),
            m_dwTimeFirstSample - m_dwTimeInit));

    DbgLog((LOG_TRACE, 2, TEXT("m_dwTimeClose:         %9d"),
            m_dwTimeClose - m_dwTimeInit));

    DbgLog((LOG_TRACE, 2, TEXT("m_dwTimeStopStreaming: %9d"),
            m_dwTimeStopStreaming - m_dwTimeInit));

    DbgLog((LOG_TRACE, 2, TEXT("m_dwTimeClosed:        %9d"),
            m_dwTimeClosed - m_dwTimeInit));

    DbgLog((LOG_TRACE, 2, TEXT("mb streamed:           %9d"),
            (LONG)((m_dwlFilePos - m_posFirstIx) / (1024 * 1024) )));

    DbgLog((LOG_TRACE, 2, TEXT("~rate, k/s:            %9d"), (long)
            ((m_dwlFilePos - m_posFirstIx) /
             (m_dwTimeStopStreaming - m_dwTimeFirstSample))));
  }

#endif // DEBUG

  ULARGE_INTEGER uli;
  uli.QuadPart = 0;
  if(hr == HRESULT_FROM_WIN32(ERROR_EMPTY)) {
      m_pIStream->SetSize(uli);
      hr = S_OK;
  }

  // release so that the file can be closed.
  m_pIStream->Release();
  m_pIStream = 0;

  // hold on to IMemInputPin until the pin is disconnected
  ASSERT(m_pIMemInputPin);
  // !!! send EOS

  m_bInitialized = FALSE;
  return hr;
}

HRESULT CAviWrite::IStreamWrite(DWORDLONG dwlFilePos, BYTE *pb, ULONG cb)
{
  HRESULT hr = S_OK;

  if(m_IlMode == INTERLEAVE_FULL && m_ibIleave != 0) {
      hr = FlushILeaveWrite();
  }

  LARGE_INTEGER offset;
  offset.QuadPart = dwlFilePos;
  ASSERT(CritCheckIn(&m_cs));
  if(SUCCEEDED(hr)) {
      hr = m_pIStream->Seek(offset, STREAM_SEEK_SET, 0);
  }
  if(hr == S_OK) {
    hr = m_pIStream->Write(pb, cb, 0);
  }
  return hr;
}

HRESULT CAviWrite::IStreamRead(DWORDLONG dwlFilePos, BYTE *pb, ULONG cb)
{
    HRESULT hr = S_OK;
    if(m_IlMode == INTERLEAVE_FULL && m_ibIleave != 0) {
        hr = FlushILeaveWrite();
    }

    LARGE_INTEGER offset;
    offset.QuadPart = dwlFilePos;
    ASSERT(CritCheckIn(&m_cs));
    if(SUCCEEDED(hr )) {
        hr = m_pIStream->Seek(offset, STREAM_SEEK_SET, 0);
    }
    if(hr == S_OK) {
        hr = m_pIStream->Read(pb, cb, 0);
    }

    return hr;
}

HRESULT CAviWrite::HandleFormatChange(
  StreamInfo *pStreamInfo,
  const AM_MEDIA_TYPE *pmt)
{
  // CBaseInputPin::Receive only calls CheckMediaType, so it doesn't
  // check the additional constraints put on on-the-fly format changes
  // (handled through QueryAccept).
  HRESULT hr = QueryAccept(pStreamInfo->m_pin, pmt);

  // upstream filter should have checked
  ASSERT(hr == S_OK);

  if(hr == S_OK)
  {
    pStreamInfo->m_mt = *pmt;
    ASSERT(pmt->pbFormat);      // from QueryAccept;
    ASSERT(((RIFFCHUNK *)(m_rgbHeader + pStreamInfo->m_posStrf))->cb ==
           pmt->cbFormat);      // from QueryAccept;
    CopyMemory(
      m_rgbHeader + pStreamInfo->m_posStrf + sizeof(RIFFCHUNK),
      pmt->pbFormat,
      pmt->cbFormat);
  }

  return hr;
}


// ------------------------------------------------------------------------
// pass our memory requirements up to the caller

void CAviWrite::GetMemReq(ULONG *pAlignment, ULONG *pcbPrefix, ULONG *pcbSuffix)
{
  // get our minimum requirements from file object
  ALLOCATOR_PROPERTIES memReq;
  HRESULT hr = m_pSampAlloc->GetProperties(&memReq);
  ASSERT(hr == S_OK);
  *pAlignment = memReq.cbAlign;
  *pcbPrefix = 0;
  *pcbSuffix = 0;

  DbgLog((LOG_TRACE, 10,
          TEXT("CAviWrite::GetMemReq: got alignment of %d"), memReq.cbAlign));

  if(m_IlMode != INTERLEAVE_FULL)
  {
      // our requirements: add space for RIFF chunk header; Quartz
      // allocators support prefixes
      *pcbPrefix += CB_AVI_PREFIX;

      // this is the wrong place to do this
      //   // need things in multiples of two bytes (RIFF requirement)
      //   if(*pAlignment < sizeof(WORD))
      //     *pAlignment = sizeof(WORD);

      // if using our allocator, we can reserve a suffix for a JUNK chunk
      // needed when we add space to align writes
      *pcbSuffix = CB_AVI_SUFFIX;
  }
  else
  {
      ASSERT(memReq.cbAlign == 1);
  }

  // save our requirements
  m_cbAlign = *pAlignment;
  m_cbPrefix = *pcbPrefix;
  m_cbSuffix = *pcbSuffix;
}

inline void CAviWrite::DbgCheckFilePos()
{
#ifdef DEBUG
//   DWORDLONG ibFileActual;
//   HRESULT hr = (m_pFile->StreamingGetFilePointer(&ibFileActua
//   ASSERT(SUCCEEDED(hr));
//   ASSERT(ibFileActual == m_dwlFilePos);
#endif // DEBUG
}



// ------------------------------------------------------------------------
// process incoming samples.
//

HRESULT CAviWrite::Receive(
    int pinNum,
    IMediaSample *pSample,
    const AM_SAMPLE2_PROPERTIES *pSampProp)
{
  HRESULT hr;
  ASSERT(pinNum < C_MAX_STREAMS);
  ASSERT(m_cStreams != 0);
  ASSERT(m_lActiveStreams.GetCount() != 0);

  REFERENCE_TIME rtStart, rtEnd;
  hr = pSample->GetTime(&rtStart, &rtEnd);
  if(FAILED(hr))
  {
      // signal error if time stamps not set. ks devices unfortunately
      // send zero byte samples with no time stamps, so don't signal
      // errors for those.
      return pSampProp->lActual == 0 ? S_OK : hr;
  }

#if  defined(DEBUG) || defined(PERF)
  REFERENCE_TIME mtStart = 0, mtEnd = 0;
  pSample->GetMediaTime(&mtStart, &mtEnd);

  DbgLog((LOG_TIMING, 2, TEXT("avi mux: pin %d - time : %d-%d, mttime %d-%d"),
          pinNum,
          (long)(rtStart / (UNITS / MILLISECONDS)),
          (long)(rtEnd / (UNITS / MILLISECONDS)),
          (long)(mtStart),
          (long)(mtEnd),
          pinNum));

#endif

  // upstream filter will send us negative time stamps if it prerolls
  // more quickly than allowed
  if(rtEnd < 0)
    return S_OK;

  StreamInfo *pStreamInfo = m_rgpStreamInfo[m_mpPinStream[pinNum]];
  //MSR_START(pStreamInfo->m_idPerfReceive);
  MSR_INTEGER(pStreamInfo->m_idPerfReceive, (LONG)(rtStart / (UNITS / MILLISECONDS)));
  MSR_INTEGER(pStreamInfo->m_idPerfReceive, (LONG)(mtStart));

  if(pSampProp->dwSampleFlags & AM_SAMPLE_TYPECHANGED)
  {
      hr = HandleFormatChange(pStreamInfo, pSampProp->pMediaType);
      if(FAILED(hr)) {
          return hr;
      }
  }

  hr = pStreamInfo->AcceptRejectSample(pSample);
  if(hr == S_OK)
  {

      if(m_IlMode == INTERLEAVE_NONE || m_IlMode == INTERLEAVE_NONE_BUFFERED)
      {
          hr = pStreamInfo->WriteSample(pSample);
      }
      else
      {
          if(m_IlMode == INTERLEAVE_FULL) {
              hr = BlockReceive(pStreamInfo);
          }
          if(SUCCEEDED(hr))
          {
              DbgLog((LOG_TRACE, 15, TEXT("CAviWrite: stream %d. queueing sample %08x"),
                      m_mpPinStream[pinNum], pSample));

              CCopiedSample *pcs = 0;

              if(m_IlMode == INTERLEAVE_FULL)
              {
                  REFERENCE_TIME mts, mte;
                  HRESULT hrGetMt = pSample->GetMediaTime(&mts, &mte);
                  pcs = new CCopiedSample(
                      pSampProp,
                      SUCCEEDED(hrGetMt) ? &mts : 0,
                      SUCCEEDED(hrGetMt) ? &mte : 0,
                      &hr);
                  if(pcs) {
                      pcs->AddRef();
                  } else {
                      hr = E_OUTOFMEMORY;
                  }
              }
              if(SUCCEEDED(hr))
              {
                  CAutoLock lock(&m_cs);
                  if(!pStreamInfo->m_fEosSeen)
                  {
                      IMediaSample *pmsTmp = m_IlMode == INTERLEAVE_FULL ? pcs : pSample;
                      if(pStreamInfo->m_lIncoming.AddTail(pmsTmp))
                      {
                          pmsTmp->AddRef();
                          // this can block as it calls Receive() downstream
                          hr = ScheduleWrites();
                      }
                      else
                      {
                          hr = E_OUTOFMEMORY;
                      }
                  }
                  else          // EOS
                  {
                      hr = S_FALSE;
                  }
              }
              if(pcs) {
                  pcs->Release();
              }
          }
      }
  }
  else if(hr == S_FALSE)
  {
      hr = S_OK;
  }
  //MSR_STOP(pStreamInfo->m_idPerfReceive);
  return hr;
}

// accept only audio changes(it can happen in audio only or video-audio interleaved stream) that change the sampling rate for DV if
// no samples have been received. should be possible to accept any
// change that does not grow the format chunk.
HRESULT CAviWrite::QueryAccept(
    int pinNum,
    const AM_MEDIA_TYPE *pmt)
{
  CAutoLock lock(&m_cs);
  HRESULT hr = S_FALSE;
  StreamInfo *pStreamInfo = m_rgpStreamInfo[m_mpPinStream[pinNum]];
  if(pStreamInfo->m_cSamples == 0)
  {
    if(pStreamInfo->m_mt.majortype == MEDIATYPE_Audio &&
       pmt->majortype == MEDIATYPE_Audio &&
       pmt->formattype == FORMAT_WaveFormatEx &&
       pStreamInfo->m_mt.cbFormat == pmt->cbFormat)
    {
	hr = S_OK;
    }
    else if(pStreamInfo->m_mt.majortype == MEDIATYPE_Interleaved &&
       pmt->majortype == MEDIATYPE_Interleaved &&
       pmt->formattype == FORMAT_DvInfo &&
       pStreamInfo->m_mt.cbFormat == pmt->cbFormat &&
       pmt->pbFormat   != NULL)
    {
      hr = S_OK;
    }

  }

  return hr;
}


// ------------------------------------------------------------------------
// if interleaving, unblock another stream

HRESULT CAviWrite::EndOfStream(int pinNum)
{
  ASSERT(pinNum < C_MAX_STREAMS);
  ASSERT(m_cStreams != 0);
  ASSERT(m_lActiveStreams.GetCount() != 0);
  return EndOfStream(m_rgpStreamInfo[m_mpPinStream[pinNum]]);
}

// don't use nulls for EOS on list to avoid confusion with list apis
// returning null meaning empty list.
#define INCOMING_EOS_SAMPLE ((IMediaSample *)1)

HRESULT CAviWrite::EndOfStream(StreamInfo *pStreamInfo)
{
  CAutoLock lock(&m_cs);
  if(pStreamInfo->m_fEosSeen)
  {
    DbgBreak("CAviWrite::EndOfStream: EOS twice");
    return E_UNEXPECTED;
  }

  if(m_IlMode == INTERLEAVE_NONE)
  {
    m_lActiveStreams.Remove(pStreamInfo->m_posActiveStream);
    pStreamInfo->m_fEosSeen = TRUE;
    return S_OK;
  }
  else
  {
      if(pStreamInfo->m_lIncoming.AddTail(INCOMING_EOS_SAMPLE)) {
          return ScheduleWrites();
      } else {
          return E_OUTOFMEMORY;
      }
  }
}

HRESULT CAviWrite::put_Mode(InterleavingMode mode)
{
  InterleavingMode oldMode = m_IlMode;

  if(mode != INTERLEAVE_NONE &&
     mode != INTERLEAVE_CAPTURE &&
     mode != INTERLEAVE_FULL &&
     mode != INTERLEAVE_NONE_BUFFERED)
    return E_INVALIDARG;

  m_IlMode = mode;

  return S_OK;
}

HRESULT CAviWrite::get_Mode(InterleavingMode *pMode)
{
  *pMode = m_IlMode;
  return S_OK;
}

HRESULT CAviWrite::put_Interleaving(
    const REFERENCE_TIME *prtInterleave,
    const REFERENCE_TIME *prtAudioPreroll)
{
  if(*prtInterleave == 0)
    return E_INVALIDARG;

  m_rtInterleaving = *prtInterleave;
  m_rtAudioPreroll = *prtAudioPreroll;
  return S_OK;
}

HRESULT CAviWrite::get_Interleaving(
  REFERENCE_TIME *prtInterleave,
  REFERENCE_TIME *prtAudioPreroll)
{
  *prtInterleave = m_rtInterleaving;
  *prtAudioPreroll = m_rtAudioPreroll;
  return S_OK;
}

HRESULT CAviWrite::SetIgnoreRiff(BOOL fNoRiff)
{
  return E_NOTIMPL;
}

HRESULT CAviWrite::GetIgnoreRiff(BOOL *pfNoRiff)
{
  return E_NOTIMPL;
}

HRESULT CAviWrite::SetOutputCompatibilityIndex(BOOL fOldIndex)
{
  m_bOutputIdx1 = fOldIndex;
  return S_OK;
}

HRESULT CAviWrite::GetOutputCompatibilityIndex(BOOL *pfOldIndex)
{
  *pfOldIndex = m_bOutputIdx1;
  return S_OK;
}

HRESULT CAviWrite::SetMasterStream(LONG iStream)
{
  DbgLog((LOG_TRACE, 5, TEXT("CAviWrite::SetMasterStream: %i"), iStream));
  m_lMasterStream = iStream;
  return S_OK;
}

HRESULT CAviWrite::GetMasterStream(LONG *pStream)
{
  *pStream = m_lMasterStream;
  return S_OK;
}

// block Receive to keep m_lIncoming from growing indefinitely and
// using too much memory. This would happen if this stream is
// producing data at a slower rate than another.
//
HRESULT CAviWrite::BlockReceive(StreamInfo *pStreamInfo)
{
  HRESULT hr = S_OK;

  while(SUCCEEDED(hr))
  {
    bool fWait = false;
    {
      CAutoLock l(&m_cs);

      if(pStreamInfo->m_fEosSeen) {
          break;
      }

      ASSERT(m_lActiveStreams.GetCount());

      // don't block if we're the only stream or this stream only has a
      // few samples on it.
      if(m_lActiveStreams.GetCount() > 1 &&
         pStreamInfo->m_lIncoming.GetCount() > 10)
      {
        // make sure the time stamps span at least 3x the interleaving
        // amount. !!! not a good way to do this because logic can be
        // fooled by drop frames. We are trying to avoid allocating
        // lots of memory on the list, but if there's 3 seconds worth
        // of dropped frames on this list, this code will fire.

        IMediaSample *psStart = pStreamInfo->m_lIncoming.GetHead();
        IMediaSample *psEnd = pStreamInfo->m_lIncoming.Get(
            pStreamInfo->m_lIncoming.GetTailPosition());

        REFERENCE_TIME rtsFirst, rteLast, rtScratch;
        HRESULT hr = psStart->GetTime(&rtsFirst, &rtScratch);
        ASSERT(hr == S_OK);         // checked in receive
        hr = psEnd->GetTime(&rtScratch, &rteLast);
        ASSERT(hr == S_OK);         // checked in receive

        ASSERT(rtsFirst < rteLast);
        if(rteLast - rtsFirst > m_rtInterleaving * 3 &&
           rteLast - rtsFirst > UNITS)
        {
            DbgLog((LOG_TRACE, 15, TEXT("blocking %d, samples queued = %d, %dms"),
                    pStreamInfo->m_stream, pStreamInfo->m_lIncoming.GetCount(),
                    (LONG)((rteLast - rtsFirst) / (UNITS / MILLISECONDS))));
          fWait = true;
        }
      }
    } // critsec

    if(fWait)
    {
      EXECUTE_ASSERT(m_evBlockReceive.Wait());
    }
    else
    {
      break;
    }
  }

  return hr;
}

HRESULT CAviWrite::ScheduleWrites()
{
  ASSERT(m_IlMode != INTERLEAVE_NONE);
  ASSERT(CritCheckIn(&m_cs));

  // something's going to change - wake up threads in BlockReceive();
  m_evBlockReceive.Set();
  StreamInfo *pSi = m_lActiveStreams.Get(m_posCurrentStream);
  ASSERT(pSi->m_posActiveStream == m_posCurrentStream);

  DbgLog((LOG_TRACE, 15,
          TEXT("CAviWrite:ScheduleWrites: stream %i (%d ticks)"),
          pSi->m_stream, pSi->m_cTicksRemaining));

  // loop until the stream we want to write to needs more data
  for(;;)
  {
    if(pSi->m_fEosSeen)
    {
      DbgLog((LOG_TRACE, 15, TEXT("... removing stream %d"), pSi->m_stream));

      ASSERT(m_posCurrentStream == pSi->m_posActiveStream);
      m_posCurrentStream = GetNextActiveStream(m_posCurrentStream);
      ASSERT(m_posCurrentStream != 0);
      m_lActiveStreams.Remove(pSi->m_posActiveStream);
      if(pSi->m_posActiveStream == m_posCurrentStream)
      {
        ASSERT(m_lActiveStreams.GetCount() == 0);
        DbgLog((LOG_TRACE, 3,
                TEXT("CAviWrite::ScheduleWrites: no streams left")));
        return S_OK;
      }
      else
      {
        ASSERT(m_lActiveStreams.GetCount() != 0);
        pSi = m_lActiveStreams.Get(m_posCurrentStream);
      }
      DbgLog((LOG_TRACE, 15, TEXT("... switched to stream %d"),
              pSi->m_stream));
    }

    // this stream is done. get the next one
    while(pSi->m_cTicksRemaining <= 0)
    {
      m_posCurrentStream = GetNextActiveStream(m_posCurrentStream);
      ASSERT(m_posCurrentStream);

      pSi = m_lActiveStreams.Get(m_posCurrentStream);
      DbgLog((LOG_TRACE, 15,
              TEXT("... switched to stream %i (%d ticks left)"),
              pSi->m_stream, pSi->m_cTicksRemaining));
      ASSERT(!pSi->m_fEosSeen);

      // compute how many ticks this stream is allowed to write.
      if(pSi->m_cTicksRemaining <= 0)
      {
        if(m_posCurrentStream == m_lActiveStreams.GetHeadPosition())
        {
          ASSERT(pSi->m_cTicksPerChunk != 0);
          DbgLog((LOG_TRACE, 15,
                  TEXT("... adding %d ticks to leading stream %d"),
                  pSi->m_cTicksPerChunk, pSi->m_stream));
          pSi->m_cTicksRemaining += pSi->m_cTicksPerChunk;
        }
        else
        {
          StreamInfo *pSiHead = m_lActiveStreams.Get(
            m_lActiveStreams.GetHeadPosition());

          REFERENCE_TIME rtDiff;
          if(m_fInterleaveByTime)
          {
            rtDiff = pSiHead->m_refTimeEnd - pSiHead->m_rtPreroll -
              (pSi->m_refTimeEnd - pSi->m_rtPreroll);
          }
          else
          {
            rtDiff = pSiHead->ConvertTickToTime(pSiHead->m_iCurrentTick);
            rtDiff -= pSiHead->m_rtPreroll;
            rtDiff -= (pSi->ConvertTickToTime(pSi->m_iCurrentTick) -
                       pSi->m_rtPreroll);
          }

          DbgLog((LOG_TRACE, 15,
                  TEXT("... adding %d ticks to non-leading stream %d"),
                  pSi->ConvertTimeToTick(rtDiff), pSi->m_stream));
          pSi->m_cTicksRemaining += pSi->ConvertTimeToTick(rtDiff);
        }
      }
    }

    ASSERT(pSi->m_cTicksRemaining > 0);

    if(pSi->m_lIncoming.GetCount() == 0)
    {
      DbgLog((LOG_TRACE, 15,
              TEXT("CAviWrite:ScheduleWrites: stream %i empty"),
              pSi->m_stream));
      return S_OK;
    }

    HRESULT hr = pSi->WriteSample();

    if(hr != S_OK)
    {
      DbgLog((LOG_TRACE, 1, TEXT("... WriteSample returned %08x"), hr));
      return hr;
    }
  }
}

POSITION CAviWrite::GetNextActiveStream(POSITION pos)
{
  POSITION posNext = m_lActiveStreams.Next(pos);
  if(posNext == 0)
    posNext = m_lActiveStreams.GetHeadPosition();
  return posNext;
}

HRESULT CAviWrite::StreamInfo::NewSampleRecvd(
  IMediaSample *pSample)
{
  REFERENCE_TIME rtStart, rtStop;
  HRESULT hr = pSample->GetTime(&rtStart, &rtStop);
  if(FAILED(hr))
    return hr;

  DWORD lActualLen = pSample->GetActualDataLength();

  if(m_fEosSeen)
    return S_FALSE;

  if(m_cSamples == 0)
  {
    DEBUG_EX(m_pAviWrite->m_dwTimeFirstSample = GetTickCount());
    m_refTimeStart = rtStart;
  }
  else if(rtStop < m_refTimeEnd)
  {
    DbgBreak("StreamInfo::NewSampleRecvd: samples ends before previous one");
    return VFW_E_START_TIME_AFTER_END;
  }

  m_refTimeEnd = rtStop;

  REFERENCE_TIME mtStart, mtStop;
  hr = pSample->GetMediaTime(&mtStart, &mtStop);
  if(hr == S_OK)
  {
    if(mtStop > m_mtEnd)
    {
      m_mtEnd = mtStop;
    }
    else
    {
      DbgBreak("StreamInfo::NewSampleRecvd: media time went backwards");
      return VFW_E_START_TIME_AFTER_END;
    }
  }
  else
  {
    m_mtEnd = -1;
  }

  ASSERT(m_refTimeEnd >= m_refTimeStart);

  //
  // other stream statistics needed
  //
  m_cSamples++;

  // byte written for dwMaxBytesPerSecond. this is total/average. not
  // max !!!
  m_dwlcBytes += lActualLen;

  // for dwSuggestedBufferSize
  m_cbLargestChunk = max(lActualLen, m_cbLargestChunk);

  return S_OK;
}

HRESULT CAviWrite::CFrameBaseStream::NotifyNewSample(
  IMediaSample *pSample, ULONG *pcTicks)
{
  *pcTicks = 1;

  REFERENCE_TIME rtStartCurrent, rtEndCurrent;
  HRESULT hr = pSample->GetTime(&rtStartCurrent, &rtEndCurrent);
  if(FAILED(hr))
    return hr;

  REFERENCE_TIME mtStartCurrent, mtEndCurrent;
  hr = pSample->GetMediaTime(&mtStartCurrent, &mtEndCurrent);
  const BOOL fMtAvailable= (hr == S_OK);

  // fixups for streams that don't set AvgTimePerFrame. The
  // interleaving code uses this. Something proper will have to be
  // done for variable frame rate files.
  if(m_cSamples == 0)
  {
    m_rtDurationFirstFrame = rtEndCurrent - rtStartCurrent;
    if(m_rtDurationFirstFrame <= 0)
      m_rtDurationFirstFrame = UNITS / 30;

    REFERENCE_TIME mtStop;
    if(pSample->GetMediaTime((REFERENCE_TIME *)&m_mtStart, &mtStop) != S_OK)
    {
      m_mtStart = -1;
    }
  }
  else if(m_bDroppedFrames)
  {
    LONG cDropped;
    REFERENCE_TIME mtStart, mtStop;

    // VFW capture filter can't provide a clock and just calls GetTime
    // when it gets a sample. It does fix the media times it sends, so
    // we have to use media times if available.
    if(m_mtEnd != -1 &&
       pSample->GetMediaTime(&mtStart, &mtStop) == S_OK)
    {
      cDropped = (LONG)(mtStart - m_mtEnd);
    }
    else
    {
      //
      // insert null index entries for dropped frames. first frame
      // must not be a drop frame.
      //

      REFERENCE_TIME rtAvgTimePerFrame = ConvertTickToTime(1);
      cDropped = (LONG)(((rtStartCurrent - m_refTimeEnd) +
                         rtAvgTimePerFrame / 2) /
                        rtAvgTimePerFrame);
    }
    // bit of a hack: cDropped may be negative if the source filter
    // went backwards. we catch this properly later.
    for(LONG iDropped = 0; iDropped < cDropped; iDropped++)
    {

#ifdef PERF
//       return VFW_E_NO_SINK;
#endif

      DbgLog((LOG_TRACE, 1, TEXT("avimux: frame %d dropped"), m_cSamples));
      MSR_INTEGER(m_pAviWrite->m_idPerfDrop, m_cSamples);

      HRESULT hr = m_pAviWrite->IndexSample(m_stream, 0, 0, FALSE);
      if(hr != S_OK)
        return hr;

      m_cSamples++;
      m_pAviWrite->m_cDroppedFrames++;
      // we can handle drop frames without abandoning the
      // compatibility fixups
      // m_pAviWrite->m_bSawDeltaFrame = true;
      (*pcTicks)++;
    }
  }

  return S_OK;
}

HRESULT CAviWrite::CAudioStream::NotifyNewSample(
  IMediaSample *pSample, ULONG *pcTicks)
{
    ULONG cb = pSample->GetActualDataLength();
    WAVEFORMATEX *pwfx = (WAVEFORMATEX *)m_mt.Format();

    if(m_bAudioAlignmentError) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    if(cb % pwfx->nBlockAlign != 0) {
        m_bAudioAlignmentError = true;
    }

#ifdef DEBUG
    // complain about dropped audio
    //
    if(m_cSamples > 0)
    {
        REFERENCE_TIME rtStartCurrent, rtEndCurrent;
        HRESULT hr = pSample->GetTime(&rtStartCurrent, &rtEndCurrent);
        if(SUCCEEDED(hr)) {

            // 1ms threshold. The start time of this sample must be
            // near the end time of the previous sample
            if(rtStartCurrent > m_refTimeEnd + UNITS / (UNITS / MILLISECONDS)) {
              DbgLog((LOG_ERROR, 0, TEXT("avimux: audio dropped.")));
            }
        }
    }
#endif


    *pcTicks = GetTicksInSample(cb);
    return S_OK;
}


HRESULT CAviWrite::CAudioStreamI::WriteSample(IMediaSample *pSample)
{
  UNREFERENCED_PARAMETER(pSample);
  // CAudioStreamI can only work in interleaved mode. our WriteSample
  // method never calls this.
  DbgBreak("? interleaved audio confused");
  return E_NOTIMPL;
}

HRESULT CAviWrite::CAudioStreamI::WriteSample()
{
  CAutoLock lock(&m_pAviWrite->m_cs);
  DbgLog((LOG_TRACE, 15, TEXT("CAudioStreamI: ")));
  ASSERT(m_cTicksRemaining > 0);
  HRESULT hr;

  // current sample
  IMediaSample *pSample = m_lIncoming.GetHead();
  ASSERT(pSample);

  if(pSample == INCOMING_EOS_SAMPLE)
  {
    EXECUTE_ASSERT(m_lIncoming.RemoveHead() == INCOMING_EOS_SAMPLE);
    return this->EndOfStream();
  }

  // starting on a new upstream sample
  if(m_cbThisSample == 0)
  {
    hr = NewSampleRecvd(pSample);
    if(hr != S_OK)
      return hr;

    LONG cb = pSample->GetActualDataLength();
    WAVEFORMATEX *pwfx = (WAVEFORMATEX *)m_mt.Format();

    if(m_bAudioAlignmentError) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    if(cb % pwfx->nBlockAlign != 0) {
        m_bAudioAlignmentError = true;
    }
  }

  ASSERT(m_pAviWrite->m_cbAlign == 1);
  ASSERT(m_pAviWrite->m_IlMode == INTERLEAVE_FULL);

  LONG lActualLen = pSample->GetActualDataLength();
  LONG cTicks = GetTicksInSample(lActualLen);

  // adjust data pointer to include our header padding for the Riff
  // chunk header
  BYTE *pbData;
  pSample->GetPointer(&pbData );

  BOOL fFinishedSample = FALSE;

  long cbRemainingThisChunk = ConvertTickToBytes(m_cTicksRemaining);

  m_pAviWrite->DbgCheckFilePos();

  // starting a new riff chunk
  if(!m_fUnfinishedChunk)
  {
    DbgLog((LOG_TRACE, 15, TEXT("AudioStreamI: %d new chunk %d bytes"),
            m_stream, cbRemainingThisChunk));

    hr = m_pAviWrite->HandleSubindexOverflow(m_stream);
    if(FAILED(hr)) {
        return hr;
    }

    m_cbLargestChunk = max((ULONG)cbRemainingThisChunk, m_cbLargestChunk);

    m_dwlOffsetThisChunk = m_pAviWrite->m_dwlFilePos;
    m_cbInRiffChunk = cbRemainingThisChunk;
    RIFFCHUNK rc = { m_moviDataCkid, cbRemainingThisChunk };
    hr = m_pAviWrite->IleaveWrite(
      m_pAviWrite->m_dwlFilePos, (BYTE *)&rc, sizeof(RIFFCHUNK));
    if(hr != S_OK)
    {
      DbgLog(( LOG_ERROR, 2, TEXT("AudioStreamI: Write failed.")));
      return hr;
    }
    m_cbThisChunk = 0;
    m_pAviWrite->m_dwlFilePos += sizeof(RIFFCHUNK);
    m_pAviWrite->DbgCheckFilePos();
  }
  else
  {
    ASSERT(m_pAviWrite->m_dwlFilePos == m_dwlOffsetRecv);
    m_pAviWrite->DbgCheckFilePos();
  }
  m_fUnfinishedChunk = TRUE;

  ULONG cbWrite = min(cbRemainingThisChunk, lActualLen - m_cbThisSample);
  m_cbThisChunk += cbWrite;

  DbgLog((LOG_TRACE, 15, TEXT("AudioStreamI: %d wrote %d bytes"),
          m_stream, cbWrite));
  hr = m_pAviWrite->IleaveWrite(
    m_pAviWrite->m_dwlFilePos,
    pbData + m_cbThisSample, cbWrite);
  if(FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2, TEXT("CAviWrite::Receive: Write failed.")));
    return hr;
  }

  ULONG ctWrite = ConvertBytesToTicks(cbWrite);
  hr = NotifyWrote(ctWrite);
  ASSERT(hr == S_OK);

  m_cbThisSample += cbWrite;
  cbRemainingThisChunk -= cbWrite;
  m_pAviWrite->m_dwlFilePos += cbWrite;
  m_pAviWrite->DbgCheckFilePos();
  DbgLog((LOG_TRACE, 15,
          TEXT("... m_cbThisSample = %d, lActualLen = %d, cbRemainingThisChunk = %d"),
          m_cbThisSample, lActualLen, cbRemainingThisChunk));

  if(cbRemainingThisChunk == 0)
  {
    m_fUnfinishedChunk = FALSE;
    hr = FlushChunk();
    if(hr != S_OK)
      return hr;
  }

  if(m_cbThisSample == lActualLen)
  {
    // take this sample off the queue
    DbgLog((LOG_TRACE, 15, TEXT("...audioI took %08x off the queue"),
            pSample));
    EXECUTE_ASSERT(pSample == m_lIncoming.RemoveHead());
    pSample->Release();
    m_cbThisSample = 0;
  }


#ifdef DEBUG
  if(m_fUnfinishedChunk)
    m_dwlOffsetRecv = m_pAviWrite->m_dwlFilePos;
#endif // DEBUG

  return S_OK;
}

HRESULT CAviWrite::CAudioStreamI::EndOfStream()
{
  DbgLog((LOG_TRACE, 5, TEXT("CAudioStreamI::EndOfStream")));
  ASSERT(m_pAviWrite->m_IlMode == INTERLEAVE_FULL);
  ASSERT(!m_fEosSeen);
  m_fEosSeen = TRUE;
  HRESULT hr;
  if(m_fUnfinishedChunk)
  {
    CAutoLock lock(&m_pAviWrite->m_cs);
    hr = FlushChunk();
    if(FAILED(hr))
      return hr;
    hr = NotifyWrote(m_cTicksRemaining);
  }
  return S_OK;
}

void
CAviWrite::CAudioStreamI::GetCbWritten(DWORDLONG *pdwlcb)
{
  *pdwlcb = m_dwlcbWritten;
}

HRESULT CAviWrite::CAudioStreamI::FlushChunk()
{
  HRESULT hr;
  ASSERT(CritCheckIn(&m_pAviWrite->m_cs));

  DbgLog((LOG_TRACE, 5, TEXT("CAudioStreamI:FlushChunk: stream %d"),
          m_stream));
  m_fUnfinishedChunk = FALSE;

  if(m_cbThisChunk != m_cbInRiffChunk)
  {
    DbgLog((LOG_TRACE, 5, TEXT("CAudioStreamI: need to fix up riff chunk.")));

    RIFFCHUNK rc = { m_moviDataCkid, m_cbThisChunk };
    hr = m_pAviWrite->IStreamWrite(
      m_dwlOffsetThisChunk, (BYTE *)&rc, sizeof(RIFFCHUNK));
    if(hr != S_OK)
    {
      DbgLog(( LOG_ERROR, 2, TEXT("AudioStreamI: Write failed.")));
      return hr;
    }
  }

  // round up to word boundary
  if(m_pAviWrite->m_dwlFilePos % 2)
  {
    m_pAviWrite->m_dwlFilePos++;
  }

  m_dwlcbWritten += m_cbThisChunk;


  hr = m_pAviWrite->IndexSample (
    m_stream,
    m_dwlOffsetThisChunk,
    m_cbThisChunk,
    TRUE);
  if(FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2, TEXT("CAudioStreamI:Flush: IndexSample failed.")));
    return hr;
  }

  hr = m_pAviWrite->NewRiffAvi_();
  if(FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2, TEXT("CAudioStreamI::Flush: NewRiffAvi_ failed.")));
    return hr;
  }

  return S_OK;
}

LONG CAviWrite::CAudioStream::GetTicksInSample(DWORDLONG lcb)
{
  WAVEFORMATEX *pwfx = (WAVEFORMATEX *)m_mt.Format();

  ASSERT(lcb / pwfx->nBlockAlign + 1 <= MAXDWORD);

  // we do need to count a partial tick
  LONG lTicks = (LONG)((lcb + pwfx->nBlockAlign - 1) / pwfx->nBlockAlign);

#ifdef DEBUG
  if(lcb % pwfx->nBlockAlign)
  {
      ASSERT(m_bAudioAlignmentError);
  }
#endif

  return lTicks;
}

HRESULT CAviWrite::StreamInfo::WriteSample()
{
  ASSERT(CritCheckIn(&m_pAviWrite->m_cs));
  IMediaSample *pSample = m_lIncoming.RemoveHead();
  ASSERT(pSample);
  if(pSample == INCOMING_EOS_SAMPLE)
  {
    ASSERT(m_fEosSeen == FALSE);
    m_fEosSeen = TRUE;
    return EndOfStream();
  }

  HRESULT hr = WriteSample(pSample);
  pSample->Release();
  return hr;
}

HRESULT CAviWrite::StreamInfo::WriteSample(IMediaSample *pSample)
{
  CAutoLock lock(&m_pAviWrite->m_cs);
  if(m_fEosSeen)
    return S_FALSE;

  bool fInterleaving = (m_pAviWrite->m_IlMode == INTERLEAVE_FULL);

  REFERENCE_TIME rtStartCurrent, rtEndCurrent;
  HRESULT hr = pSample->GetTime(&rtStartCurrent, &rtEndCurrent);
  if(FAILED(hr))
    return hr;

  hr = m_pAviWrite->HandleSubindexOverflow(m_stream);
  if(FAILED(hr)) {
      return hr;
  }

  ULONG cTicks;
  hr = NotifyNewSample(pSample, &cTicks);
  if(hr != S_OK)
    return hr;

  ULONG cbActualSampleCurrent = pSample->GetActualDataLength();

  // compute frame size of uncompressed frames and see if the sample
  // has the wrong size.
  //
  if(m_mt.formattype == FORMAT_VideoInfo)
  {
    VIDEOINFO *pvi = (VIDEOINFO *)m_mt.Format();

    if((pvi->bmiHeader.biCompression == BI_RGB ||
        pvi->bmiHeader.biCompression == BI_BITFIELDS) &&
       pvi->bmiHeader.biSizeImage < cbActualSampleCurrent)
    {
#ifdef DEBUG
      if(m_cSamples == 0) {
        DbgLog((
          LOG_ERROR, 0,
          TEXT("avi - frame size mismatch. h*w=%d, biSizeImage=%d, GetActualDataLength() = %d"),
          DIBSIZE(pvi->bmiHeader),
          pvi->bmiHeader.biSizeImage,
          cbActualSampleCurrent));

      }
#endif
      cbActualSampleCurrent = pvi->bmiHeader.biSizeImage;
      // !!! NewSampleRecvd sees the wrong buffer size too. should we
      // fix it?
    }
  }

  // adjust data pointer to include our header padding for the Riff
  // chunk header
  BYTE *pbData;
  pSample->GetPointer(&pbData );
  if(!fInterleaving) {
      pbData -= CB_AVI_PREFIX;
  }

  BOOL bSyncPoint = pSample->IsSyncPoint() == S_OK ||
      !m_mt.bTemporalCompression;

  if(!bSyncPoint) {
      m_pAviWrite->m_bSawDeltaFrame = true;
  }

  // set RIFF chunk header w/ sample size and stream id
  DWORD dwActualSize = cbActualSampleCurrent;
  DWORD dwSize = dwActualSize;

  RIFFCHUNK rc = {
      bSyncPoint ? m_moviDataCkid : m_moviDataCkidCompressed,
      dwSize
  };

  BYTE *pJunkSector = 0;
  CSampSample *pSSJunk = 0;

  DWORDLONG dwlOldFilePos = m_pAviWrite->m_dwlFilePos; // the old file offset

  if(!fInterleaving)
  {
      // adjust size for prefix we requested
      dwSize += CB_AVI_PREFIX;

      CopyMemory(pbData, &rc, sizeof(rc));

      if(m_fOurAllocator)
      {
          m_pAviWrite->AddJunk(dwSize, m_pAviWrite->m_cbAlign, pbData);
          // assert our new size fit in what's allocated
          ASSERT(dwSize <= pSample->GetSize() + m_pAviWrite->m_cbPrefix + m_pAviWrite->m_cbSuffix);
      }
      else
      {
          m_pAviWrite->AddJunkOtherAllocator(dwSize, m_pAviWrite->m_cbAlign, pbData, pSample, &pJunkSector);
      }

      CSampSample *pSS;
      hr = m_pAviWrite->m_pSampAlloc->GetBuffer(&pSS, 0, 0, 0);
      if(hr != S_OK)
          return S_FALSE;

      if(pJunkSector)
      {
          hr = m_pAviWrite->m_pSampAlloc->GetBuffer(&pSSJunk, 0, 0, 0);
          if(hr != S_OK)
          {
              pSS->Release();
              return S_FALSE;
          }
      }

      m_pAviWrite->DbgCheckFilePos();

      pSS->SetSample(pSample, pbData, cbActualSampleCurrent);
      REFERENCE_TIME rtStart = m_pAviWrite->m_dwlFilePos;
      REFERENCE_TIME rtStop = rtStart + dwSize;
      pSS->SetTime(&rtStart, &rtStop);

      hr = m_pAviWrite->m_pIMemInputPin->Receive(pSS);
      pSS->Release();
      if(hr != S_OK)
      {
          if(pSSJunk)
              pSSJunk->Release();
          DbgLog(( LOG_ERROR, 2, TEXT("CAviWrite::Receive: Write failed.")));

          // ask filter to stop accepting samples
          return S_FALSE;
      }
  }
  else
  {
      ASSERT(m_pAviWrite->m_dwlFilePos % 2 == 0);
      hr = m_pAviWrite->IleaveWrite(m_pAviWrite->m_dwlFilePos, (BYTE *)&rc, sizeof(rc));
      if(SUCCEEDED(hr))
      {
          m_pAviWrite->m_dwlFilePos += sizeof(rc);
          hr = m_pAviWrite->IleaveWrite(m_pAviWrite->m_dwlFilePos, pbData, dwSize);
          m_pAviWrite->m_dwlFilePos += dwSize;
          if(FAILED(hr)) {
              return hr;
          }
          // RIFF chunks need to be byte aligned.
          if(m_pAviWrite->m_dwlFilePos % 2)
          {
              BYTE b = 0;
              hr = m_pAviWrite->IleaveWrite(m_pAviWrite->m_dwlFilePos, &b, 1);
              m_pAviWrite->m_dwlFilePos ++;;
          }
      }
  }

  hr = NotifyWrote(cTicks);
  ASSERT(hr == S_OK);

  if(!fInterleaving)
  {
      m_pAviWrite->m_dwlFilePos += dwSize;

      m_pAviWrite->DbgCheckFilePos();

      // need to write out an additional junk sector
      if(pJunkSector)
      {
          ASSERT(m_pAviWrite->m_IlMode != INTERLEAVE_FULL);

          REFERENCE_TIME rtStart = m_pAviWrite->m_dwlFilePos;
          REFERENCE_TIME rtStop = rtStart + m_pAviWrite->m_cbAlign;
          pSSJunk->SetTime(&rtStart, &rtStop);
          pSSJunk->SetPointer(pJunkSector, (long)(rtStop - rtStart));
          hr = m_pAviWrite->m_pIMemInputPin->Receive(pSSJunk);
          pSSJunk->Release();
          if(hr != S_OK)
          {
              DbgLog(( LOG_ERROR, 2, TEXT("CAviWrite::Receive: write failed")));
              return S_FALSE;           // ask filter to stop accepting samples
          }
          m_pAviWrite->m_dwlFilePos += m_pAviWrite->m_cbAlign;
      }

      m_pAviWrite->DbgCheckFilePos();
  }

  hr = NewSampleRecvd(pSample);
  if(FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2, TEXT("CAviWrite::Receive: NewSampleRecvd failed.")));
    return hr;
  }

  hr = m_pAviWrite->IndexSample (
    m_stream,
    dwlOldFilePos,
    dwActualSize,
    bSyncPoint);
  if(hr != S_OK)
  {
    DbgLog(( LOG_ERROR, 2, TEXT("CAviWrite::Receive: IndexSample failed.")));
    return hr;
  }

  hr = m_pAviWrite->NewRiffAvi_();
  if(hr != S_OK)
  {
    DbgLog(( LOG_ERROR, 2, TEXT("CAviWrite::Receive: NewRiffAvi_ failed.")));
    return hr;
  }

  return hr;
}


HRESULT CAviWrite::StreamInfo::NotifyWrote(long cTicks)
{
  ASSERT(CritCheckIn(&m_pAviWrite->m_cs));
  m_iCurrentTick += cTicks;
  m_cTicksRemaining -= cTicks;
  DbgLog((LOG_TRACE, 15,
          TEXT("CAviWrite::NotifyWrote: stream %d wrote %d ticks, %d left"),
          m_stream, cTicks, m_cTicksRemaining));
  return S_OK;
}

// try to pick a good size for the super index so we waste less space
// in the file.
void CAviWrite::StreamInfo::ComputeAndSetIndexSize()
{
    if(!PrecomputedIndexSizes())
    {
        m_cEntriesSuperIndex = m_pAviWrite->m_cEntriesMaxSuperIndex;
        m_cEntriesSubIndex = m_pAviWrite->m_cEntriesMaxSubIndex;
    }
    else
    {
        // we cannot predict exactly how much data will be pushed at
        // us and have to allocate space for the index in the file
        // before the data is pushed, we waste some space in the last
        // subindex. If the numbers are small, size the sub indexes so
        // that we waste less space.


        if(m_mt.majortype == MEDIATYPE_Audio)
        {
            const cTicksPerChunk = ConvertTimeToTick(m_pAviWrite->m_rtInterleaving);
            const ULONG cChunks = (m_cTicksExpected + cTicksPerChunk - 1) / cTicksPerChunk;

            m_cEntriesSubIndex = m_pAviWrite->m_cEntriesMaxSubIndex;
            if(cChunks < m_cEntriesSubIndex * 5)
                m_cEntriesSubIndex /= 20;

            m_cEntriesSuperIndex = cChunks / m_cEntriesSubIndex + 1;
        }
        else
        {
            m_cEntriesSubIndex = m_pAviWrite->m_cEntriesMaxSubIndex;
            if(m_cTicksExpected < m_cEntriesSubIndex * 5)
                m_cEntriesSubIndex /= 20;

            m_cEntriesSuperIndex = m_cTicksExpected / m_cEntriesSubIndex + 1;
        }

        // allocate 2x + 5 what we computed for various things that
        // can go wrong:
        //
        // 1. wrong number reported from upstream
        // 2. rounding in audio interleaving causes extra chunks
        // 3. subindex overflow
        //
        m_cEntriesSuperIndex *= 2;
        m_cEntriesSuperIndex += 5;
        m_cEntriesSuperIndex = min(m_cEntriesSuperIndex, m_pAviWrite->m_cEntriesMaxSuperIndex);
     }

    ASSERT(m_cEntriesSuperIndex != 0);

    DbgLog((LOG_TRACE, 3, TEXT("avimux: %i super index entries on stream %i"),
            m_cEntriesSuperIndex, m_stream));
}

BOOL CAviWrite::StreamInfo::PrecomputedIndexSizes()
{
  // these two conditions allow us to write smaller-sized index chunks
  // and waste less space.
  return m_cTicksExpected != 0 && m_pAviWrite->m_IlMode == INTERLEAVE_FULL;
}

// ------------------------------------------------------------------------
// static function. returns fourccs to stick in the AVI fcchandler
// field for all known quartz video subtypes.
//

FOURCC CAviWrite::MpVideoGuidSubtype_Fourcc(const GUID *pGuidSubtype)
{
  // which are in the fourcc guid space
  FOURCCMap *fccm = (FOURCCMap*)pGuidSubtype;
  if(fccm->Data2 == GUID_Data2 && // !!! is this in the registry somewhere
     fccm->Data3 == GUID_Data3 &&
     ((DWORD *)fccm->Data4)[0] == GUID_Data4_1 &&
     ((DWORD *)fccm->Data4)[1] == GUID_Data4_2)
    return  fccm->GetFOURCC();

  GUID guidSubType = *pGuidSubtype;
  if(// guidSubType == MEDIASUBTYPE_YVU9 ||
//      guidSubType == MEDIASUBTYPE_Y411 ||
//      guidSubType == MEDIASUBTYPE_Y41P ||
//      guidSubType == MEDIASUBTYPE_YUY2 ||
//      guidSubType == MEDIASUBTYPE_YVYU ||
     guidSubType == MEDIASUBTYPE_RGB1 ||
     guidSubType == MEDIASUBTYPE_RGB4 ||
     guidSubType == MEDIASUBTYPE_RGB8 ||
     guidSubType == MEDIASUBTYPE_RGB565 ||
     guidSubType == MEDIASUBTYPE_RGB555 ||
     guidSubType == MEDIASUBTYPE_RGB24 ||
     guidSubType == MEDIASUBTYPE_RGB32)
    return FCC('DIB ');

  return 0;
}

void CAviWrite::GetCurrentBytePos(LONGLONG *pllcbCurrent)
{
  *pllcbCurrent = m_dwlFilePos;
}




void CAviWrite::GetStreamInfo(int PinNum, AM_MEDIA_TYPE** ppmt)
{
    *ppmt = NULL;
    if (m_cStreams > 0)
    {
        StreamInfo *pStreamInfo = m_rgpStreamInfo[PinNum];
        *ppmt = & (pStreamInfo->m_mt);
    }

}



void CAviWrite::GetCurrentTimePos(REFERENCE_TIME *prtCurrent)
{
  *prtCurrent = 0;
  if(m_cStreams > 0)
  {
    StreamInfo *pStreamInfo = m_rgpStreamInfo[0];
    *prtCurrent = pStreamInfo->m_refTimeEnd;
  }
  for(UINT iStream = 1; iStream < m_cStreams; iStream++)
  {
    StreamInfo *pStreamInfo = m_rgpStreamInfo[iStream];
    *prtCurrent = min(*prtCurrent, pStreamInfo->m_refTimeEnd);
  }
}

// ------------------------------------------------------------------------
// static method called when write is complete. releases sample

void CAviWrite::SampleCallback(void *pMisc)
{
  IMediaSample *pSample = (IMediaSample*)pMisc;
  pSample->Release();
}

// ------------------------------------------------------------------------
// initialize the internal representation of the avi AVIH structure in
// memory, allocate space for it on disk

HRESULT CAviWrite::InitializeHeader(IMediaPropertyBag *pProp)
{
  ULONG cbIndexChunks = 0;
  for(unsigned i = 0; i < m_cStreams; i++)
  {
    StreamInfo *pSi = m_rgpStreamInfo[i];
    cbIndexChunks += cbSuperIndex(C_ENTRIES_SUPERINDEX);
  }

  // allocate large amount of space; 8k for the header. an extra 1k
  // for each stream plus the indx chunk. 64k for properties
  const ULONG cbAlloc = 8192 +
    (cbIndexChunks + 1024) * m_cStreams +
    m_cbHeaderJunk + 65536;

  m_rgbHeader = new BYTE[cbAlloc];
  if(m_rgbHeader == 0)
    return E_OUTOFMEMORY;
  ZeroMemory(m_rgbHeader, cbAlloc);

  ULONG iPos = 0;               // current position

#define CheckOverflow(n) if(iPos + n >= cbAlloc) return VFW_E_BUFFER_OVERFLOW;

  m_pAvi_ = (RIFFLIST *)(m_rgbHeader + iPos);
  SetList(m_pAvi_, FCC('RIFF'), 0, FCC('AVI '));
  iPos += sizeof(RIFFLIST);

  m_pHdrl = (RIFFLIST *)(m_rgbHeader + iPos);
  SetList(m_pHdrl, FCC('LIST'), 0, FCC('hdrl'));
  iPos += sizeof(RIFFLIST);
  {
    m_pAvih = (AVIMAINHEADER *)(m_rgbHeader + iPos); // avih chunk
    SetChunk(m_pAvih, FCC('avih'), sizeof(AVIMAINHEADER) - sizeof(RIFFCHUNK));
    iPos += sizeof(AVIMAINHEADER);

    HRESULT hr = InitializeStrl(iPos);
    if(FAILED(hr))
      return hr;

    ASSERT(iPos <= cbAlloc);

    // do odml list
    m_pOdml = (RIFFLIST *)(m_rgbHeader + iPos);
    CheckOverflow(sizeof(RIFFLIST));
    SetList(m_pOdml, FCC('LIST'), 0, FCC('odml'));
    iPos += sizeof(RIFFLIST);
    {
      m_pDmlh = (AVIEXTHEADER *)(m_rgbHeader + iPos);
      CheckOverflow(sizeof(AVIEXTHEADER));
      SetChunk(m_pDmlh, FCC('dmlh'), sizeof(AVIEXTHEADER) - sizeof(RIFFCHUNK));
      iPos += sizeof(AVIEXTHEADER);

    } // odml list
    m_pOdml->cb = (DWORD)(m_rgbHeader + iPos - (BYTE *)m_pOdml - sizeof(RIFFCHUNK));

  } // hdrl list
  m_pHdrl->cb = (DWORD)(m_rgbHeader + iPos - (BYTE *)m_pHdrl - sizeof(RIFFCHUNK));

  // do INFO/DISP chunks
  if(pProp)
  {
      RIFFLIST *pInfoList = (RIFFLIST *)(m_rgbHeader + iPos);
      ULONG posInfoChunk = iPos;
      CheckOverflow(sizeof(RIFFLIST));
      iPos += sizeof(RIFFLIST);

      // look for INFO properties
      for(UINT i = 0; ; i++)
      {
          VARIANT varProp, varVal;
          varProp.bstrVal = 0;
          varProp.vt = VT_BSTR;
          varVal.vt = VT_EMPTY;
          HRESULT hr = pProp->EnumProperty(i, &varProp, &varVal);
          if(SUCCEEDED(hr))
          {
              // not really a valid assertion so we check for this too
              ASSERT(varProp.vt == VT_BSTR);

              if(varVal.vt == VT_BSTR && varProp.vt == VT_BSTR)
              {
                  DWORD szKey[20];        // string dereferenced as dword

                  int cch = WideCharToMultiByte(
                      CP_ACP, 0,
                      varProp.bstrVal, -1,
                      (char *)szKey, sizeof(szKey),
                      0, 0);
                  if(cch == sizeof("INFO/XXXX") &&
                     szKey[0] == FCC('INFO') &&
                     ((char *)szKey)[4] == '/')
                  {
                      DbgLog((LOG_TRACE, 5,
                              TEXT("avimux: writing copyright string %S = %S"),
                              varProp.bstrVal, varVal.bstrVal));

                      DWORD dwFcc = *(DWORD UNALIGNED *)(((BYTE *)szKey) + 5);
                      int cchVal = SysStringLen(varVal.bstrVal) + 1;
                      cchVal = AlignUp(cchVal, sizeof(DWORD)); // DWORD align RIFF chunks
                      UNALIGNED RIFFCHUNK *pRiffchunk = (RIFFCHUNK *)(m_rgbHeader + iPos);
                      CheckOverflow(sizeof(RIFFCHUNK)); // !!! memory leak
                      SetChunk(pRiffchunk, dwFcc, cchVal);
                      iPos += sizeof(RIFFCHUNK);

                      CheckOverflow(cchVal); // !!! memory leak
                      {
                          UINT cch = WideCharToMultiByte(
                              CP_ACP, 0,
                              varVal.bstrVal, -1,
                              (char *)m_rgbHeader + iPos, cbAlloc - iPos,
                              0, 0);
                          ASSERT(SysStringLen(varVal.bstrVal) + 1 == cch);
                      }
                      iPos += cchVal;
                  }

              }

              SysFreeString(varProp.bstrVal);
              VariantClear(&varVal);
          }
          else
          {
              hr = S_OK;
              break;
          }
      } // INFO

      SetList(
          pInfoList,
          FCC('LIST'),
          iPos - posInfoChunk - sizeof(RIFFCHUNK),
          FCC('INFO'));

      // DISP
      for(/* UINT */ i = 0; ; i++)
      {
          VARIANT varProp, varVal;
          varProp.bstrVal = 0;
          varProp.vt = VT_BSTR;
          varVal.vt = VT_EMPTY;
          HRESULT hr = pProp->EnumProperty(i, &varProp, &varVal);
          if(SUCCEEDED(hr) )
          {
              // not really a valid assertion, so we validate it anyway
              ASSERT(varProp.vt == VT_BSTR);

              // is this property an array of bytes?
              if(varProp.vt == VT_BSTR && varVal.vt == (VT_UI1 | VT_ARRAY))
              {
                  DWORD szKey[20];        // string dereferenced as dword

                  int cch = WideCharToMultiByte(
                      CP_ACP, 0,
                      varProp.bstrVal, -1,
                      (char *)szKey, sizeof(szKey),
                      0, 0);
                  if(cch == sizeof("DISP/XXXXXXXXXX") &&
                     szKey[0] == FCC('DISP') &&
                     ((char *)szKey)[4] == '/')
                  {
                      DbgLog((LOG_TRACE, 5,
                              TEXT("avimux: writing display string %S"),
                              varProp.bstrVal));

                      // read decimal value (no scanf w/o crt)
                      ULONG dispVal = 0, digit = 1;
                      for(int ichar = 9; ichar >= 0; ichar--)
                      {
                          dispVal += (((char *)szKey)[5 + ichar] - '0') * digit;
                          digit *= 10;
                      }

                      // bytes of data in the property
                      UINT cbDispData = varVal.parray->rgsabound[0].cElements;

                      // DWORD align RIFF chunks. +sizeof(DWORD) for
                      // the DISP chunk identifier at the beginning.
                      UINT cbDispChunk = AlignUp(cbDispData + sizeof(DWORD), sizeof(DWORD));

                      UNALIGNED RIFFCHUNK *pRiffchunk = (RIFFCHUNK *)(m_rgbHeader + iPos);

                      CheckOverflow(sizeof(RIFFCHUNK) + sizeof(DWORD)); // !!! memory leak
                      SetChunk(pRiffchunk, FCC('DISP'), cbDispChunk);
                      iPos += sizeof(RIFFCHUNK);
                      *(DWORD *)(m_rgbHeader + iPos) = dispVal;
                      iPos += sizeof(DWORD);

                      // copy the data from the property bag into the header
                      CheckOverflow(cbDispChunk - sizeof(DWORD)); // !!! memory leak
                      {
                          BYTE *pbData;
                          EXECUTE_ASSERT(SafeArrayAccessData(varVal.parray, (void **)&pbData) == S_OK);
                          CopyMemory(
                              m_rgbHeader + iPos,
                              pbData,
                              cbDispData);
                          EXECUTE_ASSERT(SafeArrayUnaccessData(varVal.parray) == S_OK);
                      }

                      // advance to the end. -sizeof(DWORD) because we
                      // already accounted for the DWORD earlier.
                      iPos += cbDispChunk - sizeof(DWORD);

                  } // DISP?
              } // array?

              SysFreeString(varProp.bstrVal);
              VariantClear(&varVal);
          } // ENUM
          else
          {
              hr = S_OK;
              break;
          }

      } // DISP chunk loop

  } // pProp

  // add requested empty space (for future edits) and make the data
  // part of the list-movi chunk start on a sector boundary
  if(m_cbAlign > 1 || m_cbHeaderJunk > 1)
  {
    RIFFCHUNK *pHeaderJunk = (RIFFCHUNK *)(m_rgbHeader + iPos);
    iPos += sizeof(RIFFCHUNK);
    ULONG cbJunk = m_cbHeaderJunk;
    unsigned remainder = (iPos + cbJunk + sizeof(RIFFLIST)) %  m_cbAlign;
    if(remainder != 0)
      cbJunk += m_cbAlign - remainder;
    CheckOverflow(cbJunk);
    SetChunk(pHeaderJunk, FCC('JUNK'), cbJunk);
    iPos += cbJunk;
  }

  ASSERT(iPos <= cbAlloc);

  m_pMovi = (RIFFLIST *)(m_rgbHeader + iPos); // movi List
  CheckOverflow(sizeof(RIFFLIST));
  SetList(m_pMovi, FCC('LIST'), 0, FCC('movi'));
  iPos += sizeof(RIFFLIST);

  ASSERT(m_cbAlign != 0);         // make sure GetMemReq was called
  ASSERT(iPos % sizeof(DWORD) == 0);

  AddJunk(iPos, m_cbAlign, m_rgbHeader);

  m_cbHeader = iPos;

  ASSERT(iPos <= cbAlloc);
  ASSERT(iPos % m_cbAlign == 0);

  m_posFirstIx = iPos;
  m_dwlCurrentRiffAvi_ = (BYTE*)m_pAvi_ - m_rgbHeader;

  m_dwlFilePos = m_posFirstIx;

  return S_OK;
}

// ------------------------------------------------------------------------
// a separate function that adds a "STRL" list for each stream

HRESULT CAviWrite::InitializeStrl(ULONG& iPos)
{
  // do the strl lists
  for(unsigned i = 0; i < m_cStreams; i++)
  {
    StreamInfo *pStreamInfo = m_rgpStreamInfo[i];
    pStreamInfo->m_posStrl = iPos;
    SetList(m_rgbHeader + iPos, FCC('LIST'), 0, FCC('strl'));
    iPos += sizeof(RIFFLIST);   // strl
    {

      // strh
      RIFFCHUNK *pStrh = (RIFFCHUNK*)(m_rgbHeader + iPos);
      SetChunk(pStrh, FCC('strh'), sizeof(AVISTREAMHEADER) - sizeof(RIFFCHUNK));
      iPos += sizeof(AVISTREAMHEADER);
      // end strh

      // STRF chunk
      pStreamInfo->m_posStrf = iPos;
      ULONG cbStrf = pStreamInfo->m_mt.FormatLength();
      const GUID &majorType = pStreamInfo->m_mt.majortype;
      if(majorType == MEDIATYPE_Video)
      {
        // adjustment -- we save only the BITMAPINFOHEADER from the
        // VIDEOINFO
        if(pStreamInfo->m_mt.formattype == FORMAT_VideoInfo)
        {
          VIDEOINFO *pvi = (VIDEOINFO *)pStreamInfo->m_mt.Format();
          cbStrf = GetBitmapFormatSize(&pvi->bmiHeader) - SIZE_PREHEADER;
        }

        pStreamInfo->m_moviDataCkid = FCC('00db');
        Hexrg2bFromW((BYTE*)&pStreamInfo->m_moviDataCkid, i);
        pStreamInfo->m_moviDataCkidCompressed = FCC('00dc');
        Hexrg2bFromW((BYTE*)&pStreamInfo->m_moviDataCkidCompressed, i);
      }
      else if(majorType == MEDIATYPE_Audio)
      {
        pStreamInfo->m_moviDataCkid = FCC('00wb');
        Hexrg2bFromW((BYTE*)&pStreamInfo->m_moviDataCkid, i);
        pStreamInfo->m_moviDataCkidCompressed = pStreamInfo->m_moviDataCkid;
      }
      else if(majorType == MEDIATYPE_Text)
      {
        pStreamInfo->m_moviDataCkid = FCC('00tx');
        Hexrg2bFromW((BYTE*)&pStreamInfo->m_moviDataCkid, i);
        pStreamInfo->m_moviDataCkidCompressed = pStreamInfo->m_moviDataCkid;
      }
      else
      {
        pStreamInfo->m_moviDataCkid = FCC('00__');
        Hexrg2bFromW((BYTE*)&pStreamInfo->m_moviDataCkid, i);
        pStreamInfo->m_moviDataCkidCompressed = pStreamInfo->m_moviDataCkid;
      }

      pStreamInfo->m_cbStrf = cbStrf;
      SetChunk(m_rgbHeader + iPos, FCC('strf'), cbStrf);
      iPos += sizeof(RIFFCHUNK) + cbStrf;
      // end strf

      // strn
      if(pStreamInfo->m_szStrn)
      {
          // we need WORD alignment. But SetChunk appears to force
          // DWORD alignment for memory alignment issues rather than
          // file format issues.
          AddJunk(iPos, sizeof(DWORD), m_rgbHeader);
          ULONG cbSz = lstrlenA(pStreamInfo->m_szStrn) + 1;
          SetChunk(m_rgbHeader + iPos, FCC('strn'), cbSz);
          iPos += sizeof(RIFFCHUNK);
          pStreamInfo->m_posStrn = iPos;
          iPos += cbSz;
      }
      else
      {
          pStreamInfo->m_posStrn = 0;
      }
      

      // we need DWORD alignment
      AddJunk(iPos, sizeof(DWORD), m_rgbHeader);

      // indx chunk (including RIFFCHUNK header)
      pStreamInfo->m_posIndx = iPos;
      const ULONG cbIndx = cbSuperIndex(pStreamInfo->m_cEntriesSuperIndex);
      SetChunk(m_rgbHeader + iPos, FCC('indx'), cbIndx - sizeof(RIFFCHUNK));
      iPos += cbIndx;
      // end indx

    }
    // end strl
    ((RIFFLIST*)(m_rgbHeader + pStreamInfo->m_posStrl))->cb =
      iPos - pStreamInfo->m_posStrl - sizeof(RIFFCHUNK);
  } // for loop

  return S_OK;
}

// ------------------------------------------------------------------------
// get configuration from the registry. use constants otherwise.

HRESULT CAviWrite::InitializeOptions()
{
  m_cbRiffMax = CB_RIFF_MAX;
  m_cbBuffer = CB_BUFFER;
  m_cBuffers = C_BUFFERS;
  m_cbHeaderJunk = CB_HEADER_JUNK;
  m_bOutputIdx1 = g_B_OUTPUT_IDX1;

  HKEY hkOptions;
  LONG lResult = RegOpenKeyEx(
    HKEY_CURRENT_USER,
    TEXT("Software\\Microsoft\\Multimedia\\AviWriterFilter"),
    0,
    KEY_READ,
    &hkOptions);
  if(lResult != ERROR_SUCCESS)
    return S_OK;

//   RegGetDword(hkOptions, TEXT("cbSubIndex"), &m_cbIx);
//   RegGetDword(hkOptions, TEXT("cbSuperIndex"), &m_cbIndx);
  RegGetDword(hkOptions, TEXT("cbOuterRiff"), &m_cbRiffMax);
  RegGetDword(hkOptions, TEXT("cbHeaderJunk"), &m_cbHeaderJunk);
  RegGetDword(hkOptions, TEXT("cbBuffer"), &m_cbBuffer);
  RegGetDword(hkOptions, TEXT("cBuffers"), &m_cBuffers);

  // need to do the binary values specially
  DWORD dw_b;
  RegGetDword(hkOptions, TEXT("bOutputOldIndex"), &dw_b) &&
    (m_bOutputIdx1 = dw_b);

  lResult = RegCloseKey(hkOptions);
  ASSERT(lResult == ERROR_SUCCESS);

  return S_OK;
}

HRESULT CAviWrite::InitializeInterleaving()
{
  BOOL fFoundAudio = FALSE;
  REFERENCE_TIME rtLeadingStream = 0;
  for(UINT iStream = 0; iStream < m_cStreams; iStream++)
  {
    StreamInfo *pStreamInfo = m_rgpStreamInfo[iStream];

    if(iStream == 0)
    {
      pStreamInfo->m_cTicksPerChunk = pStreamInfo->ConvertTimeToTick(m_rtInterleaving);
      rtLeadingStream = m_rtInterleaving;
    }
    else
    {
      ASSERT(rtLeadingStream != 0);
      pStreamInfo->m_cTicksPerChunk =
        pStreamInfo->ConvertTimeToTick(rtLeadingStream);
    }
    if(pStreamInfo->m_cTicksPerChunk == 0)
    {
      pStreamInfo->m_cTicksPerChunk = 1;
    }

    if(*pStreamInfo->m_mt.Type() == MEDIATYPE_Audio &&
       m_rtAudioPreroll > 0)
    {
      fFoundAudio = TRUE;
      ASSERT(m_rgpStreamInfo[iStream]->m_cTicksRemaining == 0);
      REFERENCE_TIME rtPreroll = m_rtAudioPreroll;
      pStreamInfo->m_rtPreroll = rtPreroll;
      pStreamInfo->m_cTicksRemaining =
        pStreamInfo->ConvertTimeToTick(rtPreroll);

      // relative to other streams, this stream has completed 1 cycle
      // when it has written the preroll.
      pStreamInfo->m_iCurrentTick = pStreamInfo->m_cTicksPerChunk;

      // audio streams for audio preroll ares first on the list
      POSITION pos = m_lActiveStreams.AddHead(pStreamInfo);
      pStreamInfo->m_posActiveStream = pos;
    }
    else
    {
      pStreamInfo->m_rtPreroll = 0;
      pStreamInfo->m_cTicksRemaining = 0;

      // anything else goes at the end of the list
      POSITION pos = m_lActiveStreams.AddTail(pStreamInfo);
      pStreamInfo->m_posActiveStream = pos;
    }


  }
  m_posCurrentStream = m_lActiveStreams.GetHeadPosition();

  if(!fFoundAudio)
  {
    m_rgpStreamInfo[0]->m_cTicksRemaining =
      m_rgpStreamInfo[0]->m_cTicksPerChunk;
  }

  // account for drift if we are trying to interleave the captured output
  m_fInterleaveByTime = (m_IlMode == INTERLEAVE_CAPTURE);

  return S_OK;
}

BOOL CAviWrite::RegGetDword(HKEY hk, TCHAR *tsz, DWORD *dw)
{
  DWORD dwType, dwResult, cbRead;
  LONG lResult;

  lResult = RegQueryValueEx(
    hk,
    tsz,
    0,
    &dwType,
    (BYTE*)&dwResult,
    &cbRead);
  if(lResult == ERROR_SUCCESS && dwType == REG_DWORD && cbRead == sizeof(DWORD))
  {
    *dw = dwResult;
    return TRUE;
  }
  return FALSE;
}

// ------------------------------------------------------------------------
// initialize sub index structures on startup. leave space at the
// start of the file for one sub index per stream. initialize the
// super index structures

HRESULT CAviWrite::InitializeIndex()
{
  ASSERT(m_pAllocator == 0);
  ASSERT(m_cStreams != 0);

  HRESULT hr = CreateMemoryAllocator(&m_pAllocator);
  if(FAILED(hr))
  {
    return hr;
  }

  ALLOCATOR_PROPERTIES Request, Actual;

  Request.cBuffers = 2 * m_cStreams;
  Request.cbBuffer = AlignUp(cbSubIndex(m_cEntriesMaxSubIndex), m_cbAlign);
  Request.cbAlign = m_cbAlign;
  Request.cbPrefix = 0;

  hr = m_pAllocator->SetProperties(&Request, &Actual);

  if(FAILED(hr))
  {
    m_pAllocator->Release();
    m_pAllocator = 0;
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviWrite::InitializeIndex:: SetProperties failed.")));
    return hr;
  }

  if ((Request.cbBuffer > Actual.cbBuffer) ||
      (Request.cBuffers > Actual.cBuffers) ||
      (Request.cbAlign > Actual.cbAlign))
  {
    DbgBreak("our allocator refused our values");
    m_pAllocator->Release();
    m_pAllocator = 0;
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviWrite::InitializeIndex:: allocator refused values.")));
    return E_UNEXPECTED;
  }

  hr = m_pAllocator->Commit();
  if(FAILED(hr))
  {
    DbgBreak("our allocator won't commit");
    m_pAllocator->Release();
    m_pAllocator = 0;
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviWrite::InitializeIndex:: Commit failed.")));
    return hr;
  }

  unsigned i;
  // get memory from the the allocator for each stream
  for(i = 0; i < m_cStreams; i++)
  {
    if(hr = InitIx(i), FAILED(hr))
    {
      DbgLog(( LOG_ERROR, 2,
               TEXT("CAviWrite::InitializeIndex:: InitIx failed.")));
      return hr;
    }
  }

  // advance the file pointer to leave space for the first sub-index
  // chunks
  ASSERT(m_dwlFilePos % m_cbAlign == 0);
  for(i = 0; i < m_cStreams; i++)
  {
    StreamInfo *pSi = m_rgpStreamInfo[i];

    // only need to do this if we really are writing out sub indexes.
    pSi->m_posFirstSubIndex = (ULONG)m_dwlFilePos;
    pSi->m_dwlOffsetCurrentSubIndex = m_dwlFilePos;
    m_dwlFilePos += cbSubIndex(pSi->m_cEntriesSubIndex);

    ASSERT(cbSubIndex(pSi->m_cEntriesSubIndex) % m_cbAlign == 0);
    ASSERT(m_dwlFilePos % m_cbAlign == 0);
  }

  //
  // build the super index
  //
  for(i = 0; i < m_cStreams; i++)
  {
    AVISUPERINDEX *pSuperIndx = (AVISUPERINDEX *)GetIndx(i);
    pSuperIndx->wLongsPerEntry = sizeof(AVISUPERINDEX::_avisuperindex_entry) /
      sizeof(DWORD);
    pSuperIndx->bIndexSubType = 0;
    pSuperIndx->bIndexType = AVI_INDEX_OF_INDEXES;
    pSuperIndx->nEntriesInUse = 0;
    pSuperIndx->dwChunkId = m_rgpStreamInfo[i]->m_moviDataCkid;
    pSuperIndx->dwReserved[0] = 0;
    pSuperIndx->dwReserved[1] = 0;
    pSuperIndx->dwReserved[2] = 0;

  }

  return S_OK;
}

// ------------------------------------------------------------------------
// fills out structures which weren't filled out on creation

HRESULT CAviWrite::CloseHeader()
{

  // go through all the steps even if a previous step failed and
  // record the first error
  HRESULT hr, hrTmp;

  if(hr = CloseStreamHeader(), FAILED(hr))
    DbgLog(( LOG_ERROR, 2,  TEXT("::CloseHeader: CloseStreamHeader failed.")));

  if(hrTmp = CloseIndex(), FAILED(hrTmp))
    DbgLog(( LOG_ERROR, 2,  TEXT("::CloseHeader: CloseIndex failed.")));

  hr = FAILED(hr) ? hr : hrTmp;

  if(hrTmp = CloseStreamFormat(), FAILED(hrTmp))
    DbgLog(( LOG_ERROR, 2,  TEXT("::CloseHeader: CloseStreamFormat failed.")));

  hr = FAILED(hr) ? hr : hrTmp;

  if(hrTmp = CloseStreamName(), FAILED(hrTmp))
    DbgLog(( LOG_ERROR, 0,  TEXT("::CloseHeader: CloseStreamName failed.")));

  hr = FAILED(hr) ? hr : hrTmp;

  if(hrTmp = CloseMainAviHeader(), FAILED(hrTmp))
    DbgLog(( LOG_ERROR, 2,  TEXT("::CloseHeader: CloseMainAviHeader failed.")));

  hr = FAILED(hr) ? hr : hrTmp;

  if(hrTmp = CloseOuterRiff(), FAILED(hrTmp))
    DbgLog(( LOG_ERROR, 2,  TEXT("::CloseHeader: CloseOuterRiff failed.")));

  hr = FAILED(hr) ? hr : hrTmp;

  DbgLog(( LOG_ERROR, 2,  TEXT("CAviWrite::CloseHeader: hr: %08x, %d"),
           hr, GetLastError()));

  return hr;
}

// ------------------------------------------------------------------------
// fills in the AVIH fields. needs to be called after the filter has
// run. note this requires that CloseStreamHeader has already been
// called to pick up updated values from that structure

HRESULT CAviWrite::CloseMainAviHeader()
{
  m_pAvih->dwStreams = m_cStreams;
  if(m_cStreams == 0)
    return S_OK;

  // locate the first video stream
  for(unsigned iVid = 0; iVid < m_cStreams; iVid++)
    if(m_rgpStreamInfo[iVid]->m_mt.majortype == MEDIATYPE_Video)
      break;

  if(iVid == m_cStreams)
  {
    // use values from the first stream
    iVid = 0;
  }

  StreamInfo &rSi = *(m_rgpStreamInfo[iVid]);
  CMediaType *pmt = &m_rgpStreamInfo[iVid]->m_mt;

  LONGLONG unitsElapsed = rSi.m_refTimeEnd.GetUnits() - rSi.m_refTimeStart.GetUnits();
  LONG secondsElapsed = (ULONG)(unitsElapsed / UNITS);

  BOOL bUseAvgTimerPerFrame = FALSE;
  VIDEOINFO *pvi;
  CRefTime rt;
  if(pmt->majortype == MEDIATYPE_Video &&
     pmt->formattype == FORMAT_VideoInfo)
  {
    pvi = (VIDEOINFO*)pmt->Format();
    rt = pvi->AvgTimePerFrame;
    bUseAvgTimerPerFrame = (rt.GetUnits() != 0);
  }
  if(bUseAvgTimerPerFrame)
  {
    m_pAvih->dwMicroSecPerFrame = (ULONG)(rt.GetUnits() / (UNITS / 1000000));
  }
  else
  {
    if(GetStrh(iVid)->dwRate != 0)
    {
      m_pAvih->dwMicroSecPerFrame =
        (DWORD)((double)(GetStrh(iVid)->dwScale) / GetStrh(iVid)->dwRate * 1000000);
    }
    else
    {
      m_pAvih->dwMicroSecPerFrame = 0;
    }
  }

  if(pmt->majortype == MEDIATYPE_Video &&
     pmt->formattype == FORMAT_VideoInfo)
  {
    VIDEOINFO *pvi;
    pvi = (VIDEOINFO*)pmt->Format();

    m_pAvih->dwHeight = pvi->bmiHeader.biHeight;
    m_pAvih->dwWidth = pvi->bmiHeader.biWidth;
  }
  else
  {
    m_pAvih->dwHeight = 0;
    m_pAvih->dwWidth = 0;
  }

  m_pAvih->dwSuggestedBufferSize = rSi.m_cbLargestChunk + sizeof(RIFFCHUNK);

  // really should check all streams for longest elapsed time
  // not maximum but average
  if(secondsElapsed != 0)
    m_pAvih->dwMaxBytesPerSec = (ULONG)(m_dwlFilePos / secondsElapsed);
  else
    m_pAvih->dwMaxBytesPerSec = 0;

  m_pAvih->dwPaddingGranularity = m_cbAlign;
  m_pAvih->dwFlags = AVIF_TRUSTCKTYPE;
  m_pAvih->dwFlags |= m_bOutputIdx1 ? AVIF_HASINDEX : 0;

  // VFW uses dwTotalFrames for the duration, so we have to find the
  // longest stream and convert it to the units we picked earlier.
  if(m_pAvih->dwMicroSecPerFrame != 0)
  {
    REFERENCE_TIME rtMaxDur = m_rgpStreamInfo[0]->m_refTimeEnd;
    for(UINT iStream = 1; iStream < m_cStreams; iStream++)
    {
      StreamInfo *pStreamInfo = m_rgpStreamInfo[iStream];
      rtMaxDur = max(pStreamInfo->m_refTimeEnd, rtMaxDur);
    }
    // convert duration to microseconds and divide by duration of each frame
    m_pAvih->dwTotalFrames = (DWORD)
      (rtMaxDur / 10 / m_pAvih->dwMicroSecPerFrame);
  }
  else
  {
    m_pAvih->dwTotalFrames = 0;
  }

  m_pAvih->dwInitialFrames = 0;
  m_pAvih->dwReserved[0] = 0;
  m_pAvih->dwReserved[1] = 0;
  m_pAvih->dwReserved[2] = 0;
  m_pAvih->dwReserved[3] = 0;

  m_pDmlh->dwGrandFrames = GetStrh(iVid)->dwLength;

  return S_OK;
}

// #define MY_CDISP(x) ((lstrcpy((char *)_alloca(2000), CDisp(x))))

// ------------------------------------------------------------------------
// fill in strh values. needs to be called after running

HRESULT CAviWrite::CloseStreamHeader()
{
  DWORD cSamplesAll = 0;
      
  // determine skew on master stream
  double dScaleMasterStream = 1;
  if(m_lMasterStream != -1)
  {
    ASSERT((ULONG)m_lMasterStream < m_cStreams);

    StreamInfo *pStreamInfo = m_rgpStreamInfo[m_lMasterStream];
    CRefTime rtDuration = pStreamInfo->m_refTimeEnd - pStreamInfo->m_refTimeStart;
    ULONG cTicks = pStreamInfo->CountSamples();
    CRefTime rtDurComputed = pStreamInfo->ConvertTickToTime(cTicks);
    DbgLog((LOG_TRACE, 2, TEXT("avimux: rtDur: %d, ticks: %d, compDur: %d"),
            (long)(rtDuration.Millisecs()), cTicks,
            (long)(rtDurComputed.Millisecs())));

    if(rtDurComputed != 0)
      dScaleMasterStream = (double)(rtDuration) / (double)rtDurComputed;

    DbgLog((LOG_TRACE, 2, TEXT("skew on master stream = %s"),
            CDisp(dScaleMasterStream)));
  }

  // normalize earliest stream to time 0.
  REFERENCE_TIME rtMax = m_rgpStreamInfo[0]->m_refTimeStart;
  for(UINT iStream = 1; iStream < m_cStreams; iStream++)
  {
    StreamInfo *pStreamInfo = m_rgpStreamInfo[iStream];
    if(pStreamInfo->m_refTimeStart < rtMax)
      rtMax = pStreamInfo->m_refTimeStart;
  }
  for(iStream = 0; iStream < m_cStreams; iStream++)
  {
    StreamInfo *pStreamInfo = m_rgpStreamInfo[iStream];
    pStreamInfo->m_refTimeStart -= rtMax;
    pStreamInfo->m_refTimeEnd -= rtMax;
  }

  // adjust time stamps for skew
  if(dScaleMasterStream != 1 && dScaleMasterStream != 0)
  {
    for(UINT iStream = 0; iStream < m_cStreams; iStream++)
    {
      StreamInfo *pStreamInfo = m_rgpStreamInfo[iStream];
      if((long)iStream != m_lMasterStream)
      {
        DbgLog((LOG_TRACE, 3,
                TEXT("avimux: adjusting for skew on %d. was %s - %s"),
                iStream, (LPCTSTR)CDisp(pStreamInfo->m_refTimeStart),
                (LPCTSTR)CDisp(pStreamInfo->m_refTimeEnd)));

        pStreamInfo->m_refTimeStart = (REFERENCE_TIME)(
          pStreamInfo->m_refTimeStart /dScaleMasterStream);
        pStreamInfo->m_refTimeEnd = (REFERENCE_TIME)(
          pStreamInfo->m_refTimeEnd / dScaleMasterStream);

        DbgLog((LOG_TRACE, 3,
                TEXT("avimux: adjusting for skew on %d. now %s - %s"),
                iStream, (LPCTSTR)CDisp(pStreamInfo->m_refTimeStart),
                (LPCTSTR)CDisp(pStreamInfo->m_refTimeEnd)));
      }
    }
  }

  if(!DoVfwDwStartHack())
  {
    // adjust start time for each stream so that frame-based streams
    // start on frame boundaries. shortcut: just do the first
    // frame-based one
    for(iStream = 0; iStream < m_cStreams; iStream++)
    {
      StreamInfo *pStreamInfo = m_rgpStreamInfo[iStream];
      if(pStreamInfo->m_mt.majortype != MEDIATYPE_Audio)
      {
        REFERENCE_TIME rtDuration = pStreamInfo->ConvertTickToTime(1);
        REFERENCE_TIME rtRemainder = pStreamInfo->m_refTimeStart % rtDuration;
        if(rtRemainder != 0)
        {
          for(UINT iStream = 0; iStream < m_cStreams; iStream++)
          {
            StreamInfo *pStreamInfo = m_rgpStreamInfo[iStream];
            pStreamInfo->m_refTimeStart += (rtDuration - rtRemainder);
            pStreamInfo->m_refTimeEnd += (rtDuration - rtRemainder);
          }
        }

        break;
      }
    }
  }
  else
  {
    // Undo some of what we did above and make the earliest audio
    // stream start at zero and record any video frames we have to
    // delete.

    StreamInfo *pStreamInfoAudio = 0;

    for(iStream = 0; iStream < m_cStreams; iStream++)
    {
      StreamInfo *pStreamInfo = m_rgpStreamInfo[iStream];
      if(pStreamInfo->m_mt.majortype == MEDIATYPE_Audio) {
        if(pStreamInfoAudio != 0) {

          // no point fixing one audio stream if we can't fix them
          // all.
          pStreamInfoAudio = 0;
          break;
        }
        else
        {
          pStreamInfoAudio = pStreamInfo;
        }
      }
    }
    if(pStreamInfoAudio)   // found exactly one audio stream
    {
      REFERENCE_TIME llAudioOffset = pStreamInfoAudio->m_refTimeStart;
      if(llAudioOffset != 0)
      {
        for(iStream = 0; iStream < m_cStreams; iStream++)
        {
          ASSERT(pStreamInfoAudio->m_cInitialFramesToDelete == 0);
          StreamInfo *pStreamInfo = m_rgpStreamInfo[iStream];
          if(pStreamInfo->m_refTimeStart >= llAudioOffset)
          {
            pStreamInfo->m_refTimeStart -= llAudioOffset;
            pStreamInfo->m_refTimeEnd -= llAudioOffset;
          }
          else
          {
            if(pStreamInfo->m_mt.majortype != MEDIATYPE_Audio) {
              pStreamInfo->m_refTimeStart -= llAudioOffset;
              pStreamInfo->m_refTimeEnd -= llAudioOffset;
              ASSERT(pStreamInfo->m_refTimeStart < 0);

              // !!! always rounding down
              pStreamInfo->m_cInitialFramesToDelete =
                pStreamInfo->ConvertTimeToTick(-pStreamInfo->m_refTimeStart.GetUnits());

              // deleting more frames than there are?
              pStreamInfo->m_cInitialFramesToDelete =
                min(pStreamInfo->m_cInitialFramesToDelete, pStreamInfo->m_cSamples);

              // this frame-based stream now starts at 0.
              pStreamInfo->m_refTimeStart = 0;

              pStreamInfo->m_mtStart += (LONGLONG)pStreamInfo->m_cInitialFramesToDelete;

            } // !audio
          } // stream starts before audio
        } // for
      } // audio starts after 0.
    } // found one audio stream
  }

  // fill in (strh) for each stream;
  for(iStream = 0; iStream < m_cStreams; iStream++)
  {
    StreamInfo *pStreamInfo = m_rgpStreamInfo[iStream];
    ASSERT(iStream == pStreamInfo->m_stream);
    AVISTREAMHEADER *pStrh = GetStrh(iStream);
    cSamplesAll += pStreamInfo->m_cSamples;

    pStrh->dwFlags = 0;
    pStrh->wPriority = 0;
    pStrh->wLanguage = 0;
    pStrh->dwInitialFrames = 0;
    pStrh->dwSuggestedBufferSize = pStreamInfo->m_cbLargestChunk + sizeof(RIFFCHUNK);

    ASSERT(pStreamInfo->m_refTimeStart >= 0);

    if(pStreamInfo->m_mtStart != -1)
      ASSERT(pStreamInfo->m_mt.majortype != MEDIATYPE_Audio);

    pStrh->dwStart = (DWORD)(pStreamInfo->ConvertTimeToTick(
        pStreamInfo->m_refTimeStart.GetUnits()));

    if(pStreamInfo->m_mt.majortype == MEDIATYPE_Video &&
       pStreamInfo->m_mt.formattype == FORMAT_VideoInfo)
    {
      VIDEOINFO *pvi = (VIDEOINFO *)(pStreamInfo->m_mt.Format());
      pStrh->fccHandler = MpVideoGuidSubtype_Fourcc(pStreamInfo->m_mt.Subtype());
      pStrh->fccType = FCC('vids');

      pStrh->dwLength = pStreamInfo->m_cSamples - pStreamInfo->m_cInitialFramesToDelete;
      SetFrameRateAndScale(pStrh, pStreamInfo, dScaleMasterStream);
      pStrh->dwQuality = 0;
      pStrh->dwSampleSize = 0;
      pStrh->rcFrame.left = (short)pvi->rcSource.left;
      pStrh->rcFrame.top = (short)pvi->rcSource.top;
      pStrh->rcFrame.right = (short)pvi->rcSource.right;
      pStrh->rcFrame.bottom = (short)pvi->rcSource.bottom;
    }
    else if(pStreamInfo->m_mt.majortype == MEDIATYPE_Audio &&
            pStreamInfo->m_mt.formattype == FORMAT_WaveFormatEx)
    {
      pStrh->fccType = FCC('auds');
      pStrh->fccHandler = 0;
      WAVEFORMATEX *pwfe = (WAVEFORMATEX *)pStreamInfo->m_mt.Format();
      pStrh->dwScale = pwfe->nBlockAlign;

      if(m_lMasterStream != -1 && (long)iStream != m_lMasterStream)
      {
        const DWORD dwNewSps = (DWORD)(pwfe->nSamplesPerSec / dScaleMasterStream);
        DbgLog((LOG_TRACE, 2, TEXT("avimux: adjusting audio from %d to %d"),
                pwfe->nSamplesPerSec, dwNewSps));
        pwfe->nSamplesPerSec = dwNewSps;
        pwfe->nAvgBytesPerSec = (DWORD)(pwfe->nAvgBytesPerSec / dScaleMasterStream);
      }
      pStrh->dwRate = pwfe->nAvgBytesPerSec;

      DbgLog((LOG_TRACE, 5, TEXT("avimux: audio: dwScale %d, dwRate %d"),
              pStrh->dwScale, pStrh->dwRate));
      DbgLog((LOG_TRACE, 5, TEXT("nSamplesPerSec %d, nAvgBytesPerSec %d, nBlockAlign %d"),
              pwfe->nSamplesPerSec, pwfe->nAvgBytesPerSec, pwfe->nBlockAlign));


      pStrh->dwLength = ((CAudioStream *)(pStreamInfo))->
          GetTicksInSample(pStreamInfo->m_dwlcBytes);

      pStrh->dwQuality = 0;
      pStrh->dwSampleSize = pwfe->nBlockAlign;
      pStrh->rcFrame.left = 0;
      pStrh->rcFrame.top = 0;
      pStrh->rcFrame.right = 0;
      pStrh->rcFrame.bottom = 0;
    }
    else
    {
      // assume it's something frame based

      // we only connect with mediatypes made from fourccs
      ASSERT(FOURCCMap(pStreamInfo->m_mt.majortype.Data1) == pStreamInfo->m_mt.majortype ||
             pStreamInfo->m_mt.majortype == MEDIATYPE_AUXLine21Data);

      if(pStreamInfo->m_mt.majortype != MEDIATYPE_AUXLine21Data) {
          pStrh->fccType = pStreamInfo->m_mt.majortype.Data1;
      } else {
          pStrh->fccType = FCC('al21');
      }

      if(FOURCCMap(pStreamInfo->m_mt.subtype.Data1) ==
         pStreamInfo->m_mt.subtype)
      {
        pStrh->fccHandler = pStreamInfo->m_mt.subtype.Data1;
      }
      else
      {
        pStrh->fccHandler = 0;
      }

      pStrh->dwLength = pStreamInfo->m_cSamples -
        pStreamInfo->m_cInitialFramesToDelete;
      SetFrameRateAndScale(pStrh, pStreamInfo, dScaleMasterStream);
    }

    // we got more samples than we expected.
    if(pStrh->dwLength > pStreamInfo->m_cTicksExpected &&
       pStreamInfo->m_cTicksExpected != 0)
    {
      DbgLog((LOG_TRACE, 1, TEXT("upstream filter lied about duration")));
    }

#ifdef DEBUG
    if(pStreamInfo->m_refTimeEnd != pStreamInfo->m_refTimeStart )
    {
      // I see a divide by zero if I do this all at once
      LONGLONG llRate = pStrh->dwLength * UNITS;
      llRate /= (pStreamInfo->m_refTimeEnd - pStreamInfo->m_refTimeStart);
      llRate /= MILLISECONDS;
      DbgLog((LOG_TRACE, 2, TEXT("stream %d: actual rate = %d mHz"),
              iStream, (long)(llRate)));
    }
#endif

  } // for loop

  // used to erase files that can't be played back
  if(cSamplesAll == 0) {
      return HRESULT_FROM_WIN32(ERROR_EMPTY);
  }

  return S_OK;
}

HRESULT CAviWrite::CloseStreamName()
{
    for(UINT iStream = 0; iStream < m_cStreams; iStream++)
    {
      StreamInfo *pStreamInfo = m_rgpStreamInfo[iStream];
      if(pStreamInfo->m_szStrn) {
          lstrcpyA((char *)(m_rgbHeader + pStreamInfo->m_posStrn),
                   pStreamInfo->m_szStrn);
      }
    }

    return S_OK;
}

void CAviWrite::SetFrameRateAndScale(
  AVISTREAMHEADER *pStrh,
  StreamInfo *pSi,
  double dScaleMasterStream)
{
  REFERENCE_TIME rtDuration = pSi->ConvertTickToTime(1);
  if(m_lMasterStream == -1 ||
     m_lMasterStream == (long)pSi->m_stream ||
     dScaleMasterStream == 1 ||
     pStrh->dwLength == 0       // check for divide by zero.
     )
  {

    // recognize standard rates and cook into known rationals. handle
    // the source rounding fractions up or down. Also handle the user
    // typing 29.97fps vs a source file which recorded 30000/1001 fps
    switch(rtDuration)
    {
      case 333666:
      case 333667:
        // 29.97fps (1e7 / (30000 / 1001) = 333666.666667 units, 1e7 / 29.97 = 333667.000334)
        pStrh->dwScale = 1001;
        pStrh->dwRate = 30000;
        DbgLog((LOG_TRACE, 3, TEXT("avimux: cooked rate 29.97")));
        break;

      case 416666:
      case 416667:
        // 24.00 (416666.666667)
        pStrh->dwScale = 1;
        pStrh->dwRate = 24;
        DbgLog((LOG_TRACE, 3, TEXT("avimux: cooked rate 24")));
        break;

      case 667333:
      case 667334:              // this number was wrong previously
        // 14.985 (667333.333334 or 667334.000667)
        pStrh->dwScale = 1001;
        pStrh->dwRate = 15000;
        DbgLog((LOG_TRACE, 3, TEXT("avimux: cooked rate 14.985")));
        break;

      case 666666:
      case 666667:
        // 15.000 (666666.666667)
        pStrh->dwScale = 1;
        pStrh->dwRate = 15;
        break;

      default:
        pStrh->dwScale = (DWORD)rtDuration;
        pStrh->dwRate = UNITS;
        DbgLog((LOG_TRACE, 3, TEXT("avimux: uncooked rate %d units"),
                (DWORD)(rtDuration)));
        break;
    }
  }
  else
  {
      // pStrh->dwLength checked for 0 above
      pStrh->dwScale = (DWORD)((pSi->m_refTimeEnd - pSi->m_refTimeStart) / pStrh->dwLength );
      DbgLog((LOG_TRACE, 2, TEXT("avimux: adjusted rate from %d to %d"),
              (DWORD)rtDuration, pStrh->dwScale));
      pStrh->dwRate = UNITS;
  }
}

// ------------------------------------------------------------------------
// fill in the strf values. can be called before or after running.

HRESULT CAviWrite::CloseStreamFormat()
{
  // fill in (strf) for each stream;
  for(unsigned i = 0; i < m_cStreams; i++)
  {
    StreamInfo *pStreamInfo = m_rgpStreamInfo[i];
    if(pStreamInfo->m_mt.majortype == MEDIATYPE_Video &&
       pStreamInfo->m_mt.formattype == FORMAT_VideoInfo)
    {
      VIDEOINFO *pvi = (VIDEOINFO *)(pStreamInfo->m_mt.Format());
      CopyMemory(GetStrf(i),
                 &pvi->bmiHeader,
                 pStreamInfo->m_cbStrf);
    }
    else
    {
      CopyMemory(
        GetStrf(i),
        pStreamInfo->m_mt.Format(),
        pStreamInfo->m_cbStrf);
    }
  }

  return S_OK;
}

// ------------------------------------------------------------------------
// CloseIndex. flushes sub indexes and propagates sub indexes up so
// they are before the data they index. also builds idx1 index.
//

HRESULT CAviWrite::CloseIndex()
{
  HRESULT hr;

  if(hr = m_pAllocator->Decommit(), FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2,  TEXT("CAviWrite::CloseIndex: decommit failed.")));
    return hr;
  }

  // this moves the index chunks and builds the old index
  if(hr = BuildIdx1(), FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2,  TEXT("CAviWrite::CloseIndex: BuildIdx1 failed.")));
    return hr;
  }

  return S_OK;
}

// ------------------------------------------------------------------------

HRESULT CAviWrite::CloseOuterRiff()
{
  HRESULT hr;

  ASSERT(m_cOutermostRiff < C_OUTERMOST_RIFF);

  //
  // fill in first RIFF-AVI_, LIST-movi pair
  //
  DWORD dwSize;
  if(m_cOutermostRiff == 0)
  {
    ASSERT(m_dwlFilePos <= MAXDWORD);
    dwSize = (DWORD)m_dwlFilePos;
  }
  else
  {
    dwSize = m_rgOutermostRiff[0].size;
  }

  ASSERT(m_bOutputIdx1 || m_cbIdx1 == 0);
  m_pAvi_->cb = dwSize - 0 - sizeof(RIFFCHUNK);
  m_pMovi->cb = (DWORD)(dwSize - ((BYTE *)m_pMovi - m_rgbHeader) - sizeof(RIFFCHUNK) - m_cbIdx1);

  ASSERT((sizeof(RIFFLIST) * 2 + sizeof(RIFFCHUNK)) % sizeof(DWORD) == 0);
  DWORD rgdw[(sizeof(RIFFLIST) * 2 + sizeof(RIFFCHUNK)) / sizeof(DWORD)];
  RIFFLIST *pRiffListRIFF = (RIFFLIST *)rgdw;
  RIFFLIST *pRiffListMOVI = pRiffListRIFF + 1;
  RIFFCHUNK *pRiffChunkJUNK = (RIFFCHUNK *)(pRiffListMOVI + 1);

  //
  // rest of the RIFF-AVI_ lists
  //
  for(unsigned i = 1; i <= m_cOutermostRiff; i++)
  {
    SizeAndPosition& rSap = m_rgOutermostRiff[i];
    pRiffListRIFF->fcc = FCC('RIFF');
    if(i == m_cOutermostRiff)
    {
      ASSERT(m_dwlFilePos - m_dwlCurrentRiffAvi_ <= MAXDWORD);
      pRiffListRIFF->cb = (DWORD)(m_dwlFilePos - m_dwlCurrentRiffAvi_) - sizeof(RIFFCHUNK);
    }
    else
    {
      ASSERT(rSap.pos % m_cbAlign == 0);
      pRiffListRIFF->cb = rSap.size - sizeof(RIFFCHUNK);
    }
    pRiffListRIFF->fccListType = FCC('AVIX');

    pRiffListMOVI->fcc = FCC('LIST');
    pRiffListMOVI->cb = pRiffListRIFF->cb - sizeof(FOURCC) - sizeof(RIFFCHUNK);
    pRiffListMOVI->fccListType = FCC('movi');

    ULONG cb = 2 * sizeof(RIFFLIST);
    AddJunk(cb, m_cbAlign, (BYTE *)rgdw);
    if(cb > sizeof(rgdw))
      cb = sizeof(rgdw);

    DWORDLONG dwlPos;
    if(i == m_cOutermostRiff)
      dwlPos = m_dwlCurrentRiffAvi_;
    else
      dwlPos = rSap.pos;

    hr = IStreamWrite(dwlPos, (BYTE*)rgdw, cb);
    if(FAILED(hr))
    {
      DbgLog(( LOG_ERROR, 2,
               TEXT("CAviWrite::CloseOuterRiff: SynchronousWrite failed.")));
      return hr;
    }
  }

  return S_OK;
}

// ------------------------------------------------------------------------
// BuildIdx1. creates the idx1 chunk in memory if necessary and
// propagates the sub index chunks

HRESULT CAviWrite::BuildIdx1()
{
  HRESULT hr;
  ULONG iIdx1 = 0;

  if(!m_bOutputIdx1)
  {
    ASSERT(!DoVfwDwStartHack());
    //
    // just propagate the sub index chunks
    //
    for(unsigned iStream = 0; iStream < m_cStreams; iStream++)
    {
      StreamInfo *pSi = m_rgpStreamInfo[iStream];
      CWalkIndex *pWalkIndex = new CWalkIndex(this, pSi);
      if(pWalkIndex == 0)
        return E_OUTOFMEMORY;

      if((hr = pWalkIndex->Init(), FAILED(hr)) ||
         (hr = pWalkIndex->Close(), FAILED(hr)))
      {
        DbgLog(( LOG_ERROR, 2,
                 TEXT("CAviWrite::BuildIdx1: CWalkIndex failed.")));
        delete pWalkIndex;
        return hr;
      }

      delete pWalkIndex;
    }
    return S_OK;
  } // !m_bOutputIdx1

  ASSERT(m_bOutputIdx1);

  hr = S_OK;

  if(m_cbIdx1 == 0)
    AllocateIdx1(FALSE);

  AVIOLDINDEX *pIdx1 = (AVIOLDINDEX *)new BYTE[m_cbIdx1];
  if (NULL == pIdx1) {
      return E_OUTOFMEMORY;
  }
  ZeroMemory(pIdx1, m_cbIdx1);
  CWalkIndex *rgpWalkIndex[C_MAX_STREAMS];
  unsigned iStream;
  ULONG iSample;

  for(iStream = 0; iStream < m_cStreams; iStream++)
    rgpWalkIndex[iStream] = 0;

  for(iStream = 0; iStream < m_cStreams; iStream++)
  {
    rgpWalkIndex[iStream] = new CWalkIndex(this, m_rgpStreamInfo[iStream]);
    if(rgpWalkIndex[iStream] == 0)
    {
      hr = E_OUTOFMEMORY;
      goto Done;
    }
    if(hr = rgpWalkIndex[iStream]->Init(), FAILED(hr))
    {
      DbgLog(( LOG_ERROR, 2,
               TEXT("CAviWrite::BuildIdx1: CWalkIndex failed.")));
      goto Done;
    }
  }

  {
    ULONG cIdx1EntriesInitially = m_cIdx1Entries;
    if(DoVfwDwStartHack())
    {
      for(UINT iStream = 0; iStream < m_cStreams; iStream++)
      {
        StreamInfo *pSi = m_rgpStreamInfo[iStream];
        if(m_cIdx1Entries < pSi->m_cInitialFramesToDelete)
        {
          DbgBreak("internal error");
          return E_UNEXPECTED;
        }
        m_cIdx1Entries -= pSi->m_cInitialFramesToDelete;
      }
    }

    DbgLog((LOG_TRACE, 5,
            TEXT("avimux: BuildIdx1: %d idx1 entries (initially: %d)"),
            m_cIdx1Entries, cIdx1EntriesInitially));
  }

  for(iSample = 0; iSample < m_cIdx1Entries; iSample++)
  {
    // first entry is junk for compatibility with mciavi
    iIdx1 = iSample + 1;

    // bad way to check whether the index is full !!!
    if((BYTE*)&(pIdx1->aIndex[iIdx1 + 1]) > (BYTE*)pIdx1 + m_cbIdx1)
      break;

    unsigned nextStreamWithSample = C_MAX_STREAMS;
    DWORDLONG dwlNextSamplePos = 0;
    DWORD dwNextSampleSize = 0;
    BOOL bNextSampleIsSyncPoint = FALSE;

    // loop over streams to find next index entry (entry whose sample
    // is earliest in the file)
    for(iStream = 0; iStream < m_cStreams; iStream++)
    {
      DWORD dwSize;
      DWORDLONG dwlPos;
      BOOL bSyncPoint;

      HRESULT hr = rgpWalkIndex[iStream]->Peek(&dwlPos, &dwSize, &bSyncPoint);
      if(SUCCEEDED(hr) &&
         (nextStreamWithSample == C_MAX_STREAMS || dwlPos < dwlNextSamplePos))
      {
        nextStreamWithSample = iStream;
        dwlNextSamplePos = dwlPos;
        dwNextSampleSize = dwSize;
        bNextSampleIsSyncPoint = bSyncPoint;
      }
    }

    // didn't find an entry
    if(nextStreamWithSample == C_MAX_STREAMS)
    {
      DbgBreak("internal error");
      hr = E_UNEXPECTED;
      goto Done;
    }
    else
    {
      DbgLog((LOG_TRACE, 0x20,
              TEXT("avimux:BuildIdx1: idx1 entry: %d, stream: %d, pos: %08x"),
              iIdx1, nextStreamWithSample, (DWORD)dwlNextSamplePos));
    }

    rgpWalkIndex[nextStreamWithSample]->Advance();

    pIdx1->aIndex[iIdx1].dwChunkId = bNextSampleIsSyncPoint ?
      m_rgpStreamInfo[nextStreamWithSample]->m_moviDataCkid :
      m_rgpStreamInfo[nextStreamWithSample]->m_moviDataCkidCompressed;

    pIdx1->aIndex[iIdx1].dwFlags = bNextSampleIsSyncPoint ?
      AVIIF_KEYFRAME :
      0;

    if(dwlNextSamplePos >= m_cbRiffMax)
    {
      DbgBreak("avimux: unexpected error");
      hr = E_UNEXPECTED;
      goto Done;
    }

    pIdx1->aIndex[iIdx1].dwOffset = (DWORD)dwlNextSamplePos - sizeof(RIFFCHUNK);

    bool fDbgSawFirstNonDropFrame = false;

    // work around vfw hang by specifying non-zero offset for drop
    // frames. only drop frames have dwSize==0, and I make sure all
    // drop frames have non-zero byte offsets. note vfw actually puts
    // the drop frame in the movi chunk as well, but we don't
    if(dwNextSampleSize == 0 && iIdx1 > 1)
    {
        if(fDbgSawFirstNonDropFrame) {
            ASSERT(pIdx1->aIndex[iIdx1].dwOffset == 0);
            ASSERT(pIdx1->aIndex[iIdx1 - 1].dwOffset != 0);
        }

        pIdx1->aIndex[iIdx1].dwOffset = pIdx1->aIndex[iIdx1 - 1].dwOffset;
    }
    if(dwNextSampleSize != 0) {
        fDbgSawFirstNonDropFrame = true;
    }

    if(fDbgSawFirstNonDropFrame) {
        ASSERT(pIdx1->aIndex[iIdx1].dwOffset != 0);
    }

    pIdx1->aIndex[iIdx1].dwSize = dwNextSampleSize;

  }

  // mark the remaining index entries invalid.
  while((BYTE*)&(pIdx1->aIndex[++iIdx1 + 1]) <= (BYTE*)pIdx1 + m_cbIdx1)
    pIdx1->aIndex[iIdx1].dwChunkId = FCC('7Fxx');


  pIdx1->fcc = FCC('idx1');
  pIdx1->cb = m_cbIdx1 - sizeof(RIFFCHUNK);

  pIdx1->aIndex[0].dwChunkId = FCC('7Fxx');
  pIdx1->aIndex[0].dwFlags = 0;
  pIdx1->aIndex[0].dwOffset = (DWORD)((BYTE*)m_pMovi - m_rgbHeader + sizeof(RIFFLIST));
  pIdx1->aIndex[0].dwSize = 0;

  hr = IStreamWrite(m_posIdx1, (BYTE*)pIdx1, m_cbIdx1);
  if(FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviWrite::BuildIdx1: SynchronousWrite failed.")));
    goto Done;
  }

Done:

  //
  // finish propagating the index / close them.
  //

  HRESULT hrClose = S_OK;
  for(iStream = 0; iStream < m_cStreams; iStream++)
  {
    if(rgpWalkIndex[iStream])
    {
      if(hrClose = rgpWalkIndex[iStream]->Close(), FAILED(hrClose))
      {
        DbgLog(( LOG_ERROR, 2,
                 TEXT("CAviWrite::BuildIdx1: CWalkIndex close failed.")));
      }
      delete rgpWalkIndex[iStream];
    }
  }
  delete pIdx1;

  return FAILED(hr) ? hr : hrClose;
}

// ------------------------------------------------------------------------
// return pointers to stream header and format structures

AVISTREAMHEADER *CAviWrite::GetStrh(unsigned stream)
{
  ASSERT(stream < m_cStreams);
  return (AVISTREAMHEADER *)
    (m_rgbHeader + m_rgpStreamInfo[stream]->m_posStrl + sizeof(RIFFLIST));
}

BYTE *CAviWrite::GetStrf(unsigned stream)
{
    ASSERT(stream < m_cStreams);
    ASSERT(m_rgpStreamInfo[stream]->m_posStrl +
           sizeof(RIFFLIST) +          // strl
           sizeof(AVISTREAMHEADER)     // strh
           == m_rgpStreamInfo[stream]->m_posStrf);
  
    return m_rgbHeader +
        m_rgpStreamInfo[stream]->m_posStrl +
        sizeof(RIFFLIST) +          // strl
        sizeof(AVISTREAMHEADER) +   // strh
        sizeof(RIFFCHUNK);          // strf RIFFCHUNK
}

AVIMETAINDEX *CAviWrite::GetIndx(unsigned stream)
{
  ASSERT(stream < m_cStreams);
  return (AVIMETAINDEX *)(m_rgbHeader + m_rgpStreamInfo[stream]->m_posIndx);
}

// ------------------------------------------------------------------------
// load a new indx entry and set initial values

HRESULT CAviWrite::InitIx(unsigned stream)
{
  StreamInfo &rStreamInfo = *(m_rgpStreamInfo[stream]);
  // !!! the critsec is locked. not really a problem if getbuffer
  // blocks, but probably better if this is done outside
  HRESULT hr = m_pAllocator->GetBuffer(&rStreamInfo.m_pSampleStdIx, 0, 0, 0);
  if(FAILED(hr))
    return hr;
  ASSERT(rStreamInfo.m_pSampleStdIx != 0);

  if(m_IlMode == INTERLEAVE_FULL)
  {
    BYTE *pbIx;
    rStreamInfo.m_pSampleStdIx->GetPointer(&pbIx);
    ZeroMemory(pbIx, rStreamInfo.m_pSampleStdIx->GetSize());
  }

  AVISTDINDEX *pStdIndx = GetCurrentIx(stream);

  rStreamInfo.m_cIx++;

  pStdIndx->fcc = FCC('ix00');
  Hexrg2bFromW((BYTE*)&pStdIndx->fcc + 2, stream);

  pStdIndx->cb = cbSubIndex(rStreamInfo.m_cEntriesSubIndex) - sizeof(RIFFCHUNK);
  pStdIndx->wLongsPerEntry = sizeof(AVISTDINDEX_ENTRY) / sizeof(LONG);
  pStdIndx->bIndexSubType = 0;
  pStdIndx->bIndexType = AVI_INDEX_OF_CHUNKS;
  pStdIndx->nEntriesInUse = 0;
  pStdIndx->dwChunkId = rStreamInfo.m_moviDataCkid;
  pStdIndx->qwBaseOffset = 0;
  pStdIndx->dwReserved_3 = 0;

  return S_OK;
}

ULONG CAviWrite::GetIndexSize(AVIMETAINDEX *pIndex)
{
  ULONG cb = (ULONG)((BYTE *)pIndex->adwIndex - (BYTE *)pIndex);
  cb += pIndex->wLongsPerEntry * sizeof(DWORD) * pIndex->nEntriesInUse;
  return cb;
}

AVISTDINDEX *CAviWrite::GetCurrentIx(unsigned stream)
{
  AVISTDINDEX *pStdIndx;
  HRESULT hr = m_rgpStreamInfo[stream]->m_pSampleStdIx->GetPointer((BYTE**)&pStdIndx);
  ASSERT(SUCCEEDED(hr));
  return pStdIndx;
}

// ------------------------------------------------------------------------
// aligns the end of a chunk.

void CAviWrite::AddJunk(DWORD& rdwSize, DWORD dwAlign, BYTE *pb)
{
  // RIFF requires new chunks to start on WORD boundaries. implicitly
  // requiring an extra byte after the sample.
  if(rdwSize % sizeof(WORD) != 0)
    rdwSize ++;

  if(rdwSize % dwAlign != 0)
  {
    WORD *pw = (WORD *)(pb + rdwSize);

    rdwSize += sizeof(RIFFCHUNK);
    DWORD cb = 0;

    if(rdwSize % dwAlign != 0)
    {
      cb = dwAlign - rdwSize % dwAlign;
      rdwSize += cb;
    }

    const DWORD dwJunk = FCC('JUNK');

    *pw++ = ((WORD*)&dwJunk)[0];
    *pw++ = ((WORD*)&dwJunk)[1];
    *pw++ = ((WORD*)&cb)[0];
    *pw   = ((WORD*)&cb)[1];
  }

  ASSERT(rdwSize % dwAlign == 0);
}

// ------------------------------------------------------------------------
// used when there is not enough room for the junk chunk in this
// buffer

void CAviWrite::AddJunkOtherAllocator(
  DWORD& rdwSize,
  DWORD dwAlign,
  BYTE *pb,
  IMediaSample *pSample,
  BYTE **ppJunkSector)
{
  *ppJunkSector = 0;
  // RIFF requires new chunks to start on WORD boundaries
  if(rdwSize % sizeof(WORD) != 0)
    rdwSize ++;

  if(rdwSize % dwAlign != 0)
  {
    ASSERT(m_cbAlign != 1);
    WORD *pw = (WORD *)(pb + rdwSize);

    rdwSize += sizeof(RIFFCHUNK);
    DWORD dwOriginalSize = rdwSize;
    DWORD cb = 0;

    if(rdwSize % dwAlign != 0)
    {
      cb = dwAlign - rdwSize % dwAlign;
      rdwSize += cb;
    }

    const DWORD dwJunk = FCC('JUNK');
    ASSERT((pSample->GetSize() + m_cbPrefix) % m_cbAlign == 0);
    long cbDiff = pSample->GetSize() + m_cbPrefix - dwOriginalSize;
    if(cbDiff >= 0)
    {
      *pw++ = ((WORD*)&dwJunk)[0];
      *pw++ = ((WORD*)&dwJunk)[1];
      *pw++ = ((WORD*)&cb)[0];
      *pw   = ((WORD*)&cb)[1];
    }
    else
    {
      ASSERT(-cbDiff % 2 == 0);
      rdwSize = pSample->GetSize() + m_cbPrefix;
      switch(cbDiff)
      {
        case -6:
          *pw = ((WORD*)&dwJunk)[0];
          *ppJunkSector = m_rgpbJunkSector[0];
          break;

        case -4:
          *pw++ = ((WORD*)&dwJunk)[0];
          *pw   = ((WORD*)&dwJunk)[1];
          *ppJunkSector = m_rgpbJunkSector[1];
          break;

        case -2:
          *pw++ = ((WORD*)&dwJunk)[0];
          *pw++ = ((WORD*)&dwJunk)[1];
          *pw   = ((WORD*)&cb)[0];
          *ppJunkSector = m_rgpbJunkSector[2];
          break;

        default:
          DbgBreak("unexpected error w/ JUNK chunks.");
      }
    }
  }

  ASSERT(rdwSize % dwAlign == 0);
}

ULONG CAviWrite::GetCbJunk(DWORD dwSize, DWORD dwAlign)
{
  if(dwSize % dwAlign != 0)
  {
    dwSize += sizeof(RIFFCHUNK);
    if(dwSize % dwAlign != 0)
    {
      dwSize += dwAlign - dwSize % dwAlign;
    }
  }

  return dwSize;
}

void CAviWrite::SetList(void *pList, FOURCC ckid, DWORD dwSize, FOURCC listid)
{
  DbgAssertAligned( pList, sizeof(DWORD) );
  ((RIFFLIST *)pList)->fcc = ckid;
  ((RIFFLIST *)pList)->cb = dwSize;
  ((RIFFLIST *)pList)->fccListType = listid;

}

void CAviWrite::SetChunk(void *pChunk, FOURCC ckid, DWORD dwSize)
{
  DbgAssertAligned(pChunk, sizeof(DWORD) );
  ((RIFFCHUNK *)pChunk)->fcc = ckid;
  ((RIFFCHUNK *)pChunk)->cb = dwSize;
}

// ------------------------------------------------------------------------
// update index for new sample

HRESULT CAviWrite::IndexSample(
  unsigned stream,
  DWORDLONG dwlPos,
  ULONG ulSize,
  BOOL bSyncPoint)
{
  HRESULT hr = S_OK;

  ASSERT(stream < m_cStreams);
  StreamInfo &rStreamInfo = *(m_rgpStreamInfo[stream]);
  AVISTDINDEX *pStdIndx = GetCurrentIx(stream);

  // update subindex
  DbgLog((LOG_TRACE, 0x20,
          TEXT("avimux::IndexSample: stream %d: subindex offset %d"),
          rStreamInfo.m_stream, pStdIndx->nEntriesInUse));
  if(pStdIndx->nEntriesInUse >= rStreamInfo.m_cEntriesSubIndex)
  {
    DbgBreak("problem counting index entries");
    return E_UNEXPECTED;
  }

  if(pStdIndx->qwBaseOffset == 0) {
      pStdIndx->qwBaseOffset = dwlPos;
  }

  // dwlPos can be 0 for dropped frames and this underflows
  DWORDLONG dwlOffsetFromBase = (dwlPos - pStdIndx->qwBaseOffset + sizeof(RIFFCHUNK));
  if(dwlPos == 0)
  {
      dwlOffsetFromBase = 0;

      // should happen for dropped frames only
      ASSERT(ulSize == 0);
  }
  else if(dwlOffsetFromBase > CB_SUBINDEX_OVERFLOW)
  {
      DbgBreak("subindex overflow error");
  }

  AVISTDINDEX_ENTRY *aIndex = &pStdIndx->aIndex[pStdIndx->nEntriesInUse++];
  aIndex->dwOffset = (DWORD)(dwlOffsetFromBase);
  aIndex->dwSize = ulSize;

  if(!bSyncPoint)
    aIndex->dwSize |= AVISTDINDEX_DELTAFRAME;

  if(m_bOutputIdx1 && m_cOutermostRiff == 0)
  {
    ASSERT(m_dwlFilePos <= m_cbRiffMax);
    m_cIdx1Entries++;

    ASSERT(m_dwlFilePos % m_cbAlign == 0);
  }

  // if index entry is full, write it out and allocate a new one.
  if(pStdIndx->nEntriesInUse >= rStreamInfo.m_cEntriesSubIndex)
  {
    hr = DoFlushIndex(rStreamInfo);
  }

  return hr;
}

// a subindex can only index data that spans 4gb because it uses a 32
// bit integer. if we are about to exceed the 4gb limit, flush the
// subindex and start a new one.
//
HRESULT CAviWrite::HandleSubindexOverflow(
  unsigned stream)
{
    HRESULT hr = S_OK;
    ASSERT(stream < m_cStreams);
    StreamInfo &rStreamInfo = *(m_rgpStreamInfo[stream]);
    AVISTDINDEX *pStdIndx = GetCurrentIx(stream);

    // dwlPos cannot be 0 because we don't call this function for
    // dropped frames.
    ASSERT(m_dwlFilePos != 0);

    if(pStdIndx->qwBaseOffset != 0)
    {
        DWORDLONG dwlOffsetFromBase = (m_dwlFilePos - pStdIndx->qwBaseOffset +
                                       sizeof(RIFFCHUNK));

        if(dwlOffsetFromBase > CB_SUBINDEX_OVERFLOW)
        {
            DbgLog((LOG_TRACE, 1, TEXT("subindex overflow.")));
            hr = DoFlushIndex(rStreamInfo);
        }
    }

    return hr;
}

HRESULT CAviWrite::DoFlushIndex(StreamInfo &rStreamInfo)
{
    HRESULT hr = S_OK;


    // write out this one and create a new one.
    hr = FlushIx(rStreamInfo.m_stream);
    if(hr != S_OK)
        return hr;

    hr = InitIx(rStreamInfo.m_stream);
    if(FAILED(hr))
        return hr;


    return hr;
}

void CAviWrite::AllocateIdx1(BOOL bStreaming)
{
  DWORD dwIdx1Size = sizeof(AVIOLDINDEX);
  ASSERT(dwIdx1Size == 8);
  dwIdx1Size += m_cIdx1Entries * sizeof(AVIOLDINDEX::_avioldindex_entry);
  // first entry is used for relative index
  dwIdx1Size += sizeof(AVIOLDINDEX::_avioldindex_entry);
  dwIdx1Size = GetCbJunk(dwIdx1Size, m_cbAlign);

  ASSERT(m_dwlFilePos < MAXDWORD);
  ASSERT(m_dwlFilePos % sizeof(WORD) == 0);
  m_posIdx1 = (ULONG)(m_dwlFilePos);
  m_cbIdx1 = dwIdx1Size;

  m_dwlFilePos += dwIdx1Size;

  if(bStreaming)
  {
    DbgCheckFilePos();
  }
}


// ------------------------------------------------------------------------
// start a new RIFF chunk if necessary. Save size and position of the
// the previous one.

HRESULT CAviWrite::NewRiffAvi_()
{
  DWORDLONG cbRiff = m_dwlFilePos - m_dwlCurrentRiffAvi_ + CB_NEW_RIFF_PADDING;
  if(cbRiff >= m_cbRiffMax ||
     (m_cOutermostRiff == 0 &&
      m_bOutputIdx1 &&
      cbRiff + m_cIdx1Entries * sizeof(AVIOLDINDEX::_avioldindex_entry) >= m_cbRiffMax)
     )
  {
    if(m_bOutputIdx1 && m_cbIdx1 == 0)
      AllocateIdx1(TRUE);

    m_rgOutermostRiff[m_cOutermostRiff].pos = m_dwlCurrentRiffAvi_;
    m_rgOutermostRiff[m_cOutermostRiff].size =
      (DWORD)(m_dwlFilePos - m_dwlCurrentRiffAvi_);

    m_dwlCurrentRiffAvi_ = m_dwlFilePos;

    ULONG seek = 2 * sizeof(RIFFLIST);
    m_dwlFilePos += 2 * sizeof(RIFFLIST);
    if(m_dwlFilePos % m_cbAlign != 0)
    {
      if(m_cbAlign - m_dwlFilePos % m_cbAlign < sizeof(RIFFCHUNK))
      {
        // space for JUNK chunk
        m_dwlFilePos += sizeof(RIFFCHUNK);
        seek += sizeof(RIFFCHUNK);
      }

      if(m_dwlFilePos % m_cbAlign != 0)
      {
        // padding for alignment
        seek +=  (ULONG)(m_cbAlign - m_dwlFilePos % m_cbAlign);
        m_dwlFilePos += m_cbAlign - m_dwlFilePos % m_cbAlign;
      }
    }

    DbgCheckFilePos();

    if(++m_cOutermostRiff >= C_OUTERMOST_RIFF)
    {
      DbgLog(( LOG_ERROR, 2,
               TEXT("CAviWrite::NewRiffAvi_: too many RIFF chunks.")));
      return VFW_E_BUFFER_OVERFLOW;
    }
  }

  return S_OK;
}

// update the super index to include the current index chunk at byte
// offset dwlPos.
//
HRESULT CAviWrite::UpdateSuperIndex(
  unsigned stream,
  DWORDLONG dwlPos)
{
  AVISUPERINDEX *pSuperIndx = (AVISUPERINDEX *)GetIndx(stream);
  DWORD &riEntry = pSuperIndx->nEntriesInUse;

  StreamInfo *pStreamInfo = m_rgpStreamInfo[stream];
  AVISTDINDEX *pStdIndx = GetCurrentIx(stream);

  ASSERT(riEntry < pStreamInfo->m_cEntriesSuperIndex);

  pSuperIndx->aIndex[riEntry].qwOffset = dwlPos;
  pSuperIndx->aIndex[riEntry].dwSize = pStdIndx->cb + sizeof(RIFFCHUNK);

  if(pStreamInfo->m_mt.majortype != MEDIATYPE_Audio)
  {
    pSuperIndx->aIndex[riEntry].dwDuration = GetCurrentIx(stream)->nEntriesInUse;
  }
  else
  {
    WAVEFORMATEX *pwfe = (WAVEFORMATEX *)pStreamInfo->m_mt.Format();

    ASSERT(pwfe->nBlockAlign != 0);
    ASSERT(pStreamInfo->m_dwlcBytes / pwfe->nBlockAlign <= MAXDWORD);

    DWORDLONG dwlcbWritten;
    pStreamInfo->GetCbWritten(&dwlcbWritten);

    pSuperIndx->aIndex[riEntry].dwDuration = ((CAudioStream *)pStreamInfo)->
        GetTicksInSample(dwlcbWritten - pStreamInfo->m_dwlcBytesLastSuperIndex);

    pStreamInfo->m_dwlcBytesLastSuperIndex = dwlcbWritten;
  }

  DbgLog((LOG_TRACE, 0x20,
          TEXT("avimux:UpdateSuperIndex: stream %d, entry %d, dwDuration %d"),
          pStreamInfo->m_stream, riEntry, pSuperIndx->aIndex[riEntry].dwDuration));

  // super index full?
  if(riEntry >= pStreamInfo->m_cEntriesSuperIndex)
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviWrite::UpdateSuperIndex: superindex full.")));
    return VFW_E_BUFFER_OVERFLOW;
  }


  riEntry++;

  return S_OK;
}


// ------------------------------------------------------------------------
// output the indx chunk to disk and update the super index

HRESULT CAviWrite::FlushIx(unsigned stream)
{
  HRESULT hr;

  ASSERT(stream < m_cStreams);
  StreamInfo &rStreamInfo = *(m_rgpStreamInfo[stream]);

  AVISTDINDEX *pStdIndx = GetCurrentIx(stream);

  // no reason to output an empty one
  ASSERT(pStdIndx->nEntriesInUse != 0);

  const ULONG cbThisSubIndex = cbSubIndex(rStreamInfo.m_cEntriesSubIndex);
  ASSERT(cbThisSubIndex % m_cbAlign == 0);
  pStdIndx->cb = cbThisSubIndex - sizeof(RIFFCHUNK);

  // when writing interlaved files, we don't want to propagate index
  // chunks back one because we write them in the right place
  const DWORDLONG dwlFileOffsetOfSubIndex = rStreamInfo.PrecomputedIndexSizes() ?
    rStreamInfo.m_dwlOffsetCurrentSubIndex :
    m_dwlFilePos;

  // !!!! we call UpdateSuperIndex before successfully writing out the
  // subindex chunk.
  if(hr = UpdateSuperIndex(stream, dwlFileOffsetOfSubIndex), FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviWrite::FlushIx:: UpdateSuperIndex failed.")));
    return hr;
  }

  // !!!! blocks with CritSec locked. will unblock when a disk write
  // completes....
  CSampSample *pSS;
  hr = m_pSampAlloc->GetBuffer(&pSS, 0, 0, 0);
  if(hr != S_OK)
    return S_FALSE;

  REFERENCE_TIME rtStart = dwlFileOffsetOfSubIndex;
  REFERENCE_TIME rtStop = rtStart + cbThisSubIndex;
  pSS->SetTime(&rtStart, &rtStop);
  BYTE *pb;
  hr = rStreamInfo.m_pSampleStdIx->GetPointer(&pb);
  ASSERT(hr == S_OK);

  pSS->SetSample(rStreamInfo.m_pSampleStdIx, pb, cbThisSubIndex);
  hr = m_pIMemInputPin->Receive(pSS);

  pSS->Release();
  if(hr != S_OK)
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviWrite::FlushIx: Write failed.")));
    return S_FALSE;
  }

  // delay releasing the sample to avoid crashes on failure. but there
  // are still other paths that can crash.
  rStreamInfo.m_pSampleStdIx->Release();
  rStreamInfo.m_pSampleStdIx = 0;

  rStreamInfo.m_dwlOffsetCurrentSubIndex = m_dwlFilePos;

  ULONG cbNextSubIndex = cbThisSubIndex;

  // leave space for the next index
  m_dwlFilePos += cbNextSubIndex;

  DbgCheckFilePos();

  return S_OK;
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// StreamInfo structure

CAviWrite::StreamInfo::StreamInfo(
  UINT iStream,
  UINT iPin,
  AviWriteStreamConfig *pAwsc,
  CAviWrite *pAviWrite,
  HRESULT *phr) :
    m_lIncoming(NAME("aviwrite - m_lIncoming"), 10)
{
  m_pin = C_MAX_STREAMS;
  m_posStrl = m_posIndx = m_cbStrf = m_cSamples = m_cIx = 0;
  m_dwlcBytes = 0;
  m_dwlcBytesLastSuperIndex = 0;
  m_cbLargestChunk = 0;
  m_pSampleStdIx = 0;
  m_cTicksPerChunk = 0;
  m_cTicksRemaining = 0;
  m_iCurrentTick = 0;
  m_posActiveStream = 0;
  m_cInitialFramesToDelete = 0;
  m_szStrn = 0;
  m_fEosSeen = FALSE;

  m_pin = iPin;
  m_mt = *pAwsc->pmt;
  m_fOurAllocator = pAwsc->fOurAllocator;
  m_cTicksExpected = pAwsc->cSamplesExpected;
  m_stream = iStream;
  m_pAviWrite = pAviWrite;

  m_mtEnd = -1;
  m_mtStart = -1;               // not necessary?

  if(pAwsc->szStreamName)
  {
      int cch = lstrlenA(pAwsc->szStreamName) + 1;
      m_szStrn = new char[cch];
      if(m_szStrn) {
          CopyMemory(m_szStrn, pAwsc->szStreamName, cch);
      } else {
          *phr = E_OUTOFMEMORY;
      }
  }


#ifdef PERF
  char buf[30];
  lstrcpy(buf, "avimux recv on pin 00");
  buf[19] = (char )m_pin / 10 + '0';
  buf[20] = (char)m_pin % 10 + '0';
  m_idPerfReceive = Msr_Register(buf);
#endif // PERF
}

CAviWrite::StreamInfo::~StreamInfo()
{
  if(m_pSampleStdIx != 0)
    m_pSampleStdIx->Release();

  delete[] m_szStrn;
}

void CAviWrite::StreamInfo::EmptyQueue()
{
  ASSERT(CritCheckIn(&m_pAviWrite->m_cs));

  while(m_lIncoming.GetCount() != 0)
  {
    IMediaSample *pSample;
    pSample = m_lIncoming.RemoveHead();
    if(pSample != INCOMING_EOS_SAMPLE)
      pSample->Release();
  }
}

CAviWrite::CFrameBaseStream::CFrameBaseStream(
  UINT iStream, UINT iPin, AviWriteStreamConfig *pAwsc, CAviWrite *pAviWrite,
  HRESULT *phr) :
    StreamInfo(iStream, iPin, pAwsc, pAviWrite, phr),
    m_rtDurationFirstFrame(0)
{
  m_bDroppedFrames = g_B_DROPPED_FRAMES;
}

CAviWrite::CVideoStream::CVideoStream(
  UINT iStream, UINT iPin, AviWriteStreamConfig *pAwsc, CAviWrite *pAviWrite,
  HRESULT *phr) :
    CFrameBaseStream(iStream, iPin, pAwsc, pAviWrite, phr)
{
  ASSERT(m_mt.formattype == FORMAT_VideoInfo);
}


CAviWrite::CAudioStream::CAudioStream(
  UINT iStream, UINT iPin, AviWriteStreamConfig *pAwsc, CAviWrite *pAviWrite,
  HRESULT *phr) :
    StreamInfo(iStream, iPin, pAwsc, pAviWrite, phr),
    m_bAudioAlignmentError(false)
{
}

CAviWrite::CAudioStreamI::CAudioStreamI(
  UINT iStream, UINT iPin, AviWriteStreamConfig *pAwsc, CAviWrite *pAviWrite,
  HRESULT *phr) :
    CAudioStream(iStream, iPin, pAwsc, pAviWrite, phr),
    m_fUnfinishedChunk(FALSE),
    m_cbThisSample(0),
    m_dwlcbWritten(0)
{
}

// for variable rate video, we assume 30fps or the duration of the
// first frame. this should be handled properly when variable frame
// rate AVI is supported.
REFERENCE_TIME CAviWrite::CFrameBaseStream::ConvertTickToTime(ULONG cTicks)
{
  if(m_rtDurationFirstFrame != 0)
    return cTicks * m_rtDurationFirstFrame;

  return cTicks * (UNITS / 30);
}

REFERENCE_TIME CAviWrite::CVideoStream::ConvertTickToTime(ULONG cTicks)
{
  VIDEOINFO *pvi = (VIDEOINFO *)m_mt.Format();
  if(pvi->AvgTimePerFrame != 0)
    return cTicks * pvi->AvgTimePerFrame;
  else
    return CFrameBaseStream::ConvertTickToTime(cTicks);
}

// for variable rate video, we assume 30fps or the duration of the
// first frame. this should be handled properly when variable frame
// rate AVI is supported.
ULONG CAviWrite::CFrameBaseStream::ConvertTimeToTick(REFERENCE_TIME rt)
{
  if(m_rtDurationFirstFrame != 0)
    return (ULONG)(rt / m_rtDurationFirstFrame);

  return (ULONG)(rt / (UNITS / 30));
}

HRESULT
CAviWrite::CVideoStream::AcceptRejectSample(IMediaSample *pSample)
{

    REFERENCE_TIME mtStart, mtStop;
    HRESULT hr = pSample->GetMediaTime(&mtStart, &mtStop);
    if(hr == S_OK)
    {
        // m_mtEnd is if -1 if the end time is not available. We want
        // to skip samples with identical media times. They are used
        // to identify extra frames when the source must send frames
        // at a higher rate than requested.
        if(mtStop == m_mtEnd)
        {
            return S_FALSE;
        }
    }


    return S_OK;

}

// for variable rate video, we assume 30fps or the duration of the
// first frame. this should be handled properly when variable frame
// rate AVI is supported.
ULONG CAviWrite::CVideoStream::ConvertTimeToTick(REFERENCE_TIME rt)
{
  VIDEOINFO *pvi = (VIDEOINFO *)m_mt.Format();
  if(pvi->AvgTimePerFrame != 0)
    return (ULONG)(rt / pvi->AvgTimePerFrame);
  else
    return CFrameBaseStream::ConvertTimeToTick(rt);
}

REFERENCE_TIME CAviWrite::CAudioStream::ConvertTickToTime(ULONG cTicks)
{
  WAVEFORMATEX *pwfx = (WAVEFORMATEX *)m_mt.Format();
  return cTicks * pwfx->nBlockAlign * UNITS / pwfx->nAvgBytesPerSec;
}

ULONG CAviWrite::CAudioStream::ConvertTimeToTick(REFERENCE_TIME rt)
{
   WAVEFORMATEX *pwfx = (WAVEFORMATEX *)m_mt.Format();
   return (ULONG)(rt *  pwfx->nAvgBytesPerSec / pwfx->nBlockAlign / UNITS);
}

ULONG CAviWrite::CAudioStream::CountSamples()
{
  ASSERT(*m_mt.Type() == MEDIATYPE_Audio);
  ASSERT(*m_mt.FormatType() == FORMAT_WaveFormatEx);

  WAVEFORMATEX *pwfx = (WAVEFORMATEX *)m_mt.Format();
  // connection refused if nBlockAlign is 0.
  ASSERT(m_dwlcBytes / pwfx->nBlockAlign <= MAXDWORD);
  ULONG cSamples= (ULONG)(m_dwlcBytes / pwfx->nBlockAlign);

  return cSamples;
}

ULONG CAviWrite::CAudioStream::ConvertTickToBytes(ULONG cTicks)
{
  ASSERT(*m_mt.Type() == MEDIATYPE_Audio);
  ASSERT(*m_mt.FormatType() == FORMAT_WaveFormatEx);

  WAVEFORMATEX *pwfx = (WAVEFORMATEX *)m_mt.Format();
  return cTicks * pwfx->nBlockAlign;
}

ULONG CAviWrite::CAudioStream::ConvertBytesToTicks(ULONG cBytes)
{
  ASSERT(*m_mt.Type() == MEDIATYPE_Audio);
  ASSERT(*m_mt.FormatType() == FORMAT_WaveFormatEx);

  WAVEFORMATEX *pwfx = (WAVEFORMATEX *)m_mt.Format();
  return cBytes / pwfx->nBlockAlign;
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

CAviWrite::CWalkIndex::CWalkIndex(CAviWrite *pAviWrite, StreamInfo *pSi)
{
  m_pSi = pSi;

  m_pAviWrite = pAviWrite;
  m_offsetSuper = m_offsetStd = 0;

  m_dwlFilePosLastStd = pSi->m_posFirstSubIndex;

  m_pSuperIndex = 0;
  m_pStdIndex = 0;
}

HRESULT CAviWrite::CWalkIndex::Init()
{
  DbgLog((LOG_TRACE, 0x20, TEXT("CWalkIndex::Init: stream %d"),
          m_pSi->m_stream));

  HRESULT hr = S_OK;

  // nothing to do if this stream has no samples
  if(m_pSi->m_cSamples == 0)
  {
    ASSERT(m_pSuperIndex == 0);
    return S_OK;
  }


  ASSERT(m_pAviWrite->GetIndx(m_pSi->m_stream)->bIndexType == AVI_INDEX_OF_INDEXES);

  m_pSuperIndex = (AVISUPERINDEX *)m_pAviWrite->GetIndx(m_pSi->m_stream);

  m_pStdIndex = (AVISTDINDEX *)new BYTE[cbSubIndex(m_pSi->m_cEntriesSubIndex)];
  if(m_pStdIndex == 0)
    return E_OUTOFMEMORY;

  // we need to update the super index if the current sub index has
  // any chunks
  AVISTDINDEX *pStdIndx = m_pAviWrite->GetCurrentIx(m_pSi->m_stream);
  if(pStdIndx->nEntriesInUse != 0)
  {
    // the file offset will be updated later. we can't call FlushIx
    // because the graph may have stopped.
    if(hr = m_pAviWrite->UpdateSuperIndex(m_pSi->m_stream,
                                          m_pSi->m_dwlOffsetCurrentSubIndex),
       FAILED(hr))
    {
      DbgLog(( LOG_ERROR, 2,
               TEXT("CAviWrite::CWalkIndex::Init: UpdateSuperIndex failed.")));
    }
  }
  if(SUCCEEDED(hr))
  {
    hr = ReadStdIndex();
    if(FAILED(hr))
    {
      DbgLog(( LOG_ERROR, 2,
               TEXT("CAviWrite::CWalkIndex::Init: ReadStdIndex failed.")));
    }
    else if(m_pSi->m_cInitialFramesToDelete > m_pSuperIndex->aIndex[0].dwDuration)
    {
      // !!! the amount of video we have to delete exceeds one sub
      // index. abort. If someone really needs to write out a file
      // with a long delay before the audio starts, they need to turn
      // off the compatibility index.

      DbgLog((LOG_ERROR, 0, TEXT("bug: cannot delete %d frames from stream %d"),
              m_pSi->m_cInitialFramesToDelete, m_pSi->m_stream));
      return E_UNEXPECTED;
    }
    else if(m_pSi->m_cInitialFramesToDelete > 0)
    {
      // update super index for frames we're deleting
      if(m_pSi->m_cInitialFramesToDelete < m_pSuperIndex->aIndex[0].dwDuration)
      {
        m_pSuperIndex->aIndex[0].dwDuration -= m_pSi->m_cInitialFramesToDelete;
      }
      else
      {
        m_pSuperIndex->aIndex[0].dwDuration = 0;
      }

      DbgLog((LOG_TRACE, 1, TEXT("m_cInitialFramesToDelete: 1, dwDuration: %d"),
              m_pSuperIndex->aIndex[0].dwDuration, m_pSi->m_cInitialFramesToDelete));

      // delete initial entries from subindex (DoVfwDwStartHack())
      ASSERT(m_pStdIndex->nEntriesInUse - m_pSi->m_cInitialFramesToDelete ==
             m_pSuperIndex->aIndex[0].dwDuration ||
             m_pSuperIndex->aIndex[0].dwDuration == 0);

      m_pStdIndex->nEntriesInUse = m_pSuperIndex->aIndex[0].dwDuration;
      ASSERT(m_pStdIndex->nEntriesInUse == m_pSuperIndex->aIndex[0].dwDuration);
      CopyMemory(
        m_pStdIndex->aIndex,
        &m_pStdIndex->aIndex[m_pSi->m_cInitialFramesToDelete],
        m_pStdIndex->nEntriesInUse * sizeof(m_pStdIndex->aIndex[0]));
      ZeroMemory(
        &m_pStdIndex->aIndex[m_pStdIndex->nEntriesInUse],
        m_pSi->m_cInitialFramesToDelete * sizeof(m_pStdIndex->aIndex[0]));

       hr = m_pAviWrite->IStreamWrite(
        m_pSuperIndex->aIndex[0].qwOffset,
        (BYTE*)m_pStdIndex,
        m_pStdIndex->cb + sizeof(RIFFCHUNK));

    }
  }



  return hr;
}

CAviWrite::CWalkIndex::~CWalkIndex()
{
  if(m_pStdIndex != 0)
    delete m_pStdIndex;
}

HRESULT CAviWrite::CWalkIndex::Peek(
  DWORDLONG *dwlPos,
  DWORD *dwSize,
  BOOL *pbSyncPoint)
{
  if(m_pSi->m_cSamples == 0) {
    ASSERT(m_pStdIndex == 0);
    return E_FAIL;
  }

  ASSERT(m_pStdIndex != 0);
  if(m_offsetStd >= m_pStdIndex->nEntriesInUse)
    return E_FAIL;

  if(m_pSuperIndex != 0 && m_offsetSuper >= m_pSuperIndex->nEntriesInUse)
    return E_FAIL;

  *dwlPos = m_pStdIndex->aIndex[m_offsetStd].dwOffset +
    m_pStdIndex->qwBaseOffset;

  *dwSize = m_pStdIndex->aIndex[m_offsetStd].dwSize & AVISTDINDEX_SIZEMASK;

  *pbSyncPoint = !(m_pStdIndex->aIndex[m_offsetStd].dwSize & AVISTDINDEX_DELTAFRAME);

  return S_OK;
}

// ------------------------------------------------------------------------
// set the pointer to the next sub index entry

HRESULT CAviWrite::CWalkIndex::Advance()
{
  HRESULT hr;

  if(++m_offsetStd >= m_pStdIndex->nEntriesInUse)
  {
    if(m_pSuperIndex == 0)
      return E_FAIL;

    if(++m_offsetSuper >= m_pSuperIndex->nEntriesInUse)
      return E_FAIL;

    if(hr = ReadStdIndex(), FAILED(hr))
      return E_FAIL;

    m_offsetStd = 0;
    if(m_offsetStd >= m_pStdIndex->nEntriesInUse)
      return E_FAIL;

  }
  return S_OK;
}

// ------------------------------------------------------------------------
// finish propagating the subindex chunks back

HRESULT CAviWrite::CWalkIndex::Close()
{
  HRESULT hr;
  if(m_pSuperIndex != 0)
    while(++m_offsetSuper < m_pSuperIndex->nEntriesInUse)
      if(hr = ReadStdIndex(), FAILED(hr))
        return hr;

  return S_OK;
}

// ------------------------------------------------------------------------
// ReadStdIndex. read the next standard index off disk to m_pStdIndex
// (the last standard index is in memory). Write it back to the
// location of the previous index entry.


HRESULT CAviWrite::CWalkIndex::ReadStdIndex()
{
  ASSERT(m_pSuperIndex != 0);
  ASSERT(m_offsetSuper < m_pSuperIndex->nEntriesInUse);

  DbgLog((LOG_TRACE, 0x20,
          TEXT("CWalkIndex::ReadStdIndex: stream %d, m_offsetSuper: %d"),
          m_pSi->m_stream, m_offsetSuper));

  // don't need to propagate index chunks for Interleaved files
  // because the indexes are in the right place already.
  BOOL fNeedToWriteOutSubIndexChunk = TRUE;

  BOOL fSubIndexInMem = FALSE;
  if(m_offsetSuper == m_pSuperIndex->nEntriesInUse - 1)
  {
    // get the last sub index. it may be on disk or in memory. It's in
    // memory if we haven't called FlushIx,InitIx(). we are able to
    // guarantee that the last video won't be written out, but can't
    // say anything about the audio.

    AVISTDINDEX *pStdIndx;
    IMediaSample *pSampleStdIx = m_pSi->m_pSampleStdIx;
    ASSERT(pSampleStdIx);
    HRESULT hr = pSampleStdIx->GetPointer((BYTE**)&pStdIndx);
    ASSERT(SUCCEEDED(hr));

    // if we didn't get a chance to write anything in this index, then
    // the last index is on disk.
    if(pStdIndx->nEntriesInUse != 0)
    {
      fSubIndexInMem = TRUE;
    }
  }

  if(!fSubIndexInMem)
  {

    HRESULT hr = m_pAviWrite->IStreamRead(
      m_pSuperIndex->aIndex[m_offsetSuper].qwOffset,
      (BYTE*)m_pStdIndex,
      m_pSuperIndex->aIndex[m_offsetSuper].dwSize);

    if(FAILED(hr))
      return hr;

    // if PrecomputedIndexSizes() then the indexes are already in the
    // right place
    fNeedToWriteOutSubIndexChunk = !m_pSi->PrecomputedIndexSizes();
  }
  else
  {
    DbgLog((LOG_TRACE, 0x20, TEXT("CWalkIndex::ReadStdIndex: copying")));
    AVISTDINDEX *pStdIndx;
    IMediaSample *&rpSampleStdIx = m_pSi->m_pSampleStdIx;
    ASSERT(rpSampleStdIx);
    HRESULT hr = rpSampleStdIx->GetPointer((BYTE**)&pStdIndx);
    ASSERT(SUCCEEDED(hr));
    CopyMemory(m_pStdIndex, pStdIndx, pStdIndx->cb + sizeof(RIFFCHUNK));
    rpSampleStdIx->Release();
    rpSampleStdIx = 0;

    // Always need to write out the last sub index chunk
    fNeedToWriteOutSubIndexChunk = TRUE;
  }

  ASSERT(m_pStdIndex->bIndexType == AVI_INDEX_OF_CHUNKS);

  if(m_pStdIndex->nEntriesInUse > 0 && fNeedToWriteOutSubIndexChunk)
  {
    // when writing interleaved files, we don't want to propagate
    // index chunks back one because we write them in the right place
    const DWORDLONG dwlByteOffsetThisSubIndex = m_pSi->PrecomputedIndexSizes() ?
      m_pSuperIndex->aIndex[m_offsetSuper].qwOffset :
      m_dwlFilePosLastStd;

    DbgLog((LOG_TRACE, 0x20,
            TEXT("CWalkIndex::ReadStdIndex: writing %d bytes to %08x"),
            m_pStdIndex->cb + sizeof(RIFFCHUNK),
            (DWORD)dwlByteOffsetThisSubIndex));

    HRESULT hr = m_pAviWrite->IStreamWrite(
      dwlByteOffsetThisSubIndex,
      (BYTE*)m_pStdIndex,
      m_pStdIndex->cb + sizeof(RIFFCHUNK));

    if(FAILED(hr))
      return hr;

    m_dwlFilePosLastStd = m_pSuperIndex->aIndex[m_offsetSuper].qwOffset;
    m_pSuperIndex->aIndex[m_offsetSuper].qwOffset = dwlByteOffsetThisSubIndex;
  }

  return S_OK;
}

HRESULT CAviWrite::FlushILeaveWrite()
{
    HRESULT hr = S_OK;

    ASSERT(m_IlMode == INTERLEAVE_FULL);

    ASSERT(CritCheckIn(&m_cs));
    ASSERT(m_ibIleave <= CB_ILEAVE_BUFFER);

    LARGE_INTEGER offset;
    offset.QuadPart = m_dwlIleaveOffset;
    hr = m_pIStream->Seek(offset, STREAM_SEEK_SET, 0);
    if(SUCCEEDED(hr)) {
        hr = m_pIStream->Write(m_rgbIleave, m_ibIleave, 0);
    }

    m_dwlIleaveOffset += m_ibIleave;
    m_ibIleave = 0;

    return hr;
}

HRESULT CAviWrite::IleaveWrite(
    const DWORDLONG &dwlOffset,
    BYTE *pb,
    ULONG cb)
{
    ASSERT(CritCheckIn(&m_cs));
    HRESULT hr = S_OK;

    ASSERT(m_IlMode == INTERLEAVE_FULL);

    if(m_dwlIleaveOffset + m_ibIleave != dwlOffset)
    {
        hr = FlushILeaveWrite();
        if(SUCCEEDED(hr)) {
            m_dwlIleaveOffset = dwlOffset;
        }
    }

    while(SUCCEEDED(hr) && cb > 0)
    {
        ULONG cbToWrite = min(cb, (CB_ILEAVE_BUFFER - m_ibIleave));
        CopyMemory(m_rgbIleave + m_ibIleave, pb, cbToWrite);
        m_ibIleave += cbToWrite;
        cb -= cbToWrite;
        pb += cbToWrite;

        ASSERT(m_ibIleave <= CB_ILEAVE_BUFFER);
        if(m_ibIleave == CB_ILEAVE_BUFFER)
        {
            hr = FlushILeaveWrite();
        }
    }

    return hr;
}

// ansi-only version of NAME macro (so that we don't need two
// CCopiedSample ctors.)
#ifdef DEBUG
#define NAME_A(x) (x)
#else
#define NAME_A(_x_) ((char *) NULL)
#endif


CCopiedSample::CCopiedSample(
    const AM_SAMPLE2_PROPERTIES *pprop,
    REFERENCE_TIME *pmtStart, REFERENCE_TIME *pmtEnd,
    HRESULT *phr) :
        CMediaSample(
            NAME_A("CCopiedSample"),
            (CBaseAllocator *)1, // keep assert from firing
            phr,
            0,                  // pbBuffer
            0)
{
    // fool SetProperties -- it refuses otherwise
    m_pBuffer = pprop->pbBuffer;
    m_cbBuffer = pprop->cbBuffer;

    if(SUCCEEDED(*phr))
    {
        *phr = SetProperties(sizeof(*pprop), (BYTE *)pprop);
    }
    if(SUCCEEDED(*phr))
    {
        SetMediaTime(pmtStart, pmtEnd);
    }

    // always initialize m_pBuffer so dtor can cleanup
    m_pBuffer = new BYTE[pprop->lActual];

    if(m_pBuffer)
    {
        CopyMemory(m_pBuffer, pprop->pbBuffer, pprop->lActual);
        ASSERT(m_cbBuffer >= pprop->lActual && m_lActual == pprop->lActual);
    }
    else
    {
        *phr = E_OUTOFMEMORY;
    }


}

CCopiedSample::~CCopiedSample()
{
    delete[] m_pBuffer;
}

// CMediaSample::Release puts the sample back on the allocator queue,
// but CCopiedSample doesn't have an allocator, so it just deletes
// itself.
ULONG CCopiedSample::Release()
{
    /* Decrement our own private reference count */
    LONG lRef = InterlockedDecrement(&m_cRef);

    ASSERT(lRef >= 0);

    DbgLog((LOG_MEMORY,3,TEXT("    Unknown %X ref-- = %d"),
        this, m_cRef));

    /* Did we release our final reference count */
    if (lRef == 0) {
        delete this;
    }
    return (ULONG)lRef;
}

// converting dv type1 - > type 2: if the dv splitter drops enough
// frames and doesn't send audio, then the video pin blocks in
// Receive(), and the avi splitter is starved, and the conversion
// stops
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\control\effect\effect.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// Base class for simple Effect filter
//

#include <streams.h>
#include <initguid.h>
#include <mmsystem.h>
#include <vfw.h>
#include <olectl.h>
#include <olectlid.h>
#include <stdlib.h>

#include "amprops.h"

#include "ieffect.h"

#define _EFFECT_IMPLEMENTATION_
#include "effect.h"
#include "effprop.h"

// setup data

const AMOVIESETUP_MEDIATYPE
sudPinTypes =   { &MEDIATYPE_Video                // clsMajorType
                , &MEDIASUBTYPE_NULL }  ;       // clsMinorType

const AMOVIESETUP_PIN
psudPins[] = { { L"Input"            // strName
               , FALSE               // bRendered
               , FALSE               // bOutput
               , FALSE               // bZero
               , FALSE               // bMany
               , &CLSID_NULL         // clsConnectsToFilter
               , L"Output"           // strConnectsToPin
               , 1                   // nTypes
               , &sudPinTypes }      // lpTypes

             , { L"Input"            // strName
               , FALSE               // bRendered
               , FALSE               // bOutput
               , FALSE               // bZero
               , FALSE               // bMany
               , &CLSID_NULL         // clsConnectsToFilter
               , L"Output"           // strConnectsToPin
               , 1                   // nTypes
               , &sudPinTypes }      // lpTypes

             , { L"Output"           // strName
               , FALSE               // bRendered
               , TRUE                // bOutput
               , FALSE               // bZero
               , FALSE               // bMany
               , &CLSID_NULL         // clsConnectsToFilter
               , L"Input"            // strConnectsToPin
               , 1                   // nTypes
               , &sudPinTypes } };   // lpTypes


const AMOVIESETUP_FILTER
sudEffect = { &CLSID_VideoEffect              // clsID
            , L"Video Effect"                 // strName
            , MERIT_DO_NOT_USE                // dwMerit
            , 3                               // nPins
            , psudPins };                     // lpPin



// list of class ids and creator functions for class factory
CFactoryTemplate g_Templates[] = {
    { L"Sample Video Effect"
    , &CLSID_VideoEffect
    , CEffectFilter::CreateInstance
    , NULL
    , &sudEffect }
  ,
    { L"Effect Property Page"
    , &CLSID_EffectPropertyPage
    , CEffectProperties::CreateInstance }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// this goes in the factory template table to create new instances
CUnknown *
CEffectFilter::CreateInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
    return new CEffectFilter(pUnk, phr);
}

/* Implements the CEffectFilter class */

CEffectFilter::CEffectFilter(
    LPUNKNOWN pUnk,
    HRESULT *phr)
    : CBaseVideoMixer(NAME("Effect Filter"), pUnk, CLSID_VideoEffect, phr, NINPUTS+NCONTROL),
    CPersistStream(pUnk, phr)
{
    m_effectStart = 0;
    m_effectEnd = 1000;

    // !!! registry?
    char   sz[60];
    GetProfileStringA("Quartz", "EffectStart", "20.0", sz, 60);
    m_effectStartTime = COARefTime(atof(sz));
    GetProfileStringA("Quartz", "EffectLength", "10.0", sz, 60);
    m_effectTime = COARefTime(atof(sz));

    m_streamOffsets[1] = m_effectStartTime;
    m_streamLengths[0] = m_effectTime + m_effectStartTime;
    m_streamLengths[1] = CRefTime(100000000L); // !!! big number

    m_apOffsets = m_streamOffsets;
    m_apLengths = m_streamLengths;

    m_bUsingClock = TRUE;

    // BIG hack: should be getting this period from one of the input streams,
    // or a dialog box, or something....
    m_iClockPeriod = 1000 / 15; // !!!

    if (NCONTROL) { 
	m_iControlPin = NINPUTS;
	m_streamOffsets[NINPUTS] = m_effectStartTime;
	m_streamLengths[NINPUTS] = m_effectTime;
    }
}

CEffectFilter::~CEffectFilter()
{
    // get the critsec to ensure that all threads have exited
    CAutoLock lock(&m_csFilter);

}
	
STDMETHODIMP
CEffectFilter::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    CheckPointer(ppv,E_POINTER);

    if (riid == IID_ISpecifyPropertyPages) {
        return GetInterface((ISpecifyPropertyPages *) this, ppv);
    } else if (riid == IID_IEffect) {
        return GetInterface((IEffect *) this, ppv);
    } else if (riid == IID_IPersistStream) {
	return GetInterface((IPersistStream *) this, ppv);
    }
    else {
	return CBaseVideoMixer::NonDelegatingQueryInterface(riid, ppv);
    }
}


HRESULT
CEffectFilter::CanMixType(const CMediaType *pmt)
{
    // Firstly, can we mix this video type? We reject everything but
    // non-compressed, fixed size samples.
    if (!IsEqualGUID(*pmt->Type(), MEDIATYPE_Video))
        return VFW_E_INVALIDMEDIATYPE;

    if ((*pmt->FormatType() != FORMAT_VideoInfo) || !pmt->IsFixedSize())
        return E_FAIL;

    if (pmt->FormatLength() < sizeof(VIDEOINFOHEADER))
	return E_FAIL;

    VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *) pmt->Format();

    if (pvi == NULL)
	return E_FAIL;

    if (pvi->bmiHeader.biCompression != BI_RGB &&
	    pvi->bmiHeader.biCompression != BI_BITFIELDS)
	    return E_INVALIDARG; // !!!

    return S_OK;
}


PVOID getPixelPtr(int x, int y, BYTE *p, BITMAPINFOHEADER *lpbi)
{
    int iBytesPerPixel = lpbi->biBitCount / 8;
    return (PVOID) (p + (y * DIBWIDTHBYTES(*lpbi)) + x * iBytesPerPixel);
}

void copyRegion(int x,int y,int width,int height,BYTE *pSource,
		BYTE *pDest, BITMAPINFOHEADER *lpbi)
// blt between two samples of the same size & bit depth at the same x,y location.
{
    int iBytesPerPixel = lpbi->biBitCount / 8;
    int iWidth = lpbi->biWidth;
    long lNumBytes;
    BYTE *pSourceBuffer, *pDestBuffer;
    int line;

    // may need to check for non zero DirectX
    // strides in the future.

    if ( (width == iWidth) && (height > 1)) // we have a run of full length lines.
    {
	lNumBytes = width * height * iBytesPerPixel;
	pSourceBuffer = (BYTE *) getPixelPtr(x, y, pSource, lpbi);
	pDestBuffer = (BYTE *) getPixelPtr(x, y, pDest, lpbi);
	CopyMemory( (PVOID) pDestBuffer, (PVOID) pSourceBuffer, lNumBytes);
    }
    else if ((height > 0) && (width > 0))
    {
	lNumBytes = width * iBytesPerPixel;
	for (line = y ; line < y + height ; line++)
	{
	    pSourceBuffer = (BYTE *) getPixelPtr(x, line, pSource, lpbi);
	    pDestBuffer = (BYTE *) getPixelPtr(x, line, pDest, lpbi);
	    CopyMemory( (PVOID) pDestBuffer, (PVOID) pSourceBuffer, lNumBytes);
	}
    }
}

void averageLine(int x, int y,long lNumBytes, BYTE *streamA,
		 BYTE *streamB, BYTE *streamC,BITMAPINFOHEADER *lpbi)
{
    BYTE *pA, *pB, *pC;
    DWORD *dA, *dB, *dC;
    WORD *wA, *wB, *wC;
    int numDwords;
    int i;
    int iBytesPerPixel = lpbi->biBitCount / 8;
    int iWidth = lpbi->biWidth;

    if (lNumBytes < 0L)
	return;

    pA = (BYTE *) getPixelPtr(x,y,streamA,lpbi);
    pB = (BYTE *) getPixelPtr(x,y,streamB,lpbi);		
    pC = (BYTE *) getPixelPtr(x,y,streamC,lpbi);
    dA = (DWORD *) pA;
    dB = (DWORD *) pB;
    dC = (DWORD *) pC;

    if (iBytesPerPixel == 1) // alternate pixels
    {
	int height, width, xx, yy;
	height = 1;
	if (lNumBytes > (long) iWidth)
	    height = (int) (lNumBytes / iWidth);
	width = lNumBytes / height;
	
	for (yy = y ; yy < y + height ; yy++)
	{
	    for (xx = x ; xx < x + width ; xx++)
	    {
		if ((xx + yy) % 2 == 0)
		{
		    *pC++ = *pA++;
		    pB++;
		}
		else
		{
		    *pC++ = *pB++;
		    pA++;
		}
	    }
	}
    }
    else if (iBytesPerPixel == 2 && lpbi->biCompression == BI_BITFIELDS)
	// Sleazy algorithm chosen for speed.  Rather than adding two components together
	// and then dividing, we zero out LSB, shift right, and then add.
    {
	numDwords = (int) (lNumBytes / 4);
	for (i = 0; i < numDwords ; i++, dA++, dB++)
	    *dC++ = ((*dA & 0xf7def7de) >> 1) + ((*dB & 0xf7def7de) >> 1);
	if ((lNumBytes % 4) == 2L)
	{
	    wA = (WORD *) dA;
	    wB = (WORD *) dB;
	    wC = (WORD *) dC;
	    *wC++ = ((*wA & 0xf7de) >> 1) + ((*wB & 0xf7de) >> 1);
	}
    }
    else if (iBytesPerPixel == 2) // RGB555 not 565
	// Sleazy algorithm chosen for speed.  Rather than adding two components together
	// and then dividing, we zero out LSB, shift right, and then add.
    {
	numDwords = (int) (lNumBytes / 4);
	for (i = 0; i < numDwords ; i++, dA++, dB++)
	    *dC++ = ((*dA & 0x7bde7bde) >> 1) + ((*dB & 0x7bde7bde) >> 1);
	if ((lNumBytes % 4) == 2L)
	{
	    wA = (WORD *) dA;
	    wB = (WORD *) dB;
	    wC = (WORD *) dC;
	    *wC++ = ((*wA & 0x7bde) >> 1) + ((*wB & 0x7bde) >> 1);
	}
    }
    else  // RGB24 or RGB32 - uses sleazy shortcut described above
    {
	numDwords = (int) (lNumBytes / 4);
	for (i = 0; i < numDwords ; i++, dA++, dB++)
	    *dC++ = ((*dA & 0xfefefefe) >> 1) + ((*dB & 0xfefefefe) >> 1);
	
	int numBytes = (int) (lNumBytes % 4);
	pA += lNumBytes - numBytes;	
	pB += lNumBytes - numBytes;	
	pC += lNumBytes - numBytes;	
	
	for (i = 0; i < numBytes ; i++, pA++, pB++)
	    *pC++ = (*pA >> 1) + (*pB >> 1);
    }
}


void averageRegion(int x,int y,int width,int height,BYTE *streamA,
		   BYTE *streamB, BYTE *streamC, BITMAPINFOHEADER *lpbi)
// Takes two regions A & B, averages them, producing output in C.
// The 3 samples must have the same size & bit depth.  The same x,y location is
// assumed for all 3 samples.
// For 256 colors, alternating pixels are chosen from A & B.
// Supports: RGB32, RGB24, RGB555, & 256 color mode (assuming palette stays fixed)
{
    int iBytesPerPixel = lpbi->biBitCount / 8;
    int iWidth = lpbi->biWidth;
    long lNumBytes;
    int line;

    // check for strides in DirectX surfaces in future
    if ( (width == iWidth) && (height > 1)) // we have a run of lines.
    {
	lNumBytes = width * height * iBytesPerPixel;
	averageLine(x,y,lNumBytes, streamA, streamB, streamC, lpbi);
    }
    else if ((height > 0) && (width > 0))
    {
	lNumBytes = width * iBytesPerPixel;
	for (line = 0; line < height; line++, y++)
	    averageLine(x,y,lNumBytes, streamA, streamB, streamC, lpbi);
    }
}

HRESULT CEffectFilter::ActuallyDoEffect(
		BITMAPINFOHEADER *lpbi,
		int iEffectNum,
		LONG lEffectParam,
		BYTE *pIn1,
		BYTE *pIn2,
		BYTE *pOut)
{
    int yActive, xActive;
    int bandHeight;
    int width, height, x, y, xCenter, yCenter;


    switch (iEffectNum)
    {
	case 0:	//************ WIPE - UP DIRECTION ****************************
	    yActive = lpbi->biHeight * lEffectParam / 1000;
	    ASSERT(yActive <= lpbi->biHeight);
	    copyRegion(0, 0, lpbi->biWidth, yActive, pIn2, pOut, lpbi);
	
	    if (yActive < lpbi->biHeight) // anti-alias the edge
		averageRegion(0, yActive, lpbi->biWidth, 1,
			      pIn1, pIn2, pOut, lpbi);
	
	    copyRegion(0, yActive+1, lpbi->biWidth,
		       lpbi->biHeight - yActive, pIn1, pOut, lpbi);
	    break;
	
	case 1: /************************  WIPE - TO THE RIGHT DIRECTION */
	    xActive = lpbi->biWidth * lEffectParam / 1000;
	    ASSERT(xActive <= lpbi->biWidth);
	
	    copyRegion(0, 0, xActive, lpbi->biHeight, pIn2, pOut, lpbi);
	    averageRegion(xActive, 0, 1, lpbi->biHeight, pIn1, pIn2, pOut, lpbi);
	    copyRegion(xActive+1, 0, lpbi->biWidth - xActive,
		       lpbi->biHeight, pIn1, pOut, lpbi);				
	    break;
	
	case 2: /****************************** IRIS SQUARE  */
	    // will be slightly off-center when dimensions are not even
	    xActive = lpbi->biWidth * lEffectParam / 2000;
	    yActive = lpbi->biHeight * lEffectParam / 2000;
	    xCenter = lpbi->biWidth / 2;
	    yCenter = lpbi->biHeight / 2;
	
	    if (xActive > 1 && yActive > 1)  // inner solid box for B
	    {
		x = xCenter - xActive + 1;
		y = yCenter - yActive + 1;
		
		ASSERT(x >= 0);
		ASSERT(y >= 0);
		width = xActive * 2 - 2;
		height = yActive * 2 - 2;
		
		copyRegion(x, y, width, height, pIn2, pOut, lpbi);
	    }
	
	    y = yCenter - yActive;
	    x = xCenter - xActive;
	    width = xActive * 2;
	    height = yActive * 2;
	
	    // anti-alias the edge box between A & B				
	    if (xActive > 0 && yActive > 0 &&
		xActive < xCenter && yActive < yCenter)	
	    {
		averageRegion(x, y, width, 1, pIn1, pIn2, pOut, lpbi);
		averageRegion(x, y + 1, 1, height-2, pIn1, pIn2, pOut, lpbi);
		averageRegion(x + width-1, y + 1, 1, height-2, pIn1, pIn2, pOut, lpbi);
		averageRegion(x, y + height-1, width, 1, pIn1, pIn2, pOut, lpbi);
	    }
	
	
	    // Draw the outer area for A as a series of 4 regions around the edge box				
	    if ( (xActive < xCenter - 2) && (yActive < yCenter - 2) )
	    {
		copyRegion(0, 0, lpbi->biWidth, y, pIn1, pOut, lpbi);
		copyRegion(0, y, x-1, height, pIn1, pOut, lpbi);
		x = xCenter + xActive;
		copyRegion(x, y, lpbi->biWidth - x + 1, height, pIn1, pOut, lpbi);
		y = yCenter + yActive;
		copyRegion(0, y, lpbi->biWidth, lpbi->biHeight - y - 1,
			   pIn1, pOut, lpbi);
	    }
	    break;
	
	case 3: /************************  BAND MERGE WIPE *****/
	    // yActive in range 0 to 1.25 * lpbi->biHeight
	    bandHeight = lpbi->biHeight / 4;
	    yActive = lEffectParam * (lpbi->biHeight + bandHeight) / 1000;
	
	    // bring in B from bottom in clipped range {y = 0 to yActive-bandHeight - 1}
	    int lines = yActive - bandHeight;
	    copyRegion(0, 0, lpbi->biWidth, lines, pIn2, pOut, lpbi);													
	
	    // 50% merge band of A and B in range {yActive - bandHeight to yActive},
	    // must be clipped to range {0 to lpbi->biHeight -1}
	
	    y = (yActive - bandHeight > 0) ? yActive - bandHeight : 0;
	    int yStop = (yActive < lpbi->biHeight - 1) ? yActive : lpbi->biHeight - 1;
	    lines = yStop - y + 1;
	    averageRegion(0, y, lpbi->biWidth, lines, pIn1, pIn2, pOut, lpbi);
	
	    // stream A is at the top until the band runs it over.
	    // In clipped range {yActive + 1, lpbi->biHeight - 1}
	    lines = lpbi->biHeight - (yActive + 1);
	    copyRegion(0, yActive+1, lpbi->biWidth, lines, pIn1, pOut, lpbi);
	    break;
    }
    return NOERROR;
}

HRESULT
CEffectFilter::MixSamples(IMediaSample *pOutSample)
{
    HRESULT hr = NOERROR;
    int iEffectNum = m_effectNum;

    DbgLog((LOG_TRACE, 8, TEXT("Doing the effect!")));

    BYTE *pDataOut;                // Pointer to actual data

    pOutSample->GetPointer(&pDataOut);
    ASSERT(pDataOut != NULL);

    int	iConnected = 0;
    int size = pOutSample->GetSize();

    int effectNow = 1000;  // assume we're finished....

    IMediaSample *pSample = NULL;

    if (m_apInput[0]->SampleReady())
	pSample = m_apInput[0]->GetHeadSample();

    if (pSample != NULL) {
	CRefTime tStart, tStop;
	pSample->GetTime((REFERENCE_TIME *)&tStart,
                         (REFERENCE_TIME *)&tStop);

	if (NCONTROL) {
	    // we have a control stream, use it!
	    if (m_apInput[2]->SampleReady()) {
		IMediaSample *pControlSample = m_apInput[2]->GetHeadSample();

		BYTE *pData, *pEndData;
		pControlSample->GetPointer(&pData);
		pEndData = pData + pControlSample->GetActualDataLength();

		PSDWORDDATA * psd = (PSDWORDDATA *) pData;

		while (((BYTE *) psd + sizeof(psd)) < pEndData) {
		    // !!! check property set GUID
		    DbgLog((LOG_TRACE, 1, TEXT("Property %d, value %d"),
			    psd->pID, psd->dwProperty));

		    switch (psd->pID) {
			case PID_WIPEPOSITION:
			    // convert from a 0-100 scale to 0-1000.
			    effectNow = psd->dwProperty * 10;
			    break;

			case PID_EFFECT:
			    // !!! verify that it's in range?

			    // !!! what error if a bad value here?
			    // !!! support sparse properties?
			    iEffectNum = psd->dwProperty;
			    break;

			default:
			    // !!! what to do with unknown properties?
			    break;
		    }

		    psd++;
		}
		
	    } else {
		DbgLog((LOG_TRACE, 1, TEXT("No control data, using 1000")));
		effectNow = 1000;
	    }
	} else {
	    if (tStart < m_effectStartTime)
		effectNow = 0;
	    else
		effectNow = ((tStart.Millisecs() -
				   m_effectStartTime.Millisecs()) * 1000) /
				    max(m_effectTime.Millisecs(), 1);
	}

	DbgLog((LOG_TRACE, 8, TEXT("sample %d  start %d  now %d"),
		tStart.Millisecs(),
		m_effectStartTime.Millisecs(), effectNow));
	if (effectNow > 1000)
	    effectNow = 1000;

    } else {
	ASSERT(m_apInput[0]->m_fEOSReceived);

	return E_FAIL;			// m_apInput[0] contains the main frame.
    }

    // if no sample ready on stream 2, what to do?  do effect against
    // blank frame?
    if (m_apInput[1]->SampleReady() && effectNow > 0 && effectNow < 1000) {
	IMediaSample *pSample2 = m_apInput[1]->GetHeadSample();

	// scale "effectNow" to be between start & end instead of
	// between 0 and 1000
	effectNow = (effectNow * (m_effectEnd - m_effectStart) / 1000) +
		    m_effectStart;

	
	BYTE *pData;                // Pointer to actual data

	pSample->GetPointer(&pData);
	ASSERT(pData != NULL);

	BYTE *pData2;                // Pointer to actual data

	pSample2->GetPointer(&pData2);
	ASSERT(pData2 != NULL);

	BITMAPINFOHEADER *pbmi = HEADER(m_pOutput->CurrentMediaType().Format());
	hr = ActuallyDoEffect(pbmi, iEffectNum, effectNow, pData, pData2, pDataOut);
    } else {
	if (effectNow == 1000 && m_apInput[1]->SampleReady())
	    pSample = m_apInput[1]->GetHeadSample();

	if (!pSample) {
	    DbgLog((LOG_TRACE, 2, TEXT("Odd--nothing to mix!!!")));
	    return E_FAIL;
	}
	
	BYTE *pData;                // Pointer to actual data

	pSample->GetPointer(&pData);
	ASSERT(pData != NULL);

	CopyMemory(pDataOut, pData, size);
    }

    return hr;
}


HRESULT CEffectFilter::SetMediaType(int iPin, const CMediaType *pmt)
{
    HRESULT hr = CBaseVideoMixer::SetMediaType(iPin, pmt);
    if (iPin == m_iInputPinCount) {
	CAutoLock l(&m_csFilter);

	DisplayType("SetMediaType (output) ", pmt);
    }

    return hr;
}


//
// --- IEffect ---
//


STDMETHODIMP CEffectFilter::GetEffectParameters(
	int *effectNum,
	REFTIME *startTime, REFTIME *lengthTime,
	int *startLevel, int *endLevel)
{
    if (effectNum)
	*effectNum = m_effectNum;

    if (startLevel)
	*startLevel = m_effectStart;

    if (endLevel)
	*endLevel = m_effectEnd;

    if (startTime)
	*startTime = COARefTime(m_effectStartTime);

    if (lengthTime)
	*lengthTime = COARefTime(m_effectTime);

    return NOERROR;
}

STDMETHODIMP CEffectFilter::SetEffectParameters(
	int effectNum,
	REFTIME startTime, REFTIME lengthTime,
	int startLevel, int endLevel)
{
    if (effectNum < 0 || effectNum >= NEFFECTS)
	return E_FAIL;

    m_effectNum = effectNum;

    m_effectStart = startLevel;
    m_effectEnd = endLevel;

    m_effectStartTime = COARefTime(startTime);
    m_effectTime = COARefTime(lengthTime);

    m_streamOffsets[1] = m_effectStartTime;
    m_streamLengths[0] = m_effectTime + m_effectStartTime;
    if (NCONTROL) { 
	m_streamOffsets[NINPUTS] = m_effectStartTime;
	m_streamLengths[NINPUTS] = m_effectTime;
    }

    SetDirty(TRUE);

    return NOERROR;
}

#if 0
// !!! are we going to add something like this back again?
//
// GetEffectName
//
STDMETHODIMP CEffectFilter::get_EffectName(
	LPOLESTR *EffectName)
{
    if (EffectName) {
	const WCHAR szTitle[] = L"Wipe Effect";

	*EffectName = (LPOLESTR) CoTaskMemAlloc(sizeof(szTitle));

	if (!*EffectName)
	    return E_OUTOFMEMORY;
	
	memcpy(*EffectName, &szTitle, sizeof(szTitle));
    }

    return NOERROR;
}
#endif


//
// --- IPersistStream stuff
//

#define WRITEOUT(var)  hr = pStream->Write(&var, sizeof(var), NULL); \
		       if (FAILED(hr)) return hr;

#define READIN(var)    hr = pStream->Read(&var, sizeof(var), NULL); \
		       if (FAILED(hr)) return hr;

STDMETHODIMP CEffectFilter::GetClassID(CLSID *pClsid)
{
    *pClsid = CLSID_VideoEffect;
    return NOERROR;
}


int CEffectFilter::SizeMax()
{
    return
        sizeof(m_effectNum)
      + sizeof(m_effectStart)
      + sizeof(m_effectEnd)
      + sizeof(m_effectStartTime)
      + sizeof(m_effectTime)
    ;

}


HRESULT CEffectFilter::WriteToStream(IStream *pStream)
{
    HRESULT hr;
    WRITEOUT(m_effectNum);
    WRITEOUT(m_effectStart);
    WRITEOUT(m_effectEnd);
    WRITEOUT(m_effectStartTime);
    WRITEOUT(m_effectTime);
    return NOERROR;
}


HRESULT CEffectFilter::ReadFromStream(IStream *pStream)
{
    HRESULT hr;
    READIN(m_effectNum);
    READIN(m_effectStart);
    READIN(m_effectEnd);
    READIN(m_effectStartTime);
    READIN(m_effectTime);

    // need to update vmbase variables when effect times change!
    m_streamOffsets[1] = m_effectStartTime;
    m_streamLengths[0] = m_effectTime + m_effectStartTime;
    if (NCONTROL) { 
	m_streamOffsets[NINPUTS] = m_effectStartTime;
	m_streamLengths[NINPUTS] = m_effectTime;
    }

    return NOERROR;
}


//
// --- ISpecifyPropertyPages ---
//


//
// GetPages
//
// Returns the clsid's of the property pages we support
HRESULT CEffectFilter::GetPages(CAUUID *pcauuid) {
    GUID *pguid;

    pcauuid->cElems = 1;
    pcauuid->pElems = pguid = (GUID *) CoTaskMemAlloc(sizeof(GUID) * pcauuid->cElems);

    if (pcauuid->pElems == NULL)
        return E_OUTOFMEMORY;

    *pguid = CLSID_EffectPropertyPage;

    return NOERROR;
}

/******************************Public*Routine******************************\
* exported entry points for registration and
* unregistration (in this case they only call
* through to default implmentations).
*
*
*
* History:
*
\**************************************************************************/
STDAPI
DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI
DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\control\amprops.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
// 6C727463-0000-0010-8000-00AA00389B71  'ctrl' == MEDIATYPE_Control
DEFINE_GUID(MEDIATYPE_Control,
0x6C727463, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

// {41BF4280-45F2-11d0-A520-6CC005C10000}
DEFINE_GUID(PSID_Standard, 
0x41bf4280, 0x45f2, 0x11d0, 0xa5, 0x20, 0x6c, 0xc0, 0x5, 0xc1, 0x0, 0x0);

const DWORD	PID_PROPERTYSETS	= 0x00000001;

// helper structure for the format block of property sets:
// this struct is for a PID_PROPERTYSETS value which says
// which property sets will be present.
struct PSFORMAT {
    GUID	psID;
    DWORD	pID;
    DWORD	dwPropertySize;
    GUID	psIDImplemented[1];
};


// {41BF4281-45F2-11d0-A520-6CC005C10000}
DEFINE_GUID(PSID_Transition, 
0x41bf4281, 0x45f2, 0x11d0, 0xa5, 0x20, 0x6c, 0xc0, 0x5, 0xc1, 0x0, 0x0);

// effect parameter, 0-100
// effects should probably have a "main parameter" which means the appropriate
// thing for whatever different kind of event it is.
const DWORD	PID_WIPEPOSITION	= 0x00000001;

// effect # (0-3 right now....)
const DWORD	PID_EFFECT		= 0x00000002;


// helper structure for writing out a single DWORD property
struct PSDWORDDATA {
    GUID	psID;
    DWORD	pID;
    DWORD	dwPropertySize;
    DWORD	dwProperty;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\control\effect\effprop.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// effprop.h
//

class CEffectProperties : public CBasePropertyPage
{

public:

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    
private:
    BOOL OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();

    void SetDirty();

    CEffectProperties(LPUNKNOWN lpunk, HRESULT *phr);


    HWND	SetSlider(HWND hwnd, int value);
    void	OnSliderNotification(WPARAM wParam);

    STDMETHODIMP GetFromDialog();


    BOOL m_bIsInitialized;  // Will be false while we set init values in Dlg
                            // to prevent theDirty flag from being set.

    int		m_startLevel;
    int		m_endLevel;

    REFTIME	m_start;
    REFTIME	m_length;

    int		m_effect;
    int		m_fSwapInputs;

    IEffect	*m_pEffect;
    IEffect	*pIEffect(void) { ASSERT(m_pEffect); return m_pEffect; }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\control\effect\effprop.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//effprop.cpp
//

#include <streams.h>

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <olectl.h>
#include <memory.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>

#include "resource.h"
#include "ieffect.h"
#include "effect.h"
#include "effprop.h"

// *
// * CEffectProperties
// *


//
// CreateInstance
//
CUnknown * WINAPI CEffectProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CEffectProperties(lpunk, phr);
    if (punk == NULL) {
	*phr = E_OUTOFMEMORY;
    }

    return punk;
}


//
// CEffectProperties::Constructor
//
CEffectProperties::CEffectProperties(LPUNKNOWN pUnk, HRESULT *phr)
    : CBasePropertyPage(NAME("Effect Property Page"),pUnk,
        IDD_EFFECTPROP, IDS_TITLE)

    , m_pEffect(NULL)
    , m_bIsInitialized(FALSE)
{
    InitCommonControls();
}



//
// SetDirty
//
// Sets m_hrDirtyFlag and notifies the property page site of the change
//
void CEffectProperties::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
    {
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
    }
}


BOOL CEffectProperties::OnReceiveMessage(HWND hwnd,
                                        UINT uMsg,
                                        WPARAM wParam,
                                        LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
        	TCHAR   sz[60];

        	SetSlider(GetDlgItem(hwnd, IDC_SLIDER), m_startLevel);
        	SetSlider(GetDlgItem(hwnd, IDC_SLIDER2), m_endLevel);

        	_stprintf(sz, TEXT("%.2f"), m_length);
        	Edit_SetText(GetDlgItem(hwnd, IDC_LENGTH), sz);
        	_stprintf(sz, TEXT("%.2f"), m_start);
        	Edit_SetText(GetDlgItem(hwnd, IDC_START), sz);

        	CheckRadioButton(hwnd, IDC_WIPEUP, IDC_BAND,
        			 m_effect + IDC_WIPEUP);

            return (LRESULT) 1;
        }

        case WM_VSCROLL:
        {
            SetDirty();
            return (LRESULT) 1;
        }

        case WM_COMMAND:
        {
            if (m_bIsInitialized)
            {
            	switch (LOWORD(wParam))
                {
	             case IDC_EFFECT:
	             case IDC_START:
	             case IDC_LENGTH:
	             case IDC_WIPEUP:
	             case IDC_WIPELEFT:	
	             case IDC_IRIS:
	             case IDC_BAND:
            		SetDirty();
            		break;
            	}
            }
            return (LRESULT) 1;
        }

        case WM_DESTROY:
        {
            return (LRESULT) 1;
        }

    }
    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
}

HRESULT CEffectProperties::OnConnect(IUnknown *pUnknown)
{

    // Get IEffect interface

    ASSERT(m_pEffect == NULL);

    HRESULT hr = pUnknown->QueryInterface(IID_IEffect, (void **) &m_pEffect);
    if (FAILED(hr))
    {
	return E_NOINTERFACE;
    }

    ASSERT(m_pEffect);
	pIEffect()->GetEffectParameters(&m_effect, &m_start, &m_length,
					&m_startLevel, &m_endLevel);

    m_bIsInitialized = FALSE ;

    return NOERROR;
}

HRESULT CEffectProperties::OnDisconnect()
{
    // Release the interface

    if (m_pEffect == NULL)
    {
        return(E_UNEXPECTED);
    }
    m_pEffect->Release();
    m_pEffect = NULL;
    return NOERROR;
}


// We are being activated

HRESULT CEffectProperties::OnActivate()
{
    m_bIsInitialized = TRUE;
    return NOERROR;
}


// We are being deactivated

HRESULT CEffectProperties::OnDeactivate(void)
{
    // remember present effect level for next Activate() call

    GetFromDialog();
    return NOERROR;
}


//
// SetSlider
//
// Set up the slider (common control) to allow the user to
// adjust the effect
HWND CEffectProperties::SetSlider(HWND hwndSlider, int iValue) {

    // Set the Range
    SendMessage(hwndSlider, TBM_SETRANGE, TRUE, MAKELONG(0, 1000));

    // Set a tick at zero
    SendMessage(hwndSlider, TBM_SETTIC, 0, 0);
    SendMessage(hwndSlider, TBM_SETTIC, 0, 1000);

    //
    // Set the slider position according to the value we obtain
    // from initialisation or from the last Deactivate call.
    //
    SendMessage(hwndSlider, TBM_SETPOS, TRUE, iValue);

    return hwndSlider;
}


STDMETHODIMP CEffectProperties::GetFromDialog(void)
{
    TCHAR sz[60];

    Edit_GetText(GetDlgItem(m_hwnd, IDC_LENGTH), sz, 60);
    m_length = COARefTime(atof(sz));

    Edit_GetText(GetDlgItem(m_hwnd, IDC_START), sz, 60);
    m_start = COARefTime(atof(sz));

    m_startLevel = (int) SendMessage(GetDlgItem(m_hwnd, IDC_SLIDER),
				       TBM_GETPOS, 0, 0L);
    m_endLevel = (int) SendMessage(GetDlgItem(m_hwnd, IDC_SLIDER2),
				       TBM_GETPOS, 0, 0L);

    for (int i = IDC_WIPEUP; i <= IDC_BAND; i++)
        if (IsDlgButtonChecked(m_hwnd, i))
            m_effect = i - IDC_WIPEUP;

    return NOERROR;
}


HRESULT CEffectProperties::OnApplyChanges()
{
    GetFromDialog();

    m_bDirty  = FALSE; // the page is now clean

    pIEffect()->SetEffectParameters(m_effect, m_start, m_length,
				    m_startLevel, m_endLevel);

    return(NOERROR);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\control\effect\effect.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef __VIDEOEFFECT__
#define __VIDEOEFFECT__

// Class ID for CEffectFilter objects
// {BCD05AD0-5020-11ce-B2B2-00DD01101B85}
DEFINE_GUID(CLSID_VideoEffect,
0xbcd05ad0, 0x5020, 0x11ce, 0xb2, 0xb2, 0x0, 0xdd, 0x1, 0x10, 0x1b, 0x85);

//
// Property Page
//
// {BCD05AD1-5020-11ce-B2B2-00DD01101B85}
DEFINE_GUID(CLSID_EffectPropertyPage,
0xbcd05ad1, 0x5020, 0x11ce, 0xb2, 0xb2, 0x0, 0xdd, 0x1, 0x10, 0x1b, 0x85);

// below stuff is implementation-only....
#ifdef _EFFECT_IMPLEMENTATION_

const int NCONTROL = 1;
const int NINPUTS = 2;
const int NEFFECTS = 4;

class CEffectFilter : public CBaseVideoMixer,
		  public ISpecifyPropertyPages,
		  public IEffect,
		  public CPersistStream {
/* Nested interfaces */

public:

    CEffectFilter(LPUNKNOWN, HRESULT *);
    ~CEffectFilter();

    // override this to say what interfaces we support and where
    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

    DECLARE_IUNKNOWN;


    // this goes in the factory template table to create new instances
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN, HRESULT *);

    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    int SizeMax();

    // ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

    // Override CPersist stream method
    STDMETHODIMP GetClassID(CLSID *pClsid);

protected:

    HRESULT ActuallyDoEffect(
		BITMAPINFOHEADER *lpbi,
		int  iEffectNum,
		LONG lEffectParam,
		BYTE *pIn1,
		BYTE *pIn2,
		BYTE *pOut);

    HRESULT MixSamples(IMediaSample *pMediaSampleOut);
    HRESULT CanMixType(const CMediaType *pmt);

    HRESULT SetMediaType(int iPin, const CMediaType *pmt);

private:

    int		   m_effectNum;

    int		   m_effectStart;
    int		   m_effectEnd;

    CRefTime 	   m_streamOffsets[NINPUTS+NCONTROL];
    CRefTime 	   m_streamLengths[NINPUTS+NCONTROL];
    CRefTime	   m_effectStartTime;
    CRefTime	   m_effectTime;
    CRefTime	   m_movieLength;

public:
    //
    // --- IEffect ---
    //

    STDMETHOD(SetEffectParameters) (
	    int effectNum,
	    REFTIME startTime, REFTIME endTime,
	    int startLevel, int endLevel);
    STDMETHOD(GetEffectParameters) (
	    int *effectNum,
	    REFTIME *startTime, REFTIME *endTime,
	    int *startLevel, int *endLevel);
};
#endif // _Effect_H_ implementation only....

#endif /* __VIDEOEFFECT__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\control\effect\ieffect.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// ieffect.h
//

// A custom interface to allow the user to adjust the effect level.

#ifndef __IEFFECT__
#define __IEFFECT__

#ifdef __cplusplus
extern "C" {
#endif


//
// IEffect's GUID
//
// {fd5010a3-8ebe-11ce-8183-00aa00577da1}
DEFINE_GUID(IID_IEffect,
0xfd5010a3, 0x8ebe, 0x11ce, 0x81, 0x83, 0x00, 0xaa, 0x00, 0x57, 0x7d, 0xa1);


//
// IEffect
//
DECLARE_INTERFACE_(IEffect, IUnknown) {
#if 0
    STDMETHOD(get_StartTime) (THIS_
    				  REFTIME *StartTime	/* [out] */
				 ) PURE;

    STDMETHOD(put_StartTime) (THIS_
    				  REFTIME  StartTime,	/* [in] */
				 ) PURE;


    STDMETHOD(get_EndTime) (THIS_
    				  REFTIME *EndTime	/* [out] */
				 ) PURE;

    STDMETHOD(put_EndTime) (THIS_
    				  REFTIME  EndTime,	/* [in] */
				 ) PURE;

    STDMETHOD(get_StartLevel) (THIS_
    				  int *StartLevel	/* [out] */
				 ) PURE;

    STDMETHOD(put_StartLevel) (THIS_
    				  int  StartLevel,	/* [in] */
				 ) PURE;


    STDMETHOD(get_EndLevel) (THIS_
    				  int *EndLevel		/* [out] */
				 ) PURE;

    STDMETHOD(put_EndLevel) (THIS_
    				  int  EndLevel,	/* [in] */
				 ) PURE;
#endif

    STDMETHOD(GetEffectParameters) (THIS_
				  int *effectNum,
				  REFTIME *StartTime,
				  REFTIME *EndTime,
				  int *StartLevel,
				  int *EndLevel
				 ) PURE;
				
    STDMETHOD(SetEffectParameters) (THIS_
				  int effectNum,
				  REFTIME StartTime,
				  REFTIME EndTime,
				  int StartLevel,
				  int EndLevel
				 ) PURE;

};


#ifdef __cplusplus
}
#endif

#endif // __IEFFECT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\control\effect\resource.h ===
//{{NO_DEPENDENCIES}}
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// Microsoft Visual C++ generated include file.
// Used by effprop.rc
//
#define IDS_WIPEUP                      1
#define IDS_WIPELEFT                    2
#define IDS_IRIS                        3
#define IDS_BAND                        4
#define IDS_TITLE                       5
#define IDD_EFFECTPROP                  101
#define IDC_EFFECT                      1000
#define IDB_DEFAULT                     1001
#define IDC_START                       1002
#define IDC_LENGTH                      1003
#define IDC_SLIDER                      1004
#define IDC_SLIDER2                     1005
#define IDC_WIPEUP                      1007
#define IDC_WIPELEFT                    1008
#define IDC_IRIS                        1009
#define IDC_BAND                        1010
#define IDS_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1010
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\control\textcont\textcont.cpp ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#pragma warning(disable: 4097 4511 4512 4514 4705)

#include <initguid.h>
#include "amprops.h"
#include "textCont.h"


CFactoryTemplate g_Templates[]= {
  {L"", &CLSID_TextControlSource, CTextControl::CreateInstance}
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

static const char rgbTextControlHeader[] = "Control";

void SkipWhite(char * &pb)
{
    while (*pb != ' ' && *pb != '\t' && *pb != ',' && *pb != '\r')
	pb++;

    while ((*pb == ' ' || *pb == '\t' || *pb == ',') && *pb != '\r')
	pb++;
}

//
// CTextControl::Constructor
//
CTextControl::CTextControl(TCHAR *pName, LPUNKNOWN lpunk, HRESULT *phr)
    : CSimpleReader(pName, lpunk, CLSID_TextControlSource, &m_cStateLock, phr),
	m_pFile(NULL),
	m_dwRate(1),
	m_dwScale(1),
	m_nSets(0),
	m_paSetID(NULL),
	m_dwLastSamp(0xFFFFFFFF)
{

    CAutoLock l(&m_cStateLock);

    DbgLog((LOG_TRACE, 1, TEXT("CTextControl created")));
}


//
// CTextControl::Destructor
//
CTextControl::~CTextControl(void) {
    delete[] m_pFile;

    delete[] m_paSetID;
    
    for (DWORD dwSet = 0; dwSet < m_nSets; dwSet++) {
	CurValue *pVal;
	CGenericList<CurValue> * list = m_aValueList[dwSet];
	while ((BOOL) (pVal = list->RemoveHead()))
	    delete pVal;
	delete list;
    }
    delete [] m_aValueList;

    DbgLog((LOG_TRACE, 1, TEXT("CTextControl destroyed")) );
}


//
// CreateInstance
//
// Called by CoCreateInstance to create a QuicktimeReader filter.
CUnknown *CTextControl::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CTextControl(NAME("Text->Control filter"), lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return punk;
}



HRESULT CTextControl::ParseNewFile()
{
    HRESULT         hr = NOERROR;

    LONGLONG llTotal, llAvailable;

    m_pAsyncReader->Length(&llTotal, &llAvailable);
    
    DWORD cbFile = (DWORD) llTotal;

    m_pFile = new char[cbFile];

    if (!m_pFile)
	goto readerror;
    
    /* Try to read whole file */
    hr = m_pAsyncReader->SyncRead(0, cbFile, (BYTE *) m_pFile);

    if (hr != S_OK)
        goto readerror;




    if (memcmp(m_pFile, rgbTextControlHeader, sizeof(rgbTextControlHeader) - 1)) {
	DbgLog((LOG_ERROR, 1, TEXT("Bad edit list header!")));
	hr = E_FAIL;
    } else {
	char * pb = m_pFile;
	DWORD	dwSet = 0;


	for (;;) {
	    // skip to eol
	    while (*pb && *pb != '\r' && *pb != '\n')
		pb++;

	    // skip eol
	    while (*pb && (*pb == '\r' || *pb == '\n'))
		pb++;

	    // at eof?
	    if (*pb == 0)
		break;

	    // lines starting with ; are comments
	    if (*pb == ';')
		continue;

	    // !!! allow options here, whether to decompress all streams or not?
	    if (*pb == '/') {
		{
		    DbgLog((LOG_TRACE, 2, TEXT("Unknown option: %hs"), pb+1));
		}

		continue;
	    }

	    // line starting with '+' says how many property sets
	    if (*pb == '+') {
		m_nSets = atol(pb+1);

		m_paSetID = new GUID[m_nSets];

		m_aValueList = new CGenericList<CurValue> * [m_nSets];
		for (DWORD dwSet = 0; dwSet < m_nSets; dwSet++) {
		    m_aValueList[dwSet] = new CGenericList<CurValue>(NAME("value list"));
		}

		SkipWhite(pb);
		m_dwRate = atol(pb);

		SkipWhite(pb);
		m_dwScale = atol(pb);

		SkipWhite(pb);
		m_lMSLength = atol(pb);

		DbgLog((LOG_TRACE, 1, TEXT("Rate = %d  Scale = %d  Length = %d"),
		       m_dwRate, m_dwScale, m_lMSLength));
		
	    } else
	    // lines starting with open braces define the output property sets
	    if (*pb == '{') {    // }
		WCHAR	wszGUID[50];
		
		char * pbEnd = pb;
		while (*pbEnd && *pbEnd != '\r' && *pbEnd != '\n' &&
		      (pbEnd - pb) < (sizeof(wszGUID) / sizeof(wszGUID[0]))) {
		    wszGUID[pbEnd - pb] = *pbEnd;
		    pbEnd++;
		}
		
		wszGUID[pbEnd - pb] = L'\0';

		CLSIDFromString(wszGUID, &m_paSetID[dwSet++]);

		// verify the CLSID?

		if (dwSet == m_nSets) // too many guids?
		    break; // end of header!!!

	    }
	    else {
		// other bad line, error? !!!!
		break;		// end of header!

	    }
	}


	m_pbPostHeader = pb;
    }

    
    m_sLength = MulDiv(m_lMSLength, m_dwRate, m_dwScale * 1000);
		    
		    
    {
	CMediaType mtControl;

	DWORD	dwFormatSize = sizeof(GUID) + 2 * sizeof(DWORD) + m_nSets * sizeof(GUID);

	
	if (mtControl.AllocFormatBuffer(dwFormatSize) == NULL)
	    goto memerror;

	// fill in format block
	PSFORMAT *pmf = (PSFORMAT *) mtControl.Format();

	pmf->psID = PSID_Standard;
	pmf->pID = PID_PROPERTYSETS;
	pmf->dwPropertySize = m_nSets * sizeof(GUID);
	memcpy(pmf->psIDImplemented, m_paSetID, m_nSets * sizeof(GUID));

	mtControl.SetType(&MEDIATYPE_Control);
	mtControl.SetFormatType(&MEDIATYPE_Control);
	mtControl.SetVariableSize();
	mtControl.SetTemporalCompression(FALSE);
	
	// !!! anything else?

	SetOutputMediaType(&mtControl);
    }
    
    return hr;

memerror:
    hr = E_OUTOFMEMORY;
    goto error;

formaterror:
    hr = VFW_E_INVALID_FILE_FORMAT;
    goto error;

readerror:
    hr = VFW_E_INVALID_FILE_FORMAT;

error:
    return hr;
}


ULONG CTextControl::GetMaxSampleSize()
{
    DWORD dwSize = 1000; // !!!!!
    
    return dwSize;
}


// !!! rounding
// returns the sample number showing at time t
LONG
CTextControl::RefTimeToSample(CRefTime t)
{
    // Rounding down
    LONG s = (LONG) ((t.GetUnits() * m_dwRate / m_dwScale) / UNITS);
    return s;
}

CRefTime
CTextControl::SampleToRefTime(LONG s)
{
    // Rounding up
    return llMulDiv( s, UNITS * m_dwScale, m_dwRate, m_dwRate-1 );
}


HRESULT
CTextControl::CheckMediaType(const CMediaType* pmt)
{
    if (*(pmt->Type()) != MEDIATYPE_Stream)
        return E_INVALIDARG;

    if (*(pmt->Subtype()) != CLSID_TextControlSource)
        return E_INVALIDARG;

    return S_OK;
}


HRESULT CTextControl::ReadSample(BYTE *pBuf, DWORD dwSamp, DWORD *pdwSize)
{
    ASSERT(dwSamp == 0 || dwSamp == m_dwLastSamp + 1);
    m_dwLastSamp = dwSamp;
    *pdwSize = 0;
    
    if (dwSamp == 0) { 
	m_pbCurrent = m_pbPostHeader;
	for (DWORD dwSet = 0; dwSet < m_nSets; dwSet++) {
	    // !!! m_aValueList[dwSet].RemoveAll(); // this would leak!
	}
    }
    
    LONG lTimeNow = MulDiv(dwSamp, m_dwScale * 1000, m_dwRate);
    
    char *pb = m_pbCurrent;
    for (;;) {
	m_pbCurrent = pb;
	
	// skip to eol
	while (*pb && *pb != '\r' && *pb != '\n')
	    pb++;

	// skip eol
	while (*pb && (*pb == '\r' || *pb == '\n'))
	    pb++;

	// at eof?
	if (*pb == 0)
	    break;

	// lines starting with ; are comments
	if (*pb == ';')
	    continue;

	if (*pb == 'V' || *pb == 'R') {
	    BOOL	fRamp = (*pb == 'R');

	    SkipWhite(pb);
	    LONG lTimeStamp = atol(pb);

	    // is this in the future, if so, don't need to read any further.
	    if (lTimeStamp > lTimeNow)
		break;
	    
	    SkipWhite(pb);
	    DWORD dwSetID = atol(pb);

	    SkipWhite(pb);
	    DWORD dwPropID = atol(pb);

	    SkipWhite(pb);
	    DWORD dwValue = atol(pb);

	    LONG lRampLength = 0;
	    if (fRamp) {
		SkipWhite(pb);
		lRampLength = atol(pb);
	    }
	    
	    DbgLog((LOG_TRACE, 1, TEXT("Time %d:  Set %d Prop %d %s to %d over %d"),
		   lTimeStamp, dwSetID, dwPropID, fRamp ? "ramp" : "set",
		    dwValue, lRampLength));

	    CurValue * pVal = NULL;
	    CGenericList<CurValue> * list = m_aValueList[dwSetID];
	    for (POSITION p = list->GetHeadPosition();
		 p != NULL; p = list->Next(p)) {
		pVal = list->Get(p);
		ASSERT(pVal);

		if (pVal->dwProp == dwPropID)
		    break;
	    }
		 
	    if (p == NULL) {
		DbgLog((LOG_TRACE, 1, TEXT("Adding new property entry")));
		pVal = new CurValue;

		pVal->dwProp = dwPropID;
		pVal->dwNewValue = 0;

		m_aValueList[dwSetID]->AddTail(pVal);
	    }

	    pVal->dwValue = pVal->dwNewValue;
	    pVal->lTimeStamp = lTimeStamp;
	    pVal->dwNewValue = dwValue;
	    pVal->lRampLength = lRampLength;
	} else {
	    ASSERT(!"Bad line?");

	}
    }

    // OK, now we've parsed the file.  What next?

struct PSDWORDDATA {
    GUID	psID;
    DWORD	pID;
    DWORD	dwPropertySize;
    DWORD	dwProperty;
};

    for (DWORD dwSet = 0; dwSet < m_nSets; dwSet++) {
	CGenericList<CurValue> * list = m_aValueList[dwSet];
    
	for (POSITION p = list->GetHeadPosition();
	     p != NULL; p = list->Next(p) ) {
	    CurValue *pVal = list->Get(p);
	    ASSERT(pVal);

	    PSDWORDDATA * pData = (PSDWORDDATA *) pBuf;
	    pBuf += sizeof(PSDWORDDATA);
	    *pdwSize += sizeof(PSDWORDDATA);

	    pData->psID = m_paSetID[dwSet];
	    pData->pID = pVal->dwProp;
	    pData->dwPropertySize = sizeof(DWORD);

	    DWORD dwVal = pVal->dwNewValue;
	    if (lTimeNow < pVal->lTimeStamp + pVal->lRampLength) {
		dwVal = pVal->dwValue +
			    MulDiv(((LONG) pVal->dwNewValue - pVal->dwValue),
				   lTimeNow - pVal->lTimeStamp,
				   pVal->lRampLength);
	    }
	    
	    pData->dwProperty = dwVal;
	}
    }

    return S_OK;
}

HRESULT CTextControl::FillBuffer(IMediaSample *pSample, DWORD dwStart, DWORD *pdwSamples)
{
    PBYTE pbuf;
    const DWORD lSamples = 1;

    DWORD dwSize = pSample->GetSize();
    
    HRESULT hr = pSample->GetPointer(&pbuf);
    if (FAILED(hr)) {
	DbgLog((LOG_ERROR,1,TEXT("pSample->GetPointer failed!")));
	pSample->Release();
	return E_OUTOFMEMORY;
    }

    
    hr = ReadSample(pbuf, dwStart, &dwSize);
    
    hr = pSample->SetActualDataLength(dwSize);
    ASSERT(SUCCEEDED(hr));

    // mark as a sync point if it should be....
    pSample->SetSyncPoint(TRUE);  // !!!
	
    *pdwSamples = 1;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\control\textcont\textcont.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.

// {533861A0-5064-11d0-A520-D8CC05C10000}
DEFINE_GUID(CLSID_TextControlSource, 
0x533861a0, 0x5064, 0x11d0, 0xa5, 0x20, 0xd8, 0xcc, 0x5, 0xc1, 0x0, 0x0);

#include "simpread.h"

//
// CTextControl
//
class CTextControl : public CSimpleReader {
public:

    // Construct our filter
    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    CCritSec m_cStateLock;      // Lock this when a function accesses
                                // the filter state.
                                // Generally _all_ functions, since access to this
                                // filter will be by multiple threads.

private:

    DECLARE_IUNKNOWN

    CTextControl(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CTextControl();

    // pure CSimpleReader overrides
    HRESULT ParseNewFile();
    HRESULT CheckMediaType(const CMediaType* mtOut);
    LONG StartFrom(LONG sStart) { return 0; };	// always seek from beginning!
    
    HRESULT FillBuffer(IMediaSample *pSample, DWORD dwStart, DWORD *pcSamples);
    LONG RefTimeToSample(CRefTime t);
    CRefTime SampleToRefTime(LONG s);
    ULONG GetMaxSampleSize();

    HRESULT ReadSample(BYTE *pBuf, DWORD dwSamp, DWORD *pdwSize);
    
    struct CurValue {
	DWORD	dwProp;
	DWORD	dwValue;
	LONG	lTimeStamp;
	DWORD	dwNewValue;
	LONG	lRampLength;
    };

    char *      m_pFile;		// whole file, kept in memory
    DWORD	m_nSets;
    GUID *	m_paSetID;

    CGenericList<CurValue> ** m_aValueList;

    char *	m_pbPostHeader;
    char *	m_pbCurrent;
    
    DWORD	m_dwLastSamp;

    DWORD	m_dwRate, m_dwScale;	// rate / scale == output "frame" rate
    LONG	m_lMSLength;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\core\filerend\filerend.cpp ===
// Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.


// Simple parser filter
//

#include <streams.h>

#ifdef FILTER_DLL
#include <initguid.h>
#endif

#include "filerend.h"

// ok to use this as it is not dereferenced
#pragma warning(disable:4355)


const AMOVIESETUP_MEDIATYPE
psudFileRendType[] = { { &MEDIATYPE_File       // 1. clsMajorType
                        , &MEDIASUBTYPE_NULL } }; //    clsMinorType


const AMOVIESETUP_MEDIATYPE
sudFileRendOutType = { &MEDIATYPE_NULL       // 1. clsMajorType
                       , &MEDIASUBTYPE_NULL }; //    clsMinorType

const AMOVIESETUP_PIN
psudFileRendPins[] =  { { L"Input"             // strName
		    , FALSE                // bRendered
		    , FALSE                // bOutput
		    , FALSE                // bZero
		    , FALSE                // bMany
		    , &CLSID_NULL          // clsConnectsToFilter
		    , L""                  // strConnectsToPin
		    , 1                    // nTypes
		    , psudFileRendType }, // lpTypes
		         { L"Output"             // strName
		    , FALSE                // bRendered
		    , TRUE                 // bOutput
		    , FALSE                // bZero
		    , FALSE                // bMany
		    , &CLSID_NULL          // clsConnectsToFilter
		    , L""                  // strConnectsToPin
		    , 1                    // nTypes
		    , &sudFileRendOutType } }; // lpTypes

const AMOVIESETUP_FILTER
sudFileRend = { &CLSID_FileRend     // clsID
               , L"File stream renderer"        // strName
               , MERIT_UNLIKELY        // dwMerit
               , 2                     // nPins
               , psudFileRendPins };   // lpPin



const AMOVIESETUP_MEDIATYPE
psudMultiParseType[] = { { &MEDIATYPE_Stream       // 1. clsMajorType
                        , &CLSID_MultFile } }; //    clsMinorType


const AMOVIESETUP_MEDIATYPE
sudMultiParseOutType = { &MEDIATYPE_NULL       // 1. clsMajorType
                       , &MEDIASUBTYPE_NULL }; //    clsMinorType

const AMOVIESETUP_PIN
psudMultiParsePins[] =  { { L"Input"             // strName
		    , FALSE                // bRendered
		    , FALSE                // bOutput
		    , FALSE                // bZero
		    , FALSE                // bMany
		    , &CLSID_NULL          // clsConnectsToFilter
		    , L""                  // strConnectsToPin
		    , 1                    // nTypes
		    , psudMultiParseType }, // lpTypes
		         { L"Output"             // strName
		    , FALSE                // bRendered
		    , TRUE                 // bOutput
		    , FALSE                // bZero
		    , TRUE                 // bMany
		    , &CLSID_NULL          // clsConnectsToFilter
		    , L""                  // strConnectsToPin
		    , 1                    // nTypes
		    , &sudMultiParseOutType } }; // lpTypes

const AMOVIESETUP_FILTER
sudMultiParse = { &CLSID_MultFile     // clsID
               , L"Multi-file Parser"  // strName
               , MERIT_UNLIKELY        // dwMerit
               , 2                     // nPins
               , psudMultiParsePins };   // lpPin

#ifdef FILTER_DLL
// COM global table of objects available in this dll
CFactoryTemplate g_Templates[] = {

    { L"Multiple Source"
    , &CLSID_FileRend
    , CFileRendFilter::CreateInstance
    , NULL
    , &sudFileRend },
    { L"Multiple Source"
    , &CLSID_MultFile
    , CMultFilter::CreateInstance
    , NULL
    , &sudMultiParse }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// exported entry points for registration and
// unregistration (in this case they only call
// through to default implmentations).
//
STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif

//
// CreateInstance
//
// Called by CoCreateInstance to create our filter
CUnknown *CFileRendFilter::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CFileRendFilter(NAME("Multiple file source"), lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return punk;
}


/* Implements the CFileRendFilter public member functions */


// constructors etc
CFileRendFilter::CFileRendFilter(
    TCHAR *pName,
    LPUNKNOWN pUnk,
    HRESULT *phr)
    : CBaseFilter(pName, pUnk, &m_csLock, CLSID_FileRend),
      m_Input(this, &m_csLock, phr, L"Reader"),
      m_Output(NAME("Fake Output pin"), phr, this, &m_csLock, L"Out")
{
}

CFileRendFilter::~CFileRendFilter()
{
}


// pin enumerator calls this
int CFileRendFilter::GetPinCount() {
    // only expose output pin if we have a reader.
    return 2;
};

// return a non-addrefed pointer to the CBasePin.
CBasePin *
CFileRendFilter::GetPin(int n)
{
    if (n == 0)
	return &m_Input;

    if (n == 1)
	return &m_Output;

    return NULL;
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// input pin

CFileRendInPin::CFileRendInPin(CFileRendFilter *pFilter,
			   CCritSec *pLock,
			   HRESULT *phr,
			   LPCWSTR pPinName) :
   CBaseInputPin(NAME("in pin"), pFilter, pLock, phr, pPinName),
   m_pFilter(pFilter)
{
}

HRESULT CFileRendInPin::CheckMediaType(const CMediaType *pmt)
{
    if (*(pmt->Type()) != MEDIATYPE_File)
        return E_INVALIDARG;

    // !!! further checking?

    return S_OK;
}

/* Implements the CFileRendStream class */


CFileRendStream::CFileRendStream(
    TCHAR *pObjectName,
    HRESULT * phr,
    CFileRendFilter * pFilter,
    CCritSec *pLock,
    LPCWSTR wszPinName)
    : CBaseOutputPin(pObjectName, pFilter, pLock, phr, wszPinName)
    , m_pFilter(pFilter)
{
}

CFileRendStream::~CFileRendStream()
{
}

STDMETHODIMP
CFileRendStream::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IStreamBuilder) {
	return GetInterface((IStreamBuilder *) this, ppv);
    } else {
	return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}

// IPin interfaces


// this pin doesn't support any media types!
HRESULT
CFileRendStream::GetMediaType(int iPosition, CMediaType* pt)
{
    return VFW_S_NO_MORE_ITEMS;
}

// check if the pin can support this specific proposed type&format
HRESULT
CFileRendStream::CheckMediaType(const CMediaType* pt)
{
    ASSERT(0);
    return E_NOTIMPL;
}

HRESULT
CFileRendStream::DecideBufferSize(IMemAllocator * pAllocator,
			     ALLOCATOR_PROPERTIES *pProperties)
{
    ASSERT(0);
    return E_NOTIMPL;
}


// IStreamBuilder::Render -- graph builder will call this
// to do something with our output pin
HRESULT CFileRendStream::Render(IPin * ppinOut, IGraphBuilder * pGraph)
{
    HRESULT hr;

    WCHAR * wsz = m_pFilter->m_Input.CurrentName();

    hr = pGraph->RenderFile(wsz, NULL);

    DbgLog((LOG_TRACE, 1, TEXT("RenderFile %ls returned %x"), wsz, hr));

    // !!! do I need to remember here that this pin has been
    // rendered and I shouldn't do it again?

    return hr;
}





// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1

//
// CreateInstance
//
// Called by CoCreateInstance to create our filter
CUnknown *CMultFilter::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CMultFilter(NAME("Multiple file source"), lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return punk;
}


/* Implements the CMultFilter public member functions */


// constructors etc
CMultFilter::CMultFilter(
    TCHAR *pName,
    LPUNKNOWN pUnk,
    HRESULT *phr)
    : CBaseFilter(pName, pUnk, &m_csLock, CLSID_MultFile),
      m_Input(this, &m_csLock, phr, L"Reader"),
      m_pOutputs(NULL),
      m_nOutputs(0),
      m_pAsyncReader(NULL)
{
}

CMultFilter::~CMultFilter()
{
    ASSERT(!m_pOutputs);
}

HRESULT CMultFilter::CreateOutputPins()
{
    LONGLONG llTotal, llAvailable;

    m_pAsyncReader->Length(&llTotal, &llAvailable);

    DWORD cbFile = (DWORD) llTotal;

    char *lpFile = new char[cbFile];

    if (!lpFile)
	return E_OUTOFMEMORY;

    /* Try to read whole file */
    HRESULT hr = m_pAsyncReader->SyncRead(0, cbFile, (BYTE *) lpFile);

    if (hr != S_OK) {
	delete[] lpFile;
        return E_FAIL;
    }

    // !!! loop through file,

    char *lp = lpFile;
    int		nOutputs = 0;


    WCHAR wsz[200];
    int		cbWide = 0;

    while (cbFile--) {
	if (*lp == '\r' || *lp == '\n') {
	    wsz[cbWide] = L'\0';
	    if (cbWide > 0 && wsz[0] != L';') {
		++nOutputs;
	    }
	    cbWide = 0;
	} else {
	    wsz[cbWide++] = (WCHAR) *lp;
            if(cbWide >= NUMELMS(wsz)) {
                delete[] lpFile;
                return VFW_E_INVALID_FILE_FORMAT;
            }
	}
	lp++;
    }

    m_pOutputs = new CMultStream * [nOutputs];
    if (!m_pOutputs) {
	delete[] lpFile;
	return E_OUTOFMEMORY;
    }

    cbWide = 0;  lp = lpFile;
    cbFile = (DWORD) llTotal;
    while (cbFile--) {
	if (*lp == '\r' || *lp == '\n') {
	    if (cbWide > 0 && wsz[0] != L';') {
		wsz[cbWide] = L'\0';

		m_pOutputs[m_nOutputs++] =
			new CMultStream(NAME("file render output"),
					&hr,
					this,
					&m_csLock,
					wsz);

		if (FAILED(hr)) {
		    break;
		}

		m_pOutputs[m_nOutputs - 1]->AddRef();
	    }
	    cbWide = 0;
	} else {
	    wsz[cbWide++] = (WCHAR) *lp;
	}
	
	lp++;
    }

    delete[] lpFile;

    return hr;
}

HRESULT CMultFilter::RemoveOutputPins()
{
    for (int iStream = 0; iStream < m_nOutputs; iStream++) {
	CMultStream *pPin = m_pOutputs[iStream];
	IPin *pPeer = pPin->GetConnected();
	if(pPeer != NULL) {
	    pPeer->Disconnect();
	    pPin->Disconnect();
	}
	pPin->Release();
    }
    delete[] m_pOutputs;
    m_pOutputs = 0;
    m_nOutputs = 0;

    return S_OK;
}




// pin enumerator calls this
int CMultFilter::GetPinCount() {
    // only expose output pin if we have a reader.
    return m_nOutputs + 1;
};

// return a non-addrefed pointer to the CBasePin.
CBasePin *
CMultFilter::GetPin(int n)
{
    if (n == 0)
	return &m_Input;

    if (n > 0 && n <= m_nOutputs)
	return m_pOutputs[n-1];

    return NULL;
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// input pin

CFRInPin::CFRInPin(CMultFilter *pFilter,
			   CCritSec *pLock,
			   HRESULT *phr,
			   LPCWSTR pPinName) :
   CBasePin(NAME("in pin"), pFilter, pLock, phr, pPinName, PINDIR_INPUT),
   m_pFilter(pFilter)
{
}

HRESULT CFRInPin::CheckMediaType(const CMediaType *pmt)
{
    if (*(pmt->Type()) != MEDIATYPE_Stream)
        return E_INVALIDARG;

    if (*(pmt->Subtype()) != CLSID_MultFile)
        return E_INVALIDARG;

    return S_OK;
}

// ------------------------------------------------------------------------
// calls the filter to parse the file and create the output pins.

HRESULT CFRInPin::CompleteConnect(
  IPin *pReceivePin)
{
    HRESULT hr = pReceivePin->QueryInterface(IID_IAsyncReader,
					     (void**)&m_pFilter->m_pAsyncReader);

    if(FAILED(hr))
	return hr;

    return m_pFilter->CreateOutputPins();
}

HRESULT CFRInPin::BreakConnect()
{
    if (m_pFilter->m_pAsyncReader) {
	m_pFilter->m_pAsyncReader->Release();
	m_pFilter->m_pAsyncReader = NULL;
    }

    m_pFilter->RemoveOutputPins();

    return CBasePin::BreakConnect();
}

/* Implements the CMultStream class */


CMultStream::CMultStream(
    TCHAR *pObjectName,
    HRESULT * phr,
    CMultFilter * pFilter,
    CCritSec *pLock,
    LPCWSTR wszPinName)
    : CBasePin(pObjectName, pFilter, pLock, phr, wszPinName, PINDIR_OUTPUT)
    , m_pFilter(pFilter)
{
    // initialize output media type
    m_mt.SetType(&MEDIATYPE_File);
    m_mt.SetSubtype(&CLSID_NULL);
    m_mt.SetFormatType(&MEDIATYPE_File);
    m_mt.SetFormat((BYTE *) wszPinName, (lstrlenW(wszPinName) + 1) * 2);
    // !!! fill in other fields?
}

CMultStream::~CMultStream()
{
}

STDMETHODIMP_(ULONG)
CMultStream::NonDelegatingAddRef()
{
    return CUnknown::NonDelegatingAddRef();
}


/* Override to decrement the owning filter's reference count */

STDMETHODIMP_(ULONG)
CMultStream::NonDelegatingRelease()
{
    return CUnknown::NonDelegatingRelease();
}

// IPin interfaces

HRESULT
CMultStream::GetMediaType(int iPosition, CMediaType* pt)
{
    if (iPosition != 0)
	return VFW_S_NO_MORE_ITEMS;

    *pt = m_mt;

    return S_OK;
}

// check if the pin can support this specific proposed type&format
HRESULT
CMultStream::CheckMediaType(const CMediaType* pt)
{
    return (*pt == m_mt) ? S_OK : E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\core\msreader\alloc.h ===
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)

// an allocator which can parcel out different samples within a record

#ifndef _alloc_h
#define _alloc_h

class CRecSample :
  public CMediaSample           // A non delegating IUnknown
{

private:

  class CRecBuffer   *m_pParentBuffer; // attached to this cache buffer
  DWORD m_dwUserContext;

  bool m_fDelivered;
  friend class CRecAllocator;

public:

  CRecSample(
    TCHAR *pName,
    CBaseAllocator *pAllocator,
    HRESULT *phr,
    LPBYTE pBuffer = NULL,
    LONG length = 0);

  ~CRecSample();

  HRESULT SetParent(CRecBuffer *pRecBuffer);

  void MarkDelivered();

  // zero means its a regular sample; o/w HandleData will be called.
  void SetUser(DWORD dwUser) { m_dwUserContext = dwUser; }
  DWORD GetUser() { return m_dwUserContext; }

  STDMETHODIMP SetActualDataLength(LONG lActual);
  STDMETHODIMP_(ULONG) Release();
};

// implementation of CBaseAllocator similar to CMemAllocator but
// doesn't allocate memory for GetBuffer();

class CRecAllocator : public CBaseAllocator
{
  // override to free the memory when decommit completes
  // - we actually do nothing, and save the memory until deletion.
  void Free(void);

  // called from the destructor (and from Alloc if changing size/count) to
  // actually free up the memory
  void ReallyFree(void);

  // overriden to allocate the memory when commit called
  HRESULT Alloc(void);

  BYTE *m_pBuffer;

  // We want to tell the audio renderer to buffer no more than some
  // amount of audio so that we are reading audio and video from the
  // same place in the file (audio is dwInitial frames ahead of video
  // in AVI). cbBuffer * cBuffers would do this except the audio
  // renderer makes cbBuffer at least 1/2 second and cBuffers is an
  // arbitrarily large number for us. So we want the audio renderer to
  // see this number. Even though it has 1/2 second buffers and we are
  // filling in say 1/15 of a second, this keeps it from running ahead.
  ULONG m_cBuffersReported;

  HANDLE m_heSampleReleased;

  LONG m_cDelivered;

  inline void IncrementDelivered();
  inline void DecrementDelivered();
  friend class CRecSample;

public:

  STDMETHODIMP SetProperties(ALLOCATOR_PROPERTIES* pRequest,
                             ALLOCATOR_PROPERTIES* pActual);

  STDMETHODIMP SetPropertiesInternal(ALLOCATOR_PROPERTIES* pRequest,
                                     ALLOCATOR_PROPERTIES* pActual);

  STDMETHODIMP GetProperties(ALLOCATOR_PROPERTIES* pAPOut);

  STDMETHODIMP GetBuffer(CRecSample **ppBuffer,
                         REFERENCE_TIME * pStartTime,
                         REFERENCE_TIME * pEndTime,
                         DWORD dwFlags);

  CRecAllocator(TCHAR *, LPUNKNOWN, HRESULT *);
  ~CRecAllocator();

  HRESULT SetCBuffersReported(UINT cBuffers);

  inline int CSamplesDownstream() { return m_cDelivered; }

  HANDLE hGetDownstreamSampleReleased(){ return m_heSampleReleased; }
};

#endif // _alloc_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\core\msreader\basemsr.cpp ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include "basemsr.h"

// ------------------------------------------------------------------------
// -------- Implements the CBaseMSRFilter public member functions ---------

#pragma warning(disable:4355)

// constructor
//
CBaseMSRFilter::CBaseMSRFilter(
  TCHAR *pName,
  LPUNKNOWN pUnk,
  CLSID clsid,
  HRESULT *phr) :
    CBaseFilter(pName, pUnk, this, clsid),
    C_MAX_REQS_PER_STREAM(64)
{
  m_cStreams = 0;

  m_pImplBuffer = 0;
  m_pAsyncReader = 0;

  m_rgpOutPin = 0;
  m_pInPin = 0;

  m_iStreamSeekingIfExposed = -1;
  m_heStartupSync = 0;
  m_ilcStreamsNotQueued = 0;

  if(FAILED(*phr))
    return;

  m_heStartupSync = CreateEvent(0, TRUE, FALSE, 0);
  if(m_heStartupSync == 0)
    *phr = AmHresultFromWin32(GetLastError());

  m_dwSeekingCaps = AM_SEEKING_CanSeekForwards
		  | AM_SEEKING_CanSeekBackwards
		  | AM_SEEKING_CanSeekAbsolute
		  | AM_SEEKING_CanGetStopPos
		  | AM_SEEKING_CanGetDuration;

  // too bad we can't call derived->CreateInputPin here
}

// destructor
//
CBaseMSRFilter::~CBaseMSRFilter()
{
  delete m_pInPin;

  if(m_pImplBuffer)
    m_pImplBuffer->Close();
  delete m_pImplBuffer;

  if(m_pAsyncReader)
    m_pAsyncReader->Release();

  if(m_rgpOutPin)
    for(UINT iStream = 0; iStream < m_cStreams; iStream++)
      delete m_rgpOutPin[iStream];
  delete[] m_rgpOutPin;

  if(m_heStartupSync)
    CloseHandle(m_heStartupSync);
}

HRESULT CBaseMSRFilter::CreateInputPin(CBaseMSRInPin **ppInPin)
{
  HRESULT hr = S_OK;
  *ppInPin = new CBaseMSRInPin(this, &hr, L"input pin");
  if(*ppInPin == 0)
    return E_OUTOFMEMORY;

  return hr;
}

HRESULT CBaseMSRFilter::RemoveOutputPins()
{
  for(UINT iStream = 0; iStream < m_cStreams; iStream++)
  {
    CBaseMSROutPin *pPin = m_rgpOutPin[iStream];
    IPin *pPeer = pPin->GetConnected();
    if(pPeer != NULL)
    {
      pPeer->Disconnect();
      pPin->Disconnect();
    }
    pPin->Release();
  }
  delete[] m_rgpOutPin;
  m_rgpOutPin = 0;

  m_cStreams = 0;

  return S_OK;
}

int CBaseMSRFilter::GetPinCount()
{
  // output pins + 1 input pin. valid before and after connections
  return m_cStreams + 1;
}

// return a non-addrefed pointer to the CBasePin.
CBasePin * CBaseMSRFilter::GetPin(int ii)
{
  if (m_cStreams > 0  &&  ii < (int)m_cStreams)
    return m_rgpOutPin[ii];

  if(ii == (int)m_cStreams)
    return m_pInPin;

  return 0;
}

//
// FindPin
//
// return the IPin that has the given pin id
//
// HRESULT CBaseMSRFilter::FindPin (
//   LPCWSTR pwszPinId,
//   IPin ** ppPin)
// {
//   // !!! handle bad ids.
//   unsigned short *pwszPinId_ = (unsigned short *)pwszPinId;
//   int ii = WstrToInt(pwszPinId_); // in sdk\classes\base\util
//   *ppPin = GetPin(ii);

//   if (*ppPin) {
//     (*ppPin)->AddRef();
//     return S_OK;
//   }

//   return VFW_E_NOT_FOUND;
// }

HRESULT CBaseMSRFilter::Pause()
{
  CAutoLock lock(this);
  HRESULT hr = S_OK;

  if(m_State == State_Stopped)
  {
    // pins on which Active is called will decrement
    // m_ilcStreamsNotQueued
    m_ilcStreamsNotQueued = 0;
    for (unsigned c = 0; c < m_cStreams; c++)
    {
      if(m_rgpOutPin[c]->IsConnected())
      {
        m_ilcStreamsNotQueued++;
      }
    }

    DbgLog((LOG_TRACE, 15,
	    TEXT("Pause: m_ilcStreamsNotQueued = %d"), m_ilcStreamsNotQueued));


    EXECUTE_ASSERT(ResetEvent(m_heStartupSync));

    if(m_State == State_Stopped && m_pImplBuffer)
    {
      // start the i/o thread. !!! this assumes that the upstream filter
      // has paused before us. why does it work?
      m_pImplBuffer->Start();
    }

    // this makes the pin threads push samples if we were stopped
    hr = CBaseFilter::Pause();

    // put all threads in known state so that subsequent Pauses don't
    // hang.
    if(FAILED(hr))
    {
      // base class won't call Inactive unless we change m_State;
      m_State = State_Paused;
      Stop();
    }
  } // State_Stopped
  else
  {
    hr = CBaseFilter::Pause();
  }


  return hr;
}

HRESULT CBaseMSRFilter::Stop()
{
  CAutoLock lock(this);
  if(m_pImplBuffer)
    m_pImplBuffer->BeginFlush();

  // tell each pin to stop
  HRESULT hr = CBaseFilter::Stop();

  if(m_pImplBuffer)
    m_pImplBuffer->EndFlush();

  ASSERT(m_ilcStreamsNotQueued == 0);

  return hr;
}

void CBaseMSRFilter::SetSeekingIf(ULONG iStream)
{
  CAutoLock lock(&m_csSeekingStream);
  m_iStreamSeekingIfExposed = iStream;
  DbgLog((LOG_TRACE, 5,
	  TEXT("CBaseFilter:SetSeekingIf: pin %d created seeking if"),
	  iStream));
}

BOOL
CBaseMSRFilter::RequestSeekingIf(ULONG iStream)
{
  CAutoLock lock(&m_csSeekingStream);
  ASSERT(iStream < m_cStreams);

  if(m_iStreamSeekingIfExposed == (long)iStream)
    return TRUE;

  if(m_iStreamSeekingIfExposed != -1)
  {
    DbgLog((LOG_TRACE, 5,
	    TEXT("CBaseFilter:RequestSeekingIf: refused %d. %d has it"),
	    iStream, m_iStreamSeekingIfExposed));
    return FALSE;
  }

  m_iStreamSeekingIfExposed = iStream;
  DbgLog((LOG_TRACE, 5,
	  TEXT("CBaseFilter:RequestSeekingIf: pin %d created seeking if"),
	  iStream));

  return TRUE;
}

HRESULT CBaseMSRFilter::SeekOtherStreams(
  ULONG iSeekingStream,
  REFERENCE_TIME *prtStart,
  REFERENCE_TIME *prtStop,
  double dRate,
  DWORD dwSeekFlags)
{
  for(ULONG iStream = 0; iStream < m_cStreams; iStream++)
  {
    if(iStream == iSeekingStream)
      continue;

    HRESULT hr = m_rgpOutPin[iStream]->UpdateSelectionAndTellWorker(
      prtStart,
      prtStop,
      0,
      dRate,
      &TIME_FORMAT_MEDIA_TIME,
      dwSeekFlags);
    if(FAILED(hr))
      return hr;
  }
  return S_OK;
}

HRESULT CBaseMSRFilter::StopFlushRestartAllStreams(DWORD dwSeekFlags)
{
  // big race between stopping and running worker since we have to
  // call endflush inbetween stopping and running the worker. but a
  // stop can't happen then. A run should be safe.

  CAutoLock lock(this);
  FILTER_STATE state = m_State;

  m_pImplBuffer->BeginFlush();

  for(UINT iStream = 0; iStream < m_cStreams; iStream++)
  {
    m_rgpOutPin[iStream]->StopWorker(
	dwSeekFlags & AM_SEEKING_NoFlush ? false : true);

    //  Update the segment number NOW - after this call we may complete
    //  and actually use it!
    //  But don't do it before StopWorker or the previous stream might
    //  complete with the wrong segment number
    if (dwSeekFlags & AM_SEEKING_Segment) {
	m_rgpOutPin[iStream]->m_dwSegmentNumber++;
	NotifyEvent(
	    EC_SEGMENT_STARTED,
	    (LONG_PTR)&m_rgpOutPin[iStream]->m_rtAccumulated,
	    m_rgpOutPin[iStream]->m_dwSegmentNumber);
    } else {
	m_rgpOutPin[iStream]->m_dwSegmentNumber = 0;
    }
    m_pImplBuffer->ClearPending(iStream);
  }

  m_pImplBuffer->EndFlush();

  if(state != State_Stopped)
  {
    m_pImplBuffer->Start();

    ResetEvent(m_heStartupSync);
    // RestartWorker will decrement m_ilcStreamsNotQueued
    m_ilcStreamsNotQueued = m_cStreams;

    for(iStream = 0; iStream < m_cStreams; iStream++)
    {
      m_rgpOutPin[iStream]->RestartWorker();
    }
  }

  return S_OK;
}

HRESULT CBaseMSRFilter::NotifyInputConnected(IAsyncReader *pAsyncReader)
{
  // these are reset when disconnected
  ASSERT(m_pImplBuffer == 0);
  ASSERT(m_pAsyncReader == 0);

  m_iStreamSeekingIfExposed = -1;

  // fail if any output pins are connected.
  UINT iStream;
  for(iStream = 0; iStream < m_cStreams; iStream++)
  {
    if(m_rgpOutPin[iStream] && m_rgpOutPin[iStream]->GetConnected())
      // !!! can't find a good error.
      return VFW_E_FILTER_ACTIVE;
  }

  // remove any output pins left
  this->RemoveOutputPins();

  // done here because LoadHeader uses m_pAsyncReader
  m_pAsyncReader = pAsyncReader;
  pAsyncReader->AddRef();

  HRESULT hr = this->CreateOutputPins();
  if(FAILED(hr))
  {
    m_pAsyncReader->Release();
    m_pAsyncReader = 0;
    return hr;
  }

  for(iStream = 0; iStream < m_cStreams; iStream++)
  {
    hr = m_rgpOutPin[iStream]->InitializeOnNewFile();
    if(FAILED(hr))
    {
      m_pAsyncReader->Release();
      m_pAsyncReader = 0;
      return hr;
    }
  }

  StreamBufParam rgSbp[C_STREAMS_MAX];
  ULONG cbRead, cBuffers;
  int iLeadingStream;
  hr = this->GetCacheParams(rgSbp, &cbRead, &cBuffers, &iLeadingStream);
  ASSERT(SUCCEEDED(hr));

  DbgLog(( LOG_TRACE, 5,
	   TEXT("CBaseMSRFilter: cbRead %d, cBuffers %d, iLeadingStream %d"),
	   cbRead, cBuffers, iLeadingStream));

  for(iStream = 0; iStream < m_cStreams; iStream++)
  {
      // callee will addref
      rgSbp[iStream].pAllocator = m_rgpOutPin[iStream]->m_pRecAllocator;
  }

  hr = CreateMultiStreamReader(
    pAsyncReader,
    m_cStreams,
    rgSbp,
    cbRead,
    cBuffers,
    iLeadingStream,
    &m_pImplBuffer);

  if(FAILED(hr))
  {
    pAsyncReader->Release();
    m_pAsyncReader = 0;

    ASSERT(m_pImplBuffer == 0);

    for(UINT iStream = 0; iStream < m_cStreams; iStream++)
      delete m_rgpOutPin[iStream];
    delete[] m_rgpOutPin;
    m_rgpOutPin = 0;
    m_cStreams =0;
  }

  return hr;
}

HRESULT CBaseMSRFilter::NotifyInputDisconnected()
{
  if (m_pAsyncReader)
  {
    m_pAsyncReader->Release();
    m_pAsyncReader = 0;
  }

  this->RemoveOutputPins();

  delete m_pImplBuffer;
  m_pImplBuffer =0;


  return S_OK;
}

// allocate a hunk of memory and read the requested region of the
// file into it.
HRESULT CBaseMSRFilter::AllocateAndRead (
  BYTE **ppb,
  DWORD cb,
  DWORDLONG qwPos)
{
  *ppb = 0;
  LPBYTE lpb = new BYTE[cb];
  if ( ! lpb)
    return E_OUTOFMEMORY;

  HRESULT hr = m_pAsyncReader->SyncRead(qwPos, cb, lpb);

  // IAsyncReader::SyncRead() returns S_FALSE if it "[r]etrieved fewer bytes 
  // than requested." (MSDN Janurary 2002).
  if(S_OK == hr)
  {
    *ppb = lpb;
    return S_OK;
  } else if(SUCCEEDED(hr)) {
    hr = E_FAIL;
  }

  // the read was a failure. free the buffer and return NULL
  DbgLog((LOG_ERROR,1,TEXT("Failed to read %d bytes error = %08X"), cb, hr));
  delete[] lpb;
  return hr;
}

HRESULT CBaseMSRFilter::GetCacheParams(
  StreamBufParam *rgSbp,
  ULONG *pcbRead,
  ULONG *pcBuffers,
  int *piLeadingStream)
{
  *piLeadingStream = -1;        // no leading stream

  UINT iStream;
  for(iStream = 0; iStream < m_cStreams; iStream++)
  {
    ZeroMemory(&rgSbp[iStream], sizeof(rgSbp[iStream]));
    rgSbp[iStream].cbSampleMax = m_rgpOutPin[iStream]->GetMaxSampleSize();
    rgSbp[iStream].cSamplesMax = C_MAX_REQS_PER_STREAM;
  }
  *pcbRead = 0;
  *pcBuffers = 0;

  return S_OK;
}

void CBaseMSRFilter::NotifyStreamQueuedAndWait()
{
  long lQueued = InterlockedDecrement(&m_ilcStreamsNotQueued);
  ASSERT(lQueued >= 0);
  if(lQueued == 0)
  {
    DbgLog((LOG_TRACE, 5,
	    TEXT("CBaseMSRFilter::NotifyStreamQueuedAndWait signal")));
    EXECUTE_ASSERT(SetEvent(m_heStartupSync));
  }
  else
  {
    DbgLog((LOG_TRACE, 5,
	    TEXT("CBaseMSRFilter::NotifyStreamQueuedAndWait block")));
    EXECUTE_ASSERT(
      WaitForSingleObject(m_heStartupSync, INFINITE) == WAIT_OBJECT_0);
  }
}

void CBaseMSRFilter::NotifyStreamQueued()
{
  long lQueued = InterlockedDecrement(&m_ilcStreamsNotQueued);
  ASSERT(lQueued >= 0);
  if(lQueued == 0)
  {
    DbgLog((LOG_TRACE, 5, TEXT("CBaseMSRFilter::NotifyStreamQueued signal")));
    EXECUTE_ASSERT(SetEvent(m_heStartupSync));
  }
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// input pin

CBaseMSRInPin::CBaseMSRInPin(
  CBaseMSRFilter *pFilter,
  HRESULT *phr,
  LPCWSTR pPinName) :
    CBasePin(NAME("in pin"), pFilter, pFilter, phr, pPinName, PINDIR_INPUT)
{
  m_pFilter = pFilter;
}

CBaseMSRInPin::~CBaseMSRInPin()
{
}

HRESULT CBaseMSRInPin::CheckMediaType(const CMediaType *mtOut)
{
  return m_pFilter->CheckMediaType(mtOut);
}

TimeFormat
CBaseMSRFilter::MapGuidToFormat(const GUID *const pGuidFormat)
{
  if(*pGuidFormat == TIME_FORMAT_MEDIA_TIME)
    return FORMAT_TIME;
  else if(*pGuidFormat == TIME_FORMAT_SAMPLE)
    return FORMAT_SAMPLE;
  else if(*pGuidFormat == TIME_FORMAT_FRAME)
    return FORMAT_FRAME;

  DbgBreak("?unknown format");
  return FORMAT_NULL;
}

HRESULT CBaseMSRInPin::CheckConnect(IPin * pPin)
{
  HRESULT hr;

  hr = CBasePin::CheckConnect(pPin);
  if(FAILED(hr))
    return hr;

  IAsyncReader *pAsyncReader = 0;
  hr = pPin->QueryInterface(IID_IAsyncReader, (void**)&pAsyncReader);
  if(SUCCEEDED(hr))
    pAsyncReader->Release();

  // E_NOINTERFACE is a reasonable error
  return hr;
}

// ------------------------------------------------------------------------
// calls the filter to parse the file and create the output pins.

HRESULT CBaseMSRInPin::CompleteConnect(
  IPin *pReceivePin)
{
  HRESULT hr = CBasePin::CompleteConnect(pReceivePin);
  if(FAILED(hr))
    return hr;

  IAsyncReader *pAsyncReader = 0;
  hr = pReceivePin->QueryInterface(IID_IAsyncReader, (void**)&pAsyncReader);
  if(FAILED(hr))
    return hr;

  hr = m_pFilter->NotifyInputConnected(pAsyncReader);
  pAsyncReader->Release();

  return hr;
}

HRESULT CBaseMSRInPin::BreakConnect()
{
  HRESULT hr = CBasePin::BreakConnect();
  if(FAILED(hr))
    return hr;

  return m_pFilter->NotifyInputDisconnected();
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// output pin

// ------------------------------------------------------------------------
// constructor

CBaseMSROutPin::CBaseMSROutPin(
  CBaseFilter *pOwningFilter,
  CBaseMSRFilter *pFilter,
  UINT iStream,
  IMultiStreamReader *&rpImplBuffer,
  HRESULT *phr,
  LPCWSTR pName) :
    CBaseOutputPin(NAME("source pin"), pOwningFilter, &m_cs, phr, pName),
    m_id(iStream),
    m_rpImplBuffer(rpImplBuffer),
    m_rtAccumulated(0),
    m_dwSegmentNumber(0)
{
  m_pFilter = pFilter;

  // have the pin addref the filter
  // these are dynamic pins and have an independent lifetime from the filter's 
  // perspective, but still require the parent filter to stay alive 
  m_pFilter->AddRef();
    
  m_pPosition = 0;
  m_pSelection = 0;
  m_pWorker = 0;
  m_pRecAllocator = 0;

  m_llImsStart = m_llImsStop = 0;
  m_dImsRate = 0;
  m_ilfNewImsValues = FALSE;
  m_fUsingExternalMemory = FALSE;

  m_guidFormat = TIME_FORMAT_MEDIA_TIME;

  if(FAILED(*phr))
    return;

  CRecAllocator *pAllocator = new CRecAllocator(
    NAME("CBaseMSROutPin allocator"),
    0,
    phr);
  if(pAllocator == 0)
    *phr = E_OUTOFMEMORY;
  if(FAILED(*phr))
    return;

  m_pRecAllocator = pAllocator;
  pAllocator->AddRef();

 ASSERT(m_pRecAllocator);

}

CBaseMSROutPin::~CBaseMSROutPin()
{
  // these have the same lifetime as the pin; the pin is responsible
  // for deleting them
  delete m_pPosition;
  delete m_pSelection;

  if(m_pWorker && m_pWorker->ThreadExists())
      m_pWorker->Exit();
  delete m_pWorker;

  if(m_pRecAllocator)
    m_pRecAllocator->Release();
    
  m_pFilter->Release();    

}

STDMETHODIMP
CBaseMSROutPin::NonDelegatingQueryInterface (
  REFIID riid,
  void ** pv)
{
  if(riid == IID_IMediaSeeking ||  riid == IID_IMediaPosition)
  {
    if(m_pSelection == 0)
    {
      HRESULT hr = CreateImplSelect();
      if(FAILED(hr))
	return hr;
      ASSERT(m_pSelection);
    }
    return m_pSelection->NonDelegatingQueryInterface(riid, pv);
  }
  else
  {
    return CBaseOutputPin::NonDelegatingQueryInterface(riid, pv);
  }
}

STDMETHODIMP_(ULONG)
CBaseMSROutPin::NonDelegatingAddRef()
{
    return CUnknown::NonDelegatingAddRef();
}


/* Override to decrement the owning filter's reference count */

STDMETHODIMP_(ULONG)
CBaseMSROutPin::NonDelegatingRelease()
{
    return CUnknown::NonDelegatingRelease();
}

// check if the pin can support this specific proposed type&format
//
HRESULT
CBaseMSROutPin::CheckMediaType (
  const CMediaType* pmt)
{
  // we support exactly the types we propose, and
  // no other.
  //
  for (int i = 0; ; i++) {
      CMediaType mt;
      if (S_OK == GetMediaType(i,&mt)) {
	  if (mt == *pmt)
	    return NOERROR;
      } else {
	  break;
      }
  }
  return E_INVALIDARG;
}

HRESULT
CBaseMSROutPin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
  ASSERT(!m_fUsingExternalMemory);
  *ppAlloc = 0;
  ASSERT(m_pRecAllocator);

  if(UseDownstreamAllocator())
  {
    HRESULT hr = CBaseOutputPin::DecideAllocator(pPin, ppAlloc);
    if(FAILED(hr))
    {
      DbgLog((LOG_ERROR, 2,
	      TEXT("CBaseMSROutPin::DecideAllocator: failed %08x"), hr));
      return hr;
    }
  }
  else
  {
    IAMDevMemoryAllocator *pDevAlloc;
    IMemAllocator *pAlloc;
    HRESULT hr;

    hr = pPin->GetAllocator(&pAlloc);
    if (SUCCEEDED(hr))
    {
      hr = pAlloc->QueryInterface(
	IID_IAMDevMemoryAllocator, (void **)&pDevAlloc);
      if(SUCCEEDED(hr))
      {
	hr = m_pFilter->NotifyExternalMemory(pDevAlloc);
	if(hr == S_OK)
	{
	  m_fUsingExternalMemory = TRUE;
	}

	pDevAlloc->Release();
      }
      pAlloc->Release();
    }

    hr = pPin->NotifyAllocator(m_pRecAllocator, TRUE);
    if(FAILED(hr))
    {
	DbgLog((LOG_ERROR, 2,
		TEXT("CBaseMSROutPin::DecideAllocator: notify failed %08x"), hr));
	return hr;
    }


    *ppAlloc = m_pRecAllocator;
    m_pRecAllocator->AddRef();
  }

  return S_OK;
}

// DecideBufferSize is pure in CBaseOutputPin so it's defined
// here. our DecideAllocator never calls it though.

HRESULT
CBaseMSROutPin::DecideBufferSize(
  IMemAllocator * pAlloc,
  ALLOCATOR_PROPERTIES *Properties)
{
  DbgBreak("this should never be called.");
  return E_UNEXPECTED;
}

HRESULT
CBaseMSROutPin::GetDeliveryBufferInternal(
  CRecSample ** ppSample,
  REFERENCE_TIME * pStartTime,
  REFERENCE_TIME * pEndTime,
  DWORD dwFlags)
{
  if(m_pAllocator == 0)
    return E_NOINTERFACE;

  // use m_pRecAllocator since we may be copying to m_pAllocator which
  // might be different.
  return m_pRecAllocator->GetBuffer(
    ppSample,
    pStartTime,
    pEndTime,
    dwFlags);
}

// ------------------------------------------------------------------------
// IMediaSelection helpers

HRESULT CBaseMSROutPin::IsFormatSupported(const GUID *const pFormat)
{
  return *pFormat == TIME_FORMAT_MEDIA_TIME ? S_OK : S_FALSE;
}

HRESULT CBaseMSROutPin::QueryPreferredFormat(GUID *pFormat)
{
  *pFormat = TIME_FORMAT_MEDIA_TIME;
  return S_OK;
}

HRESULT CBaseMSROutPin::SetTimeFormat(const GUID *const pFormat)
{
  if(IsFormatSupported(pFormat) != S_OK)
    return E_INVALIDARG;

  // prevent the filter from going active from under us
  CAutoLock lock(m_pFilter);

  // state changes do happen synchronously, so this will return
  // immediately.
  FILTER_STATE fs;
  HRESULT hr = m_pFilter->GetState(INFINITE, &fs);
  ASSERT(SUCCEEDED(hr));
  if(FAILED(hr))
    return hr;

  if(fs != State_Stopped)
    return VFW_E_WRONG_STATE;

  m_guidFormat = *pFormat;

  m_pFilter->SetSeekingIf(m_id);

  // we need to set the m_llImsStart and stop values. none were set,
  // so just use the entire file. we'll still play the right subset.
  m_llImsStart = m_llCvtImsStart;
  m_llImsStop = m_llCvtImsStop;

  // !!! what about TIME_FORMAT_KEYFRAMES and other formats
  if(m_guidFormat == TIME_FORMAT_MEDIA_TIME)
  {
    m_llImsStop = ConvertInternalToRT(m_llImsStop);
    m_llImsStart = ConvertInternalToRT(m_llImsStart);
  }

  return S_OK;
}

HRESULT CBaseMSROutPin::ConvertTimeFormat(
    LONGLONG * pTarget, const GUID * pTargetFormat,
    LONGLONG    Source, const GUID * pSourceFormat
)
{
    CheckPointer( pTarget, E_POINTER );

    // Assume the worst...
    HRESULT hr = E_INVALIDARG;

    // evaluate the format arguments
    const GUID *pSrcFmtEval = pSourceFormat ? pSourceFormat : &m_guidFormat;
    const GUID *pTargFmtEval = pTargetFormat ? pTargetFormat : &m_guidFormat;

    if ( *pTargFmtEval == *pSrcFmtEval)
    {
	*pTarget = Source;
	hr = NOERROR;
    }
    else if (*pTargFmtEval == TIME_FORMAT_MEDIA_TIME &&
	     (*pSrcFmtEval == TIME_FORMAT_SAMPLE ||
	      *pSrcFmtEval == TIME_FORMAT_FRAME))
    {

	*pTarget = ConvertInternalToRT( Source );
	hr = NOERROR;

    }
    else if (*pSrcFmtEval == TIME_FORMAT_MEDIA_TIME &&
	     (*pTargFmtEval == TIME_FORMAT_FRAME ||
	      *pTargFmtEval == TIME_FORMAT_SAMPLE))
    {

	*pTarget = ConvertRTToInternal( Source );
	hr = NOERROR;
    }

    return hr;
}

HRESULT CBaseMSROutPin::GetTimeFormat(GUID *pFormat)
{
  *pFormat = m_guidFormat;
  return S_OK;
}

HRESULT
CBaseMSROutPin::UpdateSelectionAndTellWorker(
  LONGLONG *pCurrent,
  LONGLONG *pStop,
  REFTIME *pTime,
  double dRate,
  const GUID *const pGuidFormat,
  DWORD dwSeekFlags)
{
  {
    // protect from worker thread
    CAutoLock lock(&m_csImsValues);

    HRESULT hr;
    if (dRate != 0) m_dImsRate = dRate;

    DbgLog((LOG_TRACE, 5, TEXT("CBaseMSROutPin::SetSelection: %d - %d"),
	    pCurrent ? (LONG)*pCurrent : -1,
	    pStop ? (LONG)*pStop : -1
	    ));

    hr = RecordStartAndStop(
	pCurrent,
	pStop,
	pTime,
	pGuidFormat ? pGuidFormat : &m_guidFormat);

    if(FAILED(hr)) return hr;

    if(pCurrent)
    {
      m_llImsStart = *pCurrent;
    }

    if(pStop)
      m_llImsStop = *pStop;

    m_dwSeekFlags = dwSeekFlags;
  }

  if(!pCurrent) {
      InterlockedExchange(&m_ilfNewImsValues, TRUE);
  }

  // if this is the one with the interface, seek the other streams
  if(m_pFilter->RequestSeekingIf(m_id))
  {
    ASSERT(m_guidFormat != TIME_FORMAT_NONE);
    // flush the file source and seek the other streams (in time
    // units)
    HRESULT hr;
    if(m_guidFormat == TIME_FORMAT_MEDIA_TIME)
    {
      hr = m_pFilter->SeekOtherStreams(
	m_id,
	pCurrent ? &m_llImsStart : 0,
	pStop    ? &m_llImsStop  : 0,
	m_dImsRate,
	dwSeekFlags);
    }
    else
    {
      REFERENCE_TIME rtStart =
	pCurrent ? ConvertInternalToRT(m_llCvtImsStart) : 0;
      REFERENCE_TIME rtStop =
	pStop    ? ConvertInternalToRT(m_llCvtImsStop)  : 0;

      ASSERT(m_guidFormat == TIME_FORMAT_SAMPLE ||
	     m_guidFormat == TIME_FORMAT_FRAME);
      hr = m_pFilter->SeekOtherStreams(
	m_id,
	pCurrent ? &rtStart : 0,
	pStop    ? &rtStop  : 0,
	m_dImsRate,
	dwSeekFlags);
    }
    if(FAILED(hr))
      return hr;

    if(pCurrent)
    {
      hr = m_pFilter->StopFlushRestartAllStreams(dwSeekFlags);
      if(FAILED(hr))
	return hr;
    }
  }
  return S_OK;
}

HRESULT CBaseMSROutPin::StopWorker(bool bFlush)
{
  // this lock should not be the same as the lock that protects
  // access to the start/stop/rate values. The worker thread will
  // need to lock that on some code paths before responding to a
  // Stop and thus will cause deadlock.

  // what we are locking here is access to the worker thread, and
  // thus we should hold the lock that prevents more than one client
  // thread from accessing the worker thread.

  if(m_pWorker == 0)
    return S_OK;

  CAutoLock lock(&m_pWorker->m_AccessLock);

  if(m_pWorker->ThreadExists())
  {
    DbgLog((LOG_TRACE, 5, TEXT("CBaseMSROutPin::RestartWorker")));

    // next time round the loop the worker thread will pick up the
    // position change.

    // We need to flush all the existing data - we must do that here
    // as our thread will probably be blocked in GetBuffer otherwise

    if (bFlush) {
	DeliverBeginFlush();
    }

    // make sure we have stopped pushing
    m_pWorker->Stop();

    // complete the flush
    if (bFlush) {
	DeliverEndFlush();

	// Clear segment stuff if flushing
	// but don't clear the number here - that only happens on
	// Stop() otherwise the filter graph can't reconcile
	// segment ends if SetPositions is called without NoFlush but
	// with Segment
	m_rtAccumulated = 0;
    }
  }

  return S_OK;
}


HRESULT CBaseMSROutPin::RestartWorker()
{
  // this lock should not be the same as the lock that protects
  // access to the start/stop/rate values. The worker thread will
  // need to lock that on some code paths before responding to a
  // Stop and thus will cause deadlock.

  // what we are locking here is access to the worker thread, and
  // thus we should hold the lock that prevents more than one client
  // thread from accessing the worker thread.

  if(m_pWorker == 0)
  {
    m_pFilter->NotifyStreamQueued();
    return S_OK;
  }

  CAutoLock lock(&m_pWorker->m_AccessLock);

  if(m_pWorker->ThreadExists())
  {
    m_pWorker->NotifyStreamActive();

    // restart
    m_pWorker->Run();
  }
  else
  {
    m_pFilter->NotifyStreamQueued();
  }

  return S_OK;
}



HRESULT CBaseMSROutPin::GetStopPosition(LONGLONG *pStop)
{
  if(m_guidFormat == TIME_FORMAT_NONE)
    return VFW_E_NO_TIME_FORMAT_SET;

  if(m_guidFormat == TIME_FORMAT_MEDIA_TIME)
  {
    *pStop = ConvertInternalToRT(m_llCvtImsStop);
  }
  else
  {
    *pStop = m_llCvtImsStop;
  }
  return S_OK;
}

// valid only if we haven't delivered any samples
HRESULT CBaseMSROutPin::GetCurrentPosition(LONGLONG *pCur)
{
  if(m_guidFormat == TIME_FORMAT_NONE)
    return VFW_E_NO_TIME_FORMAT_SET;

  if(m_guidFormat == TIME_FORMAT_MEDIA_TIME)
  {
    *pCur = ConvertInternalToRT( m_llCvtImsStart );
  }
  else
  {
    *pCur = m_llCvtImsStart;
  }
  return S_OK;
}

HRESULT CBaseMSROutPin::InitializeOnNewFile()
{

  // set start and stop times if none set using IMediaSelection. BUSTED!!!.
  ASSERT(m_dImsRate == 0);

  // set playback start and stop
  m_llCvtImsStart = 0;
  m_llCvtImsStop = GetStreamStart() + GetStreamLength();
  m_dImsRate = 1;

  // use TIME_FORMAT_MEDIA_TIME rather than checking if the derived class
  // supports frame/sample
  m_llImsStart = 0;
  m_llImsStop = ConvertInternalToRT(m_llCvtImsStop);
  m_guidFormat = TIME_FORMAT_MEDIA_TIME;
  m_dwSeekFlags = 0;

  return S_OK;
}


// ------ IMediaPosition implementation -----------------------

// HRESULT
// CBaseMSROutPin::CImplPosition::ChangeStart()
// {
//   DbgLog((LOG_TRACE, 2, TEXT("CImplPosition::ChangeStart: %dms"),
//           (ULONG)m_Start.Millisecs() ));

//   REFERENCE_TIME t = m_Start;
//   return m_pStream->SetSelection(
//     &t,
//     0,
//     0,
//     m_Rate,
//     &TIME_FORMAT_MEDIA_TIME);
// }

// HRESULT
// CBaseMSROutPin::CImplPosition::ChangeRate()
// {
//   DbgLog((LOG_TRACE, 2, TEXT("CImplPosition::Rate")));

//   return m_pStream->SetSelection(
//     0,
//     0,
//     0,
//     m_Rate,
//     &TIME_FORMAT_MEDIA_TIME);
// }

// HRESULT
// CBaseMSROutPin::CImplPosition::ChangeStop()
// {
//   DbgLog((LOG_TRACE, 2, TEXT("CImplPosition::ChangeStop: %dms"),
//           (ULONG)m_Stop.Millisecs() ));

//   REFERENCE_TIME t = m_Stop;
//   return m_pStream->SetSelection(
//     0,
//     &t,
//     0,
//     m_Rate,
//     &TIME_FORMAT_MEDIA_TIME);
// }

// // ok to use this as it is not dereferenced
// #pragma warning(disable:4355)

// CBaseMSROutPin::CImplPosition::CImplPosition(
//   TCHAR      * pName,
//   CBaseMSROutPin * pStream,
//   HRESULT    * phr)
//     : CSourcePosition(pName, pStream->GetOwner(), phr, (CCritSec*)this),
//       m_pStream(pStream)
// {
//   DbgBreak("IMediaPosition is being removed");
//   *phr = E_NOINTERFACE;

//   if(FAILED(*phr))
//     return;

//   *phr = m_pStream->CreateImplSelect();
//   if(FAILED(*phr))
//     return;

//   m_Duration = m_pStream->ConvertInternalToRT(
//     m_pStream->GetStreamStart() + m_pStream->GetStreamLength());

//   m_Stop = m_Duration;
//   m_Rate = 1;
//   m_Start = (LONGLONG)0;

//   *phr = S_OK;
//   return;
// }

// void CBaseMSROutPin::CImplPosition::GetValues(
//   CRefTime *ptStart,
//   CRefTime *ptStop,
//   double *pdRate)
// {
//   CAutoLock(this);
//   *ptStart = m_Start;
//   *ptStop = m_Stop;
//   *pdRate = m_Rate;
// }

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// IMediaSelection Implementation

HRESULT CBaseMSROutPin::CreateImplSelect()
{
  if(m_pSelection != 0)
  {
    return S_OK;
  }

  HRESULT hr = S_OK;
  m_pSelection = new CImplSelect(
    NAME("per stream CImplSelect"),
    this->GetOwner(),
    this,
    &hr);

  if(m_pSelection == 0)
    return E_OUTOFMEMORY;

  if(FAILED(hr))
  {
    delete m_pSelection;
    m_pSelection = 0;
    return hr;
  }

  return S_OK;
}

CBaseMSROutPin::CImplSelect::CImplSelect(
  TCHAR * name,
  LPUNKNOWN pUnk,
  CBaseMSROutPin *pPin,
  HRESULT * phr) :
    CMediaPosition(name, pUnk),
    m_pPin(pPin)
{
}

// advertise IMediaSelection
STDMETHODIMP
CBaseMSROutPin::CImplSelect::NonDelegatingQueryInterface(
  REFIID riid,
  void **ppv)
{
  CheckPointer(ppv,E_POINTER);
  ValidateReadWritePtr(ppv,sizeof(PVOID));
  if (riid == IID_IMediaSeeking) {
    return GetInterface( static_cast<IMediaSeeking *>(this), ppv);
  }
  else
  {
    // IID_IMediaPosition and unknown
    return CMediaPosition::NonDelegatingQueryInterface(riid, ppv);
  }
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::IsFormatSupported(const GUID * pFormat)
{
  return m_pPin->IsFormatSupported(pFormat);
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::QueryPreferredFormat(GUID *pFormat)
{
  return m_pPin->QueryPreferredFormat(pFormat);
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::SetTimeFormat(const GUID * pFormat)
{

  return m_pPin->SetTimeFormat(pFormat);
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::GetTimeFormat(GUID *pFormat)
{
  return m_pPin->GetTimeFormat(pFormat);
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::IsUsingTimeFormat(const GUID * pFormat)
{
  GUID TmpFormat;
  HRESULT hr = m_pPin->GetTimeFormat(&TmpFormat);
  if (SUCCEEDED(hr)) hr = (TmpFormat == *pFormat) ? S_OK : S_FALSE;
  return hr;
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::GetDuration(LONGLONG *pDuration)
{
  return m_pPin->GetDuration(pDuration);
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::GetStopPosition(LONGLONG *pStop)
{
  return m_pPin->GetStopPosition(pStop);
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::GetCurrentPosition(LONGLONG *pCurrent)
{
  return m_pPin->GetCurrentPosition(pCurrent);
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::GetCapabilities( DWORD * pCapabilities )
{
  *pCapabilities = m_pPin->m_pFilter->m_dwSeekingCaps;
  return NOERROR;
}


STDMETHODIMP
CBaseMSROutPin::CImplSelect::CheckCapabilities( DWORD * pCapabilities )
{
    DWORD dwCaps;
    HRESULT hr = GetCapabilities( &dwCaps );
    if (SUCCEEDED(hr))
    {
	dwCaps &= *pCapabilities;
	hr =  dwCaps ? ( dwCaps == *pCapabilities ? S_OK : S_FALSE ) : E_FAIL;
	*pCapabilities = dwCaps;
    }
    else *pCapabilities = 0;

    return hr;
}


STDMETHODIMP
CBaseMSROutPin::CImplSelect::ConvertTimeFormat
( LONGLONG * pTarget,  const GUID * pTargetFormat
, LONGLONG    Source,  const GUID * pSourceFormat
)
{
    return m_pPin->ConvertTimeFormat( pTarget, pTargetFormat, Source, pSourceFormat );
}


STDMETHODIMP
CBaseMSROutPin::CImplSelect::SetPositions
( LONGLONG * pCurrent, DWORD CurrentFlags
, LONGLONG * pStop,    DWORD StopFlags
)
{
    if(!m_pPin->m_pFilter->RequestSeekingIf(m_pPin->m_id))
    {
      // !!!!!!!!!@!!!
      //DbgBreak("someone tried to seek us even though we said we don't support seeking");
      return S_OK;
    }

    HRESULT hr;

    LONGLONG llCurrent = 0, llStop = 0;
    int CurrentPosBits, StopPosBits;

    CurrentPosBits = CurrentFlags & AM_SEEKING_PositioningBitsMask;
    if (CurrentPosBits == AM_SEEKING_AbsolutePositioning)              llCurrent = *pCurrent;
    else if (CurrentPosBits == AM_SEEKING_RelativePositioning)
    {
	hr = GetCurrentPosition( &llCurrent );
	if (FAILED(hr)) goto fail;
	llCurrent += *pCurrent;
    }

    StopPosBits = StopFlags & AM_SEEKING_PositioningBitsMask;
    if (StopPosBits == AM_SEEKING_AbsolutePositioning)              llStop = *pStop;
    else if (StopPosBits == AM_SEEKING_IncrementalPositioning)      llStop = llCurrent + *pStop;
    else if (StopPosBits == AM_SEEKING_RelativePositioning)
    {
	hr = GetStopPosition( &llStop );
	if (FAILED(hr)) goto fail;
	llStop += *pStop;
    }

    double dblStart;
    hr = m_pPin->UpdateSelectionAndTellWorker( CurrentPosBits ? &llCurrent : 0
			     , StopPosBits    ? &llStop    : 0
			     , CurrentPosBits ? &dblStart  : 0
			     , NULL
			     , 0
			     , CurrentFlags);

    if (FAILED(hr)) goto fail;

    if (CurrentPosBits)
    {
	const REFERENCE_TIME rtStart = LONGLONG(dblStart * 1e7 + 0.5);

	if (CurrentFlags & AM_SEEKING_ReturnTime)
	{
	    *pCurrent = rtStart;
	}

    }

    if (StopPosBits && (StopFlags & AM_SEEKING_ReturnTime))
    {
	EXECUTE_ASSERT(SUCCEEDED(
	    hr = ConvertTimeFormat( pStop, &TIME_FORMAT_MEDIA_TIME, llStop, 0 )
	));
    }

fail:
    return hr;
}



STDMETHODIMP
CBaseMSROutPin::CImplSelect::GetPositions( LONGLONG * pCurrent, LONGLONG * pStop )
{
    ASSERT( pCurrent || pStop );    // Sanity check

    HRESULT hrCurrent, hrStop, hrResult;

    if (pCurrent)
    {
	hrCurrent = GetCurrentPosition( pCurrent );
    }
    else hrCurrent = NOERROR;

    if (pStop)
    {
	hrStop = GetStopPosition( pStop );
    }
    else hrStop = NOERROR;


    if (SUCCEEDED(hrCurrent))
    {
	if (SUCCEEDED(hrStop))  hrResult = S_OK;
	else                    hrResult = hrStop;
    }
    else
    {
	if (SUCCEEDED(hrStop))  hrResult = hrCurrent;
	else                    hrResult = (hrCurrent == hrStop) ? hrCurrent : E_FAIL;
    }

    return hrResult;
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest )
{
    return m_pPin->GetAvailable(pEarliest, pLatest);
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::SetRate( double dRate)
{
    if(dRate > 0)
      return m_pPin->UpdateSelectionAndTellWorker(0, 0, 0, dRate, &TIME_FORMAT_MEDIA_TIME, 0);
    else
      return E_INVALIDARG;
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::GetRate( double * pdRate)
{
    *pdRate = m_pPin->GetRate();
    return NOERROR;
}

//
// IMediaPosition. calls IMediaSeeking implementation
//

STDMETHODIMP
CBaseMSROutPin::CImplSelect::get_Duration(REFTIME FAR* plength)
{
    HRESULT hr = S_OK;
    if(plength)
    {
	LONGLONG llDurUnknownUnits;
	hr = GetDuration(&llDurUnknownUnits);
	if(SUCCEEDED(hr))
	{
	    LONGLONG llDurTimeUnits;
	    hr = ConvertTimeFormat(
		&llDurTimeUnits, &TIME_FORMAT_MEDIA_TIME,
		llDurUnknownUnits, 0);
	    if(SUCCEEDED(hr))
	    {
		*plength = (REFTIME)llDurTimeUnits / UNITS;
	    }
	}
    }
    else
    {
	 hr = E_POINTER;
    }

    return hr;
}

// IMediaPosition always rounds down. probably ok since we don't rely
// on IMediaPosition heavily. and probably only lose anything
// converting large doubles to int64s.

STDMETHODIMP
CBaseMSROutPin::CImplSelect::put_CurrentPosition(REFTIME llTime)
{
    HRESULT hr = S_OK;
    LONGLONG llPosTimeUnits = (LONGLONG)(llTime * UNITS);
    LONGLONG llPosUnknownUnits;
    hr = ConvertTimeFormat(
	&llPosUnknownUnits, 0,
	llPosTimeUnits, &TIME_FORMAT_MEDIA_TIME);
    if(SUCCEEDED(hr))
    {
	hr = SetPositions(
	    &llPosUnknownUnits, AM_SEEKING_AbsolutePositioning,
	    0, AM_SEEKING_NoPositioning);
    }

    return hr;
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::get_CurrentPosition(REFTIME FAR* pllTime)
{
    // not tested !!!

    CheckPointer(pllTime, E_POINTER);
    LONGLONG llposUnknownUnits;
    HRESULT hr = GetCurrentPosition(&llposUnknownUnits);
    if(SUCCEEDED(hr))
    {
	LONGLONG llposTimeUnits;
	hr = ConvertTimeFormat(
	    &llposTimeUnits, &TIME_FORMAT_MEDIA_TIME,
	    llposUnknownUnits, 0);
	if(SUCCEEDED(hr))
	{
	    *pllTime = (REFTIME)llposTimeUnits / UNITS ;
	}
    }

    return hr;
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::get_StopTime(REFTIME FAR* pllTime)
{
    CheckPointer(pllTime, E_POINTER);
    LONGLONG llposUnknownUnits;
    HRESULT hr = GetStopPosition(&llposUnknownUnits);
    if(SUCCEEDED(hr))
    {
	LONGLONG llposTimeUnits;
	hr = ConvertTimeFormat(
	    &llposTimeUnits, &TIME_FORMAT_MEDIA_TIME,
	    llposUnknownUnits, 0);
	if(SUCCEEDED(hr))
	{
	    *pllTime = (REFTIME)llposTimeUnits / UNITS;
	}
    }

    return hr;
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::put_StopTime(REFTIME llTime)
{
    HRESULT hr = S_OK;
    LONGLONG llPosTimeUnits = (LONGLONG)(llTime * UNITS);
    LONGLONG llPosUnknownUnits;
    hr = ConvertTimeFormat(
	&llPosUnknownUnits, 0,
	llPosTimeUnits, &TIME_FORMAT_MEDIA_TIME);
    if(SUCCEEDED(hr))
    {
	hr = SetPositions(
	    0, AM_SEEKING_NoPositioning,
	    &llPosUnknownUnits, AM_SEEKING_AbsolutePositioning
	    );
    }

    return hr;
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::get_PrerollTime(REFTIME FAR* pllTime)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::put_PrerollTime(REFTIME llTime)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::put_Rate(double dRate)
{
    return SetRate(dRate);
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::get_Rate(double FAR* pdRate)
{
    return GetRate(pdRate);
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::CanSeekForward(long FAR* pCanSeekForward)
{
    CheckPointer(pCanSeekForward, E_POINTER);
    *pCanSeekForward = OATRUE;
    return S_OK;
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::CanSeekBackward(long FAR* pCanSeekBackward)
{
    CheckPointer(pCanSeekBackward, E_POINTER);
    *pCanSeekBackward = OATRUE;
    return S_OK;
}



// ------------------------------------------------------------------------
// ------------------------------------------------------------------------


// =================== IPin interfaces ===========================
//

// return an qzTaskMemAlloc'd string containing the name of the
// current pin.  memory allocated by qzTaskMemAlloc will be freed by
// the caller
//
// STDMETHODIMP CBaseMSROutPin::QueryId (
//   LPWSTR *ppwsz)
// {
//   *ppwsz = (LPWSTR)QzTaskMemAlloc(sizeof(WCHAR) * 28);
//   IntToWstr(m_id, *ppwsz);
//   return NOERROR;
// }

// this pin has gone active. Start the thread pushing
HRESULT
CBaseMSROutPin::Active()
{
  // filter base class must still be stopped
  ASSERT(m_pFilter->IsStopped());



  HRESULT hr = OnActive();
  if(SUCCEEDED(hr))
  {

    ASSERT(m_Connected);          // CBaseOutputPin::Pause
    ASSERT(m_pWorker);

    hr = CBaseOutputPin::Active();
    if(SUCCEEDED(hr))
    {

      // We may have two allocators on this output pin. commmit the one
      // not being used to deliver samples.
      if(UseDownstreamAllocator())
	m_pRecAllocator->Commit();

      // create the thread if it does not exist.  since the filter is
      // stopped, no one else can call this thread, so we don't take
      // the worker access lock
      ASSERT(CritCheckOut(&m_pWorker->m_AccessLock));

      if (m_pWorker->ThreadExists() || m_pWorker->Create(this))
      {
	m_pWorker->NotifyStreamActive();
	hr = m_pWorker->Run();

      }
      else
      {
        DbgLog((LOG_ERROR, 0, TEXT("CBaseMSROutPin failed to create thread")));
	hr = E_OUTOFMEMORY;
      }
    }
  }

  // all paths which would not decrement m_ilcStreamsNotQueued need to
  // do it manually
  if(hr != S_OK)
  {
    DbgLog((LOG_ERROR, 1, TEXT("basemsr Active: unexpected failure")));
    m_pFilter->NotifyStreamQueued();
  }

  return hr;
}

// pin has gone inactive. Stop and exit the worker thread
//
HRESULT
CBaseMSROutPin::Inactive()
{
  if ( ! m_Connected)
    return NOERROR;

  if(m_pWorker)
  {
    CAutoLock lock(&m_pWorker->m_AccessLock);
    HRESULT hr;
    if (m_pWorker->ThreadExists())
    {
      hr = m_pWorker->Stop();
      ASSERT(SUCCEEDED(hr));

      hr = m_pWorker->Exit();
      ASSERT(SUCCEEDED(hr));
    }
  }

  if(UseDownstreamAllocator())
    m_pRecAllocator->Decommit();

  //  Clear source seeking variables
  m_dwSegmentNumber = 0;
  m_rtAccumulated   = 0;

  return CBaseOutputPin::Inactive();
}

HRESULT CBaseMSROutPin::BreakConnect()
{
  if(m_fUsingExternalMemory)
  {
    m_pFilter->NotifyExternalMemory(0);
    m_fUsingExternalMemory = FALSE;
  }
  return CBaseOutputPin::BreakConnect();
}

STDMETHODIMP
CBaseMSROutPin::Notify (
  IBaseFilter * pSender,
  Quality q)
{
  // ??? Try to adjust the quality to avoid flooding/starving the
  // components downstream.
  //
  // ideas anyone?

  // play every nth key frame

  return NOERROR;
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

CBaseMSRWorker::CBaseMSRWorker(
  UINT stream,
  IMultiStreamReader *pReader) :
   m_pPin(NULL),
   m_id(stream),
   m_pReader(pReader)           // not addrefd
{
}

BOOL CBaseMSRWorker::Create(
   CBaseMSROutPin * pPin)
{
  CAutoLock lock(&m_AccessLock);

  if (m_pPin)
    return FALSE;
  m_pPin = pPin;

  // register perf log entries with stream id
#ifdef PERF
  char foo[1024];

  lstrcpy(foo, "pin00 basemsr Deliver");
  foo[4] += m_pPin->m_id % 10;
  foo[3] += m_pPin->m_id / 10;

  m_perfidDeliver = MSR_REGISTER(foo);

  lstrcpy(foo, "pin00 basemsr disk wait");
  foo[4] += m_pPin->m_id % 10;
  foo[3] += m_pPin->m_id / 10;

  m_perfidWaitI = MSR_REGISTER(foo);

  lstrcpy(foo, "pin00 basemsr !deliver");
  foo[4] += m_pPin->m_id % 10;
  foo[3] += m_pPin->m_id / 10;

  m_perfidNotDeliver = MSR_REGISTER(foo);

#endif // PERF

   return CAMThread::Create();
}

HRESULT CBaseMSRWorker::Run()
{
   return CallWorker(CMD_RUN);
}

HRESULT CBaseMSRWorker::Stop()
{
   return CallWorker(CMD_STOP);
}

HRESULT CBaseMSRWorker::Exit()
{
   CAutoLock lock(&m_AccessLock);

   HRESULT hr = CallWorker(CMD_EXIT);
   if (FAILED(hr))
      return hr;

   // wait for thread completion and then close
   // handle (and clear so we can start another later)
   //
   Close();

   m_pPin = NULL;
   return NOERROR;
}

HRESULT CBaseMSRWorker::NotifyStreamActive()
{
  m_fCalledNotifyStreamQueued = FALSE;
  return S_OK;
}

// called on the worker thread to do all the work. Thread exits when this
// function returns.
//
DWORD CBaseMSRWorker::ThreadProc()
{
    BOOL bExit = FALSE;
    while (!bExit)
    {
       Command cmd = GetRequest();
       switch (cmd)
       {
       case CMD_EXIT:
	   bExit = TRUE;
	   Reply(NOERROR);
	   break;

       case CMD_RUN:
	   Reply(NOERROR);
	   DoRunLoop();
	   break;

       case CMD_STOP:
	   Reply(NOERROR);
	   break;

       default:
	   Reply(E_NOTIMPL);
	   break;
       }
    }

    return NOERROR;
}

// sets the worker thread start, stop-time and rate variables. Called before push
// starts, and also when a put_Stop or put_Rate happens during running.
// If the start time changes, the worker thread will be restarted. If we change
// it here when running, the change won't be picked up.
HRESULT
CBaseMSRWorker::SetNewSelection(void)
{
  // keep worker thread from seeing inconsistent values when it's
  // pushing. the start values don't really need to be protected
  // because we restart the thread anyway when changing the start
  // value

  DbgLog((LOG_TRACE, 5, TEXT("CBaseMSRWorker::SetNewSelection.") ));

  CAutoLock lock(&m_pPin->m_csImsValues);

  // this is in the derived class' internal units
  LONGLONG llStreamStop = m_pPin->GetStreamStart() + m_pPin->GetStreamLength();

  ASSERT(m_pPin->m_dImsRate != 0);

  // try to make changes atomic
  LONGLONG llPushStart;
  LONGLONG llPushStop;
  llPushStart = m_pPin->m_llCvtImsStart;
  llPushStop = m_pPin->m_llCvtImsStop;

  // check we are not going over the end. for video, put up the last
  // tick. for audio, nothing. if it's the clock, the clock for
  // -duration to get to present time.
  llPushStop = min(llStreamStop, llPushStop);

  if(llPushStart >= llStreamStop) {
      if(*m_pPin->CurrentMediaType().Type() != MEDIATYPE_Audio) {
	  llPushStart = llStreamStop - 1;
      }
  }

  if(llPushStop < llPushStart) {
    llPushStop = llPushStart;
  }


  m_ImsValues.dRate         = m_pPin->m_dImsRate;
  m_ImsValues.llTickStart   = llPushStart;
  m_ImsValues.llTickStop    = llPushStop;
  m_ImsValues.llImsStart    = m_pPin->m_llImsStart;
  m_ImsValues.llImsStop     = m_pPin->m_llImsStop;
  m_ImsValues.dwSeekFlags   = m_pPin->m_dwSeekFlags;

  if(m_ImsValues.llImsStop < m_ImsValues.llImsStart)
    m_ImsValues.llImsStop = m_ImsValues.llImsStart;

  return S_OK;
}


void CBaseMSRWorker::DoRunLoop(void)
{
  HRESULT hr;

  // snapshot start and stop times from the other thread
  for(;;)
  {
    // each time before re-entering the push loop, pick up changes in
    // start, stop or rate.


    // initialise the worker thread's start, stop and rate variables
    // this is pulled out separately as it can also be called
    // from a seeking thread when we are running.
    SetNewSelection();

    // race condition in this debug output
    DbgLog((LOG_TRACE, 2, TEXT("CBaseMSRWorker::DoRunLoop: pushing from %d-%d"),
	    (ULONG)m_ImsValues.llTickStart, (ULONG)m_ImsValues.llTickStop));

    m_cSamples = 0;


    if(m_pPin->m_dImsRate == 0)
      m_Format = FORMAT_NULL;
    else
      m_Format = CBaseMSRFilter::MapGuidToFormat(m_pPin->CurrentFormat());

    hr = PushLoop();

    m_pPin->m_rpImplBuffer->ClearPending(m_pPin->m_id);

    if(VFW_S_NO_MORE_ITEMS == hr)
    {
      // delivered the last sample successfully. can return something
      // if it's flushing or stopped. ignore those.
      DbgLog(( LOG_TRACE, 4, TEXT("avimsr: stream %d: sending EOS"),
	       m_id ));
      DoEndOfData();
      break;
    }
    else if(FAILED(hr))
    {
      // this filter detected an error
      DbgLog((LOG_TRACE, 5,
	      TEXT("CBaseMSRWorker::DoRunLoop: push loop returned %08x"),
	      hr));

      // push loop should supress these errors when they are detected
      // as they normally indicate we are about to stop
      ASSERT(hr != VFW_E_NOT_COMMITTED && hr != VFW_E_WRONG_STATE);

      // assume the derived class only tries to read past the end of
      // the file if the file is corrupt
      if(hr == HRESULT_FROM_WIN32(ERROR_HANDLE_EOF))
	hr = VFW_E_INVALID_FILE_FORMAT;

      // tell the graph what happened.
      // Note: we previously sent EC_STREAM_ERROR_STOPPED here,
      // but this had the side affect of causing looping graphs on corrupt
      // files to loop infinitely instead off aborting. we should abort
      // anyway.
      m_pPin->m_pFilter->NotifyEvent(EC_ERRORABORT, hr, 0);

      // the error was in our filter, so we have to make the downstream
      // guy clean up properly
      DbgLog(( LOG_TRACE, 4, TEXT("avimsr: stream %d: sending EOS on error"),
	       m_id ));
      DoEndOfData();

      break;
    }
    else if(hr == S_OK)
    {
      // not my error to report. or someone wants to stop. queitly
      // exit.
      break;
    }// else S_FALSE - go round again

    // push loop should not return anything else.
    ASSERT(hr == S_FALSE);

    Command com;
    if (CheckRequest(&com))
    {
      // if it's a run command, then we're already running, so
      // eat it now.
      if (com == CMD_RUN)
      {
	GetRequest();
	Reply(NOERROR);
      }
      else
      {
	break;
      }
    }
  }

  NotifyStreamQueued();

  // end streaming
  DbgLog((LOG_TRACE,2,TEXT("CBaseMSRWorker::DoRunLoop: Leaving streaming loop")));
}

//  Signal appropriately that we got to the end of the data
void CBaseMSRWorker::DoEndOfData()
{
    if (m_ImsValues.dwSeekFlags & AM_SEEKING_Segment) {
	m_pPin->m_rtAccumulated += m_ImsValues.llImsStop - m_ImsValues.llImsStart;
	DbgLog((LOG_TRACE, 3, TEXT("Filter Sending EC_END_OF_SEGMENT")));
	m_pPin->m_pFilter->NotifyEvent(EC_END_OF_SEGMENT,
				       (LONG_PTR)&m_pPin->m_rtAccumulated,
				       m_pPin->m_dwSegmentNumber);
    } else {
	m_pPin->DeliverEndOfStream();
    }
}

// inline
void CBaseMSRWorker::NotifyStreamQueued()
{
  if(!m_fCalledNotifyStreamQueued)
  {
    DbgLog(( LOG_TRACE, 5, TEXT("CBaseMSRWorker::NotifyStreamQueued") ));
    m_pPin->m_pFilter->NotifyStreamQueued();
    m_fCalledNotifyStreamQueued = TRUE;
  }
}

// inline
void CBaseMSRWorker::NotifyStreamQueuedAndWait()
{
  if(!m_fCalledNotifyStreamQueued)
  {
    DbgLog(( LOG_TRACE, 5, TEXT("CBaseMSRWorker::NotifyStreamQueuedAndWait")));
    m_pPin->m_pFilter->NotifyStreamQueuedAndWait();
    m_fCalledNotifyStreamQueued = TRUE;
  }
}

HRESULT CBaseMSRWorker::CopyData(
  IMediaSample **ppSampleOut,
  IMediaSample *pSampleIn)
{
  DbgBreak("CBaseMSRWorker::CopyData: override this.");
  return E_UNEXPECTED;
}

HRESULT CBaseMSRWorker::AboutToDeliver(
  IMediaSample *pSample)
{
  HRESULT               hr;

  AM_MEDIA_TYPE         *pmt;

  hr = pSample->GetMediaType(&pmt);

  if (hr == S_FALSE)
  {
    hr = S_OK;
  }
  else if (hr == S_OK)
  {
    DbgLog((LOG_TRACE,1,TEXT("CBaseMSRWorker::AboutToDeliver: checking if new format is acceptable")));

    hr = m_pPin->m_Connected->QueryAccept(pmt);

    DeleteMediaType(pmt);

    if (hr != S_OK)
    {
      DbgLog((LOG_TRACE,1,TEXT("CBaseMSRWorker::AboutToDeliver: QueryAccept failed, returned %x"), hr));
      hr = VFW_E_CHANGING_FORMAT;
    }
  }

  return hr;
}


HRESULT CBaseMSRWorker::TryDeliverSample(
  BOOL *pfDeliveredSample,
  BOOL *pfStopPlease)
{
  HRESULT hr;
  *pfDeliveredSample = FALSE;
  *pfStopPlease = FALSE;
  IMediaSample *pSampleIn = 0;
  IMediaSample *pSampleDeliver = 0;

  // timeout of 0
  hr = m_pReader->PollForSample(
    &pSampleIn,
    m_id);

  if(hr == VFW_E_TIMEOUT)
  {
    DbgLog((LOG_TRACE, 0x7f, TEXT("CBaseMSRWorker::TryDeliver: poll failed ") ));
    return S_OK;
  }

  if(FAILED(hr))
  {
    DbgLog((LOG_ERROR, 5,
	    TEXT("CBaseMSRWorker::TryDeliver: wait failed %08x "), hr ));
    return hr;
  }

  ASSERT(SUCCEEDED(hr));

  CRecSample *pRecSampleIn = (CRecSample *)pSampleIn;

#ifdef DEBUG
  if(pRecSampleIn->GetUser())
  {
    DbgLog((LOG_TRACE, 5,
	    TEXT("CBaseMSRWorker::TryDeliver: Got buffer, size=%5d, mt set"),
	    pSampleIn->GetSize()));
  }
  else
  {
    CRefTime tStart, tEnd;
    pSampleIn->GetTime(
      (REFERENCE_TIME *)&tStart,
      (REFERENCE_TIME *)&tEnd);

    DbgLog((LOG_TRACE, 5,
	    TEXT("CBaseMSRWorker::TryDeliver: Got buffer, size=%5d, %07d-%07d ms"),
	    pSampleIn->GetSize(), tStart.Millisecs(), tEnd.Millisecs()));

    //   DbgLog((LOG_TRACE, 5,
    //           TEXT("%08x%08x - %08x%08x"),
    //           (ULONG)(tStart.GetUnits() >> 32),
    //           (ULONG)tStart.GetUnits(),
    //           (ULONG)(tEnd.GetUnits() >> 32),
    //           (ULONG)(tEnd.GetUnits()) ));
  }
#endif // DEBUG

  hr = E_FAIL;                  // all paths should set this.

  // nonzero user context is passed to the derived class's HandleData()
  if(pRecSampleIn->GetUser())
  {
    hr = HandleData(pSampleIn, pRecSampleIn->GetUser());
    if(FAILED(hr))
      DbgLog((LOG_ERROR, 1, TEXT("TryDeliverSample: HandleData failed")));
    pSampleIn->Release();
    pSampleIn = 0;
  }
  else
  {
    // stop time changed, but samples already queued... don't deliver
    // them. note partial frames/audio are not handled; ok as it's
    // probably not a video editing scenario
    LONGLONG lltStart, lltStop;
    if(pSampleIn->GetMediaTime(&lltStart, &lltStop) == S_OK)
    {
      if(lltStart > m_ImsValues.llTickStop)
      {
	DbgLog((LOG_TRACE, 5, TEXT("basmsr: past new stop")));
	pSampleIn->Release();
	pSampleIn = 0;
	*pfStopPlease = TRUE;
	return VFW_S_NO_MORE_ITEMS;
      }
    }
    else
    {
      DbgBreak("mt not set");
    }

    if(m_pPin->UseDownstreamAllocator())
    {
      hr = CopyData(&pSampleDeliver, pSampleIn);
      pSampleIn->Release();
      pSampleIn = 0;
      if(FAILED(hr))
	DbgLog((LOG_ERROR, 1, TEXT("TryDeliverSample: CopyData failed")));
    }
    else
    {
      pSampleDeliver = pSampleIn;
      pSampleIn = 0;            // don't Release()
      hr = AboutToDeliver(pSampleDeliver);
      if(FAILED(hr)) {
	DbgLog((LOG_ERROR, 1, TEXT("TryDeliverSample: AboutToDeliver failed")));
      }
      else {
	// we want to track the lifetime of this sample because it's
	// sent downstream
	((CRecSample *)pSampleDeliver)->MarkDelivered();
      }
    }

    if(S_OK == hr)
    {
      ++m_cSamples;

      MSR_STOP(m_perfidNotDeliver);

      hr = m_pPin->Deliver(pSampleDeliver);

      MSR_START(m_perfidNotDeliver);

      // if receive failed, downstream filter will report error; we
      // exit quietly after delivering EndOfStream
      if(FAILED(hr))
      {
	hr = S_FALSE;           // S_FALSE means please stop
      }

    } // AboutToDeliver/CopyData succeeded
    else if (SUCCEEDED(hr))
    {
      //  OK - we didn't want to deliver it
      hr = S_OK;
    }
  } // sample not data

  // done with buffer. connected pin may have its own addref
  if(pSampleDeliver)
    pSampleDeliver->Release();

  // HandleData, CopyData, or AboutToDeliver failed.
  if(FAILED(hr))
  {
    DbgLog((LOG_ERROR, 2,
	    TEXT("CBaseMSRWorker::TryDeliverSample: failed %08x"), hr));
    return hr;
  }

  *pfDeliveredSample = TRUE;

  if(hr == S_FALSE)
    *pfStopPlease = TRUE;

  return hr;
}

HRESULT CBaseMSRWorker::NewSegmentHelper()
{
    // values not yet adjusted for preroll.

    //  NewSegment start and stop times should match seek times in
    //  REFERENCE_TIME units.  If the current time format is in
    //  reference time units just use the current seek values, if not
    //  convert the seek values to REFERENCE_TIME.  For this to be
    //  correct each stream can only support 2 formats - it's native
    //  format and REFERENCE_TIME units (TIME_FORMAT_TIME).

    REFERENCE_TIME rtNsStart, rtNsStop;
    if(m_Format == FORMAT_TIME)
    {
        rtNsStart = m_ImsValues.llImsStart;
        rtNsStop = m_ImsValues.llImsStop;
    }
    else
    {
        rtNsStart = m_pPin->ConvertInternalToRT(m_ImsValues.llTickStart);
        rtNsStop = m_pPin->ConvertInternalToRT(m_ImsValues.llTickStop);
    }

    DbgLog((LOG_TRACE, 5, TEXT("PushLoop: NewSegment: %dms - %dms"),
            (DWORD)(rtNsStart / (UNITS / MILLISECONDS)),
            (DWORD)(rtNsStop / (UNITS / MILLISECONDS))));


    return m_pPin->DeliverNewSegment(rtNsStart, rtNsStop, m_ImsValues.dRate);
}

HRESULT
CBaseMSRWorker::PushLoop()
{
  HRESULT hr = S_OK;

  m_pReader->MarkStreamRestart(m_id);

  DbgLog((LOG_TRACE, 5, TEXT("PushLoop: tstart: %li, tstop %li"),
          (ULONG)m_ImsValues.llTickStart, (ULONG)m_ImsValues.llTickStop));

  // values not yet adjusted for preroll.
  hr = NewSegmentHelper();
  if(FAILED(hr))
    return hr;

  // just send EOS if start is after end of stream.
  LONGLONG llStreamStop = m_pPin->GetStreamStart() + m_pPin->GetStreamLength();
  if(m_ImsValues.llTickStart >= llStreamStop) {
      return VFW_S_NO_MORE_ITEMS;
  }

  LONGLONG llCurrent;
  hr = PushLoopInit(&llCurrent, &m_ImsValues);

  if(hr == VFW_S_NO_MORE_ITEMS)
    return VFW_S_NO_MORE_ITEMS;

  if(hr == VFW_E_NOT_COMMITTED || hr == VFW_E_WRONG_STATE)
    return S_OK;

  if(FAILED(hr))
    return hr;

  m_llPushFirst = llCurrent;    // remember the first thing we're sending

  // we send one sample at sStopAt, but we set the time stamp such that
  // it won't get rendered except for media types that understand static
  // rendering (eg video). This means that play from 10 to 10 does the right
  // thing (completing, with frame 10 visible and no audio).

  DbgLog((LOG_TRACE,5,TEXT("PushLoop: tcurrent: %li"),
	  (ULONG)(llCurrent / MILLISECONDS)));

  // queued all reads. continue waiting on and delivering samples
  BOOL fFinishDelivering = FALSE;

  // number of undelivered samples
  ULONG cQueuedReads = 0;

  for(;;)
  {
    // successfully queued a read in this iteration of push loop
    BOOL fQueuedRead = FALSE;

    // successfully waited on sample in this iteration of push loop
    BOOL fWaitedForSample = FALSE;

    DbgLog((LOG_TRACE, 0x7f,
	    TEXT("CBaseMSRWorker::PushLoop: fFinish %d, cQueued: %d"),
	    fFinishDelivering, cQueuedReads));

    // update our ims values?
    if(InterlockedExchange(&m_pPin->m_ilfNewImsValues, FALSE))
    {
      DbgLog((LOG_TRACE, 5, TEXT("CBaseMSRWorker::PushLoop - values changed")));
      SetNewSelection();

      hr = NewSegmentHelper();

      if(fFinishDelivering && m_ImsValues.llTickStop > llCurrent)
      {
	DbgLog((LOG_TRACE, 5, TEXT("CBaseMSRWorker: restarting queueing")));
	fFinishDelivering = FALSE;
      }
    }

    if(!fFinishDelivering)      // still queuing new reads?
    {
      for(;;)
      {
	hr = TryQueueSample(llCurrent, fQueuedRead, &m_ImsValues);
	if(FAILED(hr))
	{
	  DbgLog((LOG_ERROR, 5,
		  TEXT("CBaseMSRWorker::PushLoop: TryQueueSample failed %08x"),
		  hr ));
	  // supress errors when we are stopping
	  return (hr == VFW_E_NOT_COMMITTED || hr == VFW_E_WRONG_STATE) ?
	    S_OK : hr;
	}

	if(fQueuedRead)
	{
	  cQueuedReads++;
	  // MSR_INTEGER(m_perfidiSample, m_cSamples + cQueuedReads);
	}

	// this may happen if size of sample is 0. Report that we did
	// queue a read but don't increment cQueuedReads
	if(hr == S_OK /* && !fQueuedRead */ )
	  fQueuedRead = TRUE;

	if(hr == VFW_S_NO_MORE_ITEMS)
	{
	  // may or may not have queued a sample; handled above. now
	  // just continue delivering what's queued
	  fFinishDelivering = TRUE;
	  m_pReader->MarkStreamEnd(m_id);

	  // break out of inner try queue loop
	  break;
	}

	if(hr == S_FALSE)
	{
	  // could not queue sample for some non-error reason (like
	  // the queue is full)
	  ASSERT(!fQueuedRead);

	  // break out of inner try queue loop
	  break;
	}
      } // inner try queue loop

      // tried to queue a sample. even if we didn't, signal
      // NotifyStreamQueued so other threads can proceed
      NotifyStreamQueuedAndWait();

    } // we haven't queued the last sample yet

    // a chance to deliver something
    if(cQueuedReads > 0)
    {
      BOOL fDelivered, fPleaseStop;
      hr = TryDeliverSample(&fDelivered, &fPleaseStop);
      if(FAILED(hr))
      {
	ASSERT(!fDelivered);
	DbgLog((LOG_ERROR, 5,
		TEXT("CBaseMSRWorker::PushLoop: TryDeliverSample failed %08x"),
		hr ));
	// supress errors when we are stopping
	  return (hr == VFW_E_NOT_COMMITTED || hr == VFW_E_WRONG_STATE) ?
	    S_OK : hr;
      }

      if(fDelivered)
      {
	cQueuedReads--;
	fWaitedForSample = TRUE;
      }

      if(fPleaseStop)
      {
	DbgLog((LOG_TRACE, 5,
		TEXT("CBaseMSRWorker::PushLoop: TryDeliverSample request stop")));
	return hr == VFW_S_NO_MORE_ITEMS ? VFW_S_NO_MORE_ITEMS : S_OK;
      }
    }

    if(cQueuedReads == 0 && fFinishDelivering)
    {
      DbgLog((LOG_TRACE, 2,
	      TEXT("CBaseMSRWorker::PushLoop: delivered last sample")));
      // the one success condition
      return VFW_S_NO_MORE_ITEMS;
    }

    // all operations failed; block until a sample is ready.
    if(!fQueuedRead && !fWaitedForSample)
    {
      DbgLog((LOG_TRACE,5,TEXT("CBaseMSRWorker::PushLoop: blocking")));
      MSR_START(m_perfidWaitI);

      // infinite timeout.
      hr = m_pReader->WaitForSample(m_id);

      MSR_STOP(m_perfidWaitI);

      if(FAILED(hr) && hr != VFW_E_TIMEOUT)
      {
	// VFW_E_NOT_COMMITTED means that we stopped
	DbgLog((LOG_ERROR,5,
		TEXT("CBaseMSRWorker::PushLoop: block failed %08x"), hr));
	// supress errors when we are stopping
	return (hr == VFW_E_NOT_COMMITTED || hr == VFW_E_WRONG_STATE) ?
	  S_OK : hr;
      }
    }

    // any other requests ?
    Command com;
    if(CheckRequest(&com))
    {
      DbgLog((LOG_TRACE,5,
	      TEXT("CBaseMSRWorker::PushLoop: other command detected")));
      // S_FALSE means check for a new command
      return S_FALSE;
    }
  } // outer push loop

  // should never break out of the outer for(;;) loop
  DbgBreak("CBaseMSRWorker::PushLoop: internal error.");
  return E_UNEXPECTED;          // return something
}

//  Hacking MPEG time stamps - used by wave and Avi

bool FixMPEGAudioTimeStamps(
    IMediaSample *pSample,
    BOOL bFirstSample,
    const WAVEFORMATEX *pwfx
)
{
    PBYTE pbData;
    pSample->GetPointer(&pbData);
    PBYTE pbTemp = pbData;
    LONG lData = pSample->GetActualDataLength();

    //  For the first sample advance to a sync code
    if (bFirstSample) {
	while (lData >= 2 &&
	       (pbTemp[0] != 0xFF || (pbTemp[1] & 0xF0) != 0xF0)){
	    lData--;
	    pbTemp++;
	}
	if (lData < 2) {
	    return false;
	}
	if (pbTemp != pbData) {
	    memmoveInternal(pbData, pbTemp, lData);
	    pSample->SetActualDataLength(lData);
	    REFERENCE_TIME rtStart, rtStop;
	    if (S_OK == pSample->GetTime(&rtStart, &rtStop)) {
		rtStart += MulDiv((LONG)(pbTemp - pbData),
				  (LONG)UNITS,
				  pwfx->nAvgBytesPerSec);
		pSample->SetTime(&rtStart, &rtStop);
	    }
	}
    } else {
	if (lData < 2 || pbData[0] != 0xFF || (pbData[1] & 0xF0) != 0xF0) {
	    pSample->SetTime(NULL, NULL);
	    pSample->SetSyncPoint(FALSE);
	}
    }
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\core\filerend\filerend.h ===
// Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.

// CLSID_FileRend,
// {D51BD5A5-7548-11cf-A520-0080C77EF58A}
DEFINE_GUID(CLSID_FileRend,
0xd51bd5A5, 0x7548, 0x11cf, 0xa5, 0x20, 0x0, 0x80, 0xc7, 0x7e, 0xf5, 0x8a);


//
// Quartz "transform" filter which really opens a file
//

// forward declarations

class CFileRendInPin;	   // input pin
class CFileRendStream;     // output pin, just placeholder for IStreamBuilder
class CFileRendFilter;     // overall container class

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// input pin. doesn't really need any data at all

class CFileRendInPin : public CBaseInputPin
{
protected:
    class CFileRendFilter* m_pFilter;

public:
    CFileRendInPin(
		 class CFileRendFilter *pFilter,
		 CCritSec *pLock,
		 HRESULT *phr,
		 LPCWSTR pPinName);


    // CBasePin overrides
    HRESULT CheckMediaType(const CMediaType* mtOut);

    // don't try to touch allocator, we don't use it.
    HRESULT Inactive(void) { return S_OK; }

    WCHAR * CurrentName() { return (WCHAR *) m_mt.Format(); }

};

// CFileRendStream
// output pin, supports IPin, IStreamBuilder
//
// never actually connects, just provides a place for graph builder to
// look for an IStreamBuilder
//


class CFileRendStream : public CBaseOutputPin, public IStreamBuilder
{

public:

    CFileRendStream(
	TCHAR *pObjectName,
	HRESULT * phr,
	CFileRendFilter * pFilter,
	CCritSec *pLock,
	LPCWSTR wszPinName);

    ~CFileRendStream();

    // expose IMediaPosition via CImplPosition, rest via CBaseOutputPin
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);

    // IPin

    HRESULT GetMediaType(int iPosition,CMediaType* pt);

    // check if the pin can support this specific proposed type&format
    HRESULT CheckMediaType(const CMediaType*);

    // say how big our buffers should be and how many we want
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES *pProperties);



    STDMETHODIMP Render(IPin * ppinOut, IGraphBuilder * pGraph);

    // we can't back anything out....
    STDMETHODIMP Backout(IPin * ppinOut, IGraphBuilder * pGraph) { return E_NOTIMPL; };

    DECLARE_IUNKNOWN

    CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
	    
private:

    CFileRendFilter * m_pFilter;
};

//
// CFileRendFilter 
//

class CFileRendFilter : public CBaseFilter
{
public:

    // constructors etc
    CFileRendFilter(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CFileRendFilter();

    // create a new instance of this class
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    // pin enumerator calls this
    int GetPinCount();

    CBasePin * GetPin(int n);

private:

    friend class CFileRendStream;
    friend class CFileRendInPin;

    CFileRendStream m_Output;
    CFileRendInPin m_Input;

    CCritSec m_csLock;
};






// CLSID_MultFile,
// {D51BD5A3-7548-11cf-A520-0080C77EF58A}
DEFINE_GUID(CLSID_MultFile,
0xd51bd5a3, 0x7548, 0x11cf, 0xa5, 0x20, 0x0, 0x80, 0xc7, 0x7e, 0xf5, 0x8a);

//
// Quartz filter with fake output pin which supports IStreamBuilder to render
// lots of separate files
//

// forward declarations

class CMultStream;     // owns a particular stream
class CMultFilter;     // overall container class

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// input pin. uses IAsyncReader and not IMemInputPin

class CFRInPin : public CBasePin
{
protected:
    class CMultFilter* m_pFilter;

public:
    CFRInPin(
		 class CMultFilter *pFilter,
		 CCritSec *pLock,
		 HRESULT *phr,
		 LPCWSTR pPinName);


    // CBasePin overrides
    HRESULT CheckMediaType(const CMediaType* mtOut);
    HRESULT CompleteConnect(IPin *pReceivePin);
    HRESULT BreakConnect();

    STDMETHODIMP BeginFlush(void) { return E_UNEXPECTED; }
    STDMETHODIMP EndFlush(void) { return E_UNEXPECTED; }
};

// CMultStream
// output pin, supports IPin
//



class CMultStream : public CBasePin
{

public:

    CMultStream(
	TCHAR *pObjectName,
	HRESULT * phr,
	CMultFilter * pFilter,
	CCritSec *pLock,
	LPCWSTR wszPinName);

    ~CMultStream();

    // IPin

    HRESULT GetMediaType(int iPosition,CMediaType* pt);

    // check if the pin can support this specific proposed type&format
    HRESULT CheckMediaType(const CMediaType*);

    STDMETHODIMP BeginFlush(void) { return S_OK; }
    STDMETHODIMP EndFlush(void) { return S_OK; }

    // allow output pin different life time than filter
    STDMETHODIMP_(ULONG) NonDelegatingRelease();
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();


private:
    CMultFilter * m_pFilter;
};

//
// CMultFilter represents an avifile
//
// responsible for
// -- finding file and enumerating streams
// -- giving access to individual streams within the file
// -- control of streaming
//

class CMultFilter : public CBaseFilter
{
public:

    // constructors etc
    CMultFilter(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CMultFilter();

    // create a new instance of this class
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    // pin enumerator calls this
    int GetPinCount();

    CBasePin * GetPin(int n);

    HRESULT CreateOutputPins();
    HRESULT RemoveOutputPins();
private:

    friend class CMultStream;
    friend class CFRInPin;

    int	m_nOutputs;
    CMultStream **m_pOutputs;
    CFRInPin m_Input;

    CCritSec m_csLock;
    
public:
    IAsyncReader *m_pAsyncReader;
};


extern const AMOVIESETUP_FILTER sudMultiParse;
extern const AMOVIESETUP_FILTER sudFileRend;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\core\msreader\alloc.cpp ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)

#include <streams.h>
#include "alloc.h"
#include "reccache.h"

CRecAllocator::CRecAllocator(
  TCHAR *pName,
  LPUNKNOWN pUnk,
  HRESULT *phr) :
    CBaseAllocator(pName, pUnk, phr),
    m_cDelivered(0),
    m_heSampleReleased(0),
    m_pBuffer(NULL)
{
    if(SUCCEEDED(*phr))
    {
        m_heSampleReleased = CreateEvent(
            0,                      // security
            FALSE,                  // fManualReset
            FALSE,                  // fInitiallySignaled
            0);                     // name
        if(m_heSampleReleased == 0)
        {
            DWORD dw = GetLastError();
            *phr = AmHresultFromWin32(*phr);
        }
    }
}

STDMETHODIMP
CRecAllocator::SetProperties(
  ALLOCATOR_PROPERTIES* pRequest,
  ALLOCATOR_PROPERTIES* pActual)
{
    DbgLog((LOG_ERROR, 0,
            TEXT("nobody should be calling SetProperties on our allocator")));

    // but of course the l21 dec filter does call SetProperties on our
    // allocator and confuses us by giving us fewer buffers than we
    // requested. bug 13985?

    return E_UNEXPECTED;
}

STDMETHODIMP
CRecAllocator::SetPropertiesInternal(
  ALLOCATOR_PROPERTIES* pRequest,
  ALLOCATOR_PROPERTIES* pActual)
{
  HRESULT hr = CBaseAllocator::SetProperties(pRequest, pActual);
  if(FAILED(hr))
    return hr;

  m_cBuffersReported = pActual->cBuffers;
  return hr;
}

STDMETHODIMP CRecAllocator::GetProperties(ALLOCATOR_PROPERTIES* pAPOut)
{
  HRESULT hr = CBaseAllocator::GetProperties(pAPOut);
  if(FAILED(hr))
    return hr;

  // CBaseAllocator::GetProperties would have failed if this value was
  // not set in SetProperties
  pAPOut->cBuffers = m_cBuffersReported;
  return hr;
}

HRESULT CRecAllocator::SetCBuffersReported(UINT cBuffers)
{
  m_cBuffersReported = cBuffers;
  return S_OK;
}

// override this to allocate our resources when Commit is called.
//
// note that our resources may be already allocated when this is called,
// since we don't free them on Decommit. We will only be called when in
// decommit state with all buffers free.
//
// object locked by caller
HRESULT
CRecAllocator::Alloc(void)
{
    CAutoLock lck(this);

    /* Check he has called SetProperties */
    HRESULT hr = CBaseAllocator::Alloc();
    if (FAILED(hr)) {
	return hr;
    }

    ASSERT(!m_pBuffer);         // never allocating here

    /* If the requirements haven't changed then don't reallocate */
    if (hr == S_FALSE) {
	return NOERROR;
    }

    /* Free the old resources */
    if (m_pBuffer) {
	ReallyFree();
    }

    /* Create the contiguous memory block for the samples
       making sure it's properly aligned (64K should be enough!)
    */
    ASSERT(m_lAlignment != 0 &&
	   m_lSize % m_lAlignment == 0);

    m_pBuffer = 0;

    CRecSample *pSample;

    ASSERT(m_lAllocated == 0);

    /* Create the new samples */
    for (; m_lAllocated < m_lCount; m_lAllocated++) {

	pSample = new CRecSample(NAME("Default memory media sample"),
				   this, &hr, 0, 0);

	if (FAILED(hr) || pSample == NULL) {
	    return E_OUTOFMEMORY;
	}

	m_lFree.Add(pSample);
    }

    m_bChanged = FALSE;
    return NOERROR;
}


// override this to free up any resources we have allocated.
// called from the base class on Decommit when all buffers have been
// returned to the free list.
//
// caller has already locked the object.

// in our case, we keep the memory until we are deleted, so
// we do nothing here. The memory is deleted in the destructor by
// calling ReallyFree()
void
CRecAllocator::Free(void)
{
    return;
}


// called from the destructor (and from Alloc if changing size/count) to
// actually free up the memory
void
CRecAllocator::ReallyFree(void)
{
  /* Should never be deleting this unless all buffers are freed */

  ASSERT(m_lAllocated == m_lFree.GetCount());

  /* Free up all the CRecSamples */

  CMediaSample *pSample;
  while (TRUE) {
    pSample = m_lFree.RemoveHead();
    if (pSample != NULL) {
      delete pSample;
    } else {
      break;
    }
  }

  m_lAllocated = 0;

}


/* Destructor frees our memory resources */

CRecAllocator::~CRecAllocator()
{
    Decommit();
    ReallyFree();

    ASSERT(m_cDelivered == 0);

    if(m_heSampleReleased)
      EXECUTE_ASSERT(CloseHandle(m_heSampleReleased));
}

HRESULT
CRecAllocator::GetBuffer(
  CRecSample **ppBuffer,
  REFERENCE_TIME *pStartTime,
  REFERENCE_TIME *pEndTime,
  DWORD dwFlags)
{
  UNREFERENCED_PARAMETER(pStartTime);
  UNREFERENCED_PARAMETER(pEndTime);
  UNREFERENCED_PARAMETER(dwFlags);
  CRecSample *pSample;

  *ppBuffer = NULL;
  while (TRUE) {

    {
      CAutoLock cObjectLock(this);

      /* Check we are committed */
      if (!m_bCommitted) {
        return VFW_E_NOT_COMMITTED;
      }
      pSample = (CRecSample *) m_lFree.RemoveHead();
      if (pSample == NULL) {
        SetWaiting();
      }
    }

    /* If we didn't get a sample then wait for the list to signal */

    if (pSample) {
      break;
    }
    ASSERT(m_hSem != NULL);
    WaitForSingleObject(m_hSem, INFINITE);
  }

  /* This QueryInterface should addref the buffer up to one. On release
     back to zero instead of being deleted, it will requeue itself by
     calling the ReleaseBuffer member function. NOTE the owner of a
     media sample must always be derived from CRecBaseAllocator */

  pSample->m_cRef = 1;
  *ppBuffer = pSample;

  pSample->SetUser(0);

  pSample->m_fDelivered = false;

  return NOERROR;
}


void CRecAllocator::IncrementDelivered()
{
    InterlockedIncrement(&m_cDelivered);
}

void CRecAllocator::DecrementDelivered()
{
    DbgLog((LOG_TRACE, 0x3f,
            TEXT("CRecAllocator::DecrementDelivered: %08x"), this));
    EXECUTE_ASSERT(InterlockedDecrement(&m_cDelivered) >= 0);
    EXECUTE_ASSERT(SetEvent(m_heSampleReleased));
}


// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

CRecSample::CRecSample(
  TCHAR *pName,
  CBaseAllocator *pAllocator,
  HRESULT *phr,
  LPBYTE pBuffer,
  LONG length) :
    CMediaSample(pName, pAllocator, phr, pBuffer, length),
    m_pParentBuffer(0)              // no parent cache buffer

{
}


/* Destructor deletes the media type memory */

CRecSample::~CRecSample()
{
}

HRESULT CRecSample::SetParent(CRecBuffer *pRecBuffer)
{
  /* Check we are committed */
  ASSERT(m_pParentBuffer == 0);
  m_pParentBuffer = pRecBuffer;
  pRecBuffer->AddRef();

  return S_OK;
}

void CRecSample::MarkDelivered()
{
    m_fDelivered = true;
    ((CRecAllocator *)m_pAllocator)->IncrementDelivered();
}

STDMETHODIMP_(ULONG)
CRecSample::Release()
{
    /* Decrement our own private reference count */
    LONG lRef = InterlockedDecrement(&m_cRef);
    ASSERT(lRef >= 0);

    DbgLog((LOG_MEMORY,3,TEXT("    CRecSample %X ref-- = %d"),
	    this, m_cRef));

    /* Did we release our final reference count */
    if (lRef == 0) {
        /*  Free all resources */
        SetMediaType(NULL);
        m_dwFlags = 0;

        // decrement ref count on cache buffer.
        if(m_pParentBuffer)
        {
          m_pParentBuffer->Release();
          m_pParentBuffer = 0;
        }

        if(m_fDelivered) {
            ((CRecAllocator *)m_pAllocator)->DecrementDelivered();
        }

	/* This may cause us to be deleted */
	// Our refcount is reliably 0 thus no-one will mess with us
        m_pAllocator->ReleaseBuffer(this);
    }
    return (ULONG)lRef;
}

STDMETHODIMP
CRecSample::SetActualDataLength(LONG lActual)
{
  m_cbBuffer = lActual;
  return CMediaSample::SetActualDataLength(lActual);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\core\msreader\basemsr.h ===
#pragma warning(disable: 4097 4511 4512 4514 4705)

// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.

#ifndef _basemsr_h
#define _basemsr_h

#include "reader.h"
#include "alloc.h"

// forward declarations
class CBaseMSRInPin;
class CBaseMSRFilter;
class CBaseMSROutPin;

// use this to avoid comparing guids frequently in the push
// loop. could compare pointers to the guids as long as they're
// ours...
enum TimeFormat
{
  FORMAT_NULL,
  FORMAT_TIME,
  FORMAT_SAMPLE,
  FORMAT_FRAME
};

struct ImsValues
{
  double dRate;

  // tick values
  LONGLONG llTickStart, llTickStop;

  // values IMediaSelection or IMediaPosition sent us. used for
  // partial frames
  LONGLONG llImsStart, llImsStop;

  // Flags for the seek
  DWORD dwSeekFlags;
};

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// CBaseMSRFilter represents a media file with one or more streams
//
// responsible for
// -- finding file and enumerating streams
// -- giving access to individual streams within the file
// -- control of streaming
// supports
//  -- CBaseFilter
//

class AM_NOVTABLE CBaseMSRFilter :
  public CBaseFilter,
  public CCritSec
{
public:

  // constructors etc
  CBaseMSRFilter(TCHAR *pszFilter, LPUNKNOWN pUnk, CLSID clsid, HRESULT *phr);
  virtual ~CBaseMSRFilter();

  // input pin notifies filter of connection and gives the
  // IAsyncReader interface this way. parse the file here and create
  // output pins (leave pins in a state ready to connect downstream).
  virtual HRESULT NotifyInputConnected(IAsyncReader *pAsyncReader);

  virtual HRESULT NotifyInputDisconnected();

  // information about the file/streams the cache
  // wants. iLeadingStream indicates that this stream should drive,
  // and the others should follow. negative otherwise
  virtual HRESULT GetCacheParams(
    StreamBufParam *pSbp,
    ULONG *pcbRead,
    ULONG *pcBuffers,
    int *piLeadingStream);

  // stream has queued a sample. block until all streams are ready
  void NotifyStreamQueuedAndWait();

  // don't block (if pin is not active, for example)
  void NotifyStreamQueued();

  // ------ CBaseFilter methods ------
  int GetPinCount();
  CBasePin * GetPin(int ix);

  // STDMETHODIMP FindPin(LPCWSTR pwszPinId, IPin **ppPin);

  virtual STDMETHODIMP Pause();
  virtual STDMETHODIMP Stop();

  // constant: how many QueueReadsSamples can exist
  const ULONG C_MAX_REQS_PER_STREAM;

  // pin method. here to avoid new input pin class for one method.
  virtual HRESULT CheckMediaType(const CMediaType* mtOut) = 0;

  static TimeFormat MapGuidToFormat(const GUID *const pGuidFormat);

  // used to parse header. addrefd
  struct IAsyncReader *m_pAsyncReader;

  // Seeking caps
  DWORD m_dwSeekingCaps;

  // stream requests seeking if through this interface. Only one will
  // succeed
  BOOL RequestSeekingIf(ULONG iStream);

  // SetSeekingIf should only be called from a (successful)
  // IMediaSeeking::SetTimeFormat.  Whichever pin is supporting
  // a specific time format has GOT to be the preferred seeking
  // pin.
  void SetSeekingIf(ULONG iStream);

  // distributes the seek to all the streams except the one that
  // called. This just updates workers start and stop times.
  HRESULT SeekOtherStreams(
    ULONG iStream,
    REFERENCE_TIME *prtStart,
    REFERENCE_TIME *prtStop,
    double dRate,
    DWORD dwSeekFlags);

  // if the start time is changing, we'll need to restart the worker
  HRESULT StopFlushRestartAllStreams(DWORD dwSeekFlags);

  HRESULT NotifyExternalMemory(IAMDevMemoryAllocator *pDevMem) {
    return m_pImplBuffer->NotifyExternalMemory(pDevMem);
  }


protected:

  // helper
  HRESULT AllocateAndRead (BYTE **ppb, DWORD cb, DWORDLONG qwPos);

  // allocated here
  CBaseMSRInPin *m_pInPin;
  CBaseMSROutPin **m_rgpOutPin;

  // number of streams and pins
  UINT m_cStreams;

  // allocated here
  IMultiStreamReader *m_pImplBuffer;

  // create input pin when filter is created
  virtual HRESULT CreateInputPin(CBaseMSRInPin **ppInPin);

private:

  // parse the file. create output pins in m_rgpOutPin. set m_cStreams
  virtual HRESULT CreateOutputPins() = 0;

  virtual HRESULT RemoveOutputPins();

  // event set when all streams have queued samples on startup. after
  // Active() (NotifyStreamActive) all streams MUST call
  // NotifyStreamQueued even on error paths
  HANDLE m_heStartupSync;
  long m_ilcStreamsNotQueued;

  // we want only one pin to expose a seeking if so that we can more
  // easily flush the file source filter. Reset (-1) when the input
  // pin is connected. need to track which pin can expose it (not just
  // first) in case the if is released
  long m_iStreamSeekingIfExposed;

  // protect the above
  CCritSec m_csSeekingStream;
};

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// input pin. uses IAsyncReader and not IMemInputPin

class CBaseMSRInPin : public CBasePin
{
protected:
  class CBaseMSRFilter* m_pFilter;

public:
  CBaseMSRInPin(
    class CBaseMSRFilter *pFilter,
    HRESULT *phr,
    LPCWSTR pPinName);

  virtual ~CBaseMSRInPin();

  // CBasePin / CBasePin overrides
  virtual HRESULT CheckMediaType(const CMediaType* mtOut);
  virtual HRESULT CheckConnect(IPin * pPin);
  virtual HRESULT CompleteConnect(IPin *pReceivePin);
  virtual HRESULT BreakConnect();

  STDMETHODIMP BeginFlush(void) { return E_UNEXPECTED; }
  STDMETHODIMP EndFlush(void) { return E_UNEXPECTED; }
};


// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

// worker thread object
//
class AM_NOVTABLE CBaseMSRWorker : public CAMThread
{
public:
  // sets the worker thread start, stop and rate variables. Called before push
  // starts, and also when a put_Stop happens during running.
  virtual HRESULT SetNewSelection(void);

protected:

  CBaseMSROutPin * m_pPin;

  // type-corrected overrides of communication funcs
  //
  enum Command
  {
    CMD_RUN, CMD_STOP, CMD_EXIT
  };

  Command GetRequest()
  {
    return (Command) CAMThread::GetRequest();
  }

  BOOL CheckRequest(Command * pCom)
  {
    return CAMThread::CheckRequest((DWORD *)pCom);
  }

  void DoRunLoop(void);

  void DoEndOfData();

  HRESULT NewSegmentHelper();

  // return VFW_S_NO_MORE_ITEMS if we reached sStop. S_FALSE if
  // position changed or received. fail if it's our error to
  // signal. S_OK if someone else wants us to stop.
  virtual HRESULT PushLoop();

  // Set the current time (some amount before m_tStart), accounting
  // for preroll.
  virtual HRESULT PushLoopInit(
    LONGLONG *pllCurrentOut,
    ImsValues *pImsValues) = 0;

  // override this if you need to munge the sample before
  // delivery. careful changing the buffer contents as you are
  // changing what's in the cache
  virtual HRESULT AboutToDeliver(IMediaSample *pSample);

  virtual HRESULT CopyData(
    IMediaSample **ppSampleOut,
    IMediaSample *pSampleIn);

  // override this if you deal with data that should not be delivered
  // (eg palette changes or in stream index nodes)
  virtual HRESULT HandleData(IMediaSample *pSample, DWORD dwUser)
  { return S_OK; }

  // see if read has completed, deliver it. Deliver can block.
  virtual HRESULT TryDeliverSample(
    BOOL *pfDeliveredSample,
    BOOL *pfStopPlease);

  // return S_OK if we queued a sample or it's a zero byte sample. set
  // rfQueuedSample if we queued a sample. VFW_S_NO_MORE_ITEMS if we
  // reached the end (end of index or reached m_tStop). S_FALSE if the
  // queue was full. update rtCurrent. call m_pReader->QueueReadSample
  virtual HRESULT TryQueueSample(
    LONGLONG &rllCurrent,       // [in, out]
    BOOL &rfQueuedSample,       // [out]
    ImsValues *pImsValues
    ) = 0;

  // internal state shared by the functions in the push loop. cannot
  // change when worker is running
  TimeFormat m_Format;
  LONGLONG m_llPushFirst;

  // this causes problems if you mix PERF and non PERF builds...
#ifdef PERF
  int m_perfidDeliver;              /* MSR_id for Deliver() time */
  int m_perfidWaitI;                /* block for read operation */
  int m_perfidNotDeliver;           // time between delivers
#endif // PERF

  ULONG m_cSamples;

  // pin/stream number
  UINT m_id;

  // not addrefd
  IMultiStreamReader *m_pReader;


public:

  // constructor
  CBaseMSRWorker(UINT stream, IMultiStreamReader *pReader);
  virtual ~CBaseMSRWorker() {;}

  // actually create the stream and bind it to a thread
  virtual BOOL Create(CBaseMSROutPin * pPin);

  // the thread executes this function, then exits
  DWORD ThreadProc();

  // commands we can give the thread
  HRESULT Run();
  HRESULT Stop();
  HRESULT Exit();

  // tell thread to reset itself
  HRESULT NotifyStreamActive();

private:

  // snapshot of start and stop times of push loop. protect access
  // from worker thread
  ImsValues m_ImsValues;

  // helper to call filter.
  inline void NotifyStreamQueued();
  inline void NotifyStreamQueuedAndWait();

  // whether this thread has yet told the filter it has queued a read
  BOOL m_fCalledNotifyStreamQueued;
};


// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

// CBaseMSROutPin represents one stream of data within the file
// responsible for delivering data to connected components
//
// supports IPin
//
// never created by COM, so no CreateInstance or entry in global
// FactoryTemplate table. Only ever created by a CBaseMSROutPin object and
// returned via the EnumPins interface.
//

class AM_NOVTABLE CBaseMSROutPin :
    public CBaseOutputPin
{

public:
  CBaseMSROutPin(
    CBaseFilter *pOwningFilter,
    CBaseMSRFilter *pFilter,
    UINT iStream,
    IMultiStreamReader *&rpImplBuffer,
    HRESULT *phr,
    LPCWSTR pName);

  virtual ~CBaseMSROutPin();

  // expose IMediaPosition, IMediaSelection and what CBaseOutputPin
  // provides
  STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);

  // allow output pin different life time than filter
  STDMETHODIMP_(ULONG) NonDelegatingRelease();
  STDMETHODIMP_(ULONG) NonDelegatingAddRef();

  // CBaseOutPin and IPin methods

  // STDMETHODIMP QueryId(LPWSTR *Id);

  HRESULT GetMediaType(int iPosition, CMediaType* pt) = 0;
  HRESULT CheckMediaType(const CMediaType*);

  HRESULT DecideAllocator(IMemInputPin * pPin, IMemAllocator ** pAlloc);

  virtual HRESULT DecideBufferSize(
    IMemAllocator * pAlloc,
    ALLOCATOR_PROPERTIES *pProperties);

  // note this returns a cRecSample, not an IMediaSample
  HRESULT GetDeliveryBufferInternal(
    CRecSample ** ppSample,
    REFERENCE_TIME * pStartTime,
    REFERENCE_TIME * pEndTime,
    DWORD dwFlags);

  virtual HRESULT Active();
  virtual HRESULT Inactive();

  // derived class should create its worker.
  virtual HRESULT OnActive() = 0;

  HRESULT BreakConnect();

  // ----- called by worker thread ---

  // override to receive Notification messages
  STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);

  virtual ULONG GetMaxSampleSize() = 0;
  virtual BOOL UseDownstreamAllocator() { return FALSE; }

  // IMediaSelection stuff.

  // override these to support something other than time_format_none
  virtual HRESULT IsFormatSupported(const GUID *const pFormat);

  virtual HRESULT QueryPreferredFormat(GUID *pFormat);

  virtual HRESULT SetTimeFormat(const GUID *const pFormat);
  virtual HRESULT GetTimeFormat(GUID *pFormat);
  virtual HRESULT GetDuration(LONGLONG *pDuration) = 0;
  virtual HRESULT GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest )
    {
        return E_NOTIMPL;
    }


  HRESULT UpdateSelectionAndTellWorker(
    LONGLONG *pCurrent,
    LONGLONG *pStop,
    REFTIME *pTime,
    double dRate,
    const GUID *const pGuidFormat,
    DWORD dwSeekFlags
    );

  HRESULT StopWorker(bool bFlush);
  HRESULT RestartWorker();

  // for renderers only
  virtual HRESULT GetStopPosition(LONGLONG *pStop);
  virtual HRESULT GetCurrentPosition(LONGLONG *pCurrent);

  // derived class should return REFTIME value. set m_llCvtIms values
  virtual HRESULT RecordStartAndStop(
    LONGLONG *pCurrent,
    LONGLONG *pStop,
    REFTIME *pTime,
    const GUID *const pGuidFormat
    ) = 0;

  virtual HRESULT ConvertTimeFormat(
      LONGLONG * pTarget, const GUID * pTargetFormat,
      LONGLONG    Source, const GUID * pSourceFormat
      );

  double GetRate() const { return m_dImsRate; }

protected:

  // format IMediaSelection is using can only changed when worker is
  // stopped
  GUID m_guidFormat;

  // IMediaSelection values. zero rate indicates these values are
  // unset. in m_guidFormat units
  double m_dImsRate;
  LONGLONG m_llImsStart, m_llImsStop;
  DWORD    m_dwSeekFlags;

  // converted to ticks in RecordStartAndStop(). also set on startup
  // in InitializeOnNewFile()
  LONGLONG m_llCvtImsStart, m_llCvtImsStop;

  // lock when setting the above to protect worker thread
  CCritSec m_csImsValues;

  long m_ilfNewImsValues;

  //
  // Source seeking variables
  //
public:
  REFERENCE_TIME m_rtAccumulated;   // Ref time accumulated
  DWORD          m_dwSegmentNumber; // Segment number

public:

  CMediaType& CurrentMediaType() { return m_mt; }
  GUID* CurrentFormat() { return &m_guidFormat; }

  // return stream start and length in internal units.
  virtual LONGLONG GetStreamStart() = 0;
  virtual LONGLONG GetStreamLength() = 0;

  virtual HRESULT InitializeOnNewFile();

  // convert internal units to REFERENCE_TIME units. !!! really
  // needed? only used for DeliverNewSegment().
  virtual REFERENCE_TIME ConvertInternalToRT(const LONGLONG llVal) = 0;
  virtual LONGLONG ConvertRTToInternal(const REFERENCE_TIME llVal) = 0;

  HRESULT CreateImplSelect();

protected:

  CBaseMSRFilter *m_pFilter;

  IMultiStreamReader *&m_rpImplBuffer;

  // helper to return a FCC code with our stream id and
  // the upper two characters of the fcc code
  //
  // FOURCC TwoCC(WORD tcc);

  UINT m_id;                    // stream number

  friend class CBaseMSRWorker;
  CBaseMSRWorker *m_pWorker;

  // the one allocator created on creation of this pin. The
  // allocator's lifetime may be longer than the pin's, so it's
  // created separately
  friend class CBaseMSRFilter;
  CRecAllocator *m_pRecAllocator;

  CCritSec m_cs;

  // implementation of IMediaPosition
  class CImplPosition : public CSourcePosition, public CCritSec
  {

  protected:

    CBaseMSROutPin * m_pStream;
    HRESULT ChangeStart();
    HRESULT ChangeStop();
    HRESULT ChangeRate();

  public:

    CImplPosition(TCHAR*, CBaseMSROutPin*, HRESULT*);
    void GetValues(CRefTime *ptStart, CRefTime *ptSop, double *pdRate);
  };

  class CImplSelect :
    public IMediaSeeking,
    public CMediaPosition
  {
  private:
    CBaseMSROutPin *m_pPin;

  public:
    CImplSelect(TCHAR *, LPUNKNOWN, CBaseMSROutPin *pPin, HRESULT *);

    DECLARE_IUNKNOWN
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    // returns S_OK if mode is supported, S_FALSE otherwise
    STDMETHODIMP IsFormatSupported(const GUID * pFormat);
    STDMETHODIMP QueryPreferredFormat(GUID *pFormat);

    // can only change the mode when stopped (returns
    // VFE_E_WRONG_STATE otherwise) !!!
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);

    STDMETHODIMP GetTimeFormat(GUID *pFormat);
    STDMETHODIMP GetDuration(LONGLONG *pDuration);
    STDMETHODIMP GetStopPosition(LONGLONG *pStop);
    STDMETHODIMP GetCurrentPosition(LONGLONG *pCurrent);

    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities );

    STDMETHODIMP ConvertTimeFormat( LONGLONG * pTarget, const GUID * pTargetFormat,
                                    LONGLONG    Source, const GUID * pSourceFormat );

    STDMETHODIMP SetPositions( LONGLONG * pCurrent,  DWORD CurrentFlags
			     , LONGLONG * pStop,  DWORD StopFlags );

    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );

    STDMETHODIMP GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest );
    STDMETHODIMP SetRate( double dRate);
    STDMETHODIMP GetRate( double * pdRate);
    STDMETHODIMP GetPreroll(LONGLONG *pPreroll) { return E_NOTIMPL; }

    /* IMediaPosition methods */
    STDMETHOD(get_Duration)(THIS_ REFTIME FAR* plength) ;
    STDMETHOD(put_CurrentPosition)(THIS_ REFTIME llTime);
    STDMETHOD(get_CurrentPosition)(THIS_ REFTIME FAR* pllTime);
    STDMETHOD(get_StopTime)(THIS_ REFTIME FAR* pllTime) ;
    STDMETHOD(put_StopTime)(THIS_ REFTIME llTime) ;
    STDMETHOD(get_PrerollTime)(THIS_ REFTIME FAR* pllTime) ;
    STDMETHOD(put_PrerollTime)(THIS_ REFTIME llTime) ;
    STDMETHOD(put_Rate)(THIS_ double dRate) ;
    STDMETHOD(get_Rate)(THIS_ double FAR* pdRate) ;
    STDMETHOD(CanSeekForward)(THIS_ long FAR* pCanSeekForward) ;
    STDMETHOD(CanSeekBackward)(THIS_ long FAR* pCanSeekBackward) ;
  };

  // friend class CImplPosition;
  friend STDMETHODIMP CImplSelect::SetRate( double dRate);
  friend STDMETHODIMP CImplSelect::GetCapabilities(DWORD * pCapabilities );
  friend STDMETHODIMP CBaseMSROutPin::CImplSelect::SetPositions (
    LONGLONG * pCurrent,
    DWORD CurrentFlags ,
    LONGLONG * pStop,
    DWORD StopFlags);

  CImplPosition * m_pPosition;
  CImplSelect *m_pSelection;

  BOOL m_fUsingExternalMemory;
};

//  Audio stuff required by AVI and Wave
bool FixMPEGAudioTimeStamps(
    IMediaSample *pSample,
    BOOL bFirstSample,
    const WAVEFORMATEX *pwfx
);

#endif // _basemsr_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\core\msreader\reader.cpp ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)

// reader.cpp: IMultiStreamReader implementations


#include <streams.h>
#include "reader.h"
#include "reccache.h"
#include "alloc.h"

#ifdef DEBUG
#define DEBUG_EX(x) x
#else
#define DEBUG_EX(x)
#endif

// try to read this much each time
const ULONG CB_MIN_RECORD = 16 * 1024;


HRESULT CreateMultiStreamReader(
  IAsyncReader *pAsyncReader,
  ULONG cStreams,
  StreamBufParam *rgStreamBufParam,
  ULONG cbRead,
  ULONG cBuffersRead,
  int iLeadingStream,
  IMultiStreamReader **ppReader)
{
  IMemAllocator *pOurAllocator = 0;
  IMemAllocator *pAllocatorActual = 0;
  CRecCache *pRecCache = 0;
  IMultiStreamReader *pReader = 0;
  *ppReader = 0;
  ULONG cbLargestSample = 0;
  UINT iStream;

  // determine which implementation of IMultiStreamReader to use

  if(cStreams >= C_STREAMS_MAX || cStreams == 0)
    return E_INVALIDARG;

  HRESULT hr = S_OK;
  pRecCache = new CRecCache(&hr);
  if(pRecCache == 0)
    hr = E_OUTOFMEMORY;
  if(FAILED(hr))
    goto Cleanup;

  hr = pRecCache->QueryInterface(IID_IMemAllocator, (void **)&pOurAllocator);
  if(FAILED(hr))
    goto Cleanup;

  for(iStream = 0; iStream < cStreams; iStream++)
    if(rgStreamBufParam[iStream].cbSampleMax > cbLargestSample)
      cbLargestSample = rgStreamBufParam[iStream].cbSampleMax;

  // suggest values for his allocator to use
  ALLOCATOR_PROPERTIES apReq;
  ZeroMemory(&apReq, sizeof(apReq));
  apReq.cbPrefix = 0;
  apReq.cbBuffer = cbLargestSample;
  apReq.cBuffers = cStreams;
  apReq.cbAlign = 1;

  // this gives us an addrefd allocator
  hr = pAsyncReader->RequestAllocator(pOurAllocator, &apReq, &pAllocatorActual);
  if(FAILED(hr))
    goto Cleanup;

  if(pAllocatorActual == pOurAllocator)
  {
    hr = S_OK;
    pReader = new CImplReader_1(
      pAsyncReader,
      cStreams,
      rgStreamBufParam,
      cbRead,
      cBuffersRead,
      iLeadingStream,
      pRecCache,
      &hr);
    if(pReader == 0)
      hr = E_OUTOFMEMORY;
    if(FAILED(hr))
      goto Cleanup;

    *ppReader = pReader;
    hr = S_OK;
  }
  else
  {
    hr = S_OK;
//     pReader = new CImplReader_2(
//       pAsyncReader,
//       &hr);

    DbgBreak("not yet implemented");
    hr = E_UNEXPECTED;
  }

  // anyone who wanted our cache / allocator has its own addref now
  pAllocatorActual->Release();
  pOurAllocator->Release();
  return hr;

Cleanup:

  if(pOurAllocator)
    pOurAllocator->Release();
  else
    delete pRecCache;

  if(pAllocatorActual)
    pAllocatorActual->Release();

  delete pReader;
  *ppReader = 0;

  return hr;
}

// number of max-sized samples from each stream in a record (eg 5
// audio and 5 video samples) if none is specified. at 15fps, this
// means 2 second buffering. at 30 fps, 1 second... that's why it
// should be specified.
const unsigned C_SAMPLES_PER_RECORD = 5;

// ------------------------------------------------------------------------
// constructor

CImplReader_1::CImplReader_1(
  IAsyncReader *pAsyncReader,
  UINT cStreams,
  StreamBufParam *rgStreamBufParam,
  ULONG cbRead,
  ULONG cBuffersRead,
  int iLeadingStream,
  CRecCache *pRecCache,
  HRESULT *phr)
{
  m_cStreams = 0;
  m_pAsyncReader = 0;
  m_llFileLength = 0;

  m_fFileOpen = FALSE;
  m_bInitialized = FALSE;
  m_bFlushing = FALSE;
  m_pRecCache = 0;
  m_rgpStreamInfo = 0;
  m_dwAlign = 0;
  m_cRecords = 0;
  m_ilcPendingReads = 0;
  m_qwLastReadEnd = 0;
  m_qwEndLastCompletedRead = 0;
  m_iLeadingStream = iLeadingStream;
  m_iLeadingStreamSaved = iLeadingStream;

  if(FAILED(*phr))
    return;

  HRESULT hr = S_OK;

  m_cStreams = cStreams;

#ifdef PERF
  m_perfidDisk = MSR_REGISTER(TEXT("read disk buffer"));
  m_perfidSeeked = MSR_REGISTER(TEXT("disk seek"));
#endif // PERF

  ULONG cbLargestSample = 0;
  ULONG cbRecord = 0, cbRecordPadded = 0;

  m_cRecords = max(cStreams, cBuffersRead);
  m_cRecords = max(m_cRecords, 2);

  // needed to configure CRecCache
  ULONG rgStreamSize[C_STREAMS_MAX];

  ALLOCATOR_PROPERTIES apActual;
  hr = pRecCache->GetProperties(&apActual);
  if(FAILED(hr))
    goto Cleanup;

  // want at least DWORD alignment so that if frames are DWORD aligned
  // in the file, they will be DWORD aligned in memory
  m_dwAlign = max(apActual.cbAlign, sizeof(DWORD));

  // data structure for maintaining read requests
  m_rgpStreamInfo = new CStreamInfo*[m_cStreams];
  if(m_rgpStreamInfo == 0)
  {
    hr = E_OUTOFMEMORY;
    goto Cleanup;
  }

  UINT iStream;
  for(iStream = 0; iStream < m_cStreams; iStream++)
    m_rgpStreamInfo[iStream] = 0;

  for(iStream = 0; iStream < m_cStreams; iStream++)
  {
    hr = S_OK;
    m_rgpStreamInfo[iStream] = new CStreamInfo(
      &rgStreamBufParam[iStream],
      &hr);
    if(m_rgpStreamInfo[iStream] == 0)
    {
      hr = E_OUTOFMEMORY;
      goto Cleanup;
    }
    if(FAILED(hr))
      goto Cleanup;

    if(rgStreamBufParam[iStream].cbSampleMax > cbLargestSample)
      cbLargestSample = rgStreamBufParam[iStream].cbSampleMax;

    rgStreamSize[iStream] = AlignUp(rgStreamBufParam[iStream].cbSampleMax) +
      m_dwAlign;
  }

  if(cbRead == 0)
  {

    // cache buffers need to be able to hold C_SAMPLES_PER_RECORD
    // samples from each stream 1) if each sample starts on a new
    // m_dwAlign boundary or 2) if that amount requires padding to an
    // extra m_dwAlign on either side.

    for(iStream = 0; iStream < m_cStreams; iStream++)
    {
      // !!! these should really add room for the RiffChunk which may be
      // what's aligned. Think about whether the rec chunk should be
      // added too
      cbRecord += rgStreamBufParam[iStream].cbSampleMax * C_SAMPLES_PER_RECORD;
      cbRecordPadded +=
        AlignUp(rgStreamBufParam[iStream].cbSampleMax) * C_SAMPLES_PER_RECORD;

      // !!! temporary solution for the REC chunk problem
      cbRecordPadded += m_dwAlign;
    }

    // 2) need at least two sectors padding in case the samples are not
    // all aligned
    if(cbRecordPadded - cbRecord < (m_dwAlign -1 ) * 2)
      cbRecordPadded = AlignUp(cbRecord + (m_dwAlign -1 ) * 2);

    if(cbRecordPadded < CB_MIN_RECORD)
      cbRecordPadded = CB_MIN_RECORD;

    m_cbRecord = cbRecordPadded;

  } // cbRead == 0
  else
  {
    if(cbRead < CB_MIN_RECORD)
      cbRead = CB_MIN_RECORD;

    // we are responsible for adding alignment on both sides of the
    // buffer.
    cbRead += m_dwAlign * 2; 
    m_cbRecord = AlignUp(cbRead);
  }

  hr = pRecCache->Configure(
    m_cRecords,
    m_cbRecord,
    m_dwAlign,
    cStreams,
    rgStreamSize                // used with reserve buffers
    );
  if(FAILED(hr))
    goto Cleanup;

  LONGLONG llTmp;
  hr = pAsyncReader->Length(&m_llFileLength, &llTmp);
  if(FAILED(hr))
    goto Cleanup;

  pAsyncReader->AddRef();
  m_pAsyncReader = pAsyncReader;

  // start/configure worker thread
  if(!m_workerRead.Create(this))
  {
    hr = E_UNEXPECTED;
    goto Cleanup;
  }

  pRecCache->AddRef();
  m_pRecCache = pRecCache;

  m_bInitialized = TRUE;
  *phr = S_OK;
  return;

Cleanup:

  m_bInitialized = FALSE;

  if(m_rgpStreamInfo)
    for(iStream = 0; iStream < m_cStreams; iStream++)
      delete m_rgpStreamInfo[iStream];
  delete[] m_rgpStreamInfo;
  m_rgpStreamInfo = 0;

  delete m_pRecCache;
  m_pRecCache = 0;

  m_cRecords = 0;
  m_cStreams = 0;

  *phr = hr;
}

CImplReader_1::~CImplReader_1()
{
  m_workerRead.Exit();

  FreeAndReset();
}

// ------------------------------------------------------------------------
// IMultiStreamReader methods

HRESULT CImplReader_1::Close()
{
  {
    CAutoLock lock(&m_cs);

    if(!m_fFileOpen)
      return S_FALSE;
    ASSERT(m_pAsyncReader);

    m_fFileOpen = FALSE;
  }

  if(m_rgpStreamInfo)
  {
    for(UINT iStream = 0; iStream < m_cStreams; iStream++)
    {
      if(m_rgpStreamInfo[iStream])
        ClearPending(iStream);
    }
  }

  FreeAndReset();
  return S_OK;
}

HRESULT CImplReader_1::Start()
{
  // reset m_qwEndLastCompletedRead to the last successful read that
  // came in. may be zero on startup. !!! when we seek, need to update
  // this to the earliest of all streams we're playing.
  m_qwLastReadEnd = m_qwEndLastCompletedRead;

  // value changed in checkissueread
  m_iLeadingStream = m_iLeadingStreamSaved;

  for(UINT iStream = 0; iStream < m_cStreams; iStream++)
    m_rgpStreamInfo[iStream]->Start();

  return m_workerRead.Run();
}

HRESULT CImplReader_1::BeginFlush()
{
  ASSERT(!m_bFlushing);
  {
      CAutoLock lck(&m_cs);
      m_bFlushing = TRUE;
  }

  DbgLog(( LOG_TRACE, 2, TEXT("CImplReader_1::BeginFlush") ));

  m_pAsyncReader->BeginFlush();
  return m_workerRead.Stop();
}

HRESULT CImplReader_1::EndFlush()
{
  ASSERT(m_bFlushing);
  DbgLog(( LOG_TRACE, 2, TEXT("CImplReader_1::EndFlush") ));

  HRESULT hr = m_pAsyncReader->EndFlush();
  m_bFlushing = FALSE;

  return hr;
}

HRESULT CImplReader_1::QueueReadSample(
  DWORDLONG fileOffset,
  ULONG cbData,
  CRecSample *pSample,
  unsigned stream,
  bool fOooOk)
{
  CAutoLock lock(&m_cs);
  if(!m_bInitialized)
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CImplReader_1:QueueReadSample:not initialized.")));
    return E_FAIL;
  }

  if(stream >= m_cStreams)
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CImplReader_1::QueueReadSample stream out of range.")));
    return E_INVALIDARG;
  }

  CStreamInfo *pSi = m_rgpStreamInfo[stream];

  if(pSi->m_bFlushing)
  {
    DbgLog(( LOG_ERROR, 2, TEXT("CImplReader_1::QueueReadSample flushing.")));
    return E_UNEXPECTED;
  }

  if(cbData > pSi->GetCbLargestSample())
  {
    DbgLog(( LOG_ERROR, 2, TEXT("CImplReader_1::Read sample large.")));

    // VFW_E_INVALID_FILE_FORMAT ?
    return VFW_E_BUFFER_OVERFLOW;
  }

  if(m_llFileLength && (LONGLONG)(fileOffset + cbData) > m_llFileLength)
    return HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);

  SampleReq *pSampleReq = pSi->PromoteFirst(SampleReq::FREE);
  if(pSampleReq == 0)
  {
    DbgLog(( LOG_TRACE, 2, TEXT("CImplReader_1::QRS out of sreqs.")));
    return E_OUTOFMEMORY;
  }
  ASSERT(pSampleReq != 0);

  pSampleReq->fOooOk = fOooOk;
  
  pSampleReq->pSample = pSample;
  pSample->AddRef();
  pSampleReq->fileOffset = fileOffset;
  pSampleReq->cbReq = cbData;
  pSampleReq->stream = stream;

  DbgLog((LOG_TRACE, 0x45, TEXT("queueing %08x with %08x"),
          pSampleReq, pSample));

//   if((fileOffset + cbData > m_qwLastReadEnd + m_cbRecord) ||
//      pSi->NeedsQueued())
//   {
//     CAutoLock lock(&m_cs);
//     hr = CheckIssueRead();
//     if(FAILED(hr))
//     {
//       DbgLog((LOG_ERROR, 2,
//               TEXT("::QueueReadSample: CheckIssueRead failed.")));
//       return hr;
//     }
//   }

  return S_OK;
}

HRESULT CImplReader_1::PollForSample(
  IMediaSample **ppSample,
  unsigned stream)
{
  if(stream >= m_cStreams)
  {
    DbgBreak("CImplReader_1::PollForSample: bad stream");
    return E_INVALIDARG;
  }

  CStreamInfo *pSi = m_rgpStreamInfo[stream];
//   if(pSi->m_bFlushing)
//   {
//     DbgLog(( LOG_ERROR, 2, TEXT("CImplReader_1::PollForSample flushing.")));
//     return E_UNEXPECTED;
//   }

  if(pSi->WantsQueued())
  {
    CAutoLock lock(&m_cs);
    HRESULT hr = CheckIssueRead();
    if(FAILED(hr))
      return hr;
  }

  HRESULT hr;

  HRESULT hrSampleError;
  hr = pSi->PromoteFirstComplete(ppSample, &hrSampleError);
  if(FAILED(hr))
  {
    ASSERT(*ppSample == 0);
    return hr;
  }

  // !!! problems like this should be handled better.
  if(hrSampleError == VFW_E_TIMEOUT)
    hrSampleError = VFW_E_WRONG_STATE;

  DEBUG_EX(pSi->Dbg_Dump(stream, TEXT("PollForSample dump")));  

  return hrSampleError;
}

HRESULT CImplReader_1::WaitForSample(UINT stream)
{
 HRESULT hr = S_OK;
  CStreamInfo *pSi = m_rgpStreamInfo[stream];
  if(pSi->NeedsQueued())
  {
    CAutoLock lock(&m_cs);
    hr = CheckIssueRead();
    if(FAILED(hr))
      return hr;
  }

  DEBUG_EX(ULONG cLoopDbg = 0);

  while(!pSi->get_c_i_and_c())
  {
    DEBUG_EX(if(++cLoopDbg > 200) DbgBreak("possible spin"));

    // block until downstream filter releases a sample. Another stream
    // may issue a sample, so wait on completed samples as well
    HANDLE rghs[2];
    rghs[0] = m_rgpStreamInfo[stream]->m_hsCompletedReq;
    rghs[1] = pSi->GetSampleReleasedHandle();

    // will return because downstream filters must eventually release
    // buffers. (behaves like GetBuffer on allocator)
    DWORD dw = WaitForMultipleObjects(2, rghs, FALSE, INFINITE);
    ASSERT(dw < WAIT_OBJECT_0 + 2);

    if(dw == WAIT_OBJECT_0) {
        EXECUTE_ASSERT(ReleaseSemaphore(rghs[0], 1, 0));
    }

    DbgLog(( LOG_TRACE, 5,
             TEXT("::WaitForSample: unblocked because %s"),
             (dw - WAIT_OBJECT_0 == 0) ?
             TEXT("sample completed") :
             TEXT("sample released")));

    // Lock must be held while calling CheckIssueRead
    CAutoLock lck(&m_cs);
    hr = CheckIssueRead();
    if(FAILED(hr))
      return hr;
  }

  DWORD dw = WaitForSingleObject(
    m_rgpStreamInfo[stream]->m_hsCompletedReq,
    INFINITE);

  ASSERT(dw == WAIT_OBJECT_0);
  EXECUTE_ASSERT(ReleaseSemaphore(
    m_rgpStreamInfo[stream]->m_hsCompletedReq,
    1,
    0));
  return S_OK;
}

HRESULT CImplReader_1::MarkStreamEnd(UINT stream)
{
  CStreamInfo *pSi = m_rgpStreamInfo[stream];
  pSi->MarkStreamEnd();
  return S_OK;
}

HRESULT CImplReader_1::MarkStreamRestart(UINT stream)
{
  CStreamInfo *pSi = m_rgpStreamInfo[stream];
  pSi->MarkStreamRestart();
  return S_OK;
}

// the caller is reqiured not to be queueing new reads on this stream
// or waiting for completed reads on this stream.
HRESULT CImplReader_1::ClearPending(
  unsigned stream)
{
  HRESULT hr = S_OK;
  CStreamInfo *pSi = m_rgpStreamInfo[stream];

  // remove all samplereqs in state PENDING so that they cannot be
  // issued while flushing. this leaves the array in an inconsistent
  // state, reset later.

  {
    CAutoLock lock(&m_cs);

    if(pSi->m_bFlushing)
      return E_UNEXPECTED;
    pSi->m_bFlushing = TRUE;

    // PENDING reqs always accessed with m_cs locked, so this is safe
    pSi->CancelPending();
    ASSERT(pSi->GetCState(SampleReq::PENDING) == 0);
  }

  // handle all those that are complete.
  while(pSi->get_c_i_and_c())
  {
    hr = WaitForSample(stream);
    ASSERT(SUCCEEDED(hr));

    IMediaSample *pSample = 0;
    hr = PollForSample(&pSample, stream);
    if(SUCCEEDED(hr))
    {
      ASSERT(pSample);
      pSample->Release();
    }
    else
    {
      ASSERT(!pSample);
    }
  }

  ASSERT(pSi->GetCState(SampleReq::COMPLETE) == 0);
  ASSERT(pSi->GetCState(SampleReq::ISSUED) == 0);
  ASSERT(pSi->GetCState(SampleReq::PENDING) == 0);

  // this reset is necessary because removing the PENDING requests
  // without promoting them through ISSUED, COMPLETE puts the array
  // in CStreamInfo in an inconsistent state.
  pSi->Reset();

  pSi->m_bFlushing = FALSE;

  return hr;
}

HRESULT CImplReader_1::SynchronousRead(
  BYTE *pb,
  DWORDLONG fileOffset,
  ULONG cbData)
{
  return m_pAsyncReader->SyncRead(fileOffset, cbData, pb);
}

// ------------------------------------------------------------------------
// helpers

ULONG CImplReader_1::AlignUp(ULONG x)
{
  if(x % m_dwAlign != 0)
    x += m_dwAlign - x % m_dwAlign;
  return x;
}

ULONG CImplReader_1::AlignDown(ULONG x)
{
  if(x % m_dwAlign != 0)
    x -= x % m_dwAlign;
  return x;
}

// ------------------------------------------------------------------------
// extract samples from the cache buffer. the buffer may not have been
// issued (on a failed Read Request)

HRESULT
CImplReader_1::ProcessCompletedBuffer(
  CRecBuffer *pRecBuffer,
  HRESULT hrReadError)
{
  HRESULT hr;
  SampleReq *pSampleReq;

  ASSERT(CritCheckIn(&m_cs));

  if(SUCCEEDED(hrReadError))
  {
    ASSERT(pRecBuffer->m_fReadComplete);
    ASSERT(!pRecBuffer->m_fWaitingOnBuffer);
  }

  if(SUCCEEDED(pRecBuffer->m_hrRead))
    pRecBuffer->m_hrRead = hrReadError;

  // if this buffer is waiting on another, it has a refcount on us, so
  // let it process us.
  if(pRecBuffer->m_fWaitingOnBuffer)
    return S_OK;


  // make sure a buffer waiting on us sees an error. !!! is this done
  // in the caller?
  if(pRecBuffer->m_overlap.pBuffer &&
     SUCCEEDED(pRecBuffer->m_overlap.pBuffer->m_hrRead))
    pRecBuffer->m_overlap.pBuffer->m_hrRead = hrReadError;

  if(pRecBuffer->m_hrRead == S_OK)
    pRecBuffer->MarkValid();
  else
    pRecBuffer->MarkValidWithFileError();

  while(pSampleReq = pRecBuffer->sampleReqList.RemoveHead(),
        pSampleReq)
  {
    pSampleReq->hrError = pRecBuffer->m_hrRead;
    ASSERT(pSampleReq->state == SampleReq::ISSUED);
    hr = m_rgpStreamInfo[pSampleReq->stream]->
      PromoteIssued(pSampleReq);
    ASSERT(SUCCEEDED(hr));
  }
  ASSERT(pRecBuffer->sampleReqList.GetCount() == 0);

  return S_OK;
}

HRESULT
CImplReader_1:: NotifyExternalMemory(
    IAMDevMemoryAllocator *pDevMem)
{
    return m_pRecCache->NotifyExternalMemory(pDevMem);
}

HRESULT CImplReader_1::CheckIssueRead()
{
  HRESULT hr;
  DWORDLONG recStart, recEnd;
  ASSERT(CritCheckIn(&m_cs));
  if (m_bFlushing) {
      return VFW_E_WRONG_STATE;
  }

  // if the leading stream has queued all it's going to queue, exit
  // Interleaved mode.
  if(IsInterleavedMode() && m_rgpStreamInfo[m_iLeadingStream]->GetStreamEnd())
  {
    DbgLog((LOG_TRACE, 5,
            TEXT("CImplReader_1::CheckIssueRead: leaving interleaved mode" )));
    // reset in ::Start
    m_iLeadingStream = -1;
  }

  for(UINT iStream = 0; iStream < m_cStreams; iStream++)
  {
    while(ProcessCacheHit(iStream) == S_OK)
      ;
  }

  UINT iStarvedStream;
  CRecBuffer *pRecBuffer;

  for(;;)
  {
    CStreamInfo *pSi = 0;
    for(UINT i = 0; i < m_cStreams; i++)
    {
      if(IsInterleavedMode())
      {
        iStarvedStream = (i + m_iLeadingStream) % m_cStreams;
      }
      else
      {
        iStarvedStream = i;
      }
              
      pSi = m_rgpStreamInfo[iStarvedStream];
      if(pSi->WantsQueued())
        break;
    }
    if(i == m_cStreams)
    {
      break;
    }

    hr = m_pRecCache->GetBuffer(&pRecBuffer);
    if(FAILED(hr))
    {
      DbgLog((LOG_TRACE, 0x3f, TEXT("CheckIssueRead: couldnt get a buffer")));
      break;
    }

    DbgLog(( LOG_TRACE, 5, TEXT("CImplReader_1::CheckIssueRead: stream %i"),
             iStarvedStream ));
    DEBUG_EX(pSi->Dbg_Dump(iStarvedStream, TEXT("CIRead dump")));

    ASSERT((*pRecBuffer)() != 0);
    DbgLog(( LOG_TRACE, 15,
             TEXT("CImplReader_1::CIRead: Got Buffer %08x"), pRecBuffer));
    recStart = recEnd = 0;
    hr = StuffBuffer(pRecBuffer, iStarvedStream, recStart, recEnd);
    if(FAILED(hr))
    {
      DbgBreak("unexpected");
      pRecBuffer->Release();
      return hr;
    }

    ASSERT(pRecBuffer->sampleReqList.GetCount() != 0);

    hr = IssueRead(pRecBuffer, recStart, recEnd);
    pRecBuffer->Release();
    if(FAILED(hr))
      return hr;
  }

  //
  // try a reserve buffer now.
  //

  for(iStarvedStream = 0; iStarvedStream < m_cStreams; iStarvedStream++)
  {
    CStreamInfo *pSi = m_rgpStreamInfo[iStarvedStream];
    if(!pSi->NeedsQueued())
      continue;


    // see if we can get a reserve buffer for this stream
    hr = m_pRecCache->GetReserveBuffer(&pRecBuffer, iStarvedStream);
    if(SUCCEEDED(hr))
    {
      DbgLog(( LOG_TRACE, 15,
               TEXT("CImplReader_1::CIRead: Got Reserve Buf %08x"),
               pRecBuffer));
      recStart = recEnd = 0;

      // queue only the starved stream in this buffer
      hr = StuffReserveBuffer(pRecBuffer, iStarvedStream, recStart, recEnd);
      if(FAILED(hr))
      {
        DbgBreak("unexpected");
        pRecBuffer->Release();
        return hr;
      }

      // at least the first starved sample on this stream in the list
      ASSERT(pRecBuffer->sampleReqList.GetCount() != 0);
      hr = IssueRead(pRecBuffer, recStart, recEnd);
      pRecBuffer->Release();
      if(FAILED(hr))
        return hr;

      continue;
    }
    else if(hr == E_OUTOFMEMORY)
    {
      DbgLog(( LOG_TRACE, 15,
               TEXT("CImplReader_1::CIRead: couldnt get reserve buffer")));

      // could not get a buffer. try the next starved stream
      continue;
    }
    else
    {
      // unknown from GetBuffer / unhandled error
      return hr;
    }
  }

  // all starved streams examined
  return S_OK;
}

HRESULT CImplReader_1::IssueRead(
  CRecBuffer *pRecBuffer,
  DWORDLONG recStart,
  DWORDLONG recEnd)
{
  // extra to read (from sector start to first byte we want)
  ULONG cbLeading = (ULONG)(recStart % m_dwAlign);

  // sector aligned amount to read
  ULONG cbRead = AlignUp(ULONG(recEnd - recStart) + cbLeading);

  // amount at front that overlaps with another buffer
  ULONG cbBytesToSkip = 0;

  DWORDLONG recStartReading = recStart - cbLeading;

  pRecBuffer->m_fileOffsetValid = recStart - cbLeading;
  pRecBuffer->m_cbValid = cbRead;
  pRecBuffer->m_fWaitingOnBuffer = FALSE;
  pRecBuffer->m_fReadComplete = FALSE;
  pRecBuffer->m_hrRead = S_OK;

// #if (DEBUG > 1)
//   FillMemory((*pRecBuffer)(), pRecBuffer->GetSize(), 0xcd);
// #endif // DEBUG > 1

  ZeroMemory(&pRecBuffer->m_overlap, sizeof(pRecBuffer->m_overlap));

  if(m_dwAlign > 1)
  {
    CRecBuffer *pCacheBuffer;
    HRESULT hr = m_pRecCache->GetOverlappedCacheHit(
      recStart - cbLeading,
      m_dwAlign,
      &pCacheBuffer);
    if(hr == S_OK)
    {
      if(pCacheBuffer->GetState() == CRecBuffer::VALID_ACTIVE ||
         pCacheBuffer->GetState() == CRecBuffer::VALID_INACTIVE)
      {
        DbgLog(( LOG_TRACE, 5,
                 TEXT("CImplReader_1::IssueRead: overlap hit, active %08x@%08x"),
                 pCacheBuffer,
                 (ULONG)recStart ));

        CopyMemory(
          (*pRecBuffer)(),
          pCacheBuffer->GetPointer(recStartReading),
          m_dwAlign);

        recStartReading += m_dwAlign;
        cbRead -= m_dwAlign;
        cbBytesToSkip = m_dwAlign;
      }
      else
      {
        ASSERT(pCacheBuffer->GetState() == CRecBuffer::PENDING);
        DbgLog(( LOG_TRACE, 5,
                 TEXT("CImplReader_1::IssueRead: overlap hit, pending %08x@%08x"),
                 pCacheBuffer,
                 (ULONG)recStart ));

        if(pCacheBuffer->m_overlap.pBuffer == 0)
        {
          pRecBuffer->m_fWaitingOnBuffer = TRUE;
          pRecBuffer->AddRef();
          pCacheBuffer->m_overlap.pBuffer = pRecBuffer;
          pCacheBuffer->m_overlap.qwOverlapOffset = recStartReading;
          pCacheBuffer->m_overlap.cbOverlap = m_dwAlign;

          recStartReading += m_dwAlign;
          cbRead -= m_dwAlign;
          cbBytesToSkip = m_dwAlign;
        }
        else
        {
          DbgLog(( LOG_TRACE, 5,
                   TEXT("CImplReader_1::IssueRead: buffer already has one") ));
        }
      }

      pCacheBuffer->Release();
    } // hr == s_OK
  } // m_dwAlign > 1

  // configure the request through IAsyncReader
  LONGLONG tStartThis = recStartReading * UNITS;
  LONGLONG tStopThis = (recStartReading + cbRead) * UNITS;
  pRecBuffer->m_sample.SetTime(&tStartThis, &tStopThis);
  pRecBuffer->m_sample.SetPointer((*pRecBuffer)() + cbBytesToSkip, cbRead);

  BOOL fSeeked = (recStartReading != m_qwLastReadEnd);

  // doesn't handle playing backwards !!!
  m_qwLastReadEnd = recStartReading + cbRead;

  ASSERT((*pRecBuffer)() != 0);
  ASSERT((tStopThis - tStartThis) / UNITS <= pRecBuffer->GetSize());

  // configure all samples in this record with pointers to the data
  POSITION pos = pRecBuffer->sampleReqList.GetHeadPosition();
  ULONG cSample =0;
  while(pos != 0)
  {
    SampleReq *pSampleReq = pRecBuffer->sampleReqList.Get(pos);

    pSampleReq->pSample->SetPointer(
      pRecBuffer->GetPointer(pSampleReq->fileOffset),
      pSampleReq->cbReq);

    pos = pRecBuffer->sampleReqList.Next(pos);
    cSample++;
  }

  DbgLog(( LOG_TRACE, 2,
           TEXT("CImplReader_1::CIRead issue (%x%c%x) = %08x, cSample: %d, b: %x"),
           (DWORD)(tStartThis / UNITS),
           fSeeked ? 'X' : '-',
           (DWORD)(tStopThis / UNITS),
            (DWORD)((tStopThis - tStartThis) / UNITS),
           cSample,
           pRecBuffer));
  if(fSeeked)
    MSR_NOTE(m_perfidSeeked);

  // IAsyncReader does not know to addref the buffer
  pRecBuffer->AddRef();

  ASSERT(!m_bFlushing);
  pRecBuffer->MarkPending();
  InterlockedIncrement(&m_ilcPendingReads);

  MSR_INTEGER(m_perfidDisk, (long)(tStartThis / UNITS));
  HRESULT hr;
  hr = m_pAsyncReader->Request(
    &pRecBuffer->m_sample,
    (DWORD_PTR)pRecBuffer);

  if(FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CImplReader_1::Issue: Request failed. %08x."), hr));
    InterlockedDecrement(&m_ilcPendingReads);
    pRecBuffer->m_fReadComplete = TRUE;
    ProcessCompletedBuffer(pRecBuffer, hr);

    // never set because the cache is still locked
    ASSERT(!pRecBuffer->m_overlap.pBuffer);
    pRecBuffer->Release();
    return hr;
  }

  return S_OK;
}

HRESULT CImplReader_1::StuffReserveBuffer(
  class CRecBuffer *pRecBuffer,
  UINT iStarvedStream,
  DWORDLONG &rRecStart,
  DWORDLONG &rRecEnd)
{
  ASSERT(rRecStart == 0 && rRecEnd == 0);
  HRESULT hr;

  hr = AttachSampleReq(
    pRecBuffer,
    iStarvedStream,
    rRecStart,
    rRecEnd);

  if(FAILED(hr))
      return hr;

  // called with starved stream. must be able to attach first pending
  // sample to empty buffer
  ASSERT(hr == S_OK);

  for(;;)
  {
    hr = AttachSampleReq(
      pRecBuffer,
      iStarvedStream,
      rRecStart,
      rRecEnd);

    if(FAILED(hr))
      return hr;

    if(hr == S_FALSE)
      break;
  }

  return S_OK;
}

HRESULT CImplReader_1::StuffBuffer(
  class CRecBuffer *pRecBuffer,
  UINT iStarvedStream,
  DWORDLONG &rRecStart,
  DWORDLONG &rRecEnd)
{
  ASSERT(rRecStart == 0 && rRecEnd == 0);
  HRESULT hr;

  hr = AttachSampleReq(
    pRecBuffer,
    iStarvedStream,
    rRecStart,
    rRecEnd);

  if(FAILED(hr))
      return hr;

  // called with starved stream. must be able to attach first pending
  // sample to empty buffer
  ASSERT(hr == S_OK);

  // see if that sample left a hole which we can fill in. we have to
  // go back an extra m_dwAlign to handle a read which was not yet
  // requested but results in no buffers containing the entire data.
  DWORDLONG qwStartTarget;
  if(m_qwLastReadEnd < m_dwAlign)
  {
    qwStartTarget = 0;
  }
  else
  {
    qwStartTarget = m_qwLastReadEnd - (m_dwAlign == 1 ? 0 : m_dwAlign);
  }

  // different rules for interleaved files:
  if(IsInterleavedMode())
  {
    // got one sample in the buffer; now use the rest of the
    // buffer to fill in the hole.
    if(rRecStart > qwStartTarget &&
       rRecStart - qwStartTarget < m_cbRecord)
    {
      if(rRecEnd - qwStartTarget <= pRecBuffer->GetSize())
      {
        DbgLog(( LOG_TRACE, 5, TEXT("removed seek from %08x to %08x"),
                 (ULONG)m_qwLastReadEnd,
                 (ULONG)rRecStart ));
        rRecStart = qwStartTarget;
      }
    }
  }
  else
  {
    // leave some room at the end.
    if(rRecStart > qwStartTarget &&
       rRecStart - qwStartTarget < m_cbRecord / 4 * 3)
    {
      if(rRecEnd - qwStartTarget <= pRecBuffer->GetSize() - m_dwAlign * 2)
      {
        DbgLog(( LOG_TRACE, 5, TEXT("removed seek from %08x to %08x"),
                 (ULONG)m_qwLastReadEnd,
                 (ULONG)rRecStart ));
        rRecStart = qwStartTarget;
      }
    }
  }

  // stuff whatever more we can into this buffer so they don't have to
  // rely on cache hits.
  for(;;)
  {
    BOOL fAttachedSample = FALSE;

    for(UINT iStream = 0; iStream < m_cStreams; iStream++)
    {
      hr = AttachSampleReq(
        pRecBuffer,
        iStream,
        rRecStart,
        rRecEnd);

      if(FAILED(hr))
          return hr;

      if(hr == S_OK)
        fAttachedSample = TRUE;

      ASSERT(SUCCEEDED(hr));
    }

    // no stream could contribute.
    if(!fAttachedSample)
      break;
  }

  return S_OK;
}

//
// process the first cache hit for this stream
//

HRESULT CImplReader_1::ProcessCacheHit(UINT iStream)
{
  ASSERT(CritCheckIn(&m_cs));

  HRESULT hr;
  CStreamInfo *pSi = m_rgpStreamInfo[iStream];

  SampleReq *pSampleReq = pSi->GetFirst(SampleReq::PENDING);
  if(!pSampleReq)
    return S_FALSE;

  CRecBuffer *pBuffer;
  hr = m_pRecCache->GetCacheHit(pSampleReq, &pBuffer);
  if(hr != S_OK)
    return S_FALSE;

  // this addref's the buffer
  pSampleReq->pSample->SetParent(pBuffer);

  pSampleReq->pSample->SetPointer(
    pBuffer->GetPointer(pSampleReq->fileOffset),
    pSampleReq->cbReq);

  DbgLog(( LOG_TRACE, 5, TEXT("cache hit stream %d, %08x"),
           iStream,
           (ULONG)pSampleReq->fileOffset));

  // remove our refcount from GetCacheHit, rely on the one from the
  // SetParent call
  pBuffer->Release();

  if(pBuffer->GetState() == CRecBuffer::PENDING)
  {
    // make SampleReq ISSUED.  m_cs is locked by the caller, so we
    // can safely let ProcessCompletedRead take care of the
    // SampleReq

    SampleReq *pSrHit = pSi->PromoteFirst(SampleReq::PENDING);
    ASSERT(pSrHit == pSampleReq);
  }
  else
  {
    // make SampleReq PENDING->ISSUED->COMPLETE. m_cs must be locked
    // by the caller.

    SampleReq *pSrHit = pSi->PromoteFirst(SampleReq::PENDING);
    pSrHit->hrError = S_OK;
    ASSERT(pSrHit == pSampleReq);

    // this complete occurs out of order
    pSi->PromoteIssued(pSrHit);
  }

  return S_OK;
}

HRESULT CImplReader_1::AttachSampleReq(
  CRecBuffer *pRecBuffer,
  UINT iStream,
  DWORDLONG &rRecStart,
  DWORDLONG &rRecEnd)
{
  if(ProcessCacheHit(iStream) == S_OK)
    return S_OK;

  CStreamInfo *pSi = m_rgpStreamInfo[iStream];
  SampleReq *pSampleReq;

  pSampleReq = pSi->GetFirst(SampleReq::PENDING);
  if(pSampleReq == 0)
    return S_FALSE;

  ASSERT(pSi->GetCState(SampleReq::PENDING) != 0);
  ASSERT(pSampleReq->cbReq <= pRecBuffer->GetSize());

  // will sample req fit into the record?
  if(rRecStart == 0 && rRecEnd == 0)
  {
    rRecStart = pSampleReq->fileOffset;
    rRecEnd = rRecStart + pSampleReq->cbReq;
    ASSERT(rRecEnd - rRecStart <= pRecBuffer->GetSize() - m_dwAlign);
  }
  else if(max((pSampleReq->fileOffset + pSampleReq->cbReq), rRecEnd ) -
          min((pSampleReq->fileOffset), rRecStart) <
          pRecBuffer->GetSize() - 2 * m_dwAlign)
  {
    rRecStart = min((pSampleReq->fileOffset), rRecStart);
    rRecEnd = max((pSampleReq->fileOffset + pSampleReq->cbReq), rRecEnd );
  }
  else
  {
    pSampleReq = 0;
  }

  if(pSampleReq != 0)
  {
    // this samplereq fit.
    SampleReq *pSampleReq2 = pSi->PromoteFirst(SampleReq::PENDING);
    ASSERT(pSampleReq2 == pSampleReq);

    if(!pRecBuffer->sampleReqList.AddTail(pSampleReq))
        return E_OUTOFMEMORY;
    
    pSampleReq->pSample->SetParent(pRecBuffer);

    DbgLog(( LOG_TRACE, 15,
             TEXT("CImplReader_1::AttachSampleReq attached %08x, stream %d" ),
             (ULONG)pSampleReq->fileOffset, iStream));

    return S_OK;
  }
  else
  {
    return S_FALSE;
  }
}

// ------------------------------------------------------------------------


CImplReader_1::CStreamInfo::CStreamInfo(
  StreamBufParam *pSbp,
  HRESULT *phr) :
        m_cMaxReqs(pSbp->cSamplesMax),
        m_lstFree(NAME("parser free list"), m_cMaxReqs),
        m_lstPending(NAME("parser pending list"), m_cMaxReqs),
        m_lstIssued(NAME("parser issued list"), m_cMaxReqs),
        m_lstComplete(NAME("parser complete list"), m_cMaxReqs),
        m_rgSampleReq(0)
{
  m_sbp.pAllocator = 0;
  m_bFlushing = FALSE;
  m_bFirstSampleQueued = FALSE;
  m_hsCompletedReq = 0;

  if(FAILED(*phr))
    return;

  m_sbp = *pSbp;
  pSbp->pAllocator->AddRef();

  m_rgSampleReq = new SampleReq[m_cMaxReqs];
  if(m_rgSampleReq == 0)
  {
    *phr = E_OUTOFMEMORY;
    return;
  }

  m_bFlushing = FALSE;
  m_hsCompletedReq = CreateSemaphore(
    0,                          // lpSemaphoreAttributes
    0,                          // lInitialCount
    m_cMaxReqs,                 // lMaximumCount
    0);                         // lpName
  if(m_hsCompletedReq == 0)
  {
    *phr = AmHresultFromWin32(GetLastError());
    return;
  }

  // no list operations should allocate memory because we never exceed
  // the number of elements with which the list was initialized --
  // don't check failures. we have to build the node cache now to
  // accomplish this
  for(unsigned iReq = 0; iReq < m_cMaxReqs; iReq++)
  {
    m_rgSampleReq[iReq].state = SampleReq::FREE;

    if(!(m_lstFree.AddHead(&m_rgSampleReq[iReq]) &&
         m_lstPending.AddHead((SampleReq *)0) &&
         m_lstIssued.AddHead((SampleReq *)0) &&
         m_lstComplete.AddHead((SampleReq *)0)))
    {
      *phr = E_OUTOFMEMORY;
      return;
    }
  }

  m_lstPending.RemoveAll();
  m_lstIssued.RemoveAll();
  m_lstComplete.RemoveAll();

  m_rgpLsts[SampleReq::FREE] = &m_lstFree;
  m_rgpLsts[SampleReq::PENDING] = &m_lstPending;
  m_rgpLsts[SampleReq::ISSUED] = &m_lstIssued;
  m_rgpLsts[SampleReq::COMPLETE] = &m_lstComplete;

  DbgValidateLists();
}

CImplReader_1::CStreamInfo::~CStreamInfo()
{
  DbgValidateLists();

  ASSERT(m_lstFree.GetCount() == (LONG)m_cMaxReqs);

#ifdef DEBUG
  for(unsigned iReq = 0; iReq < m_cMaxReqs; iReq ++)
    ASSERT(m_rgSampleReq[iReq].state == SampleReq::FREE);
#endif

  delete[] m_rgSampleReq;

  CloseHandle(m_hsCompletedReq);

  if(m_sbp.pAllocator)
      m_sbp.pAllocator->Release();
}

SampleReq *CImplReader_1::CStreamInfo::PromoteFirst(SampleReq::State state)
{
  CAutoLock lock(&m_cs);
  DbgValidateLists();

  ASSERT(state == SampleReq::PENDING || state == SampleReq::FREE);

  SampleReq *pSampleReq = m_rgpLsts[state]->RemoveHead();
  if(pSampleReq)
  {
      m_rgpLsts[state + 1]->AddTail(pSampleReq);
      PromoteState(pSampleReq->state);
  }
  
  return pSampleReq;
}



HRESULT CImplReader_1::CStreamInfo::PromoteFirstComplete(
  IMediaSample **ppSample, HRESULT *phrError)
{
  *ppSample = 0;
  *phrError = E_FAIL;

  CAutoLock lock(&m_cs);

  DbgValidateLists();
  
  SampleReq *pSampleReq = m_lstComplete.RemoveHead();
  if(pSampleReq)
  {
    EXECUTE_ASSERT(WaitForSingleObject(m_hsCompletedReq, 0) == WAIT_OBJECT_0);

    DbgLog(( LOG_TRACE, 10,
             TEXT("PromoteFirstComplete: promoted %x sem %08x"),
             pSampleReq, m_hsCompletedReq));

    m_lstFree.AddTail(pSampleReq);
    pSampleReq->state = SampleReq::FREE;

    if(FAILED(pSampleReq->hrError))
    {
        pSampleReq->pSample->Release();
        *ppSample = 0;
    }
    else
    {
        *ppSample = pSampleReq->pSample;
    }
    *phrError = pSampleReq->hrError;
  }
  else
  {
    return VFW_E_TIMEOUT;
  }

  DbgValidateLists();

  return S_OK;
}

// wait for all issued reads
HRESULT CImplReader_1::CStreamInfo::FlushIC()
{
  while(get_c_i_and_c() > 0)
  {
    IMediaSample *pSample;
    HRESULT hrSample;
    HRESULT hr = PromoteFirstComplete(&pSample, &hrSample);

    if(SUCCEEDED(hr) && SUCCEEDED(hrSample))
      ASSERT(pSample);

    if(pSample)
      pSample->Release();
  }

  return S_OK;
}

// mark issued reqs complete. only do this if it's the first in the
// list because we want things to complete in order. when the first
// one is completed, completed reads after it are moved to the
// completed queue. things marked with fOooOk are moved out of order.

HRESULT CImplReader_1::CStreamInfo::PromoteIssued(SampleReq *pSampleReq)
{
  CAutoLock lock(&m_cs);
  ASSERT(pSampleReq->state == SampleReq::ISSUED);

  SampleReq *psrFirstIssued = m_lstIssued.GetHead();
  ASSERT(pSampleReq->stream == psrFirstIssued->stream);

  pSampleReq->state = SampleReq::COMPLETE;

  if(psrFirstIssued != pSampleReq && !pSampleReq->fOooOk)
  {
    // not first and must be completed in order.
    DbgLog(( LOG_TRACE, 10,
             TEXT("PromoteIssued: completed %08x ooo"), pSampleReq));
    return S_FALSE;
  }
  else if(pSampleReq->fOooOk)
  {
    POSITION posOoo = m_lstIssued.Find(pSampleReq); // linear search
    ASSERT(posOoo);
    m_lstIssued.Remove(posOoo);
    m_lstComplete.AddHead(pSampleReq);

    long lPrevCount = -1;
    EXECUTE_ASSERT(ReleaseSemaphore(m_hsCompletedReq, 1, &lPrevCount));
    DbgLog(( LOG_TRACE, 10,
             TEXT("PromoteIssued: completed ooo %08x on %d sem %08x = %d"),
             pSampleReq, pSampleReq->stream, m_hsCompletedReq, lPrevCount + 1));

    
    return S_OK;
  }
  else
  {
    // first one completed

    do
    {
      // handle ooo issued nodes
      EXECUTE_ASSERT(psrFirstIssued == m_lstIssued.RemoveHead());
      
      m_lstComplete.AddTail(psrFirstIssued);

      long lPrevCount = -1;
      EXECUTE_ASSERT(ReleaseSemaphore(m_hsCompletedReq, 1, &lPrevCount));
      DbgLog(( LOG_TRACE, 10,
               TEXT("PromoteIssued: completed %08x on %d sem %08x = %d"),
               psrFirstIssued, pSampleReq->stream, m_hsCompletedReq, lPrevCount + 1));

      psrFirstIssued = m_lstIssued.GetHead();
      
    } while (psrFirstIssued &&
             psrFirstIssued->state == SampleReq::COMPLETE);

    return S_OK;
  }
}


SampleReq *CImplReader_1::CStreamInfo::GetFirst(SampleReq::State state)
{
  CAutoLock lock(&m_cs);
  DbgValidateLists();
  
  return m_rgpLsts[state]->GetHead();
}

void
CImplReader_1::CStreamInfo::PromoteState(
  SampleReq::State &rState)
{
  switch(rState)
  {
    case SampleReq::FREE:
      rState = SampleReq::PENDING;
      break;

    case SampleReq::PENDING:
      ASSERT(!m_bFlushing);
      rState = SampleReq::ISSUED;
      break;

    case SampleReq::ISSUED:
      rState = SampleReq::COMPLETE;
      break;

    case SampleReq::COMPLETE:
      rState = SampleReq::FREE;
      break;

    default:
      DbgBreak("invalid statew");
  }


  DbgValidateLists();
}

ULONG
CImplReader_1::CStreamInfo::GetCState(
  SampleReq::State state)
{
  return m_rgpLsts[state]->GetCount();
}

ULONG
CImplReader_1::CStreamInfo::get_c_i_and_c()
{
  CAutoLock lock(&m_cs);
  return GetCState(SampleReq::ISSUED) + GetCState(SampleReq::COMPLETE);
}

void CImplReader_1::CStreamInfo::CancelPending()
{
  CAutoLock lock(&m_cs);
  for(SampleReq *psr; psr = m_lstPending.RemoveHead();)
  {
    psr->state = SampleReq::FREE;
    psr->pSample->Release();
    psr->pSample = 0;
    m_lstFree.AddTail(psr);
  }

  DbgValidateLists();
}

// ------------------------------------------------------------------------
// should we go out of our way to read data for this stream (is it
// starved?)
BOOL
CImplReader_1::CStreamInfo::NeedsQueued()
{
  CAutoLock lock(&m_cs);

  ULONG c_i_and_c = GetCState(SampleReq::ISSUED) + GetCState(SampleReq::COMPLETE);

//   DbgLog((LOG_TRACE, 0x3f,
//           TEXT("CImplReader_1::NeedsQueued stream %x: %d samples downstream"),
//           this, m_pRecAllocator->CSamplesDownstream() ));

  return (m_sbp.pAllocator->CSamplesDownstream() == 0) &&
      (GetCState(SampleReq::PENDING) != 0) &&
       (c_i_and_c < 1);
}

BOOL
CImplReader_1::CStreamInfo::WantsQueued()
{
  CAutoLock lock(&m_cs);

  BOOL fRetVal = FALSE;

  // something to read. we want to issue reads for free samples too
  // because it may mean new reads could not be queued because the pin
  // is waiting for an index to come in.
  ULONG cPending = GetCState(SampleReq::PENDING);
  ULONG cPendingOrFree = cPending + GetCState(SampleReq::FREE);

  if(cPending == 0)
    fRetVal = FALSE;
  else if(cPendingOrFree >= m_cMaxReqs / 4)
    fRetVal = TRUE;
  else if(m_fStreamEnd)
    fRetVal = TRUE;

  return fRetVal;
}

// output something like this
// AVIRDR.DLL(tid dd) : : 222222222222222221111111111111111
// AVIRDR.DLL(tid dd) : : p: 17,47, i: 0,17, c: 0,0, f: 0,0
//
#ifdef DEBUG

void CImplReader_1::CStreamInfo::Dbg_Dump(
  int iStream, 
  TCHAR *sz)
{

  CAutoLock lock(&m_cs);

  static const char rgc[] = "fpic";

  TCHAR szDbg[1024];
  TCHAR *pch = szDbg;
  for(unsigned i = 0; i < m_cMaxReqs; i++)
    *pch++ = rgc[m_rgSampleReq[i].state];
  *pch = 0;

  DbgLog(( LOG_TRACE, 5, TEXT("%02x, %20.20s: %s"), iStream, sz, szDbg));
  DbgLog(( LOG_TRACE, 5,
           TEXT("%s: p: %2i, i: %2i c: %2i, f: %2i"), sz,
           GetCState(SampleReq::PENDING),
           GetCState(SampleReq::ISSUED),
           GetCState(SampleReq::COMPLETE),
           GetCState(SampleReq::FREE)));
}

void CImplReader_1::CStreamInfo::DbgValidateLists()
{
  CAutoLock lock(&m_cs);

  ASSERT(m_lstFree.GetCount() + m_lstPending.GetCount() +       
         m_lstIssued.GetCount() + m_lstComplete.GetCount() ==   
         (LONG)m_cMaxReqs);

  for(int i = 0; i < 4; i++)
  {
    CGenericList<SampleReq> *pLst = m_rgpLsts[i];

    for(POSITION pos = pLst->GetHeadPosition();
        pos;
        pos = pLst->Next(pos))
    {
      if(i == SampleReq::ISSUED)
      {
        ASSERT(pLst->Get(pos)->state == i ||
               pLst->Get(pos)->state == i + 1);
      }
      else
      {
        ASSERT(pLst->Get(pos)->state == i);
      }
    }
  }
}

#endif // DEBUG



void CImplReader_1::CStreamInfo::Reset()
{
#ifdef DEBUG
  CAutoLock lock(&m_cs);

  ASSERT(GetCState(SampleReq::FREE) == m_cMaxReqs);

  DbgValidateLists();
#endif
}

void CImplReader_1::CStreamInfo::Start()
{
  ASSERT(GetCState(SampleReq::COMPLETE) == 0);
  ASSERT(GetCState(SampleReq::ISSUED) == 0);
  ASSERT(GetCState(SampleReq::PENDING) == 0);
  ASSERT(GetCState(SampleReq::FREE) == m_cMaxReqs);

  m_fStreamEnd = FALSE;
}

void CImplReader_1::CStreamInfo::MarkStreamEnd()
{
  m_fStreamEnd = TRUE;
}

void CImplReader_1::FreeAndReset()
{
  if(m_pRecCache)
    m_pRecCache->Release();
  m_pRecCache = 0;

  ASSERT(!m_fFileOpen);
  m_fFileOpen = FALSE;

  m_dwAlign = 0;

  if(m_pAsyncReader)
    m_pAsyncReader->Release();
  m_pAsyncReader = 0;

  if(m_rgpStreamInfo != 0)
    for(unsigned i = 0; i < m_cStreams; i++)
      delete m_rgpStreamInfo[i];
  delete[] m_rgpStreamInfo;
  m_rgpStreamInfo = 0;

  ASSERT(m_ilcPendingReads == 0);
  m_ilcPendingReads = 0;

  m_fFileOpen = FALSE;
  m_cStreams = 0;
  m_bInitialized = FALSE;
  m_bFlushing = FALSE;
  m_cRecords = 0;
}

// // ------------------------------------------------------------------------

// CAlignedMemObject::CAlignedMemObject(ULONG cbData, ULONG cbAlign)
// {
//   m_pbAllocated = new BYTE[cbData + 2 * cbAlign];
//   m_pbAlign = m_pbAllocated;
//   ULONG remainder = (DWORD)m_pbAlign % cbAlign;
//   if(remainder != 0)
//     m_pbAlign += cbAlign - remainder;
//   ASSERT((DWORD)m_pbAlign % cbAlign == 0);

//   m_pbData = 0;
// }

CImplReader_1Worker::CImplReader_1Worker()
{
}

BOOL CImplReader_1Worker::Create(CImplReader_1 *pReader)
{
  CAutoLock lock(&m_AccessLock);
  m_pReader = pReader;
  return CAMThread::Create();
}

HRESULT CImplReader_1Worker::Run()
{
   return CallWorker(CMD_RUN);
}

HRESULT CImplReader_1Worker::Stop()
{
   return CallWorker(CMD_STOP);
}

HRESULT CImplReader_1Worker::Exit()
{
   CAutoLock lock(&m_AccessLock);

   HRESULT hr = CallWorker(CMD_EXIT);
   if (FAILED(hr))
      return hr;

   // wait for thread completion and then close handle (and clear so
   // we can start another later)
   //
   Close();

   return NOERROR;
}

// called on the worker thread to do all the work. Thread exits when this
// function returns.
//
DWORD CImplReader_1Worker::ThreadProc()
{
    BOOL bExit = FALSE;
    while (!bExit)
    {
       Command cmd = GetRequest();
       switch (cmd)
       {
       case CMD_EXIT:
           bExit = TRUE;
           Reply(NOERROR);
           break;

       case CMD_RUN:
           Reply(NOERROR);
           DoRunLoop();
           break;

       case CMD_STOP:
           Reply(NOERROR);
           break;

       default:
           Reply(E_NOTIMPL);
           break;
       }
    }

    return NOERROR;
}

void CImplReader_1Worker::DoRunLoop(void)
{
  HRESULT hr;
  for(;;)
  {
    IMediaSample *pSample = 0;
    DWORD_PTR dwUser = 0;
    HRESULT hrDiskError = S_OK;

    if(m_pReader->m_bFlushing && m_pReader->m_ilcPendingReads == 0)
    {
      // the IAsyncReader lets us block even though we are flushing.
      DbgLog(( LOG_TRACE, 5,
               TEXT("CImplReader_1Worker::DoRunLoop: flushing, 0 pending")));
      break;
    }

    hr = m_pReader->m_pAsyncReader->WaitForNext(INFINITE, &pSample, &dwUser);

    // we clear reads in a controlled way. so this only happens when
    // we call BeginFlush
    if(pSample == 0 || dwUser == 0)
    {
      break;
    }

    EXECUTE_ASSERT(InterlockedDecrement(&m_pReader->m_ilcPendingReads) >= 0);

    if(hr != S_OK)
    {
      // source filter might have notified the graph when it detected
      // an error. the error can be a disk error or a timeout if we
      // are stopping

      DbgLog(( LOG_TRACE, 5,
               TEXT("CImplReader_1Worker::loop: disk error %08x."), hr ));

      // short file?
      if(SUCCEEDED(hr))
        hr = VFW_E_INVALID_FILE_FORMAT;

      hrDiskError = hr;
    }

    {
      // necessary to keep from accessing the cache simultaneously
      // with IssueRead
      CAutoLock lock(&m_pReader->m_cs);

      // buffer has addref for us from Request() call
      CRecBuffer *pRecBuffer = (CRecBuffer *)dwUser;

      if(hrDiskError == S_OK)
      {
        REFERENCE_TIME tStart, tStop;
        if(pSample->GetTime(&tStart, &tStop) == S_OK)
        {
          m_pReader->m_qwEndLastCompletedRead = tStop / UNITS;
          MSR_INTEGER(m_pReader->m_perfidDisk, -(long)(tStart / UNITS));
        }
      }

      // !!! invalid assertion. indicates read completed out of order
      // ASSERT(!!!pRecBuffer->m_fWaitingOnBuffer);

      pRecBuffer->m_fReadComplete = TRUE;
      DbgLog(( LOG_TRACE, 5,
               TEXT("CImplReader_1Worker::loop: buffer %08x came in"),
               pRecBuffer));

      // inner dependent buffer chain loop
      for(;;)
      {
        if(!pRecBuffer->m_fReadComplete)
          break;

        hr = m_pReader->ProcessCompletedBuffer(pRecBuffer, hrDiskError);
        ASSERT(SUCCEEDED(hr));

        CRecBuffer *pDestBuffer = pRecBuffer->m_overlap.pBuffer;
        pRecBuffer->m_overlap.pBuffer = 0;

        if(pDestBuffer == 0)
        {
          pRecBuffer->Release();
          break;
        }

        // remove source buffer's ref count on the destination
        // buffer. since the destination buffer must have samples, its
        // refcount must be > 0
        EXECUTE_ASSERT(pDestBuffer->Release() > 0);

        DbgLog(( LOG_TRACE, 5,
                 TEXT("CImplReader_1Worker::loop: csrc= %08x cb=%08x  to %08x@%08x"),
                 pRecBuffer,
                 pRecBuffer->m_overlap.cbOverlap,
                 pDestBuffer->GetPointer(pRecBuffer->m_overlap.qwOverlapOffset),
                 pDestBuffer ));

        CopyMemory(
          pDestBuffer->GetPointer(pRecBuffer->m_overlap.qwOverlapOffset),
          pRecBuffer->GetPointer(pRecBuffer->m_overlap.qwOverlapOffset),
          pRecBuffer->m_overlap.cbOverlap);

        pRecBuffer->Release();

        pDestBuffer->m_fWaitingOnBuffer = FALSE;

        // ASSERT(!!!pDestBuffer->m_overlap.pBuffer); // temporary

        // buffer will be processed when what it's waiting for completes
        if(!pDestBuffer->m_fReadComplete)
          break;

        // need to process buffer now
        pRecBuffer = pDestBuffer;
        pRecBuffer->AddRef();   // loop wants addrefd buffer.
        continue;
      } // inner dependent buffer chain loop
    } // critsec

    Command com;
    if (CheckRequest(&com))
    {
      // if it's a run command, then we're already running, so
      // eat it now.
      if (com == CMD_RUN)
      {
        GetRequest();
        Reply(NOERROR);
      }
      else if(com == CMD_STOP)
      {
        // continue processing requests until all queued reads return
        ASSERT(m_pReader->m_bFlushing);
        continue;
      }
      else
      {
        break;
      }
    }
  }

  // this assert introduces a race condition
  // ASSERT(m_pReader->m_ilcPendingReads == 0);
  DbgLog((LOG_TRACE,2,
          TEXT("CImplReader_1Worker::DoRunLoop: Leaving streaming loop")));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\core\msreader\reccache.h ===
// Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved.
#ifndef _reccache_h
#define _reccache_h

#include "reader.h"

class CRecCache;

class CRecBuffer
{
public:
  enum State {
    INVALID,                    // uninitialized
    PENDING,                    // waiting on disk
    VALID_ACTIVE,               // valid w/ refcounts
    VALID_INACTIVE };           // valid w/ no refcounts

  CRecBuffer(
    CRecCache *pParentCache,
    ULONG cbBuffer,
    BYTE *pb,
    HRESULT *phr,
    int stream = -1);

  void SetPointer(BYTE *pb);

  ~CRecBuffer();

  void Reset();

  BYTE *operator()() { return m_pbAligned; }
  BYTE *GetPointer(DWORDLONG fileOffset);

  // this sample is used for the read request 
  CMediaSample m_sample;
  
  DWORDLONG m_fileOffsetValid;
  ULONG m_cbValid;
  HRESULT m_hrRead;

  // list of sample reqs; valid only while the buffer is in state
  // PENDING
  CGenericList<SampleReq> sampleReqList;

  ULONG AddRef();
  ULONG Release();
  ULONG GetSize() { return m_cbReported; }

  void MarkPending();
  void MarkValid();
  void MarkValidWithFileError();

  State GetState() { return m_state; }

  // restriction: this buffer may overlap with only one other
  // buffer. this is not necessarily the case with reserve buffers,
  // and this causes extra seeks and reads. a better thing to do: give
  // sample requests a list of buffers on which they wait.
  struct Overlap
  {
    // buffer waiting on this one.
    class CRecBuffer *pBuffer;

    DWORDLONG qwOverlapOffset;
    ULONG cbOverlap;
  } m_overlap;

  BOOL m_fWaitingOnBuffer;
  BOOL m_fReadComplete;

private:

  // memory associated w/ this buffer, allocated elsewhere
  BYTE *m_pbAligned;

  // memory reported, adjusted for alignment
  ULONG m_cbReported;

  CRecCache *m_pParentCache;

  State m_state;

  long m_cRef;

  // stream # for reserve buffers -1 means not associated with stream
  int m_stream;

  // needed to remove from the active buffer list in constant time.
  POSITION m_posSortedList;

  void ResetPointer(BYTE *pb);

  friend class CRecCache;
};

class CRecCache :
  public CBaseAllocator
{

public:
  CRecCache(HRESULT *phr);
  ~CRecCache();

  HRESULT Configure(
    UINT CRecBuffers,
    ULONG cbBuffer,
    ULONG cbAlign,
    UINT cStreams,
    ULONG *rgStreamSize);

  HRESULT GetBuffer(CRecBuffer **ppRecBuffer);

  HRESULT GetReserveBuffer(
    CRecBuffer **ppRecBuffer,
    UINT stream);
  
  // put RecBuffer on free list on final release
  ULONG ReleaseBuffer(
    CRecBuffer *pRecBuffer);

  // return the AddRef'd buffer which can contain the SampleReq. mark
  // the buffer Active. S_FALSE: cache miss
  HRESULT GetCacheHit(
    SampleReq *pSampleReq,      /* [in] */
    CRecBuffer **ppBuffer);     /* [out] */

  // return the AddRef'd buffer which contains or will contain
  // overlapping sector. S_FALSE on cache miss
  HRESULT GetOverlappedCacheHit(
    DWORDLONG filePos,
    ULONG cbData,
    CRecBuffer **ppBuffer);     /* [out] */

  HRESULT BufferMarkPending(
    CRecBuffer *pBuffer);

  HRESULT NotifyExternalMemory(IAMDevMemoryAllocator *pDevMem);

  STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);

private:

  CRecBuffer *LocateBuffer(
    CGenericList<CRecBuffer> *pList,
    DWORDLONG qwFileOffset,
    ULONG cbBuffer);

  void MakeActive(CRecBuffer *pBuffer);

  void InvalidateCache();

  struct PerStreamBuffer
  {
    CRecBuffer *pBuffer;
  };

  PerStreamBuffer *m_rgPerStreamBuffer;
  UINT m_cStreams;

  // buffers with no refcounts (fifo)
  CGenericList<CRecBuffer> m_lFreeBuffers;

  // initial number of buffers in the free list (but not in the
  // reserve buffer pool)
  ULONG m_cBuffers;

  // buffers that are valid. may be in both this and the free
  // list. really should be a balancing tree.
  CGenericList<CRecBuffer> m_lSortedBuffers;

  CCritSec m_cs;

  int m_idPerfBufferReleased;

  void FreeBuffer();
  IAMDevMemoryAllocator *m_pDevMem;
  IUnknown *m_pDevConInner;
  BYTE *m_pbAllBuffers;

private:

  // CBaseAllocator overrides
  void Free(void);

  STDMETHODIMP SetProperties(
    ALLOCATOR_PROPERTIES* pRequest,
    ALLOCATOR_PROPERTIES* pActual);

};

#endif /* _reccache_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\core\msreader\reader.h ===
// Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)

// reader.h. IMultiStreamReader definition: asynchronous buffering
// implementations optimized to read files with multiple streams
// (sequential access, random access, interleaved and uninterleaved)

#ifndef _Reader_H
#define _Reader_H

#include "alloc.h"

class CRecCache;
class CRecSample;
class IMultiStreamReader;

// SampleRequest - information kept while a sample is active.
struct SampleReq
{
  enum State { FREE = 0, PENDING, ISSUED, COMPLETE, C_STATES };
  State state;

  // sample gotten from QueueReadSample
  CRecSample *pSample;

  // region in file this sample occupies
  DWORDLONG fileOffset;
  ULONG cbReq;

  // file error reading media saved here.
  HRESULT hrError;

  // stream to return sample to
  UINT stream;

  // ok to complete this sample out of order
  bool fOooOk;
};

// structure used to configure each stream
struct StreamBufParam
{
  ULONG cbSampleMax;            // largest sample this stream will see
  ULONG cSamplesMax;            /* max # active samples */
  class CRecAllocator *pAllocator;
};

HRESULT CreateMultiStreamReader(
  struct IAsyncReader *pAsyncReader,
  ULONG cStreams,
  StreamBufParam *rgStreamBufParam,
  ULONG cbRead,
  ULONG cBuffers,
  int iLeadingStream,
  IMultiStreamReader **ppReader);

// ------------------------------------------------------------------------
// IMultiStreamReader interface

class AM_NOVTABLE IMultiStreamReader
{
public:

  // succeed even if the file is not open
  virtual HRESULT Close() = 0;

  virtual HRESULT BeginFlush() = 0;
  virtual HRESULT EndFlush() = 0;

  // read sample in a stream. ERROR_NOT_ENOUGH_MEMORY means too many
  // pending requests. VFW_E_NOT_COMMITTED means someone pressed
  // "stop"
  virtual HRESULT QueueReadSample(
    DWORDLONG fileOffset,
    ULONG cbData,               // # bytes to read
    CRecSample *pSample,
    UINT stream,
    bool fOooOk = false) = 0;

  // get the next sample if available (returned in request
  // order). VFW_E_TIMEOUT or S_OK. VFW_E_NOT_COMMITTED means someone
  // pressed "stop"
  virtual HRESULT PollForSample(
    IMediaSample **ppSample,    // may be 0
    UINT stream) = 0;

  virtual HRESULT WaitForSample(UINT stream) = 0;

  virtual HRESULT MarkStreamEnd(UINT stream) = 0;
  virtual HRESULT MarkStreamRestart(UINT stream) = 0;

  // discard pending requests. blocks.
  virtual HRESULT ClearPending(
    UINT stream) = 0;

  // read/copy non-stream data into supplied buffer.
  virtual HRESULT SynchronousRead(
    BYTE *pMem,
    DWORDLONG fileOffset,
    ULONG cbData) = 0;

  virtual HRESULT Start() = 0;

  virtual HRESULT NotifyExternalMemory(
      IAMDevMemoryAllocator *pDevMem) = 0;

  virtual ~IMultiStreamReader() { }
};

// ------------------------------------------------------------------------
// implementation of IMultiStreamReader with internal cache, coalesced
// reads

// arbitrary limit.
const UINT C_STREAMS_MAX = 0x80;

class CImplReader_1Worker : public CAMThread
{
private:
  class CImplReader_1 *m_pReader;
  enum Command
  {
    CMD_RUN,
    CMD_STOP,
    CMD_EXIT
  };

  Command GetRequest()
  {
    return (Command) CAMThread::GetRequest();
  }

  BOOL CheckRequest(Command * pCom)
  {
    return CAMThread::CheckRequest((DWORD *)pCom);
  }

  void DoRunLoop(void);

public:

  CImplReader_1Worker();

  // actually create the stream and bind it to a thread
  BOOL Create(CImplReader_1 *pReader);

  // the thread executes this function, then exits
  DWORD ThreadProc();

  // commands we can give the thread
  HRESULT Run();
  HRESULT Stop();
  HRESULT Exit();
};

class CImplReader_1 : public IMultiStreamReader
{
public:

  CImplReader_1(
    IAsyncReader *pAsyncReader,
    UINT cStreams,
    StreamBufParam *rgStreamBufParam,
    ULONG cbRead,
    ULONG cBuffers,
    int iLeadingStream,
    CRecCache *pRecCache,
    HRESULT *phr);

  ~CImplReader_1();

  HRESULT Close();

  HRESULT Start();

  HRESULT BeginFlush();

  HRESULT EndFlush();

  HRESULT QueueReadSample(
    DWORDLONG fileOffset,
    ULONG cbData,
    CRecSample *pSample,
    UINT stream,
    bool fOooOk);

  HRESULT PollForSample(
    IMediaSample **ppSample,
    UINT stream);

  HRESULT WaitForSample(UINT stream);

  HRESULT MarkStreamEnd(UINT stream);
  HRESULT MarkStreamRestart(UINT stream);

  HRESULT ClearPending(
    UINT stream);

  HRESULT SynchronousRead(
    BYTE *pb,
    DWORDLONG fileOffset,
    ULONG cbData);

  HRESULT ProcessCompletedBuffer(
    class CRecBuffer *pRecBuffer,
    HRESULT hrDiskError);

  HRESULT NotifyExternalMemory(IAMDevMemoryAllocator *pDevMem);

private:

  BOOL m_bInitialized;

  BOOL m_bFlushing;

  UINT m_cStreams;
  UINT m_cRecords;              // # records
  ULONG m_cbRecord;

  // for interleaved files, if we have one stream that leads (eg audio
  // in avi files). -1 o/w
  int m_iLeadingStream;
  int m_iLeadingStreamSaved;
  BOOL IsInterleavedMode() { return m_iLeadingStream >= 0; }

  long m_ilcPendingReads;

  LONGLONG m_llFileLength;

  //
  // CStreamInfo. manipulates lists of SampleReq's. requests start off
  // on the the free list. as the parser thread requests data, it's
  // put on the pending queue. when there are enough pending requests
  // to make a disk read worthwhile, they are put on the issued
  // queue. when the disk read completes, they go on the completed
  // queue.
  //
  class CStreamInfo
  {
  public:

    CStreamInfo(StreamBufParam *pSbp, HRESULT *phr);
    ~CStreamInfo();

    // make a free node pending, a pending node issued
    SampleReq *PromoteFirst(SampleReq::State state);

    // return the first one w/o promoting it
    SampleReq *GetFirst(SampleReq::State state);

    HRESULT PromoteFirstComplete(
      IMediaSample **ppSample,
      HRESULT *phrError);

    // wait for all issued reads to complete
    HRESULT FlushIC();

    // put Issued reads on the completed queue (and handle those that
    // can't be handled out of order)
    HRESULT PromoteIssued(SampleReq *pSampleReq);

    void CancelPending();

    // count of SampleReqs in state state
    inline ULONG GetCState(SampleReq::State state);

    // count of issued + completed (atomic)
    ULONG get_c_i_and_c();

    // no-op in retail builds
    inline void Reset();

    void Start();

    void MarkStreamEnd();
    void MarkStreamRestart() { m_fStreamEnd = FALSE; }
    BOOL GetStreamEnd() { return m_fStreamEnd; }

    ULONG GetCbLargestSample() { return m_sbp.cbSampleMax; }
    BOOL NeedsQueued();
    BOOL WantsQueued();

    HANDLE GetSampleReleasedHandle() {
        return m_sbp.pAllocator->hGetDownstreamSampleReleased();
    }

#ifdef DEBUG
    void Dbg_Dump(int iStream, TCHAR *psz);
    void DbgValidateLists();
#else
    inline void Dbg_Dump(int iStream, TCHAR *psz) {; }
    inline void DbgValidateLists() {; }
#endif

    BOOL m_bFlushing;

    // at least one sample queued on this stream
    BOOL m_bFirstSampleQueued;

    HANDLE m_hsCompletedReq;
    CCritSec m_cs;              // !!! per stream cs not needed

  private:

    void IncrementIReq(ULONG &riReq);
    void PromoteState(SampleReq::State &rState);

    StreamBufParam m_sbp;
    ULONG m_cMaxReqs;

    SampleReq *m_rgSampleReq;

    CGenericList<SampleReq> m_lstFree;
    CGenericList<SampleReq> m_lstPending;
    CGenericList<SampleReq> m_lstIssued;
    CGenericList<SampleReq> m_lstComplete;

    CGenericList<SampleReq>* m_rgpLsts[SampleReq::C_STATES];

    BOOL m_fStreamEnd;

  } **m_rgpStreamInfo;


  // does not lock. returns immediately
  HRESULT CheckIssueRead();

  // process cache hits. does not lock. returns immediately
  HRESULT ProcessCacheHit(UINT iStream);

  // called with starved stream and empty buffer
  HRESULT StuffBuffer(
    class CRecBuffer *pRecBuffer,
    UINT iStream,
    DWORDLONG &rRecStart,
    DWORDLONG &rRecEnd);

  // called with starved stream and empty buffer
  HRESULT StuffReserveBuffer(
    class CRecBuffer *pRecBuffer,
    UINT iStream,
    DWORDLONG &rRecStart,
    DWORDLONG &rRecEnd);

  HRESULT AttachSampleReq(
    class CRecBuffer *pRecBuffer,
    UINT iStream,
    DWORDLONG &rRecStart,
    DWORDLONG &rRecEnd);

  HRESULT IssueRead(
    class CRecBuffer *pRecBuffer,
    DWORDLONG recStart,
    DWORDLONG recEnd);

  void FreeAndReset();

  // thread that processes completed reads
  CImplReader_1Worker m_workerRead;

  // end of last read issued. used to avoid issuing non-contiguous
  // reads by filling in holes
  DWORDLONG m_qwLastReadEnd;

  // end of last read completed successfully. when stopping, the file
  // source times out pending reads. may cause us to seek unless we
  // track that here.
  DWORDLONG m_qwEndLastCompletedRead;

  // file info
  struct IAsyncReader *m_pAsyncReader;
  DWORD m_dwAlign;

  BOOL m_fFileOpen;

  // helpers
  ULONG AlignUp(ULONG x);
  ULONG AlignDown(ULONG x);

  CRecCache *m_pRecCache;

  CCritSec m_cs;

  friend class CImplReader_1Worker;

#ifdef PERF
  int m_perfidDisk;
  int m_perfidSeeked;
#endif /* PERF */
};

#endif // _Reader_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\core\multfile\multfile.h ===
// Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.

// CLSID_MultFile,
// {D51BD5A3-7548-11cf-A520-0080C77EF58A}
DEFINE_GUID(CLSID_MultFile,
0xd51bd5a3, 0x7548, 0x11cf, 0xa5, 0x20, 0x0, 0x80, 0xc7, 0x7e, 0xf5, 0x8a);

//
// Quartz filter with fake output pin which supports IStreamBuilder to render
// lots of separate files
//

// forward declarations

class CMultStream;     // owns a particular stream
class CMultFilter;     // overall container class

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// input pin. uses IAsyncReader and not IMemInputPin

class CReaderInPin : public CBasePin
{
protected:
    class CMultFilter* m_pFilter;

public:
    CReaderInPin(
		 class CMultFilter *pFilter,
		 CCritSec *pLock,
		 HRESULT *phr,
		 LPCWSTR pPinName);


    // CBasePin overrides
    HRESULT CheckMediaType(const CMediaType* mtOut);
    HRESULT CompleteConnect(IPin *pReceivePin);
    HRESULT BreakConnect();

    STDMETHODIMP BeginFlush(void) { return E_UNEXPECTED; }
    STDMETHODIMP EndFlush(void) { return E_UNEXPECTED; }
};

// CMultStream
// output pin, supports IPin, IStreamBuilder
//
// never actually connects, just provides a place for graph builder to
// look for an IStreamBuilder
//


class CMultStream : public CBaseOutputPin, public IStreamBuilder
{

public:

    CMultStream(
	TCHAR *pObjectName,
	HRESULT * phr,
	CMultFilter * pFilter,
	CCritSec *pLock,
	LPCWSTR wszPinName);

    ~CMultStream();

    // expose IMediaPosition via CImplPosition, rest via CBaseOutputPin
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);

    // IPin

    HRESULT GetMediaType(int iPosition,CMediaType* pt);

    // check if the pin can support this specific proposed type&format
    HRESULT CheckMediaType(const CMediaType*);

    // say how big our buffers should be and how many we want
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES *pProperties);



    STDMETHODIMP Render(IPin * ppinOut, IGraphBuilder * pGraph);

    // we can't back anything out....
    STDMETHODIMP Backout(IPin * ppinOut, IGraphBuilder * pGraph) { return E_NOTIMPL; };

    DECLARE_IUNKNOWN

private:

    CMultFilter * m_pFilter;
};

//
// CMultFilter represents an avifile
//
// responsible for
// -- finding file and enumerating streams
// -- giving access to individual streams within the file
// -- control of streaming
//

class CMultFilter : public CBaseFilter
{
public:

    // constructors etc
    CMultFilter(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CMultFilter();

    // create a new instance of this class
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    // pin enumerator calls this
    int GetPinCount();

    CBasePin * GetPin(int n);

private:

    friend class CMultStream;
    friend class CReaderInPin;

    CMultStream m_Output;
    CReaderInPin m_Input;

    CCritSec m_csLock;
    
public:
    IAsyncReader *m_pAsyncReader;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\core\simpread\simpread.cpp ===
// Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.


// Simple parser filter
//
// Positional information is supported by the pins, which expose IMediaPosition.
// upstream pins will use this to tell us the start/stop position and rate to
// use
//

#include <streams.h>
#include "simpread.h"

// ok to use this as it is not dereferenced
#pragma warning(disable:4355)


/* Implements the CSimpleReader public member functions */


// constructors etc
CSimpleReader::CSimpleReader(
    TCHAR *pName,
    LPUNKNOWN pUnk,
    REFCLSID refclsid,
    CCritSec *pLock,
    HRESULT *phr)
    : m_pLock(pLock),
      CBaseFilter(pName, pUnk, pLock, refclsid),
      m_Input(this, pLock, phr, L"Reader"),
      m_Output(NAME("Output pin"), phr, this, pLock, L"Out"),
      m_pAsyncReader(NULL)
{
}

CSimpleReader::~CSimpleReader()
{
}


// pin enumerator calls this
int CSimpleReader::GetPinCount() {
    // only expose output pin if we have a reader.
    return m_pAsyncReader ? 2 : 1;
};

// return a non-addrefed pointer to the CBasePin.
CBasePin *
CSimpleReader::GetPin(int n)
{
    if (n == 0)
	return &m_Input;

    if (n == 1)
	return &m_Output;
    
    return NULL;
}

HRESULT CSimpleReader::NotifyInputConnected(IAsyncReader *pAsyncReader)
{
    // these are reset when disconnected
    ASSERT(m_pAsyncReader == 0);

    // m_iStreamSeekingIfExposed = -1;

    // fail if any output pins are connected.
    if (m_Output.GetConnected()) {
	// !!! can't find a good error.
	return VFW_E_FILTER_ACTIVE;
    }

    // done here because CreateOutputPins uses m_pAsyncReader
    m_pAsyncReader = pAsyncReader;
    pAsyncReader->AddRef();

    HRESULT hr = ParseNewFile();

    if (FAILED(hr)) {
	m_pAsyncReader->Release();
	m_pAsyncReader = 0;
	return hr;
    }

    // set duration and length of stream
    m_Output.SetDuration(m_sLength, SampleToRefTime(m_sLength));
    
     // !!! anything else to set up here?
    
    return hr;
}

HRESULT CSimpleReader::NotifyInputDisconnected()
{
    if (m_pAsyncReader) {
	m_pAsyncReader->Release();
	m_pAsyncReader = 0;
    }

    // !!! disconnect output???

    return S_OK;
}


HRESULT CSimpleReader::SetOutputMediaType(const CMediaType* mtOut)
{
    m_Output.SetMediaType(mtOut);

    return S_OK;
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// input pin

CReaderInPin::CReaderInPin(CSimpleReader *pFilter,
			   CCritSec *pLock,
			   HRESULT *phr,
			   LPCWSTR pPinName) :
   CBasePin(NAME("in pin"), pFilter, pLock, phr, pPinName, PINDIR_INPUT)
{
    m_pFilter = pFilter;
}

CReaderInPin::~CReaderInPin()
{
}

HRESULT CReaderInPin::CheckMediaType(const CMediaType *mtOut)
{
    return m_pFilter->CheckMediaType(mtOut);
}

HRESULT CReaderInPin::CheckConnect(IPin * pPin)
{
    HRESULT hr;

    hr = CBasePin::CheckConnect(pPin);
    if (FAILED(hr))
	return hr;

    IAsyncReader *pAsyncReader = 0;
    hr = pPin->QueryInterface(IID_IAsyncReader, (void**)&pAsyncReader);
    if(SUCCEEDED(hr))
	pAsyncReader->Release();

    // E_NOINTERFACE is a reasonable error
    return hr;
}

// ------------------------------------------------------------------------
// calls the filter to parse the file and create the output pins.

HRESULT CReaderInPin::CompleteConnect(
  IPin *pReceivePin)
{
    HRESULT hr = CBasePin::CompleteConnect(pReceivePin);
    if(FAILED(hr))
	return hr;

    IAsyncReader *pAsyncReader = 0;
    hr = pReceivePin->QueryInterface(IID_IAsyncReader, (void**)&pAsyncReader);
    if(FAILED(hr))
	return hr;

    hr = m_pFilter->NotifyInputConnected(pAsyncReader);
    pAsyncReader->Release();

    return hr;
}

HRESULT CReaderInPin::BreakConnect()
{
    HRESULT hr = CBasePin::BreakConnect();
    if(FAILED(hr))
	return hr;

    return m_pFilter->NotifyInputDisconnected();
}

/* Implements the CReaderStream class */


CReaderStream::CReaderStream(
    TCHAR *pObjectName,
    HRESULT * phr,
    CSimpleReader * pFilter,
    CCritSec *pLock,
    LPCWSTR wszPinName)
    : CBaseOutputPin(pObjectName, pFilter, pLock, phr, wszPinName)
    , CSourceSeeking(NAME("source position"), (IPin*) this, phr, &m_WorkerLock)
    , m_pFilter(pFilter)
{
}

CReaderStream::~CReaderStream()
{
}

STDMETHODIMP
CReaderStream::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IMediaSeeking) {
	return GetInterface((IMediaSeeking *) this, ppv);
    } else {
	return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}


// IPin interfaces


// return default media type & format
HRESULT
CReaderStream::GetMediaType(int iPosition, CMediaType* pt)
{
    // check it is the single type they want
    if (iPosition<0) {
	return E_INVALIDARG;
    }
    if (iPosition>0) {
	return VFW_S_NO_MORE_ITEMS;
    }

    CopyMediaType(pt, &m_mt);

    return S_OK;
}

// check if the pin can support this specific proposed type&format
HRESULT
CReaderStream::CheckMediaType(const CMediaType* pt)
{
    // we support exactly the type specified in the file header, and
    // no other.

    if (m_mt == *pt) {
	return NOERROR;
    } else {
	return E_INVALIDARG;
    }
}

HRESULT
CReaderStream::DecideBufferSize(IMemAllocator * pAllocator,
			     ALLOCATOR_PROPERTIES *pProperties)
{
    ASSERT(pAllocator);
    ASSERT(pProperties);

    // !!! how do we decide how many to get ?
    pProperties->cBuffers = 4;

    pProperties->cbBuffer = m_pFilter->GetMaxSampleSize();

    // ask the allocator for these buffers
    ALLOCATOR_PROPERTIES Actual;
    HRESULT hr = pAllocator->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
	return hr;
    }

    return NOERROR;
}

// this pin has gone active. Start the thread pushing
HRESULT
CReaderStream::Active()
{
    // do nothing if not connected - its ok not to connect to
    // all pins of a source filter
    if (m_Connected == NULL) {
	return NOERROR;
    }

    HRESULT hr = CBaseOutputPin::Active();
    if (FAILED(hr)) {
	return hr;
    }


    // start the thread
    if (!ThreadExists()) {
	if (!Create()) {
	    return E_FAIL;
	}
    }

    return RunThread();
}

// pin has gone inactive. Stop and exit the worker thread
HRESULT
CReaderStream::Inactive()
{
    if (m_Connected == NULL) {
	return NOERROR;
    }

    HRESULT hr;
    if (ThreadExists()) {
	hr = StopThread();

	if (FAILED(hr)) {
	    return hr;
	}

	hr = ExitThread();
	if (FAILED(hr)) {
	    return hr;
	}
    }
    return CBaseOutputPin::Inactive();
}

#if 0  // MIDL and structs don't match well
STDMETHODIMP
CReaderStream::Notify(IBaseFilter * pSender, Quality q)
{
   // ??? Try to adjust the quality to avoid flooding/starving the
   // components downstream.
   //
   // ideas anyone?

   return E_NOTIMPL;  // We are (currently) NOT handling this
}
#endif

// worker thread stuff


BOOL
CReaderStream::Create()
{
    CAutoLock lock(&m_AccessLock);

    return CAMThread::Create();
}


HRESULT
CReaderStream::RunThread()
{
    return CallWorker(CMD_RUN);
}

HRESULT
CReaderStream::StopThread()
{
    return CallWorker(CMD_STOP);
}


HRESULT
CReaderStream::ExitThread()
{
    CAutoLock lock(&m_AccessLock);

    HRESULT hr = CallWorker(CMD_EXIT);
    if (FAILED(hr)) {
	return hr;
    }

    // wait for thread completion and then close
    // handle (and clear so we can start another later)
    Close();

    return NOERROR;
}


// called on the worker thread to do all the work. Thread exits when this
// function returns.
DWORD
CReaderStream::ThreadProc()
{

    BOOL bExit = FALSE;
    while (!bExit) {

	Command cmd = GetRequest();

	switch (cmd) {

	case CMD_EXIT:
	    bExit = TRUE;
	    Reply(NOERROR);
	    break;

	case CMD_RUN:
	    Reply(NOERROR);
	    DoRunLoop();
	    break;

	case CMD_STOP:
	    Reply(NOERROR);
	    break;

	default:
	    Reply(E_NOTIMPL);
	    break;
	}
    }
    return NOERROR;
}

void
CReaderStream::DoRunLoop(void)
{
    // snapshot start and stop times from the other thread
    CRefTime tStart, tStopAt;
    double dRate;
    LONG sStart;
    LONG sStopAt;

    while (TRUE) {

	// each time before re-entering the push loop, check for changes
	// in start, stop or rate. If start has not changed, pick up from the
	// same current position.
	{
	    CAutoLock lock(&m_WorkerLock);

	    tStart = Start();
	    tStopAt = Stop();
	    dRate = Rate();

	    sStart = m_pFilter->RefTimeToSample(tStart);
	    sStopAt = m_pFilter->RefTimeToSample(tStopAt);

	    // if the stream is temporally compressed, we need to start from
	    // the previous key frame and play from there. All samples until the
	    // actual start will be marked with negative times.
	    // we send tStart as time 0, and start from tCurrent which may be
	    // negative

	}

	LONG sCurrent = m_pFilter->StartFrom(sStart);

	// check we are not going over the end
	sStopAt = min(sStopAt, (LONG) m_pFilter->m_sLength-1);

	// set the variables checked by PushLoop - these can also be set
	// on the fly
	SetRateInternal(dRate);
	SetStopAt(sStopAt, tStopAt);
	ASSERT(sCurrent >= 0);

	// returns S_OK if reached end
	HRESULT hr = PushLoop(sCurrent, sStart, tStart, dRate);
	if (VFW_S_NO_MORE_ITEMS == hr) {

	    DbgLog((LOG_ERROR,1,TEXT("Sending EndOfStream")));
	    // all done
	    // reached end of stream - notify downstream
	    DeliverEndOfStream();
	
	    break;
	} else if (FAILED(hr)) {

	    // signal an error to the filter graph and stop

	    // This could be the error reported from GetBuffer when we
	    // are stopping. In that case, nothing is wrong, really
	    if (hr != VFW_E_NOT_COMMITTED) {
		DbgLog((LOG_ERROR,1,TEXT("PushLoop failed! hr=%lx"), hr));
		m_pFilter->NotifyEvent(EC_ERRORABORT, hr, 0);

		DeliverEndOfStream();
	    } else {
		DbgLog((LOG_TRACE,1,TEXT("PushLoop failed! But I don't care")));
	    }

	    break;
	} else if(hr == S_OK) {
	    // not my error to report. or someone wants to stop. queitly
	    // exit.
	    break;
	} // else S_FALSE - go round again

	Command com;
	if (CheckRequest(&com)) {
	    // if it's a run command, then we're already running, so
	    // eat it now.
	    if (com == CMD_RUN) {
		GetRequest();
		Reply(NOERROR);
	    } else {
		break;
	    }
	}
    }

    DbgLog((LOG_TRACE,1,TEXT("Leaving streaming loop")));
}


// return S_OK if reach sStop, S_FALSE if pos changed, or else error
HRESULT
CReaderStream::PushLoop(
    LONG sCurrent,
    LONG sStart,
    CRefTime tStart,
    double dRate
    )
{
    DbgLog((LOG_TRACE,1,TEXT("Entering streaming loop: start = %d, stop=%d"),
	    sCurrent, GetStopAt()));

    LONG sFirst = sCurrent; // remember the first thing we're sending

    // since we are starting on a new segment, notify the downstream pin
    DeliverNewSegment(tStart, GetStopTime(), GetRate());


    // we send one sample at m_sStopAt, but we set the time stamp such that
    // it won't get rendered except for media types that understand static
    // rendering (eg video). This means that play from 10 to 10 does the right
    // thing (completing, with frame 10 visible and no audio).

    while (sCurrent <= GetStopAt()) {

	DWORD sCount;

	// get a buffer
	DbgLog((LOG_TRACE,5,TEXT("Getting buffer...")));

	IMediaSample *pSample;
	HRESULT hr = GetDeliveryBuffer(&pSample, NULL, NULL, 0);

	if (FAILED(hr)) {
	    DbgLog((LOG_ERROR,1,TEXT("Error %lx getting delivery buffer"), hr));
	    return hr;
	}

	DbgLog((LOG_TRACE,5,TEXT("Got buffer, size=%d"), pSample->GetSize()));

	// mark sample as preroll or not....
	pSample->SetPreroll(sCurrent < sStart);
	
	// If this is the first thing we're sending, it is discontinuous
	// from the last thing they received.
	if (sCurrent == sFirst)
	    pSample->SetDiscontinuity(TRUE);
	else
	    pSample->SetDiscontinuity(FALSE);

	// !!! actually get data here!!!!!!
	hr = m_pFilter->FillBuffer(pSample, sCurrent, &sCount);

	if (FAILED(hr)) {
	    DbgLog((LOG_ERROR,1,TEXT("FillBuffer failed!  hr = %x"), hr));

	    return hr;
	}
	
	// set the start/stop time for this sample.
	CRefTime tThisStart = m_pFilter->SampleToRefTime(sCurrent) - tStart;
	CRefTime tThisEnd = m_pFilter->SampleToRefTime(sCurrent + sCount) - tStart;

	// we may have pushed a sample past the stop time, but we need to
	// make sure that the stop time is correct
	tThisEnd = min(tThisEnd, GetStopTime());

	// adjust both times by Rate... unless Rate is 0

	if (dRate && (dRate!=1.0)) {
	    tThisStart = LONGLONG( tThisStart.GetUnits() / dRate);
	    tThisEnd = LONGLONG( tThisEnd.GetUnits() / dRate);
	}

	pSample->SetTime((REFERENCE_TIME *)&tThisStart,
			 (REFERENCE_TIME *)&tThisEnd);


	DbgLog((LOG_TRACE,5,TEXT("Sending buffer, size = %d"), pSample->GetActualDataLength()));
	hr = Deliver(pSample);

	// done with buffer. connected pin may have its own addref
	DbgLog((LOG_TRACE,4,TEXT("Sample is delivered - releasing")));
	pSample->Release();
	if (FAILED(hr)) {
	    DbgLog((LOG_ERROR,1,TEXT("... but sample FAILED to deliver! hr=%lx"), hr));
	    // pretend everything's OK.  If we return an error, we'll panic
	    // and send EC_ERRORABORT and EC_COMPLETE, which is the wrong thing
	    // to do if we've tried to deliver something downstream.  Only
	    // if the downstream guy never got a chance to see the data do I
	    // feel like panicing.  For instance, the downstream guy could
	    // be failing because he's already seen EndOfStream (this thread
	    // hasn't noticed it yet) and he's already sent EC_COMPLETE and I
	    // would send another one!
	    return S_OK;
	}
	sCurrent += sCount;
	
	// what about hr==S_FALSE... I thought this would mean that
	// no more data should be sent down the pipe.
	if (hr == S_FALSE) {
	    DbgLog((LOG_ERROR,1,TEXT("Received S_FALSE from Deliver, stopping delivery")));
	    return S_OK;
	}
	
	// any other requests ?
	Command com;
	if (CheckRequest(&com)) {
	    return S_FALSE;
	}

    }

    DbgLog((LOG_TRACE,1,TEXT("Leaving streaming loop: current = %d, stop=%d"),
	    sCurrent, GetStopAt()));
    return VFW_S_NO_MORE_ITEMS;
}

// ------ IMediaPosition implementation -----------------------

HRESULT
CReaderStream::ChangeStart()
{
    // this lock should not be the same as the lock that protects access
    // to the start/stop/rate values. The worker thread will need to lock
    // that on some code paths before responding to a Stop and thus will
    // cause deadlock.

    // what we are locking here is access to the worker thread, and thus we
    // should hold the lock that prevents more than one client thread from
    // accessing the worker thread.

    CAutoLock lock(&m_AccessLock);

    if (ThreadExists()) {

	// next time round the loop the worker thread will
	// pick up the position change.
	// We need to flush all the existing data - we must do that here
	// as our thread will probably be blocked in GetBuffer otherwise

	DeliverBeginFlush();

	// make sure we have stopped pushing
	StopThread();

	// complete the flush
	DeliverEndFlush();

	// restart
	RunThread();
    }
    return S_OK;
}

HRESULT
CReaderStream::ChangeRate()
{
    // changing the rate can be done on the fly
    if( Rate() > 0 ) // we only support positive rates
    {
        SetRateInternal(Rate());
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

HRESULT
CReaderStream::ChangeStop()
{
    // we don't need to restart the worker thread to handle stop changes
    // and in any case that would be wrong since it would then start
    // pushing from the wrong place. Set the variables used by
    // the PushLoop
    REFERENCE_TIME tStopAt;
    {
        CAutoLock lock(&m_WorkerLock);
        tStopAt = Stop();
    }
    LONG sStopAt = m_pFilter->RefTimeToSample(tStopAt);
    SetStopAt(sStopAt, tStopAt);

    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\core\msreader\reccache.cpp ===
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)

#include <streams.h>
#include "reccache.h"
#include "alloc.h"

static inline DWORD_PTR AlignUp(DWORD_PTR dw, DWORD_PTR dwAlign) {
  // align up: round up to next boundary
  return (dw + (dwAlign -1)) & ~(dwAlign -1);
};

static inline BYTE *AlignUp(BYTE *pb, ULONG cbAlign)
{
  return (BYTE *)(AlignUp((DWORD_PTR)pb, cbAlign));
}


CRecBuffer::CRecBuffer(
  CRecCache *pParentCache,
  ULONG cbBuffer,
  BYTE *pb,
  HRESULT *phr,
  int stream) :
    sampleReqList(NAME("rec buffer sample req list"), 50),
    m_sample(NAME("buffer sample"), pParentCache, phr)
{
  m_pParentCache = pParentCache;
  m_state = INVALID;
  m_posSortedList = 0;
  ZeroMemory(&m_overlap, sizeof(m_overlap));
  m_cRef = 0;
  m_stream = stream;

  m_fWaitingOnBuffer = FALSE;
  m_fReadComplete = FALSE;
  m_hrRead = E_FAIL;

  ASSERT(m_cRef == 0);
  if(FAILED(*phr))
    return;

  m_pbAligned = pb;

  // report the aligned amount
  m_cbReported = cbBuffer;
}

CRecBuffer::~CRecBuffer()
{
  ASSERT(sampleReqList.GetCount() == 0);
  ASSERT(m_cRef == 0);
}

void CRecBuffer::Reset()
{
  m_fileOffsetValid = 0;
  m_cbValid = 0;

  ASSERT(sampleReqList.GetCount() == 0);
  ASSERT(m_overlap.pBuffer == 0);
  ASSERT(m_fWaitingOnBuffer == FALSE);
  m_fReadComplete = FALSE;
  m_hrRead = E_FAIL;

  ASSERT(m_cRef == 0);
}

void CRecBuffer::ResetPointer(BYTE *pb)
{
  m_state = INVALID;
  m_pbAligned = pb;
}

BYTE *CRecBuffer::GetPointer(DWORDLONG fileOffset)
{
  return m_pbAligned + (fileOffset - m_fileOffsetValid);
}

ULONG CRecBuffer::AddRef()
{
  InterlockedIncrement(&m_cRef);
  m_pParentCache->AddRef();
  ASSERT(m_cRef > 0);
  return m_cRef;
}

ULONG CRecBuffer::Release()
{
  // call RecCache's ReleaseBuffer so that its critical section can be
  // locked. otherwise there is a race condition between the
  // InterlockedDecrement to zero and entering the cs in CRecCache.
  ULONG c = m_pParentCache->ReleaseBuffer(this);
  m_pParentCache->Release();
  return c;
}

void CRecBuffer::MarkPending()
{
  m_pParentCache->BufferMarkPending(this);
}

void CRecBuffer::MarkValid()
{
  ASSERT(m_state == PENDING);
  m_state = VALID_ACTIVE;
}

void CRecBuffer::MarkValidWithFileError()
{
  ASSERT(m_state == PENDING);
  m_state = VALID_ACTIVE;
  m_cbValid = 0;
}

CRecCache::CRecCache(HRESULT *phr) :
    m_lFreeBuffers(NAME("free buffer list"), 10, FALSE),
    m_lSortedBuffers(NAME("Sorted buffer list"), 10, FALSE),
    CBaseAllocator(NAME("cache allocator"), 0, phr)
{
  m_cStreams = 0;
  m_cBuffers = 0;
  m_rgPerStreamBuffer = 0;
  m_pDevMem = 0;
  m_pDevConInner = 0;
  m_pbAllBuffers = 0;

#ifdef PERF
  m_idPerfBufferReleased = MSR_REGISTER(TEXT("basemsr buffer released"));
#endif // PERF
}

CRecCache::~CRecCache()
{
  ASSERT(m_lFreeBuffers.GetCount() == (long)m_cBuffers);

  for(ULONG iBuffer = 0; iBuffer < m_cBuffers; iBuffer++)
  {
    CRecBuffer *pRecBuffer = m_lFreeBuffers.RemoveHead();
    ASSERT(pRecBuffer);
    delete pRecBuffer;
  }

  for(UINT iStream = 0; iStream < m_cStreams; iStream++)
  {
    delete m_rgPerStreamBuffer[iStream].pBuffer;
  }

  m_lSortedBuffers.RemoveAll();

  delete[] m_rgPerStreamBuffer;

  FreeBuffer();
}

HRESULT CRecCache::Configure(
  UINT cBuffers,
  ULONG cbBuffer,
  ULONG cbAlign,
  UINT cStreams,
  ULONG *rgStreamSize)
{
  HRESULT hr;
  UINT iStream;

  ASSERT(m_rgPerStreamBuffer == 0);
  ASSERT(m_lFreeBuffers.GetCount() == 0);

  m_cStreams = cStreams;
  m_rgPerStreamBuffer = new PerStreamBuffer[cStreams];

  if(m_rgPerStreamBuffer == 0)
    return E_OUTOFMEMORY;

  for(iStream = 0; iStream < cStreams; iStream++)
  {
    m_rgPerStreamBuffer[iStream].pBuffer = 0;
  }

  ULONG cbAllocate = 0;
  for(iStream = 0; iStream < cStreams; iStream++)
    cbAllocate += (DWORD)AlignUp(rgStreamSize[iStream], cbAlign);
  cbAllocate += cBuffers * (DWORD)AlignUp(cbBuffer, cbAlign);
  ASSERT(AlignUp(cbAllocate, cbAlign) == cbAllocate);

  BYTE *pbAligned;
  m_pbAllBuffers = new BYTE[cbAllocate + cbAlign];
  if(m_pbAllBuffers == 0)
    return E_OUTOFMEMORY;
  pbAligned = AlignUp(m_pbAllBuffers, cbAlign);

  DbgLog(( LOG_TRACE, 5, TEXT("CRecCache::Configure: %i reserve"), cStreams ));
  for(iStream = 0; iStream < cStreams; iStream++)
  {
    hr = S_OK;
    m_rgPerStreamBuffer[iStream].pBuffer = new CRecBuffer(
      this,
      rgStreamSize[iStream],
      pbAligned,
      &hr,
      iStream);

    if(!m_rgPerStreamBuffer[iStream].pBuffer)
      hr = E_OUTOFMEMORY;
    if(FAILED(hr))
      goto Bail;

    pbAligned += AlignUp(rgStreamSize[iStream], cbAlign);

  }

  {
    DbgLog(( LOG_TRACE, 5,
             TEXT("CRecCache::Configure: %i (%i) buffers"),
             cBuffers, cbBuffer ));
    for(UINT iBuffer = 0; iBuffer < cBuffers; iBuffer++)
    {
      hr = S_OK;
      CRecBuffer *pRecBuffer = new CRecBuffer(this, cbBuffer, pbAligned, &hr);
      if(pRecBuffer == 0)
        hr = E_OUTOFMEMORY;
      if(FAILED(hr))
      {
        delete pRecBuffer;
        goto Bail;
      }

      pbAligned += AlignUp(cbBuffer, cbAlign);

      m_lFreeBuffers.AddHead(pRecBuffer);
    }
    m_cBuffers = cBuffers;
  }

  ASSERT(cBuffers != 0);

  return S_OK;

Bail:

  for(iStream = 0; iStream < cStreams; iStream++)
  {
    delete m_rgPerStreamBuffer[iStream].pBuffer;
    m_rgPerStreamBuffer[iStream].pBuffer = 0;
  }

  delete [] m_rgPerStreamBuffer;
  m_rgPerStreamBuffer = 0;

  CRecBuffer *pRecBuffer;
  while(pRecBuffer = m_lFreeBuffers.RemoveHead(),
        pRecBuffer)
  {
    delete pRecBuffer;
  }

  m_cStreams = 0;

  ASSERT(FAILED(hr));
  return hr;
}


HRESULT CRecCache::GetBuffer(
  CRecBuffer **ppRecBuffer)
{
  CAutoLock lock(&m_cs);

  *ppRecBuffer = m_lFreeBuffers.RemoveHead();
  if(!*ppRecBuffer) {
      return E_OUTOFMEMORY;
  }

  ASSERT(*ppRecBuffer);

  (*ppRecBuffer)->Reset();
  ASSERT((*ppRecBuffer)->m_state == CRecBuffer::INVALID ||
         (*ppRecBuffer)->m_state == CRecBuffer::VALID_INACTIVE);
  ASSERT((**ppRecBuffer)() != 0);

  (*ppRecBuffer)->AddRef();

  if((*ppRecBuffer)->m_state == CRecBuffer::VALID_INACTIVE)
  {
    DbgLog(( LOG_TRACE, 5,
             TEXT("CRecCache::GetBuffer: invalidate %08x"),
             (ULONG)((**ppRecBuffer).m_fileOffsetValid) ));
  }
  (*ppRecBuffer)->m_state = CRecBuffer::INVALID;

  POSITION pos = (**ppRecBuffer).m_posSortedList;
  if(pos != 0)
    m_lSortedBuffers.Remove(pos);

  return S_OK;
}

HRESULT CRecCache::GetReserveBuffer(
  CRecBuffer **ppRecBuffer,
  UINT stream)
{
  CAutoLock lock(&m_cs);

  *ppRecBuffer = m_rgPerStreamBuffer[stream].pBuffer;
  if(!*ppRecBuffer) {
      return E_OUTOFMEMORY;
  }
  m_rgPerStreamBuffer[stream].pBuffer = 0;

  ASSERT(*ppRecBuffer);

  (*ppRecBuffer)->Reset();
  ASSERT((*ppRecBuffer)->m_state == CRecBuffer::INVALID ||
         (*ppRecBuffer)->m_state == CRecBuffer::VALID_INACTIVE);

  (*ppRecBuffer)->AddRef();

  if((*ppRecBuffer)->m_state == CRecBuffer::VALID_INACTIVE)
  {
    DbgLog(( LOG_TRACE, 5,
             TEXT("CRecCache::GetBuffer: invalidate %08x"),
             (ULONG)((**ppRecBuffer).m_fileOffsetValid) ));
  }
  (*ppRecBuffer)->m_state = CRecBuffer::INVALID;

  POSITION pos = (**ppRecBuffer).m_posSortedList;
  if(pos != 0)
    m_lSortedBuffers.Remove(pos);

  return S_OK;
}


ULONG CRecCache::ReleaseBuffer(
  CRecBuffer *pRecBuffer)
{

  CAutoLock lock(&m_cs);

  // this is done here to avoid a race condition. if this is the final
  // release, only CRecCache can addref it with m_cs locked.
  long c = InterlockedDecrement(&pRecBuffer->m_cRef);
  ASSERT(c >= 0);

  DbgLog(( LOG_MEMORY, 3, TEXT("::ReleaseBuffer: %08x = %d"),
           pRecBuffer, pRecBuffer->m_cRef ));

  if(c > 0)
    return c;

  ASSERT(c == 0);
//   if(c != 0) _asm int 3;

  ASSERT(pRecBuffer->sampleReqList.GetCount() == 0);
  ASSERT(pRecBuffer->m_cRef == 0);
  ASSERT((*pRecBuffer)() != 0);

  ASSERT(pRecBuffer->m_overlap.pBuffer == 0);
  ASSERT(pRecBuffer->m_fWaitingOnBuffer == FALSE);

  if(pRecBuffer->m_state == CRecBuffer::VALID_ACTIVE)
  {
    pRecBuffer->m_state = CRecBuffer::VALID_INACTIVE;
    ASSERT(pRecBuffer->m_posSortedList != 0);
  }
  else
  {
    pRecBuffer->m_state = CRecBuffer::INVALID;
    ASSERT(pRecBuffer->m_posSortedList == 0);
  }

  if(pRecBuffer->m_stream == -1)
  {
    m_lFreeBuffers.AddTail(pRecBuffer);
  }
  else
  {
    ASSERT(m_rgPerStreamBuffer[pRecBuffer->m_stream].pBuffer == 0);
    m_rgPerStreamBuffer[pRecBuffer->m_stream].pBuffer = pRecBuffer;
  }

  DbgLog(( LOG_MEMORY, 2, TEXT("::ReleaseBuffer: %08x = %d"),
           pRecBuffer, pRecBuffer->m_cRef ));

  DbgLog((LOG_TRACE, 0x3f, TEXT("CRecCache: buffer %08x freed"),
          pRecBuffer));

  MSR_NOTE(m_idPerfBufferReleased);

  return 0;
}

// return addref'd buffer

HRESULT CRecCache::GetCacheHit(
  SampleReq *pSampleReq,
  CRecBuffer **ppBuffer)
{
  CAutoLock lock(&m_cs);

  *ppBuffer = 0;
  CRecBuffer *&rpBuffer = *ppBuffer;

  rpBuffer = LocateBuffer(
    &m_lSortedBuffers,
    pSampleReq->fileOffset,
    pSampleReq->cbReq);

  if(rpBuffer)
  {
    // reserve buffer for a different stream?
    if(rpBuffer->m_stream != -1 &&
       rpBuffer->m_stream != (signed)pSampleReq->stream)
    {
      rpBuffer = 0;
      return S_FALSE;
    }

    rpBuffer->AddRef();

    if(rpBuffer->m_state == CRecBuffer::PENDING)
      rpBuffer->sampleReqList.AddTail(pSampleReq);

    // take this buffer off the free list
    if(rpBuffer->m_state == CRecBuffer::VALID_INACTIVE)
    {
      MakeActive(rpBuffer);
    }

    return S_OK;
  }
  else
  {
    return S_FALSE;
  }
}

HRESULT CRecCache::GetOverlappedCacheHit(
  DWORDLONG filePos,
  ULONG cbData,
  CRecBuffer **ppBuffer)
{
  CAutoLock lock(&m_cs);

  CRecBuffer *&rpBuffer = *ppBuffer;
  rpBuffer = LocateBuffer(
    &m_lSortedBuffers,
    filePos,
    cbData);

  if(rpBuffer)
  {
    rpBuffer->AddRef();

    // take this buffer off the free list
    if(rpBuffer->m_state == CRecBuffer::VALID_INACTIVE)
    {
      MakeActive(rpBuffer);
    }

     return S_OK;
  }
  else
  {
    return S_FALSE;
  }
}

void CRecCache::MakeActive(CRecBuffer *pBuffer)
{
  ASSERT(CritCheckIn(&m_cs));
  ASSERT(pBuffer->sampleReqList.GetCount() == 0);
  // remove it from the free list. !!! linear search.
  if(pBuffer->m_stream == -1)
  {
    POSITION pos = m_lFreeBuffers.Find(pBuffer);
    ASSERT(pos != 0);
    m_lFreeBuffers.Remove(pos);
  }
  else
  {
    ASSERT(m_rgPerStreamBuffer[pBuffer->m_stream].pBuffer != 0);
    m_rgPerStreamBuffer[pBuffer->m_stream].pBuffer = 0;
  }
  pBuffer->m_state = CRecBuffer::VALID_ACTIVE;
}

// this is done here rather instead of in the buffer so that we can
// lock CRecCache and prevent LocateBuffer from finding
// m_posSortedList unset.

HRESULT CRecCache::BufferMarkPending(
  CRecBuffer *pBuffer)
{
  CAutoLock lock(&m_cs);

  ASSERT(pBuffer->m_state == CRecBuffer::INVALID);
  pBuffer->m_state = CRecBuffer::PENDING;

  // list is not sorted for the moment
  POSITION pos = m_lSortedBuffers.AddHead(pBuffer);
  pBuffer->m_posSortedList = pos;

  return S_OK;
}

STDMETHODIMP
CRecCache::NonDelegatingQueryInterface (
  REFIID riid,
  void ** pv)
{
  if(m_pDevConInner && riid == IID_IAMDevMemoryControl)
  {
    return m_pDevConInner->QueryInterface(riid, pv);
  }
  else
  {
    return CBaseAllocator::NonDelegatingQueryInterface(riid, pv);
  }
}

// called when an output pin finds that this filter can use memory
// from the downstream filter. null means stop using any external
// allocator

HRESULT CRecCache::NotifyExternalMemory(
    IAMDevMemoryAllocator *pDevMem)
{
  DbgLog((LOG_TRACE, 5, TEXT("CRecCache::NotifyExternalMemory")));
  InvalidateCache();

  HRESULT hr = S_OK;

  // not running
  ASSERT(m_lFreeBuffers.GetCount() == (long)m_cBuffers);

  // allocated when input pin connected
  ASSERT(m_pbAllBuffers);

  if(pDevMem == 0 && m_pDevMem == 0)
  {
    DbgLog((LOG_TRACE, 5, TEXT("CRecCache: keeping internal allocator")));
    return S_OK;
  }

  ALLOCATOR_PROPERTIES apThis;
  GetProperties(&apThis);
  ASSERT(apThis.cbAlign != 0);

  //
  // count how much memory to allocate
  //
  ULONG cbAllocate = 0;
  POSITION pos = m_lFreeBuffers.GetHeadPosition();
  while(pos)
  {
    CRecBuffer *pBuffer = m_lFreeBuffers.Get(pos);
    ASSERT(pBuffer->GetSize() % apThis.cbAlign == 0);
    cbAllocate += pBuffer->GetSize();
    pos = m_lFreeBuffers.Next(pos);
  }
  for(UINT iStream = 0; iStream < m_cStreams; iStream++)
  {
    CRecBuffer *pBuffer = m_rgPerStreamBuffer[iStream].pBuffer;
    ASSERT(pBuffer->GetSize() % apThis.cbAlign == 0);
    cbAllocate += pBuffer->GetSize();
  }

  DbgLog((LOG_TRACE, 5, TEXT("CRecCache: computed cbAllocate= %d"),
          cbAllocate));

  BYTE *pbMem;
  if(pDevMem)
  {
    if(m_pDevMem)
    {
      DbgLog((LOG_TRACE, 5, TEXT("CRecCache: keeping external allocator")));
      return S_OK;
    }

    DbgLog((LOG_TRACE, 5, TEXT("CRecCache: trying external allocator")));

#ifdef DEBUG
    DWORD dwTotalFree, dwLargestFree, dwTotalMem, dwMinChunk;
    hr = pDevMem->GetInfo(
      &dwTotalFree, &dwLargestFree, &dwTotalMem, &dwMinChunk);
    DbgLog((LOG_TRACE, 3,
            TEXT("DevMemInfo: hr = %08x, total free: %08x,")
	    TEXT("largest free: %08x, total mem: %08x, min chunk: %08x"),
            hr, dwTotalFree, dwLargestFree, dwTotalMem, dwMinChunk));
#endif // DEBUG

    DWORD dwcb = (DWORD)AlignUp(cbAllocate, apThis.cbAlign);
    hr = pDevMem->Alloc(&pbMem, &dwcb);
    if(FAILED(hr))
    {
      return S_FALSE;
    }
    else if(dwcb < cbAllocate)
    {
      DbgLog((LOG_ERROR, 1, TEXT("reccache: insufficent memory from DevMem")));
      EXECUTE_ASSERT(SUCCEEDED(pDevMem->Free(pbMem)));
      return S_FALSE;
    }


    FreeBuffer();

    IUnknown *pDevConUnk;
    hr = pDevMem->GetDevMemoryObject(&pDevConUnk, GetOwner());
    if(FAILED(hr))
    {
      DbgLog((LOG_ERROR, 1, TEXT("CRecCache: GetDevMemoryObject: %08x"), hr));
      EXECUTE_ASSERT(SUCCEEDED(pDevMem->Free(pbMem)));
      return hr;
    }

    m_pDevMem = pDevMem;
    m_pDevConInner = pDevConUnk; // already addrefd
    pDevMem->AddRef();
    m_pbAllBuffers = pbMem;
    pbMem = AlignUp(pbMem, apThis.cbAlign);
  }
  else
  {
    DbgLog((LOG_TRACE, 5, TEXT("CRecCache: back to internal allocator")));
    ASSERT(m_pDevMem);
    FreeBuffer();

    m_pbAllBuffers = new BYTE[cbAllocate + apThis.cbAlign];
    if(m_pbAllBuffers == 0)
      return E_OUTOFMEMORY;

    pbMem = AlignUp(m_pbAllBuffers, apThis.cbAlign);
  }

  DbgAssertAligned(pbMem, apThis.cbAlign );
  BYTE *pbMemStart = pbMem;

  pos = m_lFreeBuffers.GetHeadPosition();
  while(pos)
  {
    CRecBuffer *pBuffer = m_lFreeBuffers.Get(pos);
    pBuffer->ResetPointer(pbMem);
    ASSERT(pBuffer->GetSize() % apThis.cbAlign == 0);
    pbMem += pBuffer->GetSize();

    pos = m_lFreeBuffers.Next(pos);
  }
  for(iStream = 0; iStream < m_cStreams; iStream++)
  {
    CRecBuffer *pBuffer = m_rgPerStreamBuffer[iStream].pBuffer;
    pBuffer->ResetPointer(pbMem);
    ASSERT(pBuffer->GetSize() % apThis.cbAlign == 0);
    pbMem += pBuffer->GetSize();
  }
  ASSERT(pbMem <= pbMemStart + cbAllocate);

  return S_OK;
}

void CRecCache::FreeBuffer()
{
  if(m_pDevMem)
  {
    EXECUTE_ASSERT(SUCCEEDED(m_pDevMem->Free(m_pbAllBuffers)));
    m_pDevMem->Release();
    m_pDevConInner->Release();
    m_pDevMem = 0;
    m_pDevConInner = 0;
  }
  else
  {
    delete[] m_pbAllBuffers;
  }
  m_pbAllBuffers = 0;
}

void CRecCache::InvalidateCache()
{
  POSITION pos;
  while(pos = m_lSortedBuffers.GetHeadPosition(),
        pos)
  {
    m_lSortedBuffers.Get(pos)->m_state = CRecBuffer::INVALID;
    m_lSortedBuffers.Get(pos)->m_posSortedList = 0;
    m_lSortedBuffers.RemoveHead();
  }
}

CRecBuffer *CRecCache::LocateBuffer(
  CGenericList<CRecBuffer> *pList,
  DWORDLONG qwFileOffset,
  ULONG cbBuffer)
{
  ASSERT(CritCheckIn(&m_cs));
  POSITION pos = pList->GetHeadPosition();

  // list is not sorted for the moment
  while(pos)
  {
    CRecBuffer *pBuffer = pList->Get(pos);
    ASSERT(pBuffer);

    ASSERT(pBuffer->m_state != CRecBuffer::INVALID);
    ASSERT(pBuffer->m_state == CRecBuffer::PENDING ||
           pBuffer->m_state == CRecBuffer::VALID_INACTIVE ||
           pBuffer->m_state == CRecBuffer::VALID_ACTIVE);

    // if it fits in this buffer
    if((pBuffer->m_fileOffsetValid <= qwFileOffset) &&
       (pBuffer->m_fileOffsetValid + pBuffer->m_cbValid >=
        qwFileOffset + cbBuffer))
    {
      return pBuffer;
    }

    pList->GetNext(pos);
  }

  return 0;
}


// ------------------------------------------------------------------------
// CBaseAllocator overrides

void CRecCache::Free()
{
}

//
// just remember the numbers
//
STDMETHODIMP
CRecCache::SetProperties(
  ALLOCATOR_PROPERTIES* pRequest,
  ALLOCATOR_PROPERTIES* pActual)
{
  CAutoLock cObjectLock(this);
  CheckPointer(pRequest, E_POINTER);
  CheckPointer(pActual, E_POINTER);
  ValidateReadWritePtr(pActual, sizeof(ALLOCATOR_PROPERTIES));

  ZeroMemory(pActual, sizeof(ALLOCATOR_PROPERTIES));

  ASSERT(pRequest->cbBuffer > 0);

  /* Can't do this if already committed, there is an argument that says we
     should not reject the SetProperties call if there are buffers still
     active. However this is called by the source filter, which is the same
     person who is holding the samples. Therefore it is not unreasonable
     for them to free all their samples before changing the requirements */

  if (m_bCommitted) {
    return VFW_E_ALREADY_COMMITTED;
  }

  /* Must be no outstanding buffers */

  if (m_lAllocated != m_lFree.GetCount()) {
    return VFW_E_BUFFERS_OUTSTANDING;
  }

  /* There isn't any real need to check the parameters as they
     will just be rejected when the user finally calls Commit */

  pActual->cbBuffer = m_lSize = pRequest->cbBuffer;
  pActual->cBuffers = m_lCount = pRequest->cBuffers;
  pActual->cbAlign = m_lAlignment = pRequest->cbAlign;
  pActual->cbPrefix = m_lPrefix = pRequest->cbPrefix;

  m_bChanged = TRUE;
  return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\core\multfile\multfile.cpp ===
// Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.


// Simple parser filter
//

#include <streams.h>

#ifdef FILTER_DLL
#include <initguid.h>
#endif

#include "multfile.h"

// ok to use this as it is not dereferenced
#pragma warning(disable:4355)


const AMOVIESETUP_MEDIATYPE
psudMultiParseType[] = { { &MEDIATYPE_Stream       // 1. clsMajorType
                        , &CLSID_MultFile } }; //    clsMinorType


const AMOVIESETUP_MEDIATYPE
sudMultiParseOutType = { &MEDIATYPE_NULL       // 1. clsMajorType
                       , &MEDIASUBTYPE_NULL }; //    clsMinorType

const AMOVIESETUP_PIN
psudMultiParsePins[] =  { { L"Input"             // strName
		    , FALSE                // bRendered
		    , FALSE                // bOutput
		    , FALSE                // bZero
		    , FALSE                // bMany
		    , &CLSID_NULL          // clsConnectsToFilter
		    , L""                  // strConnectsToPin
		    , 1                    // nTypes
		    , psudMultiParseType }, // lpTypes
		         { L"Output"             // strName
		    , FALSE                // bRendered
		    , TRUE                 // bOutput
		    , FALSE                // bZero
		    , FALSE                // bMany
		    , &CLSID_NULL          // clsConnectsToFilter
		    , L""                  // strConnectsToPin
		    , 1                    // nTypes
		    , &sudMultiParseOutType } }; // lpTypes

const AMOVIESETUP_FILTER
sudMultiParse = { &CLSID_MultFile     // clsID
               , L"Multiple Source"        // strName
               , MERIT_UNLIKELY        // dwMerit
               , 2                     // nPins
               , psudMultiParsePins };   // lpPin

#ifdef FILTER_DLL
// COM global table of objects available in this dll
CFactoryTemplate g_Templates[] = {

    { L"Multiple Source"
    , &CLSID_MultFile
    , CMultFilter::CreateInstance
    , NULL
    , &sudMultiParse }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// exported entry points for registration and
// unregistration (in this case they only call
// through to default implmentations).
//
STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif

//
// CreateInstance
//
// Called by CoCreateInstance to create our filter
CUnknown *CMultFilter::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CMultFilter(NAME("Multiple file source"), lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return punk;
}


/* Implements the CMultFilter public member functions */


// constructors etc
CMultFilter::CMultFilter(
    TCHAR *pName,
    LPUNKNOWN pUnk,
    HRESULT *phr)
    : CBaseFilter(pName, pUnk, &m_csLock, CLSID_MultFile),
      m_Input(this, &m_csLock, phr, L"Reader"),
      m_Output(NAME("Fake Output pin"), phr, this, &m_csLock, L"Out"),
      m_pAsyncReader(NULL)
{
}

CMultFilter::~CMultFilter()
{
}


// pin enumerator calls this
int CMultFilter::GetPinCount() {
    // only expose output pin if we have a reader.
    return m_pAsyncReader ? 2 : 1;
};

// return a non-addrefed pointer to the CBasePin.
CBasePin *
CMultFilter::GetPin(int n)
{
    if (n == 0)
	return &m_Input;

    if (n == 1)
	return &m_Output;
    
    return NULL;
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// input pin

CReaderInPin::CReaderInPin(CMultFilter *pFilter,
			   CCritSec *pLock,
			   HRESULT *phr,
			   LPCWSTR pPinName) :
   CBasePin(NAME("in pin"), pFilter, pLock, phr, pPinName, PINDIR_INPUT),
   m_pFilter(pFilter)
{
}

HRESULT CReaderInPin::CheckMediaType(const CMediaType *pmt)
{
    if (*(pmt->Type()) != MEDIATYPE_Stream)
        return E_INVALIDARG;

    if (*(pmt->Subtype()) != CLSID_MultFile)
        return E_INVALIDARG;

    return S_OK;
}

// ------------------------------------------------------------------------
// calls the filter to parse the file and create the output pins.

HRESULT CReaderInPin::CompleteConnect(
  IPin *pReceivePin)
{
    HRESULT hr = pReceivePin->QueryInterface(IID_IAsyncReader,
					     (void**)&m_pFilter->m_pAsyncReader);
    
    if(FAILED(hr))
	return hr;

    return hr;
}

HRESULT CReaderInPin::BreakConnect()
{
    if (m_pFilter->m_pAsyncReader) {
	m_pFilter->m_pAsyncReader->Release();
	m_pFilter->m_pAsyncReader = NULL;
    }
    
    return CBasePin::BreakConnect();
}

/* Implements the CMultStream class */


CMultStream::CMultStream(
    TCHAR *pObjectName,
    HRESULT * phr,
    CMultFilter * pFilter,
    CCritSec *pLock,
    LPCWSTR wszPinName)
    : CBaseOutputPin(pObjectName, pFilter, pLock, phr, wszPinName)
    , m_pFilter(pFilter)
{
}

CMultStream::~CMultStream()
{
}

STDMETHODIMP
CMultStream::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IStreamBuilder) {
	return GetInterface((IStreamBuilder *) this, ppv);
    } else {
	return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}

// IPin interfaces


// this pin doesn't support any media types!
HRESULT
CMultStream::GetMediaType(int iPosition, CMediaType* pt)
{
    return VFW_S_NO_MORE_ITEMS;
}

// check if the pin can support this specific proposed type&format
HRESULT
CMultStream::CheckMediaType(const CMediaType* pt)
{
    ASSERT(0);
    return E_NOTIMPL;
}

HRESULT
CMultStream::DecideBufferSize(IMemAllocator * pAllocator,
			     ALLOCATOR_PROPERTIES *pProperties)
{
    ASSERT(0);
    return E_NOTIMPL;
}


// IStreamBuilder::Render -- graph builder will call this
// to do something with our output pin
HRESULT CMultStream::Render(IPin * ppinOut, IGraphBuilder * pGraph)
{
    LONGLONG llTotal, llAvailable;

    m_pFilter->m_pAsyncReader->Length(&llTotal, &llAvailable);
    
    DWORD cbFile = (DWORD) llTotal;

    char *lpFile = new char[cbFile];

    if (!lpFile)
	return E_OUTOFMEMORY;
    
    /* Try to read whole file */
    HRESULT hr = m_pFilter->m_pAsyncReader->SyncRead(0, cbFile, (BYTE *) lpFile);

    if (hr != S_OK)
        return E_FAIL;

    // !!! loop through file,

    char *lp = lpFile;

    WCHAR wsz[200];
    int		cbWide = 0;

    HRESULT hrSummary = E_FAIL;

    while (cbFile--) {
	if (*lp == '\r' || *lp == '\n') {
	    if (cbWide > 0 && wsz[0] != L';') {
		wsz[cbWide] = L'\0';

		hr = pGraph->RenderFile(wsz, NULL);

		DbgLog((LOG_TRACE, 1, TEXT("RenderFile %ls returned %x"), wsz, hr));
		if ((hrSummary == S_OK && SUCCEEDED(hr)) ||
			(SUCCEEDED(hr) && hr != S_OK) ||
			FAILED(hrSummary))
		    hrSummary = hr;
	    }
	    cbWide = 0;
	} else {
	    wsz[cbWide++] = (WCHAR) *lp;
	}
	
	lp++;
    }

    delete[] lpFile;

    return hrSummary;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\core\simpread\simpread.h ===
// Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.

//
//
// implements quartz stream handler interfaces by mapping to avifile apis.
//

// forward declarations

#ifndef __SIMPLEREADER__
#define __SIMPLEREADER__

class CReaderStream;     // owns a particular stream
class CSimpleReader;     // overall container class

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// input pin. uses IAsyncReader and not IMemInputPin

class CReaderInPin : public CBasePin
{
protected:
    class CSimpleReader* m_pFilter;

public:
    CReaderInPin(
		 class CSimpleReader *pFilter,
		 CCritSec *pLock,
		 HRESULT *phr,
		 LPCWSTR pPinName);

    virtual ~CReaderInPin();

    // CBasePin overrides
    virtual HRESULT CheckMediaType(const CMediaType* mtOut);
    virtual HRESULT CheckConnect(IPin * pPin);
    virtual HRESULT CompleteConnect(IPin *pReceivePin);
    virtual HRESULT BreakConnect();

    STDMETHODIMP BeginFlush(void) { return E_UNEXPECTED; }
    STDMETHODIMP EndFlush(void) { return E_UNEXPECTED; }
};

// CReaderStream
// represents one stream of data within the file
// responsible for delivering data to connected components
//
// supports IPin
//
// never created by COM, so no CreateInstance or entry in global
// FactoryTemplate table. Only ever created by a CSimpleReader object and
// returned via the EnumPins interface.
//

class CReaderStream : public CBaseOutputPin, public CAMThread, public CSourceSeeking
{

public:

    CReaderStream(
	TCHAR *pObjectName,
	HRESULT * phr,
	CSimpleReader * pFilter,
	CCritSec *pLock,
	LPCWSTR wszPinName);

    ~CReaderStream();

    // expose IMediaPosition via CImplPosition, rest via CBaseOutputPin
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);

    // IPin

    HRESULT GetMediaType(int iPosition,CMediaType* pt);

    // check if the pin can support this specific proposed type&format
    HRESULT CheckMediaType(const CMediaType*);

    // say how big our buffers should be and how many we want
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES *pProperties);

    // Override to start & stop thread
    HRESULT Active();
    HRESULT Inactive();


    // ----- called by worker thread ---

    // access the stop and rate variables used by PushLoop
    // called by worker thread and
    double GetRate(void) {
        // not atomic - so use critsec
        CAutoLock lock(&m_WorkerLock);
        return m_dRate;
    }
    void SetRateInternal(double dRate) {
        // not atomic so hold critsec
        CAutoLock lock(&m_WorkerLock);
        m_dRate = dRate;
    }
    LONG GetStopAt(void) {
        // atomic so no critsec
        return m_sStopAt;
    }
    REFERENCE_TIME GetStopTime(void) {
        // not atomic - so use critsec
        CAutoLock lock(&m_WorkerLock);
        return m_rtStop;
    }
    void SetStopAt(DWORD sStop, REFERENCE_TIME tStop) {
        // not atomic - so use critsec
        CAutoLock lock(&m_WorkerLock);
        m_rtStop = tStop;
	m_sStopAt = sStop;
    }

    void SetDuration(DWORD sDuration, REFERENCE_TIME tDuration) {
        // not atomic - so use critsec
        CAutoLock lock(&m_WorkerLock);

	m_sStopAt = sDuration;

        // set them in the base class
	m_rtDuration = tDuration;
	m_rtStop = tDuration;
    }

private:

    CSimpleReader * m_pFilter;

    // CSourcePosition stuff
    // the worker thread PushLoop is checking against these for every sample
    // Use Get/SetRate Get/SetStop to access from worker thread
    LONG m_sStopAt;


    HRESULT ChangeStart();
    HRESULT ChangeStop();
    HRESULT ChangeRate();

#if 0    // MIDL and structs don't match well
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);
#endif
    
    double Rate() {
	return m_dRateSeeking;
    };
    CRefTime Start() {
        // not atomic, so use critsec
        ASSERT(CritCheckIn(&m_WorkerLock));
	return m_rtStart;
    };
    CRefTime Stop() {
        // not atomic, so use critsec
        ASSERT(CritCheckIn(&m_WorkerLock));
	return m_rtStop;
    };

    // worker thread stuff
    enum Command { CMD_RUN, CMD_STOP, CMD_EXIT };

    // type-corrected overrides of communication funcs
    Command GetRequest() {
	return (Command) CAMThread::GetRequest();
    };

    BOOL CheckRequest(Command * pCom) {
	return CAMThread::CheckRequest( (DWORD *) pCom);
    };

    void DoRunLoop(void);

    // return S_OK if reach sStop, S_FALSE if pos changed, or else error
    HRESULT PushLoop(
		LONG sCurrent,
		LONG sStart,
		CRefTime tStart,
		double dRate
		);

    CCritSec m_WorkerLock;
    CCritSec m_AccessLock;
    
public:
    BOOL Create();

    DWORD ThreadProc();

    // commands we can give the thread
    HRESULT RunThread();
    HRESULT StopThread();

    HRESULT ExitThread();

};

//
// CSimpleReader represents an avifile
//
// responsible for
// -- finding file and enumerating streams
// -- giving access to individual streams within the file
// -- control of streaming
//

class CSimpleReader : public CBaseFilter
{
public:

    // constructors etc
    CSimpleReader(TCHAR *, LPUNKNOWN, REFCLSID, CCritSec *, HRESULT *);
    ~CSimpleReader();

    // create a new instance of this class
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    // pin enumerator calls this
    int GetPinCount();

    CBasePin * GetPin(int n);

    // input pin notifies filter of connection and gives the
    // IAsyncReader interface this way. parse the file here and create
    // output pins (leave pins in a state ready to connect downstream).
    virtual HRESULT NotifyInputConnected(IAsyncReader *pAsyncReader);

    virtual HRESULT NotifyInputDisconnected();

    // these must be overridden....
    virtual HRESULT ParseNewFile() = 0;
    virtual HRESULT CheckMediaType(const CMediaType* mtOut) = 0;
    virtual LONG StartFrom(LONG sStart) = 0;
    virtual HRESULT FillBuffer(IMediaSample *pSample, DWORD dwStart, DWORD *cSamples) = 0;
    
    HRESULT SetOutputMediaType(const CMediaType* mtOut);
    
    
private:

    friend class CReaderStream;
    friend class CReaderInPin;

    CReaderStream m_Output;
    CReaderInPin m_Input;

    CCritSec *m_pLock;
    
public:
    IAsyncReader *m_pAsyncReader;
    DWORD	m_sLength;

protected:
    // returns the sample number starting at or after time t
    virtual LONG RefTimeToSample(CRefTime t) = 0;

    // returns the RefTime for s (media time)
    virtual CRefTime SampleToRefTime(LONG s) = 0;

    virtual ULONG GetMaxSampleSize() = 0;
};


#endif // __SIMPLEREADER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\audmix\audmix.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#ifdef FILTER_DLL
#include <initguid.h>
#endif

#include "AudMix.h"
#include "prop.h"
#include "..\util\perf_defs.h"

// Using this pointer in constructor
#pragma warning(disable:4355)

#define MAX_LONG 0x7fffffff
#define MAX_REFERENCE_TIME 0x7fffffffffffffff

#define HOT_JUMP_SLOPE 5000
#define MAX_CLIP 5000

//############################################################################
// 
//############################################################################

void CAudMixer::ClearHotnessTable( )
{
    for( int i = 0 ; i < HOTSIZE ; i++ )
    {
        m_nHotness[i] = 32767L;
    }
    m_nLastHotness = 32767;
}

//
// Constructor
//
CAudMixer::CAudMixer(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) :
    CPersistStream(pUnk, phr),
    m_InputPinsList(NAME("AudMixer Input Pins list")),
    m_cInputs(0), 
    m_pOutput(NULL),
    m_iOutputBufferCount(4),      //4 buffers
    // !!! needs to be as big as input buffers!
    m_msPerBuffer(250),  //250 mSecond/buffer
    CBaseFilter(NAME("AudMixer"), pUnk, this, CLSID_AudMixer),
    m_fEOSSent(FALSE),
    m_rtLastStop(0),    //??? can be set by APP
    m_cFlushDelivery(0), m_bNewSegmentDelivered(FALSE),
    m_pPinMix(NULL), m_pPinTemp(NULL), m_pStartTemp(NULL), m_pStopTemp(NULL)
{
    ASSERT(phr);

    // set default mixer mediatype that we accept
    //
    m_MixerMt.majortype = MEDIATYPE_Audio;
    m_MixerMt.subtype = MEDIASUBTYPE_PCM;
    m_MixerMt.formattype = FORMAT_WaveFormatEx;
    m_MixerMt.AllocFormatBuffer( sizeof( WAVEFORMATEX ) );

    // set the mediatype format block
    //
    WAVEFORMATEX * vih = (WAVEFORMATEX*) m_MixerMt.Format( );
    ZeroMemory( vih, sizeof( WAVEFORMATEX ) );
    vih->wFormatTag = WAVE_FORMAT_PCM;
    vih->nChannels = 2;
    vih->nSamplesPerSec = 44100;
    vih->nBlockAlign = 4;
    vih->nAvgBytesPerSec = vih->nBlockAlign * vih->nSamplesPerSec;
    vih->wBitsPerSample = 16;

    m_MixerMt.SetSampleSize(vih->nBlockAlign);  //lSampleSize

    // clear the input pins list (it should already be blank anyhow)
    InitInputPinsList();
    // Create a single input pin at this time and add it to the list
    CAudMixerInputPin *pInputPin = CreateNextInputPin(this);

    // create the single output pin as well
    m_pOutput = new CAudMixerOutputPin(NAME("Output Pin"), this, phr, L"Output");

    ClearHotnessTable( );

} /* CAudMixer::CAudMixer */


//############################################################################
// 
//############################################################################

//
// Destructor
//
CAudMixer::~CAudMixer()
{
    // clear out the input pins
    //
    InitInputPinsList();

    // delete the output pin, too
    //
    if (m_pOutput)
    {
        delete m_pOutput;
    }

    // free the media type format block
    //
    FreeMediaType(m_MixerMt);

} /* CAudMixer::~CAudMixer */


//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixer::Pause()
{
    CAutoLock cAutolock(m_pLock);
 
    // if we're going into paused mode from stopped, allocate a bunch of
    // arrays for mixing. 
    //
    m_rtLastStop=0;
    if (m_State == State_Stopped) 
    {
        ClearHotnessTable( );

        m_pPinTemp = (CAudMixerInputPin **)QzTaskMemAlloc(m_cInputs *
                    sizeof(CAudMixerInputPin *));
        if (m_pPinTemp == NULL)
            goto Pause_Error;
            m_pPinMix = (BYTE **)QzTaskMemAlloc(m_cInputs *
                        sizeof(CAudMixerInputPin *));
        if (m_pPinMix == NULL)
            goto Pause_Error;
            m_pStartTemp = (REFERENCE_TIME *)QzTaskMemAlloc(m_cInputs *
                        sizeof(REFERENCE_TIME));
        if (m_pStartTemp == NULL)
            goto Pause_Error;
            m_pStopTemp = (REFERENCE_TIME *)QzTaskMemAlloc(m_cInputs *
                        sizeof(REFERENCE_TIME));
        if (m_pStopTemp == NULL)
            goto Pause_Error;
    }
    // !!! check the return value of pause to make sure to leave these arrays
    // allocated
    //
    return CBaseFilter:: Pause();       

Pause_Error:

    // free up our arrays
    //
    if (m_pPinTemp)
    QzTaskMemFree(m_pPinTemp);
    m_pPinTemp = 0;
    if (m_pPinMix)
    QzTaskMemFree(m_pPinMix);
    m_pPinMix = 0;
    if (m_pStartTemp)
    QzTaskMemFree(m_pStartTemp);
    m_pStartTemp = 0;
    if (m_pStopTemp)
    QzTaskMemFree(m_pStopTemp);
    m_pStopTemp = 0;
    return E_OUTOFMEMORY;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixer::Stop()
{
    CAutoLock cAutolock(m_pLock);

    // make sure receive is done, or freeing these things will fault!
    CAutoLock foo(&m_csReceive);

    // free up our arrays. This looks suspiciously like the above free methods
    //
    if (m_pPinTemp)
    QzTaskMemFree(m_pPinTemp);
    m_pPinTemp = 0;
    if (m_pPinMix)
    QzTaskMemFree(m_pPinMix);
    m_pPinMix = 0;
    if (m_pStartTemp)
    QzTaskMemFree(m_pStartTemp);
    m_pStartTemp = 0;
    if (m_pStopTemp)
    QzTaskMemFree(m_pStopTemp);
    m_pStopTemp = 0;

    return CBaseFilter::Stop();       
}

//############################################################################
// 
//############################################################################

//
// GetPinCount
//
int CAudMixer::GetPinCount()
{
    return 1 + m_cInputs;
} /* CAudMixer::GetPinCount */


//############################################################################
// 
//############################################################################

//
// GetPin
//
CBasePin *CAudMixer::GetPin(int n)
{
    // Pin zero is the one and only output pin
    if( n == 0 )
    return m_pOutput;

    // return the input pin at position(n) (zero based)  We can use n, and not
    // n-1, because we have already decremented n if an Output pin exists.
    return GetPinNFromList(n-1);

} /* CAudMixer::GetPin */

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixer::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CheckPointer(ppv,E_POINTER);

    if (riid == IID_IAudMixer) {
    return GetInterface((IAudMixer *) this, ppv);
    } else  if (IsEqualIID(IID_ISpecifyPropertyPages, riid)) {
    return GetInterface((ISpecifyPropertyPages *)this, ppv);
    } else if (riid == IID_IPersistStream) {
        return GetInterface((IPersistStream *) this, ppv);
    } else {
    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }
} // NonDelegatingQueryInterface


//############################################################################
// 
//############################################################################

//
// IPersistStream method
//
STDMETHODIMP CAudMixer::GetClassID(CLSID *pClsid)
{
    CheckPointer(pClsid, E_POINTER);
    *pClsid = CLSID_AudMixer;
    return S_OK;  
}


//############################################################################
// 
//############################################################################

typedef struct {
    int version;    // version
    AM_MEDIA_TYPE mt;    // audio mixer format is hidden after the array
    int cBuffers;    // OutputBufferNumber
    int msBuffer;    // OutputBuffermSecond
    int nInputPins;    // total input pin number m_cInputs
    int cbExtra;    // m_MixerMt.cbFormat+ all input pin's Envelope table +output pin's Envelope table
    LPBYTE pExtra;
    // format is hidden here
    // also hidden here is the list of envelopes and ranges
} saveMix;


//
// IPersistStream method
//
// persist ourself - we have a bunch of random stuff to save, our media type
// (sans format), an array of queued connections, and finally the format of
// the media type
//
HRESULT CAudMixer::WriteToStream(IStream *pStream)
{
    DbgLog((LOG_TRACE,1,TEXT("CAudMixer::WriteToStream")));
    CheckPointer(pStream, E_POINTER);

    // we're looking at the envelope, which can change at any moment
    CAutoLock l(&m_csVol);

    saveMix *px;

    // how big will our saved data be?
    int nEnvelopes = 0;
    int nRanges = 0;
    int savesize = sizeof(saveMix) - sizeof(LPBYTE) + m_MixerMt.cbFormat;

    //memory space for saving all input pin's Envelope table
    POSITION pos = m_InputPinsList.GetHeadPosition();
    while( pos )
    {
        CAudMixerInputPin *pInputPin = m_InputPinsList.GetNext(pos);
    savesize += sizeof(int) + pInputPin->m_VolumeEnvelopeEntries *
                        sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);
    savesize += sizeof(int) + pInputPin->m_cValid * sizeof(REFERENCE_TIME)
                    * 2;
    }

    //memory space for saving the output pin's Envelope talbe
    savesize += sizeof(int) + m_pOutput->m_VolumeEnvelopeEntries *
                        sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);

    DbgLog((LOG_TRACE,1,TEXT("Persisted data is %d bytes"), savesize));

    px = (saveMix *)QzTaskMemAlloc(savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
    return E_OUTOFMEMORY;
    }

    //
    px->version = 1;
    px->mt = m_MixerMt;
    // Can't persist pointers
    px->mt.pbFormat = NULL;
    px->mt.pUnk = NULL;        // !!!
    px->nInputPins = m_cInputs;
    px->cBuffers = m_iOutputBufferCount;
    px->msBuffer = m_msPerBuffer;

    // the format goes after the array
    LPBYTE pSave = (LPBYTE)&px->pExtra;
    CopyMemory(pSave, m_MixerMt.pbFormat, m_MixerMt.cbFormat);
    int cbExtra = m_MixerMt.cbFormat;
    pSave += m_MixerMt.cbFormat;

    // then comes the input pins envelopes and ranges prefixed by the number for each pin
    pos = m_InputPinsList.GetHeadPosition();
    while( pos )
    {
        CAudMixerInputPin *pInputPin = m_InputPinsList.GetNext(pos);
        nEnvelopes = (int)pInputPin->m_VolumeEnvelopeEntries;
        *(int *)pSave = nEnvelopes;
    pSave += sizeof(int);
    if (nEnvelopes)
        CopyMemory(pSave, pInputPin->m_pVolumeEnvelopeTable, nEnvelopes *
                sizeof(DEXTER_AUDIO_VOLUMEENVELOPE));
    pSave += nEnvelopes * sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);


        int nRanges = (int)pInputPin->m_cValid;
        *(int *)pSave = nRanges;
    pSave += sizeof(int);
    if (nRanges)
        CopyMemory(pSave, pInputPin->m_pValidStart, nRanges *
                        sizeof(REFERENCE_TIME));
    pSave += nRanges * sizeof(REFERENCE_TIME);
    if (nRanges)
        CopyMemory(pSave, pInputPin->m_pValidStop, nRanges *
                        sizeof(REFERENCE_TIME));
    pSave += nRanges * sizeof(REFERENCE_TIME);

    cbExtra += 2 * sizeof(int) + nEnvelopes *
        sizeof(DEXTER_AUDIO_VOLUMEENVELOPE) + nRanges * 2 *
        sizeof(REFERENCE_TIME);
    }

    // then comes the output pin envelopes and ranges prefixed by the number for each pin
    nEnvelopes = (int)m_pOutput->m_VolumeEnvelopeEntries;
    *(int *)pSave = nEnvelopes;
    pSave += sizeof(int);
    if (nEnvelopes)
        CopyMemory(pSave, m_pOutput->m_pVolumeEnvelopeTable, nEnvelopes *
            sizeof(DEXTER_AUDIO_VOLUMEENVELOPE));
    pSave += nEnvelopes * sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);

    cbExtra +=  sizeof(int) + nEnvelopes * sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);
    

    px->cbExtra = cbExtra;    // how big the extra stuff is


    HRESULT hr = pStream->Write(px, savesize, 0);
    QzTaskMemFree(px);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** WriteToStream FAILED")));
        return hr;
    }
    return NOERROR;
}

//############################################################################
// 
//############################################################################

//
// IPersistStream method
//
// load ourself back in
//
HRESULT CAudMixer::ReadFromStream(IStream *pStream)
{
    DbgLog((LOG_TRACE,1,TEXT("CAudMixer::ReadFromStream")));
    CheckPointer(pStream, E_POINTER);

    // we don't yet know how big the save data is...
    // all we know we have for sure is the beginning of the struct
    int savesize1 = sizeof(saveMix) - sizeof(LPBYTE);
    saveMix *px = (saveMix *)QzTaskMemAlloc(savesize1);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
        return E_OUTOFMEMORY;
    }
    
    HRESULT hr = pStream->Read(px, savesize1, 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    if (px->version != 1) {
        DbgLog((LOG_ERROR,1,TEXT("*** ERROR! Bad version file")));
        QzTaskMemFree(px);
        return S_OK;
    }

    // how much saved data was there, really?  Get the rest
    int savesize = savesize1 + px->cbExtra;
    DbgLog((LOG_TRACE,1,TEXT("Persisted data is %d bytes"), savesize));
    px = (saveMix *)QzTaskMemRealloc(px, savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
        return E_OUTOFMEMORY;
    }

    LPBYTE pSave = (LPBYTE)&px->pExtra;
    hr = pStream->Read(pSave, savesize - savesize1, 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    // create the rest of the input pins we need
    for (int x=1; x<px->nInputPins; x++) {
        CAudMixerInputPin *pInputPin = CreateNextInputPin(this);
        if(pInputPin != NULL)
            IncrementPinVersion();
    }

    AM_MEDIA_TYPE mt = px->mt;
    mt.pbFormat = (BYTE *)QzTaskMemAlloc(mt.cbFormat);
    // remember, the format is after the array
    CopyMemory(mt.pbFormat, pSave, mt.cbFormat);
    pSave += mt.cbFormat;

    set_OutputBuffering(px->cBuffers, px->msBuffer);

    // then comes the envelopes and ranges prefixed by the number for each pin
    POSITION pos = m_InputPinsList.GetHeadPosition();
    while( pos )
    {
        CAudMixerInputPin *pInputPin = m_InputPinsList.GetNext(pos);
        int nEnvelopes = *(int *)pSave;
        pSave += sizeof(int);
        pInputPin->put_VolumeEnvelope((DEXTER_AUDIO_VOLUMEENVELOPE *)pSave,
                        nEnvelopes);
        pSave += nEnvelopes * sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);
        int nRanges = *(int *)pSave;
        pSave += sizeof(int);
        pInputPin->InvalidateAll();
        REFERENCE_TIME *pStart = (REFERENCE_TIME *)pSave;
        pSave += nRanges * sizeof(REFERENCE_TIME);
        REFERENCE_TIME *pStop = (REFERENCE_TIME *)pSave;
        pSave += nRanges * sizeof(REFERENCE_TIME);
        for (x=0; x<nRanges; x++) {
            pInputPin->ValidateRange(*pStart, *pStop);
            pStart++; pStop++;
        }
    }

    // then comes the envelopes for ouput pin
    int nEnvelopes = *(int *)pSave;
    pSave += sizeof(int);

    if( nEnvelopes )
    {
        m_pOutput->put_VolumeEnvelope((DEXTER_AUDIO_VOLUMEENVELOPE *)pSave,
                        nEnvelopes);
        pSave += nEnvelopes * sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);
    }
    
    put_MediaType(&mt);
    FreeMediaType(mt);
    QzTaskMemFree(px);
    return S_OK;
}

//############################################################################
// 
//############################################################################

// how big is our save data?
//
int CAudMixer::SizeMax()
{
    int savesize = sizeof(saveMix) - sizeof(LPBYTE) + m_MixerMt.cbFormat;
    POSITION pos = m_InputPinsList.GetHeadPosition();
    while( pos )
    {
        CAudMixerInputPin *pInputPin = m_InputPinsList.GetNext(pos);
    savesize += sizeof(int) + pInputPin->m_VolumeEnvelopeEntries *
                        sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);
    savesize += sizeof(int) + pInputPin->m_cValid * sizeof(REFERENCE_TIME)
                    * 2;
    }

    // output pin
    savesize += sizeof(int) + m_pOutput->m_VolumeEnvelopeEntries *
                        sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);
    
    return savesize;
}



//############################################################################
// this returns the next enumerated pin, used for property pages. 
//############################################################################

STDMETHODIMP CAudMixer::NextPin(IPin **ppIPin)
{
    CAutoLock ListLock(&m_csPinList);
    POSITION pos = m_InputPinsList.GetHeadPosition();
    

    //find first not shown input pin
    int i=m_cInputs - m_ShownPinPropertyPageOnFilter;
    int j=0;
    CAudMixerInputPin *pInputPin=NULL;
    while(i>j)
    {
       pInputPin = m_InputPinsList.GetNext(pos);
       i--;
    }

    if(pInputPin)
    {
    *ppIPin=(IPin *) pInputPin;
    }
    else
    {
    //output pin
    if( m_pOutput )
    {
        ASSERT(m_cInputs==m_ShownPinPropertyPageOnFilter);
        *ppIPin=(IPin *)  m_pOutput;
    }

    }

    ASSERT(*ppIPin!=NULL);
    m_ShownPinPropertyPageOnFilter++;
    return NOERROR;
}


//############################################################################
// 
//############################################################################

//
// InitInputPinsList
//
void CAudMixer::InitInputPinsList()
{
    // Release all pins in the list and remove them from the list.
    CAutoLock ListLock(&m_csPinList);
    POSITION pos = m_InputPinsList.GetHeadPosition();
    while( pos )
    {
        CAudMixerInputPin *pInputPin = m_InputPinsList.GetNext(pos);
        pInputPin->Release();
    }
    m_cInputs = 0;     // Reset the pin count to 0.
    m_InputPinsList.RemoveAll();

} /* CAudMixer::InitInputPinsList */

//############################################################################
// 
//############################################################################

//
// CreateNextInputPin
//
CAudMixerInputPin *CAudMixer::CreateNextInputPin(CAudMixer *pFilter)
{
    DbgLog((LOG_TRACE,1,TEXT("CAudMixer: Create an input pin")));

    TCHAR szbuf[16];        // Temporary scratch buffer, can be smaller depending on max # of input pins
    int NextInputPinNumber =m_cInputs+1; // Next number to use for pin
    HRESULT hr = NOERROR;

    wsprintf(szbuf, TEXT("Input%d"), NextInputPinNumber);
#ifdef _UNICODE
    CAudMixerInputPin *pPin = new CAudMixerInputPin(NAME("Mixer Input"), pFilter,
        &hr, szbuf, NextInputPinNumber);
#else
    WCHAR wszbuf[16];
    ::MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, szbuf, -1, wszbuf, 16 );
    CAudMixerInputPin *pPin = new CAudMixerInputPin(NAME("Mixer Input"), pFilter,
        &hr, wszbuf, NextInputPinNumber);
#endif

    if( FAILED( hr ) || pPin == NULL )
    {
        delete pPin;
        pPin = NULL;
    }
    else
    {
        pPin->AddRef();
    pFilter->m_cInputs++;
    pFilter->m_InputPinsList.AddTail(pPin);
    }

    return pPin;
} /* CAudMixer::CreateNextInputPin */


//############################################################################
// 
//############################################################################

//
// DeleteInputPin
//
void CAudMixer::DeleteInputPin(CAudMixerInputPin *pPin)
{
    // Iterate our input pin list looking for the specified pin.
    // If we find the pin, delete it and remove it from the list.
    CAutoLock ListLock(&m_csPinList);
    POSITION pos = m_InputPinsList.GetHeadPosition();
    while( pos )
    {
        POSITION posold = pos;         // Remember this position
        CAudMixerInputPin *pInputPin = m_InputPinsList.GetNext(pos);
        if( pInputPin == pPin )
        {
            m_InputPinsList.Remove(posold);
            m_cInputs--;
            IncrementPinVersion();
            
            delete pPin;
            break;
        }
    }
} /* CAudMixer::DeleteInputPin */


//############################################################################
// 
//############################################################################

//
// GetNumFreePins
//
int CAudMixer::GetNumFreePins()
{
    // Iterate our pin list, counting pins that are not connected.
    int n = 0;
    CAutoLock ListLock(&m_csPinList);
    POSITION pos = m_InputPinsList.GetHeadPosition();
    while( pos )
    {
        CAudMixerInputPin *pInputPin = m_InputPinsList.GetNext(pos);
        if( !pInputPin->IsConnected() )
        {
            n++;
        }
    }
    return n;
} /* CAudMixer::GetNumFreePins */


//############################################################################
// 
//############################################################################

//
// GetPinNFromList
//
CAudMixerInputPin *CAudMixer::GetPinNFromList(int n)
{
    CAudMixerInputPin *pInputPin = NULL;
    // Validate the position being asked for
    CAutoLock ListLock(&m_csPinList);
    if( n < m_cInputs && n >= 0 )
    {
        // Iterate through the list, returning the pin at position n+1
        POSITION pos = m_InputPinsList.GetHeadPosition();
        n++;        // Convert zero starting index to 1

        while( n )
        {
            pInputPin = m_InputPinsList.GetNext(pos);
            n--;
        }
    }
    return pInputPin;
} /* CAudMixer::GetPinNFromList */

//############################################################################
// We have to inform the pospassthru about the input pins. Called by an
// output pin.
// !!! move this function to the output pin's?
//############################################################################

HRESULT CAudMixer::SetInputPins()
{
    HRESULT hr = S_OK;
    CAudMixerInputPin **ppInputPins, *pPin;

    // Iterate the list of input pins, storing all connected input pins
    // in an array.  Pass this array to CMultiPinPosPassThru::SetPins.
    ppInputPins = new CAudMixerInputPin * [m_cInputs];
    if( !ppInputPins )
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        //--- fill in the array of input pins
        int i = 0;
        CAutoLock ListLock(&m_csPinList);
        POSITION pos = m_InputPinsList.GetHeadPosition();
        while( pos )
        {
            pPin = m_InputPinsList.GetNext(pos);
            if( pPin->IsConnected() )
            {
                ppInputPins[i++] = pPin;
            }
        }

    if (m_pOutput)
        hr = m_pOutput->m_pPosition->SetPins( (CBasePin**)ppInputPins, NULL, i );
    }

    delete [] ppInputPins;
    return hr;

} /* CAudMixer::SetInputPins */

//############################################################################
// 
//############################################################################

//
// ISpecifyPropertyPages
//
STDMETHODIMP CAudMixer::GetPages(CAUUID *pPages)
{
    pPages->cElems = m_pOutput ? (2 + m_cInputs): (1+m_cInputs);  //1 for output, 1 for filter
    

    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID)*(pPages->cElems));
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }
    
    //Filter property page
    pPages->pElems[0] = CLSID_AudMixPropertiesPage;

    // Input pin property page 
    for ( int i=1; i<= m_cInputs; i++)
        pPages->pElems[i] = CLSID_AudMixPinPropertiesPage;

    // Output pin Property page
    if( m_pOutput )
    pPages->pElems[i] = CLSID_AudMixPinPropertiesPage;

    //to show all pins property page,
    //m_ShownPinPropertyPageOnFilter can only modified by this function and NextPin() function
    m_ShownPinPropertyPageOnFilter = 0;

    return NOERROR;
}

//############################################################################
// called from input pin's ClearCachedData. Every input pin that gets
// told to ClearCachedData will flush the output pin's volenventry. wonder why?
//############################################################################

void CAudMixer::ResetOutputPinVolEnvEntryCnt()
{
    if(m_pOutput) 
    {
        m_pOutput->m_iVolEnvEntryCnt=0;
    }
}

//############################################################################
// 
//############################################################################


// IAudMixer
STDMETHODIMP CAudMixer::get_MediaType(AM_MEDIA_TYPE *pmt)
{
    CAutoLock cAutolock(m_pLock);

    CheckPointer(pmt,E_POINTER);
    
    CopyMediaType(pmt, &m_MixerMt);
    
    return NOERROR;
}

//############################################################################
// 
// Media type can be changed only if the output pin is not connected yet.
//
//############################################################################

// IAudMixer
STDMETHODIMP CAudMixer::put_MediaType(const AM_MEDIA_TYPE *pmt)
{
    CAutoLock cAutolock(m_pLock);

    CheckPointer(pmt,E_POINTER);
    DbgLog((LOG_TRACE, 1, TEXT("CAudMixer::put_MediaType")));
    
    //if output already connected, refuse get new number
    if(m_pOutput)
    if ( m_pOutput->IsConnected() )
        return VFW_E_ALREADY_CONNECTED;

    POSITION pos = m_InputPinsList.GetHeadPosition();
    while( pos )
    {
        CAudMixerInputPin *pInputPin = m_InputPinsList.GetNext(pos);
        if( pInputPin && pInputPin->IsConnected() )
        return VFW_E_ALREADY_CONNECTED;
    }
   
    //check media 
    if( (pmt->majortype  != MEDIATYPE_Audio )    ||
    (pmt->subtype     != MEDIASUBTYPE_PCM)    ||
    (pmt->formattype != FORMAT_WaveFormatEx)||
    (pmt->cbFormat     < sizeof( WAVEFORMATEX ) ) )
    return VFW_E_TYPE_NOT_ACCEPTED;

    //only support 8, 16bits, pcm, mono or stereo
    WAVEFORMATEX * vih = (WAVEFORMATEX*) (pmt->pbFormat);
    
    if( ( vih->nChannels > 2)  ||
    ( vih->nChannels <1 )  ||
    ( ( vih->wBitsPerSample != 16 ) && 
      ( vih->wBitsPerSample != 8 )  ) )
      return VFW_E_TYPE_NOT_ACCEPTED;

    // !!! only accept 16 bit for now
    //
    if( vih->wBitsPerSample != 16 )
    {
        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    FreeMediaType(m_MixerMt);
    CopyMediaType(&m_MixerMt, pmt);

    // reconnect input pins?

    return NOERROR;
}


//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixer::put_InputPins( long Pins )
{
    if( m_cInputs >= Pins )
    {
        return NOERROR;
    }
    long diff = Pins - m_cInputs;
    HRESULT hr = 0;
    for( long i = 0 ; i < diff ; i++ )
    {
        CAudMixerInputPin * pPin = CreateNextInputPin( this );
        if( !pPin )
        {
            // let the destructor take care of cleaning up pins
            //
            return E_OUTOFMEMORY;
        }
    }
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixer::set_OutputBuffering(const int iNumber, const int mSecond )
{
    DbgLog((LOG_TRACE, 1, TEXT("CAudMixer: %d buffers %dms"), iNumber, mSecond));
    if(m_pOutput)
    {
        if ( m_pOutput->IsConnected() )
            return VFW_E_ALREADY_CONNECTED;
    }
    m_iOutputBufferCount=iNumber;
    m_msPerBuffer=mSecond; return NOERROR;
}

STDMETHODIMP CAudMixer::get_OutputBuffering( int *piNumber, int *pmSecond )
{ 
    CheckPointer( piNumber, E_POINTER );
    CheckPointer( pmSecond, E_POINTER );
    *piNumber=m_iOutputBufferCount;
    *pmSecond=m_msPerBuffer; return NOERROR;
}

//############################################################################
// called by the RenderEngine to wholesale clear all our pin's envelope
// boundaries
//############################################################################

STDMETHODIMP CAudMixer::InvalidatePinTimings( )
{
    for( int i = 0 ; i < m_cInputs ; i++ )
    {
        CAudMixerInputPin * pPin = GetPinNFromList( i );
        pPin->InvalidateAll( );
    }
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixer::get_CurrentAveragePower(double *pdAvePower)
{
    return E_NOTIMPL;
}

//############################################################################
// global function that sets a pin's property setter
//############################################################################

HRESULT PinSetPropertySetter( IAudMixerPin * pPin, const IPropertySetter * pSetter )
{
    CheckPointer( pPin, E_POINTER );
    CheckPointer( pSetter, E_POINTER );

    HRESULT hr;

    long Params = 0;
    DEXTER_PARAM * pParam = NULL;
    DEXTER_VALUE * pValue = NULL;
    IPropertySetter * ps = (IPropertySetter*) pSetter;
    hr = ps->GetProps( &Params, &pParam, &pValue );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // no parameters, so do nothing
    //
    if( Params == 0 )
    {
        return NOERROR;
    }

    long ValueOffset = 0;
    for( int i = 0 ; i < Params ; i++ )
    {
        DEXTER_PARAM * p = pParam + i;
        if( !DexCompareW(p->Name, L"Vol" ))
        {
            // found a volume param, go look at the values
            //
            long index = ValueOffset;
            long values = p->nValues;

            DEXTER_AUDIO_VOLUMEENVELOPE * pEnv = new DEXTER_AUDIO_VOLUMEENVELOPE[values];
            if( !pEnv )
            {
                return E_OUTOFMEMORY;
            }

            for( int v = 0 ; v < values ; v++ )
            {
                DEXTER_VALUE * dvp = pValue + v + index;
                VARIANT var = dvp->v;
                VARIANT var2;
                VariantInit( &var2 );
                hr = VariantChangeType( &var2, &var, 0, VT_R8 );
                ASSERT( !FAILED( hr ) );
                if( FAILED( hr ) )
                {
                    // !!! what should we do here?
                    //
		    delete pEnv;
                    return hr;
                }
                double level = 0.0;
                level = var2.dblVal;
                REFERENCE_TIME time = dvp->rt;
                pEnv[v].rtEnd = time;
                pEnv[v].dLevel = level;
                if( dvp->dwInterp == DEXTERF_JUMP )
                {
                    pEnv[v].bMethod = DEXTER_AUDIO_JUMP;
                }
                else if( dvp->dwInterp == DEXTERF_INTERPOLATE )
                {
                    pEnv[v].bMethod = DEXTER_AUDIO_INTERPOLATE;
                }
                else
                {
                    pEnv[v].bMethod = DEXTER_AUDIO_JUMP;
                }
            } // for all values for this param

            hr = pPin->put_VolumeEnvelope( pEnv, values );
	    delete pEnv;
            if( FAILED( hr ) )
            {
                return hr;
            }
        } // if it was "Vol"

        // !!! other Param types go here, like "Pan"
        // !!! what about other types that aren't recognized?

        // keep track of this
        //
        ValueOffset += p->nValues;

    } // for all Params

    hr = ps->FreeProps( Params, pParam, pValue );

    return NOERROR;
}

//############################################################################
// called on an input pin's EndOfStream, or in an input pin's Receive.
//############################################################################

HRESULT CAudMixer::TryToMix(REFERENCE_TIME rtReceived)
{

    DbgLog((LOG_TRACE,3,TEXT("MIX: TryToMix")));

    // all done
    if (m_fEOSSent) {
        DbgLog((LOG_TRACE,3,TEXT("EOS...")));
    return S_OK;
    }

    HRESULT hr = S_OK;
    LONG lSamplesToMix;
    REFERENCE_TIME rtNewSeg;

    // the first input audio pin...
    //
    POSITION pos = m_InputPinsList.GetHeadPosition();

    // set this to zero, we'll add 'em up as we go
    //
    int MixedPins=0;

    // go through each pin and find out how many samples it wants to mix
    // and where it's mixing from.
    //
    while( pos )
    {
        CAudMixerInputPin * pInput = m_InputPinsList.GetNext(pos);
    
        // don't do anything if it's not connected
        //
        if( !pInput->IsConnected( ) )
        {
            continue;
        }

        // don't do anything if this pin isn't enabled
        //
        BOOL fEnable = pInput->m_fEnable;
        if(fEnable==FALSE)
        {
            continue;
        }    

            // !!! optimize this
            //
        int count = pInput->m_SampleList.GetCount();
        if (count == 0) 
        {
            if( !pInput->m_fEOSReceived && ( pInput->IsValidAtTime( rtReceived ) == TRUE ) )
            {
                // we're expecting data from this pin.  Wait for it
                DbgLog((LOG_TRACE,3,TEXT("Still waiting for pin %d"), pInput->m_iPinNo));
                return S_OK;
            }

            continue;
        }
    
        //get the sample
        //
        IMediaSample *pSample = pInput->GetHeadSample();

        //get this sample's start and stop time.
        //
        REFERENCE_TIME        rtStart, rtStop;
        hr = pSample->GetTime( &rtStart, &rtStop );
        ASSERT(SUCCEEDED(hr));

        // add in the segment's times?
        //
        rtStart += pInput->m_tStart;
        rtStop += pInput->m_tStart;

        // set the variables in our array that tell what we're mixing
        //
        m_pPinTemp[MixedPins] = pInput;
        m_pStartTemp[MixedPins]     = rtStart; 
        m_pStopTemp[MixedPins]     = rtStop;

        // how many samples are we mixing? (left and right combined)
        //
        LONG ll = pSample->GetActualDataLength() / m_pOutput->BytesPerSample();

        // if we're the first pin, save off how many samples, so we can
        // make sure all other pins try to mix the same
        //
        if (MixedPins == 0) 
        {
            rtNewSeg = pInput->m_tStart;
            lSamplesToMix = ll;
        } 
        else if (lSamplesToMix != ll) 
        {
            ASSERT(FALSE);
            m_pOutput->DeliverEndOfStream();	// don't hang
            return E_FAIL;
        }

        // All pins should receive samples with equal time stamps
        //
        if (MixedPins > 0) 
        {
            if (m_pStartTemp[MixedPins-1] != rtStart || m_pStopTemp[MixedPins-1] != rtStop) 
            {
                ASSERT(FALSE);
                m_pOutput->DeliverEndOfStream();	// don't hang
                return E_FAIL;
            }
        }
    
        ASSERT( MixedPins < m_cInputs );
        MixedPins++;

    } //while(pos)

    // did we find any pins to mix? If not, send EOS and return
    //
    if(!MixedPins)
    {
        m_fEOSSent = TRUE;
        DbgLog((LOG_TRACE,3,TEXT("All done!")));
        return m_pOutput->DeliverEndOfStream();
    }

    // this is the time we start mixing
    //
    REFERENCE_TIME rtStart = m_pStartTemp[0];
    REFERENCE_TIME rtStop = m_pStopTemp[0];

    DbgLog((LOG_TRACE,3,TEXT("Mix %d pins, (%d, %d)"), MixedPins,
             (int)(rtStart / 10000), (int)(rtStop / 10000)));
    DbgLog((LOG_TRACE,3,TEXT("Mix %d samples"), lSamplesToMix));

    //get the output buffer
    //
    IMediaSample *pOutSample;
    rtStart -= rtNewSeg; // don't use NewSeg
    rtStop -= rtNewSeg;
    hr = m_pOutput->m_pAllocator->GetBuffer( &pOutSample, &rtStart, &rtStop, 0 );
    if (FAILED(hr))
    {
        return hr;
    }

    // get output buffer size
    //
    LONG lSize = pOutSample->GetSize() / m_pOutput->BytesPerSample();

    // if our buffer's too small, we're dead
    //
    if (lSize < lSamplesToMix)
    {
        ASSERT(FALSE); // leak
        return E_FAIL;
    }

    long DiscontOverdrive = 0;
    long Channels = m_pOutput->BytesPerSample() / ( m_pOutput->BitsPerSample() / 8 );
    long SamplesT = lSamplesToMix * Channels;

    long x;
    long dx;

remix:

    // load up our array of pointers
    //
    for(int j=0; j<MixedPins; j++)
    {
        IMediaSample *pSample = m_pPinTemp[j]->GetHeadSample();
        pSample->GetPointer(&m_pPinMix[j]);
    }

    // get the pointer to the output buffer
    //
    BYTE * pOut;
    pOutSample->GetPointer(&pOut);
    
#ifdef DEBUG
    static long lTotalSamplesMixed = 0;
    static DWORD dwTotalTime = 0;
    static double avgTime = 0.0;
    static DWORD dwMinTime = 0;
    static DWORD dwMaxTime = 0;
#endif

#ifdef DEBUG
    DWORD tick = timeGetTime();
#endif

#ifdef SMOOTH_FADEOFF
    if( MixedPins >= 1 )
#else
    if( MixedPins > 1 )
#endif
    {
        // calculate the maximum hotness for the last HOTSIZE
        // buffers we processed. This allows the ramp to change
        // more slowly over time, almost like an average
        //
        long max = 0;
        for( int l = 0 ; l < HOTSIZE ; l++ )
        {
            max = max( max, m_nHotness[l] );
        }

        
        // if we didnt' have to remix because of a large jump in the audio,
        // then figure out the ramp
        //
        if( DiscontOverdrive == 0 )
        {
            // we need to ramp audio from the last one to the current one
            //
            long rLastMax = 32767 * 32768 / m_nLastHotness;
            long rMax = 32767 * 32768 / max;
            DbgLog( ( LOG_TRACE, 2, "lhot: %ld, max: %ld, r: %ld to %ld", m_nLastHotness, max, rLastMax - 32768, rMax - 32768 ) );
            m_nLastHotness = max;

            // set the starting dividend, and the deltra increasor,
            // sorta like brezenham's or something
            //
            x = rLastMax;
            dx = ( rMax - rLastMax ) / SamplesT;
        }

        // set the max hotness to "full volume", if it gets hotter,
        // this number will only increase. (thus, it's never possible for
        // a hotness value in the hot array to be BELOW this maximum)
        //
        long max_pre = 32767;
        long max_post = 32767;
#ifdef DEBUG
        static long avgmaxclip = 0;
        static long avgmaxclipsamples = 0;
#endif

        __int16 * pDest = (__int16*) pOut;

        for( int l = SamplesT - 1 ; l >= 0 ; l-- )
        {
            // add each of the pins
            //
            register t = 0;
            for( j = MixedPins - 1 ; j >= 0 ; j-- )
            {
                // this is an array of pointers to bytes
                t += *((short*)(m_pPinMix[j]));
                m_pPinMix[j] += 2;
            }

            // see how much it's over driving the signal, if any
            // half-wave analysis is good enough
            //
            if( t > max_pre )
            {
                max_pre = t;
            }

            // multiply by the ramp to apply the volume envelope limiter
            // if our input signal is just clipping, hotness will be 32768,
            // and x = 32767 * 32768 / 32768. so t = t * 32767 * 32768 / ( 32768 * 32768 ),
            // or t = t * 32767 / 32768, and if t = 32768, then t = 32767. So 
            // it all works. No off by 1 errors.
            //
            t *= x;
            t = t >> 15;

            // ramp the volume divider to where it's supposed to end up
            //
            x = x + dx;

            // clip the result so we don't hear scratchies
            //
            if( t > 32767L )
            {
                // half-wave analysis is good enough
                max_post = max( max_post, t );

                t = 32767L;
            }
            else if( t < -32768L )
            {
                t = -32768L;
            }

#ifdef DEBUG
            avgmaxclip = avgmaxclip + max_post;
            avgmaxclipsamples++;
#endif

            *pDest++ = (__int16) t;
        }

        // if the maximum clip was too much, we need to stick in
        // a discontinuity for the hotness, go back and remix
        //
        if( max_post > MAX_CLIP + 32768 )
        {
            // force a discontinuity
            //
            DbgLog( ( LOG_TRACE, 2, "WAYYYYYYYYYY too hot (%ld), remixing with discontinuity jump", max_pre ) );
            DiscontOverdrive = max_pre;
            dx = 0;
            x = 32768 * 32768 / max_pre;
            goto remix;
        }

#ifdef DEBUG
        DbgLog( ( LOG_TRACE, 2, "            max = %ld, clip = %ld, avgc = %ld\r\n", max_pre, max_post - 32768, ( avgmaxclip / avgmaxclipsamples ) - 32768 ) );
#endif

        // shift the average buffer and stuff a new one in
        //
        memcpy( &m_nHotness[0], &m_nHotness[1], ( HOTSIZE - 1 ) * sizeof( long ) );

        // don't less hotness jump by more than a set amount, unless we got a 
        // serious discontinuity
        //
        if( DiscontOverdrive == 0 )
        {
            if( max_pre > m_nHotness[HOTSIZE-1] + HOT_JUMP_SLOPE )
            {
                max_pre = m_nHotness[HOTSIZE-1] + HOT_JUMP_SLOPE;
            }
            else if( max_pre < m_nHotness[HOTSIZE-1] - HOT_JUMP_SLOPE )
            {
                max_pre = m_nHotness[HOTSIZE-1] - HOT_JUMP_SLOPE;
            }
        }
        else
        {
            max_pre = DiscontOverdrive;
        }

        // set the new hotness
        //
        m_nHotness[HOTSIZE-1] = max_pre;
    }
    else
    {
        CopyMemory(pOut,m_pPinMix[0],m_pOutput->BytesPerSample() * lSamplesToMix);
    }

#ifdef DEBUG
    tick = timeGetTime() - tick;

    lTotalSamplesMixed++;
    dwTotalTime += tick;
    avgTime = dwTotalTime / ((double) lTotalSamplesMixed);
    if( (!dwMinTime) || (dwMinTime > tick) )
    {
        dwMinTime = tick;
    }
    if(dwMaxTime < tick)
    {
        dwMaxTime = tick;
    }

    DbgLog((LOG_TRACE, 2, TEXT("tick: %d, avgTime: %f, min: %d, max: %d"), tick, avgTime, dwMinTime, dwMaxTime));
#endif
    
    pOutSample->SetPreroll(FALSE);
    // !!! Discontinuity property
    pOutSample->SetDiscontinuity(FALSE);
    //set actual data Length
    pOutSample->SetActualDataLength(lSamplesToMix *
                        m_pOutput->BytesPerSample());

    //from new on, rtStart is the time without NewSeg
    pOutSample->SetTime(&rtStart,&rtStop);

    
    DbgLog((LOG_TRACE,3,TEXT("Delivering (%d, %d)"),
             (int)(rtStart / 10000), (int)(rtStop / 10000)));

    // Send sample downstream
    if( SUCCEEDED( hr ) )
    {
        //Pan output pin
        CMediaType *pmt=&(m_pOutput->m_mt);
        WAVEFORMATEX *pwfx    = (WAVEFORMATEX *) pmt->Format();
        if( (m_pOutput->m_dPan!=0.0) &&  (pwfx->nChannels==2) )
        PanAudio(pOut,m_pOutput->m_dPan, pwfx->wBitsPerSample, (int) lSamplesToMix);

        //apply volume envelope to output pin
        if(m_pOutput->m_pVolumeEnvelopeTable)
        {
    	    // we're looking at the envelope, which can change at any moment
    	    CAutoLock l(&m_csVol);

            // have to skew timeline time to offset time
            //
            REFERENCE_TIME Start = rtStart - m_pOutput->m_rtEnvStart;
            REFERENCE_TIME Stop = rtStop - m_pOutput->m_rtEnvStart;

            ApplyVolEnvelope( Start,  //output sample start time
                Stop,    //output sample stop time
                m_pOutput->m_rtEnvStop - m_pOutput->m_rtEnvStart, // duration of the envelope
                pOutSample,    //point to the sample
                pwfx,     //output sample format
                &(m_pOutput->m_VolumeEnvelopeEntries), //total table entries
                &(m_pOutput->m_iVolEnvEntryCnt),  //current table entry pointer
                m_pOutput->m_pVolumeEnvelopeTable); //envelope table

        }

        hr = m_pOutput->Deliver(pOutSample);
    }
    pOutSample->Release();

    for (int z=0; z<MixedPins; z++) 
    {
    IMediaSample *pSample = m_pPinTemp[z]->GetHeadSample();
    m_pPinTemp[z]->m_SampleList.RemoveHead();
    pSample->Release();
    }

    return hr;
} /* CAudMixerInputPin::TryToMix */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\audmix\amextra2.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef __AMEXTRA2__
#define __AMEXTRA2__


class CMediaSeeking :
    public IMediaSeeking,
    public CUnknown
{
    CBaseDispatch m_basedisp;


public:

    CMediaSeeking(const TCHAR *, LPUNKNOWN);
    CMediaSeeking(const TCHAR *, LPUNKNOWN, HRESULT *phr);
    virtual ~CMediaSeeking();

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
};


// A utility class which handles media position controls for many input pins
// connected to a single output pin

class CMultiPinPosPassThru :
    public CMediaSeeking
{
protected:

    IMediaSeeking **m_apMS;
    CRefTime *m_apOffsets;
    int m_iPinCount;
    CRefTime m_rtStartTime;
    CRefTime m_rtStopTime;
    double m_dRate;

    static const DWORD m_dwPermittedCaps;

public:

    CMultiPinPosPassThru(TCHAR *pName,LPUNKNOWN pUnk);
    ~CMultiPinPosPassThru();

    HRESULT SetPins(CBasePin **apPins,CRefTime *apOffsets,int iPinCount);
    HRESULT ResetPins(void);

//     // IMediaPosition methods

//     STDMETHODIMP get_Duration(REFTIME * plength);
//     STDMETHODIMP put_CurrentPosition(REFTIME llTime);
//     STDMETHODIMP get_StopTime(REFTIME * pllTime);
//     STDMETHODIMP put_StopTime(REFTIME llTime);
//     STDMETHODIMP get_PrerollTime(REFTIME * pllTime);
//     STDMETHODIMP put_PrerollTime(REFTIME llTime);
//     STDMETHODIMP get_Rate(double * pdRate);
//     STDMETHODIMP put_Rate(double dRate);

//     STDMETHODIMP get_CurrentPosition(REFTIME *pllTime) {
//         return E_NOTIMPL;
//     };

    // IMediaSeeking methods
    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities );
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);
    STDMETHODIMP GetTimeFormat(GUID *pFormat);
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);
    STDMETHODIMP IsFormatSupported( const GUID * pFormat);
    STDMETHODIMP QueryPreferredFormat( GUID *pFormat);
    STDMETHODIMP ConvertTimeFormat(LONGLONG * pTarget, const GUID * pTargetFormat,
                                   LONGLONG    Source, const GUID * pSourceFormat );
    STDMETHODIMP SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
                             , LONGLONG * pStop, DWORD StopFlags );

    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );
    STDMETHODIMP GetCurrentPosition( LONGLONG * pCurrent );
    STDMETHODIMP GetStopPosition( LONGLONG * pStop );
    STDMETHODIMP SetRate( double dRate);
    STDMETHODIMP GetRate( double * pdRate);
    STDMETHODIMP GetDuration( LONGLONG *pDuration);
    STDMETHODIMP GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest );
    STDMETHODIMP GetPreroll( LONGLONG *pllPreroll );
};

#endif // __AMEXTRA2__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\audmix\inpin.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#ifdef FILTER_DLL
#include <initguid.h>
#endif

#include "AudMix.h"
#include "prop.h"

// Using this pointer in constructor
#pragma warning(disable:4355)

//##############################################
//
// CAudMixerInputPin constructor
//
//###############################################

CAudMixerInputPin::CAudMixerInputPin(TCHAR *pName, CAudMixer *pFilter,
    HRESULT *phr, LPCWSTR pPinName, int iPinNo) :
    CBaseInputPin(pName, pFilter, pFilter, phr, pPinName), m_pFilter(pFilter),
    m_iPinNo(iPinNo), 
    m_cPinRef(0), 
    m_dPan(0.0),
    m_fEnable(TRUE),
    m_VolumeEnvelopeEntries(0),
    m_iVolEnvEntryCnt(0),
    m_rtEnvStart(0),
    m_rtEnvStop(0),
    m_UserID(0),
    m_SampleList(NAME("Queue of input samples"))
{
    ASSERT(pFilter);
    m_pVolumeEnvelopeTable=(DEXTER_AUDIO_VOLUMEENVELOPE *)NULL;
    ClearCachedData();

    // by default, this pin is on always
    m_cValid = 1;
    m_cValidMax = 10;
    m_pValidStart = (REFERENCE_TIME *)QzTaskMemAlloc(sizeof(REFERENCE_TIME) *
                    m_cValidMax);
    if (m_pValidStart == NULL)
        *phr = E_OUTOFMEMORY;
    m_pValidStop = (REFERENCE_TIME *)QzTaskMemAlloc(sizeof(REFERENCE_TIME) *
                    m_cValidMax);
    if (m_pValidStop == NULL) {
        *phr = E_OUTOFMEMORY;
        QzTaskMemFree(m_pValidStart);
        m_pValidStart = NULL;
    }
    if (m_pValidStart)
        *m_pValidStart = 0;
    if (m_pValidStop)
        *m_pValidStop = MAX_TIME;

} /* CAudMixerInputPin::CAudMixerInputPin */


//############################################################################
// 
//############################################################################

//
// CAudMixerInputPin destructor
//

CAudMixerInputPin::~CAudMixerInputPin()
{
    if (m_pValidStart)
        QzTaskMemFree(m_pValidStart);
    if (m_pValidStop)
        QzTaskMemFree(m_pValidStop);

    if(m_pVolumeEnvelopeTable)
        QzTaskMemFree( m_pVolumeEnvelopeTable );


} /* CAudMixerInputPin::~CAudMixerInputPin */


//############################################################################
// 
//############################################################################

//
// NonDelegatingAddRef
//
// We need override this method so that we can do proper reference counting
// on each input pin. The CBasePin implementation of NonDelegatingAddRef
// refcounts the filter, but this won't work for use since we need to know
// when we should delete individual pins.
//
STDMETHODIMP_(ULONG) CAudMixerInputPin::NonDelegatingAddRef()
{
#ifdef DEBUG
    // Update the debug only variable maintained by the base class
    m_cRef++;
    ASSERT(m_cRef > 0);
#endif

    // Now update our reference count
    m_cPinRef++;
    ASSERT(m_cPinRef > 0);

    // If our reference count == 2, then someone besides the filter has referenced
    // us.  Therefore we need to AddRef the filter.  The reference on the filter will
    // be released when our ref count gets back to 1.
//    if (2 == m_cPinRef)
//    m_pFilter->AddRef();

    return m_cPinRef;
} /* CAudMixerInputPin::NonDelegatingAddRef */


//############################################################################
// 
//############################################################################

//
// NonDelegatingRelease
//
// CAudMixerInputPin overrides this class so that we can take the pin out of our
// input pins list and delete it when its reference count drops to 1 and there
// is at least two free pins.
//
// Note that CreateNextInputPin holds a reference count on the pin so that
// when the count drops to 1, we know that no one else has the pin.
//
STDMETHODIMP_(ULONG) CAudMixerInputPin::NonDelegatingRelease()
{
#ifdef DEBUG
    // Update the debug only variable in CBasePin
    m_cRef--;
    ASSERT(m_cRef >= 0);
#endif

    // Now update our reference count
    m_cPinRef--;
    ASSERT(m_cPinRef >= 0);

    // if the reference count on the object has gone to one, remove
    // the pin from our output pins list and physically delete it
    // provided there are atealst two free pins in the list(including
    // this one)

    // Also, when the ref count drops to 0, it really means that our
    // filter that is holding one ref count has released it so we
    // should delete the pin as well.

    // since DeleteINputPin will wipe out "this"'s stack, we need
    // to save this off as a local variable.
    //
    ULONG ul = m_cPinRef;

    if ( 0 == ul )
    {
    m_pFilter->DeleteInputPin(this);
    }
    return ul;
} /* CAudMixerInputPin::NonDelegatingRelease */

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerInputPin::NonDelegatingQueryInterface (REFIID riid, void **ppv)
{ 

    if (IsEqualIID(IID_ISpecifyPropertyPages, riid))
    return GetInterface((ISpecifyPropertyPages *)this, ppv);
    else if (riid == IID_IAudMixerPin) 
    return GetInterface((IAudMixerPin *) this, ppv);
    else if (riid == IID_IAMAudioInputMixer) 
    return GetInterface((IAMAudioInputMixer *) this, ppv);
    else
    return CBaseInputPin::NonDelegatingQueryInterface(riid, ppv);

} // NonDelegatingQueryInterface //

//############################################################################
// 
//############################################################################

//
// CheckMediaType, inputpin
//
HRESULT CAudMixerInputPin::CheckMediaType(const CMediaType *pmt)
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    DbgLog((LOG_TRACE,3,TEXT("CAudMixIn::CheckMediaType")));
    CheckPointer(pmt, E_POINTER);

    // Check major type
    const CLSID *pType = pmt->Type();
    if( MEDIATYPE_Audio != *pType )
        return VFW_E_TYPE_NOT_ACCEPTED;

    // Check subtypes
    const CLSID *pSubtype = pmt->Subtype();
    if( *pSubtype == MEDIASUBTYPE_PCM )
    {
    
    // check that sample rate & bitrate match user wanted
    
    WAVEFORMATEX *pwfx    = (WAVEFORMATEX *) pmt->Format();
    CMediaType *pmtNow    = &m_pFilter->m_MixerMt;
    WAVEFORMATEX *pwfxNow    = (WAVEFORMATEX *) pmtNow->Format();

    if (pwfx->nChannels != pwfxNow->nChannels) {
        DbgLog((LOG_TRACE, 1, TEXT("input's # channels doesn't match.")));
        return VFW_E_TYPE_NOT_ACCEPTED;
    }
    
    if (pwfx->nSamplesPerSec != pwfxNow->nSamplesPerSec ||
        pwfx->wBitsPerSample != pwfxNow->wBitsPerSample) 
    {
        DbgLog((LOG_TRACE, 1, TEXT("input format doesn't match user wanted format.")));
        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    if (pwfx->wBitsPerSample != pwfxNow->wBitsPerSample) {
        DbgLog((LOG_TRACE, 1, TEXT("input's bits/sample doesn't match.")));
        return VFW_E_TYPE_NOT_ACCEPTED;
    }
    
        return NOERROR;
    }

    return VFW_E_TYPE_NOT_ACCEPTED;
    
} /* CAudMixerInputPin::CheckMediaType */

//############################################################################
// 
//############################################################################

//
// GetMediaType
//
HRESULT CAudMixerInputPin::GetMediaType( int iPosition, CMediaType *pmt )
{
    if( iPosition < 0 )
    {
        return E_INVALIDARG;
    }

    switch( iPosition )
    {
    case 0:
    {
        //
        // All input pins only accept one kind media type ===> which is filter's m_MixerMt
        //
        *pmt = m_pFilter->m_MixerMt;
    }
    default:
        return VFW_S_NO_MORE_ITEMS;

    }

} /* CAudMixerInputPin::GetMediaType */

//############################################################################
// 
//############################################################################

//
// SetMediaType
//
HRESULT CAudMixerInputPin::SetMediaType(const CMediaType *pmt)
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    HRESULT hr;
    const CLSID *pType = pmt->Type();

    hr = CBasePin::SetMediaType(pmt);

    return hr;
}

//############################################################################
// 
//############################################################################

//
// BreakConnect
//
HRESULT CAudMixerInputPin::BreakConnect()
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    m_mt.SetType(&GUID_NULL);

    return CBaseInputPin::BreakConnect();
} /* CAudMixerInputPin::BreakConnect */


//############################################################################
// 
//############################################################################

//
// EndOfStream
//
HRESULT CAudMixerInputPin::EndOfStream()
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    HRESULT hr = S_OK;

    CAutoLock ReceiveLock(&m_pFilter->m_csReceive);

    m_fEOSReceived = TRUE;
    
    m_pFilter->TryToMix(MAX_TIME);

    return hr;

} /* CAudMixerInputPin::EndOfStream */


//############################################################################
// 
//############################################################################

HRESULT CAudMixerInputPin::Inactive()
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    // make sure receive is done
    CAutoLock l(&m_pFilter->m_csReceive);
    ClearCachedData();

    return CBaseInputPin::Inactive();
}

//############################################################################
// 
//############################################################################

HRESULT CAudMixerInputPin::ClearCachedData()
{

    IMediaSample *pSample;
    while (pSample = GetHeadSample()) {
    pSample->Release();

    m_SampleList.RemoveHead();
    }
    m_lBytesUsed = 0;
    m_fEOSReceived = FALSE;

    m_pFilter->m_fEOSSent = FALSE;
    m_iVolEnvEntryCnt=0;
    
    //reset output pin's cnt
    m_pFilter->ResetOutputPinVolEnvEntryCnt();
    
    return S_OK;
}

//############################################################################
// 
//############################################################################

//
// BeginFlush
//
HRESULT CAudMixerInputPin::BeginFlush()
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    // sending the message downstream. 
    HRESULT hr = S_OK;
    
    if (0 == m_pFilter->m_cFlushDelivery++ && m_pFilter->m_pOutput) {
        DbgLog((LOG_TRACE,3,TEXT("CAudMixIn::BeginFlush")));
    hr = m_pFilter->m_pOutput->DeliverBeginFlush();
    }

    if( SUCCEEDED( hr ) )
        hr = CBaseInputPin::BeginFlush();

    // wait for receive to finish before nuking its data
    CAutoLock l(&m_pFilter->m_csReceive);

    m_pFilter->ClearHotnessTable( );

    // nuke away!
    ClearCachedData();
    
    return hr;
} /* CAudMixerInputPin::BeginFlush */


//############################################################################
// 
//############################################################################

//
// EndFlush
//
HRESULT CAudMixerInputPin::EndFlush()
{
    CAutoLock cAutolock(m_pFilter->m_pLock);


    // sending the message downstream.
    HRESULT hr = S_OK;

    if (1 == m_pFilter->m_cFlushDelivery-- && m_pFilter->m_pOutput)
    {
        DbgLog((LOG_TRACE,3,TEXT("CAudMixIn::EndFlush")));
    hr = m_pFilter->m_pOutput->DeliverEndFlush();
    m_pFilter->m_bNewSegmentDelivered = FALSE;
    }

    if( SUCCEEDED( hr ) )
        hr = CBaseInputPin::EndFlush();

    return hr;
} /* CAudMixerInputPin::EndFlush */

//############################################################################
// 
//############################################################################

//
// NewSegment
//                
HRESULT CAudMixerInputPin::NewSegment(REFERENCE_TIME tStart, REFERENCE_TIME tStop,
    double dRate)
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    // a new time needs to be delivered again - we might not be flushed
    if (tStart != m_tStart)
    m_pFilter->m_bNewSegmentDelivered = FALSE;
    
    HRESULT hr = S_OK;
    
    if (!m_pFilter->m_bNewSegmentDelivered && m_pFilter->m_pOutput) {
        DbgLog((LOG_TRACE,3,TEXT("CAudMixIn::NewSegment %d"),
                        (int)(tStart / 10000)));
    hr = m_pFilter->m_pOutput->DeliverNewSegment(tStart, tStop, dRate);
    }

    if( SUCCEEDED( hr ) )
    {
    m_pFilter->m_bNewSegmentDelivered = TRUE;
        hr = CBaseInputPin::NewSegment(tStart, tStop, dRate);
    }

    return hr;
} /* CAudMixerInputPin::NewSegment */


//############################################################################
// 
//############################################################################

//
// Receive
//
HRESULT CAudMixerInputPin::Receive(IMediaSample *pSample)
{
    IMediaSample *pOutSample = NULL;

    // We are receiving data, we better have an output pin
    ASSERT(m_pFilter->m_pOutput);
    
    CAutoLock ReceiveLock(&m_pFilter->m_csReceive);

    if( m_fEOSReceived )
        return S_FALSE;

    if(m_fEnable==FALSE)
    return NOERROR;

    HRESULT hr = CBaseInputPin::Receive(pSample);

    if( SUCCEEDED( hr ) )
    {
    // Keep this sample and add it to the sample list
    pSample->AddRef();                  // keep new one
    m_SampleList.AddTail(pSample);

    //Pan audio?
    WAVEFORMATEX * vih = (WAVEFORMATEX*) m_mt.Format( );
    if( (m_dPan!=0.0) &&  (vih->nChannels==2) )
    {
        
        BYTE * pIn;
        pSample->GetPointer(&pIn);
        long Length=pSample->GetActualDataLength();

        Length /=(long)( vih->nBlockAlign );

        PanAudio(pIn,m_dPan, vih->wBitsPerSample, (int) Length);
    }

    REFERENCE_TIME rtStart, rtStop;
    hr = pSample->GetTime(&rtStart, &rtStop);
    if (FAILED(hr))
        return hr;    // we can't mix without time stamps!
     DbgLog((LOG_TRACE,3,TEXT("MIX: Receive pin %d (%d, %d) %d bytes"),
            m_iPinNo, (int)(rtStart/10000), (int)(rtStop/10000),
            (int)(pSample->GetActualDataLength())));

    rtStart += m_tStart;
    rtStop += m_tStart;
    DbgLog((LOG_TRACE,3,TEXT("Adding NewSeg of %d"),(int)(m_tStart/10000)));

    //apply volume envelope
    if(m_pVolumeEnvelopeTable)
    {
	// we're looking at the envelope, which can change at any moment
        CAutoLock l(&m_pFilter->m_csVol);

        // the volume enveloping code assumes that
        // the incoming times are in terms of it's offsets,
        // not in terms of timeline time. If this pin has an audio
        // envelope, ValidateRange will have been called on it,
        // and it will be the first validate range called.
        //
        REFERENCE_TIME Start, Stop;
        Start = rtStart - m_rtEnvStart;
        Stop = rtStop - m_rtEnvStart;
    
      ApplyVolEnvelope( Start,  //output sample start time
             Stop,    //output sample stop time
             m_rtEnvStop - m_rtEnvStart,
             pSample,    //point to the sample
             vih,     //output sample format
             &m_VolumeEnvelopeEntries,   //total Envelope Entries
             &m_iVolEnvEntryCnt,    //current Entry point
             m_pVolumeEnvelopeTable);    //Envelope Table
    }
    
    // !!! I am assuming everything received is wholly within a valid range!

    // mix
    hr = m_pFilter->TryToMix(rtStart);

    } // endif SUCCEEDED(hr) base pin receive.

    return hr;
}

//############################################################################
// 
//############################################################################

BOOL CAudMixerInputPin::IsValidAtTime(REFERENCE_TIME rt)
{
    for (int z=0; z<m_cValid; z++) {
    if (rt >= m_pValidStart[z] && rt < m_pValidStop[z])
        return TRUE;
    }
    return FALSE;
}

//############################################################################
// 
//############################################################################

//
// CompleteConnect
//
HRESULT CAudMixerInputPin::CompleteConnect(IPin *pReceivePin)
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    ASSERT(m_Connected == pReceivePin);
    HRESULT hr = CBaseInputPin::CompleteConnect(pReceivePin);

    // Since this pin has been connected up, create another input pin
    // if there are no unconnected pins.
    if( SUCCEEDED( hr ) )
    {
        int n = m_pFilter->GetNumFreePins();

        if( n == 0 )
        {
            // No unconnected pins left so spawn a new one
            CAudMixerInputPin *pInputPin = m_pFilter->CreateNextInputPin(m_pFilter);
            if( pInputPin != NULL )
                m_pFilter->IncrementPinVersion();
        }

    }

    return hr;
} /* CAudMixerInputPin::CompleteConnect */


//############################################################################
// 
//############################################################################

// ISpecifyPropertyPages 
STDMETHODIMP CAudMixerInputPin::GetPages(CAUUID *pPages)
{
    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID)*1);
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }
    pPages->pElems[0] = CLSID_AudMixPinPropertiesPage;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

//
// methords in  IAMAudioInputMixer
//    
STDMETHODIMP CAudMixerInputPin::put_Pan(double Pan)
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    //can not change property if the filter is not currently stopped
    if(!IsStopped() )
      return E_FAIL;    //VFW_E_WRONG_STATE;
  
    m_dPan = Pan;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerInputPin::get_Pan( double FAR* pPan )
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    CheckPointer(pPan,E_POINTER);

    *pPan = m_dPan;

    return NOERROR;

} // get_Pan

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerInputPin::put_Enable(BOOL fEnable)
{
 
    CAutoLock cAutolock(m_pFilter->m_pLock);

    //can not change property if the filter is not currently stopped
    if(!IsStopped() )
      return E_FAIL;        //VFW_E_WRONG_STATE;
  
    m_fEnable = fEnable;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerInputPin::get_Enable(BOOL *pfEnable)
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    CheckPointer(pfEnable,E_POINTER);

    *pfEnable=m_fEnable;

    return NOERROR;

} // get_Enable


//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerInputPin::InvalidateAll()
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    m_cValid = 0;
    return NOERROR;
}


STDMETHODIMP CAudMixerInputPin::ValidateRange(REFERENCE_TIME rtStart,
                        REFERENCE_TIME rtStop)
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    if (m_cValid == m_cValidMax) {
        m_cValidMax += 10;
        m_pValidStart = (REFERENCE_TIME *)QzTaskMemRealloc(m_pValidStart,
                sizeof(REFERENCE_TIME) * m_cValidMax);
        if (m_pValidStart == NULL)
            return E_OUTOFMEMORY;
        m_pValidStop = (REFERENCE_TIME *)QzTaskMemRealloc(m_pValidStop,
                sizeof(REFERENCE_TIME) * m_cValidMax);
        if (m_pValidStop == NULL)
            return E_OUTOFMEMORY;
    }

    m_pValidStart[m_cValid] = rtStart;
    m_pValidStop[m_cValid] = rtStop;
    m_cValid++;

    return NOERROR;
}

STDMETHODIMP CAudMixerInputPin::SetEnvelopeRange( REFERENCE_TIME rtStart,
                                                 REFERENCE_TIME rtStop )
{
    m_rtEnvStart = rtStart;
    m_rtEnvStop = rtStop;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

//
// When *ppsAudioVolumeEnvelopeTable=NULL return m_VolumeEnvelopeEntries
// so, user can allocte/release memory space
//
STDMETHODIMP CAudMixerInputPin::get_VolumeEnvelope(DEXTER_AUDIO_VOLUMEENVELOPE **ppsAudioVolumeEnvelopeTable, 
            int *ipEntries )
{
    // we're looking at the envelope, which can change at any moment
    CAutoLock l(&m_pFilter->m_csVol);

    CheckPointer(ipEntries,E_POINTER);

    *ipEntries=m_VolumeEnvelopeEntries;

    if(*ppsAudioVolumeEnvelopeTable != NULL)
    {
    int iSize=*ipEntries * sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);
    
    CopyMemory( (PBYTE)*ppsAudioVolumeEnvelopeTable,(PBYTE)m_pVolumeEnvelopeTable, iSize);
    }

    return NOERROR;
}

//############################################################################
// 
//############################################################################

//
// if (m_pVolumeEnvelopeTable!=NULL)
//    insert input envelope table to existed m_pVolumeEnvelopeTable table
//  else
//    input table =m_pVolumeEnvelopeTable
//
STDMETHODIMP CAudMixerInputPin::put_VolumeEnvelope(const DEXTER_AUDIO_VOLUMEENVELOPE *psAudioVolumeEnvelopeTable,
                const int iEntries)
{ 
    // we're touching the envelope
    CAutoLock l(&m_pFilter->m_csVol);

    if(!iEntries) return NOERROR;

    DbgLog((LOG_TRACE, 1, TEXT("CAudMixIn::put_Envelope %d"), iEntries));

    CheckPointer(psAudioVolumeEnvelopeTable,E_POINTER);

    putVolumeEnvelope( psAudioVolumeEnvelopeTable, //current input table
            iEntries, // current input entries
            &m_pVolumeEnvelopeTable    , //existed table    
            &m_VolumeEnvelopeEntries); //existed table netries

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerInputPin::ClearVolumeEnvelopeTable()
{ 

    // we're touching the envelope
    CAutoLock l(&m_pFilter->m_csVol);

    //clear existed VolumeEnvelope Array entry cnt
    m_VolumeEnvelopeEntries =0;

    //free pre-exist table
    if (m_pVolumeEnvelopeTable)
        QzTaskMemFree(m_pVolumeEnvelopeTable);
    m_pVolumeEnvelopeTable = NULL;

    //reset entry point
    m_iVolEnvEntryCnt=0;

    return NOERROR;

}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerInputPin::put_PropertySetter( const IPropertySetter * pSetter )
{
    return PinSetPropertySetter( this, pSetter );
}


//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerInputPin::put_UserID(long ID)
{
    m_UserID = ID;
    return S_OK;
}


//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerInputPin::get_UserID(long *pID)
{
    CheckPointer(pID, E_POINTER);
    *pID = m_UserID;
    return S_OK;
}


//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerInputPin::OverrideVolumeLevel(double dVol)
{
    DEXTER_AUDIO_VOLUMEENVELOPE env;
    env.rtEnd = 0;
    env.dLevel = dVol;
    env.bMethod = DEXTERF_JUMP;

    ClearVolumeEnvelopeTable();
    HRESULT hr = put_VolumeEnvelope(&env, 1);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\audmix\amextra2.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>        // ActiveMovie base class definitions
#include <mmsystem.h>       // Needed for definition of timeGetTime
#include <limits.h>         // Standard data type limit definitions
#include <measure.h>        // Used for time critical log functions

#include "amextra2.h"

#pragma warning(disable:4355)


// Implements the CMultiPinPosPassThru class

// restrict capabilities to what we know about today and don't allow
// AM_SEEKING_CanGetCurrentPos and AM_SEEKING_CanPlayBackwards;
const DWORD CMultiPinPosPassThru::m_dwPermittedCaps = AM_SEEKING_CanSeekAbsolute |
    AM_SEEKING_CanSeekForwards |
    AM_SEEKING_CanSeekBackwards |
    AM_SEEKING_CanGetStopPos |
    AM_SEEKING_CanGetDuration;

CMultiPinPosPassThru::CMultiPinPosPassThru(TCHAR *pName,LPUNKNOWN pUnk) :
    m_apMS(NULL),
    m_iPinCount(0),
    CMediaSeeking(pName, pUnk)
{
}


HRESULT CMultiPinPosPassThru::SetPins(CBasePin **apPins,
				      CRefTime *apOffsets,
				      int iPinCount)
{
    int i;

    // Discard our current pointers
    ResetPins();

    // Reset our start/stop times
    m_rtStartTime = 0;
    m_rtStopTime = 0;
    m_dRate = 1.0;

    // Check that all pointers are valid
    if (!apPins) {
        DbgBreak("bad pointer");
        return E_POINTER;
    }

    // We need each pin to be connected
    for (i = 0; i < iPinCount; i++)
        if (apPins[i] == NULL)
            return E_POINTER;

    // Allocate an array of pointers to the pin's IMediaSeeking interfaces.
    m_apMS = new IMediaSeeking*[iPinCount];

    if (m_apMS == NULL) {
        return E_OUTOFMEMORY;
    }

    // Reset in case of trouble
    for (i = 0; i < iPinCount; i++) {
        m_apMS[i] = NULL;
    }

    m_iPinCount = iPinCount;

    // Get the IMediaSeeking interface for each pin
    for (i = 0; i < iPinCount; i++) {
        IPin *pConnected;

        HRESULT hr = apPins[i]->ConnectedTo(&pConnected);
        if (FAILED(hr)) {
            ResetPins();
            return hr;
        }

        IMediaSeeking * pMS;
        hr = pConnected->QueryInterface(IID_IMediaSeeking, (void **) &pMS);
        pConnected->Release();

        if (FAILED(hr)) {
            ResetPins();
            return hr;
        }
        m_apMS[i] = pMS;
    }

    // Finally set the pointer up if all went well

    m_apOffsets = apOffsets;

    //get_Duration(&m_rtStopTime);
    return NOERROR;
}


HRESULT CMultiPinPosPassThru::ResetPins(void)
{
    // Must be called when a pin is connected
    if (m_apMS != NULL) {
        for (int i = 0; i < m_iPinCount; i++)
            if( m_apMS[i] )
                m_apMS[i]->Release();

        delete [] m_apMS;
        m_apMS = NULL;
    }
    return NOERROR;
}


CMultiPinPosPassThru::~CMultiPinPosPassThru()
{
    ResetPins();
}

// IMediaSeeking methods
STDMETHODIMP CMultiPinPosPassThru::GetCapabilities( DWORD * pCapabilities )
{
	CheckPointer( pCapabilities, E_POINTER );
    // retrieve the mask of capabilities that all upstream pins
    // support
    DWORD dwCapMask = m_dwPermittedCaps;

    for(int i = 0; i < m_iPinCount; i++)
    {
        DWORD dwCaps;
        m_apMS[i]->GetCapabilities(&dwCaps);
        dwCapMask &= dwCaps;

        if(dwCapMask == 0)
            break;
    }

    *pCapabilities = dwCapMask;
    return S_OK;
}

STDMETHODIMP CMultiPinPosPassThru::CheckCapabilities( DWORD * pCapabilities )
{
	CheckPointer( pCapabilities, E_POINTER );
    // retrieve the mask of capabilities that all upstream pins
    // support

    DWORD dwCapRequested = *pCapabilities;
    (*pCapabilities) &= m_dwPermittedCaps;
    
    for(int i = 0; i < m_iPinCount; i++)
    {
        m_apMS[i]->GetCapabilities(pCapabilities);
    }

    return dwCapRequested ?
        ( dwCapRequested == *pCapabilities ? S_OK : S_FALSE ) :
        E_FAIL;
}

STDMETHODIMP CMultiPinPosPassThru::SetTimeFormat(const GUID * pFormat)
{
	CheckPointer( pFormat, E_POINTER );
	HRESULT hr = E_FAIL;

    for(int i = 0; i < m_iPinCount; i++)
    {
        hr = m_apMS[i]->SetTimeFormat( pFormat );
		if( FAILED( hr ) ) return hr;
    }

	return hr;
}

STDMETHODIMP CMultiPinPosPassThru::GetTimeFormat(GUID *pFormat)
{
	// They're all the same, so return the first
    return m_apMS[0]->GetTimeFormat( pFormat );
}

STDMETHODIMP CMultiPinPosPassThru::IsUsingTimeFormat(const GUID * pFormat)
{
	CheckPointer( pFormat, E_POINTER );
	GUID guidFmt;
	HRESULT hr = m_apMS[0]->GetTimeFormat( &guidFmt );
	if( SUCCEEDED( hr ) )
	{
		return *pFormat == guidFmt ? S_OK : S_FALSE;
	}
	return hr;
}

STDMETHODIMP CMultiPinPosPassThru::IsFormatSupported( const GUID * pFormat)
{
	CheckPointer( pFormat, E_POINTER );
	HRESULT hr = S_FALSE;

	// All inputs must support the format
    for(int i = 0; i < m_iPinCount; i++)
    {
        hr = m_apMS[i]->IsFormatSupported( pFormat );
		if( hr == S_FALSE ) return hr;
    }
	return hr;
}

STDMETHODIMP CMultiPinPosPassThru::QueryPreferredFormat( GUID *pFormat)
{
	CheckPointer( pFormat, E_POINTER );
	HRESULT hr;
	// Take the first input with a preferred format that's supported by all
	// other inputs (for now)
    for(int i = 0; i < m_iPinCount; i++)
    {
        hr = m_apMS[i]->QueryPreferredFormat( pFormat );
		if( hr == S_OK )
		{
			if( S_OK == IsFormatSupported( pFormat ) )
			{
				return S_OK;
			}
		}
    }
    return S_FALSE;
}

STDMETHODIMP CMultiPinPosPassThru::ConvertTimeFormat(LONGLONG * pTarget, const GUID * pTargetFormat,
                               LONGLONG    Source, const GUID * pSourceFormat )
{
    // We used to check pointers here, but since we don't actually derefernce any of them here just
    // pass them through.  If anyone we call cares, they should check them.

    HRESULT hr;
    // Find an input that can do the conversion
    for(int i = 0; i < m_iPinCount; i++)
    {
	hr = m_apMS[i]->ConvertTimeFormat(pTarget, pTargetFormat, Source, pSourceFormat);
	if( hr == NOERROR ) return hr;
    }
    return E_FAIL;
}

STDMETHODIMP CMultiPinPosPassThru::SetPositions(
    LONGLONG * pCurrent, DWORD CurrentFlags,
    LONGLONG * pStop, DWORD StopFlags )
{
	CheckPointer( pCurrent, E_POINTER );
	CheckPointer( pStop, E_POINTER );

    m_rtStartTime = *pCurrent;
    m_rtStopTime = *pStop;
    
    HRESULT hr = S_OK;
    for(int i = 0; i < m_iPinCount; i++)
    {
        LONGLONG llCurrent = *pCurrent;
        LONGLONG llStop = *pStop;
        if(m_apOffsets)
        {
            llCurrent += m_apOffsets[i];
            llStop += m_apOffsets[i];
        }

        hr = m_apMS[i]->SetPositions(&llCurrent, CurrentFlags, &llStop, StopFlags);
        if(FAILED(hr))
            break;
    }

    return hr;
}


STDMETHODIMP CMultiPinPosPassThru::GetPositions( LONGLONG * pCurrent, LONGLONG * pStop )
{
    HRESULT hr = m_apMS[0]->GetPositions(pCurrent, pStop);
    if(SUCCEEDED(hr))
    {
        if(m_apOffsets)
        {
	    if (pCurrent)
		(*pCurrent) -= m_apOffsets[0];
	    if (pStop)
		(*pStop) -= m_apOffsets[0];
        }

    
        for(int i = 1; i < m_iPinCount; i++)
        {
            LONGLONG llCurrent = 0;
            LONGLONG llStop = 0;

	    if (pCurrent)
	    {
		if (pStop)
		    hr = m_apMS[i]->GetPositions(&llCurrent, &llStop);
		else
		    hr = m_apMS[i]->GetPositions(&llCurrent, NULL);
	    }
	    else
	    {
		if (pStop)
                {
		    hr = m_apMS[i]->GetPositions(NULL, &llStop);
                    ASSERT( !FAILED( hr ) );
                }
		else
		{
		    ASSERT(!"Called GetPositions with 2 NULL pointers!!");
		    break;
		}
	    }



            if(SUCCEEDED(hr))
            {
                if(m_apOffsets)
                {
		    llCurrent -= m_apOffsets[i];
		    llStop -= m_apOffsets[i];
                }

		if (pCurrent)
		    *pCurrent = min(llCurrent, *pCurrent);
		if (pStop)
		    *pStop = max(llStop, *pStop);
            }
            else
            {
                break;
            }
        }
    } 

    return hr;
}

STDMETHODIMP CMultiPinPosPassThru::GetCurrentPosition( LONGLONG * pCurrent )
{
	// This will be the same for all our inputs
	CheckPointer( pCurrent, E_POINTER );
    return m_apMS[0]->GetCurrentPosition( pCurrent );
}

STDMETHODIMP CMultiPinPosPassThru::GetStopPosition( LONGLONG * pStop )
{
    CheckPointer( pStop, E_POINTER );
    return GetPositions(NULL, pStop);
}

STDMETHODIMP CMultiPinPosPassThru::SetRate( double dRate)
{
    m_dRate = dRate;
    
    HRESULT hr = S_OK;
    for(int i = 0; i < m_iPinCount; i++)
    {
        hr =m_apMS[i]->SetRate(dRate);
        if(FAILED(hr))
            break;
    }
    return hr;
}

STDMETHODIMP CMultiPinPosPassThru::GetRate( double * pdRate)
{
	CheckPointer( pdRate, E_POINTER );
    *pdRate = m_dRate;
    return S_OK;
}

STDMETHODIMP CMultiPinPosPassThru::GetDuration( LONGLONG *pDuration)
{
    CheckPointer( pDuration, E_POINTER );
    LONGLONG llStop;
    HRESULT hr;

    *pDuration = 0;

    for(int i = 0; i < m_iPinCount; i++)
    {
        hr = m_apMS[i]->GetDuration(&llStop);

        if(SUCCEEDED(hr))
            *pDuration = max(llStop, *pDuration);
        else
            break;
    }

    DbgLog((LOG_TRACE, 4, TEXT("CMultiPinPosPassThru::GetDuration returning %d"), *pDuration));
    return hr;
}

STDMETHODIMP CMultiPinPosPassThru::GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest )
{
	CheckPointer( pEarliest, E_POINTER );
	CheckPointer( pLatest, E_POINTER );
	LONGLONG llMin, llMax;
	HRESULT hr = m_apMS[0]->GetAvailable( pEarliest, pLatest );

	// Return the maximum early and the minimum late times
	if( SUCCEEDED( hr ) )
	{
		for(int i = 1; i < m_iPinCount; i++)
		{
			hr = m_apMS[i]->GetAvailable( &llMin, &llMax );
			if(FAILED(hr))
				break;
			if( llMin > *pEarliest ) *pEarliest = llMin;
			if( llMax < *pLatest ) *pLatest = llMax;
		}
	}

	// Make sure our earliest time is less than or equal to our latest time
	if( SUCCEEDED( hr ) )
	{
		if( *pEarliest > *pLatest )
		{
			*pEarliest = 0;
			*pLatest = 0;
			hr = S_FALSE;
		}
	}

    return hr;
}

STDMETHODIMP CMultiPinPosPassThru::GetPreroll( LONGLONG *pllPreroll )
{
	CheckPointer( pllPreroll, E_POINTER );
	LONGLONG llPreroll;
	HRESULT hr = m_apMS[0]->GetPreroll( pllPreroll );

	// return the minimum preroll of all our inputs
	if( SUCCEEDED( hr ) )
	{
		for(int i = 1; i < m_iPinCount; i++)
		{
			hr = m_apMS[i]->GetPreroll( &llPreroll );
			if(FAILED(hr))
				break;
			if( *pllPreroll > llPreroll ) *pllPreroll = llPreroll;
		}
	}
	return hr;
}


// --- CMediaSeeking implementation ----------


CMediaSeeking::CMediaSeeking(const TCHAR * name,LPUNKNOWN pUnk) :
    CUnknown(name, pUnk)
{
}

CMediaSeeking::CMediaSeeking(const TCHAR * name,
                               LPUNKNOWN pUnk,
                               HRESULT * phr) :
    CUnknown(name, pUnk)
{
    UNREFERENCED_PARAMETER(phr);
}

CMediaSeeking::~CMediaSeeking()
{
}


// expose our interfaces IMediaPosition and IUnknown

STDMETHODIMP
CMediaSeeking::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    if (riid == IID_IMediaSeeking) {
	return GetInterface( (IMediaSeeking *) this, ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\audmix\audmix.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// AudMix.h : Declaration of the Audio Mixer and  pin objects

#ifndef __AudMixer__
#define __AudMixer__

#include <qeditint.h>
#include <qedit.h>
#include "amextra2.h"

extern const AMOVIESETUP_FILTER sudAudMixer;

#define HOTSIZE 14

class CAudMixer;
class CAudMixerOutputPin;

//
// class for the input pin
// A input pin has its own property page
//
class CAudMixerInputPin : public CBaseInputPin
            , public IAudMixerPin
            , public ISpecifyPropertyPages
            , public IAMAudioInputMixer
{
    friend class CAudMixerOutputPin;
    friend class CAudMixer;

protected:
    CAudMixer *     m_pFilter;      // Main filter object
    LONG            m_cPinRef;      // Pin's reference count
    const int       m_iPinNo;       // Identifying number of this pin

    //IAMAudioInputMixer
    double          m_dPan;         // -1 = full left, 0 = centre, 1 = right
    BOOL            m_fEnable;

    //point to VolumeEnvelopeTable
    DEXTER_AUDIO_VOLUMEENVELOPE *m_pVolumeEnvelopeTable;
    int             m_VolumeEnvelopeEntries;
    int             m_iVolEnvEntryCnt;

    int             m_cValid;       // how many entries?
    int             m_cValidMax;    // allocated space for this many entries
    REFERENCE_TIME *m_pValidStart, *m_pValidStop;    // the entries
    REFERENCE_TIME  m_rtEnvStart, m_rtEnvStop;

    CCritSec        m_csMediaList;  // Critical section for accessing our media types list

    // The samples are held in a First in, First Out queue.
public:
    CGenericList<IMediaSample>    m_SampleList;
    LONG            m_lBytesUsed;
    BOOL            m_fEOSReceived;            // Received an EOS yet?

    long	m_UserID;	// given by user

    IMediaSample *GetHeadSample(void)
        { return m_SampleList.Get(m_SampleList.GetHeadPosition()); }

    HRESULT ClearCachedData();
    BOOL IsValidAtTime(REFERENCE_TIME);

public:

    // Constructor and destructor
    CAudMixerInputPin(
        TCHAR *pObjName,
        CAudMixer *pFilter,
        HRESULT *phr,
        LPCWSTR pPinName,
        int iPinNo);
    ~CAudMixerInputPin();

    DECLARE_IUNKNOWN

    //  ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

    // INonDelegatingUnknown overrides
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

    //expose IAudMixerPin, ISpecifyPropertyPages, IAMAudioInputMixer
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppvoid);

    // IPin overrides
    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();
    STDMETHODIMP EndOfStream();
    STDMETHODIMP NewSegment(REFERENCE_TIME tStart, REFERENCE_TIME tStop, double dRate);

    // CBasePin overrides
    HRESULT BreakConnect();
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT GetMediaType( int iPosition, CMediaType *pmt );
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT CompleteConnect(IPin *pReceivePin);

    HRESULT Inactive();

    // CBaseInputPin overrides
    STDMETHODIMP Receive(IMediaSample *pSample);


    // internal methods
    IPin * CurrentPeer() { return m_Connected; }
    CMediaType& CurrentMediaType() { return m_mt; }

    long BytesPerSample() { return (LONG) ((WAVEFORMATEX *) m_mt.pbFormat)->nBlockAlign; }
    long BitsPerSample() { return (LONG) ((WAVEFORMATEX *) m_mt.pbFormat)->wBitsPerSample; }
    DWORD SamplesPerSec(){ return ((WAVEFORMATEX *) m_mt.pbFormat)->nSamplesPerSec; };

    //IAudMixerPin; support volume envelope, The volume envelope is a set of
    // ordered pairs of (time,attenuation)

    STDMETHODIMP get_VolumeEnvelope(
            DEXTER_AUDIO_VOLUMEENVELOPE **ppsAudioVolumeEnvelopeTable,
            int *ipEntries );

    STDMETHODIMP put_VolumeEnvelope(
            const DEXTER_AUDIO_VOLUMEENVELOPE *psAudioVolumeEnvelopeTable,
            const int iEntries);

    STDMETHODIMP ClearVolumeEnvelopeTable(); //clear existed VolumeEnvelope Array

    STDMETHODIMP InvalidateAll();
    STDMETHODIMP ValidateRange(REFERENCE_TIME rtStart, REFERENCE_TIME rtStop);
    STDMETHODIMP SetEnvelopeRange( REFERENCE_TIME rtStart, REFERENCE_TIME rtStop );
    STDMETHODIMP put_PropertySetter( const IPropertySetter * pSetter );

    // Implement IAMAudioInputMixer
    STDMETHODIMP put_Enable(BOOL fEnable);    //enable or disable an input in mix
    STDMETHODIMP get_Enable(BOOL *pfEnable);
    STDMETHODIMP put_Mono(BOOL fMono){ return E_NOTIMPL; }; //combine all channels to a mono
    STDMETHODIMP get_Mono(BOOL *pfMono){ return E_NOTIMPL; };
    STDMETHODIMP put_Loudness(BOOL fLoudness){ return E_NOTIMPL; };//turn loadness control on or off
    STDMETHODIMP get_Loudness(BOOL *pfLoudness){ return E_NOTIMPL; };
    STDMETHODIMP put_MixLevel(double Level){ return E_NOTIMPL; }; //set record level for this input
    STDMETHODIMP get_MixLevel(double FAR* pLevel){ return E_NOTIMPL; };
    STDMETHODIMP put_Pan(double Pan);
    STDMETHODIMP get_Pan(double FAR* pPan);
    STDMETHODIMP put_Treble(double Treble){ return E_NOTIMPL; }; //set treble equalization for this pin
    STDMETHODIMP get_Treble(double FAR* pTreble){ return E_NOTIMPL; };
    STDMETHODIMP get_TrebleRange(double FAR* pRange){ return E_NOTIMPL; };
    STDMETHODIMP put_Bass(double Bass){ return E_NOTIMPL; };//set pass equalization for this pin
    STDMETHODIMP get_Bass(double FAR* pBass){ return E_NOTIMPL; };
    STDMETHODIMP get_BassRange(double FAR* pRange){ return E_NOTIMPL; };//retriet pass range for this pin
    STDMETHODIMP get_UserID(long *pID);
    STDMETHODIMP put_UserID(long ID);
    STDMETHODIMP OverrideVolumeLevel(double dVol);

};


// Class for the Audio Mixer's Output pin.

class CAudMixerOutputPin
    : public CBaseOutputPin
    , public ISpecifyPropertyPages
    , public IAudMixerPin
{
    friend class CAudMixerInputPin;
    friend class CAudMixer;

    //point to VolumeEnvelopeTable
    DEXTER_AUDIO_VOLUMEENVELOPE *m_pVolumeEnvelopeTable;
    int m_VolumeEnvelopeEntries;
    int m_iVolEnvEntryCnt;


    CAudMixer *m_pFilter;         // Main filter object pointer
    CMultiPinPosPassThru *m_pPosition;  // Pass seek calls upstream
    double m_dPan;        // -1 = full left, 0 = centre, 1 = right

protected:

    // need to know the start/stop time we'll be called so we can offset the
    // mix offset times
    //
    REFERENCE_TIME m_rtEnvStart, m_rtEnvStop;

    long m_UserID;	// set by user

public:

    // Constructor and destructor
    CAudMixerOutputPin(TCHAR *pObjName, CAudMixer *pFilter, HRESULT *phr,
        LPCWSTR pPinName);
    ~CAudMixerOutputPin();

    DECLARE_IUNKNOWN


    //  ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);


    //IAudMixerPin; support volume envelope, Th evolume envelope is a set of ordered pairs of (time,attenuation)
    STDMETHODIMP get_VolumeEnvelope(
            DEXTER_AUDIO_VOLUMEENVELOPE **ppsAudioVolumeEnvelopeTable,
            int *ipEntries );

    STDMETHODIMP put_VolumeEnvelope(
            const DEXTER_AUDIO_VOLUMEENVELOPE *psAudioVolumeEnvelopeTable,
            const int iEntries);

    STDMETHODIMP ClearVolumeEnvelopeTable(); //clear existed VolumeEnvelope Array

    STDMETHODIMP InvalidateAll() {return E_NOTIMPL;}
    STDMETHODIMP ValidateRange(REFERENCE_TIME rtStart, REFERENCE_TIME rtStop);
    STDMETHODIMP SetEnvelopeRange( REFERENCE_TIME rtStart, REFERENCE_TIME rtStop );
    STDMETHODIMP put_PropertySetter( const IPropertySetter * pSetter );
    STDMETHODIMP put_UserID(long ID);
    STDMETHODIMP get_UserID(long *pID);
    STDMETHODIMP OverrideVolumeLevel(double dVol);

    // INonDelegatingUnknown overrides
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppvoid);

    // CBasePin overrides
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT GetMediaType( int iPosition, CMediaType *pmt );
    STDMETHODIMP Notify(IBaseFilter *pSender, Quality q);


    // CBaseOutputPin overrides
    HRESULT DecideBufferSize(IMemAllocator *pMemAllocator,
        ALLOCATOR_PROPERTIES * ppropInputRequest);

    // internal methods
    IPin *  CurrentPeer() { return m_Connected; }
    CMediaType& CurrentMediaType() { return m_mt; };

    long BytesPerSample() { return (LONG) ((WAVEFORMATEX *) m_mt.pbFormat)->nBlockAlign; };
    long BitsPerSample() { return (LONG) ((WAVEFORMATEX *) m_mt.pbFormat)->wBitsPerSample; }
    DWORD SamplesPerSec(){ return ((WAVEFORMATEX *) m_mt.pbFormat)->nSamplesPerSec; };


};

//
//  Class for the Audio Mixer
//  1. It supports an interface where you can tell it what media type to accept
//    All pins will only accept this type.
//  2. The filter property page will bring all input pins property pages.

class CAudMixer
    : public CBaseFilter
    , public IAudMixer
    , public CCritSec
    , public ISpecifyPropertyPages
    , public CPersistStream

{
    // Let the pins access our internal state
    friend class CAudMixerInputPin;
    friend class CAudMixerOutputPin;
    typedef CGenericList <CAudMixerInputPin> CInputList;

    // filters output pin
    CAudMixerOutputPin *m_pOutput;    // Filter's output pin

    // input pin count
    INT m_cInputs;

    // m_ShownPinPropertyPageOnFilter can only modified by GetPages()
    // function and NextPin() function
    INT m_ShownPinPropertyPageOnFilter;

    // list of the output pins
    CInputList m_InputPinsList;
    // Critical section for accessing our input pin list
    CCritSec m_csPinList;
    // Critical section for delivering media samples
    CCritSec m_csReceive;
    // Critical section for dicking with the volume envelope
    CCritSec m_csVol;

    //  The following variables are used to ensure that we deliver the associated commands only once
    // to the output pin even though we have multiple input pins.
    BOOL m_bNewSegmentDelivered;
    // We only send BeginFlush when this is 0 and EndFlush when it equals 1
    LONG m_cFlushDelivery;

    // how to configure output buffers
    int m_iOutputBufferCount;
    int m_msPerBuffer;

    //output sample time stamp
    REFERENCE_TIME m_rtLastStop;

    // temp space for the mixing code
    CAudMixerInputPin **m_pPinTemp;
    BYTE **m_pPinMix;
    REFERENCE_TIME *m_pStartTemp;
    REFERENCE_TIME *m_pStopTemp;

    BOOL m_fEOSSent;

    long m_nHotness[HOTSIZE];
    long m_nLastHotness;

public:
    CAudMixer(TCHAR *pName,LPUNKNOWN pUnk,HRESULT *hr);
    ~CAudMixer();
    DECLARE_IUNKNOWN;

    STDMETHODIMP Pause();
    STDMETHODIMP Stop();

    // ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

    // CBaseFilter overrides
    CBasePin *GetPin(int n);
    int GetPinCount();

    // Function needed for the class factory
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    //expose IAudMixer, ISpecifyPropertyPages
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    // CPersistStream
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    STDMETHODIMP GetClassID(CLSID *pClsid);
    int SizeMax();

    //IAudMixer
    STDMETHODIMP put_InputPins( long Pins );
    STDMETHODIMP get_MediaType(AM_MEDIA_TYPE *pmt);
    STDMETHODIMP put_MediaType(const AM_MEDIA_TYPE *pmt);
    STDMETHODIMP get_CurrentAveragePower(double *pdAvePower);
    STDMETHODIMP NextPin(IPin **ppIPin );  //fetch next input pin.
    STDMETHODIMP InvalidatePinTimings( );
    STDMETHODIMP set_OutputBuffering(const int iNumber, const int mSecond );
    STDMETHODIMP get_OutputBuffering( int *piNumber, int *pmSecond );

protected:

    // mediatype which input pins and output pin only accept
    CMediaType      m_MixerMt;

    // List management of our input pins
    void InitInputPinsList();
    CAudMixerInputPin *GetPinNFromList(int n);
    CAudMixerInputPin *CreateNextInputPin(CAudMixer *pFilter);
    void DeleteInputPin(CAudMixerInputPin *pPin);
    int GetNumFreePins();

    //
    // Other helpers
    //

    // refresh the output pin's pospassthru about the input pins
    HRESULT SetInputPins();
    void ResetOutputPinVolEnvEntryCnt();
    HRESULT TryToMix(REFERENCE_TIME rt);
    void ClearHotnessTable( );
};

// global prototypes
//
HRESULT PinSetPropertySetter( IAudMixerPin * pPin, const IPropertySetter * pSetter );

void PanAudio(BYTE *pIn,    //source buffer
          double dPan,
          int Bits,        //8bit,16tis audio
          int nSamples  //how manmy audio samples which be panned
          );

void VolEnvelopeAudio(BYTE *pIn,        //source buffer
           WAVEFORMATEX * vih,    //source audio format
           int nSamples,    // how many audio samples which will be applied with this envelope
           double dStartLev,    //start level
           double dStopLev);    //stop level, If(dStartLev==sStopLev) dMethod=DEXTER_AUDIO_JUMP

void ApplyVolEnvelope( REFERENCE_TIME rtStart,  //output sample start time
             REFERENCE_TIME rtStop,    //output sample stop time
             REFERENCE_TIME rtEnvelopeDuration,
             IMediaSample *pSample,    //point to the sample
             WAVEFORMATEX *vih,     //output sample format
             int *pVolumeEnvelopeEntries,
             int *piVolEnvEntryCnt,
             DEXTER_AUDIO_VOLUMEENVELOPE *pVolumeEnvelopeTable);

void putVolumeEnvelope(    const DEXTER_AUDIO_VOLUMEENVELOPE *psAudioVolumeEnvelopeTable, //current input table
            const int ipEntries, // current input entries
            DEXTER_AUDIO_VOLUMEENVELOPE **ppVolumeEnvelopeTable    , //existed table
            int *ipVolumeEnvelopeEntries); //existed table netries

#endif // __AudMixer__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\audmix\outpin.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include "AudMix.h"
#include "prop.h"

//############################################################################
// 
//############################################################################

////////////////////////////////////////////////////////////////////////////////////////
//
// CAudMixerOutputPin constructor
//
CAudMixerOutputPin::CAudMixerOutputPin(TCHAR *pName, CAudMixer *pFilter,
    HRESULT *phr, LPCWSTR pPinName) :
    CBaseOutputPin(pName, pFilter, pFilter, phr, pPinName), m_pPosition(NULL),
    m_VolumeEnvelopeEntries(0),
    m_iVolEnvEntryCnt(0),
    m_pFilter(pFilter),
    m_dPan(0.0),
    m_rtEnvStart(0), m_rtEnvStop(0),
    m_UserID(0)
{
    m_pVolumeEnvelopeTable=(DEXTER_AUDIO_VOLUMEENVELOPE *)NULL;
} /* CAudMixerOutputPin::CAudMixerOutputPin */


//############################################################################
// 
//############################################################################

//
// CAudMixerOutputPin destructor
//
CAudMixerOutputPin::~CAudMixerOutputPin()
{
    delete m_pPosition;
    if(m_pVolumeEnvelopeTable)
    QzTaskMemFree( m_pVolumeEnvelopeTable );

} /* CAudMixerOutputPin::~CAudMixerOutputPin */

// ISpecifyPropertyPages 
STDMETHODIMP CAudMixerOutputPin::GetPages(CAUUID *pPages)
{
    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID)*1);
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }
    pPages->pElems[0] = CLSID_AudMixPinPropertiesPage;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

//
// NonDelegatingQueryInterface
//
// This function is overwritten to expose IMediaPosition and IMediaSeeking
//
STDMETHODIMP CAudMixerOutputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CheckPointer(ppv,E_POINTER);
    *ppv = NULL;

    // See what interface the caller is interested in.
    if( riid == IID_IMediaPosition || riid == IID_IMediaSeeking )
    {
        if( m_pPosition )
        {
            return m_pPosition->NonDelegatingQueryInterface(riid, ppv);
        }
    }
    else if (IsEqualIID(IID_ISpecifyPropertyPages, riid))
        return GetInterface((ISpecifyPropertyPages *)this, ppv);
    else if (riid == IID_IAudMixerPin) 
        return GetInterface((IAudMixerPin *) this, ppv);
    else
        return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);

    // Create implementation of this dynamically as sometimes we may never
    // try and seek.
    m_pPosition = new CMultiPinPosPassThru( NAME("CAudMixer::m_pPosition"), GetOwner() );
    if( m_pPosition == NULL )
    {
        return E_OUTOFMEMORY;
    }
    HRESULT hr = m_pFilter->SetInputPins();
    if(SUCCEEDED(hr)) {
        hr = NonDelegatingQueryInterface(riid, ppv);
    }
    return hr;
} /* CAudMixerOutputPin::NonDelegatingQueryInterface */


//############################################################################
// 
//############################################################################

//
// DecideBufferSize 
//
//
HRESULT CAudMixerOutputPin::DecideBufferSize(IMemAllocator *pAllocator,
    ALLOCATOR_PROPERTIES * pProp)
{
    CheckPointer( pAllocator, E_POINTER );
    CheckPointer( pProp, E_POINTER );
    
    pProp->cBuffers = m_pFilter->m_iOutputBufferCount;

    WAVEFORMATEX * vih = (WAVEFORMATEX*) m_mt.Format( );
    pProp->cbBuffer = vih->nBlockAlign*vih->nSamplesPerSec *
                m_pFilter->m_msPerBuffer / 1000; 

    ASSERT( pProp->cbBuffer );

    // Ask the allocator to reserve us some sample memory, NOTE the function
    // can succeed (that is return NOERROR) but still not have allocated the
    // memory that we requested, so we must check we got whatever we wanted

    ALLOCATOR_PROPERTIES Actual;
    HRESULT hr = pAllocator->SetProperties(pProp,&Actual);

    if( SUCCEEDED( hr ) )
    {
        if (pProp->cBuffers > Actual.cBuffers || pProp->cbBuffer > Actual.cbBuffer)
        {
            hr = E_FAIL;
        }
    }
    return hr;
} /* CAudMixerOutputPin::DecideBufferSize */

//############################################################################
// 
//############################################################################

//
// CheckMediaType
//
HRESULT CAudMixerOutputPin::CheckMediaType(const CMediaType *pmt)
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    DbgLog((LOG_TRACE,3,TEXT("CAudMixOut::CheckMediaType")));
    CheckPointer(pmt, E_POINTER);

    // Check major type
    const CLSID *pType = pmt->Type();
    if( MEDIATYPE_Audio != *pType )
        return VFW_E_TYPE_NOT_ACCEPTED;

    // Check subtypes
    const CLSID *pSubtype = pmt->Subtype();
    if( *pSubtype == MEDIASUBTYPE_PCM )
    {
    
    // check that sample rate & bitrate match user watned
    
    WAVEFORMATEX *pwfx    = (WAVEFORMATEX *) pmt->Format();
    CMediaType *pmtNow    = &m_pFilter->m_MixerMt;
    WAVEFORMATEX *pwfxNow    = (WAVEFORMATEX *) pmtNow->Format();

    if (pwfx->nChannels != pwfxNow->nChannels) {
        DbgLog((LOG_TRACE, 1, TEXT("output # channels doesn't match.")));
        return VFW_E_TYPE_NOT_ACCEPTED;
    }
    
    if (pwfx->nSamplesPerSec != pwfxNow->nSamplesPerSec ||
        pwfx->wBitsPerSample != pwfxNow->wBitsPerSample) 
    {
        DbgLog((LOG_TRACE, 1, TEXT("output format doesn't match user wanted fromat.")));
        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    if (pwfx->wBitsPerSample != pwfxNow->wBitsPerSample) {
        DbgLog((LOG_TRACE, 1, TEXT("Output pin's bits/sample doesn't match.")));
        return VFW_E_TYPE_NOT_ACCEPTED;
    }
    
        return NOERROR;
    }

    return VFW_E_TYPE_NOT_ACCEPTED;
} /* CAudMixerOutputPin::CheckMediaType */

//############################################################################
// 
//############################################################################

//
// Notify
//
STDMETHODIMP CAudMixerOutputPin::Notify(IBaseFilter *pSender, Quality q)
{

#if 0
    // We pass the message on, which means that we find the quality sink
    // for our input pin and send it there

    CAutoLock ListLock(&m_pFilter->m_csPinList);
    POSITION pos = m_pFilter->m_InputPinsList.GetHeadPosition();
    CAudMixerInputPin *pInput;
    IQualityControl * pIQC;

    while( pos )
    {
        pInput = m_pFilter->m_InputPinsList.GetNext(pos);
        if( pInput->m_pQSink != NULL)
        {
            pInput->m_pQSink->Notify(m_pFilter, q);
        } 
        else 
        {
            if( pInput->m_Connected )
            {
                pInput->m_Connected->QueryInterface(IID_IQualityControl,(void**)&pIQC);

                if( pIQC != NULL )
                {
                    pIQC->Notify(m_pFilter, q);
                    pIQC->Release();
                }
            }
        }
    }

    return NOERROR;
#endif

    return E_FAIL;

} /* CAudMixerOutputPin::Notify */

//############################################################################
// 
//############################################################################

//
// GetMediaType
//
HRESULT CAudMixerOutputPin::GetMediaType( int iPosition, CMediaType *pmt )
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    LARGE_INTEGER li;
    CMediaType *pMediaType = NULL;
    CheckPointer(pmt, E_POINTER);

    if( iPosition < 0 )
    {
        return E_INVALIDARG;
    }

    if ( iPosition > 0 )
    {
    return VFW_S_NO_MORE_ITEMS;
    
   }

    //get media type from filter( user gives media type he/she wanted)
    *pmt= m_pFilter->m_MixerMt;

    if (!pmt)
    return VFW_S_NO_MORE_ITEMS;

#ifdef DEBUG
    DisplayType(TEXT("Audio mixer ouput pin::GetMediaType"), pmt);
#endif

    return NOERROR;
} /* CAudMixerOutputPin::GetMediaType */

STDMETHODIMP CAudMixerOutputPin::get_VolumeEnvelope(DEXTER_AUDIO_VOLUMEENVELOPE **ppsAudioVolumeEnvelopeTable, 
            int *ipEntries )
{
    // we're looking at the envelope, which can change at any moment
    CAutoLock l(&m_pFilter->m_csVol);

    CheckPointer(ipEntries,E_POINTER);
    CheckPointer(*ppsAudioVolumeEnvelopeTable, E_POINTER);

    *ipEntries=m_VolumeEnvelopeEntries;

    if(*ppsAudioVolumeEnvelopeTable != NULL)
    {
        int iSize=*ipEntries * sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);
        CopyMemory( (PBYTE)*ppsAudioVolumeEnvelopeTable,(PBYTE)m_pVolumeEnvelopeTable, iSize);
    }

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerOutputPin::put_VolumeEnvelope(const DEXTER_AUDIO_VOLUMEENVELOPE *psAudioVolumeEnvelopeTable,
                const int iEntries)
{ 
    // we're touching the envelope
    CAutoLock l(&m_pFilter->m_csVol);

    if (!iEntries) return NOERROR;

    DbgLog((LOG_TRACE, 1, TEXT("CAudMixOut::put_Envelope %d"), iEntries));
    
    CheckPointer(psAudioVolumeEnvelopeTable,E_POINTER);

    putVolumeEnvelope( psAudioVolumeEnvelopeTable, //current input table
            iEntries, // current input entries
            &m_pVolumeEnvelopeTable    , //existed table    
            &m_VolumeEnvelopeEntries); //existed table netries
    
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerOutputPin::ClearVolumeEnvelopeTable()
{ 
    // we're touching the envelope
    CAutoLock l(&m_pFilter->m_csVol);

    //clear existed VolumeEnvelope Array entry cnt
    m_VolumeEnvelopeEntries =0;

    //free pre-exist talbe
    if (m_pVolumeEnvelopeTable)
        QzTaskMemFree(m_pVolumeEnvelopeTable);
    m_pVolumeEnvelopeTable = NULL;

    //reset entry point
    m_iVolEnvEntryCnt=0;

    return NOERROR;
}

STDMETHODIMP CAudMixerOutputPin::put_PropertySetter( const IPropertySetter * pSetter )
{
    return PinSetPropertySetter( this, pSetter );
}

STDMETHODIMP CAudMixerOutputPin::ValidateRange( REFERENCE_TIME Start, REFERENCE_TIME Stop )
{
    return E_NOTIMPL;
}

STDMETHODIMP CAudMixerOutputPin::SetEnvelopeRange( REFERENCE_TIME rtStart,
                                                   REFERENCE_TIME rtStop )
{
    m_rtEnvStart = rtStart;
    m_rtEnvStop = rtStop;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerOutputPin::put_UserID(long ID)
{
    m_UserID = ID;
    return S_OK;
}


//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerOutputPin::get_UserID(long *pID)
{
    CheckPointer(pID, E_POINTER);
    *pID = m_UserID;
    return S_OK;
}


//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerOutputPin::OverrideVolumeLevel(double dVol)
{
    DEXTER_AUDIO_VOLUMEENVELOPE env;
    env.rtEnd = 0;
    env.dLevel = dVol;
    env.bMethod = DEXTERF_JUMP;

    ClearVolumeEnvelopeTable();
    HRESULT hr = put_VolumeEnvelope(&env, 1);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\audmix\prop.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// prop.h , 
//

//
//property page  for audio mixer input pin
//
// {BDF23680-C1E5-11d2-9EF7-006008039E37}
DEFINE_GUID(CLSID_AudMixPinPropertiesPage, 
0xbdf23680, 0xc1e5, 0x11d2, 0x9e, 0xf7, 0x0, 0x60, 0x8, 0x3, 0x9e, 0x37);

class CAudMixPinProperties : public CBasePropertyPage
{

public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
         
private:
    STDMETHODIMP GetPageInfo(LPPROPPAGEINFO pPageInfo);
    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();

    void SetDirty();

    CAudMixPinProperties(LPUNKNOWN lpunk, HRESULT *phr);


    STDMETHODIMP GetFromDialog();

    BOOL m_bIsInitialized;  // Will be false while we set init values in Dlg
                            // to prevent theDirty flag from being set.

    REFERENCE_TIME	m_rtStartTime;  //*1000
    REFERENCE_TIME	m_rtDuration;	//*1000
    double		m_dStartLevel;	//*100	
    double		m_dPan;	//*100	
    int			m_iEnable;	//IDC_AUDMIXPIN_ENABLE	

    //IAudMixerPin interface
    IAudMixerPin	*m_pIAudMixPin;
    IAudMixerPin	*pIAudMixPin(void) { ASSERT(m_pIAudMixPin); return m_pIAudMixPin; }

    IAMAudioInputMixer  *m_IAMAudioInputMixer;


};

//
// property page  for the audio mixer filter
//
// {67F07E00-CCEF-11d2-9EF9-006008039E37}
DEFINE_GUID(CLSID_AudMixPropertiesPage, 
0x67f07e00, 0xccef, 0x11d2, 0x9e, 0xf9, 0x0, 0x60, 0x8, 0x3, 0x9e, 0x37);

class CAudMixProperties : public CBasePropertyPage
{

public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
         
private:
    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();

    void SetDirty();

    CAudMixProperties(LPUNKNOWN lpunk, HRESULT *phr);


    STDMETHODIMP GetFromDialog();

    BOOL m_bIsInitialized;  // Will be false while we set init values in Dlg
                            // to prevent theDirty flag from being set.

    int m_nSamplesPerSec;
    int m_nChannelNum;
    int m_nBits;
    int m_iOutputbufferNumber;
    int m_iOutputBufferLength;
    
    //IAudMixer interface
    IAudMixer	*m_pIAudMix;
    IAudMixer	*pIAudMix(void) { ASSERT(m_pIAudMix); return m_pIAudMix; }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\audmix\resource.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by filter.rc
//
#define IDS_AudMix			350
#define IDD_AudMix			351
#define IDC_SampleRate			352
#define IDC_ChannelNum                  353
#define IDC_Bits			354
#define IDC_OutputBufferNumber          355
#define IDC_OutputBufferLength          156

#define IDS_AudMixPin			360
#define IDD_AudMixPin			361
#define IDC_StartTime			362
#define IDC_Pan				363
#define IDC_AUDMIXPIN_ENABLE		364
#define IDC_Duration			365
#define IDC_StartVolume			366

#ifndef IDS_STATIC
#define IDS_STATIC                      -1
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\audmix\mixfuncs.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#ifdef FILTER_DLL
#include <initguid.h>
#endif

#include "AudMix.h"
#include "prop.h"

// Using this pointer in constructor
#pragma warning(disable:4355)

//############################################################################
// 
//############################################################################

void VolEnvelopeAudio(BYTE *pIn,		//source buffer
		   WAVEFORMATEX * vih,	//source audio format
		   int nSamples,	// how many audio samples which will be applied with this envelope
		   double dStartLev,	//start level 
		   double dStopLev)	//stop level, If(dStartLev==sStopLev) dMethod=DEXTER_AUDIO_JUMP
{
    BYTE    *pb=pIn;
    short   *pShort=(short *)pIn;
    int iCnt;
    int iTmp;
    double dTmp;


    //more code, but faster
    if( dStartLev==dStopLev)
    {
	//+++++++++++
	//DEXTER_AUDIO_JUMP
	//+++++++++++
        if(dStartLev==0.0)
        {
            FillMemory(pb,nSamples *vih->nBlockAlign,0);
            return;
        }

	if( (vih->wBitsPerSample == 16) && (vih->nChannels ==2) )
	{
	    //16bits, stereo
	    for(iCnt=0; iCnt<nSamples; iCnt++)
	    {
		dTmp = (double)*pShort * dStopLev;
		if(dTmp>=0.0)
		    iTmp=(int)(dTmp+0.5);
		else
		    iTmp=(int)(dTmp-0.5);
		
		if( iTmp > 0x7fff )
		    *pShort++= (short)0x7fff; //overflow
		else if( iTmp < -32768 )
		    *pShort++= (short)0x8000; //underflow
		else
		    *pShort++=(short)( iTmp );

		dTmp = (double)*pShort * dStopLev;
		if(dTmp>=0.0)
		    iTmp=(int)(dTmp+0.5);
		else
		    iTmp=(int)(dTmp-0.5);
		
		if( iTmp > 0x7fff )
		    *pShort++= (short)0x7fff; //overflow
		else if( iTmp < -32768 )
		    *pShort++= (short)0x8000; //underflow
		else
		    *pShort++=(short)( iTmp );

	    }
	}
	else if( vih->wBitsPerSample == 16) 
	{
	    ASSERT( vih->nChannels ==1);

	    //16 bits mono
	    for(iCnt=0; iCnt<nSamples; iCnt++)
	    {
		dTmp = (double)*pShort * dStopLev;
		if(dTmp>=0.0)
		    iTmp=(int)(dTmp+0.5);
		else
		    iTmp=(int)(dTmp-0.5);
		
		if( iTmp > 0x7fff )
		    *pShort++= (short)0x7fff; //overflow
		else if( iTmp < -32768 )
		    *pShort++= (short)0x8000; //underflow
		else
		    *pShort++=(short)( iTmp );
	    }

	}
	else if( ( vih->wBitsPerSample == 8) && (vih->nChannels ==2) )
	{
	    //8bits, stereo
	    for(iCnt=0; iCnt<nSamples; iCnt++)
	    {
		dTmp = (double)*pb * dStopLev;
		if(dTmp>=0.0)
		    iTmp=(int)(dTmp+0.5);
		else
		    iTmp=(int)(dTmp-0.5);
		
		if( iTmp > 0x7f )
		    *pb++= (BYTE)0x7f; //overflow
		else if( iTmp < -128 )
		    *pb++=(BYTE) 0x80; //underflow
		else
		    *pb++=(BYTE)( iTmp );

		dTmp = (double)*pb * dStopLev;
		if(dTmp>=0.0)
		    iTmp=(int)(dTmp+0.5);
		else
		    iTmp=(int)(dTmp-0.5);
		
		if( iTmp > 0x7f )
		    *pb++= (BYTE)0x7f; //overflow
		else if( iTmp < -128 )
		    *pb++= (BYTE)0x80; //underflow
		else
		    *pb++=(BYTE)( iTmp );
	    }
	}
	else
	{
	    ASSERT( vih->wBitsPerSample == 8);
	    ASSERT( vih->nChannels ==1);

	    //8bits, mono
	    for(iCnt=0; iCnt<nSamples; iCnt++)
	    {
		dTmp = (double)*pb * dStopLev;
		if(dTmp>=0.0)
		    iTmp=(int)(dTmp+0.5);
		else
		    iTmp=(int)(dTmp-0.5);
		
		if( iTmp > 0x7f )
		    *pb++= (BYTE)0x7f; //overflow
		else if( iTmp < -128 )
		    *pb++= (BYTE)0x80; //underflow
		else
		    *pb++=(BYTE)( iTmp );
	    }
	}
    }
    else
    {
	//++++++++++++++++++
	//DEXTER_AUDIO_INTERPOLATE
	//++++++++++++++++++
	double dLevel;
	double dDeltaLevel=dStopLev-dStartLev;

	if( (vih->wBitsPerSample == 16) && (vih->nChannels ==2) )
	{
	    //16bits, stereo
	    for(iCnt=0; iCnt<nSamples; iCnt++)
	    {
		dLevel = dDeltaLevel*iCnt/nSamples+dStartLev ;

		dTmp = (double)*pShort * dLevel;

		if(dTmp>=0.0)
		    iTmp=(int)(dTmp+0.5);
		else
		    iTmp=(int)(dTmp-0.5);
		
		if( iTmp > 0x7fff )
		    *pShort++=0x7fff; //overflow
		else if( iTmp < -32768 )
		    *pShort++=(short)0x8000; //underflow
		else
		    *pShort++=(short)( iTmp );

		dTmp = (double)*pShort * dLevel;
		if(dTmp>=0.0)
		    iTmp=(int)(dTmp+0.5);
		else
		    iTmp=(int)(dTmp-0.5);
		
		if( iTmp > 0x7fff )
		    *pShort++= 0x7fff; //overflow
		else if( iTmp < -32768 )
		    *pShort++=(short)0x8000; //underflow
		else
		    *pShort++=(short)( iTmp );

	    }
	}
	else if( vih->wBitsPerSample == 16) 
	{
	    ASSERT( vih->nChannels ==1);

	    //16 bits mono
	    for(iCnt=0; iCnt<nSamples; iCnt++)
	    {
		dLevel = dDeltaLevel*iCnt/nSamples+dStartLev ;

		dTmp = (double)*pShort * dLevel;
		if(dTmp>=0.0)
		    iTmp=(int)(dTmp+0.5);
		else
		    iTmp=(int)(dTmp-0.5);
		
		if( iTmp > 0x7fff )
		    *pShort++= 0x7fff; //overflow
		else if( iTmp < -32768 )
		    *pShort++= (short)0x8000; //underflow
		else
		    *pShort++=(short)( iTmp );
	    }

	}
	else if( (vih->wBitsPerSample == 8) && (vih->nChannels ==2) )
	{
	    //8bits, stereo
	    for(iCnt=0; iCnt<nSamples; iCnt++)
	    {
		dLevel = dDeltaLevel*iCnt/nSamples+dStartLev ;

		dTmp = (double)*pb * dLevel;
		if(dTmp>=0.0)
		    iTmp=(int)(dTmp+0.5);
		else
		    iTmp=(int)(dTmp-0.5);
		
		if( iTmp > 0x7f )
		    *pb++= 0x7f; //overflow
		else if( iTmp < -128 )
		    *pb++= (BYTE)0x80; //underflow
		else
		    *pb++=(BYTE)( iTmp );

		dTmp = (double)*pb * dLevel;
		if(dTmp>=0.0)
		    iTmp=(int)(dTmp+0.5);
		else
		    iTmp=(int)(dTmp-0.5);
		
		if( iTmp > 0x7f )
		    *pb++= 0x7f; //overflow
		else if( iTmp < -128 )
		    *pb++= (BYTE)0x80; //underflow
		else
		    *pb++=(BYTE)( iTmp );
	    }
	}
	else
	{
	    ASSERT( vih->wBitsPerSample == 8);
	    ASSERT( vih->nChannels ==1);

	    //8bits, mono
	    for(iCnt=0; iCnt<nSamples; iCnt++)
	    {
		dLevel = dDeltaLevel*iCnt/nSamples+dStartLev ;

		dTmp = (double)*pb * dLevel;
		if(dTmp>=0.0)
		    iTmp=(int)(dTmp+0.5);
		else
		    iTmp=(int)(dTmp-0.5);
		
		if( iTmp > 0x7f )
		    *pb++= 0x7f; //overflow
		else if( iTmp < -128 )
		    *pb++= (BYTE)0x80; //underflow
		else
		    *pb++=(BYTE)( iTmp );
	    }
	}
    }
}


//############################################################################
// 
//############################################################################

void PanAudio(BYTE *pIn,double dPan, int Bits, int nSamples)
{
    //assuming stereo audio:  left  right

    //full right(1.0)
    DWORD dwMask    =0x00ff00ff;
    DWORD dwOrMask  =0x80008000;

    //for right( dPan 0-1.0) keeps the current , low left
    BYTE *pb=pIn;
    short  *pShort=(short *)pIn;

    if( (dPan==-1.0 ) || (dPan==1.0 ) )
    {
	//assuming input audio buffer would be 4 bytes Align, but in case
	    
	int nDWORD  = 0;
	DWORD *pdw=(DWORD *)pIn;

	if( Bits == 8)
	{
	    //very dword take care two samples
	    nDWORD  = nSamples >> 1 ;
	    int nRem    = nSamples%2;

	    if(dPan==-1.0 )
		//full left, right silence 
	    {
		dwMask	=0xff00ff00;
		dwOrMask=0x00800080;
	    }
	    // elsed wMask=0x00ff00ff;

	    //input audio buffer would be 4 bytes Align, but in case
	    while(nDWORD--)
		*pdw++  = (*pdw & dwMask ) | dwOrMask;

	    //what left
	    pShort=(short *)(pdw);
	    short sMask =(short)(dwMask >> 16);
	    short sOrMask =(short)(dwOrMask >> 16);
	    while(nRem--)
		*pShort++  = (*pShort & sMask ) | sOrMask;

	}
	else
	{
	    ASSERT(Bits ==16);

	    //very dword take care 0ne samples
	    nDWORD  = nSamples ;
	
	    if(dPan==-1.0)
		dwMask=0xffff0000;
	    else
		dwMask=0x0000ffff;

	    while(nDWORD--)
		*pdw  &= dwMask ;

	}
    }
    else
    {
	double dIndex = (dPan > 0.0 ) ? ( 1.0-dPan):(1.0+dPan);

	if(dPan < 0.0 )
	{
	    //left change keeps current value, low right channel 
	    pb++;
	    pShort++;
	}

	if( Bits == 8)
	{

	    for(int j=0; j<nSamples; j++)
	    {
		*pb++ = (BYTE) ( (double)(*pb) * dIndex +0.5);

		pb++;
	    }

	}
	else
	{
	    ASSERT(Bits==16);
	    for(int j=0; j<nSamples; j++)
	    {
		*pShort++=(short)( (double)(*pShort) * dIndex +0.5);
		pShort++;

	    }
	}
    }
}

//############################################################################
// 
//############################################################################

void ApplyVolEnvelope( REFERENCE_TIME rtStart,  //output sample start time
		     REFERENCE_TIME rtStop,	//output sample stop time
                     REFERENCE_TIME rtEnvelopeDuration,
		     IMediaSample *pSample,	//point to the sample
		     WAVEFORMATEX *vih,     //output sample format
		     int *pVolumeEnvelopeEntries,  //total table entries
		     int *piVolEnvEntryCnt,   //current table entry point
		     DEXTER_AUDIO_VOLUMEENVELOPE *pVolumeEnvelopeTable) //table
{
    DbgLog((LOG_TRACE,1,TEXT("Entry=%d rt=%d val=%d/10"), *piVolEnvEntryCnt,
		pVolumeEnvelopeTable[*piVolEnvEntryCnt].rtEnd,
		(int)(pVolumeEnvelopeTable[*piVolEnvEntryCnt].dLevel * 10)));
    //there is an volume envelope table

    BYTE * pIn;  //input buffer point
    int iL;

    if( (&pVolumeEnvelopeTable[*piVolEnvEntryCnt])->rtEnd >=rtStop &&
        (&pVolumeEnvelopeTable[*piVolEnvEntryCnt])->bMethod ==DEXTER_AUDIO_JUMP  )
    {
        //no envelope from rtStart to rtStop
        if( !*piVolEnvEntryCnt )
            return; 
        else if( (&pVolumeEnvelopeTable[*piVolEnvEntryCnt-1])->dLevel ==1.0 ) 
            return;
    }

    //get input buffer pointer
    pSample->GetPointer(&pIn);
    long Length=pSample->GetActualDataLength(); //how many bytes in this buffer
    
    //calc how many bytes in this sample
    Length /=(long)( vih->nBlockAlign );   //how many samples in this buffer
    int iSampleLeft=(int)Length;


    //envelope levels and time
    double      dPreLev=1.0, dCurLev, dStartLev, dStopLev;  
    REFERENCE_TIME rtPre=0, rtCur, rtTmp, rt0=rtStart, rt1;

    if(*piVolEnvEntryCnt)  //if current table  entry is not 0, fetch pre-level as start leve
    {
      	dPreLev=(&pVolumeEnvelopeTable[*piVolEnvEntryCnt-1])->dLevel;
        rtPre=(&pVolumeEnvelopeTable[*piVolEnvEntryCnt-1])->rtEnd;
    }
    dCurLev=(&pVolumeEnvelopeTable[*piVolEnvEntryCnt])->dLevel;
    rtCur =(&pVolumeEnvelopeTable[*piVolEnvEntryCnt])->rtEnd;

    //apply envelope
    while( ( *pVolumeEnvelopeEntries-*piVolEnvEntryCnt) >0 )
    {	
        if(  ( rt0 >=rtCur )  &&
             (*pVolumeEnvelopeEntries== *piVolEnvEntryCnt+1) )
        {
            if( rt0 > rtEnvelopeDuration ) 
            {
                //CASE 0: at end of envelope, for REAL. back to 1.0
                dStopLev = dStartLev = 1.0;
                rt1 = rtStop;
            }
            else
            {
                //CASE 1: at end of envelope,  keep the last level
                dStopLev=dStartLev=dCurLev;
                rt1=rtStop;
            }
        }
        else if( rt0 >= rtCur ) 
        {
            //CASE 2: forword one more envelope
            rt1=rt0;
            goto NEXT_ENVELOPE;
        }
        else 
        {
            ASSERT( rt0 < rtCur);

            if( rtStop <= rtCur )
                //CASE 3: 
                rt1=rtStop;
            else
                //CASE 4:
                rt1=rtCur;
    
            if( (&pVolumeEnvelopeTable[*piVolEnvEntryCnt])->bMethod==DEXTER_AUDIO_JUMP )
                dStopLev=dStartLev=dPreLev;  //keep pre. level
            else
            {
                //interpolate

                double dDiff=dCurLev-dPreLev;
                rtTmp       =rtCur-rtPre;

                //envelope level
                dStartLev=dPreLev+ dDiff*(rt0 - rtPre ) /rtTmp;
                dStopLev =dPreLev+ dDiff*(rt1 - rtPre ) /rtTmp;

             }
        }

        //apply current envelope from rt0 to rt1
        iL=(int)( (rt1-rt0)*Length /(rtStop-rtStart) ); 

        // avoid off by 1 errors.  If we're supposed to use the rest of the
        // buffer, make sure we use the rest of the buffer!  iL might be 1 too
        // small due to rounding errors
        if (rt1 == rtStop)
            iL = iSampleLeft;

	ASSERT(iL<=iSampleLeft);

        if( dStartLev !=1.0 || dStopLev!=1.0 )
	    VolEnvelopeAudio(pIn,	    //source buffer
	    	vih,	    //source audio format
		iL,	    // how many audio samples which will be applied with this envelope
		dStartLev, //start level 
		dStopLev); //stop level, If(dStartLev==sStopLev) dMethod=DEXTER_AUDIO_JUMP
        
        pIn +=(iL* vih->nBlockAlign);
	iSampleLeft-=iL;

	if( rt1==rtStop )
	{
            ASSERT(!iSampleLeft);
	    return;
	}
	else
        {
NEXT_ENVELOPE:
            ASSERT(iSampleLeft);

            dPreLev= dCurLev;
            rtPre=rtCur;
            *piVolEnvEntryCnt+=1;
            dCurLev=(&pVolumeEnvelopeTable[*piVolEnvEntryCnt])->dLevel;
            rtCur =(&pVolumeEnvelopeTable[*piVolEnvEntryCnt])->rtEnd;
            rt0=rt1;
        }
	        
    } //end of while()

}

//############################################################################
// 
//############################################################################

void putVolumeEnvelope(	const DEXTER_AUDIO_VOLUMEENVELOPE *psAudioVolumeEnvelopeTable, //current input table
			const int iEntries, // current input entries
			DEXTER_AUDIO_VOLUMEENVELOPE **ppVolumeEnvelopeTable	, //existed table	
			int *ipVolumeEnvelopeEntries) //existed table netries
{

    DEXTER_AUDIO_VOLUMEENVELOPE *pVolumeEnvelopeTable;
    pVolumeEnvelopeTable=*ppVolumeEnvelopeTable;

    int iSize;

    //is a table existed
    if(pVolumeEnvelopeTable)
    {	
	//MAX Entries, may be too big, but we do not care
	iSize=(iEntries +*ipVolumeEnvelopeEntries)* sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);

	//allocate memory for new table, I can use Realloc(), but this way is eaiser to insert
	DEXTER_AUDIO_VOLUMEENVELOPE *pNewTable=
	    (DEXTER_AUDIO_VOLUMEENVELOPE *)QzTaskMemAlloc(iSize); 

	//insert the new input table to the existed table
	int iInput=0;  //input table cnt
	int iExist=0;  //exist table cnt
	int iNew=0;  //new table cnt

	int iExtraEntries=0;   

	//how many more entries
	while (	iInput<iEntries )
	{
	    if( ( iExist == *ipVolumeEnvelopeEntries ) )
	    {
	        //copy rest input table
	        CopyMemory( (PBYTE)(&pNewTable[iNew]), 
		    (PBYTE)(&psAudioVolumeEnvelopeTable[iInput]),
		    (iEntries-iInput)*sizeof(DEXTER_AUDIO_VOLUMEENVELOPE));
	        iExtraEntries+=(iEntries-iInput);
	        break;
	    }
	    else if( psAudioVolumeEnvelopeTable[iInput].rtEnd <= pVolumeEnvelopeTable[iExist].rtEnd )
	    {
		//insert or replace 
		CopyMemory( (PBYTE)(&pNewTable[iNew++]), 
			    (PBYTE)(&psAudioVolumeEnvelopeTable[iInput]),
			    sizeof(DEXTER_AUDIO_VOLUMEENVELOPE));

		if( psAudioVolumeEnvelopeTable[iInput].rtEnd == pVolumeEnvelopeTable[iExist].rtEnd )
		    //replace existed one
		    iExist++;
		else
		    //insert new one
		    iExtraEntries++;
		
		iInput++;
	    }
	    else 
	    {
		//how many existed elements will be copied
		int iCnt=1;

		if(iExist < *ipVolumeEnvelopeEntries )
		{
		    iExist++;

		    while( ( iExist < *ipVolumeEnvelopeEntries) &&
			( psAudioVolumeEnvelopeTable[iInput].rtEnd > pVolumeEnvelopeTable[iExist].rtEnd) )
		    {
			iCnt++;
			iExist++;
		    }
		}

		//copy iCnt elements from existed table to the new table
		CopyMemory( (PBYTE)(&pNewTable[iNew]), 
			    (PBYTE)(&pVolumeEnvelopeTable[(iExist-iCnt)]),
			    iCnt*sizeof(DEXTER_AUDIO_VOLUMEENVELOPE));
		iNew+=iCnt;
	    }
	}

	//new table entries
	*ipVolumeEnvelopeEntries =*ipVolumeEnvelopeEntries+iExtraEntries;

	//free pre-exist talbe
	QzTaskMemFree(pVolumeEnvelopeTable);

	//point to new table
	*ppVolumeEnvelopeTable=pNewTable;   

    }
    else
    {
	//input table = pVolumeEnvelopeTable(), memory size
	iSize=iEntries * sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);

	*ppVolumeEnvelopeTable = (DEXTER_AUDIO_VOLUMEENVELOPE *)QzTaskMemAlloc(iSize);
    	CopyMemory( (PBYTE)(*ppVolumeEnvelopeTable), (PBYTE)psAudioVolumeEnvelopeTable, iSize);
	*ipVolumeEnvelopeEntries =(int)iEntries;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\audmix\setup.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#ifdef FILTER_DLL
#include <initguid.h>
#endif

#include "AudMix.h"
#include "prop.h"

// Using this pointer in constructor
#pragma warning(disable:4355)

// Setup data

const AMOVIESETUP_MEDIATYPE sudPinTypes =
{
    &MEDIATYPE_Audio,   // Major CLSID
    &MEDIASUBTYPE_PCM  // Minor type
};

const AMOVIESETUP_PIN psudPins[] =
{
    { L"Input",            // Pin's string name - this pin is what pulls the filter into the graph
      FALSE,                // Is it rendered
      FALSE,                // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      NULL,                 // Connects to pin
      1,                    // Number of types
      &sudPinTypes },	    // Pin information
    { L"Output",            // Pin's string name
      FALSE,                // Is it rendered
      TRUE,                 // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Input",             // Connects to pin
      1,                    // Number of types
      &sudPinTypes }        // Pin information
};

const AMOVIESETUP_FILTER sudAudMixer =
{
    &CLSID_AudMixer,       // CLSID of filter
    L"Audio Mixer",     // Filter's name
    MERIT_DO_NOT_USE,             // Filter merit
    2,                          // Number of pins to start
    psudPins                    // Pin information
};


#ifdef FILTER_DLL

CFactoryTemplate g_Templates[] = {
    { L"Audio Mixer",
    &CLSID_AudMixer,
    CAudMixer::CreateInstance,
    NULL,
    &sudAudMixer },
    { L"Audio Mixer Property", 
    &CLSID_AudMixPropertiesPage,
    CAudMixProperties::CreateInstance},
    { L"Pin Property", 
    &CLSID_AudMixPinPropertiesPage,
    CAudMixPinProperties::CreateInstance}
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);


//
// DllRegisterServer
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );
}


//
// DllUnregisterServer
//
STDAPI
DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );
}

#endif

//
// CreateInstance
//
// Creator function for the class ID
//
CUnknown * WINAPI CAudMixer::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CAudMixer(NAME("Audio Mixer"), pUnk, phr);
} /* CAudMixer::CreateInstance */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\audmix\prop.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//prop.cpp
//

#include <streams.h>
#include <atlbase.h>
#include <qeditint.h>
#include <qedit.h>

#include "resource.h"
#include "prop.h"

inline void SAFE_RELEASE(IUnknown **ppObj)
{
    if ( *ppObj != NULL )
    {
        ULONG cRef = (*ppObj)->Release();
        *ppObj = NULL;
    }
}

// *
// * CAudMixPinProperties
// *


//
// CreateInstance
//
CUnknown *CAudMixPinProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{

    CUnknown *punk = new CAudMixPinProperties(lpunk, phr);
    if (punk == NULL)
    {
	*phr = E_OUTOFMEMORY;
    }

    return punk;
}


//
// CAudMixPinProperties::Constructor
//
CAudMixPinProperties::CAudMixPinProperties(LPUNKNOWN pUnk, HRESULT *phr)
    : CBasePropertyPage(NAME("Audio Mixer Pin Property Page"),pUnk,
        IDD_AudMixPin, IDS_AudMixPin)
    , m_pIAudMixPin(NULL)
    , m_IAMAudioInputMixer(NULL)
    , m_bIsInitialized(FALSE)
{
}

// Override CBasePropertyPage's GetPageInfo
STDMETHODIMP CAudMixPinProperties::GetPageInfo(LPPROPPAGEINFO pPageInfo)
{
    HRESULT hr = CBasePropertyPage::GetPageInfo(pPageInfo);
    if (FAILED(hr))  return hr;

    //get IPin interface
    ASSERT(m_pIAudMixPin!=NULL);
    ASSERT(m_IAMAudioInputMixer!=NULL);

    IPin *pIPin;
    hr = m_pIAudMixPin->QueryInterface(IID_IPin, (void**) &pIPin);
    if (FAILED(hr))  return hr;

    // Figure out which input pin it is, and concat the pin number to
    // property page's title
    {
        PIN_INFO PinInfo;
        PinInfo.pFilter = NULL;
        hr = pIPin->QueryPinInfo( &PinInfo );
        SAFE_RELEASE( (LPUNKNOWN *) &PinInfo.pFilter );

        // Get the default page title
        WCHAR wszTitle[STR_MAX_LENGTH];
        WideStringFromResource(wszTitle,m_TitleId);

        // Put the original title and pin name together
        wsprintfWInternal(wszTitle+lstrlenWInternal(wszTitle), L"%ls", PinInfo.achName);

        // Allocate dynamic memory for the new property page title
        int Length = (lstrlenWInternal(wszTitle) + 1) * sizeof(WCHAR);
        LPOLESTR pszTitle = (LPOLESTR) QzTaskMemAlloc(Length);
        if (pszTitle == NULL) {
            NOTE("No caption memory");
	    pIPin->Release();
            return E_OUTOFMEMORY;
        }
        CopyMemory(pszTitle,wszTitle,Length);

        // Free the memory of the old title string
        if (pPageInfo->pszTitle)
            QzTaskMemFree(pPageInfo->pszTitle);
        pPageInfo->pszTitle = pszTitle;

	pIPin->Release();
    }

    return hr;
}

//
// SetDirty
//
// Sets m_hrDirtyFlag and notifies the property page site of the change
//
void CAudMixPinProperties::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
    {
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
    }
}


INT_PTR CAudMixPinProperties::OnReceiveMessage(HWND hwnd,
                                        UINT uMsg,
                                        WPARAM wParam,
                                        LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
	    //start time
	    SetDlgItemInt(hwnd, IDC_StartTime, (int)(m_rtStartTime / 10000),FALSE);
	
	    //duration
	    SetDlgItemInt(hwnd, IDC_Duration, (int)(m_rtDuration/ 10000), FALSE);

	    //start volume level
	    SetDlgItemInt(hwnd, IDC_StartVolume, (int)(m_dStartLevel*100), FALSE);

	    //start volume level
	    SetDlgItemInt(hwnd, IDC_Pan, (int)(m_dPan*100), FALSE);

            return (LRESULT) 1;
        }
        case WM_COMMAND:
        {
            if (m_bIsInitialized)
            {
                m_bDirty = TRUE;
                if (m_pPageSite)
                {
                    m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
                }
            }
            return (LRESULT) 1;
        }
    }
    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
}

HRESULT CAudMixPinProperties::OnConnect(IUnknown *pUnknown)
{
    // Get IAudMixPin interface
    ASSERT(m_pIAudMixPin == NULL);
    ASSERT(m_IAMAudioInputMixer == NULL);
    HRESULT hr = S_OK;

    // Query for IAudMixer, if added for the filter
    CComPtr<IAudMixer> pIAudMix = NULL;

    hr = pUnknown->QueryInterface(IID_IAudMixer, (void **) &pIAudMix);
    if (SUCCEEDED(hr))
    {
	//added from filter
	IPin *pIPin=NULL;
	hr = pIAudMix->NextPin(&pIPin);
        if (FAILED(hr)) {
            return hr;
	}

        hr = pIPin->QueryInterface(IID_IAudMixerPin, (void**) &m_pIAudMixPin);
        if (FAILED(hr))
	{
	    pIPin->Release();
	    return hr;
	}

        hr = pIPin->QueryInterface(IID_IAMAudioInputMixer, (void**) &m_IAMAudioInputMixer);
	pIPin->Release();

        if (FAILED(hr)) {
	    return hr;
	}
    }
    else
    {

	
	//added for pin only
	HRESULT hr = pUnknown->QueryInterface(IID_IAudMixerPin, (void **) &m_pIAudMixPin);
	if (FAILED(hr))
	    return E_NOINTERFACE;

	hr = pUnknown->QueryInterface(IID_IAMAudioInputMixer, (void **) &m_IAMAudioInputMixer);
	if (FAILED(hr))
	    return E_NOINTERFACE;

    }

    ASSERT(m_pIAudMixPin);
    ASSERT(m_IAMAudioInputMixer);

    // get init data
//    pIAudMixPin()->get_VolumeEnvelope(&m_rtStartTime,&m_rtDuration,&m_dStartLevel);
    m_IAMAudioInputMixer->get_Pan(&m_dPan);
    BOOL fEnable=TRUE;
    m_IAMAudioInputMixer->get_Enable(&fEnable);
    if(fEnable==TRUE)
	m_iEnable=IDC_AUDMIXPIN_ENABLE;
    else
	m_iEnable=0;
	

    m_bIsInitialized = FALSE ;

    return NOERROR;
}

HRESULT CAudMixPinProperties::OnDisconnect()
{
    // Release the interface

    if( (m_pIAudMixPin == NULL) || (m_IAMAudioInputMixer ==NULL) )
    {
	// !!! why does this happen?
        return(E_UNEXPECTED);
    }
    m_pIAudMixPin->Release();
    m_pIAudMixPin = NULL;

    m_IAMAudioInputMixer->Release();
    m_IAMAudioInputMixer=NULL;
    return NOERROR;
}


// We are being activated

HRESULT CAudMixPinProperties::OnActivate()
{
    CheckRadioButton(m_Dlg, IDC_AUDMIXPIN_ENABLE, IDC_AUDMIXPIN_ENABLE, m_iEnable);
    m_bIsInitialized = TRUE;
    return NOERROR;
}


// We are being deactivated

HRESULT CAudMixPinProperties::OnDeactivate(void)
{
    // remember present effect level for next Activate() call

    GetFromDialog();
    return NOERROR;
}

//
// get data from Dialog

STDMETHODIMP CAudMixPinProperties::GetFromDialog(void)
{
    //get start time
    m_rtStartTime = GetDlgItemInt(m_Dlg, IDC_StartTime, NULL, FALSE);
    m_rtStartTime *= 10000;

    //get duration
    m_rtDuration = GetDlgItemInt(m_Dlg, IDC_Duration, NULL, FALSE);
    m_rtDuration *= 10000;

    //get start volume level
    int n = GetDlgItemInt(m_Dlg, IDC_StartVolume, NULL, FALSE);
    m_dStartLevel = (double)(n / 100.);

    //get Pan
    n = GetDlgItemInt(m_Dlg, IDC_Pan, NULL, FALSE);
    m_dPan = (double)(n / 100.);

    //get enable
    n=IDC_AUDMIXPIN_ENABLE;
    if (IsDlgButtonChecked(m_Dlg, n))
	m_iEnable=n;
    else
	m_iEnable=0;

    // cehck if all data is valid ??
    return NOERROR;
}


HRESULT CAudMixPinProperties::OnApplyChanges()
{
    GetFromDialog();

    HRESULT hr=NOERROR;

    m_bDirty  = FALSE; // the page is now clean

    // get current data
    REFERENCE_TIME rtStart, rtDuration;
    rtStart =0;
    rtDuration=0;
    double dLevel=0.0;
    double dPan=0.0;
    int iEnable=0;
    BOOL fEnable=FALSE;

    //get old data
//    pIAudMixPin()->get_VolumeEnvelope(&rtStart,&rtDuration,&dLevel);
    m_IAMAudioInputMixer->get_Pan(&dPan);
    m_IAMAudioInputMixer->get_Enable(&fEnable);
    if(fEnable==TRUE)
	iEnable =IDC_AUDMIXPIN_ENABLE;

    //set new enable data
    if(m_iEnable==IDC_AUDMIXPIN_ENABLE)
	fEnable=TRUE;
    else
	fEnable=FALSE;


    if( (rtStart != m_rtStartTime)	||
	(rtDuration != m_rtDuration )	||
	(dLevel != m_dStartLevel )	||
	(dPan	!= m_dPan)		||
	(iEnable!= m_iEnable) )
    {
	//put new data

	//hr=pIAudMixPin()->put_VolumeEnvelope(m_rtStartTime,m_rtDuration,m_dStartLevel);
	hr=NOERROR;

	HRESULT hr1= m_IAMAudioInputMixer->put_Pan(m_dPan);
	HRESULT hr2= m_IAMAudioInputMixer->put_Enable(fEnable);

	if(hr!=NOERROR && hr1!=NOERROR && hr2!=NOERROR )
	    return E_FAIL;
    }

    return(hr);

}

//#########################################
// *
// * CAudMixProperties
// *
//##############################################

CUnknown *CAudMixProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{

    CUnknown *punk = new CAudMixProperties(lpunk, phr);
    if (punk == NULL)
    {
	*phr = E_OUTOFMEMORY;
    }

    return punk;
}


//
// CAudMixProperties::Constructor
//
CAudMixProperties::CAudMixProperties(LPUNKNOWN pUnk, HRESULT *phr)
    : CBasePropertyPage(NAME("Audio Mixer Property Page"),pUnk,
	IDD_AudMix, IDS_AudMix)
    , m_pIAudMix(NULL)
    , m_bIsInitialized(FALSE)
{
}


//
// SetDirty
//
// Sets m_hrDirtyFlag and notifies the property page site of the change
//
void CAudMixProperties::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
    {
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
    }
}


INT_PTR CAudMixProperties::OnReceiveMessage(HWND hwnd,
                                        UINT uMsg,
                                        WPARAM wParam,
                                        LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
	    //Sampling rate
	    SetDlgItemInt(hwnd, IDC_SampleRate, (int)m_nSamplesPerSec,FALSE);
	
	    //channel Number
	    SetDlgItemInt(hwnd, IDC_ChannelNum, (int)m_nChannelNum, FALSE);

	    //channel bits
	    SetDlgItemInt(hwnd, IDC_Bits, (int)m_nBits, FALSE);

    	    //buffer number
	    SetDlgItemInt(hwnd, IDC_OutputBufferNumber, (int)m_iOutputbufferNumber, FALSE);

	    //buffer lenght in mSecond
	    SetDlgItemInt(hwnd, IDC_OutputBufferLength, (int)m_iOutputBufferLength, FALSE);

            return (LRESULT) 1;
        }
        case WM_COMMAND:
        {
            if (m_bIsInitialized)
            {
                m_bDirty = TRUE;
                if (m_pPageSite)
                {
                    m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
                }
            }
            return (LRESULT) 1;
        }
    }
    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
}

HRESULT CAudMixProperties::OnConnect(IUnknown *pUnknown)
{
    // Get IAudMix interface
    ASSERT(m_pIAudMix == NULL);

    HRESULT hr = pUnknown->QueryInterface(IID_IAudMixer, (void **) &m_pIAudMix);
    if (FAILED(hr))
	return E_NOINTERFACE;

    ASSERT(m_pIAudMix);

    // get init data
    CMediaType mt;
    mt.AllocFormatBuffer( sizeof( WAVEFORMATEX ) );

    pIAudMix()->get_MediaType( &mt );

    WAVEFORMATEX * vih = (WAVEFORMATEX*) mt.Format( );

    m_nSamplesPerSec	=vih->nSamplesPerSec;
    m_nChannelNum	=vih->nChannels;
    m_nBits		=(int)vih->wBitsPerSample;

    //buffer number, lenght in mSecond
    pIAudMix()->get_OutputBuffering( &m_iOutputbufferNumber, &m_iOutputBufferLength );

    m_bIsInitialized	= FALSE ;

    FreeMediaType(mt);

    return NOERROR;
}

HRESULT CAudMixProperties::OnDisconnect()
{
    // Release the interface

    if (m_pIAudMix == NULL)
    {
        return(E_UNEXPECTED);
    }
    m_pIAudMix->Release();
    m_pIAudMix = NULL;
    return NOERROR;
}


// We are being activated

HRESULT CAudMixProperties::OnActivate()
{

    m_bIsInitialized = TRUE;
    return NOERROR;
}


// We are being deactivated

HRESULT CAudMixProperties::OnDeactivate(void)
{
    // remember present effect level for next Activate() call

    GetFromDialog();
    return NOERROR;
}

//
// get data from Dialog

STDMETHODIMP CAudMixProperties::GetFromDialog(void)
{

    // Sampling rate
    m_nSamplesPerSec = GetDlgItemInt(m_Dlg, IDC_SampleRate, NULL, FALSE);

    // audio chanenl
    m_nChannelNum = GetDlgItemInt(m_Dlg, IDC_ChannelNum, NULL, FALSE);

    // bits
    m_nBits = GetDlgItemInt(m_Dlg, IDC_Bits, NULL, FALSE);

    //buffer number
    m_iOutputbufferNumber=GetDlgItemInt(m_Dlg, IDC_OutputBufferNumber, NULL, FALSE);

    //buffer lenght in mSecond
    m_iOutputBufferLength=GetDlgItemInt(m_Dlg, IDC_OutputBufferLength, NULL, FALSE);

    return NOERROR;
}


HRESULT CAudMixProperties::OnApplyChanges()
{
    GetFromDialog();

    HRESULT hr=NOERROR;

    m_bDirty  = FALSE; // the page is now clean

    //get current media type
    CMediaType mt;
    mt.AllocFormatBuffer( sizeof( WAVEFORMATEX ) );

    //old format
    hr=pIAudMix()->get_MediaType( &mt );
    if(hr!=NOERROR)
    {
	FreeMediaType(mt);
	return E_FAIL;
    }

    int iNumber=0, mSecond=0;
    hr=pIAudMix()->get_OutputBuffering( &iNumber, &mSecond);
    if(hr!=NOERROR)
    {
	
	FreeMediaType(mt);
	return E_FAIL;
    }

    WAVEFORMATEX * vih = (WAVEFORMATEX*) mt.Format( );
    if( (m_nSamplesPerSec!= (int)(vih->nSamplesPerSec) ) ||
	(m_nChannelNum	 !=vih->nChannels )  ||
	(m_nBits	 !=(int)vih->wBitsPerSample)  ||
	(iNumber	 !=m_iOutputbufferNumber    ) ||
	(mSecond	 !=m_iOutputBufferLength) )
    {
	vih->nSamplesPerSec = m_nSamplesPerSec;
	vih->nChannels	    = (WORD)m_nChannelNum;
	vih->wBitsPerSample = (WORD)m_nBits;
	vih->nBlockAlign    = vih->wBitsPerSample * vih->nChannels / 8;
	vih->nAvgBytesPerSec = vih->nBlockAlign * vih->nSamplesPerSec;
	
	hr= pIAudMix()->put_MediaType( &mt );
	if(hr!=NOERROR){
	    	FreeMediaType(mt);
		return E_FAIL;
	}

	hr= pIAudMix()->set_OutputBuffering(m_iOutputbufferNumber,m_iOutputBufferLength);
	if(hr!=NOERROR){
	    	FreeMediaType(mt);
		return E_FAIL;
	}
    }

    FreeMediaType(mt);
    return(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\audpack\audpack.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// !!! The MEDIA TIMES are not fixed up!  This could mess up live data!

#include <streams.h>
#ifdef FILTER_DLL
    #include <initguid.h>
    #include <qeditint.h>
    #include "qedit.h"
    #include "qedit_i.c"
#else
#include <qeditint.h>
#include <qedit.h>
#endif
#include "AudPack.h"
#include "seek.h"
#include "..\util\conv.cxx"
#include "..\util\perf_defs.h"

#define CHANNELS 2
#define BITSPERSAMPLE 16

// NOTES ON SHARING A SOURCE FILTER:  The same source filter may be used in
// the video group, and the audio group, to avoid opening it twice. Seeking
// such a graph is complicated.  For the AVI parser, here's the behaviour...
// a seek on the video pin is obeyed, and seeks on the audio pin are ignored.
// (they better be identical anyway).  So what happens if the video switch is
// seeked first, is that that will cause the splitter to flush and send the
// new data to the audio branch, much to the surprise of the audio branch.
// Then later, the audio switch will see the seek, and the audio chain will
// ignore it.
// If the audio switch is seeked first, then we will see the seek, but nothing
// will happen, and then later when the video group is seeked, the audio chain
// will get flushed, and new data delivered, again, much to our surprise.
//
// So, if we get flushed during a seek, that's the normal case.  But now there
// are 2 other cases:
// 1. We get flushed out of nowhere. Wait for the seek we know is coming, and
//    then allow ourself to deliver data again (we need to wait for the switch
//    to be expecting the new data)
// 2. We get a seek, then a surprise flush.  We can start sending new data right
//    away without waiting for another seek.
//
//
// #ifdef NOFLUSH
//
// (this will need to be ifdef'd in if a Dexter source doesn't always flush
// when seeked and streaming (eg: no data sent yet; it's not exactly necessary)
//
// Also, some sources don't flush, if they haven't delivered data yet.  So
// the right thing to do is actually a little different:
//
// 1.  If we get an unexpected NewSeg (not from going Active or seeking) that's
//     the same as a surprise flush.  Block all input. Don't send the NewSeg yet
// 2.  When we get a seek after having the surprise NewSeg, send the NewSeg
//     downstream them.
//
// #endif
//
//
// TO BE CONTINUED in switch.cpp



const AMOVIESETUP_MEDIATYPE sudPinTypes[1] =
{
    {&MEDIATYPE_Audio, &MEDIASUBTYPE_NULL}
};

const AMOVIESETUP_PIN psudPins[] =
{
    {
        L"Input"            // strName
        , FALSE               // bRendered
        , FALSE               // bOutput
        , FALSE               // bZero
        , FALSE               // bMany
        , &CLSID_NULL         // clsConnectsToFilter
        , L"Output"           // strConnectsToPin
        , 1                   // nTypes
        , &sudPinTypes[0]
    },
    {
        L"Output"           // strName
        , FALSE               // bRendered
        , TRUE                // bOutput
        , FALSE               // bZero
        , FALSE               // bMany
        , &CLSID_NULL         // clsConnectsToFilter
        , L"Input"            // strConnectsToPin
        , 1                   // nTypes
        , &sudPinTypes[0]
    }
};   // lpTypes


const AMOVIESETUP_FILTER sudAudRepack =
{
    &CLSID_AudRepack
    , L"Audio Repackager"        // strName
    , MERIT_DO_NOT_USE           // dwMerit
    , 2                          // nPins
    , psudPins                   // lpPin
};

#ifdef FILTER_DLL
// Needed for the CreateInstance mechanism
CFactoryTemplate g_Templates[]=
{
    { L"Audio Repackager", &CLSID_AudRepack, CAudRepack::CreateInstance, NULL, &sudAudRepack },
    { L"Audio Repackager Property Page", &CLSID_AUDProp, CAudPropertyPage::CreateInstance }
};

int g_cTemplates = sizeof(g_Templates)/sizeof(g_Templates[0]);
#endif

const int TRACE_HIGHEST = 2;
const int TRACE_MEDIUM = 3;
const int TRACE_LOW = 4;
const int TRACE_LOWEST = 5;

BOOL SafeResetEvent(HANDLE h);
BOOL SafeSetEvent(HANDLE h);

CAudRepack::CAudRepack(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr)
    : CTransformFilter( tszName, punk, CLSID_AudRepack )
    , CPersistStream(punk, phr)
    , m_dOutputFrmRate(4.0)    // default output frame rate
    , m_rtLastSeek(-1)        // nobody has seeked us yet
    , m_nCacheSize(0)
    , m_fSeeking(FALSE)
    , m_pCache(NULL)
    , m_pResample(NULL)
    , m_cResample(0)
    , m_bMediaTypeSetByUser( false )
    , m_pSkew(NULL)
    , m_cTimes(0)
    , m_cMaxTimes(0)
    , m_fSpecialSeek(FALSE)
    , m_fStopPushing(FALSE)
    , m_fFlushWithoutSeek(FALSE)
#ifdef NOFLUSH
    , m_fSurpriseNewSeg(FALSE)
#endif
    , m_hEventSeek(0)
    , m_hEventThread(0)
{
    ZeroMemory(&m_mtAccept, sizeof(AM_MEDIA_TYPE));
    m_mtAccept.majortype = MEDIATYPE_Audio;	// at least we know this much

    // by default, play the movie normally
    AddStartStopSkew(0, MAX_TIME, 0, 1.0);
    m_nCurSeg = 0;

    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("CAudRepack")));
}

CAudRepack::~CAudRepack( )
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("~CAudRepack")));
    Free();
    if (m_pResample)
	QzTaskMemFree(m_pResample);
    if (m_pSkew)
	QzTaskMemFree(m_pSkew);

    ASSERT(m_hEventThread == 0);
    ASSERT(m_hEventSeek == 0);
}

void CAudRepack::Free()
{
    if( m_pCache )
    {
        delete [] m_pCache;
        m_pCache = NULL;
    }
}

CUnknown *CAudRepack::CreateInstance(LPUNKNOWN punk, HRESULT *phr)
{
    CAudRepack *pNewObject = new CAudRepack( NAME("AudRepack"), punk, phr);
    if (pNewObject == NULL)
        *phr = E_OUTOFMEMORY;
    return pNewObject;
}

//
// NonDelegatingQueryInterface
//
// Reveals IDexterSequencer, IPersistStream and ISpecifyPropertyPages
//
STDMETHODIMP CAudRepack::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CheckPointer(ppv,E_POINTER);

    if (IsEqualIID(IID_ISpecifyPropertyPages, riid)) {
      return GetInterface((ISpecifyPropertyPages *)this, ppv);
    } else if (riid == IID_IDexterSequencer) {
    return GetInterface((IDexterSequencer *) this, ppv);
    } else if (riid == IID_IPersistStream) {
    return GetInterface((IPersistStream *) this, ppv);
    } else {
    return CTransformFilter::NonDelegatingQueryInterface(riid, ppv);
    }
} // NonDelegatingQueryInterface


#ifdef FILTER_DLL
HRESULT DllRegisterServer()
{
    return AMovieDllRegisterServer2(TRUE);
}

HRESULT DllUnregisterServer()
{
    return AMovieDllRegisterServer2(FALSE);
}
#endif


CBasePin *CAudRepack::GetPin(int n)
{
    HRESULT hr = S_OK;

    // Create an input pin if not already done
    if (m_pInput == NULL) {
        m_pInput = new CAudRepackInputPin(
                          NAME("Audio Repackager input pin")
                          , this       // Owner filter
                          , &hr        // Result code
                          , L"Input"  // Pin name
                          );

        // Constructor can't fail
        ASSERT(SUCCEEDED(hr));
    }

    // Create an output pin if not already done
    if (m_pInput!=NULL && m_pOutput == NULL)
    {
        m_pOutput = new CAudRepackOutputPin(
                            NAME("Audio Repackager output pin")
                          , this       // Owner filter
                          , &hr        // Result code
                          , L"Output"  // Pin name
                          );

        // a failed return code should delete the object

        ASSERT(SUCCEEDED(hr));
        if (m_pOutput == NULL)
        {
            delete m_pInput;
            m_pInput = NULL;
        }
    }

    // Return the appropriate pin
    ASSERT (n>=0 && n<=1);
    if (n == 0) {
        return m_pInput;
    } else if (n==1) {
        return m_pOutput;
    } else {
        return NULL;
    }
} // GetPin


HRESULT CAudRepack::NextSegment(BOOL fUseOtherThread)
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:Done Segment %d"), m_nCurSeg));

    if (m_nCurSeg < m_cTimes) {
        m_nCurSeg++;
    }

    if (m_nCurSeg == m_cTimes) {
        DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:ALL done")));
	// deliver EOS only after all segs done
	CTransformFilter::EndOfStream();
	return S_OK;
    }

    // WE CANNOT SEEK ON the source's pushing thread, or you hang.
    // (That's just the rule).  So we have a separate thread that can seek
    // for us in that case.  Let's wake it up.
    if (fUseOtherThread) {
        m_fThreadCanSeek = TRUE;
        SetEvent(m_hEventThread);
    } else {
	m_fThreadCanSeek = TRUE;
	SeekNextSegment();
    }

    return S_OK;
}


// called by our special thread to do the seek to the next segment
//
HRESULT CAudRepack::SeekNextSegment()
{
    // our thread can't seek at the same time the app seeks us
    CAutoLock cAutolock(&m_csThread);

    // it is not safe for our thread to seek
    if (!m_fThreadCanSeek) {
	return S_OK;
    }
    m_fThreadCanSeek = FALSE;

    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:Delayed Seek for NextSegment")));

    // in timeline time (which includes skew), this is where we are starting
    m_rtNewLastSeek = m_pSkew[m_nCurSeg].rtTLStart;
    m_nSeekCurSeg = m_nCurSeg;	// EndFlush looks at this

    // just in case we don't get a NewSeg (paranoia?)
    m_rtNewSeg = m_rtNewLastSeek;
    m_llStartFrameOffset = Time2Frame( m_rtNewSeg, m_dOutputFrmRate );

    // note we're seeking during the flush that this will generate
    m_fSeeking = TRUE;
    m_fSpecialSeek = TRUE;

    IMediaSeeking *pMS;
    IPin *pPin = m_pInput->GetConnected();
    HRESULT hr = pPin->QueryInterface(IID_IMediaSeeking, (void **)&pMS);
    // !!! Right now we count on all sources being seekable
    if (FAILED(hr))
	return E_FAIL;
    // Make sure we're talking MEDIA TIME
    hr = pMS->SetTimeFormat(&TIME_FORMAT_MEDIA_TIME);
    // this will FAIL if we're not stopped, and that's OK

// we're not going to set a stop position
#if 0
    // what's the real stop time?
    if (m_prtStop[m_nCurSeg] == MAX_TIME) {
        hr = pMS->GetStopPosition(&m_prtStop[m_nCurSeg]);
        if (FAILED(hr)) {
	    m_prtStop[m_nCurSeg] = 3600*UNITS;	// !!! one hour OK?
        }
        DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("AUD:Real Stop time is %d"), (int)
				(m_prtStop[m_nCurSeg] / 10000)));
    }
#endif

    // We don't make the source do the rate, we do it ourselves
    hr = pMS->SetRate(1.0);
    // this could fail if not stopped

#if 0
    // seek to the piece of movie we're interested in
    // !!! HACK for MPEG... it sends 1/2s less than we ask for, so we better
    // ask for too much or the big switch will hang being shortchanged.
    // !!! we'll still break if m_prtStop is already near the end!
    REFERENCE_TIME stop = m_prtStop[m_nCurSeg];
    stop += 5000000;	// !!! wastes too much time?
#endif

    // I know we were asked to play until time n, but I'm going to tell it to
    // play all the way to the end.  If there's a gap in the file, and the stop
    // time is during the gap, we won't get enough samples to fill the whole
    // playing time.  If we play until the end, we'll get the first sample
    // after the gap, notice it's after the time we originally wanted to stop
    // at, and send silence to fill the gap, noticing there has been a gap.
    // The alternative is just trigger sending silence to fill the gap when
    // we get an EOS earlier than we expected.
    hr = pMS->SetPositions(&m_pSkew[m_nCurSeg].rtMStart,
			AM_SEEKING_AbsolutePositioning, NULL, 0);
    if (hr != S_OK) {
        // MPEG1 audio pin fails seek (the video pin does them) so we must
        // ignore this benign error.  (IVF parser may have a bug that makes it
        // not work with Dexter, but that's not our fault)
    }

    pMS->Release();

    // if the push thread was stopped, we won't get flushed, and this won't
    // have been updated
    // !!! I ASSUME the push thread won't be started until this thread does it
    // when this function returns, or there is a race condition
    m_rtLastSeek = m_rtNewLastSeek;

    // all done
    m_fSpecialSeek = FALSE;
    m_fSeeking = FALSE;

    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:Seg=%d  Seeking source to %d,%d ms"),
				m_nCurSeg,
				(int)(m_pSkew[m_nCurSeg].rtMStart / 10000),
				(int)(m_pSkew[m_nCurSeg].rtMStop / 10000)));

    // reset same stuff we reset when we start streaming
    Init();

    // only now that the above calculations were made, can we accept data again
    SetEvent(m_hEventSeek);

    return S_OK;
}


HRESULT CAudRepack::CheckInputType( const CMediaType * pmtIn )
{
    // always make sure major type is valid
    //
    if( *pmtIn->Type( ) != MEDIATYPE_Audio )
    {
        return E_INVALIDARG;
    }

    // always make sure minor type is valid
    //
    if( ( *pmtIn->Subtype( ) != MEDIASUBTYPE_PCM ) && ( *pmtIn->Subtype( ) != MEDIASUBTYPE_NULL ) )
    {
        return E_INVALIDARG;
    }

    // if user hasn't set a particular format, then accept it
    //
    if( !m_bMediaTypeSetByUser )
    {
        return NOERROR;
    }

    if( pmtIn->cbFormat != m_mtAccept.cbFormat )
    {
        return E_INVALIDARG;
    }

    LPBYTE lp1 = pmtIn->Format();
    LPBYTE lp2 = m_mtAccept.pbFormat;
    if (memcmp(lp1, lp2, pmtIn->FormatLength()) != 0)
    {
        return E_INVALIDARG;
    }

    return S_OK;
}


HRESULT CAudRepack::DecideBufferSize( IMemAllocator * pAlloc, ALLOCATOR_PROPERTIES * pProp )
{

    WAVEFORMATEX *pwfx =(WAVEFORMATEX *)(m_pInput->CurrentMediaType().Format());
    m_nSPS = pwfx->nSamplesPerSec;
    m_nSampleSize = pwfx->nChannels * ((pwfx->wBitsPerSample + 7) / 8);
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:Using %dHz %dbit %d"), m_nSPS,
            pwfx->wBitsPerSample, pwfx->nChannels));
    // !!! Why do we need to add 2?  Double check the math!
    m_nCacheSize = (int)(m_nSPS / m_dOutputFrmRate + 2); // round up to fit it!
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:Cache will hold %d samples"), m_nCacheSize));
    m_nCacheSize *= m_nSampleSize;
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:Cache is %d bytes"), m_nCacheSize));

    {
        // !!! is this right?
        pProp->cBuffers = 8;
        pProp->cbBuffer = m_nCacheSize;
	if (pProp->cbAlign == 0)
            pProp->cbAlign = 1;

        ALLOCATOR_PROPERTIES propActual;

        HRESULT hr = pAlloc->SetProperties(pProp, &propActual);
        if (FAILED(hr))
        {
            return hr;
        }

        if ((pProp->cBuffers > propActual.cBuffers)
            || (pProp->cbBuffer > propActual.cbBuffer)
           )
        {
            return E_FAIL;
        }
    }

    return NOERROR;
}

HRESULT CAudRepack::GetMediaType( int iPosition, CMediaType *pMediaType )
{
    if( !m_pInput->IsConnected( ) )
    {
        return E_INVALIDARG;
    }

    if( iPosition < 0 )
    {
        return E_INVALIDARG;
    }
    if( iPosition >= 1 )
    {
        return VFW_S_NO_MORE_ITEMS;
    }

    *pMediaType = m_pInput->CurrentMediaType();

    return NOERROR;
}


HRESULT CAudRepack::CheckTransform( const CMediaType * p1, const CMediaType * p2 )
{
    HRESULT hr;
    if (*p1 != *p2)
    {
        DbgLog((LOG_TRACE, TRACE_LOW,TEXT("AUD:CheckTransform - INVALID")));
        return VFW_E_INVALIDMEDIATYPE;
    }

    return NOERROR;
}


HRESULT CAudRepack::NewSegment( REFERENCE_TIME tStart, REFERENCE_TIME tStop, double Rate )
{
    ASSERT(Rate==1);   //since we only support this now.

    // ignore - we're all done, and m_nCurSeg is an invalid value to use
    if (m_nCurSeg == m_cTimes)
        return S_OK;

    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:NewSegment %d-%dms"),
            (int)(tStart / 10000), (int)(tStop / 10000)));

    // convert to timeline time
    REFERENCE_TIME rtNewStart, rtNewStop;
    // !!!! include rate in this calculation, since downstream will include it?
    if (m_rtLastSeek < 0) {
        // Never been seeked, so this is the beginning of what we're sending
        rtNewStart = m_pSkew[m_nCurSeg].rtTLStart;
        rtNewStop = m_pSkew[m_nCurSeg].rtTLStart + tStop - tStart;
    } else {
        // Skew the #'s, and send 'em on!
	rtNewStart = tStart;
        rtNewStop = tStop;
        if (rtNewStart < m_pSkew[m_nCurSeg].rtMStart)
	    rtNewStart = m_pSkew[m_nCurSeg].rtMStart;
        if (rtNewStart > m_pSkew[m_nCurSeg].rtMStop)
	    rtNewStart = m_pSkew[m_nCurSeg].rtMStop;
        rtNewStart = (REFERENCE_TIME)(m_pSkew[m_nCurSeg].rtTLStart +
		(rtNewStart - m_pSkew[m_nCurSeg].rtMStart) /
		m_pSkew[m_nCurSeg].dRate);
        if (rtNewStop < m_pSkew[m_nCurSeg].rtMStart)
	    rtNewStop = m_pSkew[m_nCurSeg].rtMStart;
        if (rtNewStop > m_pSkew[m_nCurSeg].rtMStop)
	    rtNewStop = m_pSkew[m_nCurSeg].rtMStop;
        rtNewStop = (REFERENCE_TIME)(m_pSkew[m_nCurSeg].rtTLStart +
		 (rtNewStop - m_pSkew[m_nCurSeg].rtMStart) /
		 m_pSkew[m_nCurSeg].dRate);

	m_rtLastSeek = rtNewStart;	// pretend we were seeked here
    }
    m_rtNewSeg = rtNewStart;
    DbgLog((LOG_TRACE,TRACE_HIGHEST,TEXT("NewSeg:Skewing %dms to %dms"),
			(int)(tStart / 10000), (int)(m_rtNewSeg / 10000)));

    m_rtPinNewSeg = tStart;	// save this too so we don't have to override
				// the pin class

    // What packet were we seeked into?
    m_llStartFrameOffset = Time2Frame( m_rtNewSeg, m_dOutputFrmRate );
    DbgLog((LOG_TRACE, TRACE_LOW,TEXT("AUD:Seek was to packet %d"),
						(int)m_llStartFrameOffset));

#ifdef NOFLUSH
    // special stuff unnecessary if we got a surprise flush too
    if (m_fExpectNewSeg || m_fFlushWithoutSeek) {
        // we might get 2 in a row
        // m_fExpectNewSeg = FALSE;
        return CTransformFilter::NewSegment( rtNewStart, rtNewStop, Rate );
    } else {
        // we weren't expecting a NewSeg.  It must mean that we are sharing
        // a parser with a video group that got seeked, and seeked us.  We will
        // get seeked too, eventually, and then send this NewSeg on.  Until then
        // do not deliver anything to the switch, it will screw it up. It does
        // not know about the seek yet.
    	DbgLog((LOG_TRACE,1,TEXT("Got SURPRISE NewSeg! Stop Delivering until Seek")));
        m_fSurpriseNewSeg = TRUE;
        m_rtSurpriseStart = rtNewStart;
        m_rtSurpriseStop = rtNewStop;
        ResetEvent(m_hEventSeek);
        return S_OK;
    }
#else
    return CTransformFilter::NewSegment( rtNewStart, rtNewStop, Rate );
#endif
}


void CAudRepack::Init()
{
    Free();

    m_pCache = new BYTE[m_nCacheSize];
    m_nInCache = 0;
    m_dError = 0.;
    m_pReadPointer = m_pCache;
    m_llSamplesDelivered = 0;
    m_llPacketsDelivered = 0;
    m_bFirstSample = TRUE;
    // flushing must reset this so that a real seek will kill a pending
    // segment seek, or else the segment seek will hang (won't flush the switch)
    m_fThreadCanSeek = FALSE;
}


HRESULT CAudRepack::StartStreaming()
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:StartStreaming")));

    // if we were stopped when this was set, it will not be reset, since we
    // won't have gotten an EndFlush from the seek trying to start us again
    m_fStopPushing = FALSE;

#ifdef NOFLUSH
    m_fExpectNewSeg = TRUE;     // we'll get one now
    m_fSurpriseNewSeg = FALSE;
#endif

    if (m_cTimes == 0)
	return E_UNEXPECTED;

    // make the event BEFORE creating the thread... it uses this!
    m_hEventThread = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_hEventThread == NULL) {
        return E_OUTOFMEMORY;
    }

    m_hEventSeek = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (m_hEventSeek == NULL) {
	CloseHandle(m_hEventThread);
	m_hEventThread = NULL;
        return E_OUTOFMEMORY;
    }

    // We need a thread to seek on if we are re-using our source
    if (m_cTimes > 1) {
	m_fThreadMustDie = FALSE;
	m_fThreadCanSeek = FALSE;
        if (m_worker.Create(this)) {
            m_worker.Run();
	}
    }

#ifdef DEBUG
    // before we begin, make sure all timeline times are on a frame boundary
    // !!! Play.  Stop.  Change the frame rate.  Play. These numbers will drift.
    //
    for (int z=0; z<m_cTimes; z++)
    {
	// !!! actually align instead of asserting?
    	LONGLONG llOffset = Time2Frame( m_pSkew[z].rtTLStart,
							m_dOutputFrmRate );
    	REFERENCE_TIME rtTest = Frame2Time( llOffset, m_dOutputFrmRate );
	ASSERT(rtTest == m_pSkew[z].rtTLStart);
#if 0	// this assert will fire (rounding error)
    	REFERENCE_TIME rt = m_prtStart[z] + m_prtSkew[z] +
			(REFERENCE_TIME) ((m_prtStop[z] - m_prtStart[z]) /
			m_pdRate[z]);
    	llOffset = Time2Frame( rt, m_dOutputFrmRate );
    	rtTest = Frame2Time( llOffset, m_dOutputFrmRate );
	ASSERT(rtTest == rt);
#endif
    }
#endif

    Init();
    // can't do this in Init.. BeginFlush mustn't reset this
    m_fFlushWithoutSeek = FALSE;

    IMediaSeeking *pMS;
    GUID guid;
    IPin *pPin = m_pInput->GetConnected();
    if (pPin == NULL)
        return CTransformFilter:: StartStreaming();

    // if we weren't seeked, but we're just playing ordinarily, we never
    // seeked upstream to get the piece of movie we're interested in.  Do it now
    if (m_rtLastSeek < 0) {
	ASSERT(m_nCurSeg == 0);
	m_nCurSeg--;
	NextSegment(FALSE);
    }

    return CTransformFilter:: StartStreaming();
}


HRESULT CAudRepack::StopStreaming()
{
    // make sure we're not in receive (redundant!)
    CAutoLock foo(&m_csReceive);

    if (m_hEventSeek) {
        CloseHandle(m_hEventSeek);
        m_hEventSeek = NULL;
    }
    if (m_hEventThread) {
        CloseHandle(m_hEventThread);
        m_hEventThread = NULL;
    }
    return CTransformFilter::StopStreaming();
}


STDMETHODIMP CAudRepack::Stop()
{
    // If we have a thread, kill it. This thread can take our filter critsec,
    // so we must do this OUTSIDE of that crit sec!
    if (m_hEventThread && m_cTimes > 1) {
	m_fThreadMustDie = TRUE;
	SetEvent(m_hEventThread);
	m_worker.Stop();
	m_worker.Exit();
	m_worker.Close();
    }

    CAutoLock lck1(&m_csFilter);
    if (m_State == State_Stopped) {
        return NOERROR;
    }

    // Succeed the Stop if we are not completely connected

    ASSERT(m_pInput == NULL || m_pOutput != NULL);
    if (m_pInput == NULL || m_pInput->IsConnected() == FALSE ||
        m_pOutput->IsConnected() == FALSE) {
                m_State = State_Stopped;
                m_bEOSDelivered = FALSE;
                return NOERROR;
    }

    ASSERT(m_pInput);
    ASSERT(m_pOutput);

    // decommit the input pin before locking or we can deadlock
    m_pInput->Inactive();

    // synchronize with Receive calls

    CAutoLock lck2(&m_csReceive);
    m_pOutput->Inactive();

    // allow a class derived from CTransformFilter
    // to know about starting and stopping streaming

    HRESULT hr = StopStreaming();
    if (SUCCEEDED(hr)) {
	// complete the state transition
	m_State = State_Stopped;
	m_bEOSDelivered = FALSE;
    }
    return hr;
}


HRESULT CAudRepack::Receive(IMediaSample * pIn)
{
    // Stop pushing data to me!
    if (m_fStopPushing) {
	return E_FAIL;
    }

    HRESULT hr = 0;
    CAutoLock foo(&m_csReceive);

    // maybe we're in the middle of seeking and are supposed to wait before
    // accepting data
    WaitForSingleObject(m_hEventSeek, INFINITE);

    if (m_nCurSeg == m_cTimes) {
	return E_FAIL;
    }

    // We should never see a preroll!
    ASSERT(pIn->IsPreroll() != S_OK);
    if (pIn->IsPreroll() == S_OK)
        return NOERROR;

    // make sure sample size is not zero
    long InLen = pIn->GetActualDataLength();
    DbgLog((LOG_TRACE, TRACE_LOW,TEXT("AUD:Received %d bytes"), InLen));
    if (!InLen) {
        return NOERROR;
    }

    // get the sample times, this will always work
    //
    REFERENCE_TIME trStart = 0;
    REFERENCE_TIME trStop = 0;
    hr = pIn->GetTime(&trStart, &trStop);
    trStart += m_rtPinNewSeg;
    trStop += m_rtPinNewSeg;
    DbgLog((LOG_TRACE, TRACE_LOW,TEXT("AUD:Receive Start=%d Stop=%d ms"),
        (int)(trStart / 10000), (int)(trStop / 10000)));

    // the time stamp we just received... skewed and rate converted
    trStart = (REFERENCE_TIME)(m_pSkew[m_nCurSeg].rtTLStart +
				(trStart - m_pSkew[m_nCurSeg].rtMStart) /
				m_pSkew[m_nCurSeg].dRate);
    trStop = (REFERENCE_TIME)(m_pSkew[m_nCurSeg].rtTLStart +
				(trStop - m_pSkew[m_nCurSeg].rtMStart) /
				m_pSkew[m_nCurSeg].dRate);

    // What packet is the sample we first received a part of?
    REFERENCE_TIME llOffset = Time2Frame( trStart, m_dOutputFrmRate );
    DbgLog((LOG_TRACE, TRACE_LOW,TEXT("AUD:Audio received starts at packet %d"),
                        (int)llOffset));

    // what time stamp the thing we deliver needs to have
    REFERENCE_TIME rtPacketStart, rtPacketStop;
    rtPacketStart = Frame2Time(m_llStartFrameOffset + m_llPacketsDelivered,
							m_dOutputFrmRate );
    rtPacketStop = Frame2Time(m_llStartFrameOffset + m_llPacketsDelivered + 1,
							m_dOutputFrmRate );

    BYTE *pSampleData = NULL;
    hr = pIn->GetPointer(&pSampleData);
    if (hr != NOERROR)
        return E_FAIL;

    // !!! We won't always be delivered audio samples where the time stamps
    // are what we expect, given how much PCM data we get.  EG:
    //
    // 1. If the rate is supposed to be 44100.3, that can't be expressed
    // (integers only allowed) so the source filter will probably handle that
    // by having the time stamps slightly off so we can tell we're supposed
    // to play the audio at 44100.3, even though the format is 44100
    //
    // 2. Live capture, using a random clock, will have time stamps WAY OFF
    // compared to #1.  We need to trust the time stamps
    //
    // !!! We are going to drift out of sync in these cases!  To prevent it,
    // we need to sample rate convert everything coming in so the amount of
    // data matches the time stamps exactly.  Just dropping samples, or adding
    // silence will harm the audio quality, probably immensely. Even doing a
    // sample rate conversion on the whole packet will hurt the audio unless
    // it's anti-aliased.
    //
    // !!! So right now, this problem is ignored, and there is possible drift!

    BYTE * pFreeMe = NULL;

    // I am going to drop/add samples from the first thing ever delivered to
    // me, so the sync starts out right.  But I am NOT going to do this
    // during playback to try and keep in sync (see above)

    // we received stuff that belongs in an earlier packet... get rid of it!
    if (trStart < rtPacketStart && m_bFirstSample) {

	// throw away this many bytes, (account for rate)
	// CAREFUL:  Make sure bytes is a multiple of 4
	int samples = (int)((rtPacketStart - trStart) * m_nSPS / 10000000
					 * m_pSkew[m_nCurSeg].dRate);
	int bytes = samples * m_nSampleSize;
        DbgLog((LOG_TRACE, TRACE_LOW,TEXT("AUD:throw away %d inbytes"),
                        				(int)bytes));
	if (bytes >= InLen) {
	    m_trStopLast = trStop;
	    return S_OK;
	}
	pSampleData += bytes;
	InLen -= bytes;
    }

    // we received stuff later than what we expected... prepend with silence
    // Or, we have a discontinuity... let's at least get back in sync after
    // each discontinuity.
    // !!! Ick, memory copy

    BOOL fPrependSilence = FALSE;
    REFERENCE_TIME rtSilenceStart;
    if (rtPacketStart < trStart && m_bFirstSample) {
	fPrependSilence = TRUE;
	rtSilenceStart = rtPacketStart;
    }
    if (pIn->IsDiscontinuity() == S_OK && trStart > m_trStopLast + 1 &&
						m_bFirstSample == FALSE) {
	fPrependSilence = TRUE;
	rtSilenceStart = m_trStopLast;
    }

    if (fPrependSilence) {
	// put some silence in front of what we got (account for rate)
	// CAREFUL:  Make sure bytes is a multiple of 4
	int samples = (int)((trStart - rtSilenceStart) * m_nSPS / 10000000
					 * m_pSkew[m_nCurSeg].dRate);
	int bytes = samples * m_nSampleSize;
	if (bytes > 0) {
	    BYTE *pNew = (BYTE *)QzTaskMemAlloc(bytes + InLen);
	    if (pNew == NULL) {
		return E_OUTOFMEMORY;
	    }
            DbgLog((LOG_TRACE, TRACE_LOW,TEXT("AUD:Added %d bytes of silence"),
                        				(int)bytes));
	    ZeroMemory(pNew, bytes);
	    CopyMemory(pNew + bytes, pSampleData, InLen);
	    pSampleData = pNew;
	    InLen += bytes;
	    pFreeMe = pSampleData;
	}
    }
    m_bFirstSample = FALSE;
    m_trStopLast = trStop;

    // !!! Only works for 16 bit stereo
    // !!! Anti-alias it!

    // Now convert the samples using this inefficent algorithm.
    // Don't let errors propogate... at least I do one thing cleverly
    if (m_pSkew[m_nCurSeg].dRate != 1.0) {
	LONG nIn = InLen / 4;
	ASSERT(nIn * 4 == InLen);
 	double dOut = nIn / m_pSkew[m_nCurSeg].dRate;
	LONG nOut = (LONG)(dOut + m_dError);

	LPDWORD lpIn = (LPDWORD)pSampleData;
	if (m_cResample == 0) {
	    m_pResample = (LPBYTE)QzTaskMemAlloc(nOut * 4);
	    m_cResample = nOut * 4;
	} else if (nOut * 4 > m_cResample) {
	    m_pResample = (LPBYTE)QzTaskMemRealloc(m_pResample, nOut * 4);
	    m_cResample = nOut * 4;
 	}
	LPDWORD lpOut = (LPDWORD)m_pResample;
	if (lpOut == NULL) {
	    if (pFreeMe)
		QzTaskMemFree(pFreeMe);
	    return E_OUTOFMEMORY;
	}

	double d = (double)nOut / nIn;
	double dErr = 0.;
        LPDWORD lpdwEnd = (LPDWORD)(pSampleData + InLen);
	do {
	    LONG n = (LONG)(d + dErr);
            for (int z=0; z < n; z++)
	        *lpOut++ = *lpIn;
	    lpIn++;
	    dErr = d + dErr - n;
	} while (lpIn < lpdwEnd);

	// fix up these variables to fall through
	if (pFreeMe)
	    QzTaskMemFree(pFreeMe);
	pFreeMe = NULL;
	pSampleData = m_pResample;
        // how many bytes did we output?
	InLen = (LONG) ((LPBYTE)lpOut - (LPBYTE)m_pResample);
        // update the running error with how much we made vs. wanted to make
	m_dError = dOut - InLen / 4;
        DbgLog((LOG_TRACE, TRACE_LOW,TEXT("AUD:RATE ADJUSTED: Became %d bytes"), InLen));
    }

    // as long as we have data in the incoming buffer,
    // copy it to the cache, and possibly deliver it
    //
    while(InLen > 0) {
        int nBytesToSend, nSamplesToSend;

	// !!! this is the same code as EndOfStream!  there are 2 copies!

	// don't send anything after our end time... it'll confuse the switch
	// (the RHS could round too low, so fudge by 1ms)
	if (rtPacketStart + 10000 >= m_pSkew[m_nCurSeg].rtTLStop) {
	    // looks like we're done
	    EndOfStream();
	    if (pFreeMe)
		QzTaskMemFree(pFreeMe);
	    // We can't trust sources to stop pushing, and unfortunately, Dexter
	    // will hang if it doesn't. (Seeking ourself to the next segment
	    // doesn't let the flush go downstream or it confuses other filters,
	    // so we have to make sure the push thread can't ever block).
	    // So, from now on, fail any calls to GetBuffer or Receive
	    m_fStopPushing = TRUE;
            return E_FAIL;
	}

	// if this sample is too early, don't send it or you'll confuse the
	// switch - skip this GetBuffer and Deliver
	BOOL fAvoid = FALSE;
	if (rtPacketStart < m_pSkew[m_nCurSeg].rtTLStart) {
	    fAvoid = TRUE;
	}

        // how many samples will need to have been sent after this packet
        // goes out?
        LONGLONG ll = Time2Frame( rtPacketStop, m_nSPS );

        // How many samples would have gone out if we had started at the
	// beginning and sent up to the point we were seeked to (and really
	// began from?)
        REFERENCE_TIME rt = Frame2Time( m_llStartFrameOffset, m_dOutputFrmRate );
        llOffset = Time2Frame( rt, m_nSPS );

        // That tells us how many samples need to go out this time
        nSamplesToSend = (int)(ll - (m_llSamplesDelivered + llOffset));
	ASSERT(nSamplesToSend > 0);	// we're messed up and about to die!
	if (nSamplesToSend <= 0) {
	    hr = E_UNEXPECTED;
	    EndOfStream();
	    break;		// try not to hang
	}
        nBytesToSend = nSamplesToSend * m_nSampleSize;
        DbgLog((LOG_TRACE, TRACE_LOW,TEXT("AUD:Need to send %d bytes %d samples"),
						nBytesToSend, nSamplesToSend));

        // calculate how much more the cache needs
        long CacheFreeSpace = nBytesToSend - m_nInCache;

        // calculate how much we can copy
        long CopySize = min(CacheFreeSpace, InLen);
	ASSERT(CopySize >= 0);

	if (CopySize > 0) {
            CopyMemory(m_pReadPointer, pSampleData, CopySize);
	}

        // advance the pointers, etc
        //
        m_pReadPointer += CopySize;
        pSampleData += CopySize;
        InLen -= CopySize;
        m_nInCache += CopySize;

        // do we have enough to deliver?
        //
        if (m_nInCache == nBytesToSend)
        {
            // yep.

	    hr = S_OK;
	    if (!fAvoid) {
                hr = DeliverOutSample(m_pCache, nBytesToSend, rtPacketStart,
                            rtPacketStop);
	    }
            if (hr != S_OK) {
                DbgLog((LOG_ERROR,1,TEXT("*AUD:Deliver FAILED - DIE!")));
                // don't send an extra EOS, that will screw up the switch
                m_fStopPushing = TRUE;
                break;
	    }

            m_llSamplesDelivered += nSamplesToSend;
            m_llPacketsDelivered += 1;
            m_nInCache = 0;
            m_pReadPointer = m_pCache;
        }

        // packet size varies by as much as 1 sample each time.  How many
        // bytes are we supposed to send this time? (prepare for next loop)
        rtPacketStart = Frame2Time(m_llStartFrameOffset + m_llPacketsDelivered,
							m_dOutputFrmRate);
        rtPacketStop = Frame2Time(m_llStartFrameOffset+m_llPacketsDelivered + 1,
							m_dOutputFrmRate );
    }

    if (pFreeMe)
	QzTaskMemFree(pFreeMe);
    return hr;
}

HRESULT CAudRepack::DeliverOutSample(BYTE * pData, int nBytesToSend, REFERENCE_TIME rtPacketStart, REFERENCE_TIME rtPacketStop)
{
    if (nBytesToSend <= 0) {
	return S_OK;
    }

    IMediaSample * pOutSample = NULL;

    // remove the new segment offset from the time stamps before stamping
    rtPacketStart -= m_rtNewSeg;
    rtPacketStop -= m_rtNewSeg;

    HRESULT hr = m_pOutput->GetDeliveryBuffer(&pOutSample, &rtPacketStart,
							&rtPacketStop, 0);
    if( FAILED(hr)) {
        m_llPacketsDelivered = MAX_TIME;        // don't recurse
        EndOfStream();  // our fault
        return hr;
    }

    // !!! more?
    pOutSample->SetDiscontinuity(FALSE);
    pOutSample->SetSyncPoint(TRUE);

    hr = pOutSample->SetTime(&rtPacketStart, &rtPacketStop);
    if( FAILED(hr))
    {
        pOutSample->Release( );
        m_llPacketsDelivered = MAX_TIME;        // don't recurse
        EndOfStream();  // our fault we're not delivering anymore
        return hr;
    }
    DbgLog((LOG_TRACE, TRACE_LOW,TEXT("AUD:Sent %d bytes as %d,%d"), nBytesToSend,
        (int)(rtPacketStart / 10000), (int)(rtPacketStop / 10000)));

    BYTE *pOutBuffer = NULL;
    pOutSample->GetPointer(&pOutBuffer);
    CopyMemory(pOutBuffer, pData, nBytesToSend);
    pOutSample->SetActualDataLength(nBytesToSend);

    hr = m_pOutput->Deliver(pOutSample);

    pOutSample->Release( );

    return hr;
}


HRESULT CAudRepack::BeginFlush()
{
    HRESULT hr = S_OK;
    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("AUD:BeginFlush")));

    // make sure Receive is not blocked
    SafeSetEvent(m_hEventSeek);

    // don't flush downstream if we're doing a special seek to the next segment
    if (!m_fSpecialSeek) {
        hr = CTransformFilter::BeginFlush();
    }

    // make sure receive is done before calling init on the variables used in
    // receive
    CAutoLock foo(&m_csReceive);

    // do the flush
    Init();

    // if we get flushed without a seek having been made, that's a surprise.
    // It hopefully means the other chain of our shared source caused the seek
    if (m_fSeeking) {
	m_fFlushWithoutSeek = FALSE;
    } else {
	// wait for EndFlush to set m_fFlushWithoutSeek
    }

    return hr;
}


HRESULT CAudRepack::EndFlush()
{
    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("AUD:EndFlush")));

    // hold off the new receives that will come in until we're ready for them
    if (m_fSeeking) {
	m_rtLastSeek = m_rtNewLastSeek;	// time to update this
	m_nCurSeg = m_nSeekCurSeg;	// the NewSeg about to be generated
					// needs this set
    	SafeResetEvent(m_hEventSeek);
    } else {
	// This needs to be set before the NewSeg that's about to arrive after
	// the flush.  When sharing a source, we never have multiple segments
	m_nCurSeg = 0;
	if (m_fFlushWithoutSeek) {
	    // If this is set, we've already seen a seek.  Now that the flush
	    // has arrived, we're done
    	    DbgLog((LOG_TRACE,2,TEXT("OK to proceed")));
	    m_fFlushWithoutSeek = FALSE;
	} else {
	    // We haven't seen a seek yet.  This is a surprise flush
    	    DbgLog((LOG_TRACE,2,TEXT("state=2. Wait for Seek")));
    	    SafeResetEvent(m_hEventSeek);
	    m_fFlushWithoutSeek = TRUE;
	}
    }

    m_fStopPushing = FALSE;	// OK to deliver to me again

    // If we got flushed without seeking, it probably means our shared source
    // got seeked by the other stream.  We'll get a seek later, and only then
    // can we resume delivering, or the switch won't be ready to receive the
    // new data yet.

    // don't flush downstream if we're doing a special seek to the next segment
    if (!m_fSpecialSeek) {
        return CTransformFilter::EndFlush();
    }
    return S_OK;
}


HRESULT CAudRepack::EndOfStream( )
{
    if (m_fStopPushing) {
        DbgLog((LOG_TRACE,TRACE_HIGHEST,TEXT("AUD: Ignoring bogus EOS")));
	return S_OK;
    }

    // ignore - we're all done, and m_nCurSeg is an invalid value to use
    if (m_nCurSeg == m_cTimes)
        return S_OK;

    DbgLog((LOG_TRACE,TRACE_HIGHEST,TEXT("AUD:EndOfStream")));

    // Uh oh!  We got an end of stream before we sent enough data to keep
    // the switch from panicing! We MUST deliver the last stuff in our buffer
    // followed by silence until we've sent enough
    // DO NOT, however, deliver past the end time we're supposed to, or we'll
    // mess the switch up! If the number of samples left to send is some tiny
    // fraction of the amount we send each time, it means we really are done,
    // sending even 1 more packet will be too much

    while (1)
    {
        // fill the rest of the cache with 0's
        //
        long CacheFreeSpace = m_nCacheSize - m_nInCache;
        ZeroMemory(m_pCache + m_nInCache, CacheFreeSpace);

        REFERENCE_TIME rtStart, rtStop;

        // !!! this is the same code as Receive!  there are 2 copies!

        // packet size varies by as much as 1 sample each time.  How many
        // bytes are we supposed to send this time?
        rtStart = Frame2Time( m_llStartFrameOffset + m_llPacketsDelivered, m_dOutputFrmRate );
        rtStop = Frame2Time( m_llStartFrameOffset + m_llPacketsDelivered + 1, m_dOutputFrmRate );

	// we're all done
	// (the RHS could round too low, so fudge by 1ms)
	if (rtStart + 10000 >= m_pSkew[m_nCurSeg].rtTLStop) {
	    // looks like we're done
            break;
	}

        DbgLog((LOG_TRACE,2,TEXT("Delivering the left over bits")));

        // how many samples should have been sent (total) after this packet
        // goes out?
        LONGLONG ll = Time2Frame( rtStop, m_nSPS );

        // How many samples would have gone out if we had started at the
	// beginning and sent up to the point we were seeked to (and really
	// began from?)
        REFERENCE_TIME rt = Frame2Time( m_llStartFrameOffset, m_dOutputFrmRate );
        LONGLONG llOffset = Time2Frame( rt, m_nSPS );


        // That tells us how many samples need to go out this time
        int nSamplesToSend = (int)(ll - (m_llSamplesDelivered + llOffset));
        if (nSamplesToSend <= 0)
            break;      // we're all done
        int nBytesToSend = nSamplesToSend * m_nSampleSize;

        HRESULT hr = DeliverOutSample(m_pCache, nBytesToSend, rtStart, rtStop);
	// What if this fails?
	if (FAILED(hr)) {
            DbgLog((LOG_ERROR,1,TEXT("Deliver FAILED - we're dead?")));
	    break;
	}

	m_nInCache = 0;
	m_llSamplesDelivered += nSamplesToSend;
	m_llPacketsDelivered += 1;
    }

    // all done this segment, now for the next one
    NextSegment(TRUE);

    // DONT propogate the EOS until ALL SEGMENTS done
    return S_OK;
}


// IPersistStream

// tell our clsid
//
STDMETHODIMP CAudRepack::GetClassID(CLSID *pClsid)
{
    CheckPointer(pClsid, E_POINTER);
    *pClsid = CLSID_AudRepack;
    return S_OK;
}

typedef struct _AUDSave {
    int version;
    double dFrmRate;
    int cTimes;
} AUDSave;

// persist ourself
// !!! save the media type someday?
//
HRESULT CAudRepack::WriteToStream(IStream *pStream)
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:WriteToStream")));

    CheckPointer(pStream, E_POINTER);

    int savesize = sizeof(AUDSave) + m_cTimes * sizeof(AUDSKEW);
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:Persisted data is %d bytes"), savesize));

    AUDSave *px = (AUDSave *)QzTaskMemAlloc(savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("AUD:*** Out of memory")));
	return E_OUTOFMEMORY;
    }
    px->version = 1;
    px->dFrmRate = m_dOutputFrmRate;
    px->cTimes = m_cTimes;

    BYTE *pb;
    pb=(BYTE *)(px)+sizeof(AUDSave);
    if (m_cTimes) {
        CopyMemory(pb, m_pSkew, sizeof(AUDSKEW) * m_cTimes);
        pb += sizeof(AUDSKEW) * m_cTimes;
    }

    HRESULT hr = pStream->Write(px, savesize, 0);
    QzTaskMemFree(px);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** AUD:WriteToStream FAILED")));
        return hr;
    }
    return NOERROR;
}


// load ourself
//
HRESULT CAudRepack::ReadFromStream(IStream *pStream)
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:ReadFromStream")));

    CheckPointer(pStream, E_POINTER);

    int savesize=sizeof(AUDSave);

    // we don't yet know how many saved connections there are
    // all we know we have for sure is the beginning of the struct
    AUDSave *px = (AUDSave *)QzTaskMemAlloc(savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("AUD:*** Out of memory")));
	return E_OUTOFMEMORY;
    }

    HRESULT hr = pStream->Read(px, savesize, 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("AUD:*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    put_OutputFrmRate(px->dFrmRate);

    // how much saved data was there, really?  Get the rest
    savesize += px->cTimes * sizeof(AUDSKEW);
    px = (AUDSave *)QzTaskMemRealloc(px, savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("AUD:*** Out of memory")));
        return E_OUTOFMEMORY;
    }

    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:Persisted data is %d bytes"), savesize));

    BYTE *pb;
    pb=(BYTE *)(px)+sizeof(AUDSave) ;
    hr = pStream->Read(pb, (savesize-sizeof(AUDSave)), 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("AUD:*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    ClearStartStopSkew();
    for (int z=0; z<px->cTimes; z++) {
        AUDSKEW *pSkew = (AUDSKEW *)pb;
	REFERENCE_TIME rtStart = pSkew->rtMStart;
	REFERENCE_TIME rtStop = pSkew->rtMStop;
	REFERENCE_TIME rtSkew = pSkew->rtSkew;
	double dRate = pSkew->dRate;
        AddStartStopSkew(rtStart, rtStop, rtSkew, dRate);
	pb += sizeof(AUDSKEW);
    }

    QzTaskMemFree(px);
    SetDirty(FALSE);
    return S_OK;
}


// how big is our save data?
//
int CAudRepack::SizeMax()
{
    return sizeof(AUDSave) + m_cTimes * 3 * sizeof(REFERENCE_TIME) +
			    m_cTimes * sizeof(double);
}



//
// IDexterSequencer implementation
//


//
// get_OutputFrmRate(double *PFS)
//
STDMETHODIMP CAudRepack::get_OutputFrmRate(double *dpFrmRate)
{
    CAutoLock cAutolock(&m_csFilter);
    CheckPointer(dpFrmRate,E_POINTER);
    *dpFrmRate = m_dOutputFrmRate;
    return NOERROR;
}


//
// put_OutputFrmRate
//
// Set the required FrmRateSpeed
//
STDMETHODIMP CAudRepack::put_OutputFrmRate(double dFrmRate)
{
    CAutoLock cAutolock(&m_csFilter);
    if (dFrmRate == m_dOutputFrmRate) {
        return S_OK;    // what-EVER!
    }
    if (m_State != State_Stopped) {
	return VFW_E_NOT_STOPPED;
    }
    BOOL fReconnect = FALSE;
    if (m_pInput && m_pInput->IsConnected() && dFrmRate < m_dOutputFrmRate) {
        fReconnect = TRUE;
    }

    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:put_OutputFrmRate to %d/10 fps"),
                        (int)(dFrmRate * 10)));
    m_dOutputFrmRate = dFrmRate;
    SetDirty(TRUE);

    // a smaller frame rate may mean bigger buffers needed in this allocator
    if (fReconnect) {
        m_pGraph->Reconnect(m_pOutput);
    }

    return NOERROR;
}


STDMETHODIMP CAudRepack::GetStartStopSkew(REFERENCE_TIME *pStart, REFERENCE_TIME *pStop, REFERENCE_TIME *pSkew, double *pdRate)
{
    CAutoLock cAutolock(&m_csFilter);

    CheckPointer(pStart,E_POINTER);
    CheckPointer(pStop,E_POINTER);
    CheckPointer(pSkew,E_POINTER);
    CheckPointer(pdRate,E_POINTER);

    for (int i = 0; i < m_cTimes; i++) {
        pStart[i] = m_pSkew[i].rtMStart;
        pStop[i] = m_pSkew[i].rtMStop;
        pSkew[i] = m_pSkew[i].rtSkew;
        pdRate[i] = m_pSkew[i].dRate;
    }

    return NOERROR;
}


// Sort the new one into the list
//
STDMETHODIMP CAudRepack::AddStartStopSkew(REFERENCE_TIME Start, REFERENCE_TIME Stop, REFERENCE_TIME Skew, double dRate)
{
    CAutoLock cAutolock(&m_csFilter);

    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:ADD Start %d  Stop %d  Skew %d ms  Rate %d/100"),
				(int)(Start / 10000), (int)(Stop / 10000),
				(int)(Skew / 10000), (int)(dRate * 100)));

    //can not change times if our filter is not currently stopped
    if(!IsStopped() )
	return VFW_E_WRONG_STATE;

    if (m_cTimes == m_cMaxTimes) {
	m_cMaxTimes += 10;
	if (m_pSkew)
	    m_pSkew = (AUDSKEW *)QzTaskMemRealloc(m_pSkew,
					m_cMaxTimes * sizeof(AUDSKEW));
	else
	    m_pSkew = (AUDSKEW *)QzTaskMemAlloc(m_cMaxTimes * sizeof(AUDSKEW));
	if (m_pSkew == NULL) {
	    m_cMaxTimes = 0;
	    return E_OUTOFMEMORY;
	}
    }

    if( dRate == 0.0 )
    {
        // go look for the time we want to extend
        //
#ifdef DEBUG
        bool fHosed = true;
#endif
        for( int z = 0 ; z < m_cTimes ; z++ ) {
            REFERENCE_TIME rtLastTLStart = m_pSkew[z].rtTLStart;
            REFERENCE_TIME rtLastTLStop = m_pSkew[z].rtTLStop;

            if( AreTimesAndRateReallyClose( rtLastTLStop, Start + Skew,
                        m_pSkew[z].rtMStop, Start, 0.0, 0.0, m_dOutputFrmRate))
            {
                m_pSkew[z].rtMStop += Stop - Start;
                m_pSkew[z].rtTLStop = m_pSkew[z].rtMStart + m_pSkew[z].rtSkew +
                    (REFERENCE_TIME)((m_pSkew[z].rtMStop - m_pSkew[z].rtMStart)
                                / m_pSkew[z].dRate);
                // the above math will have a rounding error, and rtTLStop won't
                // be frame aligned, so we better fix that
                LONGLONG ll = RoundTime2Frame(m_pSkew[z].rtTLStop, m_dOutputFrmRate);
                m_pSkew[z].rtTLStop = Frame2Time(ll, m_dOutputFrmRate);
#ifdef DEBUG
                fHosed = false;
#endif
                break;
            }
        }
#ifdef DEBUG
        if (fHosed) ASSERT(FALSE);    // we're dead!
#endif
    }
    else
    {
        // merge it sorted by timeline time into the list
        //
        for (int z=0; z<m_cTimes; z++)
        {
            // calculate the TL Start for this one
            //
            REFERENCE_TIME TLStartNext = Start + Skew;

            // calculate the TL Stop for the last one
            //
            REFERENCE_TIME TLStopLast = m_pSkew[z].rtTLStop;

            REFERENCE_TIME MediaStartNext = Start;
            REFERENCE_TIME MediaStopLast = m_pSkew[z].rtMStop;

	    if (Start + Skew < m_pSkew[z].rtTLStart)
            {
    	        for (int y = m_cTimes - 1; y >= z; y--)
                {
    		    m_pSkew[y + 1] = m_pSkew[y];
	        }
	        break;
	    }
        }

        m_pSkew[z].rtMStart = Start;
        m_pSkew[z].rtMStop = Stop;
        m_pSkew[z].rtSkew = Skew;
        m_pSkew[z].dRate = dRate;
        m_pSkew[z].rtTLStart = Start + Skew;
        m_pSkew[z].rtTLStop = Start + Skew +
                                (REFERENCE_TIME)((Stop - Start) / dRate);

        m_cTimes++;
    }

#if 0	// do this only if cleared and then re-added?
    // need to recalc last seek time if we were seeked and then this is changed
    // !!! sync with Seek command!
    if (m_rtLastSeek >= 0)
	m_rtLastSeek += (Skew - m_rtSkew);
#endif

    SetDirty(TRUE);
    return S_OK;
}


STDMETHODIMP CAudRepack::GetStartStopSkewCount(int *pCount)
{
    CheckPointer(pCount, E_POINTER);
    *pCount = m_cTimes;
    return NOERROR;
}


STDMETHODIMP CAudRepack::ClearStartStopSkew()
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:ClearStartStopSkew")));
    CAutoLock cAutolock(&m_csFilter);

    //can not change duration if our filter is not currently stopped
    if(!IsStopped() )
      return VFW_E_WRONG_STATE;

    if (m_pSkew)
	QzTaskMemFree(m_pSkew);
    m_pSkew = NULL;

    m_cTimes = 0;
    m_cMaxTimes = 0;
    SetDirty(TRUE);

    return NOERROR;
}


STDMETHODIMP CAudRepack::get_MediaType( AM_MEDIA_TYPE * pmt )
{
    CAutoLock cAutolock(&m_csFilter);
    CheckPointer(pmt, E_POINTER);
    if (!m_bMediaTypeSetByUser)
	return E_UNEXPECTED;
    CopyMediaType(pmt, &m_mtAccept);
    return S_OK;
}

STDMETHODIMP CAudRepack::put_MediaType( const AM_MEDIA_TYPE * pmt )
{
    CAutoLock cAutolock(&m_csFilter);
    CheckPointer(pmt, E_POINTER);
    if (m_State != State_Stopped)
        return VFW_E_NOT_STOPPED;

    if (m_pInput && m_pInput->IsConnected())
        return VFW_E_ALREADY_CONNECTED;

    if (m_pOutput && m_pOutput->IsConnected())
        return VFW_E_ALREADY_CONNECTED;

    FreeMediaType(m_mtAccept);
    CopyMediaType(&m_mtAccept, pmt);
    SetDirty(TRUE);
    m_bMediaTypeSetByUser = true;

    return S_OK;
}


// --- ISpecifyPropertyPages ---

STDMETHODIMP CAudRepack::GetPages (CAUUID *pPages)

  { // GetPages //

    pPages->cElems = 1;
    pPages->pElems = (GUID *)CoTaskMemAlloc(sizeof(GUID));

    if (pPages->pElems == NULL)
    return E_OUTOFMEMORY;

    *(pPages->pElems) = CLSID_AUDProp;

    return NOERROR;

  } // GetPages



//////////////////////////////////////////////////////////////////////////
//
// CAudRepackInputPin
//
//////////////////////////////////////////////////////////////////////////
CAudRepackInputPin::CAudRepackInputPin(TCHAR       *pObjectName,
           CAudRepack *pBaseFilter,
           HRESULT     *phr,
           LPCWSTR      pPinName)
    : CTransformInputPin(pObjectName, pBaseFilter, phr, pPinName),
      m_pAudRepack(pBaseFilter)
{
}


CAudRepackInputPin::~CAudRepackInputPin()
{
}

// Offer MajorType AUDIO so intelligent connect can be way faster
// Don't offer a complete Mediatype... this exposes a bug in the MP3 decoder
// which will cease to function
//
HRESULT CAudRepackInputPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    if (iPosition < 0) {
        return E_INVALIDARG;
    }
    if (iPosition > 0) {
        return VFW_S_NO_MORE_ITEMS;
    }

    FreeMediaType(*pMediaType); // just in case
    pMediaType->SetType(&MEDIATYPE_Audio);
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////
//
// CAudRepackOutputPin
//
//////////////////////////////////////////////////////////////////////////
CAudRepackOutputPin::CAudRepackOutputPin(TCHAR       *pObjectName,
           CAudRepack *pBaseFilter,
           HRESULT     *phr,
           LPCWSTR      pPinName)
    : CTransformOutputPin(pObjectName, pBaseFilter, phr, pPinName),
      m_pAudRepack(pBaseFilter),
      m_pAudPassThru(NULL)
{
    ASSERT(pBaseFilter);
    DbgLog((LOG_TRACE, 2, TEXT("CAudRepackOutputPin()")));

}

CAudRepackOutputPin::~CAudRepackOutputPin()
{
    if( m_pAudPassThru)
    delete m_pAudPassThru;
    DbgLog((LOG_TRACE, 2, TEXT("~CAudRepackOutputPin()")));
}

//
// NonDelegatingQueryInterface
//
STDMETHODIMP CAudRepackOutputPin::NonDelegatingQueryInterface (REFIID riid, void ** ppv)
{
    CheckPointer(ppv,E_POINTER);
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    *ppv = NULL;

    if (riid == IID_IMediaSeeking ) {
    //
    // Create a seeking implementation
    //
    ASSERT(m_pAudRepack->m_pInput != NULL);

    if (m_pAudPassThru == NULL)
    {
        HRESULT hr = S_OK;
        m_pAudPassThru = new  CAudPassThru (NAME("Audio Pass Through"),
                    GetOwner(),
                    &hr,
                     (IPin *)m_pAudRepack->m_pInput,
                     m_pAudRepack);

        if (FAILED(hr)) {
        return hr;
        }
    }
     return m_pAudPassThru->NonDelegatingQueryInterface(riid, ppv);
    }
    else {
    return CTransformOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}



CAudWorker::CAudWorker()
{
}

HRESULT CAudWorker::Create(CAudRepack *pAud)
{
    m_pAud = pAud;

    return CAMThread::Create();
}

HRESULT CAudWorker::Run()
{
    return CallWorker(CMD_RUN);
}

HRESULT CAudWorker::Stop()
{
    return CallWorker(CMD_STOP);
}

HRESULT CAudWorker::Exit()
{
    return CallWorker(CMD_EXIT);
}



// called on the worker thread to do all the work. Thread exits when this
// function returns.
DWORD CAudWorker::ThreadProc()
{
    BOOL bExit = FALSE;

    QzInitialize(NULL);

#ifdef CHANGE_THREAD_PRIORITIES
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL);
#endif

    while (!bExit) {

	Command cmd = GetRequest();

	switch (cmd) {

	case CMD_EXIT:
	    bExit = TRUE;
	    Reply(NOERROR);
	    break;

	case CMD_RUN:
	    Reply(NOERROR);
	    DoRunLoop();
	    break;

	case CMD_STOP:
	    Reply(NOERROR);
	    break;

	default:
	    Reply(E_NOTIMPL);
	    break;
	}
    }

    QzUninitialize();

    return NOERROR;
}

HRESULT CAudWorker::DoRunLoop()
{
    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE, 2, TEXT("AUD:entering worker thread")));

    while (1) {
	Command com;
	if (CheckRequest(&com)) {
	    if (com == CMD_STOP)
		break;
	}

	// no more blocking if we're waiting to get stopped
	if (!m_pAud->m_fThreadMustDie) {
            WaitForSingleObject(m_pAud->m_hEventThread, INFINITE);
	}

	// might have gotten set while we were blocked
	if (!m_pAud->m_fThreadMustDie && m_pAud->m_fThreadCanSeek) {
	    m_pAud->SeekNextSegment();
	}
    }

    DbgLog((LOG_TRACE, 2, TEXT("AUD:getting ready to leave worker thread")));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\audpack\resource.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#define IDD_AUDREPACK 	    800
#define IDC_AUD_RATE        810
#define IDC_AUD_SKEW        811
#define IDC_AUD_START       812
#define IDC_AUD_STOP        813
#define IDS_AUDPROP_TITLE   820
#ifndef IDC_STATIC
#define IDC_STATIC          -1
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\audpack\prop.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <windows.h>
#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "audpack.h"
#include "seek.h"
#include "resource.h"

//////////////////////////////////////////////////////////////////////////
//
// CAudPropertyPage
//
//////////////////////////////////////////////////////////////////////////

//
// CreateInstance
//
CUnknown *CAudPropertyPage::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)

  { // CreateInstance //

    CUnknown *punk = new CAudPropertyPage(lpunk, phr);

    if (NULL == punk)
	    *phr = E_OUTOFMEMORY;

    return punk;

  } // CreateInstance //

CAudPropertyPage::CAudPropertyPage(LPUNKNOWN pUnk, HRESULT *phr)
	: CBasePropertyPage(NAME("Audio Repackager Property Page"), pUnk,
			IDD_AUDREPACK, IDS_AUDPROP_TITLE), m_pifrc(NULL),
			m_bInitialized(FALSE)
{
}

void CAudPropertyPage::SetDirty()
{ // SetDirty //

      m_bDirty = TRUE;

      if (m_pPageSite)
	m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);

  } // SetDirty //

HRESULT CAudPropertyPage::OnActivate (void)

  { // OnActivate //

    m_bInitialized = TRUE;

    return NOERROR;

  } // OnActivate //

HRESULT CAudPropertyPage::OnDeactivate (void)

  { // OnDeactivate //

    m_bInitialized = FALSE;

    GetControlValues();

    return NOERROR;

  } // OnDeactivate //

INT_PTR CAudPropertyPage::OnReceiveMessage (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)

  { // OnReceiveMessage //

    ASSERT(m_pifrc != NULL);

    switch(uMsg)

      { // Switch

	case WM_COMMAND:

	  if (!m_bInitialized)
	    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);

	  m_bDirty = TRUE;

	  if (m_pPageSite)
	    m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);

	  return TRUE;

        case WM_INITDIALOG:
          SetDlgItemInt(hwnd, IDC_AUD_RATE, (int)(m_dFrameRate * 100), FALSE);
          SetDlgItemInt(hwnd, IDC_AUD_SKEW, (int)(m_rtSkew / 10000), TRUE);
          SetDlgItemInt(hwnd, IDC_AUD_START, (int)(m_rtMediaStart / 10000),
									FALSE);
          SetDlgItemInt(hwnd, IDC_AUD_STOP, (int)(m_rtMediaStop / 10000),
									FALSE);
          return TRUE;
          break;

	default:
	  return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
	  break;

      } // Switch

  } // OnReceiveMessage //

HRESULT CAudPropertyPage::OnConnect (IUnknown *pUnknown)

  { // OnConnect //

    pUnknown->QueryInterface(IID_IDexterSequencer, (void **)&m_pifrc);

    ASSERT(m_pifrc != NULL);

    // Defaults from filter's current values (via IFrameRateConverter)
    m_pifrc->get_OutputFrmRate(&m_dFrameRate);

    // !!! we only support one start/stop/skew in this prop page
    int c;
    m_pifrc->GetStartStopSkewCount(&c);

    REFERENCE_TIME *pStart = (REFERENCE_TIME *)QzTaskMemAlloc(c * 3 *
				sizeof(REFERENCE_TIME) + c * sizeof(double));
    if (pStart == NULL) {
	return E_OUTOFMEMORY;
    }
    REFERENCE_TIME *pStop = pStart + c;
    REFERENCE_TIME *pSkew = pStop + c;
    double *pRate = (double *)(pSkew + c);

    m_pifrc->GetStartStopSkew(pStart, pStop, pSkew, pRate);

    m_rtMediaStart = *pStart;
    m_rtMediaStop = *pStop;
    m_rtSkew = *pSkew;
    m_dRate = *pRate;

    m_bInitialized = FALSE;

    QzTaskMemFree(pStart);

    return NOERROR;

  }

HRESULT CAudPropertyPage::OnDisconnect()

  { // OnDisconnect //

    if (m_pifrc)

      { // Release

	m_pifrc->Release();
	m_pifrc = NULL;

      } // Release

    m_bInitialized = FALSE;

    return NOERROR;

  } // OnDisconnect //

HRESULT CAudPropertyPage::OnApplyChanges()

  { // OnApplyChanges //

    ASSERT(m_pifrc != NULL);

    GetControlValues();

    m_pifrc->put_OutputFrmRate(m_dFrameRate);
    m_pifrc->ClearStartStopSkew();
    m_pifrc->AddStartStopSkew(m_rtMediaStart, m_rtMediaStop, m_rtSkew, m_dRate);

    return NOERROR;

  } // OnApplyChanges //

void CAudPropertyPage::GetControlValues (void)

  { // GetControlValues //

    int n;

    // Frame rate
    n = GetDlgItemInt(m_Dlg, IDC_AUD_RATE, NULL, FALSE);
    m_dFrameRate = (double)(n / 100.);

    // Skew
    n = GetDlgItemInt(m_Dlg, IDC_AUD_SKEW, NULL, TRUE);
    m_rtSkew = (REFERENCE_TIME)n * 10000;

    // Media times
    n = GetDlgItemInt(m_Dlg, IDC_AUD_START, NULL, FALSE);
    m_rtMediaStart = (REFERENCE_TIME)n * 10000;
    n = GetDlgItemInt(m_Dlg, IDC_AUD_STOP, NULL, FALSE);
    m_rtMediaStop = (REFERENCE_TIME)n * 10000;

  } // GetControlValues //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\audpack\audpack.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
class CAudPassThru;     // IMediaSeeking support
class CAudRepack;

extern const AMOVIESETUP_FILTER sudAudRepack;

class CAudWorker : public CAMThread
{

    CAudRepack * m_pAud;

public:
    enum Command { CMD_RUN, CMD_STOP, CMD_EXIT };

private:
    // type-corrected overrides of communication funcs
    Command GetRequest() {
	return (Command) CAMThread::GetRequest();
    };

    BOOL CheckRequest(Command * pCom) {
	return CAMThread::CheckRequest( (DWORD *) pCom);
    };

    HRESULT DoRunLoop(void);

public:
    CAudWorker();

    HRESULT Create(CAudRepack * pAud);

    DWORD ThreadProc();

    // commands we can give the thread
    HRESULT Run();
    HRESULT Stop();

    HRESULT Exit();
};

class CAudRepack 
    : public CTransformFilter
    , public IDexterSequencer
    , public CPersistStream
    , public ISpecifyPropertyPages
{

    friend class CAudRepackInputPin;
    friend class CAudRepackOutputPin;
    friend class CAudPassThru;
    friend class CAudWorker;

public:

    static CUnknown * CreateInstance(LPUNKNOWN punk, HRESULT *phr);

    // These implement the custom IDexterSequencer interface
    // FrmRate == FrmPerSecond
    STDMETHODIMP get_OutputFrmRate(double *dpFrmRate);
    STDMETHODIMP put_OutputFrmRate(double dFrmRate);
    STDMETHODIMP get_Skew(REFERENCE_TIME *pSkew);
    STDMETHODIMP put_Skew(REFERENCE_TIME Skew);
    STDMETHODIMP get_MediaType( AM_MEDIA_TYPE * pMediaType );
    STDMETHODIMP put_MediaType(const AM_MEDIA_TYPE * pMediaType );

    STDMETHODIMP GetStartStopSkew(REFERENCE_TIME *pStart, REFERENCE_TIME *pStop, REFERENCE_TIME *pSkew, double *pdRate);
    STDMETHODIMP AddStartStopSkew(REFERENCE_TIME Start, REFERENCE_TIME Stop, REFERENCE_TIME Skew, double dRate);
    STDMETHODIMP ClearStartStopSkew();
    STDMETHODIMP GetStartStopSkewCount(int *pCount);

    // ISpecifyPropertyPages
    STDMETHODIMP GetPages (CAUUID *);

    // CPersistStream
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    STDMETHODIMP GetClassID(CLSID *pClsid);
    int SizeMax();

private:

    DECLARE_IUNKNOWN;

    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);
    HRESULT CheckInputType( const CMediaType * pmt );
    HRESULT DecideBufferSize( IMemAllocator * pAlloc, ALLOCATOR_PROPERTIES * pPropInputRequest );
    HRESULT GetMediaType( int iPosition, CMediaType *pMediaType );
    HRESULT CheckTransform( const CMediaType * p1, const CMediaType * p2 );
    // this is NEVER called
    HRESULT Transform(IMediaSample * pIn, IMediaSample *pOut) { return E_FAIL; }
    HRESULT NewSegment( REFERENCE_TIME tStart, REFERENCE_TIME tStop, double Rate );
    HRESULT Receive(IMediaSample * pSample);
    HRESULT EndOfStream( );
    HRESULT BeginFlush( );
    HRESULT EndFlush( );
    HRESULT StartStreaming();
    HRESULT StopStreaming();
    STDMETHODIMP Stop();
    CBasePin *GetPin(int n);

    HRESULT NextSegment(BOOL);
    HRESULT SeekNextSegment();

protected:
    // Constructor
    CAudRepack(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr);
    ~CAudRepack();

    double m_dOutputFrmRate; // set by IDexterSequencer

    bool m_bFirstSample;
    REFERENCE_TIME m_trStopLast;	// last stop time received
    BYTE * m_pCache;
    long m_nCacheSize;
    long m_nInCache;
    double m_dError;	// error propagation
    BYTE * m_pReadPointer;
    LONGLONG m_llStartFrameOffset;	// after a seek, the first frame sent
    LONGLONG m_llSamplesDelivered;
    LONGLONG m_llPacketsDelivered;
    CMediaType m_mtAccept;		// all pins only connect with this
    bool m_bMediaTypeSetByUser;


    int m_nSPS;		// samples per second we're working with
    int m_nSampleSize;	// bytes per sample at this format

    REFERENCE_TIME m_Tare;	// to line up the sample times

    void Free( );
    void Init( );
    HRESULT DeliverOutSample(BYTE *, int, REFERENCE_TIME, REFERENCE_TIME);

    // StartStopSkew stuff

    typedef struct {
        REFERENCE_TIME rtMStart;
        REFERENCE_TIME rtMStop;
        REFERENCE_TIME rtSkew;
        REFERENCE_TIME rtTLStart;
        REFERENCE_TIME rtTLStop;
        double dRate;
    } AUDSKEW;

    AUDSKEW *m_pSkew;
    int m_cTimes;	// # of items in skew
    int m_cMaxTimes;	// size allocated for this many items
    int m_nCurSeg;	// current index of array being played
    int m_nSeekCurSeg;	// new value being set by the seek

    REFERENCE_TIME m_rtLastSeek;	// last timeline time seek command
    REFERENCE_TIME m_rtNewLastSeek;	// next value for m_rtLastSeek
    REFERENCE_TIME m_rtNewSeg;		// NewSeg we sent downstream
    REFERENCE_TIME m_rtPinNewSeg;	// NewSeg we were given

    BOOL m_fSeeking;	// in the middle of a seek?
    HANDLE m_hEventSeek;

    LPBYTE m_pResample;	// place for resampled audio
    int m_cResample;

    CAudWorker m_worker;
    HANDLE m_hEventThread;
    BOOL m_fThreadMustDie;
    BOOL m_fThreadCanSeek;
    BOOL m_fSpecialSeek;
    CCritSec m_csThread;

    BOOL m_fStopPushing;
    BOOL m_fFlushWithoutSeek;

#ifdef NOFLUSH
    BOOL m_fExpectNewSeg;
    BOOL m_fSurpriseNewSeg;
    REFERENCE_TIME m_rtSurpriseStart;
    REFERENCE_TIME m_rtSurpriseStop;
#endif
};



// overridden to provide major type audio on GetMediaType. This IMMENSELY
// speeds up intelligent connects
//
class CAudRepackInputPin : public CTransformInputPin
{
public:
    CAudRepackInputPin( TCHAR *pObjectName
                             , CAudRepack *pAudRepack
                             , HRESULT * phr
                             , LPCWSTR pName
                             );
    ~CAudRepackInputPin();

    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

private:
    CAudRepack     	  *m_pAudRepack;
};


//
// CAudRepackOutputPin class
//
class CAudRepackOutputPin : public CTransformOutputPin
{
    friend class CAudRepack;
    friend class CAudRepackInputPin;

public:
    CAudRepackOutputPin( TCHAR *pObjectName
                             , CAudRepack *pAudRepack
                             , HRESULT * phr
                             , LPCWSTR pName
                             );
    ~CAudRepackOutputPin();

    // expose IMediaSeeking
    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);
   
private:
    CAudRepack     	  *m_pAudRepack;
    CAudPassThru	  *m_pAudPassThru;
};


class CAudPropertyPage : public CBasePropertyPage
{

    public:

      static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    private:

      INT_PTR OnReceiveMessage (HWND, UINT ,WPARAM ,LPARAM);

      HRESULT OnConnect (IUnknown *);
      HRESULT OnDisconnect (void);
      HRESULT OnActivate (void);
      HRESULT OnDeactivate (void);
      HRESULT OnApplyChanges (void);

      void SetDirty (void);

      CAudPropertyPage (LPUNKNOWN, HRESULT *);

      void GetControlValues (void);

      IDexterSequencer *m_pifrc;

      // Temporary variables (until OK/Apply)

      double          m_dFrameRate;
      REFERENCE_TIME  m_rtSkew;
      REFERENCE_TIME  m_rtMediaStart;
      REFERENCE_TIME  m_rtMediaStop;
      double          m_dRate;
      BOOL            m_bInitialized;
};  // CAudPropertyPage //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\audpack\seek.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "audpack.h"
#include "seek.h"

BOOL SafeSetEvent(HANDLE h);

CAudPassThru::CAudPassThru(const TCHAR *pName,
			   LPUNKNOWN pUnk,
			   HRESULT *phr,
			   IPin *pPin,
			   CAudRepack *pAud) :
    CPosPassThru(pName,pUnk, phr, pPin),
    m_pAudRepack( pAud )
{
}

// Expose our IMediaSeeking interfaces
STDMETHODIMP
CAudPassThru::NonDelegatingQueryInterface(REFIID riid,void **ppv)
{
    CheckPointer(ppv,E_POINTER);
    *ppv = NULL;

    if (riid == IID_IMediaSeeking)
    {
	return GetInterface( static_cast<IMediaSeeking *>(this), ppv);
    }
    else {
	//we only support the IID_DIMediaSeeking
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


// fix a clip time into timeline time, bounding it by the legal area
//
HRESULT CAudPassThru::FixTime(REFERENCE_TIME *prt, int nCurSeg)
{
    CheckPointer(prt, E_POINTER);

    REFERENCE_TIME rtStart, rtStop, rtSkew;
    double dRate;
    rtSkew = m_pAudRepack->m_pSkew[nCurSeg].rtSkew;
    rtStart = m_pAudRepack->m_pSkew[nCurSeg].rtMStart;
    rtStop = m_pAudRepack->m_pSkew[nCurSeg].rtMStop;
    dRate = m_pAudRepack->m_pSkew[nCurSeg].dRate;
    if (*prt < rtStart)
	*prt = rtStart;
    if (*prt > rtStop)
	*prt = rtStop;
    *prt = (REFERENCE_TIME)(rtStart + rtSkew + (*prt - rtStart) / dRate);
    return S_OK;
}


// fix a timeline time back into clip time, bounding it by the legal area
//
int CAudPassThru::FixTimeBack(REFERENCE_TIME *prt, BOOL fRound)
{
    CheckPointer(prt, E_POINTER);
    REFERENCE_TIME rtStart, rtStop, rtSkew;
    REFERENCE_TIME rtTLStart, rtTLStop;
    double dRate;

    if (m_pAudRepack->m_cTimes == 0) {
	ASSERT(FALSE);
	return 0;
    }

#if 0
    if (fRound)
    {
        LONGLONG llOffset = Time2Frame( *prt, m_pFrm->m_dOutputFrmRate );
    	*prt = Frame2Time( llOffset, m_pFrm->m_dOutputFrmRate );
    }
#endif

    REFERENCE_TIME rtSave;
    for (int z = 0; z < m_pAudRepack->m_cTimes; z++) {
        rtSkew = m_pAudRepack->m_pSkew[z].rtSkew;
        rtStart = m_pAudRepack->m_pSkew[z].rtMStart;
        rtStop = m_pAudRepack->m_pSkew[z].rtMStop;
        dRate = m_pAudRepack->m_pSkew[z].dRate;
	rtTLStart = rtStart + rtSkew;
	rtTLStop = rtStart + rtSkew +
			(REFERENCE_TIME) ((rtStop - rtStart) / dRate);
	if (*prt < rtTLStart) {
	    *prt = rtStart;
	    break;
	} else if (*prt >= rtTLStop) {
	    // just in case there is no next segment, this is the final value
	    rtSave = rtStop;
	} else {
    	    *prt = (REFERENCE_TIME)(rtStart + (*prt - (rtStart + rtSkew)) *
								dRate);
	    break;
	}
    }
    if (z == m_pAudRepack->m_cTimes) {
	z--;
	*prt = rtSave;
    }
    return z;
}


// --- IMediaSeeking methods ----------

STDMETHODIMP
CAudPassThru::GetCapabilities(DWORD * pCaps)
{
    return CPosPassThru::GetCapabilities(pCaps);

#if 0
    CheckPointer(pCaps,E_POINTER);
    // we always know the current position
    *pCaps =     AM_SEEKING_CanSeekAbsolute
		   | AM_SEEKING_CanSeekForwards
		   | AM_SEEKING_CanSeekBackwards
		   | AM_SEEKING_CanGetCurrentPos
		   | AM_SEEKING_CanGetStopPos
		   | AM_SEEKING_CanGetDuration
		   // This one scares me | AM_SEEKING_CanDoSegments
		   | AM_SEEKING_Source;
    return S_OK;
#endif
}


STDMETHODIMP
CAudPassThru::CheckCapabilities(DWORD * pCaps)
{
    return CPosPassThru::CheckCapabilities(pCaps);
#if 0
    CheckPointer(pCaps,E_POINTER);

    DWORD dwMask = 0;
    GetCapabilities(&dwMask);
    *pCaps &= dwMask;

    return S_OK;
#endif
}


STDMETHODIMP
CAudPassThru::IsFormatSupported(const GUID * pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    return (*pFormat == TIME_FORMAT_MEDIA_TIME) ? S_OK : S_FALSE;
}

STDMETHODIMP
CAudPassThru::QueryPreferredFormat(GUID *pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    *pFormat = TIME_FORMAT_MEDIA_TIME;
    return S_OK;
}

STDMETHODIMP
CAudPassThru::SetTimeFormat(const GUID * pFormat)
{
    CheckPointer(pFormat,E_POINTER);

    if(*pFormat == TIME_FORMAT_MEDIA_TIME)
	return S_OK;
    else
	return E_FAIL;
}

STDMETHODIMP
CAudPassThru::GetTimeFormat(GUID *pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    *pFormat = TIME_FORMAT_MEDIA_TIME ;
    return S_OK;
}

STDMETHODIMP
CAudPassThru::IsUsingTimeFormat(const GUID * pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    if (*pFormat == TIME_FORMAT_MEDIA_TIME)
	return S_OK;
    else
	return S_FALSE;
}

// The biggie!
//
STDMETHODIMP
CAudPassThru::SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
			  , LONGLONG * pStop, DWORD StopFlags )
{
    // make sure our re-using sources thread isn't seeking at the moment.
    // Wait till it's done, so the app seek happens last, and that the thread
    // won't seek anymore from now on

    CAutoLock cAutolock(&m_pAudRepack->m_csThread);

    // make sure we don't change state during this
    CAutoLock c(&m_pAudRepack->m_csFilter);

    m_pAudRepack->m_fThreadCanSeek = FALSE;

    HRESULT hr;
    REFERENCE_TIME rtStart, rtStop;
    int nCurSeg = m_pAudRepack->m_nCurSeg;

    // we don't do segments
    if ((CurrentFlags & AM_SEEKING_Segment) ||
				(StopFlags & AM_SEEKING_Segment)) {
    	DbgLog((LOG_TRACE,1,TEXT("AudPack: ERROR-Seek used EC_ENDOFSEGMENT!")));
	return E_INVALIDARG;
    }

    // !!! We ignore stop times, because of the way we re-use sources and play
    // things in segments.  We will always send a stop time upstream equal to
    // the end of the current segment, and only pay attention to changes in the
    // start time.  This will work only because the switch will ignore things
    // we send after we were supposed to stop and stop us.

    DWORD dwFlags = (CurrentFlags & AM_SEEKING_PositioningBitsMask);
    if (dwFlags == AM_SEEKING_AbsolutePositioning) {
	CheckPointer(pCurrent, E_POINTER);
	rtStart = *pCurrent;
	nCurSeg = FixTimeBack(&rtStart, FALSE);
    } else if (dwFlags == AM_SEEKING_RelativePositioning) {
	CheckPointer(pCurrent, E_POINTER);
	hr = CPosPassThru::GetCurrentPosition(&rtStart);
	if (hr != S_OK)
	    return hr;
	FixTime(&rtStart, m_pAudRepack->m_nCurSeg);
	rtStart += *pCurrent;
	nCurSeg = FixTimeBack(&rtStart, FALSE);
    } else if (dwFlags) {
    	DbgLog((LOG_TRACE,1,TEXT("AudPack::Invalid Current Seek flags")));
	return E_INVALIDARG;
    }

// we're not going to set a stop time
#if 0
    // always play until the end of the segment we're going to start in
    rtStop = m_pAudRepack->m_prtStop[nCurSeg];
#endif

    if (!(CurrentFlags & AM_SEEKING_PositioningBitsMask)) {
	return S_OK;	// nothing to do
    }

    DWORD CFlags = CurrentFlags & ~AM_SEEKING_PositioningBitsMask;
    DWORD SFlags = StopFlags & ~AM_SEEKING_PositioningBitsMask;
    CFlags |= AM_SEEKING_AbsolutePositioning;
    SFlags |= AM_SEEKING_AbsolutePositioning;
    DbgLog((LOG_TRACE,1,TEXT("AudPack: Seek to %dms"),
					(int)(rtStart / 10000)));

    // we're in the middle of seeking.  This thread will generate flushes
    m_pAudRepack->m_fSeeking = TRUE;

    // we can't set the LastSeek variable until we've been flushed, and old
    // data has stopped arriving.  It must be send between the flush and the
    // next NewSegment call, so we'll set it in EndFlush to this value
    m_pAudRepack->m_rtNewLastSeek = rtStart;
    FixTime(&m_pAudRepack->m_rtNewLastSeek, nCurSeg);

    // the flush generated by the seek below needs to know this
    m_pAudRepack->m_nSeekCurSeg = nCurSeg;

#ifdef NOFLUSH
    m_pAudRepack->m_fExpectNewSeg = TRUE;       // seek will cause one
#endif

    // I know we were asked to play until time n, but I'm going to tell it to
    // play all the way to the end.  If there's a gap in the file, and the stop
    // time is during the gap, we won't get enough samples to fill the whole
    // playing time.  If we play until the end, we'll get the first sample
    // after the gap, notice it's after the time we originally wanted to stop
    // at, and send silence to fill the gap, noticing there has been a gap.
    // The alternative is just trigger sending silence to fill the gap when
    // we get an EOS earlier than we expected.
    hr = CPosPassThru::SetPositions(&rtStart, CFlags, NULL, 0);
    if (hr != S_OK) {
        // MPEG1 parser audio pin fails seek, but that's ok.  video does it
        DbgLog((LOG_TRACE,1,TEXT("AudPack: SEEK ERROR!")));
    }

#ifdef NOFLUSH
    if (m_pAudRepack->m_fSurpriseNewSeg) {
    	DbgLog((LOG_TRACE,1,TEXT("Seek:Sending SURPRISE NewSeg now")));
        m_pAudRepack->CTransformFilter::NewSegment(m_pAudRepack->m_rtSurpriseStart,
                                        m_pAudRepack->m_rtSurpriseStop, 1);
        m_pAudRepack->m_fSurpriseNewSeg = FALSE;
    }
#endif

    // if the push thread was stopped, we won't get flushed, and this won't
    // have been updated
    // !!! I ASSUME the push thread won't be started until this thread does it
    // when this function returns, or there is a race condition
    m_pAudRepack->m_rtLastSeek = m_pAudRepack->m_rtNewLastSeek;

    // OK, no longer seeking
    m_pAudRepack->m_fSeeking = FALSE;

    // Not necessary. Flush & StartStreaming do this, which is what matters
    // m_pAudRepack->Init();

    // in case we weren't flushed
    m_pAudRepack->m_nCurSeg = nCurSeg;

    // (see comment about sharing a source filter at the top of audpack.cpp)
    // We were waiting for this seek, ever since we got a surprise flush.
    // Now that the switch knows about the seek, we can resume sending it
    // new data, and allow Receive to be entered (set the Seek event)
    // making sure we've set all our variables first before releasing the hounds
    //
    if (m_pAudRepack->m_fFlushWithoutSeek) {
	m_pAudRepack->m_fFlushWithoutSeek = FALSE;
    	DbgLog((LOG_TRACE,1,TEXT("SURPRISE FLUSH followed by a SEEK - OK to resume")));

        // DO NOT FLUSH! The push thread has already started delivering the new
        // post-seek data... flushing will kill it and hang us!
	
    } else if (m_pAudRepack->m_State == State_Paused) {
	// Set this so that if a flush ever happens without a seek later,
	// we'll know that flush was AFTER the seek, not before
	m_pAudRepack->m_fFlushWithoutSeek = TRUE;
    	DbgLog((LOG_TRACE,1,TEXT("AudPack SEEK - State=3")));
    }

    // after the seek, all receives block until we fix the calculations above.
    // Now it's ok to receive again.
    SafeSetEvent(m_pAudRepack->m_hEventSeek);

    return S_OK;
}

STDMETHODIMP
CAudPassThru::GetPositions(LONGLONG *pCurrent, LONGLONG * pStop)
{
    HRESULT hr=CPosPassThru::GetPositions(pCurrent, pStop);
    if(hr== S_OK)
    {
	FixTime(pCurrent, m_pAudRepack->m_nCurSeg);
	FixTime(pStop, m_pAudRepack->m_nCurSeg);
    }
    return hr;
}

STDMETHODIMP
CAudPassThru::GetCurrentPosition(LONGLONG *pCurrent)
{
    HRESULT hr = CPosPassThru::GetCurrentPosition(pCurrent);
    if(hr== S_OK)
    {
	FixTime(pCurrent, m_pAudRepack->m_nCurSeg);
    }
    return hr;
}

STDMETHODIMP
CAudPassThru::GetStopPosition(LONGLONG *pStop)
{
    HRESULT hr=CPosPassThru::GetStopPosition(pStop);
    if( hr == S_OK)
    {
	FixTime(pStop, m_pAudRepack->m_nCurSeg);
    }
    return hr;
}

STDMETHODIMP
CAudPassThru::GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest )
{
    CheckPointer(pEarliest, E_POINTER);
    CheckPointer(pLatest, E_POINTER);

    *pEarliest = m_pAudRepack->m_pSkew[m_pAudRepack->m_nCurSeg].rtMStart;
    *pLatest = m_pAudRepack->m_pSkew[m_pAudRepack->m_nCurSeg].rtMStop;

    FixTime(pEarliest, m_pAudRepack->m_nCurSeg);
    FixTime(pLatest, m_pAudRepack->m_nCurSeg);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\audpack\seek.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// {DBF8F620-53F0-11d2-9EE6-006008039E37}
DEFINE_GUID(CLSID_AudPassThru, 
0xdbf8f620, 0x53f0, 0x11d2, 0x9e, 0xe6, 0x0, 0x60, 0x8, 0x3, 0x9e, 0x37);

class CAudPassThru : public CPosPassThru
		    
{
    friend class CAudRepack;
    friend class CAudRepackOutputPin;

public:

    CAudPassThru(const TCHAR *, LPUNKNOWN, HRESULT*, IPin *, CAudRepack *pAud);

    //only support IMediaSeeking
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    // IMediaSeeking methods
    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities ); 
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);	
    STDMETHODIMP GetTimeFormat(GUID *pFormat);		    
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);  
    STDMETHODIMP IsFormatSupported( const GUID * pFormat); 
    STDMETHODIMP QueryPreferredFormat( GUID *pFormat);	    
    
    STDMETHODIMP SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
                             , LONGLONG * pStop, DWORD StopFlags );

    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );
    STDMETHODIMP GetCurrentPosition( LONGLONG * pCurrent );
    STDMETHODIMP GetStopPosition( LONGLONG * pStop );
    STDMETHODIMP GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest );
    STDMETHODIMP GetPreroll( LONGLONG *pllPreroll ) { if( pllPreroll) *pllPreroll =0; return S_OK; };
    
    //methods we do not support
    STDMETHODIMP SetRate( double dRate)	    { return E_NOTIMPL; };
    // STDMETHODIMP GetRate( double * pdRate); //use the base class
    STDMETHODIMP ConvertTimeFormat(LONGLONG * pTarget, const GUID * pTargetFormat,
				   LONGLONG    Source, const GUID * pSourceFormat ){ return E_NOTIMPL ;};


private:
    
    // converts clip time to timeline time
    HRESULT FixTime(REFERENCE_TIME *prt, int nCurSeg);
    // converts timeline time to clip time
    int FixTimeBack(REFERENCE_TIME *prt, BOOL fRound);

    CAudRepack	*m_pAudRepack;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\audscrub\audscrub.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <initguid.h>
#include <vfw.h>

// {6A9E0A10-C6C2-11d2-8D3E-00A0C9441E20}
DEFINE_GUID( CLSID_AudioScrubber, 
0x6a9e0a10, 0xc6c2, 0x11d2, 0x8d, 0x3e, 0x0, 0xa0, 0xc9, 0x44, 0x1e, 0x20);

class CAudScrub : public CBaseRenderer
{
public:

    CMediaType m_mtIn;                  // Source connection media type
    HWAVEOUT m_hWaveOut;
    WAVEHDR  m_WaveHdr;
    BYTE *   m_pWaveBuffer;
    long     m_nWaveBufferLen;
    long     m_nInBuffer;
    REFERENCE_TIME m_rtFirstAfterFull;
    bool m_bWasFull;

    static CUnknown *CreateInstance( LPUNKNOWN, HRESULT * );
    CAudScrub( TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr );
    ~CAudScrub( );
    LPAMOVIESETUP_FILTER GetSetupData( );

    HRESULT OpenWaveDevice( );
    void    CloseWaveDevice( );

    HRESULT CheckMediaType( const CMediaType *pmtIn );
    HRESULT DoRenderSample( IMediaSample *pMediaSample );
    HRESULT SetMediaType( const CMediaType *pmt );
    HRESULT GetSampleTimes(IMediaSample *pMediaSample,REFERENCE_TIME *pStartTime,REFERENCE_TIME *pEndTime)
    {
        return 0;
    }
    STDMETHODIMP SetSyncSource(IReferenceClock *pClock)
    {
        return S_FALSE;
    }
    void OnReceiveFirstSample(IMediaSample *pMediaSample)
    {
        DoRenderSample(pMediaSample);
    }
    HRESULT Receive(IMediaSample *pSample);

    DECLARE_IUNKNOWN
};

AMOVIESETUP_MEDIATYPE sudPinTypes = { &MEDIATYPE_Video, &MEDIASUBTYPE_RGB24 };
AMOVIESETUP_PIN sudPins   =    
{ 
    L"Input"             // strName
   , TRUE                // bRendered
   , FALSE               // bOutput
   , FALSE               // bZero
   , FALSE               // bMany
   , &CLSID_NULL         // clsConnectsToFilter
   , L"Output"           // strConnectsToPin
   , 1                   // nTypes
   , &sudPinTypes        // lpTypes
};


AMOVIESETUP_FILTER sudAudScrub   = 
{ 
    &CLSID_AudioScrubber                 // clsID
    , L"AudioScrubRenderer"                   // strName
    , MERIT_DO_NOT_USE                // dwMerit
    , 1                               // nPins
    , &sudPins                        // lpPin
};

CFactoryTemplate g_Templates[] = 
{
    { L"AudioScrubRenderer", &CLSID_AudioScrubber, CAudScrub::CreateInstance}
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

HRESULT DllRegisterServer()
{
    return AMovieDllRegisterServer();
}

STDAPI DllUnregisterServer()
{
    return AMovieDllUnregisterServer();
}

CUnknown * CAudScrub::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CAudScrub( NAME("AudioScrubRenderer"), pUnk, phr );
}

//*********************************************************************
//*********************************************************************
//*********************************************************************
//*********************************************************************
//*********************************************************************
//*********************************************************************

CAudScrub::CAudScrub( TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr )
    : CBaseRenderer( CLSID_AudioScrubber, pName, pUnk, phr )
    , m_hWaveOut( NULL )
    , m_pWaveBuffer( NULL )
    , m_nWaveBufferLen( 0 )
    , m_nInBuffer( 0 )
    , m_rtFirstAfterFull( 0 )
    , m_bWasFull( false )
{
}

CAudScrub::~CAudScrub( )
{
}

void CAudScrub::CloseWaveDevice( )
{
    if( m_hWaveOut )
    {
        waveOutUnprepareHeader( m_hWaveOut, &m_WaveHdr, sizeof( m_WaveHdr ) );
        waveOutClose( m_hWaveOut );
        m_hWaveOut = NULL;
    }
}

HRESULT CAudScrub::OpenWaveDevice( )
{
    CloseWaveDevice( );
    WAVEFORMATEX * pWaveFormat = (WAVEFORMATEX*) m_mtIn.Format( );
    MMRESULT mm = waveOutOpen( &m_hWaveOut, WAVE_MAPPER, pWaveFormat, NULL, 0, CALLBACK_NULL );
    if( mm != MMSYSERR_NOERROR )
    {
        return E_FAIL;
    }

    m_nWaveBufferLen = pWaveFormat->nAvgBytesPerSec;
    m_pWaveBuffer = new BYTE[ m_nWaveBufferLen ];
    memset( &m_WaveHdr, 0, sizeof( m_WaveHdr ) );
    m_WaveHdr.lpData = (char*) m_pWaveBuffer;
    m_WaveHdr.dwBufferLength = m_nWaveBufferLen;
//    mm = waveOutPrepareHeader( m_hWaveOut, &m_WaveHdr, sizeof( m_WaveHdr ) );
    if( mm != MMSYSERR_NOERROR )
    {
        return E_FAIL;
    }

    return NOERROR;
}

LPAMOVIESETUP_FILTER CAudScrub::GetSetupData()
{
    return &sudAudScrub;
}

HRESULT CAudScrub::CheckMediaType(const CMediaType *pmtIn)
{
    if( *pmtIn->Type( ) != MEDIATYPE_Audio )
        return VFW_E_INVALIDMEDIATYPE;

    return S_OK;
}

HRESULT CAudScrub::SetMediaType(const CMediaType *pmt)
{
    CAutoLock cInterfaceLock(&m_InterfaceLock);
    m_mtIn = *pmt;
    OpenWaveDevice( );
    return NOERROR;
}

// Called by the source filter when we have a sample to render. Under normal
// circumstances we set an advise link with the clock, wait for the time to
// arrive and then render the data using the PURE virtual DoRenderSample that
// the derived class will have overriden. After rendering the sample we may
// also signal EOS if it was the last one sent before EndOfStream was called

HRESULT CAudScrub::Receive(IMediaSample *pSample)
{
    ASSERT(pSample);

    if( m_bWasFull )
    {
        m_bWasFull = false;
        CBasePin * pPin = GetPin( 0 );
        m_rtFirstAfterFull = pPin->CurrentStartTime( );
    }

    // It may return VFW_E_SAMPLE_REJECTED code to say don't bother

    HRESULT hr = PrepareReceive(pSample);
    ASSERT(m_bInReceive == SUCCEEDED(hr));
    if (FAILED(hr)) {
	if (hr == VFW_E_SAMPLE_REJECTED) {
	    return NOERROR;
	}
	return hr;
    }

    BYTE * pData;
    hr = pSample->GetPointer( &pData );
    long len = pSample->GetActualDataLength( );

    // if we have too much, just use a little
    //
    if( len + m_nInBuffer > m_nWaveBufferLen )
    {
        len = m_nWaveBufferLen - m_nInBuffer;
    }

    // copy it to our wave buffer
    //
    memcpy( m_pWaveBuffer + m_nInBuffer, pData, len );
    m_nInBuffer += len;

    // if we don't have enough, then exit right NOW
    //
    if( m_nInBuffer < m_nWaveBufferLen )
    {
        DbgLog((LOG_TRACE, 1, ("buffer %ld size, not full"), m_nInBuffer ) );
        PrepareRender();
        m_bInReceive = FALSE;
        // since we gave away the filter wide lock, the sate of the filter could
        // have chnaged to Stopped
        if (m_State == State_Stopped)
	    return NOERROR;
        CAutoLock cSampleLock(&m_RendererLock);
        ClearPendingSample();
        SendEndOfStream();
        CancelNotification();
        return NOERROR;
    }

    DbgLog((LOG_TRACE, 1, ("buffer is full"), m_nInBuffer ) );
    m_nInBuffer = 0;
    m_bWasFull = true;

    DbgLog((LOG_TRACE, 1, ("Seek time = %ld"), long( m_rtFirstAfterFull / 10000 ) ) );

    // do something special in paused mode
    //
    if (m_State == State_Paused) 
    {
	PrepareRender();

	// no need to use InterlockedExchange
	m_bInReceive = FALSE;
	{
	    // We must hold both these locks
	    CAutoLock cRendererLock(&m_InterfaceLock);
	    if (m_State == State_Stopped)
		return NOERROR;
	    m_bInReceive = TRUE;
	    CAutoLock cSampleLock(&m_RendererLock);
            OnReceiveFirstSample( pSample );
	}

	Ready();
    }

    // Having set an advise link with the clock we sit and wait. We may be
    // awoken by the clock firing or by a state change. The rendering call
    // will lock the critical section and check we can still render the data

    hr = WaitForRenderTime();
    if (FAILED(hr)) {
	m_bInReceive = FALSE;
	return NOERROR;
    }

    PrepareRender();

    //  Set this here and poll it until we work out the locking correctly
    //  It can't be right that the streaming stuff grabs the interface
    //  lock - after all we want to be able to wait for this stuff
    //  to complete
    m_bInReceive = FALSE;

    // We must hold both these locks
    CAutoLock cRendererLock(&m_InterfaceLock);

    // since we gave away the filter wide lock, the sate of the filter could
    // have chnaged to Stopped
    if (m_State == State_Stopped)
	return NOERROR;

    CAutoLock cSampleLock(&m_RendererLock);

    // Deal with this sample

    Render(m_pMediaSample);
    ClearPendingSample();
    SendEndOfStream();
    CancelNotification();
    return NOERROR;
}

HRESULT CAudScrub::DoRenderSample( IMediaSample * pSample )
{
    REFERENCE_TIME Start, Stop;
    pSample->GetTime( &Start, &Stop );
    Start += m_rtFirstAfterFull;
    Start = m_rtFirstAfterFull;
    long len = pSample->GetActualDataLength( );
    DbgLog((LOG_TRACE, 1, ("Sample Times %ld %ld len = %ld"), long( Start / 10000 ), long( Stop / 10000 ), len ) );

    double dTime = double( Start ) / double( UNITS );
    static double dLastTime = 0;

    double deltamedia = dTime - dLastTime;
    dLastTime = dTime;

    long t1 = timeGetTime( );
    double dCurrentClock = double( t1 ) / 1000.0;
    static double dLastClock = 0;
    double deltaClock = dCurrentClock - dLastClock;
    dLastClock = dCurrentClock;

    MMRESULT mm = waveOutPrepareHeader( m_hWaveOut, &m_WaveHdr, sizeof( m_WaveHdr ) );
    if( mm != MMSYSERR_NOERROR )
    {
        Beep( 5000, 100 );
        return E_FAIL;
    }

    if( deltamedia == 0 )
    {
        return 0;
    }

//    deltamedia = 1;

    if( deltamedia < 0 )
    {
        // reverse the buffer
        for( int i = 0 ; i < m_nWaveBufferLen / 2 ; i++ )
        {
            BYTE t = m_pWaveBuffer[m_nWaveBufferLen - i - 1];
            m_pWaveBuffer[m_nWaveBufferLen - i - 1] = m_pWaveBuffer[i];
            m_pWaveBuffer[i] = t;
        }
    }

    double ratio = deltamedia / deltaClock;
    if( ratio < 0.0 )
        ratio = -ratio;

//    ratio = 1.0;

    // if abs( ratio ) < 1.0 then we've seeked the graph to a spot that's well ahead of, or behind
    // where we are right now in time. Really, we should have a way to speed up the playback.

    // if abs( ratio ) = ~1.0 then we've moved the seek pointer just about at the same rate as the
    // amount of time that's elapsed. we should play normally, forwards or backwards

    // if abs( ratio ) > 1.0 then we've moved the seek pointer very slowly compared to the amount
    // of time that's elapsed, so we should play S L O W E D  D O W N...

    DbgLog((LOG_TRACE, 1, ("media delta = %ld, time delta = %ld, ratio = %ld"), long( deltamedia * 1000.0 ), long( deltaClock * 1000.0 ), long( ratio * 1000.0 ) ) );

    if( ratio < 1.0 )
    {
        DbgLog((LOG_TRACE, 1, ("Need to be slowed down") ) );
        for( int i = m_nWaveBufferLen - 1 ; i >= 0 ; i-- )
        {
            m_pWaveBuffer[i] = m_pWaveBuffer[long(i * ratio )];
        }
    }

    mm = waveOutWrite( m_hWaveOut, &m_WaveHdr, sizeof( m_WaveHdr ) );

    m_nInBuffer = 0;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\black\prop.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//prop.cpp
//

#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "black.h"
#include "resource.h"

// *
// * CGenVidProperties
// *


//
// CreateInstance
//
CUnknown *CGenVidProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{

    CUnknown *punk = new CGenVidProperties(lpunk, phr);
    if (punk == NULL)
    {
	*phr = E_OUTOFMEMORY;
    }

    return punk;
}


//
// CGenVidProperties::Constructor
//
CGenVidProperties::CGenVidProperties(LPUNKNOWN pUnk, HRESULT *phr)
    : CBasePropertyPage(NAME("GenBlkVid Property Page"),pUnk,
        IDD_GenVid, IDS_TITLE)
    , m_pGenVid(NULL)
    , m_pDexter(NULL)
    , m_pCBlack(NULL)
    , m_bIsInitialized(FALSE)
{
}


//
// SetDirty
//
// Sets m_hrDirtyFlag and notifies the property page site of the change
//
void CGenVidProperties::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
    {
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
    }
}


INT_PTR CGenVidProperties::OnReceiveMessage(HWND hwnd,
                                        UINT uMsg,
                                        WPARAM wParam,
                                        LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
	    //start time
	    SetDlgItemInt(hwnd, IDC_START, (int)(m_rtStartTime / 10000),FALSE);
	
	    //frame rate
	    SetDlgItemInt(hwnd, IDC_FRAMERATE, (int)(m_dOutputFrmRate * 100), FALSE);
	
	    //width
	    SetDlgItemInt(hwnd, IDC_VIDWIDTH, (int)(m_biWidth), FALSE);
	
	    //height
	    SetDlgItemInt(hwnd, IDC_VIDHEIGHT, (int)(m_biHeight), FALSE);

	    //biBitCount
	    SetDlgItemInt(hwnd, IDC_BITCOUNT, (int)(m_biBitCount), FALSE);

	    //duration
	    SetDlgItemInt(hwnd, IDC_DURATION, (int)(m_rtDuration/ 10000), FALSE);

	    // bit 31	    |		|	|     0
	//	    Alph    |	Red	|Green	|Blue

	    //Color B
	    SetDlgItemInt(hwnd, IDC_COLOR_B, (int)(m_dwRGBA & 0xff), FALSE);

	    //Color G
	    SetDlgItemInt(hwnd, IDC_COLOR_G, (int)((m_dwRGBA >> 8) & 0xff), FALSE);

	    //Color R
	    SetDlgItemInt(hwnd, IDC_COLOR_R, (int)((m_dwRGBA >> 16) & 0xff), FALSE);

	    //Color A
	    SetDlgItemInt(hwnd, IDC_COLOR_A, (int)((m_dwRGBA >> 24) & 0xff), FALSE);


            return (LRESULT) 1;
        }
        case WM_COMMAND:
        {
            if (m_bIsInitialized)
            {
                m_bDirty = TRUE;
                if (m_pPageSite)
                {
                    m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
                }
            }
            return (LRESULT) 1;
        }
    }
    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
}

HRESULT CGenVidProperties::OnConnect(IUnknown *pUnknown)
{

    ASSERT(m_pGenVid == NULL);
    ASSERT(m_pDexter == NULL);
    ASSERT(m_pCBlack == NULL);
    HRESULT hr = pUnknown->QueryInterface(IID_IGenVideo, (void **) &m_pGenVid);
    if (FAILED(hr)) {
	return E_NOINTERFACE;
    }
    hr = pUnknown->QueryInterface(IID_IDexterSequencer, (void **) &m_pDexter);
    if (FAILED(hr)) {
	return E_NOINTERFACE;
    }

    m_pCBlack = static_cast<CBlkVidStream*>( m_pDexter );
    if (m_pCBlack == NULL) {
	return E_NOINTERFACE;
    }
    m_pCBlack->AddRef();

    ASSERT(m_pGenVid);
    ASSERT(m_pDexter);
    ASSERT(m_pCBlack);

    // get init data

    //get FrmRate
    m_pDexter->get_OutputFrmRate( &m_dOutputFrmRate );

    //get width, height and bitCoutn
    AM_MEDIA_TYPE mt;
    ZeroMemory(&mt, sizeof(AM_MEDIA_TYPE));
    mt.pbFormat = (BYTE *)QzTaskMemAlloc(SIZE_PREHEADER +
						sizeof(BITMAPINFOHEADER));
    mt.cbFormat = SIZE_PREHEADER + sizeof(BITMAPINFOHEADER);
    ZeroMemory(mt.pbFormat, mt.cbFormat);

    m_pDexter->get_MediaType(&mt);

    m_biWidth = HEADER(mt.pbFormat)->biWidth;
    m_biHeight = HEADER(mt.pbFormat)->biHeight;
    m_biBitCount = HEADER(mt.pbFormat)->biBitCount;

    //get starttime/duration
    m_rtStartTime = m_pCBlack->m_rtStartTime;
    m_rtDuration = m_pCBlack->m_rtDuration;

    //get Color
    m_pGenVid->get_RGBAValue( &m_dwRGBA );

    m_bIsInitialized = FALSE ;

    return NOERROR;
}

HRESULT CGenVidProperties::OnDisconnect()
{
    // Release the interface

    if (m_pGenVid)
        m_pGenVid->Release();
    m_pGenVid = NULL;
    if (m_pDexter)
        m_pDexter->Release();
    m_pDexter = NULL;
    if (m_pCBlack)
        m_pCBlack->Release();
    m_pCBlack = NULL;
    return NOERROR;
}


// We are being activated

HRESULT CGenVidProperties::OnActivate()
{
    m_bIsInitialized = TRUE;
    return NOERROR;
}


// We are being deactivated

HRESULT CGenVidProperties::OnDeactivate(void)
{
    // remember present effect level for next Activate() call

    GetFromDialog();
    return NOERROR;
}

//
// get data from Dialog

STDMETHODIMP CGenVidProperties::GetFromDialog(void)
{
    int n;

    //get start time
    m_rtStartTime = GetDlgItemInt(m_Dlg, IDC_START, NULL, FALSE);
    m_rtStartTime *= 10000;

    //get frame rate
    n = GetDlgItemInt(m_Dlg, IDC_FRAMERATE, NULL, FALSE);
    m_dOutputFrmRate = (double)(n / 100.);

    //Video Width
    m_biWidth = GetDlgItemInt(m_Dlg, IDC_VIDWIDTH, NULL, FALSE);

    // Video Height
    m_biHeight = GetDlgItemInt(m_Dlg, IDC_VIDHEIGHT, NULL, FALSE);

    // bitCount
    m_biBitCount = (WORD) GetDlgItemInt(m_Dlg, IDC_BITCOUNT, NULL, FALSE);

    // duration
    m_rtDuration = GetDlgItemInt(m_Dlg, IDC_DURATION, NULL, FALSE);
    m_rtDuration *= 10000;

    // bit 31	    |		|	|     0
    //	    Alph    |	Red	|Green	|Blue

    // Color B
    m_dwRGBA = GetDlgItemInt(m_Dlg, IDC_COLOR_B, NULL, FALSE);

    // Color G
    m_dwRGBA |=(  GetDlgItemInt(m_Dlg, IDC_COLOR_G, NULL, FALSE)  <<8 );

    // Color R
    m_dwRGBA |=(  GetDlgItemInt(m_Dlg, IDC_COLOR_R, NULL, FALSE)  <<16 );

    // Color A
    m_dwRGBA |=(  GetDlgItemInt(m_Dlg, IDC_COLOR_A, NULL, FALSE)  <<32 );


    // cehck if all data is valid
    if( (   (m_biBitCount ==16)  ||
	    (m_biBitCount ==24)  ||
	    (m_biBitCount ==32)
	)
	&& (m_rtDuration>=0)
       )	
	return NOERROR;
    else
	return E_FAIL;
}


HRESULT CGenVidProperties::OnApplyChanges()
{
    GetFromDialog();

    HRESULT hr=NOERROR;

    m_bDirty  = FALSE; // the page is now clean

    // set Frame rate
    double dw;
    m_pDexter->get_OutputFrmRate(&dw);

    if(dw != m_dOutputFrmRate )
	hr= m_pDexter->put_OutputFrmRate( m_dOutputFrmRate );

    if(hr==NOERROR)
    {	
	// set Width, Height, andd BitCount
	AM_MEDIA_TYPE mt;
	m_pDexter->get_MediaType( &mt);

	if(    (HEADER(mt.pbFormat)->biWidth    != m_biWidth)
	    || (HEADER(mt.pbFormat)->biHeight   != m_biHeight)
	    || (HEADER(mt.pbFormat)->biBitCount != m_biBitCount) )
	{

	    HEADER(mt.pbFormat)->biWidth    = m_biWidth;
	    HEADER(mt.pbFormat)->biHeight   = m_biHeight;
	    HEADER(mt.pbFormat)->biBitCount = m_biBitCount;
	    HEADER(mt.pbFormat)->biSizeImage = DIBSIZE(*HEADER(mt.pbFormat));

	    hr=m_pDexter->put_MediaType( &mt);
	}

	if(hr ==NOERROR )
	{	
	    m_pCBlack->m_rtStartTime = m_rtStartTime;
	    m_pCBlack->m_rtDuration = m_rtDuration;

	    //set Color
	    hr = m_pGenVid->put_RGBAValue( m_dwRGBA );
	}
    }

    if(hr!=NOERROR)
	return E_FAIL;
    return(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\black\resource.h ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by prop.rc
//
#define IDS_TITLE                       300
#define IDD_GenVid                      301
#define IDC_EFFECT                      302
#define IDB_DEFAULT                     303
#define IDC_START                       304
#define IDC_DURATION                    305
#define IDC_FRAMERATE                   306
#define IDC_BITCOUNT			307
#define IDC_VIDWIDTH                    308
#define IDC_VIDHEIGHT                   309
#define IDC_COLOR_R			310
#define IDC_COLOR_G			311
#define IDC_COLOR_B			312
#define IDC_COLOR_A			313
#ifndef IDS_STATIC
#define IDS_STATIC                      -1
#endif

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                1
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1010
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\black\black.h ===
// !!! Support IGenVideo, IDexterSequencer on the FILTER, not the pin?

//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

extern const AMOVIESETUP_FILTER sudBlkVid;


// Generates Black Video 

class CBlkVidStream;
class CGenVidProperties;

// Main object for a Generate Black Video
class CGenBlkVid :  public CSource
	    , public CPersistStream, public IDispatch

{
    friend class CBlkVidStream;

public:
    CGenBlkVid(LPUNKNOWN lpunk, HRESULT *phr);
    ~CGenBlkVid();
    DECLARE_IUNKNOWN;

    // IDispatch
    STDMETHODIMP GetTypeInfoCount(unsigned int *);
    STDMETHODIMP GetTypeInfo(unsigned int,unsigned long,struct ITypeInfo ** );
    STDMETHODIMP GetIDsOfNames(const struct _GUID &,unsigned short ** ,unsigned int,unsigned long,long *);
    STDMETHODIMP Invoke(long,const struct _GUID &,unsigned long,unsigned short,struct tagDISPPARAMS *,struct tagVARIANT *,struct tagEXCEPINFO *,unsigned int *);

    // Create GenBlkVid filter!
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    // CPersistStream
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    STDMETHODIMP GetClassID(CLSID *pClsid);
    int SizeMax();

private:

    CBlkVidStream *m_pStream;

    friend class CBlkVidStream;

}; // CGenBlkVid


// CBlkVidStream manages the data flow from the output pin.
class CBlkVidStream :	public CSourceStream
			, public IGenVideo
			, public IDexterSequencer
			, public ISpecifyPropertyPages
			, public IMediaSeeking
{
    friend class CGenBlkVid ;
    friend class CGenVidProperties ;

public:

    CBlkVidStream(HRESULT *phr, CGenBlkVid *pParent, LPCWSTR pPinName);
    ~CBlkVidStream();

    // IMediaSeeking methods
    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities ); 
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);	
    STDMETHODIMP GetTimeFormat(GUID *pFormat);		    
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);  
    STDMETHODIMP IsFormatSupported( const GUID * pFormat); 
    STDMETHODIMP QueryPreferredFormat( GUID *pFormat);	    
    STDMETHODIMP SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
                             , LONGLONG * pStop, DWORD StopFlags );
    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );
    STDMETHODIMP GetCurrentPosition( LONGLONG * pCurrent );
    STDMETHODIMP GetStopPosition( LONGLONG * pStop );
    STDMETHODIMP GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest );
    STDMETHODIMP GetDuration( LONGLONG *pDuration );
    STDMETHODIMP GetPreroll( LONGLONG *pllPreroll )
	{ if( pllPreroll) *pllPreroll =0; return S_OK; };
    STDMETHODIMP SetRate( double dRate);
    STDMETHODIMP GetRate( double * pdRate);
    STDMETHODIMP ConvertTimeFormat(LONGLONG *pTarget, const GUID *pTargetFormat,
				   LONGLONG Source, const GUID *pSourceFormat )
	{ return E_NOTIMPL ;};


    //IGenVideo, IDexterSequencer, and ISpecifyPropertyPages
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);
    STDMETHODIMP GetPages(CAUUID *pPages);
    DECLARE_IUNKNOWN;

    // put blank ARGB32 video into the supplied video frame
    HRESULT DoBufferProcessingLoop(void);
    HRESULT FillBuffer(IMediaSample *pms);

    // To say "read only buffer"
    HRESULT DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc);

    // Ask for buffers of the size appropriate to the agreed media type
    HRESULT DecideBufferSize(IMemAllocator *pIMemAlloc,
                             ALLOCATOR_PROPERTIES *pProperties);


    HRESULT CheckMediaType(const CMediaType *pMediaType);
    HRESULT GetMediaType(int iPosition, CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType* pmt);

    // Resets the stream time to zero
    HRESULT OnThreadCreate(void);


    //IDexterSequencer
    STDMETHODIMP get_OutputFrmRate(double *dpFrmRate);
    STDMETHODIMP put_OutputFrmRate(double dFrmRate);
    STDMETHODIMP get_MediaType(AM_MEDIA_TYPE *pmt);
    STDMETHODIMP put_MediaType(const AM_MEDIA_TYPE *pmt);
    STDMETHODIMP GetStartStopSkewCount(int *piCount);
    STDMETHODIMP GetStartStopSkew(REFERENCE_TIME *prtStart, REFERENCE_TIME *prtStop, REFERENCE_TIME *prtSkew, double *pdRate);
    STDMETHODIMP AddStartStopSkew(REFERENCE_TIME rtStart, REFERENCE_TIME rtStop, REFERENCE_TIME rtSkew, double dRate);
    STDMETHODIMP ClearStartStopSkew();

    //IGenVideo
    STDMETHODIMP ImportSrcBuffer(const AM_MEDIA_TYPE *pmt, const BYTE *pBuf);
    STDMETHODIMP get_RGBAValue(long *dwRGBA);
    STDMETHODIMP put_RGBAValue(long dwRGBA);

    // DO NO SUPPORT Quality control notifications sent to us
    // STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);
    
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);

protected:

    REFERENCE_TIME	m_rtStartTime;	// start time to play
    REFERENCE_TIME	m_rtDuration;	// duration

    REFERENCE_TIME	m_rtNewSeg;	// last NewSeg given

    LONG		m_lDataLen;		//actual output data lenght
    CMediaType 		m_mtAccept;		// accept only this type
    LONGLONG		m_llSamplesSent;	// output frame cnt
    double		m_dOutputFrmRate;	// Output frm rate frames/second
    LONG		m_dwRGBA;		// solid colour to generate
    BYTE		m_bIntBufCnt;		// CNT for first 2 sampel	
    int			m_iBufferCnt;		//record how many buffer it can gets
    BYTE		m_bZeroBufCnt;		// How many buffer already set to 0
    BYTE		**m_ppbDstBuf;
    BOOL		m_fMediaTypeIsSet;	//flag : whether put_MediaType() is called first
    PBYTE		m_pImportBuffer;	//pointer to import data buffer

    CCritSec    m_csFilling;	// are we delivering?

}; // CBlkVidStream
	

class CGenVidProperties : public CBasePropertyPage
{

public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
         
private:
    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();

    void SetDirty();

    CGenVidProperties(LPUNKNOWN lpunk, HRESULT *phr);


    STDMETHODIMP GetFromDialog();

    BOOL m_bIsInitialized;  // Will be false while we set init values in Dlg
                            // to prevent theDirty flag from being set.

    REFERENCE_TIME	m_rtStartTime;
    REFERENCE_TIME	m_rtDuration;
    LONG		m_biWidth;			// output video Width
    LONG		m_biHeight;			// output video Height
    WORD		m_biBitCount;			// support 16,24,32
    double		m_dOutputFrmRate;		// Output frm rate frames/second
    long		m_dwRGBA;	// solid colour to generate


    CBlkVidStream	*m_pCBlack;
    IGenVideo		*m_pGenVid;
    IDexterSequencer	*m_pDexter;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\black\black.cpp ===
// !!! use 2 RO buffers, fill with black by calling GetBuffer twice

//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#ifdef FILTER_DLL
#include <initguid.h>
#endif
#include <qeditint.h>
#include <qedit.h>
#include "black.h"
#include "..\util\conv.cxx"

#define MAXBUFFERCNT   2

// Setup data

const AMOVIESETUP_MEDIATYPE sudOpPinTypes =
{
    &MEDIATYPE_Video,       // Major type
    &MEDIASUBTYPE_NULL      // Minor type
};

const AMOVIESETUP_PIN sudOpPin =
{
    L"Output",              // Pin string name
    FALSE,                  // Is it rendered
    TRUE,                   // Is it an output
    FALSE,                  // Can we have none
    FALSE,                  // Can we have many
    &CLSID_NULL,            // Connects to filter
    NULL,                   // Connects to pin
    1,                      // Number of types
    &sudOpPinTypes };       // Pin details

const AMOVIESETUP_FILTER sudBlkVid =
{
    &CLSID_GenBlkVid,    // Filter CLSID
    L"Generate Solid Colour",  // String name
    MERIT_DO_NOT_USE,       // Filter merit
    1,                      // Number pins
    &sudOpPin               // Pin details
};


#ifdef FILTER_DLL
// COM global table of objects in this dll

CFactoryTemplate g_Templates[] = {
  { L"Generate Solid Colour"
  , &CLSID_GenBlkVid
  , CGenBlkVid::CreateInstance
  , NULL
  , &sudBlkVid
  },
  {L"Video Property"
  , &CLSID_GenVidPropertiesPage
  , CGenVidProperties::CreateInstance
  }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);


//
// DllRegisterServer
//
// Exported entry points for registration and unregistration
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );

} // DllRegisterServer


//
// DllUnregisterServer
//
STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );

} // DllUnregisterServer
#endif


//
// CreateInstance
//
// Create GenBlkVid filter
//
CUnknown * WINAPI CGenBlkVid::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CGenBlkVid(lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return punk;

} // CreateInstance


//
// Constructor
//
// Initialise a CBlkVidStream object so that we have a pin.
//
CGenBlkVid::CGenBlkVid(LPUNKNOWN lpunk, HRESULT *phr) :
    CSource(NAME("Generate Solid Colour") ,lpunk,CLSID_GenBlkVid)
   ,CPersistStream(lpunk, phr)

{
    DbgLog((LOG_TRACE,3,TEXT("BLACK::")));

    CAutoLock cAutoLock(pStateLock());

    m_paStreams    = (CSourceStream **) new CBlkVidStream*[1];
    if (m_paStreams == NULL) {
        *phr = E_OUTOFMEMORY;
	return;
    }

    m_paStreams[0] = new CBlkVidStream(phr, this, L"Generate Solid Colour");
    if (m_paStreams[0] == NULL) {
        *phr = E_OUTOFMEMORY;
	return;
    }

} // (Constructor)


CGenBlkVid::~CGenBlkVid()
{
    DbgLog((LOG_TRACE,3,TEXT("~BLACK::")));
}


STDMETHODIMP CGenBlkVid::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CheckPointer(ppv,E_POINTER);

    if (riid == IID_IPersistStream) {
	return GetInterface((IPersistStream *) this, ppv);
    } else if (riid == IID_IDispatch) {
        return GetInterface((IDispatch *)this, ppv);
    } else {
	return CSource::NonDelegatingQueryInterface(riid, ppv);
    }
} // NonDelegatingQueryInterface



// IDispatch
//
STDMETHODIMP CGenBlkVid::GetTypeInfoCount(unsigned int *)
{
    return E_NOTIMPL;
}


STDMETHODIMP CGenBlkVid::GetTypeInfo(unsigned int,unsigned long,struct ITypeInfo ** )
{
    return E_NOTIMPL;
}


STDMETHODIMP CGenBlkVid::GetIDsOfNames(const struct _GUID &guid,unsigned short **pName ,unsigned int num,unsigned long loc,long *pOut)
{
    WCHAR *pw = *pName;
    if(
        (!DexCompareW(L"colour", pw))
        ||
        (!DexCompareW(L"color", pw))
    )
    {
	*pOut = 1;
	return S_OK;
    }
	
    return E_FAIL;
}


STDMETHODIMP CGenBlkVid::Invoke(long dispid,const struct _GUID &,unsigned long,unsigned short,struct tagDISPPARAMS *pDisp,struct tagVARIANT *,struct tagEXCEPINFO *,unsigned int *)
{
    if (dispid != 1)
	return E_FAIL;

    CBlkVidStream *pOutpin=( CBlkVidStream *)m_paStreams[0];

    #define US_LCID MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT)
    VARIANT v;
    VariantInit(&v);
    HRESULT hr = VariantChangeTypeEx(&v, pDisp->rgvarg, US_LCID, 0, VT_R8);
    ASSERT(hr == S_OK);

    double f = V_R8(&v);
    pOutpin->m_dwRGBA = (DWORD)f;

    return S_OK;
}


// IPersistStream

// tell our clsid
//
STDMETHODIMP CGenBlkVid::GetClassID(CLSID *pClsid)
{
    CheckPointer(pClsid, E_POINTER);
    *pClsid = CLSID_GenBlkVid;
    return S_OK;
}

typedef struct _BLKSave {
    double		dOutputFrmRate;	// Output frm rate frames/second
    LONG		dwRGBA;
    AM_MEDIA_TYPE mt; 			// format is hidden after the array
} BLKSav;

// persist ourself
//
HRESULT CGenBlkVid::WriteToStream(IStream *pStream)
{
    DbgLog((LOG_TRACE,1,TEXT("CGenBlkVid::WriteToStream")));

    CheckPointer(pStream, E_POINTER);
    CheckPointer(m_paStreams[0], E_POINTER);

    BLKSav *px;
    CBlkVidStream *pOutpin=( CBlkVidStream *)m_paStreams[0];

    //get current media type
    CMediaType MyMt;
    pOutpin->get_MediaType( &MyMt );

    int savesize = sizeof(BLKSav) + MyMt.cbFormat;

    DbgLog((LOG_TRACE,1,TEXT("Persisted data is %d bytes"), savesize));

    px = (BLKSav *)QzTaskMemAlloc(savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	FreeMediaType(MyMt);
	return E_OUTOFMEMORY;
    }

    px->dOutputFrmRate	= pOutpin->m_dOutputFrmRate;
    px->dwRGBA		= pOutpin->m_dwRGBA;

    px->mt	    = MyMt;
    // Can't persist pointers
    px->mt.pbFormat = NULL;
    px->mt.pUnk	    = NULL;		// !!!

    BYTE *pb;
    pb=(BYTE *)(px)+sizeof(BLKSav);

    // the format goes after the array
    CopyMemory(pb, MyMt.pbFormat, MyMt.cbFormat);

    HRESULT hr = pStream->Write(px, savesize, 0);
    FreeMediaType(MyMt);
    QzTaskMemFree(px);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** WriteToStream FAILED")));
        return hr;
    }
    return NOERROR;
}


// load ourself
//
HRESULT CGenBlkVid::ReadFromStream(IStream *pStream)
{
    DbgLog((LOG_TRACE,1,TEXT("CenBlkVid::ReadFromStream")));

    CheckPointer(pStream, E_POINTER);
    CheckPointer(m_paStreams[0], E_POINTER);

    int savesize=sizeof(BLKSav);

    // we don't yet know how many saved connections there are
    // all we know we have for sure is the beginning of the struct
    BLKSav *px = (BLKSav *)QzTaskMemAlloc(savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	return E_OUTOFMEMORY;
    }

    HRESULT hr = pStream->Read(px, savesize, 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    if(px->mt.cbFormat)
    {
	// how much saved data was there, really?  Get the rest
	savesize +=  px->mt.cbFormat;
	px = (BLKSav *)QzTaskMemRealloc(px, savesize);
	if (px == NULL) {
	    DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	    return E_OUTOFMEMORY;
	}

    }
    DbgLog((LOG_TRACE,1,TEXT("Persisted data is %d bytes"), savesize));

    BYTE *pb;
    pb=(BYTE *)(px)+sizeof(BLKSav) ;
    hr = pStream->Read(pb, (savesize-sizeof(BLKSav)), 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    CBlkVidStream *pOutpin=( CBlkVidStream *)m_paStreams[0];

    pOutpin->put_OutputFrmRate(px->dOutputFrmRate);
    pOutpin->put_RGBAValue(px->dwRGBA);

    AM_MEDIA_TYPE MyMt = px->mt;
    MyMt.pbFormat = (BYTE *)QzTaskMemAlloc(MyMt.cbFormat);

    // remember, the format is after the array
    CopyMemory(MyMt.pbFormat, pb, MyMt.cbFormat);

    pOutpin->put_MediaType (&MyMt);
    FreeMediaType(MyMt);
    QzTaskMemFree(px);
    SetDirty(FALSE);
    return S_OK;
}

// how big is our save data?
int CGenBlkVid::SizeMax()
{
    if (!m_paStreams || !m_paStreams[0]) {
	return 0;

    }
    CBlkVidStream *pOutpin=( CBlkVidStream *)m_paStreams[0];
    int savesize = sizeof(BLKSav) + pOutpin->m_mtAccept.cbFormat;
    return savesize;
}


//
// output pin Constructor
//
CBlkVidStream::CBlkVidStream(HRESULT *phr,
                         CGenBlkVid *pParent,
                         LPCWSTR pPinName) :
    CSourceStream(NAME("Generate Solid Colour"),phr, pParent, pPinName),
    m_iBufferCnt(0),    //How many buffers we get
    m_lDataLen (0),	//output buffer data length
    m_dOutputFrmRate(15.0),
    m_dwRGBA( 0xFF000000 ),
    m_ppbDstBuf(NULL),
    m_fMediaTypeIsSet(FALSE),
    m_pImportBuffer(NULL),
    m_rtNewSeg(0),		// last NewSeg given
    // includes the NewSeg value
    m_rtStartTime(0),		// start at the beginning
    m_rtDuration(MAX_TIME/1000),// MUST DEFAULT TO INFINITE LENGTH because
				// dexter never sets a stop time! (don't be
				// too big that math on it will overflow)
    m_llSamplesSent(0)
{
    pParent->m_pStream	= this;

    //build a default media type
    ZeroMemory(&m_mtAccept, sizeof(AM_MEDIA_TYPE));
    m_mtAccept.majortype = MEDIATYPE_Video;
    m_mtAccept.subtype = MEDIASUBTYPE_ARGB32;
    m_mtAccept.formattype = FORMAT_VideoInfo;

    m_mtAccept.bFixedSizeSamples = TRUE;
    m_mtAccept.bTemporalCompression = FALSE;

    m_mtAccept.pbFormat = (BYTE *)QzTaskMemAlloc(sizeof(VIDEOINFOHEADER));
    m_mtAccept.cbFormat = sizeof(VIDEOINFOHEADER);
    ZeroMemory(m_mtAccept.pbFormat, m_mtAccept.cbFormat);

    LPBITMAPINFOHEADER lpbi = HEADER(m_mtAccept.pbFormat);
    lpbi->biSize = sizeof(BITMAPINFOHEADER);
    lpbi->biCompression = BI_RGB;
    lpbi->biBitCount	= 32;
    lpbi->biWidth	= 320;
    lpbi->biHeight	= 240;
    lpbi->biPlanes	= 1;
    lpbi->biSizeImage = DIBSIZE(*lpbi);
    m_mtAccept.lSampleSize = DIBSIZE(*lpbi);
    ((VIDEOINFOHEADER *)(m_mtAccept.pbFormat))->AvgTimePerFrame = Frame2Time( 1, m_dOutputFrmRate );
    ((VIDEOINFOHEADER *)(m_mtAccept.pbFormat))->dwBitRate =
				(DWORD)(DIBSIZE(*lpbi) * m_dOutputFrmRate);

} // (Constructor)

    //X
// destructor
CBlkVidStream::~CBlkVidStream()
{
    /* BUFFER POINTER */
    if (m_ppbDstBuf)  delete [] m_ppbDstBuf;

    if (m_pImportBuffer){ delete [] m_pImportBuffer; m_pImportBuffer=NULL;};

    FreeMediaType(m_mtAccept);
}

//
// IGenVideo, IDexterSequencer
// ISpecifyPropertyPages
//
STDMETHODIMP CBlkVidStream::NonDelegatingQueryInterface(
    REFIID riid,
    void ** ppv
    )
{
    if (IsEqualIID(IID_IGenVideo, riid))
      return GetInterface((IGenVideo *) this, ppv);

    if (IsEqualIID(IID_IDexterSequencer, riid))
      return GetInterface((IDexterSequencer *) this, ppv);

    if (IsEqualIID(IID_ISpecifyPropertyPages, riid))
      return GetInterface((ISpecifyPropertyPages *) this, ppv);

    if (IsEqualIID(IID_IMediaSeeking, riid))
      return GetInterface((IMediaSeeking *) this, ppv);

    return CSourceStream::NonDelegatingQueryInterface(riid, ppv);
}


//
// DoBufferProcessingLoop - overridden to put time stamps on GetBuffer
//
// Grabs a buffer and calls the users processing function.
// Overridable, so that different delivery styles can be catered for.
HRESULT CBlkVidStream::DoBufferProcessingLoop(void) {

    Command com;

    DbgLog((LOG_TRACE, 3, TEXT("Entering DoBufferProcessing Loop")));

    OnThreadStartPlay();

    do {
	while (!CheckRequest(&com)) {
	    IMediaSample *pSample;

    	    // What time stamps will this buffer get? Use that in GetBuffer
	    // because the switch needs to know.  MAKE SURE to use the same
	    // algorithm as FillBuffer!
    	    LONGLONG llOffset = Time2Frame( m_rtStartTime, m_dOutputFrmRate );
    	    REFERENCE_TIME rtStart = Frame2Time( llOffset + m_llSamplesSent,
							m_dOutputFrmRate );
    	    REFERENCE_TIME rtStop = Frame2Time( llOffset + m_llSamplesSent + 1,
							m_dOutputFrmRate );

    	    if ( rtStart > m_rtStartTime + m_rtDuration ||
		(rtStart == m_rtStartTime + m_rtDuration && m_rtDuration > 0)) {
		DbgLog((LOG_TRACE,2,TEXT("Black: Finished")));
		//m_llSamplesSent = 0;
		DeliverEndOfStream();
		return S_OK;
    	    }

    	    rtStart -= m_rtNewSeg;
    	    rtStop -= m_rtNewSeg;

    	    DbgLog((LOG_TRACE,2,TEXT("Black: GetBuffer %d"),
						(int)(rtStart / 10000)));
	    HRESULT hr = GetDeliveryBuffer(&pSample,&rtStart,&rtStop,0);
	    if (FAILED(hr)) {
    	        DbgLog((LOG_TRACE,2,TEXT("Black: FAILED %x"), hr));
		return S_OK;
	    }

	    // Virtual function user will override.
	    hr = FillBuffer(pSample);

	    if (hr == S_OK) {
		hr = Deliver(pSample);
                pSample->Release();

                // downstream filter returns S_FALSE if it wants us to
                // stop or an error if it's reporting an error.
                if(hr != S_OK)
                {
                  DbgLog((LOG_TRACE, 2, TEXT("Deliver() returned %08x; stopping"), hr));
		  // NO NO! DeliverEndOfStream();
		  // !!! EC_ERRORABORT if FAILED?
                  return hr;
                }

	    } else if (hr == S_FALSE) {
                // derived class wants us to stop pushing data
		pSample->Release();
		DeliverEndOfStream();
		return S_OK;
	    } else {
                // derived class encountered an error
                pSample->Release();
		DbgLog((LOG_ERROR, 1, TEXT("Error %08lX from FillBuffer!!!"), hr));
                DeliverEndOfStream();
                m_pFilter->NotifyEvent(EC_ERRORABORT, hr, 0);
                return hr;
	    }

            // all paths release the sample
	}

        // For all commands sent to us there must be a Reply call!

	if (com == CMD_RUN || com == CMD_PAUSE) {
	    Reply(NOERROR);
	} else if (com != CMD_STOP) {
	    Reply((DWORD) E_UNEXPECTED);
	    DbgLog((LOG_ERROR, 1, TEXT("Unexpected command!!!")));
	}
    } while (com != CMD_STOP);

    return S_FALSE;
}


//
// FillBuffer called by HRESULT CSourceStream::DoBufferProcessingLoop(void) {
//
// Plots a Blk video into the supplied video buffer
//
// Give  a start time, a duration, and a frame rate,
// it sends  a certain size (ARGB32, RGB555,RGB24 ) black frames out time stamped appropriately starting
// at the start time.
//
HRESULT CBlkVidStream::FillBuffer(IMediaSample *pms)
{
    CAutoLock foo(&m_csFilling);

    ASSERT( m_ppbDstBuf != NULL );
    ASSERT( m_iBufferCnt );
    ASSERT( m_dOutputFrmRate != 0.0);

    // !!! If NewSeg > 0, this is broken!

    // calc the output sample times the SAME WAY FRC DOES, so the FRC will
    // not need to modify anything
    LONGLONG llOffset = Time2Frame( m_rtStartTime, m_dOutputFrmRate );
    REFERENCE_TIME rtStart = Frame2Time( llOffset + m_llSamplesSent,
							m_dOutputFrmRate );
    REFERENCE_TIME rtStop = Frame2Time( llOffset + m_llSamplesSent + 1,
							m_dOutputFrmRate );
    if ( rtStart > m_rtStartTime + m_rtDuration ||
		(rtStart == m_rtStartTime + m_rtDuration && m_rtDuration > 0)) {
	DbgLog((LOG_TRACE,2,TEXT("Black: Finished")));
	//m_llSamplesSent = 0;
	DeliverEndOfStream();
	return S_FALSE;
    }

    rtStart -= m_rtNewSeg;
    rtStop -= m_rtNewSeg;

    BYTE *pData;

    //pms: output media sample pointer
    pms->GetPointer(&pData);	    //get pointer to output buffer

    if( m_bZeroBufCnt < m_iBufferCnt  )	
    {
	//
	// there is no guarantee the buffer we just get is not initilized before
	//
	int	i	= 0;
	BOOL	bInit	= FALSE;
	while ( i <  m_bZeroBufCnt )
	{
	    if( m_ppbDstBuf[ i++ ] == pData)
	    {
		bInit	= TRUE;
		break;
	    }
	}

	if( bInit   == FALSE )
	{
	    long lDataLen = pms->GetSize(); //get output buffer size
	    if(!m_dwRGBA)
	    {
		//import buffer
		if(m_pImportBuffer)
		    memcpy(pData,m_pImportBuffer,lDataLen);
		else
		    //TRANSPARENT black
    		    ZeroMemory( pData, lDataLen );  //clear memory
	    }
	    else
	    {
		long *pl    =	(long *)pData;
		BYTE *p=(BYTE *)pl;
		int iCnt= lDataLen/12;
		
		switch(HEADER(m_mtAccept.pbFormat)->biBitCount)
		{
		case 32:
		    while(lDataLen)
		    {
			*pl++=m_dwRGBA;
			lDataLen-=4;
		    }
		    break;
		case 24:
		    long dwVal[3];
		    dwVal[0]= ( m_dwRGBA & 0xffffff )       | ( (m_dwRGBA & 0xff) << 24);
		    dwVal[1]= ( (m_dwRGBA & 0xffff00) >>8 ) | ( (m_dwRGBA & 0xffff) << 16);
		    dwVal[2]= ( (m_dwRGBA & 0xff0000) >>16 )| ( (m_dwRGBA & 0xffffff) << 8);
		    while(iCnt)
		    {
			*pl++=dwVal[0];
			*pl++=dwVal[1];
			*pl++=dwVal[2];
			iCnt--;
		    }
		    while(iCnt)
		    {
			*p++=(BYTE)( m_dwRGBA & 0xff );
			*p++=(BYTE)( ( m_dwRGBA & 0xff00 ) >> 8) ;
			*p++=(BYTE)( ( m_dwRGBA & 0xff0000 ) >> 16) ;
			iCnt--;
		    }
		    break;
		case 16:
		    WORD wTmp=(WORD)(  ((m_dwRGBA & 0xf8)    >>3 )      //R
				    | ((m_dwRGBA & 0xf800)  >>6 )      //G
				    | ((m_dwRGBA & 0xf80000)>>9 ) );	//B
		    WORD *pw=(WORD *)pData;
		    while(lDataLen)
		    {
			*pw++=wTmp;
			lDataLen-=2;
		    }
		    break;
		}
	    }
	    m_ppbDstBuf[ i ]	= pData;    //save this data pointer	
	    m_bZeroBufCnt++;
	}
    }

    DbgLog((LOG_TRACE,2,TEXT("Black: Deliver %d"), (int)(rtStart / 10000)));
    pms->SetTime( &rtStart,&rtStop);

    m_llSamplesSent++;
    pms->SetActualDataLength(m_lDataLen);
    pms->SetSyncPoint(TRUE);
    return NOERROR;

} // FillBuffer


//
// GetMediaType
//
HRESULT CBlkVidStream::GetMediaType(int iPosition, CMediaType *pmt)
{
    CAutoLock cAutoLock(m_pFilter->pStateLock());

    if (iPosition < 0) {
        return E_INVALIDARG;
    }

    // Have we run off the end of types
    if (iPosition > 0) {
        return VFW_S_NO_MORE_ITEMS;
    }

    AM_MEDIA_TYPE mt;
    get_MediaType(&mt);
    *pmt = mt;
    FreeMediaType(mt);

    return NOERROR;

} // GetMediaType


// set media type
//
HRESULT CBlkVidStream::SetMediaType(const CMediaType* pmt)
{
    HRESULT hr;
    DbgLog((LOG_TRACE,2,TEXT("SetMediaType %x %dbit %dx%d"),
		HEADER(pmt->Format())->biCompression,
		HEADER(pmt->Format())->biBitCount,
		HEADER(pmt->Format())->biWidth,
		HEADER(pmt->Format())->biHeight));

// !!! check for the frame rate given, and use it?

    return CSourceStream::SetMediaType(pmt);
}

//
// CheckMediaType
//
// We accept mediatype =vids, subtype =MEDIASUBTYPE_ARGB32, RGB24, RGB555
// Returns E_INVALIDARG if the mediatype is not acceptable
//
HRESULT CBlkVidStream::CheckMediaType(const CMediaType *pMediaType)
{
    CAutoLock cAutoLock(m_pFilter->pStateLock());

    if (   ( (*pMediaType->Type())   != MEDIATYPE_Video )  	// we only output video!
	|| (    (*pMediaType->Subtype())!= MEDIASUBTYPE_ARGB32
	     && (*pMediaType->Subtype())!= MEDIASUBTYPE_RGB24
	     && (*pMediaType->Subtype())!= MEDIASUBTYPE_RGB555
	    )
       )
                return E_INVALIDARG;

    // Get the format area of the media type
    VIDEOINFO *pvi = (VIDEOINFO *) pMediaType->Format();

    if (pvi == NULL)
	return E_INVALIDARG;

    // Check the image size.
    if ( (pvi->bmiHeader.biWidth  != HEADER(m_mtAccept.pbFormat)->biWidth )  ||
	 (pvi->bmiHeader.biHeight != HEADER(m_mtAccept.pbFormat)->biHeight ) ||
	 (pvi->bmiHeader.biBitCount != HEADER(m_mtAccept.pbFormat)->biBitCount ))
    {
	return E_INVALIDARG;
    }

    if( !IsRectEmpty( &pvi->rcTarget) ) {
	if (pvi->rcTarget.top != 0 || pvi->rcTarget.left !=0 ||
		pvi->rcTarget.right != pvi->bmiHeader.biWidth ||
		pvi->rcTarget.bottom != pvi->bmiHeader.biHeight) {
	    return VFW_E_TYPE_NOT_ACCEPTED;
	}
    }
    if( !IsRectEmpty( &pvi->rcSource) ) {
	if (pvi->rcSource.top != 0 || pvi->rcSource.left !=0 ||
		pvi->rcSource.right != pvi->bmiHeader.biWidth ||
		pvi->rcSource.bottom != pvi->bmiHeader.biHeight) {
	    return VFW_E_TYPE_NOT_ACCEPTED;
	}
    }
	
    return S_OK;  // This format is acceptable.

} // CheckMediaType


HRESULT CBlkVidStream::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    HRESULT hr = NOERROR;
    *ppAlloc = NULL;

    // get downstream prop request
    // the derived class may modify this in DecideBufferSize, but
    // we assume that he will consistently modify it the same way,
    // so we only get it once
    ALLOCATOR_PROPERTIES prop;
    ZeroMemory(&prop, sizeof(prop));

    // whatever he returns, we assume prop is either all zeros
    // or he has filled it out.
    pPin->GetAllocatorRequirements(&prop);

    // if he doesn't care about alignment, then set it to 1
    if (prop.cbAlign == 0) {
        prop.cbAlign = 1;
    }

    /* Try the allocator provided by the input pin */

    hr = pPin->GetAllocator(ppAlloc);
    if (SUCCEEDED(hr)) {

	hr = DecideBufferSize(*ppAlloc, &prop);
	if (SUCCEEDED(hr)) {
	    hr = pPin->NotifyAllocator(*ppAlloc, TRUE);		//read only buffer
	    if (SUCCEEDED(hr)) {
		return NOERROR;
	    }
	}
    }

    /* If the GetAllocator failed we may not have an interface */

    if (*ppAlloc) {
	(*ppAlloc)->Release();
	*ppAlloc = NULL;
    }

    /* Try the output pin's allocator by the same method */

    hr = InitAllocator(ppAlloc);
    if (SUCCEEDED(hr)) {

        // note - the properties passed here are in the same
        // structure as above and may have been modified by
        // the previous call to DecideBufferSize
	hr = DecideBufferSize(*ppAlloc, &prop);
	if (SUCCEEDED(hr)) {
	    hr = pPin->NotifyAllocator(*ppAlloc, TRUE);  //READ-only buffer
	    if (SUCCEEDED(hr)) {
		return NOERROR;
	    }
	}
    }

    /* Likewise we may not have an interface to release */

    if (*ppAlloc) {
	(*ppAlloc)->Release();
	*ppAlloc = NULL;
    }
    return hr;
}

//
// DecideBufferSize
//
// This will always be called after the format has been sucessfully
// negotiated. So we have a look at m_mt to see what size image we agreed.
// Then we can ask for buffers of the correct size to contain them.
//
HRESULT CBlkVidStream::DecideBufferSize(IMemAllocator *pAlloc,ALLOCATOR_PROPERTIES *pProperties)
{
    CAutoLock cAutoLock(m_pFilter->pStateLock());

    ASSERT(pAlloc);
    ASSERT(pProperties);
    HRESULT hr = NOERROR;

    VIDEOINFO *pvi = (VIDEOINFO *) m_mt.Format();

    pProperties->cBuffers = MAXBUFFERCNT;   //only one read-only buffer
    pProperties->cbBuffer = pvi->bmiHeader.biSizeImage;


    // Ask the allocator to reserve us some sample memory, NOTE the function
    // can succeed (that is return NOERROR) but still not have allocated the
    // memory that we requested, so we must check we got whatever we wanted

    ALLOCATOR_PROPERTIES Actual;
    hr = pAlloc->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        return hr;
    }

    // Is this allocator unsuitable

    if (Actual.cbBuffer < pProperties->cbBuffer) {
        return E_FAIL;
    }

    //because I am not insisting my own buffer, I may get more than MAXBUFFERCNT buffers.
    m_iBufferCnt =Actual.cBuffers; //how many buffer need to be set to 0

    return NOERROR;

} // DecideBufferSize



//
// OnThreadCreate
//
//
HRESULT CBlkVidStream::OnThreadCreate()
{
    // we have to have at least MAXBUFFERCNT buffer
    ASSERT(m_iBufferCnt >= MAXBUFFERCNT);

    //output frame cnt
    m_llSamplesSent	    =0;

    //how many buffer is already set to 0.
    m_bZeroBufCnt	    =0;

    // actual output buffer's data size
    m_lDataLen= HEADER(m_mtAccept.pbFormat)->biHeight * (DWORD)WIDTHBYTES((DWORD)HEADER(m_mtAccept.pbFormat)->biWidth * HEADER(m_mtAccept.pbFormat)->biBitCount);

    // will be used to zero the Dst buffers
    delete [] m_ppbDstBuf;
    m_ppbDstBuf		= new BYTE *[ m_iBufferCnt ];   //NULL;
    if( !m_ppbDstBuf )
    {
        return E_OUTOFMEMORY;
    }

    // don't reset m_rtNewSeg!  We might have seeked while stopped

    for (int i=0; i<m_iBufferCnt; i++)
	m_ppbDstBuf[i]=NULL;

    return NOERROR;

} // OnThreadCreate


//
// Notify
//
//
STDMETHODIMP CBlkVidStream::Notify(IBaseFilter * pSender, Quality q)
{
    //Even I am later, I do not care. I still send my time frame as nothing happened.
    return NOERROR;

} // Notify

//
// GetPages
//
// Returns the clsid's of the property pages we support
//
STDMETHODIMP CBlkVidStream::GetPages(CAUUID *pPages)
{
    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
    if (pPages->pElems == NULL)
    {
        return E_OUTOFMEMORY;
    }
    *(pPages->pElems) = CLSID_GenVidPropertiesPage;
    return NOERROR;

} // GetPages

//
// IDexterSequencer
//

STDMETHODIMP CBlkVidStream::get_OutputFrmRate( double *dpFrmRate )
{
    CAutoLock cAutolock(m_pFilter->pStateLock());

    CheckPointer(dpFrmRate,E_POINTER);

    *dpFrmRate = m_dOutputFrmRate;

    return NOERROR;

} // get_OutputFrmRate

//
// Frame rate can be changed as long as the filter is stopped.
//
STDMETHODIMP CBlkVidStream::put_OutputFrmRate( double dFrmRate )
{
    CAutoLock cAutolock(m_pFilter->pStateLock());

    //can not change property if our filter is not currently stopped
    if(!IsStopped() )
      return VFW_E_WRONG_STATE;

    // don't blow up
    if (dFrmRate == 0.0)
	dFrmRate = 0.1;
    m_dOutputFrmRate = dFrmRate;

    return NOERROR;

} // put_OutputFrmRate

STDMETHODIMP CBlkVidStream::get_MediaType(AM_MEDIA_TYPE *pmt)
{
    CAutoLock cAutolock(m_pFilter->pStateLock());
    CheckPointer(pmt,E_POINTER);

    CopyMediaType(pmt, &m_mtAccept);

    return NOERROR;
}

//
// size can be changed only the output pin is not connected yet.
//
STDMETHODIMP CBlkVidStream::put_MediaType(const AM_MEDIA_TYPE *pmt)
{
    CAutoLock cAutolock(m_pFilter->pStateLock());
    CheckPointer(pmt,E_POINTER);

    if ( IsConnected() )
	return VFW_E_ALREADY_CONNECTED;

    if ( HEADER(pmt->pbFormat)->biBitCount != 32 &&
	 HEADER(pmt->pbFormat)->biBitCount != 24 &&
	 HEADER(pmt->pbFormat)->biBitCount != 16)
	return E_INVALIDARG;

    if (HEADER(pmt->pbFormat)->biWidth == 16 &&
	pmt->subtype != MEDIASUBTYPE_RGB555)
	return E_INVALIDARG;

    FreeMediaType(m_mtAccept);
    CopyMediaType(&m_mtAccept, pmt);

    m_fMediaTypeIsSet =TRUE;

    return NOERROR;
}


// We don't support this, the frame rate converter does

STDMETHODIMP CBlkVidStream::GetStartStopSkewCount(int *piCount)
{
    return E_NOTIMPL;
}


STDMETHODIMP CBlkVidStream::GetStartStopSkew( REFERENCE_TIME *prtStart, REFERENCE_TIME *prtStop, REFERENCE_TIME *prtSkew, double *pdRate )
{
    return E_NOTIMPL;
}

STDMETHODIMP CBlkVidStream::AddStartStopSkew( REFERENCE_TIME rtStart, REFERENCE_TIME rtStop, REFERENCE_TIME rtSkew , double dRate)
{
    return E_NOTIMPL;
}


//
// Duration can be changed as long as the filter is stopped.
//
STDMETHODIMP CBlkVidStream::ClearStartStopSkew()
{
    return E_NOTIMPL;
}


//
// IGenVideo
//


STDMETHODIMP CBlkVidStream::get_RGBAValue( long *pdwRGBA )
{
    CAutoLock cAutolock(m_pFilter->pStateLock());
    CheckPointer(pdwRGBA,E_POINTER);

    *pdwRGBA=m_dwRGBA ;

    return NOERROR;

}

STDMETHODIMP CBlkVidStream::put_RGBAValue( long dwRGBA )
{

    CAutoLock cAutolock(m_pFilter->pStateLock());

    //can not change duration if our filter is not currently stopped
    if(!IsStopped() )
      return VFW_E_WRONG_STATE;

    m_dwRGBA = dwRGBA;

    return NOERROR;

}


// --- IMediaSeeking methods ----------

STDMETHODIMP
CBlkVidStream::GetCapabilities(DWORD * pCaps)
{
    CheckPointer(pCaps,E_POINTER);
    // we always know the current position
    *pCaps =     AM_SEEKING_CanSeekAbsolute
		   | AM_SEEKING_CanSeekForwards
		   | AM_SEEKING_CanSeekBackwards
		   | AM_SEEKING_CanGetCurrentPos
		   | AM_SEEKING_CanGetStopPos
		   | AM_SEEKING_CanGetDuration;
		   //| AM_SEEKING_CanDoSegments
		   //| AM_SEEKING_Source;
    return S_OK;
}


STDMETHODIMP
CBlkVidStream::CheckCapabilities(DWORD * pCaps)
{
    CheckPointer(pCaps,E_POINTER);

    DWORD dwMask = 0;
    GetCapabilities(&dwMask);
    *pCaps &= dwMask;

    return S_OK;
}


STDMETHODIMP
CBlkVidStream::IsFormatSupported(const GUID * pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    return (*pFormat == TIME_FORMAT_MEDIA_TIME) ? S_OK : S_FALSE;
}

STDMETHODIMP
CBlkVidStream::QueryPreferredFormat(GUID *pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    *pFormat = TIME_FORMAT_MEDIA_TIME;
    return S_OK;
}

STDMETHODIMP
CBlkVidStream::SetTimeFormat(const GUID * pFormat)
{
    CheckPointer(pFormat,E_POINTER);

    if(*pFormat == TIME_FORMAT_MEDIA_TIME)
	return S_OK;
    else
	return E_FAIL;
}

STDMETHODIMP
CBlkVidStream::GetTimeFormat(GUID *pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    *pFormat = TIME_FORMAT_MEDIA_TIME ;
    return S_OK;
}

STDMETHODIMP
CBlkVidStream::IsUsingTimeFormat(const GUID * pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    if (*pFormat == TIME_FORMAT_MEDIA_TIME)
	return S_OK;
    else
	return S_FALSE;
}

// The biggie!
//
STDMETHODIMP
CBlkVidStream::SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
			  , LONGLONG * pStop, DWORD StopFlags )
{
    // make sure we're not filling a buffer right now
    m_csFilling.Lock();

    HRESULT hr;
    REFERENCE_TIME rtStart, rtStop;

    // we don't do segments
    if ((CurrentFlags & AM_SEEKING_Segment) ||
				(StopFlags & AM_SEEKING_Segment)) {
    	DbgLog((LOG_TRACE,1,TEXT("FRC: ERROR-Seek used EC_ENDOFSEGMENT!")));
        m_csFilling.Unlock();
	return E_INVALIDARG;
    }

    // default to current values unless this seek changes them
    // these numbers already include new segment times
    GetCurrentPosition(&rtStart);
    GetStopPosition(&rtStop);

    // figure out where we're seeking to
    DWORD dwFlags = (CurrentFlags & AM_SEEKING_PositioningBitsMask);
    if (dwFlags == AM_SEEKING_AbsolutePositioning) {
	CheckPointer(pCurrent, E_POINTER);
	rtStart = *pCurrent;
    } else if (dwFlags == AM_SEEKING_RelativePositioning) {
	CheckPointer(pCurrent, E_POINTER);
	hr = GetCurrentPosition(&rtStart);
	rtStart += *pCurrent;
    } else if (dwFlags) {
    	DbgLog((LOG_TRACE,1,TEXT("Switch::Invalid Current Seek flags")));
        m_csFilling.Unlock();
	return E_INVALIDARG;
    }

    dwFlags = (StopFlags & AM_SEEKING_PositioningBitsMask);
    if (dwFlags == AM_SEEKING_AbsolutePositioning) {
	CheckPointer(pStop, E_POINTER);
	rtStop = *pStop;
    } else if (dwFlags == AM_SEEKING_RelativePositioning) {
	CheckPointer(pStop, E_POINTER);
	hr = GetStopPosition(&rtStop);
	rtStop += *pStop;
    } else if (dwFlags == AM_SEEKING_IncrementalPositioning) {
	CheckPointer(pStop, E_POINTER);
	hr = GetCurrentPosition(&rtStop);
	rtStop += *pStop;
    }

    // !!! We ignore the seek stop time!

    DbgLog((LOG_TRACE,2,TEXT("Seek BLACK:  Start=%d Stop=%d"),
			(int)(rtStart / 10000), (int)(rtStop / 10000)));

    // flush first, so that our thread won't be blocked delivering
    DeliverBeginFlush();

    // Unlock/Stop so that our thread can wake up and stop without hanging
    m_csFilling.Unlock();
    Stop();

    m_rtStartTime = rtStart;
    m_rtDuration = rtStop - rtStart;
    m_llSamplesSent = 0;

    // now finish flushing
    DeliverEndFlush();

    DeliverNewSegment(rtStart, rtStop, 1.0);
    m_rtNewSeg = rtStart;

    // reset same stuff we reset when we start streaming
    m_bZeroBufCnt = 0;

    // now start the thread up again
    Pause();

    DbgLog((LOG_TRACE,2,TEXT("Completed BLACK seek")));

    return S_OK;
}

STDMETHODIMP
CBlkVidStream::GetPositions(LONGLONG *pCurrent, LONGLONG * pStop)
{
    CheckPointer(pCurrent, E_POINTER);
    CheckPointer(pStop, E_POINTER);
    GetCurrentPosition(pCurrent);
    GetStopPosition(pStop);
    return S_OK;
}

STDMETHODIMP
CBlkVidStream::GetCurrentPosition(LONGLONG *pCurrent)
{
    CheckPointer(pCurrent, E_POINTER);
    *pCurrent = m_rtStartTime + Frame2Time( m_llSamplesSent, m_dOutputFrmRate );
    return S_OK;
}

STDMETHODIMP
CBlkVidStream::GetStopPosition(LONGLONG *pStop)
{
    CheckPointer(pStop, E_POINTER);
    *pStop = m_rtStartTime + m_rtDuration;
    return S_OK;
}

STDMETHODIMP
CBlkVidStream::GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest )
{
    CheckPointer(pEarliest, E_POINTER);
    CheckPointer(pLatest, E_POINTER);
    *pEarliest = 0;
    *pLatest = MAX_TIME;
    return S_OK;
}

STDMETHODIMP
CBlkVidStream::GetDuration( LONGLONG *pDuration )
{
    CheckPointer(pDuration, E_POINTER);
    *pDuration = m_rtDuration;
    return S_OK;
}

STDMETHODIMP
CBlkVidStream::GetRate( double *pdRate )
{
    CheckPointer(pdRate, E_POINTER);
    *pdRate = 1.0;
    return S_OK;
}


STDMETHODIMP
CBlkVidStream::SetRate( double dRate )
{
    if (dRate == 1.0)
	return S_OK;
    ASSERT(FALSE);
    return E_INVALIDARG;
}


/*X* When you make the filter, it always asks for a filename
    because it's based on a file source filter.
    So, solid colour filter support ImportSrcBuffer(), Stillvid filter does not) *X*/
STDMETHODIMP CBlkVidStream::ImportSrcBuffer(const AM_MEDIA_TYPE *pmt, const BYTE *pBuf)
{

    CAutoLock cAutolock(m_pFilter->pStateLock());
    CheckPointer(pBuf, E_POINTER);

    if ( IsConnected() )
	return VFW_E_ALREADY_CONNECTED;

    HRESULT hr = put_MediaType(pmt);
    if (FAILED(hr))
	return hr;

    if( m_pImportBuffer!=NULL )
	delete [] m_pImportBuffer;

    VIDEOINFO *pvi = (VIDEOINFO *) m_mt.Format();
    LONG lSize = pvi->bmiHeader.biSizeImage;

    m_pImportBuffer = new BYTE [lSize ];   //NULL;
    if( !m_pImportBuffer )
    {
        return E_OUTOFMEMORY;
    }

    memcpy(m_pImportBuffer, (PBYTE) pBuf, sizeof(BYTE)*lSize);
    //m_fMediaTypeIsSet = FALSE;
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dasource\dasource.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <ddraw.h>
#include <ddrawex.h>
#include <atlbase.h>
#include "..\idl\qeditint.h"
#include "qedit.h"
#include "dasource.h"

#undef IDABehavior

void __stdcall _com_issue_error(HRESULT)
{
}

void __stdcall _com_issue_errorex(HRESULT, IUnknown*, REFIID) //  throw(_com_error)
{
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// 
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
CUnknown * WINAPI CDASource::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CDASource(lpunk, phr);
    if (punk == NULL) 
    {
        *phr = E_OUTOFMEMORY;
    }
    return punk;

} // CreateInstance


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Constructor
//
// Initialise a CDASourceStream object so that we have a pin.
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
CDASource::CDASource(LPUNKNOWN lpunk, HRESULT *phr)
    : CSource(NAME("DASource"), lpunk, CLSID_DASourcer),
    m_pReaderPin(NULL)
{
    CAutoLock cAutoLock(&m_cStateLock);

    m_paStreams = (CSourceStream **) new CDASourceStream*[1];
    if (m_paStreams == NULL) 
    {
        *phr = E_OUTOFMEMORY;
        return;
    }

    m_paStreams[0] = new CDASourceStream(phr, this, L"DASource!");
    if (m_paStreams[0] == NULL) 
    {
        *phr = E_OUTOFMEMORY;
        return;
    }
} // (Constructor)

CDASource::~CDASource()
{
    if (m_pReaderPin)
        delete m_pReaderPin;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// 
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
STDMETHODIMP CDASource::NonDelegatingQueryInterface( REFIID riid, void ** ppv )
{
    if( riid == IID_IDASource )
    {
        return GetInterface( (IDASource*) this, ppv );
    }
    return CSource::NonDelegatingQueryInterface(riid, ppv);
}


HRESULT CDASource::SetDAImage( IUnknown * pDAImage )
{
    return ((CDASourceStream*) m_paStreams[0])->SetDAImage( pDAImage );
}

HRESULT CDASource::SetParseCallback( IAMParserCallback *pCallback,
                                     REFGUID guidParser)
{
    HRESULT hr = S_OK;
    if (!m_pReaderPin) {
        m_pReaderPin = new CReaderInPin(this, &m_cStateLock, &hr, guidParser, pCallback);
    }

    return hr;
}

HRESULT CDASource::SetImageSize( int width, int height )
{
    ((CDASourceStream*) m_paStreams[0])->m_iImageWidth = width;
    ((CDASourceStream*) m_paStreams[0])->m_iImageHeight = height;

    return S_OK;
}

HRESULT CDASource::SetDuration( REFERENCE_TIME rtDuration )
{
    ((CDASourceStream*) m_paStreams[0])->m_rtDuration = rtDuration;
    ((CDASourceStream*) m_paStreams[0])->m_rtStop = rtDuration;
    
    return S_OK;
}

CReaderInPin::CReaderInPin(CBaseFilter *pFilter,
			   CCritSec *pLock,
			   HRESULT *phr,
			   REFGUID guidSubType,
                           IAMParserCallback *pCallback) :
   CBasePin(NAME("in pin"), pFilter, pLock, phr, L"in", PINDIR_INPUT),
   m_pFilter(pFilter), m_guidSubType(guidSubType), m_pCallback(pCallback), m_pAsyncReader(NULL)
{
}

HRESULT CReaderInPin::CheckMediaType(const CMediaType *pmt)
{
    if (*(pmt->Type()) != MEDIATYPE_Stream)
        return E_INVALIDARG;

    if (*(pmt->Subtype()) != m_guidSubType)
        return E_INVALIDARG;

    return S_OK;
}

// ------------------------------------------------------------------------
// calls the filter to parse the file and create the output pins.

HRESULT CReaderInPin::CompleteConnect(
  IPin *pReceivePin)
{
    HRESULT hr = pReceivePin->QueryInterface(IID_IAsyncReader,
					     (void**)&m_pAsyncReader);
    
    if(FAILED(hr))
	return hr;

    return m_pCallback->ParseNow(m_pAsyncReader);
}

HRESULT CReaderInPin::BreakConnect()
{
    if (m_pAsyncReader) {
	m_pAsyncReader->Release();
	m_pAsyncReader = NULL;
    }

    m_pCallback->ParseNow(NULL);
    
    return CBasePin::BreakConnect();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dasource\dastream.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <ddraw.h>
#include <ddrawex.h>
#include <atlbase.h>
#include "..\idl\qeditint.h"
#include "qedit.h"
#include "dasource.h"
#include "../util/conv.cxx"

const double DEFAULT_FPS = 15.0;
const long DEFAULT_WIDTH = 320;
const long DEFAULT_HEIGHT = 240;

#define DBGLVL 3

//////////////////////////////////////////////////////////////////////////////
// Constructor
//////////////////////////////////////////////////////////////////////////////
//
CDASourceStream::CDASourceStream(HRESULT *phr, CDASource *pParent, LPCWSTR pPinName)
     : CSourceStream(NAME("DASource"),phr, pParent, pPinName)
     , CSourceSeeking( NAME("DASource"), (IPin*) this, phr, &m_SeekLock )
     , m_iImageWidth(DEFAULT_WIDTH)
     , m_iImageHeight(DEFAULT_HEIGHT)
     , m_rtSampleTime( (REFERENCE_TIME) 0 ) // the time that starts at 0 when you start delivering
     , m_bSeeked( false )
     , m_iDelivered( 0 )
     , m_bRecueFromTick( false )
{
    // m_rtDuration is defined as the length of the source clip.
    // we default to the maximum amount of time.
    //
    m_rtDuration = 60*60*24*UNITS; // is one day enough?
    m_rtStop = m_rtDuration;

    // no seeking to absolute pos's and no seeking backwards!
    //
    m_dwSeekingCaps = 
        AM_SEEKING_CanSeekForwards |
        AM_SEEKING_CanGetStopPos |
        AM_SEEKING_CanGetDuration |
        AM_SEEKING_CanSeekAbsolute;

} // (Constructor)


//////////////////////////////////////////////////////////////////////////////
// Destructor
//////////////////////////////////////////////////////////////////////////////
//
CDASourceStream::~CDASourceStream()
{
    freeDA( );
} // (Destructor)

//////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////
//
STDMETHODIMP CDASourceStream::NonDelegatingQueryInterface( REFIID riid, void ** ppv )
{
    if( riid == IID_IMediaSeeking ) 
    {
        return CSourceSeeking::NonDelegatingQueryInterface( riid, ppv );
    }
    return CSourceStream::NonDelegatingQueryInterface(riid, ppv);
}

HRESULT CDASourceStream::ChangeRate( )
{
    if( m_dRateSeeking != 1.0 )
    {
        m_dRateSeeking = 1.0;
        return E_FAIL;
    }
    return NOERROR;
}

//////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////
//
HRESULT CDASourceStream::SetDAImage( IUnknown * pDAImage )
{
    HRESULT hr = pDAImage->QueryInterface( __uuidof(IDAImage), (void**) &m_pFinalImg );
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )
    {
        return hr;
    }
    hr = initDA( );
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
// Notify. Ignore it.
//////////////////////////////////////////////////////////////////////////////
//
STDMETHODIMP CDASourceStream::Notify(IBaseFilter * pSender, Quality q)
{
    return NOERROR;
} // Notify


//////////////////////////////////////////////////////////////////////////////
// GetMediaType. Return RGB32, the only output format this one supports.
//////////////////////////////////////////////////////////////////////////////
//
HRESULT CDASourceStream::GetMediaType(int iPosition, CMediaType *pmt)
{
    if (iPosition < 0) 
    {
        return E_INVALIDARG;
    }

    // Have we run off the end of types

    if( iPosition > 1 ) 
    {
        return VFW_S_NO_MORE_ITEMS;
    }

    VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *) pmt->AllocFormatBuffer( sizeof(VIDEOINFOHEADER) );
    if (NULL == pvi) 
    {
        return(E_OUTOFMEMORY);
    }

    ZeroMemory(pvi, sizeof(VIDEOINFOHEADER));

    switch (iPosition) 
    {
        case 0: 
        {
            pvi->bmiHeader.biCompression = BI_RGB;
            pvi->bmiHeader.biBitCount    = 32;
        }
        break;
    }

    pvi->bmiHeader.biSize         = sizeof(BITMAPINFOHEADER);
    pvi->bmiHeader.biWidth        = m_iImageWidth;
    pvi->bmiHeader.biHeight       = m_iImageHeight;
    pvi->bmiHeader.biPlanes       = 1;
    pvi->bmiHeader.biSizeImage    = GetBitmapSize(&pvi->bmiHeader);
    pvi->bmiHeader.biClrImportant = 0;

    pvi->AvgTimePerFrame = Frame2Time( 1, DEFAULT_FPS );

    SetRectEmpty(&(pvi->rcSource));    // we want the whole image area rendered.
    SetRectEmpty(&(pvi->rcTarget));    // no particular destination rectangle

    pmt->SetType(&MEDIATYPE_Video);
    pmt->SetFormatType(&FORMAT_VideoInfo);
    pmt->SetTemporalCompression(false);

    // Work out the GUID for the subtype from the header info.
    const GUID SubTypeGUID = GetBitmapSubtype(&pvi->bmiHeader);
    pmt->SetSubtype(&SubTypeGUID);
    pmt->SetSampleSize(pvi->bmiHeader.biSizeImage);

    return NOERROR;

} // GetMediaType

//////////////////////////////////////////////////////////////////////////////
// CheckMediaType
//////////////////////////////////////////////////////////////////////////////
//
HRESULT CDASourceStream::CheckMediaType(const CMediaType *pMediaType)
{
    // we only want fixed size video
    //
    if( *(pMediaType->Type()) != MEDIATYPE_Video )
    {
        return E_INVALIDARG;
    }
    if( !pMediaType->IsFixedSize( ) ) 
    {
        return E_INVALIDARG;
    }
    if( *pMediaType->Subtype( ) != MEDIASUBTYPE_RGB32 )
    {
        return E_INVALIDARG;
    }
    if( *pMediaType->FormatType( ) != FORMAT_VideoInfo )
    {
        return E_INVALIDARG;
    }

    // Get the format area of the media type
    //
    VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *) pMediaType->Format();

    if (pvi == NULL)
    {
        return E_INVALIDARG;
    }

    return S_OK;

} // CheckMediaType

//////////////////////////////////////////////////////////////////////////////
// DecideBufferSize
//
// This will always be called after the format has been sucessfully
// negotiated. So we have a look at m_mt to see what size image we agreed.
// Then we can ask for buffers of the correct size to contain them.
//////////////////////////////////////////////////////////////////////////////
//
HRESULT CDASourceStream::DecideBufferSize(IMemAllocator *pAlloc,ALLOCATOR_PROPERTIES *pProperties)
{
    ASSERT(pAlloc);
    ASSERT(pProperties);
    HRESULT hr = NOERROR;

    VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *) m_mt.Format();
    pProperties->cBuffers = 1;
    pProperties->cbBuffer = pvi->bmiHeader.biSizeImage;

    ASSERT(pProperties->cbBuffer);

    // Ask the allocator to reserve us some sample memory, NOTE the function
    // can succeed (that is return NOERROR) but still not have allocated the
    // memory that we requested, so we must check we got whatever we wanted

    ALLOCATOR_PROPERTIES Actual;
    hr = pAlloc->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) 
    {
        return hr;
    }

    // Is this allocator unsuitable

    if (Actual.cbBuffer < pProperties->cbBuffer) 
    {
        return E_FAIL;
    }

    ASSERT( Actual.cBuffers == 1 );

    return NOERROR;

} // DecideBufferSize

HRESULT CDASourceStream::OnThreadStartPlay( )
{
    DeliverNewSegment( m_rtStart, m_rtStop, 1.0 );
    return CSourceStream::OnThreadStartPlay( );
}

//////////////////////////////////////////////////////////////////////////////
// OnThreadCreate
//
// As we go active reset the stream time to zero
//////////////////////////////////////////////////////////////////////////////
//
HRESULT CDASourceStream::OnThreadCreate()
{
    DbgLog( ( LOG_TRACE, DBGLVL, TEXT("DASrc::Thread created") ) );

    // start up DA
    //
    HRESULT hr; 
    if( m_pView )
    {
        hr = m_pView->StartModel( m_pFinalImg, m_pFinalSound, 0 );
        ASSERT( !FAILED( hr ) );
        if( FAILED( hr ) )  
        {
            freeDA( );
            return hr;
        }
    }

    return NOERROR;

} // OnThreadCreate

//////////////////////////////////////////////////////////////////////////////
// OnThreadDestroy
//////////////////////////////////////////////////////////////////////////////
//
HRESULT CDASourceStream::OnThreadDestroy()
{
    DbgLog( ( LOG_TRACE, DBGLVL, TEXT("DASrc::Thread destroyed") ) );

    // stop DA
    //
    HRESULT hr = 0;
    if( m_pView )
    {
        hr = m_pView->StopModel( );
        ASSERT( !FAILED( hr ) );
    }

    return NOERROR;

} // OnThreadCreate

//////////////////////////////////////////////////////////////////////////////
// called from a bunch of places
//////////////////////////////////////////////////////////////////////////////
//
void CDASourceStream::freeDA( )
{
    if( m_pSurfaceBuffer )
    {
        m_pSurfaceBuffer.Release( );
        m_pSurfaceBuffer = NULL;
    }
    if( m_pDirectDraw )
    {
        m_pDirectDraw.Release( );
        m_pDirectDraw = NULL;
    }
    if( m_pView )  
    {
        m_pView->StopModel();
        m_pView.Release();
    }
}

//////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////
//
HRESULT CDASourceStream::initDA( )
{
    HRESULT hr;

    CComPtr<IDirectDrawFactory> pDirectFactory;

    hr = CoCreateInstance(
        CLSID_DirectDrawFactory,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IDirectDrawFactory,
        (void**) &pDirectFactory
        );
    ASSERT( !FAILED( hr ) );

    if( FAILED( hr ) )
    {
        freeDA( );
        return hr;
    }

    hr = pDirectFactory->CreateDirectDraw( NULL, NULL, DDSCL_NORMAL, 0, NULL, &m_pDirectDraw );
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )
    {
        freeDA( );
        return hr;
    }

    hr = m_pDirectDraw->SetCooperativeLevel( NULL, DDSCL_NORMAL );
    ASSERT( !FAILED( hr ) );
    if( hr != DD_OK )
    {
        freeDA( );
        return hr;
    }

    // ********************************************
    //
    // CREATE THE SURFACES
    //
    // ********************************************

    // create the primary surface
    //
    DDSURFACEDESC ddsd;
    memset( &ddsd, 0, sizeof( ddsd ) );
    ddsd.dwSize = sizeof( ddsd );
    ddsd.dwFlags = DDSD_CAPS;
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;

    // create a direct draw surface to hand to DA
    //
    DDPIXELFORMAT PixelFormat;
    memset( &PixelFormat, 0, sizeof( PixelFormat ) );
    PixelFormat.dwSize = sizeof( PixelFormat );
    PixelFormat.dwFlags = DDPF_RGB;
    PixelFormat.dwRGBBitCount = 32;
    PixelFormat.dwRBitMask = 0x00FF0000;
    PixelFormat.dwGBitMask = 0x0000FF00;
    PixelFormat.dwBBitMask = 0x000000FF;
    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY;
    ddsd.dwWidth = m_iImageWidth;
    ddsd.dwHeight = m_iImageHeight;
    ddsd.ddpfPixelFormat = PixelFormat;
    hr = m_pDirectDraw->CreateSurface( &ddsd, &m_pSurfaceBuffer, NULL );
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )
    {
        freeDA( );
        return hr;
    }

    // ********************************************
    //
    // initialize the DXA View
    //
    // ********************************************

    // create a view
    //
    hr = CoCreateInstance(
        __uuidof(DAView), 
        NULL, 
        CLSCTX_INPROC, 
        __uuidof(IDAView), 
        (void**) &m_pView );
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )  
    {
        freeDA( );
        return hr;
    }

    // m_pFinalImg should be valid by now

    // tell the view the DD surface it's outputting to
    //
    hr = m_pView->put_IDirectDrawSurface( m_pSurfaceBuffer );
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )
    {
        freeDA( );
        return hr;
    }

    // uh... tell it to output? I guess?
    //
    hr = m_pView->put_CompositeDirectlyToTarget(true);
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )
    {
        freeDA( );
        return hr;
    }

    return NOERROR;
}

//////////////////////////////////////////////////////////////////////////////
// FillBuffer. This routine fills up the given IMediaSample
//////////////////////////////////////////////////////////////////////////////
//
HRESULT CDASourceStream::FillBuffer(IMediaSample *pms)
{
    HRESULT hr = 0;

    // you NEED to have a lock on the critsec you sent to CSourceSeeking, so
    // it doesn't fill while you're changing positions, because the timestamps
    // won't be right. m_iDelivered will be off.
    //
    CAutoLock Lock( &m_SeekLock );

    DbgLog( ( LOG_TRACE, DBGLVL, TEXT("DASrc::FillBuffer") ) );
    REFERENCE_TIME NextSampleStart = Frame2Time( m_iDelivered++, DEFAULT_FPS );
    m_rtSampleTime = NextSampleStart;
    REFERENCE_TIME NextSampleStop =  Frame2Time( m_iDelivered, DEFAULT_FPS );

    // return S_FALSE if we've hit EOS. Parent class will send EOS for us
    //
    if( NextSampleStart > m_rtStop )
    {
        return S_FALSE;
    }

    // get the buffer and the bits
    //
    DWORD * pData = NULL;
    hr = pms->GetPointer( (BYTE**) &pData );
    long lDataLen = pms->GetSize( );

    if( FAILED( hr ) )
    {
        return hr;
    }

    if( lDataLen == 0 )
    {
        return NOERROR;
    }

    // force DA to update itself
    //
    if( m_pView )
    {
        if( m_bSeeked )
        {
            m_bRecueFromTick = true;

            DbgLog( ( LOG_TRACE, DBGLVL, TEXT("DASrc::tick, must reseek") ) );
            hr = m_pView->StopModel( );
            ASSERT( !FAILED( hr ) );
            // tell the view the DD surface it's outputting to
            //
            hr = m_pView->put_IDirectDrawSurface( m_pSurfaceBuffer );
            ASSERT( !FAILED( hr ) );
            hr = m_pView->put_CompositeDirectlyToTarget(true);
            ASSERT( !FAILED( hr ) );
            hr = m_pView->StartModel( m_pFinalImg, m_pFinalSound, 0 );
            ASSERT( !FAILED( hr ) );
            m_bSeeked = false;

            m_bRecueFromTick = false;
        }

        // calculate the time at which to tell the view to tick
        //
        double thisTime = double( m_rtSampleTime + m_rtStart ) / UNITS;

        DbgLog( ( LOG_TRACE, DBGLVL, TEXT("DASrc::tick to %ld, rtStart = %ld"), long( ( m_rtSampleTime + m_rtStart ) / 10000 ), long( m_rtStart / 10000 ) ) );

        // do the tick
        //
        BOOL render = TRUE;
        hr = m_pView->raw_Tick( thisTime, (short*) &render );
        ASSERT( !FAILED( hr ) );

        // if it didn't work, big deal
        //
        if( !SUCCEEDED( hr ) )
        {
            return hr;
        }

        // if it told us to render, then render!
        // !!! What happens if it didn't tell us to?
        //
        if( render )
        {
            hr = m_pView->Render( );
            ASSERT( !FAILED( hr ) );
        }
    }

    // lock the DA DD surface so we can get at the bits
    //
    RECT rc;
    rc.left = 0;
    rc.top = 0;
    rc.right = m_iImageWidth;   // !!! is this set yet?
    rc.bottom = m_iImageHeight; // !!! is this set yet?
    DDSURFACEDESC SurfaceDesc;
    memset( &SurfaceDesc, 0, sizeof( SurfaceDesc ) );
    SurfaceDesc.dwSize = sizeof( SurfaceDesc );
    hr = m_pSurfaceBuffer->Lock(
        &rc,
        &SurfaceDesc,
        DDLOCK_SURFACEMEMORYPTR | DDLOCK_WAIT,
        NULL );
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )
    {
        return hr;
    }
    
    // get the pointer to the DD's bits
    //
    DWORD * pSurfaceBits = (DWORD*) SurfaceDesc.lpSurface;
    if( !pSurfaceBits )
    {
        return E_POINTER;
    }

    // and go to the end of them, since it's inverted
    //
    pSurfaceBits += ( ( m_iImageWidth * m_iImageHeight ) /* - 1 */ );
    pSurfaceBits -= m_iImageWidth;

    for( int y = m_iImageHeight - 1 ; y >= 0 ; y-- )
    {
        for( int x = m_iImageWidth - 1 ; x >= 0 ; x-- )
        {
            *pData = *pSurfaceBits;
            pData++;
            pSurfaceBits++;
        }
        pSurfaceBits -= ( m_iImageWidth * 2 );
    }

    // free up the DD buffer
    //
    m_pSurfaceBuffer->Unlock( SurfaceDesc.lpSurface );

    ASSERT( m_iDelivered != 0 );

    DbgLog( ( LOG_TRACE, DBGLVL, TEXT("DASrc::FillBuffer, sample = %ld to %ld"), long( NextSampleStart / 10000 ), long( NextSampleStop / 10000 ) ) );

    // set the timestamp
    //
    pms->SetTime( &NextSampleStart, &NextSampleStop );

    // set the sync point
    //
    pms->SetSyncPoint(true);

    return NOERROR;

} // FillBuffer

//////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////
//
HRESULT CDASourceStream::ChangeStart( )
{
    DbgLog( ( LOG_TRACE, DBGLVL, TEXT("DASrc::ChangeStart to %ld"), long( m_rtStart / 10000 ) ) );

    if( m_bRecueFromTick )
    {
        DbgLog( ( LOG_TRACE, DBGLVL, TEXT("DASrc::ChangeStart received during FillBuffer, aborting") ) );
        return 0;
    }

    m_bSeeked = true;
    m_iDelivered = 0;

    if (ThreadExists()) 
    {
	// next time round the loop the worker thread will
	// pick up the position change.
	// We need to flush all the existing data - we must do that here
	// as our thread will probably be blocked in GetBuffer otherwise

        DbgLog( ( LOG_TRACE, DBGLVL, TEXT("DASrc::calling DeliverBeginFlush") ) );
	DeliverBeginFlush();
	// make sure we have stopped pushing
        DbgLog( ( LOG_TRACE, DBGLVL, TEXT("DASrc::calling Stop") ) );
	Stop();
	// complete the flush
        DbgLog( ( LOG_TRACE, DBGLVL, TEXT("DASrc::calling DeliverEndFlush") ) );
	DeliverEndFlush();
	// restart
        DbgLog( ( LOG_TRACE, DBGLVL, TEXT("DASrc::calling Run") ) );
	Run();
    }

    return NOERROR;
}

//////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////
//
HRESULT CDASourceStream::ChangeStop( )
{
    DbgLog( ( LOG_TRACE, DBGLVL, TEXT("DASrc::ChangeStop to %ld"), long( m_rtStop / 10000 ) ) );
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dasource\dasource.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// import danim. These absolute paths are not very good.
//
#if 1
#include "danim.tlh"
#else
//#import <c:\windows\system\danim.dll>
#import <c:\winnt\system32\danim.dll> \
  exclude( "_RemotableHandle", "IMoniker", "IPersist", "ISequentialStream", \
  "IParseDisplayName", "IOleClientSite", "_FILETIME", "tagSTATSTG" ) \
  rename( "GUID", "DAGUID" ) \
  rename_namespace( "DAnim" ) \
  named_guids
#endif
          
using namespace DAnim;

// import the ocx.
//
#import "msscript.ocx" \
  rename_namespace( "ScriptControl" ) \
  named_guids

using namespace ScriptControl;

class CDAScriptParser 
    : public CUnknown
    , public IFileSourceFilter
    , public IPersist
{
    // the filename we're hosting
    //
    WCHAR m_szFilename[_MAX_PATH];
    char                        m_szScript[4096];
    bool                        m_bJScript; // whether we're jscript or not

    IUnknown * m_pAggregateUnk;
    CComPtr<IDAImage>           m_pFinalImg;        // don't quite understand this, but it's needed.
    CComPtr<IDASound>           m_pFinalSound;      // don't quite understand this, but it's needed.

    // required
    //
    DECLARE_IUNKNOWN

    CDAScriptParser( LPUNKNOWN lpunk, HRESULT *phr );
    ~CDAScriptParser( );

    STDMETHODIMP NonDelegatingQueryInterface( REFIID riid, void ** ppv );

    // IFileSourceFilter
    //
    STDMETHODIMP Load( LPCOLESTR pszFileName, const AM_MEDIA_TYPE *pmt );
    STDMETHODIMP GetCurFile( LPOLESTR *ppszFileName, AM_MEDIA_TYPE *pmt );

    // IPersist
    STDMETHODIMP GetClassID( CLSID * pClassId );

    HRESULT init( );
    void free( );
    HRESULT parseScript( );

    //DA ID name
    char    m_sDaID[_MAX_PATH]; 

public:

    // only way to make one of these
    //
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
};

class CDASource;
class CDASourceStream;


// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// input pin

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// input pin. uses IAsyncReader and not IMemInputPin

class CReaderInPin : public CBasePin
{
protected:
    class CBaseFilter* m_pFilter;
    REFGUID m_guidSubType;
    IAsyncReader *m_pAsyncReader;
    IAMParserCallback *m_pCallback;

public:
    CReaderInPin(
		 CBaseFilter *pFilter,
		 CCritSec *pLock,
		 HRESULT *phr,
		 REFGUID guidSubType,
                 IAMParserCallback *pCallback);


    // CBasePin overrides
    HRESULT CheckMediaType(const CMediaType* mtOut);
    HRESULT CompleteConnect(IPin *pReceivePin);
    HRESULT BreakConnect();

    STDMETHODIMP BeginFlush(void) { return E_UNEXPECTED; }
    STDMETHODIMP EndFlush(void) { return E_UNEXPECTED; }
};


class CDASource 
    : public CSource
    , public IDASource
{
protected:

    // the filename we're hosting
    //
    WCHAR m_Filename[_MAX_PATH];
    CReaderInPin *m_pReaderPin;

public:

    // only way to make one of these
    //
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

private:

    // required
    //
    DECLARE_IUNKNOWN
    CDASource(LPUNKNOWN lpunk, HRESULT *phr);
    ~CDASource();
    
    STDMETHODIMP NonDelegatingQueryInterface( REFIID riid, void ** ppv );

    int GetPinCount() { return CSource::GetPinCount() + (m_pReaderPin ? 1 : 0); }
    CBasePin *GetPin(int n)
    {
        if (m_pReaderPin) {
            if (n-- == 0)
                return m_pReaderPin;
        }

        return CSource::GetPin(n);
    }

    // IDASource
    //
    STDMETHODIMP SetDAImage( IUnknown * pDAImage );
    STDMETHODIMP SetParseCallback( IAMParserCallback *pCallback, REFGUID guidParser );
    STDMETHODIMP SetImageSize( int width, int height );
    STDMETHODIMP SetDuration( REFERENCE_TIME rtDuration );
}; // CDASource


// CDASourceStream manages the data flow from the output pin.
//
class CDASourceStream 
    : public CSourceStream
    , public CSourceSeeking
{
    friend CDASource;

public:

    CDASourceStream(HRESULT *phr, CDASource *pParent, LPCWSTR pPinName);
    ~CDASourceStream();
    STDMETHODIMP NonDelegatingQueryInterface( REFIID riid, void ** ppv );

    // fills in the bits for our output frame
    //
    HRESULT FillBuffer(IMediaSample *pms);

    // Ask for buffers of the size appropriate to the agreed media type
    //
    HRESULT DecideBufferSize(IMemAllocator *pIMemAlloc,
                             ALLOCATOR_PROPERTIES *pProperties);

    // negotiate these for the correct output type
    //
    HRESULT CheckMediaType(const CMediaType *pMediaType);
    HRESULT GetMediaType(int iPosition, CMediaType *pmt);

    // Resets the stream time to zero
    //
    HRESULT OnThreadCreate( );
    HRESULT OnThreadDestroy( );
    HRESULT OnThreadStartPlay( );

    // Quality control notifications sent to us. We'll patently ignore them.
    //
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);

    // CSourceSeeking
    //
    HRESULT ChangeStart( );
    HRESULT ChangeStop( );
    HRESULT ChangeRate( );

protected:

    int m_iImageHeight;                    // The current image height
    int m_iImageWidth;                    // And current image width
    int m_iDelivered;                   // how many samples we delivered
    CRefTime m_rtSampleTime;
    CCritSec                    m_SeekLock; // needed for CSourceSeeking

    CComPtr<IDirectDraw>        m_pDirectDraw;      // provides DD services
    CComPtr<IDirectDrawSurface> m_pSurfaceBuffer;   // surface to get bits out of DA
    CComPtr<IDAView>            m_pView;            // our "view" in DA. Needed.
    CComPtr<IDAImage>           m_pFinalImg;        // don't quite understand this, but it's needed.
    CComPtr<IDASound>           m_pFinalSound;      // don't quite understand this, but it's needed.
    bool m_bSeeked;

    void freeDA( );
    HRESULT initDA(  );
    STDMETHODIMP SetDAImage( IUnknown * pDAImage );

    bool m_bRecueFromTick;

}; // CDASourceStream
    
extern const AMOVIESETUP_FILTER sudDASourceax;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dasource\resource.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#define IDS_VERSION                     100
#define IDS_TITLE                       101
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dasource\resrc1.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dasource.rc
//
#define VERSION_RES_MINOR_VER           0
#define VERSION_RES_BUILD               0
#define VER_DEBUG                       0
#define VERSION_RES_MAJOR_VER           1
#define VERSION_RES_LANGUAGE            0x409
#define VERSION_RES_CHARSET             1252

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dasource\setup.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <ddraw.h>
#include <ddrawex.h>
#include <atlbase.h>
#include "..\idl\qeditint.h"
#include "qedit.h"
#include "dasource.h"

const AMOVIESETUP_MEDIATYPE sudOpPinTypes =
{
    &MEDIATYPE_Video,       // Major type
    &MEDIASUBTYPE_NULL      // Minor type
};

const AMOVIESETUP_PIN sudOpPin =
{
    L"Output",              // Pin string name
    false,                  // Is it rendered
    true,                   // Is it an output
    false,                  // Can we have none
    false,                  // Can we have many
    &CLSID_NULL,            // Connects to filter
    NULL,                   // Connects to pin
    1,                      // Number of types
    &sudOpPinTypes };       // Pin details

const AMOVIESETUP_FILTER sudDASourceax =
{
    &CLSID_DAScriptParser,    // Filter CLSID
    L"DAScriptParser",       // String name
    MERIT_DO_NOT_USE,       // Filter merit
    1,                      // Number pins
    &sudOpPin               // Pin details
};

#ifdef FILTER_DLL
#include "qedit_i.c"

// COM global table of objects in this dll

CFactoryTemplate g_Templates[] = {
  { L"DASource"
  , &CLSID_DASourcer
  , CDASource::CreateInstance
  , NULL
  , NULL },
  { L"DAScriptParser"
  , &CLSID_DAScriptParser
  , CDAScriptParser::CreateInstance
  , NULL
  , &sudDASourceax }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);


//
// DllRegisterServer
//
// Exported entry points for registration and unregistration
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( true );

} // DllRegisterServer


//
// DllUnregisterServer
//
STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2( false );

} // DllUnregisterServer
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dasource\scriptobj.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <ddraw.h>
#include <ddrawex.h>
#include <atlbase.h>
#include "..\idl\qeditint.h"
#include "qedit.h"
#include "dasource.h"

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// 
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
CUnknown * WINAPI CDAScriptParser::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CDAScriptParser(lpunk, phr);
    if (punk == NULL) 
    {
        *phr = E_OUTOFMEMORY;
    }
    return punk;

} // CreateInstance


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Constructor
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
CDAScriptParser::CDAScriptParser(LPUNKNOWN lpunk, HRESULT *phr)
    : CUnknown(NAME("DAScriptParser"), lpunk)
    , m_pAggregateUnk( NULL )
{
    HRESULT hr = 0;

    IUnknown * pOwner = GetOwner( );
    ASSERT( pOwner );
    hr = CoCreateInstance( CLSID_DASourcer, pOwner, CLSCTX_INPROC_SERVER, IID_IUnknown, (void**) &m_pAggregateUnk );

    *phr = hr;
}

CDAScriptParser::~CDAScriptParser( )
{
    free( );
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// 
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
STDMETHODIMP CDAScriptParser::NonDelegatingQueryInterface( REFIID riid, void ** ppv )
{
    HRESULT hr = 0;

#if 1
    if( riid == IID_IPersist )
    {
        return GetInterface( (IPersist*) this, ppv );
    }
#endif


    // if we have an aggregate, ask it first if it wants the interface
    //
    if( m_pAggregateUnk && ( riid != IID_IUnknown ) )
    {
        hr = m_pAggregateUnk->QueryInterface( riid, ppv );
        if( hr != E_NOINTERFACE )
        {
            // the unk decided to take it, we're done
            //
            return hr;
        }

        // aggregate didn't like it, so we can ask ourselves!
    }

    if( riid == IID_IFileSourceFilter ) 
    {
        return GetInterface( (IFileSourceFilter*) this, ppv );
    }

    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// 
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
STDMETHODIMP CDAScriptParser::Load( LPCOLESTR pszFileName, const AM_MEDIA_TYPE *pmt )
{
    wcscpy( m_szFilename, pszFileName );
    return init( );
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// 
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
STDMETHODIMP CDAScriptParser::GetCurFile( WCHAR ** ppszFileName, AM_MEDIA_TYPE *pmt )
{
    CheckPointer(ppszFileName, E_POINTER);
    *ppszFileName = NULL;
    if( !m_szFilename )
    {
        return S_FALSE;
    }

    DWORD n = sizeof(WCHAR) * ( 1 + lstrlenW( m_szFilename ) );
    *ppszFileName = (LPOLESTR) CoTaskMemAlloc( n );
    if( !*ppszFileName )
    {
        return E_OUTOFMEMORY;
    }

    CopyMemory( *ppszFileName, m_szFilename, n );

    return NOERROR;
}

HRESULT CDAScriptParser::init( )
{
    HRESULT hr;

    CComPtr<IScriptControl>     m_pScriptControl;   // the script control that parses the html
    CComPtr<IDAViewerControl>   m_pViewerControl;   // this pulls stuff out of the ScriptControl for us.

    hr = CoCreateInstance(
        CLSID_ScriptControl,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IScriptControl,
        (void**) &m_pScriptControl );
    if( FAILED( hr ) )
    {
        ASSERT( !FAILED( hr ) );
        return hr;
    }

    hr = CoCreateInstance(
        __uuidof(DAViewerControl),
        NULL,
        CLSCTX_INPROC_SERVER,
        __uuidof(IDAViewerControl),
        (void**) &m_pViewerControl );
    if( FAILED( hr ) )
    {
        ASSERT( !FAILED( hr ) );
        return hr;
    }

    CComPtr<IDispatch> pDispatch;
    hr = m_pViewerControl->QueryInterface( IID_IDispatch, (void**) &pDispatch );

    // go get the script and parse it
    //
    hr = parseScript( );
    if( FAILED( hr ) )
    {
        return hr;
    }

    USES_CONVERSION;
    WCHAR * BigScript = A2W( m_szScript );
    if( wcslen( BigScript ) < 1 )
    {
        return VFW_E_INVALIDMEDIATYPE;
    }

    // YOU MUST ALLOCATE THE Language STRING! If you just use static ones, things blow up!!!
    //
    WCHAR * ObjName = A2W( m_sDaID );
    BSTR Language;

    if( m_bJScript )
    {
        Language = SysAllocString( L"JScript" );
    }
    else
    {
        Language = SysAllocString( L"VBScript" );
    }
    if( !Language )
    {
        return E_OUTOFMEMORY;
    }

    hr = m_pScriptControl->put_Language( Language );
    if( SUCCEEDED( hr ) )
    {
        hr = m_pScriptControl->put_UseSafeSubset( FALSE );
        ASSERT( !FAILED( hr ) );
    }
    if( SUCCEEDED( hr ) )
    {
        hr = m_pScriptControl->put_AllowUI( FALSE );
        ASSERT( !FAILED( hr ) );
    }
    if( SUCCEEDED( hr ) )
    {
        hr = m_pScriptControl->AddObject( ObjName, pDispatch, TRUE );
        ASSERT( !FAILED( hr ) );
    }
    if( SUCCEEDED( hr ) )
    {
        hr = m_pScriptControl->AddCode( BigScript );
        ASSERT( !FAILED( hr ) );
    }

    SysFreeString( Language );

    if( FAILED( hr ) )
    {
        return hr;
    }

    // grab out the image and stuff it into the aggregated sub-filter
    //
    m_pFinalImg = (IDAImage*) m_pViewerControl->GetImage( );
    m_pFinalSound = (IDASound*) m_pViewerControl->GetSound( );
    if( !m_pFinalImg )
    {
        return VFW_E_INVALIDMEDIATYPE;
    }

    CComPtr<IUnknown> pFinalImgUnk( m_pFinalImg );

    IDASource * pAggregate;
    hr = m_pAggregateUnk->QueryInterface( IID_IDASource, (void**) &pAggregate );
    if( pAggregate )
    {
        hr = pAggregate->SetDAImage( pFinalImgUnk );

        pAggregate->Release( );
    }

    return NOERROR;
}

void CDAScriptParser::free( )
{
    // release only the unknown aggregate. The non-unknown one will call OUR
    // release function! (bad)
    //
    if( m_pAggregateUnk )
    {
        m_pAggregateUnk->Release( );
        m_pAggregateUnk = NULL;
    }
}

STDMETHODIMP CDAScriptParser::GetClassID( CLSID * pClassId )
{
    CheckPointer( pClassId, E_POINTER );
    *pClassId = CLSID_DAScriptParser;
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dasource\parser.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <stdio.h>
#include <ddraw.h>
#include <ddrawex.h>
#include <atlbase.h>
#include "..\idl\qeditint.h"
#include "qedit.h"
#include "dasource.h"

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// 
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
HRESULT CDAScriptParser::parseScript( )
{
    USES_CONVERSION;
    char * shortname = W2A( m_szFilename );
    FILE * pFile = fopen( shortname, "r" );
    if( !pFile )
    {
        return STG_E_FILENOTFOUND;
    }
	
    strcpy(m_sDaID, "");

    char	sTmp[_MAX_PATH]; 
    char	*pDaID = NULL;
    
    char    line[_MAX_PATH];
    char    lineTemp[_MAX_PATH];
    char   width[_MAX_PATH] = "";
    char   height[_MAX_PATH] = "";

    char * head = NULL;
    char * headend = NULL;

    char * begin  = NULL;
    char * begin1 = NULL;
    char * begin2 = NULL;
    char * begin3 = NULL;
    char * begin4 = NULL;
    char * language = NULL;
    char * language1 = NULL;
    char *    end = NULL;
    char * objsizeline = NULL;
    BOOL bSound = FALSE;
    int counter = 0;
    int SurfaceWidth = 0;
    int SurfaceHeight = 0;
    m_szScript[0] = 0;

    while (fgets(line, _MAX_PATH, pFile) != NULL)
    {
        head = strstr(line, "<HEAD");
        //will skip over any scripts in head section
        if(head)
        {
            while (fgets(line, _MAX_PATH, pFile) != NULL)  {
            headend = strstr(line, "</HEAD>");
            if(headend)
                break;
            }
        }

        //find DA control name
	pDaID = strstr(line, "<OBJECT ID=");
	if(pDaID)
	{
	    char *pBegin = strchr(pDaID, '"');
	    pBegin++;
	    char *pEnd  = strchr(pBegin, '"');
	    int cnt = 0;
          
	    while(cnt<(pEnd - pBegin))  
	    {
		strncat( m_sDaID, pBegin+cnt, 1 );
		cnt++;
	    }
	}
        
        objsizeline = strstr(line, "width:");
        if(objsizeline)  {
          char * result = strpbrk( objsizeline, "0123456789" );
          char * endresult = strchr(result, ';');
          while(counter<(endresult - result))  {
            strncat( width, result+counter, 1 );
            counter++;
          }
          result = strpbrk( endresult, "0123456789" );
          endresult = strchr(result, '"');
          counter = 0;
          while(counter<(endresult - result))  {
            strncat( height, result+counter, 1 );
            counter++;
          }
          SurfaceWidth = atoiA(width);
          if(SurfaceWidth <= 0)
            SurfaceWidth = 300;
          SurfaceHeight = atoiA(height);
          if(SurfaceHeight <= 0)
            SurfaceHeight = 300;
        }

        begin = strstr(line, "<SCRIPT");

        if (begin)        // found the start of a <SCRIPT> tag
        {
            strcpy(lineTemp, begin);
            end = strchr(lineTemp, '>');// find the end of the <SCRIPT> tag after the beginning of the <SCRIPT> tag

            language = strstr(lineTemp, "JScript");
            language1 = strstr(lineTemp, "JSCRIPT");
            if((language || language1) && (language < end || language1 < end))
                m_bJScript = true;
            else
                m_bJScript = false;

            end++;        // <- this is the start of our SCRIPT paragraph
            
            if ( *(end + 1) != '\0' )
                strcpy( m_szScript, end ); // copy what's left, if any, of the first line 
            
            // next lines
            while (fgets(line, _MAX_PATH, pFile) != NULL)
            {
                begin = strstr(line, "</SCRIPT>");
                begin1 = strstr(line, "<!--");
                begin2 = strstr(line, "-->");
				
				strcpy( sTmp, m_sDaID );  
          		strcat(sTmp,".Sound"); 
                begin4 = strstr(line, sTmp);

                if(begin4 != NULL)
                  bSound = TRUE;

                strcpy( sTmp, m_sDaID );  
        	if( m_bJScript )
        	  strcat(sTmp,".Start();"); 
                else
        	  strcat(sTmp,".Start()"); 

                begin3 = strstr(line, sTmp);                

                if (begin == line )
                {
                    // found the <\SCRIPT> tag at the beginning of the line
                    // so do nothing and break
                    break;
                }
                else if (begin)
                {
                    *begin = '\0';    // terminate the string leaving off <\SCRIPT>    
                    strcat( m_szScript, line );
                    break;
                }
                else if(!begin1 && !begin2 && !begin3)        // begin is NULL, <\\SCRIPT not found so copy the line,and no HTML Comment tags.
                    strcat( m_szScript, line );
                    // and continue with next line
            } // while

            if(!bSound)  
            {
                strcpy( sTmp, m_sDaID );  
          	if(m_bJScript)
		    strcat(sTmp,".Sound = m.Silence;"); 
                else
            	    strcat(sTmp,".Sound = m.Silence"); 

            	strcat( m_szScript, sTmp );
            }
        }
    } // while

    fclose( pFile );
    pFile = NULL;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\blackkey\dxtmix.h ===
// DxtMix.h : Declaration of the CDxtMix

#ifndef __DxtMix_H_
#define __DxtMix_H_

#ifndef DTBase_h
    #include <DTBase.h>
#endif

#include "resource.h"       // main symbols

#define _BASECOPY_STRING L"Copyright Microsoft Corp. 1998.  Unauthorized duplication of this string is illegal. "

/////////////////////////////////////////////////////////////////////////////
// CDxtMix
class ATL_NO_VTABLE CDxtMix : 
    public CDXBaseNTo1,
    public CComCoClass<CDxtMix, &CLSID_DxtMix>,
    public IDispatchImpl<IDxtMix, &IID_IDxtMix, &LIBID_DXTMIXDLLLib>,
//        public IObjectSafetyImpl2<CDxtMix>,
//        public IPersistStorageImpl<CDxtMix>,
//        public IPersistPropertyBagImpl<CDxtMix>,
    public IOleObjectDXImpl<CDxtMix>
{
    bool m_bInputIsClean;
    bool m_bOutputIsClean;
    DXSAMPLE * m_pInBufA;
    DXSAMPLE * m_pInBufB;
    DXSAMPLE * m_pOutBuf;
    long m_nInputWidth;
    long m_nInputHeight;
    long m_nOutputWidth;
    long m_nOutputHeight;

public:
        DECLARE_POLY_AGGREGATABLE(CDxtMix)
        DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
        DECLARE_REGISTER_DX_TRANSFORM(IDR_DXTMIX, CATID_DXImageTransform)
        DECLARE_GET_CONTROLLING_UNKNOWN()

	CDxtMix();
        ~CDxtMix();

//BEGIN_PROP_MAP(CDxtMix)
//END_PROP_MAP()

BEGIN_COM_MAP(CDxtMix)
        // Block CDXBaseNTo1 IObjectSafety implementation because we
        // aren't safe for scripting
        COM_INTERFACE_ENTRY_NOINTERFACE(IObjectSafety) 
        COM_INTERFACE_ENTRY(IDXEffect)
	COM_INTERFACE_ENTRY(IDxtMix)
	COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
//        COM_INTERFACE_ENTRY(IPersistPropertyBag)
//        COM_INTERFACE_ENTRY(IPersistStorage)
        COM_INTERFACE_ENTRY_DXIMPL(IOleObject)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
END_COM_MAP()

    CComPtr<IUnknown> m_pUnkMarshaler;

    // required for ATL
    BOOL            m_bRequiresSave;

    // CDXBaseNTo1 overrides
    //
    HRESULT WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue );
    HRESULT OnSetup( DWORD dwFlags );
    HRESULT FinalConstruct();

    // our helper function
    //
    HRESULT DoEffect( DXSAMPLE * pOut, DXSAMPLE * pInA, DXSAMPLE * pInB, long Samples );
    HRESULT MakeSureBufAExists( long Samples );
    HRESULT MakeSureBufBExists( long Samples );
    HRESULT MakeSureOutBufExists( long Samples );
    void FreeStuff( );

// IDxtMix
public:
};

#endif //__DxtMix_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\blackkey\dxtmix.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// DxtMix.cpp : Implementation of CDxtMix
#include "stdafx.h"
#include "DxtMixDll.h"
#include "DxtMix.h"

/////////////////////////////////////////////////////////////////////////////
// CDxtMix

CDxtMix::CDxtMix( )
{
    m_ulMaxImageBands = 1;
    m_ulMaxInputs = 2;
    m_ulNumInRequired = 2;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_pInBufA = NULL;
    m_pInBufB = NULL;
    m_pOutBuf = NULL;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;
}

CDxtMix::~CDxtMix( )
{
    FreeStuff( );
}

void CDxtMix::FreeStuff( )
{
    if( m_pInBufA ) delete [] m_pInBufA;
    if( m_pInBufB ) delete [] m_pInBufB;
    if( m_pOutBuf ) delete [] m_pOutBuf;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_pInBufA = NULL;
    m_pInBufB = NULL;
    m_pOutBuf = NULL;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;
}
    
HRESULT CDxtMix::OnSetup( DWORD dwFlags )
{        
    // delete any stored stuff we have, or memory allocated
    //
    FreeStuff( );

    HRESULT hr;
    CDXDBnds InBounds(InputSurface(0), hr);
    m_nInputWidth = InBounds.Width( );
    m_nInputHeight = InBounds.Height( );

    CDXDBnds OutBounds(OutputSurface(), hr );
    m_nOutputWidth = OutBounds.Width( );
    m_nOutputHeight = OutBounds.Height( );

    if( m_nOutputWidth > m_nInputWidth )
    {
        m_nOutputWidth = m_nInputWidth;
    }
    if( m_nOutputHeight > m_nInputHeight )
    {
        m_nOutputHeight = m_nInputHeight;
    }

    return NOERROR;
}

HRESULT CDxtMix::FinalConstruct( )
{
    HRESULT hr;

    m_ulMaxImageBands = 1;
    m_ulMaxInputs = 2;
    m_ulNumInRequired = 2;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_pInBufA = NULL;
    m_pInBufB = NULL;
    m_pOutBuf = NULL;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;

    hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(), &m_pUnkMarshaler.p );
    return hr;
}

HRESULT CDxtMix::WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue )
{
    HRESULT hr = S_OK;
    
    //--- Get input sample access pointer for the requested region.
   
    CComPtr<IDXARGBReadPtr> pInA = NULL;
    CComPtr<IDXARGBReadPtr> pInB = NULL;
    DXSAMPLE * pInBufA = NULL;
    DXSAMPLE * pInBufB = NULL;
    DXNATIVETYPEINFO NativeType;

    // !!! do this
    //
//    ValidateSurfaces();

    long cInputSamples = m_nInputHeight * m_nInputWidth;
    
    hr = InputSurface( 0 )->LockSurface
        (
        NULL, 
        m_ulLockTimeOut, 
        DXLOCKF_READ,
        IID_IDXARGBReadPtr, 
        (void**)&pInA, 
        NULL 
        );
    if( FAILED( hr ) ) 
    {
        return hr;
    }

    DXSAMPLEFORMATENUM Format = pInA->GetNativeType( &NativeType );
    if( ( Format == DXPF_ARGB32 ) )
    {
        pInBufA = pInA->Unpack( NULL, cInputSamples, FALSE );        
    }
    else
    {
        MakeSureBufAExists( cInputSamples );
        pInBufA = m_pInBufA;
        for( int i = 0 ; i < m_nInputHeight ; i ++ )
        {
            pInA->MoveToRow( i );
            pInA->Unpack( pInBufA, m_nInputWidth, FALSE );
            pInBufA += m_nInputWidth;
        }
        pInBufA = m_pInBufA + ( ( m_nInputHeight - 1 ) * m_nInputWidth );
    }
    
    hr = InputSurface( 1 )->LockSurface
        (
        NULL, 
        m_ulLockTimeOut, 
        DXLOCKF_READ,
        IID_IDXARGBReadPtr, 
        (void**)&pInB, 
        NULL 
        );
    if( FAILED( hr ) ) 
    {
        return hr;
    }

    Format = pInB->GetNativeType( &NativeType );
    if( ( Format == DXPF_ARGB32 ) )
    {
        pInBufB = pInB->Unpack( NULL, cInputSamples, FALSE );        
    }
    else
    {
        MakeSureBufBExists( cInputSamples );
        pInBufB = m_pInBufB;
        for( int i = 0 ; i < m_nInputHeight ; i ++ )
        {
            pInB->MoveToRow( i );
            pInB->Unpack( pInBufB, m_nInputWidth, FALSE );
            pInBufB += m_nInputWidth;
        }
        pInBufB = m_pInBufB + ( ( m_nInputHeight - 1 ) * m_nInputWidth );
    }

    // no dithering!

    CComPtr<IDXARGBReadWritePtr> pO;
    hr = OutputSurface()->LockSurface
        (
        &WI.OutputBnds, 
        m_ulLockTimeOut, 
        DXLOCKF_READWRITE,
        IID_IDXARGBReadWritePtr, 
        (void**)&pO, 
        NULL 
        );

    if( FAILED( hr ) ) 
    {
        return hr;
    }

    // output surface may not be the same size as the input surface
    //
    CDXDBnds bnds;
    bnds = WI.DoBnds;        
    long OutWidth = bnds.Width( );
    long OutHeight = bnds.Height( );
    ASSERT( OutWidth == m_nOutputWidth );
    ASSERT( OutHeight == m_nOutputHeight );
    IDXSurface * pOSurface = NULL;
    pO->GetSurface( IID_IDXSurface, (void**) &pOSurface );
    DXBNDS RealOutBnds;
    pOSurface->GetBounds( &RealOutBnds );
    CDXDBnds RealOutBnds2( RealOutBnds );
    long RealOutWidth = RealOutBnds2.Width( );
    long RealOutHeight = RealOutBnds2.Height( );

    if( OutWidth != m_nInputWidth || OutHeight != m_nInputHeight || RealOutWidth != m_nInputWidth || RealOutHeight != m_nInputHeight )
    {
        // we'll do the effect on a buffer that's as big as our
        // inputs, then pack it into the destination
        
        // make sure the buffer's big enough
        //
        MakeSureOutBufExists( cInputSamples );

        // do the effect
        //
        DoEffect( m_pOutBuf, pInBufA, pInBufB, cInputSamples );

        // if the output is bigger than our input, then fill it first
        //
        if( OutHeight > m_nInputHeight || OutWidth > m_nInputWidth )
        {
            RECT rc;
            rc.left = 0;
            rc.top = 0;
            rc.right = OutWidth;
            rc.bottom = OutHeight;
            DXPMSAMPLE FillValue;
            FillValue.Blue = 0;
            FillValue.Red = 0;
            FillValue.Green = 0;
            FillValue.Alpha = 0;
            pO->FillRect( &rc, FillValue, false );
        }

        // need to pack the result into the destination
        //
        DXPACKEDRECTDESC PackedRect;
        RECT rc;
        rc.left = 0;
        rc.top = 0;
        rc.right = OutWidth;
        rc.bottom = OutHeight;
        long HeightDiff = m_nInputHeight - OutHeight;
        long WidthDiff = m_nInputWidth - OutWidth;
        PackedRect.pSamples = (DXBASESAMPLE*) m_pOutBuf;
        if( HeightDiff > 0 )
        {
            PackedRect.pSamples += ((HeightDiff/2)*m_nInputWidth); // adjust for height
        }
        if( WidthDiff > 0 )
        {
            PackedRect.pSamples += (WidthDiff/2);
        }
        PackedRect.bPremult = true;
        PackedRect.rect = rc;
        PackedRect.lRowPadding = WidthDiff;

        pO->PackRect( &PackedRect );

        // we're good, reset the clean flags
        //
        m_bInputIsClean = m_bOutputIsClean = true;
    }
    else
    {
        DXSAMPLE * pOBuf = NULL;
        DXSAMPLEFORMATENUM Format = pO->GetNativeType( &NativeType );
        if( ( Format == DXPF_ARGB32 ) )
        {
            pOBuf = pO->Unpack( NULL, cInputSamples, FALSE );        
        }
        else
        {
            MakeSureOutBufExists( cInputSamples );
            pOBuf = m_pOutBuf;
            for( int i = 0 ; i < m_nInputHeight ; i ++ )
            {
                pO->MoveToRow( i );
                pO->Unpack( pOBuf, m_nInputWidth, FALSE );
                pOBuf += m_nInputWidth;
            }
            pOBuf = m_pOutBuf + ( ( m_nInputHeight - 1 ) * m_nInputWidth );
        }

        // we're good, reset the clean flags
        //
        m_bInputIsClean = m_bOutputIsClean = true;

        // do the actual effect
        //
        DoEffect( pOBuf, pInBufA, pInBufB, cInputSamples );

        if( Format != DXPF_ARGB32 )
        {
            // need to pack the result into the destination
            //
            DXPACKEDRECTDESC PackedRect;
            RECT rc;
            rc.left = 0;
            rc.top = 0;
            rc.right = OutWidth;
            rc.bottom = OutHeight;
            PackedRect.pSamples = (DXBASESAMPLE*) m_pOutBuf;
            PackedRect.bPremult = true;
            PackedRect.rect = rc;
            PackedRect.lRowPadding = 0;

            pO->PackRect( &PackedRect );
        }
    }

    return S_OK;
}

HRESULT CDxtMix::MakeSureBufAExists( long Samples )
{
    if( m_pInBufA )
    {
        return NOERROR;
    }
    m_pInBufA = new DXSAMPLE[ Samples ];
    if( !m_pInBufA )
    {
        return E_OUTOFMEMORY;
    }
    return NOERROR;
}

HRESULT CDxtMix::MakeSureBufBExists( long Samples )
{
    if( m_pInBufB )
    {
        return NOERROR;
    }
    m_pInBufB = new DXSAMPLE[ Samples ];
    if( !m_pInBufB )
    {
        return E_OUTOFMEMORY;
    }
    return NOERROR;
}

HRESULT CDxtMix::MakeSureOutBufExists( long Samples )
{
    if( m_pOutBuf )
    {
        return NOERROR;
    }
    m_pOutBuf = new DXSAMPLE[ Samples ];
    if( !m_pOutBuf )
    {
        return E_OUTOFMEMORY;
    }
    return NOERROR;
}

HRESULT CDxtMix::DoEffect( DXSAMPLE * pOut, DXSAMPLE * pInA, DXSAMPLE * pInB, long Samples )
{
    for( int x = 0 ; x < m_nInputWidth ; x++ )
    {
        for( int y = 0 ; y < m_nInputHeight ; y++ )
        {
            DXSAMPLE * pA = pInA + ( -y * m_nInputWidth ) + ( m_nInputWidth - x - 1 );
            DXSAMPLE * pB = pInB + ( -y * m_nInputWidth ) + ( m_nInputWidth - x - 1 );
            DXSAMPLE * pO = pOut + ( -y * m_nInputWidth ) + ( m_nInputWidth - x - 1 );

            if( ( pB->Red > 1 ) && ( pB->Green > 1 ) && ( pB->Blue > 1 ) )
            {
                *pO = *pB;
            }
            else
            {
                *pO = *pA;
            }
        }
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\blackkey\resource.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DxtMixDll.rc
//
#define IDS_PROJNAME                    100
#define IDR_DXTMIX                      101
#define IDS_TITLEDxtMixPP               102
#define IDS_HELPFILEDxtMixPP            103
#define IDS_DOCSTRINGDxtMixPP           104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         205
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\bluekey\bluekeydll.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// DxtBlnd1Dll.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f DxtBlnd1Dllps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
    #include "DxtBlnd1Dll.h"
    #include "DxtBlnd1Dll_i.c"
    #include "DxtBlnd1.h"

#include <dxtguid.c>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_DxtBlnd1, CDxtBlnd1)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_DxtBlnd1DLLLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\blackkey\stdafx.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <dtbase.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\blackkey\dxtmixdll.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// DxtMixDll.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f DxtMixDllps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
    #include "DxtMixDll.h"
    #include "DxtMixDll_i.c"
    #include "DxtMix.h"

#include <dxtguid.c>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_DxtMix, CDxtMix)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_DXTMIXDLLLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\bluekey\stdafx.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <dtbase.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\blackkey\stdafx.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_)
#define AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED
#define _ATL_STATIC_REGISTRY

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
//
//  To allow us to compile with warning level 4, we need to disable
//  three warnings that ATLCTL generates at this warning level.
//
#pragma warning(disable: 4510 4610 4100)
#include <atlctl.h>
#pragma warning(default: 4510 4610 4100)
#include <DXTmpl.h>
#include <streams.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\bluekey\stdafx.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_)
#define AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED
#define _ATL_STATIC_REGISTRY

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
//
//  To allow us to compile with warning level 4, we need to disable
//  three warnings that ATLCTL generates at this warning level.
//
#pragma warning(disable: 4510 4610 4100)
#include <atlctl.h>
#pragma warning(default: 4510 4610 4100)
#include <DXTmpl.h>
#include <streams.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\bluekey\bluekeydll.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Mon Feb 08 18:17:25 1999
 */
/* Compiler settings for E:\quartz\filterus\dexter\DxtBlnd1\DxtBlnd1Dll.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __DxtBlnd1Dll_h__
#define __DxtBlnd1Dll_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IDxtBlnd1_FWD_DEFINED__
#define __IDxtBlnd1_FWD_DEFINED__
typedef interface IDxtBlnd1 IDxtBlnd1;
#endif 	/* __IDxtBlnd1_FWD_DEFINED__ */


#ifndef __DxtBlnd1_FWD_DEFINED__
#define __DxtBlnd1_FWD_DEFINED__

#ifdef __cplusplus
typedef class DxtBlnd1 DxtBlnd1;
#else
typedef struct DxtBlnd1 DxtBlnd1;
#endif /* __cplusplus */

#endif 	/* __DxtBlnd1_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "dxtrans.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IDxtBlnd1_INTERFACE_DEFINED__
#define __IDxtBlnd1_INTERFACE_DEFINED__

/* interface IDxtBlnd1 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDxtBlnd1;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("68F3E0A0-BFBB-11d2-8D34-00A0C9441E20")
    IDxtBlnd1 : public IDXEffect
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDxtBlnd1Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDxtBlnd1 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDxtBlnd1 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDxtBlnd1 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDxtBlnd1 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDxtBlnd1 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDxtBlnd1 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDxtBlnd1 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDxtBlnd1 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDxtBlnd1 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDxtBlnd1 __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDxtBlnd1 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDxtBlnd1 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDxtBlnd1 __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } IDxtBlnd1Vtbl;

    interface IDxtBlnd1
    {
        CONST_VTBL struct IDxtBlnd1Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDxtBlnd1_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDxtBlnd1_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDxtBlnd1_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDxtBlnd1_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDxtBlnd1_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDxtBlnd1_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDxtBlnd1_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDxtBlnd1_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDxtBlnd1_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDxtBlnd1_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDxtBlnd1_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDxtBlnd1_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDxtBlnd1_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDxtBlnd1_INTERFACE_DEFINED__ */



#ifndef __DxtBlnd1DLLLib_LIBRARY_DEFINED__
#define __DxtBlnd1DLLLib_LIBRARY_DEFINED__

/* library DxtBlnd1DLLLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DxtBlnd1DLLLib;

EXTERN_C const CLSID CLSID_DxtBlnd1;

#ifdef __cplusplus

class DECLSPEC_UUID("68F3E0A4-BFBB-11d2-8D34-00A0C9441E20")
DxtBlnd1;
#endif
#endif /* __DxtBlnd1DLLLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\bluekey\dxtblnd1.h ===
// DxtBlnd1.h : Declaration of the CDxtBlnd1

#ifndef __DxtBlnd1_H_
#define __DxtBlnd1_H_

#ifndef DTBase_h
    #include <DTBase.h>
#endif

#include "resource.h"       // main symbols

#define _BASECOPY_STRING L"Copyright Microsoft Corp. 1998.  Unauthorized duplication of this string is illegal. "

/////////////////////////////////////////////////////////////////////////////
// CDxtBlnd1
class ATL_NO_VTABLE CDxtBlnd1 : 
    public CDXBaseNTo1,
    public CComCoClass<CDxtBlnd1, &CLSID_DxtBlnd1>,
    public IDispatchImpl<IDxtBlnd1, &IID_IDxtBlnd1, &LIBID_DxtBlnd1DLLLib>,
    public IOleObjectDXImpl<CDxtBlnd1>
{
    bool m_bInputIsClean;
    bool m_bOutputIsClean;
    DXSAMPLE * m_pInBufA;
    DXSAMPLE * m_pInBufB;
    DXSAMPLE * m_pOutBuf;
    long m_nInputWidth;
    long m_nInputHeight;
    long m_nOutputWidth;
    long m_nOutputHeight;

public:
        DECLARE_POLY_AGGREGATABLE(CDxtBlnd1)
        DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
        DECLARE_REGISTER_DX_TRANSFORM(IDR_DxtBlnd1, CATID_DXImageTransform)
        DECLARE_GET_CONTROLLING_UNKNOWN()

	CDxtBlnd1();
        ~CDxtBlnd1();

//BEGIN_PROP_MAP(CDxtBlnd1)
//END_PROP_MAP()

BEGIN_COM_MAP(CDxtBlnd1)
        // Block CDXBaseNTo1 IObjectSafety implementation because we
        // aren't safe for scripting
        COM_INTERFACE_ENTRY_NOINTERFACE(IObjectSafety) 
        COM_INTERFACE_ENTRY(IDXEffect)
	COM_INTERFACE_ENTRY(IDxtBlnd1)
	COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
        COM_INTERFACE_ENTRY_DXIMPL(IOleObject)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
END_COM_MAP()

    CComPtr<IUnknown> m_pUnkMarshaler;

    // required for ATL
    BOOL            m_bRequiresSave;

    // CDXBaseNTo1 overrides
    //
    HRESULT WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue );
    HRESULT OnSetup( DWORD dwFlags );
    HRESULT FinalConstruct();

    // our helper function
    //
    HRESULT DoEffect( DXSAMPLE * pOut, DXSAMPLE * pInA, DXSAMPLE * pInB, long Samples );
    HRESULT MakeSureBufAExists( long Samples );
    HRESULT MakeSureBufBExists( long Samples );
    HRESULT MakeSureOutBufExists( long Samples );
    void FreeStuff( );

// IDxtBlnd1
public:
};

#endif //__DxtBlnd1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\bluekey\dxtblnd1.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// DxtBlnd1.cpp : Implementation of CDxtBlnd1
#include "stdafx.h"
#include "DxtBlnd1Dll.h"
#include "DxtBlnd1.h"
#include <math.h>

/////////////////////////////////////////////////////////////////////////////
// CDxtBlnd1

double mCos[360];
double mSin[360];

void RGB_TO_HSV( const DXPMSAMPLE& rgb, int &conex, int &coney, int &val )
{
    int hue, sat;

    int colMax    = max( max( rgb.Red, rgb.Green ), rgb.Blue );
    int colMin    = min( min( rgb.Red, rgb.Green ), rgb.Blue );

    val = colMax;
    
    // ------------------------------------------------
    // check for super black

    if( colMax == 0 )
    {
        hue = 0;
        sat = 0;
    }
    else
    {
        double delta = colMax - colMin;

        sat = delta * 50 / colMax;

        // for color matching purposes, multiply the sat by the value to account for black hole apex
        //
        sat *= val;
        sat /= 256;

        delta /= 60.0;
        
        // ------------------------------------------------
        // check for no saturation
        
        if( delta == 0.0 )
        {
            hue = 0;
        }
        else if( rgb.Red == colMax )
        {
            // will give us value between 0 and 2
            hue =    000.0 + double( rgb.Green - rgb.Blue ) / delta; // we're mostly red
        }
        else if( rgb.Green == colMax )
        {
            // will give us value between 0 and 2
            hue = 120.0 + double( rgb.Blue - rgb.Red )   / delta; // we're mostly green
        }
        else if( rgb.Blue == colMax )
        {
            // will give us value between 0 and 2
            hue = 240.0 + double( rgb.Red - rgb.Green )  / delta; // we're mostly blue
        }
        else
        {
            ASSERT( 0 );
        }
        
        if( hue < 0 )
        {
            hue += 360;
        }
    }

    // conex and y can be from -50 to 50
    //
    conex = sat * mCos[hue%360];
    coney = sat * mSin[hue%360];
}

CDxtBlnd1::CDxtBlnd1( )
{
    m_ulMaxImageBands = 1;
    m_ulMaxInputs = 2;
    m_ulNumInRequired = 2;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_pInBufA = NULL;
    m_pInBufB = NULL;
    m_pOutBuf = NULL;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;
    for( int i = 0 ; i < 360 ; i++ )
    {
        mCos[i] = cos( 3.14159 * 2 * i / 360 );
        mSin[i] = sin( 3.14159 * 2 * i / 360 );
    }
}

CDxtBlnd1::~CDxtBlnd1( )
{
    FreeStuff( );
}

void CDxtBlnd1::FreeStuff( )
{
    if( m_pInBufA ) delete [] m_pInBufA;
    if( m_pInBufB ) delete [] m_pInBufB;
    if( m_pOutBuf ) delete [] m_pOutBuf;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_pInBufA = NULL;
    m_pInBufB = NULL;
    m_pOutBuf = NULL;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;
}
    
HRESULT CDxtBlnd1::OnSetup( DWORD dwFlags )
{        
    // delete any stored stuff we have, or memory allocated
    //
    FreeStuff( );

    HRESULT hr;
    CDXDBnds InBounds(InputSurface(0), hr);
    m_nInputWidth = InBounds.Width( );
    m_nInputHeight = InBounds.Height( );

    CDXDBnds OutBounds(OutputSurface(), hr );
    m_nOutputWidth = OutBounds.Width( );
    m_nOutputHeight = OutBounds.Height( );

    if( m_nOutputWidth > m_nInputWidth )
    {
        m_nOutputWidth = m_nInputWidth;
    }
    if( m_nOutputHeight > m_nInputHeight )
    {
        m_nOutputHeight = m_nInputHeight;
    }

    return NOERROR;
}

HRESULT CDxtBlnd1::FinalConstruct( )
{
    HRESULT hr;

    m_ulMaxImageBands = 1;
    m_ulMaxInputs = 2;
    m_ulNumInRequired = 2;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_pInBufA = NULL;
    m_pInBufB = NULL;
    m_pOutBuf = NULL;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;

    hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(), &m_pUnkMarshaler.p );
    return hr;
}

HRESULT CDxtBlnd1::MakeSureBufAExists( long Samples )
{
    if( m_pInBufA )
    {
        return NOERROR;
    }
    m_pInBufA = new DXSAMPLE[ Samples ];
    if( !m_pInBufA )
    {
        return E_OUTOFMEMORY;
    }
    return NOERROR;
}

HRESULT CDxtBlnd1::MakeSureBufBExists( long Samples )
{
    if( m_pInBufB )
    {
        return NOERROR;
    }
    m_pInBufB = new DXSAMPLE[ Samples ];
    if( !m_pInBufB )
    {
        return E_OUTOFMEMORY;
    }
    return NOERROR;
}

HRESULT CDxtBlnd1::MakeSureOutBufExists( long Samples )
{
    if( m_pOutBuf )
    {
        return NOERROR;
    }
    m_pOutBuf = new DXSAMPLE[ Samples ];
    if( !m_pOutBuf )
    {
        return E_OUTOFMEMORY;
    }
    return NOERROR;
}

HRESULT CDxtBlnd1::WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue )
{
    HRESULT hr = S_OK;

    //--- Get input sample access pointer for the requested region.
    //    Note: Lock may fail due to a lost surface.
    CComPtr<IDXARGBReadPtr> pInA;
    hr = InputSurface( 0 )->LockSurface( &WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                         IID_IDXARGBReadPtr, (void**)&pInA, NULL );
    if( FAILED( hr ) ) return hr;

    CComPtr<IDXARGBReadPtr> pInB;
    hr = InputSurface( 1 )->LockSurface( &WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                         IID_IDXARGBReadPtr, (void**)&pInB, NULL );
    if( FAILED( hr ) ) return hr;


    //--- Put a write lock only on the region we are updating so multiple
    //    threads don't conflict.
    //    Note: Lock may fail due to a lost surface.
    CComPtr<IDXARGBReadWritePtr> pOut;
    hr = OutputSurface()->LockSurface( &WI.OutputBnds, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                       IID_IDXARGBReadWritePtr, (void**)&pOut, NULL );
    if( FAILED( hr ) ) return hr;

    //--- Allocate a working buffer
    ULONG Width = WI.DoBnds.Width();
    ULONG Height = WI.DoBnds.Height();

    // allocate a scratch buffer fer us
    //
    DXPMSAMPLE *pOverlayBuffer = DXPMSAMPLE_Alloca( Width );
    DXPMSAMPLE *pScratchBuffer = DXPMSAMPLE_Alloca( Width );
    DXSAMPLE   *pChromaBuffer =  DXSAMPLE_Alloca( Width );

    // no dithering
    //
    if (DoDither())
    {
        return 0;
    }

    long t1 = timeGetTime( );

    for( ULONG OutY = 0 ; OutY < Height ; ++OutY )
    {
        ULONG i;

        // copy background row into dest row
        //
        pOut->MoveToRow( OutY );
        pOut->CopyAndMoveBoth( (DXBASESAMPLE*) pScratchBuffer, pInA, Width, FALSE );
        pOut->MoveToRow( OutY );

        pInB->MoveToXY( 0, OutY );

        // unpack the overlay and what the heck, the original values, too.
        //
        pInB->UnpackPremult( pOverlayBuffer, Width, FALSE );
        pInB->Unpack( pChromaBuffer, Width, FALSE );

        float Percent = 1.0;
        get_Progress( &Percent );

        // convert the src's blue bits into an alpha value
        //
        for( i = 0; i < Width ; ++i )
        {
            long rb = pChromaBuffer[i].Blue - pChromaBuffer[i].Red;
            long gb = pChromaBuffer[i].Blue - pChromaBuffer[i].Green;

            if( rb > 30 || gb > 30 )
            {
                if( rb > 70 || gb > 70 )
                {
                    // completely transparent!
                    //
                    pOverlayBuffer[i].Red = 0;
                    pOverlayBuffer[i].Green = 0;
                    pOverlayBuffer[i].Blue = 0;
                    pOverlayBuffer[i].Alpha = 0;
                }
                else
                {
                    double T = 1.0;

                    // do a quick search left or right to see if we find more blue
                    //
                    bool found = false;
                    if( ( i > 11 ) && ( i < ( Width - 11 ) ) )
                    {
                        for( int j = i - 10 ; j < i + 10 ; j++ )
                        {
                            long rb = pChromaBuffer[j].Blue - pChromaBuffer[j].Red;
                            long gb = pChromaBuffer[j].Blue - pChromaBuffer[j].Green;
                            if( rb > 70 && gb > 70 )
                            {
                                found = true;
                            }
                        }
                    }
                    if( found )
                    {
                        // vary the transparency of the colors based on how
                        // much blue is left
                    
                        // first subtract off the blue itself, it's at least 70 above something
                        //
                        pOverlayBuffer[i].Blue -= 70;

                        // the rest of the blue's value determines how transparent everything
                        // else is. Blue is from 0 to 185. The MORE blue we have, the more transparent it should be.

                        T = ( 185.0 - pOverlayBuffer[i].Blue ) / 185.0;

                        T /= 3.0;

                    }

                    pOverlayBuffer[i].Red *= T;
                    pOverlayBuffer[i].Green *= T;
                    pOverlayBuffer[i].Blue *= T;
                    pOverlayBuffer[i].Alpha *= T;
                }
            }

            // vary the amount of foreground based on the progress.
            //
            pOverlayBuffer[i].Red *= Percent;
            pOverlayBuffer[i].Green *= Percent;
            pOverlayBuffer[i].Blue *= Percent;
            pOverlayBuffer[i].Alpha *= Percent;

        } // for i

        // blend the src (B) back into the destination
        //
        pOut->OverArrayAndMove( pScratchBuffer, pOverlayBuffer, Width );

    } // End for

    long t2 = timeGetTime( );

    long t3 = t2 - t1;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\colfilter\stdafx.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_)
#define AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED
#define _ATL_STATIC_REGISTRY

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
//
//  To allow us to compile with warning level 4, we need to disable
//  three warnings that ATLCTL generates at this warning level.
//
#pragma warning(disable: 4510 4610 4100)
#include <atlctl.h>
#pragma warning(default: 4510 4610 4100)
#include <DXTmpl.h>
#include <streams.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\colfilter\stdafx.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <dtbase.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\bluekey\resource.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DxtBlnd1Dll.rc
//
#define IDS_PROJNAME                    100
#define IDR_DxtBlnd1                    101
#define IDS_TITLEDxtBlnd1PP             102
#define IDS_HELPFILEDxtBlnd1PP          103
#define IDS_DOCSTRINGDxtBlnd1PP         104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         205
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\bluekey\dxtblnd1dll.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Mon Feb 08 18:17:25 1999
 */
/* Compiler settings for E:\quartz\filterus\dexter\DxtBlnd1\DxtBlnd1Dll.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __DxtBlnd1Dll_h__
#define __DxtBlnd1Dll_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IDxtBlnd1_FWD_DEFINED__
#define __IDxtBlnd1_FWD_DEFINED__
typedef interface IDxtBlnd1 IDxtBlnd1;
#endif 	/* __IDxtBlnd1_FWD_DEFINED__ */


#ifndef __DxtBlnd1_FWD_DEFINED__
#define __DxtBlnd1_FWD_DEFINED__

#ifdef __cplusplus
typedef class DxtBlnd1 DxtBlnd1;
#else
typedef struct DxtBlnd1 DxtBlnd1;
#endif /* __cplusplus */

#endif 	/* __DxtBlnd1_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "dxtrans.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IDxtBlnd1_INTERFACE_DEFINED__
#define __IDxtBlnd1_INTERFACE_DEFINED__

/* interface IDxtBlnd1 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDxtBlnd1;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("68F3E0A0-BFBB-11d2-8D34-00A0C9441E20")
    IDxtBlnd1 : public IDXEffect
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDxtBlnd1Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDxtBlnd1 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDxtBlnd1 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDxtBlnd1 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDxtBlnd1 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDxtBlnd1 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDxtBlnd1 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDxtBlnd1 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDxtBlnd1 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDxtBlnd1 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDxtBlnd1 __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDxtBlnd1 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDxtBlnd1 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDxtBlnd1 __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } IDxtBlnd1Vtbl;

    interface IDxtBlnd1
    {
        CONST_VTBL struct IDxtBlnd1Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDxtBlnd1_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDxtBlnd1_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDxtBlnd1_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDxtBlnd1_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDxtBlnd1_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDxtBlnd1_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDxtBlnd1_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDxtBlnd1_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDxtBlnd1_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDxtBlnd1_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDxtBlnd1_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDxtBlnd1_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDxtBlnd1_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDxtBlnd1_INTERFACE_DEFINED__ */



#ifndef __DxtBlnd1DLLLib_LIBRARY_DEFINED__
#define __DxtBlnd1DLLLib_LIBRARY_DEFINED__

/* library DxtBlnd1DLLLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DxtBlnd1DLLLib;

EXTERN_C const CLSID CLSID_DxtBlnd1;

#ifdef __cplusplus

class DECLSPEC_UUID("68F3E0A4-BFBB-11d2-8D34-00A0C9441E20")
DxtBlnd1;
#endif
#endif /* __DxtBlnd1DLLLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\colfilter\colgen.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// Colgen.cpp : Implementation of CColgen
#include "stdafx.h"
#include "ColgenDll.h"
#include "Colgen.h"

/////////////////////////////////////////////////////////////////////////////
// CColgen

CColgen::CColgen( )
{
    m_ulMaxImageBands = 1;
    m_ulMaxInputs = 1;
    m_ulNumInRequired = 1;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_pOutBuf = NULL;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;
    m_cFilterBlue = 0;
    m_cFilterGreen = 0;
    m_cFilterRed = 255;
}

CColgen::~CColgen( )
{
    FreeStuff( );
}

void CColgen::FreeStuff( )
{
    if( m_pOutBuf ) delete [] m_pOutBuf;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_pOutBuf = NULL;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;
}
    
HRESULT CColgen::OnSetup( DWORD dwFlags )
{        
    // delete any stored stuff we have, or memory allocated
    //
    FreeStuff( );

    HRESULT hr;
    CDXDBnds InBounds(InputSurface(0), hr);
    m_nInputWidth = InBounds.Width( );
    m_nInputHeight = InBounds.Height( );

    CDXDBnds OutBounds(OutputSurface(), hr );
    m_nOutputWidth = OutBounds.Width( );
    m_nOutputHeight = OutBounds.Height( );

    if( m_nOutputWidth > m_nInputWidth )
    {
        m_nOutputWidth = m_nInputWidth;
    }
    if( m_nOutputHeight > m_nInputHeight )
    {
        m_nOutputHeight = m_nInputHeight;
    }

    return NOERROR;
}

HRESULT CColgen::FinalConstruct( )
{
    HRESULT hr;

    m_ulMaxImageBands = 1;
    m_ulMaxInputs = 1;
    m_ulNumInRequired = 1;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_pOutBuf = NULL;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;

    hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(), &m_pUnkMarshaler.p );
    return hr;
}

HRESULT CColgen::MakeSureOutBufExists( long Samples )
{
    if( m_pOutBuf )
    {
        return NOERROR;
    }
    m_pOutBuf = new DXSAMPLE[ Samples ];
    if( !m_pOutBuf )
    {
        return E_OUTOFMEMORY;
    }
    return NOERROR;
}

HRESULT CColgen::WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue )
{
    HRESULT hr = S_OK;

    //--- Get input sample access pointer for the requested region.
    //    Note: Lock may fail due to a lost surface.
    CComPtr<IDXARGBReadPtr> pInA;
    hr = InputSurface( 0 )->LockSurface( &WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                         IID_IDXARGBReadPtr, (void**)&pInA, NULL );

    //--- Put a write lock only on the region we are updating so multiple
    //    threads don't conflict.
    //    Note: Lock may fail due to a lost surface.
    CComPtr<IDXARGBReadWritePtr> pOut;
    hr = OutputSurface()->LockSurface( &WI.OutputBnds, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                       IID_IDXARGBReadWritePtr, (void**)&pOut, NULL );
    if( FAILED( hr ) ) return hr;

    //--- Allocate a working buffer
    ULONG Width = WI.DoBnds.Width();
    ULONG Height = WI.DoBnds.Height();

    // allocate a scratch buffer fer us
    //
    DXPMSAMPLE *pOverlayBuffer = DXPMSAMPLE_Alloca( Width );
    DXPMSAMPLE *pScratchBuffer = DXPMSAMPLE_Alloca( Width );

    // no dithering
    //
    if (DoDither())
    {
        return 0;
    }

    long t1 = timeGetTime( );

    float Percent = 1.0;
    get_Progress( &Percent );

    for( ULONG OutY = 0 ; OutY < Height ; ++OutY )
    {
        ULONG i;

        // copy background row into dest row
        //
        pInA->MoveToRow( OutY );
        pInA->UnpackPremult( pOverlayBuffer, Width, FALSE );

        pOut->MoveToRow( OutY );

        // convert the src's blue bits into an alpha value
        //
        for( i = 0; i < Width ; ++i )
        {
            long avg = ( pOverlayBuffer[i].Green + pOverlayBuffer[i].Blue + pOverlayBuffer[i].Red ) / 3;
            pOverlayBuffer[i].Green = avg * m_cFilterGreen / 255;
            pOverlayBuffer[i].Blue = avg * m_cFilterBlue / 255;
            pOverlayBuffer[i].Red = avg * m_cFilterRed / 255;
            pOverlayBuffer[i].Alpha = 0;
        } // for i

        // blend the src (B) back into the destination
        //
        pOut->PackPremultAndMove( pOverlayBuffer, Width );

    } // End for

    long t2 = timeGetTime( );

    long t3 = t2 - t1;

    return hr;
}


STDMETHODIMP CColgen::get_FilterColor(long *pVal)
{
    DXPMSAMPLE * pSample = (DXPMSAMPLE*) pVal;
    pSample->Blue = m_cFilterBlue;
    pSample->Green = m_cFilterGreen;
    pSample->Red = m_cFilterRed;
    pSample->Alpha = 0;

    return NOERROR;
}

STDMETHODIMP CColgen::put_FilterColor(long newVal)
{
    long * pVal = &newVal;
    DXPMSAMPLE * pSample = (DXPMSAMPLE*) pVal;

    m_cFilterBlue = pSample->Blue;
    m_cFilterGreen = pSample->Green;
    m_cFilterRed = pSample->Red;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\colfilter\resource.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Colgendll.rc
//
#define IDS_PROJNAME                    100
#define IDR_Colgen                     101
#define IDS_TITLEColgenPP              102
#define IDS_HELPFILEColgenPP           103
#define IDS_DOCSTRINGColgenPP          104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         205
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\colfilter\colgen.h ===
// Colgen.h : Declaration of the CColgen

#ifndef __Colgen_H_
#define __Colgen_H_

#ifndef DTBase_h
    #include <DTBase.h>
#endif

#include "resource.h"       // main symbols

#define _BASECOPY_STRING L"Copyright Microsoft Corp. 1998.  Unauthorized duplication of this string is illegal. "

/////////////////////////////////////////////////////////////////////////////
// CColgen
class ATL_NO_VTABLE CColgen : 
    public CDXBaseNTo1,
    public CComCoClass<CColgen, &CLSID_ColorGenerator>,
    public IDispatchImpl<IColorGenerator, &IID_IColorGenerator, &LIBID_ColgenDLLLib>,
    public IOleObjectDXImpl<CColgen>
{
    bool m_bInputIsClean;
    bool m_bOutputIsClean;
    DXSAMPLE * m_pOutBuf;
    long m_nInputWidth;
    long m_nInputHeight;
    long m_nOutputWidth;
    long m_nOutputHeight;
    BYTE m_cFilterBlue;
    BYTE m_cFilterGreen;
    BYTE m_cFilterRed;

public:
        DECLARE_POLY_AGGREGATABLE(CColgen)
        DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
        DECLARE_REGISTER_DX_TRANSFORM(IDR_Colgen, CATID_DXImageTransform)
        DECLARE_GET_CONTROLLING_UNKNOWN()

	CColgen();
        ~CColgen();

BEGIN_PROP_MAP(CColgen)
    PROP_ENTRY( "FilterColor", 1, CLSID_ColorGenerator )
END_PROP_MAP()

BEGIN_COM_MAP(CColgen)
        // Block CDXBaseNTo1 IObjectSafety implementation because we
        // aren't safe for scripting
        COM_INTERFACE_ENTRY_NOINTERFACE(IObjectSafety) 
        COM_INTERFACE_ENTRY(IDXEffect)
	COM_INTERFACE_ENTRY(IColorGenerator)
	COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
        COM_INTERFACE_ENTRY_DXIMPL(IOleObject)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
END_COM_MAP()

    CComPtr<IUnknown> m_pUnkMarshaler;

    // required for ATL
    BOOL            m_bRequiresSave;

    // CDXBaseNTo1 overrides
    //
    HRESULT WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue );
    HRESULT OnSetup( DWORD dwFlags );
    HRESULT FinalConstruct();

    // our helper function
    //
    HRESULT DoEffect( DXSAMPLE * pOut, DXSAMPLE * pInA, DXSAMPLE * pInB, long Samples );
    HRESULT MakeSureOutBufExists( long Samples );
    void FreeStuff( );

// IColorGenerator
public:
	STDMETHOD(get_FilterColor)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_FilterColor)(/*[in]*/ long newVal);
};

#endif //__Colgen_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\comp\alpha.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// DxtAlphaSetter.cpp : Implementation of CDxtAlphaSetter
#include <streams.h>
#include "stdafx.h"
#include <qeditint.h>
#include <qedit.h>
#include "Comp.h"

/////////////////////////////////////////////////////////////////////////////
// CDxtAlphaSetter

CDxtAlphaSetter::CDxtAlphaSetter( )
{
    m_ulMaxImageBands = 1;
    m_ulMaxInputs = 1;
    m_ulNumInRequired = 1;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;
    m_nAlpha = -1;
    m_dAlphaRamp = -1.0;
}

CDxtAlphaSetter::~CDxtAlphaSetter( )
{
}

HRESULT CDxtAlphaSetter::OnSetup( DWORD dwFlags )
{
    HRESULT hr;
    CDXDBnds InBounds(InputSurface(0), hr);
    m_nInputWidth = InBounds.Width( );
    m_nInputHeight = InBounds.Height( );

    CDXDBnds OutBounds(OutputSurface(), hr );
    m_nOutputWidth = OutBounds.Width( );
    m_nOutputHeight = OutBounds.Height( );

    if( m_nOutputWidth > m_nInputWidth )
    {
        m_nOutputWidth = m_nInputWidth;
    }
    if( m_nOutputHeight > m_nInputHeight )
    {
        m_nOutputHeight = m_nInputHeight;
    }

    return NOERROR;
}

HRESULT CDxtAlphaSetter::FinalConstruct( )
{
    HRESULT hr;

    m_ulMaxImageBands = 1;
    m_ulMaxInputs = 1;
    m_ulNumInRequired = 1;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;
    m_nAlpha = -1;
    m_dAlphaRamp = -1.0;

    hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(), &m_pUnkMarshaler.p );
    return hr;
}

HRESULT CDxtAlphaSetter::WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue )
{
    HRESULT hr = S_OK;

    //--- Get input sample access pointer for the requested region.
    //    Note: Lock may fail due to a lost surface.
    CComPtr<IDXARGBReadPtr> pInput;
    hr = InputSurface( 0 )->LockSurface( &WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                         IID_IDXARGBReadPtr, (void**)&pInput, NULL );
    if( FAILED( hr ) ) return hr;

    //--- Put a write lock only on the region we are updating so multiple
    //    threads don't conflict.
    //    Note: Lock may fail due to a lost surface.
    CComPtr<IDXARGBReadWritePtr> pOut;
    hr = OutputSurface()->LockSurface( &WI.OutputBnds, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                       IID_IDXARGBReadWritePtr, (void**)&pOut, NULL );
    if( FAILED( hr ) ) return hr;

    //--- Allocate a working buffer
    ULONG Width = WI.DoBnds.Width();
    ULONG Height = WI.DoBnds.Height();

    // allocate a scratch buffer fer us
    //
    DXSAMPLE *pOverlayBuffer = DXSAMPLE_Alloca( Width );

    // no dithering
    //
    if (DoDither())
    {
        return 0;
    }

    if( m_nAlpha >= 0 && m_dAlphaRamp >= 0.0 )
    {
        return E_INVALIDARG;
    }

    float Percent = 1.0;
    get_Progress( &Percent );

    BYTE a = (BYTE) m_nAlpha;
    for( unsigned long OutY = 0 ; OutY < Height ; ++OutY )
    {
        pInput->MoveToRow( OutY );
        pOut->MoveToRow( OutY );

        pInput->Unpack( pOverlayBuffer, Width, FALSE );

        if( m_nAlpha >= 0 )
        {
            for( int i = Width - 1 ; i >= 0 ; i-- )
            {
                pOverlayBuffer[i].Alpha = a;
            }
        }
        else
        {
            for( int i = Width - 1 ; i >= 0 ; i-- )
            {
                pOverlayBuffer[i].Alpha = BYTE( double( pOverlayBuffer[i].Alpha ) * m_dAlphaRamp );
            }
        }

        pOut->PackAndMove( pOverlayBuffer, Width );
    }

    return hr;
}

HRESULT CDxtAlphaSetter::put_Alpha( long Alpha )
{
    m_nAlpha = Alpha;
    return NOERROR;
}

HRESULT CDxtAlphaSetter::get_Alpha( long * pAlpha )
{
    CheckPointer( pAlpha, E_POINTER );
    *pAlpha = m_nAlpha;
    return NOERROR;
}

HRESULT CDxtAlphaSetter::put_AlphaRamp( double Alpha )
{
    m_dAlphaRamp = Alpha;
    return NOERROR;
}

HRESULT CDxtAlphaSetter::get_AlphaRamp( double * pAlpha )
{
    CheckPointer( pAlpha, E_POINTER );
    *pAlpha = m_dAlphaRamp;
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\comp\comp.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// DxtCompositor.cpp : Implementation of CDxtCompositor
#include <streams.h>
#include "stdafx.h"
#include <qeditint.h>
#include <qedit.h>
#include "Comp.h"
#include <math.h>

/////////////////////////////////////////////////////////////////////////////
// CDxtCompositor

CDxtCompositor::CDxtCompositor( )
{
    m_ulMaxImageBands = 1;
    m_ulMaxInputs = 2;
    m_ulNumInRequired = 2;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_nSurfaceWidth = 0;
    m_nSurfaceHeight = 0;
    m_nDstX = 0;
    m_nDstY = 0;
    m_nDstWidth = -1;
    m_nDstHeight = -1;
    m_nSrcX = 0;
    m_nSrcY = 0;
    m_nSrcWidth = -1;
    m_nSrcHeight = -1;
    m_pRowBuffer = NULL;
    m_pDestRowBuffer = NULL;
}

CDxtCompositor::~CDxtCompositor( )
{
    if( m_pRowBuffer )
    {
        delete [] m_pRowBuffer;
        m_pRowBuffer = NULL;
    }

    if(m_pDestRowBuffer)
    {
        delete [] m_pDestRowBuffer;
        m_pDestRowBuffer = NULL;
    }
}

HRESULT CDxtCompositor::OnSetup( DWORD dwFlags )
{
    HRESULT hr;
    CDXDBnds InBounds(InputSurface(0), hr);

    CDXDBnds OutBounds(OutputSurface(), hr );
    m_nSurfaceWidth = OutBounds.Width( );
    m_nSurfaceHeight = OutBounds.Height( );
    if( ( m_nSrcX < 0 ) || ( m_nSrcWidth + m_nSrcX > m_nSurfaceWidth ) )
    {
        return E_INVALIDARG;
    }
    if( ( m_nSrcY < 0 ) || ( m_nSrcHeight + m_nSrcY > m_nSurfaceHeight ) )
    {
        return E_INVALIDARG;
    }
    if( m_nSrcWidth == -1 )
    {
        m_nSrcWidth = m_nSurfaceWidth;
    }
    if( m_nSrcHeight == -1 )
    {
        m_nSrcHeight = m_nSurfaceHeight;
    }
    if( m_nDstWidth == -1 )
    {
        m_nDstWidth = m_nSurfaceWidth;
    }
    if( m_nDstHeight == -1 )
    {
        m_nDstHeight = m_nSurfaceHeight;
    }

    if( m_pRowBuffer )
    {
        delete [] m_pRowBuffer;
        m_pRowBuffer = NULL;
    }

    m_pRowBuffer = new DXPMSAMPLE[ m_nSurfaceWidth ];
    if( !m_pRowBuffer )
    {
        return E_OUTOFMEMORY;
    }

    // try to allocate the destination row buffer (needed when we scale up)
    if(m_pDestRowBuffer)
    {
        delete [] m_pDestRowBuffer;
        m_pDestRowBuffer = NULL;
    }

    m_pDestRowBuffer = new DXPMSAMPLE[ m_nSurfaceWidth ];
    if( !m_pDestRowBuffer )
    {
        // delete the row buffer
        delete [] m_pRowBuffer;
        m_pRowBuffer = NULL;

        // signal error
        return E_OUTOFMEMORY;
    }

    return NOERROR;
}

HRESULT CDxtCompositor::FinalConstruct( )
{
    HRESULT hr;

    m_ulMaxImageBands = 1;
    m_ulMaxInputs = 2;
    m_ulNumInRequired = 2;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_nSurfaceWidth = 0;
    m_nSurfaceHeight = 0;
    m_nDstX = 0;
    m_nDstY = 0;
    m_nDstWidth = -1;
    m_nDstHeight = -1;

    hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(), &m_pUnkMarshaler.p );
    return hr;
}

HRESULT CDxtCompositor::WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue )
{
    HRESULT hr = S_OK;

    CComPtr<IDXARGBReadPtr> pInA;
    hr = InputSurface( 0 )->LockSurface( &WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                         IID_IDXARGBReadPtr, (void**)&pInA, NULL );
    if( FAILED( hr ) ) return hr;

    CComPtr<IDXARGBReadPtr> pInB;
    hr = InputSurface( 1 )->LockSurface( &WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                         IID_IDXARGBReadPtr, (void**)&pInB, NULL );
    if( FAILED( hr ) ) return hr;

    CComPtr<IDXARGBReadWritePtr> pOut;
    hr = OutputSurface()->LockSurface( &WI.OutputBnds, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                       IID_IDXARGBReadWritePtr, (void**)&pOut, NULL );
    if( FAILED( hr ) ) return hr;

    ULONG Width = WI.DoBnds.Width();
    ULONG Height = WI.DoBnds.Height();

    // no dithering! Ever!
    //
    if (DoDither())
    {
        return 0;
    }

    long t1 = timeGetTime( );

    ULONG OutY;

    // copy the background (A) to the resultant picture. You cannot do this as a block
    // copy, it will fail.
    //
    for( OutY = 0 ; OutY < Height ; ++OutY )
    {
        pInA->MoveToRow( OutY );
        pOut->MoveToRow( OutY );
        pOut->CopyAndMoveBoth( (DXBASESAMPLE*) m_pRowBuffer, pInA, Width, FALSE );
    }

    // don't draw if destination is completely out of bounds
    //
    if( m_nDstX + m_nDstWidth < 0 ||
        m_nDstX > m_nSurfaceWidth ||
        m_nDstY + m_nDstHeight < 0 ||
        m_nDstY > m_nSurfaceHeight )
    {
        return 0;
    }

    if( m_nDstWidth < 0 )
    {
        return E_INVALIDARG;
    }

    if( m_nDstWidth == 0 )
    {
        return NOERROR;
    }

    // calculate the ration of the source to the destination, as integer math
    //
    long width_divider = (m_nSrcWidth << 16) / m_nDstWidth;

    long DstWidth = m_nDstWidth;
    long DstX = m_nDstX;
    long SrcWidth = m_nSrcWidth;
    long SrcX = m_nSrcX;

    // bring it within range
    //
    if( DstX < 0 )
    {
        long diff = -DstX;
        SrcX += diff * width_divider / 65536;
        SrcWidth -= diff * width_divider / 65536;
        DstWidth -= diff;
        DstX = 0;
    }
    if( DstX + DstWidth > (long) Width )
    {
        long diff = DstX + DstWidth - Width;
        SrcWidth -= ( diff * width_divider ) / 65536;
        DstWidth -= diff;
    }
    if( ( SrcX < 0 ) || ( SrcX + SrcWidth > m_nSurfaceWidth ) )
    {
        return E_INVALIDARG;
    }
    if( ( m_nSrcY < 0 ) || ( m_nSrcY + m_nSrcHeight > m_nSurfaceHeight ) )
    {
        return E_INVALIDARG;
    }

    // we don't check DstY or DxtY + DstHeight because
    // if they're OOB, we just ignore it in the loop below

    // what if SrcX is still out of bounds?

    long DstRight = DstX + DstWidth; // ( width_divider * DstWidth ) >> 16;
    DbgLog( ( LOG_TRACE, 3, ", Dest X1 = %ld, Wid = %ld, Dest X2 = %ld", m_nDstX, DstWidth, DstRight ) );

    for( OutY = 0 ; OutY < (ULONG) m_nDstHeight ; OutY++ )
    {
        // avoid out of bounds Y conditions. This can happen
        // because it's on Dst, it's not a source-only calculation
        //
        if( long( OutY + m_nDstY ) < 0 )
        {
            continue;
        }
        if( OutY + m_nDstY >= Height )
        {
            continue;
        }

        // unpack a row of the source to a row buffer, starting at the source's offset.
        // the unpacking is done without scaling, from the source image.
        // (don't allow unpacking from an invalid source Y location)
        //
        long SourceY = m_nSrcY + ( OutY * m_nSrcHeight ) / m_nDstHeight;

        pInB->MoveToXY( SrcX, SourceY );
        pInB->UnpackPremult( m_pRowBuffer, SrcWidth, FALSE );

        // seek to where we're going to draw to on the Y axis.
        //
        pOut->MoveToXY( DstX, OutY + m_nDstY );

        // copy DstWidth of samples from the source row buffer into the dest. row buffer
        // note: we can scale up or down
        //
        long runx = 0;
        for( int x = 0 ; x < DstWidth ; x++ )
        {
            m_pDestRowBuffer[x] = m_pRowBuffer[runx>>16];

            // move to the next (source row index << 16)
            runx += width_divider;
        }

        pOut->OverArrayAndMove( m_pRowBuffer, m_pDestRowBuffer, DstWidth );
    }

    long t2 = timeGetTime( );

    long t3 = t2 - t1;

    return hr;
}


STDMETHODIMP CDxtCompositor::get_OffsetX(long *pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = m_nDstX;
    return S_OK;
}

STDMETHODIMP CDxtCompositor::put_OffsetX(long newVal)
{
    m_nDstX = newVal;
    return NOERROR;
}

STDMETHODIMP CDxtCompositor::get_OffsetY(long *pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = m_nDstY;
    return S_OK;
}

STDMETHODIMP CDxtCompositor::put_OffsetY(long newVal)
{
    m_nDstY = newVal;
    return NOERROR;
}

STDMETHODIMP CDxtCompositor::get_Width(long *pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = m_nDstWidth;
    return S_OK;
}

STDMETHODIMP CDxtCompositor::put_Width(long newVal)
{
    m_nDstWidth = newVal;
    return NOERROR;
}

STDMETHODIMP CDxtCompositor::get_Height(long *pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = m_nDstHeight;
    return S_OK;
}

STDMETHODIMP CDxtCompositor::put_Height(long newVal)
{
    m_nDstHeight = newVal;
    return NOERROR;
}

STDMETHODIMP CDxtCompositor::get_SrcOffsetX(long *pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = m_nSrcX;
    return S_OK;
}

STDMETHODIMP CDxtCompositor::put_SrcOffsetX(long newVal)
{
    // don't check for values out of range here, do it in the effect loop
    m_nSrcX = newVal;
    return NOERROR;
}

STDMETHODIMP CDxtCompositor::get_SrcOffsetY(long *pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = m_nSrcY;
    return S_OK;
}

STDMETHODIMP CDxtCompositor::put_SrcOffsetY(long newVal)
{
    // don't check for values out of range here, do it in the effect loop
    m_nSrcY = newVal;
    return NOERROR;
}

STDMETHODIMP CDxtCompositor::get_SrcWidth(long *pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = m_nSrcWidth;
    return S_OK;
}

STDMETHODIMP CDxtCompositor::put_SrcWidth(long newVal)
{
    // don't check for values out of range here, do it in the effect loop
    m_nSrcWidth = newVal;
    return NOERROR;
}

STDMETHODIMP CDxtCompositor::get_SrcHeight(long *pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = m_nSrcHeight;
    return S_OK;
}

STDMETHODIMP CDxtCompositor::put_SrcHeight(long newVal)
{
    // don't check for values out of range here, do it in the effect loop
    m_nSrcHeight = newVal;
    return NOERROR;
}


//-----------------------------------------------------------
// private methods

// CDxtCompositor::PerformBoundsCheck()
// This assumes that both input and output surfaces have the same size
// i.e. single params for width and height
HRESULT
CDxtCompositor::PerformBoundsCheck(long lWidth, long lHeight)
{
    // if anything is out of bounds, then fail out
    if( (m_nDstX < 0)
        || (m_nDstY < 0)
        || (m_nDstX >= lWidth)
        || (m_nDstY >= lHeight)
        || (m_nDstWidth <= 0)
        || (m_nDstHeight <= 0)
        || (m_nDstX + m_nDstWidth > lWidth)
        || (m_nDstY + m_nDstHeight > lHeight)
        || (m_nSrcX < 0)
        || (m_nSrcY < 0)
        || (m_nSrcX >= lWidth)
        || (m_nSrcY >= lHeight)
        || (m_nSrcWidth <= 0)
        || (m_nSrcHeight <= 0)
        || (m_nSrcX + m_nSrcWidth > lWidth)
        || (m_nSrcY + m_nSrcHeight > lHeight) )
    {
        return E_FAIL;
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\colfilter\colgendll.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// ColgenDll.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f ColgenDllps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
    #include "ColgenDll.h"
    #include "ColgenDll_i.c"
    #include "Colgen.h"

#include <dxtguid.c>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ColorGenerator, CColgen)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_ColgenDLLLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\comp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DxtCompositorDll.rc
//
#define IDS_PROJNAME                         1605
#define IDR_DxtCompositor                    1600
#define IDS_TITLEDxtCompositorPP             1601
#define IDS_HELPFILEDxtCompositorPP          1602
#define IDS_DOCSTRINGDxtCompositorPP         1603
#define IDR_DxtAlphaSetter                   1604

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        1606
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         205
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\comp\stdafx.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include <streams.h>
#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <dtbase.cpp>
#include <atlctl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\comp\comp.h ===
// DxtCompositor.h : Declaration of the CDxtCompositor

#ifndef __DxtCompositor_H_
#define __DxtCompositor_H_

#ifndef DTBase_h
    #include <DTBase.h>
#endif

#include <qeditint.h>
#include <qedit.h>
#include "resource.h"       // main symbols

#define _BASECOPY_STRING L"Copyright Microsoft Corp. 1998.  Unauthorized duplication of this string is illegal. "

/////////////////////////////////////////////////////////////////////////////
// CDxtCompositor
class ATL_NO_VTABLE CDxtCompositor :
    public CDXBaseNTo1,
    public CComCoClass<CDxtCompositor, &CLSID_DxtCompositor>,
    public CComPropertySupport<CDxtCompositor>, // property support
#ifdef FILTER_DLL
    BANG BANG
#else
    public IDispatchImpl<IDxtCompositor, &IID_IDxtCompositor, &LIBID_DexterLib>,
#endif
    public IOleObjectDXImpl<CDxtCompositor>
{
    bool m_bInputIsClean;
    bool m_bOutputIsClean;
    long m_nSurfaceWidth;
    long m_nSurfaceHeight;
    long m_nDstX;
    long m_nDstY;
    long m_nDstWidth;
    long m_nDstHeight;
    long m_nSrcX;
    long m_nSrcY;
    long m_nSrcWidth;
    long m_nSrcHeight;
    DXPMSAMPLE * m_pRowBuffer;
    DXPMSAMPLE * m_pDestRowBuffer;

    // private methods
    HRESULT PerformBoundsCheck(long lWidth, long lHeigth);


public:
        DECLARE_POLY_AGGREGATABLE(CDxtCompositor)
        DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
        DECLARE_REGISTER_DX_TRANSFORM(IDR_DxtCompositor, CATID_DXImageTransform)
        DECLARE_GET_CONTROLLING_UNKNOWN()

	CDxtCompositor();
        ~CDxtCompositor();

//BEGIN_PROP_MAP(CDxtCompositor)
//END_PROP_MAP()

BEGIN_COM_MAP(CDxtCompositor)
        // Block CDXBaseNTo1 IObjectSafety implementation because we
        // aren't safe for scripting
        COM_INTERFACE_ENTRY_NOINTERFACE(IObjectSafety) 
        COM_INTERFACE_ENTRY(IDXEffect)
	COM_INTERFACE_ENTRY(IDxtCompositor)
	COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
        COM_INTERFACE_ENTRY_DXIMPL(IOleObject)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
END_COM_MAP()

	SIZE m_sizeExtent;  //current extents in himetric

BEGIN_PROPERTY_MAP(CDxtCompositor)
    PROP_ENTRY("OffsetX",           1, CLSID_NULL)
    PROP_ENTRY("OffsetY",           2, CLSID_NULL)
    PROP_ENTRY("Width",             3, CLSID_NULL)
    PROP_ENTRY("Height",            4, CLSID_NULL)
    PROP_ENTRY("SrcOffsetX",        5, CLSID_NULL)
    PROP_ENTRY("SrcOffsetY",        6, CLSID_NULL)
    PROP_ENTRY("SrcWidth",          7, CLSID_NULL)
    PROP_ENTRY("SrcHeight",         8, CLSID_NULL)
    PROP_PAGE(CLSID_NULL)
END_PROPERTY_MAP()

    CComPtr<IUnknown> m_pUnkMarshaler;

    // required for ATL
    BOOL            m_bRequiresSave;

    // CDXBaseNTo1 overrides
    //
    HRESULT WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue );
    HRESULT OnSetup( DWORD dwFlags );
    HRESULT FinalConstruct();

    // our helper function
    //
    HRESULT DoEffect( DXSAMPLE * pOut, DXSAMPLE * pInA, DXSAMPLE * pInB, long Samples );

// IDxtCompositor
public:
	STDMETHOD(get_Height)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_Height)(/*[in]*/ long newVal);
	STDMETHOD(get_Width)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_Width)(/*[in]*/ long newVal);
	STDMETHOD(get_OffsetY)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_OffsetY)(/*[in]*/ long newVal);
	STDMETHOD(get_OffsetX)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_OffsetX)(/*[in]*/ long newVal);

        STDMETHOD(get_SrcHeight)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_SrcHeight)(/*[in]*/ long newVal);
	STDMETHOD(get_SrcWidth)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_SrcWidth)(/*[in]*/ long newVal);
	STDMETHOD(get_SrcOffsetY)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_SrcOffsetY)(/*[in]*/ long newVal);
	STDMETHOD(get_SrcOffsetX)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_SrcOffsetX)(/*[in]*/ long newVal);
};

#if 1
/////////////////////////////////////////////////////////////////////////////
// CDxtAlphaSetter
class ATL_NO_VTABLE CDxtAlphaSetter :
    public CDXBaseNTo1,
    public CComCoClass<CDxtAlphaSetter, &CLSID_DxtAlphaSetter>,
    public IDispatchImpl<IDxtAlphaSetter, &IID_IDxtAlphaSetter, &LIBID_DexterLib>,
    public CComPropertySupport<CDxtCompositor>, // property support
    public IOleObjectDXImpl<CDxtAlphaSetter>
{
    bool m_bInputIsClean;
    bool m_bOutputIsClean;
    long m_nInputWidth;
    long m_nInputHeight;
    long m_nOutputWidth;
    long m_nOutputHeight;
    long m_nAlpha;
    double m_dAlphaRamp;

public:
        DECLARE_POLY_AGGREGATABLE(CDxtAlphaSetter)
        DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
        DECLARE_REGISTER_DX_TRANSFORM(IDR_DxtAlphaSetter, CATID_DXImageTransform)
        DECLARE_GET_CONTROLLING_UNKNOWN()

	CDxtAlphaSetter();
        ~CDxtAlphaSetter();

BEGIN_PROPERTY_MAP(CDxtCompositor)
    PROP_ENTRY("Alpha",           1, CLSID_NULL)
    PROP_ENTRY("AlphaRamp",       2, CLSID_NULL)
END_PROPERTY_MAP()

BEGIN_COM_MAP(CDxtAlphaSetter)
        // Block CDXBaseNTo1 IObjectSafety implementation because we
        // aren't safe for scripting
        COM_INTERFACE_ENTRY_NOINTERFACE(IObjectSafety) 
        COM_INTERFACE_ENTRY(IDXEffect)
	COM_INTERFACE_ENTRY(IDxtAlphaSetter)
	COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
        COM_INTERFACE_ENTRY_DXIMPL(IOleObject)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
END_COM_MAP()

    CComPtr<IUnknown> m_pUnkMarshaler;

    // required for ATL
    BOOL            m_bRequiresSave;

    // CDXBaseNTo1 overrides
    //
    HRESULT WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue );
    HRESULT OnSetup( DWORD dwFlags );
    HRESULT FinalConstruct();

    // our helper function
    //
    HRESULT DoEffect( DXSAMPLE * pOut, DXSAMPLE * pInA, DXSAMPLE * pInB, long Samples );

// IDxtAlphaSetter
public:
    STDMETHODIMP get_Alpha(long *pVal);
    STDMETHODIMP put_Alpha(long newVal);
    STDMETHODIMP get_AlphaRamp(double *pVal);
    STDMETHODIMP put_AlphaRamp(double newVal);
};
#endif

#endif //__DxtCompositor_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\comp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_)
#define AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define _ATL_APARTMENT_THREADED
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
//#define _WIN32_WINNT 0x0400
//#define _ATL_APARTMENT_THREADED
//#define _ATL_STATIC_REGISTRY

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
//
//  To allow us to compile with warning level 4, we need to disable
//  three warnings that ATLCTL generates at this warning level.
//
#pragma warning(disable: 4510 4610 4100)
#include <atlctl.h>
#pragma warning(default: 4510 4610 4100)
#include <DXTmpl.h>
#include <streams.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\comp\compdll.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// DxtCompDll.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f DxtCompositorDllps.mk in the project directory.


#include <streams.h>

#ifdef FILTER_DLL

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include <qeditint.h>
#include "qedit.h"
#include "CompDll.h"
#include "CompDll_i.c"
#include "Comp.h"

#include <dxtguid.c>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_DxtCompositor, CDxtCompositor)
OBJECT_ENTRY(CLSID_DxtAlphaSetter, CDxtAlphaSetter)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_DxtCompositorDLLLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\cutter\cutter.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// Cutter.cpp : Implementation of CCutter
#include <streams.h>
#include "stdafx.h"
#include "qedit.h"
#include "Cutter.h"

/////////////////////////////////////////////////////////////////////////////
// CCutter

CCutter::CCutter( )
{
    m_ulMaxImageBands = 1;
    m_ulMaxInputs = 2;
    m_ulNumInRequired = 2;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;
    m_dCutPoint = 0.5;

    IDirect3DRM *pD3DRM;
    IDirect3DRM3 *pD3DRM3;
    HRESULT hr = Direct3DRMCreate(&pD3DRM);
    pD3DRM->QueryInterface( IID_IUnknown, (void**) &pD3DRM3 );

}

CCutter::~CCutter( )
{
    FreeStuff( );
}

void CCutter::FreeStuff( )
{
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;
}
    
HRESULT CCutter::OnSetup( DWORD dwFlags )
{        
    // delete any stored stuff we have, or memory allocated
    //
    FreeStuff( );

    HRESULT hr;
    CDXDBnds InBounds(InputSurface(0), hr);
    m_nInputWidth = InBounds.Width( );
    m_nInputHeight = InBounds.Height( );

    CDXDBnds OutBounds(OutputSurface(), hr );
    m_nOutputWidth = OutBounds.Width( );
    m_nOutputHeight = OutBounds.Height( );

    if( m_nOutputWidth > m_nInputWidth )
    {
        m_nOutputWidth = m_nInputWidth;
    }
    if( m_nOutputHeight > m_nInputHeight )
    {
        m_nOutputHeight = m_nInputHeight;
    }

    return NOERROR;
}

HRESULT CCutter::FinalConstruct( )
{
    HRESULT hr;

    m_ulMaxImageBands = 1;
    m_ulMaxInputs = 2;
    m_ulNumInRequired = 2;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;

    hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(), &m_pUnkMarshaler.p );
    return hr;
}

HRESULT CCutter::WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue )
{
    HRESULT hr = S_OK;

    CComPtr<IDXARGBReadPtr> pInput;
    CComPtr<IDXARGBReadWritePtr> pOut;

    float Percent = 1.0;
    get_Progress( &Percent );

    hr = OutputSurface( )->LockSurface( 
        &WI.DoBnds, 
        m_ulLockTimeOut, 
        DXLOCKF_READWRITE,
        IID_IDXARGBReadWritePtr, 
        (void**)&pOut, 
        NULL );
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) ) 
    {
        return hr;
    }

    if( m_dCutPoint >= Percent )
    {
        hr = InputSurface( 0 )->LockSurface( 
            &WI.DoBnds, 
            m_ulLockTimeOut, 
            DXLOCKF_READ,
            IID_IDXARGBReadPtr, 
            (void**)&pInput, 
            NULL );
        ASSERT( !FAILED( hr ) );
        if( FAILED( hr ) ) 
        {
            return hr;
        }
    }
    else
    {
        hr = InputSurface( 1 )->LockSurface( 
            &WI.DoBnds, 
            m_ulLockTimeOut, 
            DXLOCKF_READ,
            IID_IDXARGBReadPtr, 
            (void**)&pInput, 
            NULL );
        ASSERT( !FAILED( hr ) );
        if( FAILED( hr ) ) 
        {
            return hr;
        }
    }

    // copy input to output
    //

    //--- Allocate a working buffer
    ULONG Width = WI.DoBnds.Width();
    ULONG Height = WI.DoBnds.Height();

    // allocate a scratch buffer fer us
    //
    DXBASESAMPLE *pScratchBuffer = DXBASESAMPLE_Alloca( Width );

    long t1 = timeGetTime( );

    for( ULONG OutY = 0 ; OutY < Height ; ++OutY )
    {
        pOut->MoveToRow( OutY );
        pInput->MoveToRow( OutY );
        pOut->CopyAndMoveBoth( pScratchBuffer, pInput, Width, TRUE );
    }

    long t2 = timeGetTime( ) - t1;

    return hr;
}



STDMETHODIMP CCutter::get_CutPoint(double *pVal)
{
    *pVal = m_dCutPoint;
    return S_OK;
}

STDMETHODIMP CCutter::put_CutPoint(double newVal)
{
    m_dCutPoint = newVal;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\cutter\cutter.h ===
// Cutter.h : Declaration of the CCutter

#ifndef __Cutter_H_
#define __Cutter_H_

#ifndef DTBase_h
    #include <DTBase.h>
#endif

#include "resource.h"       // main symbols

#define _BASECOPY_STRING L"Copyright Microsoft Corp. 1998.  Unauthorized duplication of this string is illegal. "

/////////////////////////////////////////////////////////////////////////////
// CCutter
class ATL_NO_VTABLE CCutter : 
    public CDXBaseNTo1,
    public CComCoClass<CCutter, &CLSID_DXTCutter>,
    public IDispatchImpl<IDXTCutter, &IID_IDXTCutter, &LIBID_DexterLib>,
    public IOleObjectDXImpl<CCutter>
{
    long m_nInputWidth;
    long m_nInputHeight;
    long m_nOutputWidth;
    long m_nOutputHeight;
    double m_dCutPoint;

public:
        DECLARE_POLY_AGGREGATABLE(CCutter)
        DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
        DECLARE_REGISTER_DX_TRANSFORM(IDR_Cutter, CATID_DXImageTransform)
        DECLARE_GET_CONTROLLING_UNKNOWN()

	CCutter();
        ~CCutter();

//BEGIN_PROP_MAP(CCutter)
//END_PROP_MAP()

BEGIN_COM_MAP(CCutter)
        // Block CDXBaseNTo1 IObjectSafety implementation because we
        // aren't safe for scripting
        COM_INTERFACE_ENTRY_NOINTERFACE(IObjectSafety) 
        COM_INTERFACE_ENTRY(IDXEffect)
	COM_INTERFACE_ENTRY(IDXTCutter)
	COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
        COM_INTERFACE_ENTRY_DXIMPL(IOleObject)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
END_COM_MAP()

    CComPtr<IUnknown> m_pUnkMarshaler;

    // required for ATL
    BOOL            m_bRequiresSave;

    // CDXBaseNTo1 overrides
    //
    HRESULT WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue );
    HRESULT OnSetup( DWORD dwFlags );
    HRESULT FinalConstruct();

    // our helper function
    //
    void FreeStuff( );

    // IDXTCutter
    STDMETHOD(get_CutPoint)(/*[out, retval]*/ double *pVal);
    STDMETHOD(put_CutPoint)(/*[in]*/ double newVal);
};

#endif //__Cutter_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\cutter\resource.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Cutterdll.rc
//
#define IDS_PROJNAME                    1100
#define IDR_Cutter                     1101
#define IDS_TITLECutterPP              1102
#define IDS_HELPFILECutterPP           1103
#define IDS_DOCSTRINGCutterPP          1104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         205
#define _APS_NEXT_SYMED_VALUE           1105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\cutter\cutterdll.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// CutterDll.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f CutterDllps.mk in the project directory.

#include <streams.h>
#include "stdafx.h"
#include "resource.h"

#ifdef FILTER_DLL

    #include "qedit.h"
    #include "qedit_i.c"
    #include "Cutter.h"
    #include <dtbase.cpp>
    
    #include <dxtguid.c>

    CComModule _Module;

    BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_DXTCutter, CCutter)
    END_OBJECT_MAP()

    /////////////////////////////////////////////////////////////////////////////
    // DLL Entry Point

    extern "C"
    BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
    {
        if (dwReason == DLL_PROCESS_ATTACH)
        {
            _Module.Init(ObjectMap, hInstance);
            DisableThreadLibraryCalls(hInstance);
        }
        else if (dwReason == DLL_PROCESS_DETACH)
            _Module.Term();
        return TRUE;    // ok
    }

    /////////////////////////////////////////////////////////////////////////////
    // Used to determine whether the DLL can be unloaded by OLE

    STDAPI DllCanUnloadNow(void)
    {
        return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
    }

    /////////////////////////////////////////////////////////////////////////////
    // Returns a class factory to create an object of the requested type

    STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
    {
        return _Module.GetClassObject(rclsid, riid, ppv);
    }

    /////////////////////////////////////////////////////////////////////////////
    // DllRegisterServer - Adds entries to the system registry

    STDAPI DllRegisterServer(void)
    {
        // registers object, typelib and all interfaces in typelib
        return _Module.RegisterServer(TRUE);
    }

    /////////////////////////////////////////////////////////////////////////////
    // DllUnregisterServer - Removes entries from the system registry

    STDAPI DllUnregisterServer(void)
    {
        return _Module.UnregisterServer();
    }

#endif // #ifdef FILTER_DLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\cutter\stdafx.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_)
#define AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>


//  To allow us to compile with warning level 4, we need to disable
//  three warnings that ATLCTL generates at this warning level.
//
#pragma warning(disable: 4510 4610 4100)
#include <atlctl.h>
#pragma warning(default: 4510 4610 4100)
#include <DXTmpl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\dxtenum\common.h ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED
//#define _ATL_STATIC_REGISTRY
#ifndef _USRDLL
#define _USRDLL
#endif

#include <atlbase.h>
extern CComModule _Module;;
#include <atlcom.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\cutter\stdafx.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include <streams.h>
#include "stdafx.h"

#ifdef FILTER_DLL
    #ifdef _ATL_STATIC_REGISTRY
        #include <statreg.h>
        #include <statreg.cpp>
    #endif
    #include <atlimpl.cpp>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\dxtenum\dxtenum.cpp ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#if 0
#include "qeditint.h"
#include "qedit.h"

#include "vidfx1.h"
#include "vidfx2.h"

CComModule _Module;


BEGIN_OBJECT_MAP(ObjectMap)
  OBJECT_ENTRY(CLSID_VideoEffects1Category, CVidFX1ClassManager)
  OBJECT_ENTRY(CLSID_VideoEffects2Category, CVidFX2ClassManager)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DXTENUM_DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        // We hit this ASSERT in NT setup
        // ASSERT(_Module.GetLockCount()==0 );
        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DXTENUM_DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DXTENUM_DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}


STDAPI DXTENUM_DllRegisterServer(void)
{
    // registers object, no typelib
    HRESULT hr = _Module.RegisterServer(FALSE);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DXTENUM_DllUnregisterServer(void)
{
    HRESULT hr = _Module.UnregisterServer();
    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\dxtenum\vidfx2.h ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "dxtrans.h"
#include "..\..\..\pnp\devenum\cmgrbase.h"
#include "common.h"

// !!!
#define MAX_2EFFECTS 100

typedef HRESULT(STDAPICALLTYPE *PD3DRMCreate)(IDirect3DRM **pD3DRM);

class CVidFX2ClassManager :
    public CClassManagerBase,
    public CComObjectRoot,
    public CComCoClass<CVidFX2ClassManager,&CLSID_VideoEffects2Category>
{
    struct FXGuid
    {
        GUID guid;
        LPWSTR wszDescription;
    } *m_rgFX[MAX_2EFFECTS];

    ULONG m_cFX;

    BOOL m_f3DSupported;

    // for dynamically linking to D3DRMCreate
    HMODULE m_hD3DRMCreate;
    PD3DRMCreate m_pfnDirect3DRMCreate;

public:

    CVidFX2ClassManager();
    ~CVidFX2ClassManager();

    BEGIN_COM_MAP(CVidFX2ClassManager)
	COM_INTERFACE_ENTRY2(IDispatch, ICreateDevEnum)
	COM_INTERFACE_ENTRY(ICreateDevEnum)
    END_COM_MAP();

    DECLARE_NOT_AGGREGATABLE(CVidFX2ClassManager) ;
    DECLARE_NO_REGISTRY();
    
    HRESULT ReadLegacyDevNames();
    BOOL MatchString(const TCHAR *szDevName);
    HRESULT CreateRegKeys(IFilterMapper2 *pFm2);
    BOOL CheckForOmittedEntries() { return FALSE; }

    void AddClassToList(HKEY hkClsIdRoot, CLSID &clsid, ULONG Index);
    HRESULT AddCatsToList(ICatInformation *pCatInfo, const GUID &catid);
    HRESULT InitializeEffectList();
    HRESULT AddToRejectList(const GUID &guid);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\dxtenum\vidfx1.h ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "dxtrans.h"
#include "..\..\..\pnp\devenum\cmgrbase.h"
#include "common.h"

// !!!
#define MAX_1EFFECTS 100

typedef HRESULT(STDAPICALLTYPE *PD3DRMCreate)(IDirect3DRM **pD3DRM);

class CVidFX1ClassManager :
    public CClassManagerBase,
    public CComObjectRoot,
    public CComCoClass<CVidFX1ClassManager,&CLSID_VideoEffects1Category>
{
    struct FXGuid
    {
        GUID guid;
        LPWSTR wszDescription;
    } *m_rgFX[MAX_1EFFECTS];

    ULONG m_cFX;

    BOOL m_f3DSupported;

    // for dynamically linking to D3DRMCreate
    HMODULE m_hD3DRMCreate;
    PD3DRMCreate m_pfnDirect3DRMCreate;

public:

    CVidFX1ClassManager();
    ~CVidFX1ClassManager();

    BEGIN_COM_MAP(CVidFX1ClassManager)
	COM_INTERFACE_ENTRY2(IDispatch, ICreateDevEnum)
	COM_INTERFACE_ENTRY(ICreateDevEnum)
    END_COM_MAP();

    DECLARE_NOT_AGGREGATABLE(CVidFX1ClassManager) ;
    DECLARE_REGISTRY_RESOURCEID(IDR_REGISTRY);
    
    HRESULT ReadLegacyDevNames();
    BOOL MatchString(const TCHAR *szDevName);
    HRESULT CreateRegKeys(IFilterMapper2 *pFm2);
    BOOL CheckForOmittedEntries() { return FALSE; }

    void AddClassToList(HKEY hkClsIdRoot, CLSID &clsid, ULONG Index);
    HRESULT AddCatsToList(ICatInformation *pCatInfo, const GUID &catid);
    HRESULT InitializeEffectList();
    HRESULT AddToRejectList(const GUID &guid);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\dxtenum\vidfx2.cpp ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "vidfx2.h"
#include <initguid.h>

DEFINE_GUID(CLSID_VideoEffects2Rejects, 0xcc7bfb47, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59);

// we make 2 registry keys that the DXTWrapper will use to get what effect to
// use... the effect guid, and how many input pins to expose
const TCHAR g_szGUIDBag[] = TEXT("guid");
const TCHAR g_szInputsBag[] = TEXT("inputs");
extern TCHAR g_szReject[];

CVidFX2ClassManager::CVidFX2ClassManager() :
	// value of this key is given to me in MatchString
        CClassManagerBase(g_szGUIDBag),
	m_cFX(0),
        m_hD3DRMCreate(NULL),
        m_pfnDirect3DRMCreate(NULL)
{
    DbgLog((LOG_TRACE,1,TEXT("Video Effects 2 Constructor")));

    // so we don't have to link to d3drm.dll
    //
    // GetProcAddress only takes a char
    static const char sz_Direct3DRMCreate[] = "Direct3DRMCreate";
    if(m_hD3DRMCreate = LoadLibrary(TEXT("d3drm.dll")))
    {
        m_pfnDirect3DRMCreate = (PD3DRMCreate)GetProcAddress(m_hD3DRMCreate,
						sz_Direct3DRMCreate);
        if(m_pfnDirect3DRMCreate == 0) {
            DWORD dwLastError = GetLastError();
            FreeLibrary(m_hD3DRMCreate);
            m_hD3DRMCreate = 0;
            // !!! *phr = HRESULT_FROM_WIN32(dwLastError);
	    return;
        }
    } else {
        DWORD dwLastError = GetLastError();
        // !!! *phr = HRESULT_FROM_WIN32(dwLastError);
	return;
    }

}

CVidFX2ClassManager::~CVidFX2ClassManager()
{
    DbgLog((LOG_TRACE,1,TEXT("Video Effects 2 Destructor")));
    for (ULONG i = 0; i < m_cFX; i++) {
	CoTaskMemFree(m_rgFX[i]->wszDescription);
	delete m_rgFX[i];
    }
    if (m_hD3DRMCreate) {
        FreeLibrary(m_hD3DRMCreate);
    }
}

HRESULT CVidFX2ClassManager::ReadLegacyDevNames()
{
    DbgLog((LOG_TRACE,1,TEXT("FX2: ReadLegacyDevNames")));

    // fills m_rgFX and sets m_cFX
    InitializeEffectList();

    m_cNotMatched = m_cFX;
    return S_OK;
}

BOOL CVidFX2ClassManager::MatchString(const TCHAR *szDevName)
{
    USES_CONVERSION;
    DbgLog((LOG_TRACE,3,TEXT("FX2: MatchString %s"), szDevName));
    for (UINT i = 0; i < m_cFX; i++)
    {
        GUID guid;
	CLSIDFromString((WCHAR *) T2CW(szDevName), &guid);
        if (guid == m_rgFX[i]->guid)
        {
    	    DbgLog((LOG_TRACE,3,TEXT("MATCHED")));
            return TRUE;
        }

    }
    DbgLog((LOG_TRACE,3,TEXT("NOT MATCHED")));
    return FALSE;
}

HRESULT CVidFX2ClassManager::CreateRegKeys(IFilterMapper2 *pFm2)
{
    DbgLog((LOG_TRACE,1,TEXT("FX2: CreateRegKeys")));

    USES_CONVERSION;
    ResetClassManagerKey(CLSID_VideoEffects2Category);
    HRESULT hr = S_OK;

    ReadLegacyDevNames();
    for (UINT i = 0; i < m_cFX; i++)
    {
        WCHAR wszUniq[120];
	StringFromGUID2(m_rgFX[i]->guid, wszUniq, 120);

        DWORD dwFlags = 0;

        REGFILTER2 rf2;
        rf2.dwVersion = 1;
        rf2.dwMerit = MERIT_DO_NOT_USE;
        rf2.cPins = 0;
        rf2.rgPins = NULL;

        IMoniker *pMoniker = 0;
        hr = RegisterClassManagerFilter(
            pFm2,
            CLSID_DXTWrap,
	    // friendly name presented to user
            m_rgFX[i]->wszDescription,
            &pMoniker,
            &CLSID_VideoEffects2Category,
	    // effect GUID is the unique identifier
            wszUniq,
            &rf2);
        if(SUCCEEDED(hr))
        {
            IPropertyBag *pPropBag;
            hr = pMoniker->BindToStorage(
                0, 0, IID_IPropertyBag, (void **)&pPropBag);
            if(SUCCEEDED(hr))
            {
                VARIANT var;
                var.vt = VT_BSTR;
                var.bstrVal = SysAllocString(wszUniq);
                if(var.bstrVal) {
                    hr = pPropBag->Write(T2CW(g_szGUIDBag), &var);
                    SysFreeString(var.bstrVal);
                } else {
                    hr = E_OUTOFMEMORY;
                }
		if (hr == S_OK) {
                    var.vt = VT_I4;
                    var.lVal = 2;
                    hr = pPropBag->Write(T2CW(g_szInputsBag), &var);
		}

                pPropBag->Release();
            }
            pMoniker->Release();
        }
	if (FAILED(hr))
	    break;
    }
    return hr;
}


void CVidFX2ClassManager::AddClassToList(HKEY hkClsIdRoot, CLSID &clsid, ULONG Index)
{
    USES_CONVERSION;
    OLECHAR wszGUID[MAX_PATH];
    StringFromGUID2(clsid, wszGUID, MAX_PATH);
    TCHAR *szTcharGUID = W2T(wszGUID);

    m_rgFX[Index] = new FXGuid;
    long cbSizeW = _MAX_PATH * sizeof(WCHAR);
    m_rgFX[Index]->wszDescription = (LPWSTR)CoTaskMemAlloc(cbSizeW);
    m_rgFX[Index]->wszDescription[0] = 0;
    TCHAR szDesc[_MAX_PATH];
    long cbSize = sizeof(szDesc);
    LONG rrv = RegQueryValue(hkClsIdRoot, szTcharGUID, szDesc, &cbSize);
    if (rrv == ERROR_SUCCESS) {
	lstrcpyW(m_rgFX[Index]->wszDescription, T2W(szDesc));
   	DbgLog((LOG_TRACE,1,TEXT("%S"), m_rgFX[Index]->wszDescription));
    }
    m_rgFX[Index]->guid = (GUID)clsid;
    m_cFX++;
}


HRESULT CVidFX2ClassManager::AddCatsToList(ICatInformation *pCatInfo, const GUID &catid)
{
#include "..\..\..\pnp\devenum\util.h"
#define NUM_GUIDS 10
    USES_CONVERSION;
    IEnumCLSID *pEnumCLSID;
    GUID aguid[NUM_GUIDS];
    ULONG cguid;

    HRESULT hr = pCatInfo->EnumClassesOfCategories(1, (GUID *)&catid,
						0, NULL, &pEnumCLSID);
    if (SUCCEEDED(hr)) {
        HKEY hkClsIdRoot;
       if (RegOpenKey(HKEY_CLASSES_ROOT, TEXT("CLSID"), &hkClsIdRoot) != ERROR_SUCCESS)
        {
            DbgLog((LOG_ERROR,1,TEXT("Failed to open CLSID registry key")));
            pEnumCLSID->Release();
            return E_OUTOFMEMORY;
        }
        while (1) {
            ULONG ulUsed;
	    GUID guid[25];
	    ulUsed = 0;
            hr = pEnumCLSID->Next(25, guid, &ulUsed);
	    if (FAILED(hr) || ulUsed == 0) {
		break;
	    }
	    while (ulUsed-- > 0) {
   	        DbgLog((LOG_TRACE,3,TEXT("Found a possible effect...")));

	        // If this clsid is already in the category, we don't need to
		// query it and waste countless hours. some DXTs can take 700ms
		// each to create and query!!

    	        HKEY hk;
    	        OLECHAR szReg[MAX_PATH];
	        lstrcpyW(szReg, T2W(g_szCmRegPath));
    	        OLECHAR szGUID[MAX_PATH];
    	        StringFromGUID2(CLSID_VideoEffects2Category, szGUID,
							MAX_PATH);
    	        lstrcatW(szReg, L"\\");
    	        lstrcatW(szReg, szGUID);
    	        lstrcatW(szReg, L"\\");
    	        StringFromGUID2(guid[ulUsed], szGUID, MAX_PATH);
    	        lstrcatW(szReg, szGUID);
    	        TCHAR *TszReg = W2T(szReg);
    	        TCHAR XX[_MAX_PATH];
    	        long rrv = RegOpenKey(g_hkCmReg, TszReg, &hk);
	        if (rrv == ERROR_SUCCESS) {
	            DWORD cb = sizeof(XX);
    	            rrv = RegQueryValueEx(hk, TEXT("FriendlyName"), NULL, NULL,
						(BYTE *)XX, &cb);
    	            RegCloseKey(hk);
	            if (rrv == ERROR_SUCCESS) {
    	    	        m_rgFX[m_cFX] = new FXGuid;
		        if (m_rgFX[m_cFX] == NULL) {
		            return E_OUTOFMEMORY;
		        }
    	    	        long cbSizeW = _MAX_PATH * sizeof(WCHAR);
    	    	        m_rgFX[m_cFX]->wszDescription =
					    (LPWSTR)CoTaskMemAlloc(cbSizeW);
	    	        if (m_rgFX[m_cFX]->wszDescription == NULL) {
		            return E_OUTOFMEMORY;
	    	        }
    	    	        lstrcpyW(m_rgFX[m_cFX]->wszDescription, T2W(XX));
    	    	        m_rgFX[m_cFX]->guid = (GUID)guid[ulUsed];
    	    	        m_cFX++;
    	                DbgLog((LOG_TRACE,2,TEXT("Found in Registry: Saved making it!")));
		        continue;
	            }
	        }

	        // If this clsid is already in the reject registry, we've tried
	        // it and know it doesn't belong. Don't waste up to 800ms
		// creating it!

    	        RegOpenKey(HKEY_CURRENT_USER, g_szReject, &hk);
	        if (hk) {
    	            StringFromGUID2(CLSID_VideoEffects2Rejects, szReg,
							MAX_PATH);
    	            lstrcatW(szReg, L"\\");
    	            StringFromGUID2(guid[ulUsed], szGUID, MAX_PATH);
    	            lstrcatW(szReg, szGUID);
    	            TszReg = W2T(szReg);
	            long cb = sizeof(XX);
    	            rrv = RegQueryValue(hk, TszReg, XX, &cb);
    	            RegCloseKey(hk);
	            if (rrv == ERROR_SUCCESS) {
    	                DbgLog((LOG_TRACE,2,TEXT("Found in REJECT Registry: Saved making it!")));
		        continue;
	            }
		}

	        IDXTransform *pDXT;
    	        hr = CoCreateInstance(guid[ulUsed], NULL, CLSCTX_INPROC,
					IID_IDXTransform, (void **)&pDXT);
	        if (hr == S_OK) {
		    ULONG k = 0;
		    DWORD dw;
    		    cguid = NUM_GUIDS;	// reset!
		    while ((hr = pDXT->GetInOutInfo(FALSE, k++, &dw, aguid,
						&cguid, NULL)) == S_OK) {
		        for (ULONG j = 0; j < cguid; j++) {
		            if (IsEqualGUID(aguid[j], IID_IDXSurface))
			        break;
		        }
		        if (j >= cguid) {
   	    	            DbgLog((LOG_TRACE,3,TEXT("Input %d can't accept surfaces"), k));
			    break;
		        } else {
    		            cguid = NUM_GUIDS;	// reset!
			    continue;
		        }
		    }

		    if (hr == S_FALSE && k > 2) {
			// if there are 2 good inputs we can use, and pin 3
			// is optional, this is a 2 input effect
    		        cguid = NUM_GUIDS;
		        hr = pDXT->GetInOutInfo(FALSE, 2, &dw, aguid,
								&cguid, NULL);
		        if (hr == S_FALSE || (hr == S_OK &&
						(dw & DXINOUTF_OPTIONAL))) {
   	    	            DbgLog((LOG_TRACE,3,TEXT("This can operate with 2 2D inputs")));
                            AddClassToList(hkClsIdRoot, guid[ulUsed], m_cFX);
			} else {
   	    	            DbgLog((LOG_TRACE,3,TEXT("REJECT: >2 inputs")));
		            AddToRejectList(guid[ulUsed]);
			}
		    } else {
   	    	        DbgLog((LOG_TRACE,3,TEXT("REJECT: <2 inputs")));
		        AddToRejectList(guid[ulUsed]);
		    }
		    pDXT->Release();
		} else {
   	    	    DbgLog((LOG_TRACE,3,TEXT("REJECT: Can't create it")));
		    AddToRejectList(guid[ulUsed]);
		}
	    }
        }
        pEnumCLSID->Release();
        RegCloseKey(hkClsIdRoot);
    } else {
   	DbgLog((LOG_ERROR,1,TEXT("No effects in this category at all")));
    }
    return hr;
}


HRESULT CVidFX2ClassManager::AddToRejectList(const GUID &guid)
{
    // Add this CLSID to the reject registry

    USES_CONVERSION;
    HKEY hk;
    OLECHAR szReg[MAX_PATH];
    szReg[0] = 0;
    lstrcatW(szReg, T2W(g_szReject));
    lstrcatW(szReg, L"\\");
    OLECHAR szGUIDFX[MAX_PATH];
    StringFromGUID2(CLSID_VideoEffects2Rejects, szGUIDFX, MAX_PATH);
    lstrcatW(szReg, szGUIDFX);
    lstrcatW(szReg, L"\\");
    StringFromGUID2(guid, szGUIDFX, MAX_PATH);
    lstrcatW(szReg, szGUIDFX);
    TCHAR *TszReg = W2T(szReg);
    RegCreateKey(HKEY_CURRENT_USER, TszReg, &hk);
    if (hk) {
    	DbgLog((LOG_TRACE,3,TEXT("Added to REJECT list")));
        RegCloseKey(hk);
	return NOERROR;
    } else {
    	DbgLog((LOG_TRACE,3,TEXT("ERROR: Can't add to REJECT list")));
	return E_OUTOFMEMORY;
    }
}


HRESULT CVidFX2ClassManager::InitializeEffectList()
{

    // already done
    if (m_cFX)
	return S_OK;

    // You need DXF6 (Chrome 1.0, Win98SP1, or NT5) to get 3D effects
    // !!! After installing DX6, make sure this code runs again!
    m_f3DSupported = FALSE;
    IDirect3DRM *pD3DRM;
    IDirect3DRM3 *pD3DRM3;
    HRESULT hr = m_pfnDirect3DRMCreate(&pD3DRM);
    if (hr == NOERROR) {
	hr = pD3DRM->QueryInterface(IID_IDirect3DRM3, (void **)&pD3DRM3);
	pD3DRM->Release();
        if (hr == NOERROR) {
            DbgLog((LOG_TRACE,1,TEXT("***This OS supports 3D transforms")));
	    pD3DRM3->Release();
	    m_f3DSupported = TRUE;
        }
    }

    ICatInformation *pCatInfo;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL,
			CLSCTX_ALL, IID_ICatInformation, (void **)&pCatInfo);
    if (SUCCEEDED(hr)) {
   	DbgLog((LOG_TRACE,1,TEXT("Initializing 2 input 2D effects")));
        hr = AddCatsToList(pCatInfo, CATID_DXImageTransform);
	if (m_f3DSupported) {
   	    DbgLog((LOG_TRACE,1,TEXT("Initializing 2 input 3D effects")));
            hr = AddCatsToList(pCatInfo, CATID_DX3DTransform);
	}
        pCatInfo->Release();
    } else {
   	DbgLog((LOG_ERROR,1,TEXT("There are no effects at all")));
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\dxtenum\vidfx1.cpp ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "vidfx1.h"
#include <initguid.h>

DEFINE_GUID(CLSID_VideoEffects1Rejects, 0xcc7bfb46, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59);

// we make 2 registry keys that the DXTWrapper will use to get what effect to
// use... the effect guid, and how many input pins to expose
const TCHAR g_szGUIDBag[] = TEXT("guid");
const TCHAR g_szInputsBag[] = TEXT("inputs");
TCHAR g_szReject[] = TEXT("Software\\Microsoft\\ActiveMovie");

CVidFX1ClassManager::CVidFX1ClassManager() :
	// value of this key is given to me in MatchString
        CClassManagerBase(g_szGUIDBag),
	m_cFX(0),
        m_hD3DRMCreate(NULL),
        m_pfnDirect3DRMCreate(NULL)
{
    DbgLog((LOG_TRACE,1,TEXT("Video Effects 1 Constructor")));

    // so we don't have to link to d3drm.dll
    //
    // GetProcAddress only takes a char
    const char sz_Direct3DRMCreate[] = "Direct3DRMCreate";
    if(m_hD3DRMCreate = LoadLibrary(TEXT("d3drm.dll")))
    {
        m_pfnDirect3DRMCreate = (PD3DRMCreate)GetProcAddress(m_hD3DRMCreate,
						sz_Direct3DRMCreate);
        if(m_pfnDirect3DRMCreate == 0) {
            DWORD dwLastError = GetLastError();
            FreeLibrary(m_hD3DRMCreate);
            m_hD3DRMCreate = 0;
            // !!! *phr = HRESULT_FROM_WIN32(dwLastError);
	    return;
        }
    } else {
        DWORD dwLastError = GetLastError();
        // !!! *phr = HRESULT_FROM_WIN32(dwLastError);
	return;
    }

}

CVidFX1ClassManager::~CVidFX1ClassManager()
{
    DbgLog((LOG_TRACE,1,TEXT("Video Effects 1 Destructor")));
    for (ULONG i = 0; i < m_cFX; i++) {
	CoTaskMemFree(m_rgFX[i]->wszDescription);
	delete m_rgFX[i];
    }
    if (m_hD3DRMCreate) {
        FreeLibrary(m_hD3DRMCreate);
    }
}

HRESULT CVidFX1ClassManager::ReadLegacyDevNames()
{
    DbgLog((LOG_TRACE,1,TEXT("FX1: ReadLegacyDevNames")));

    // fills m_rgFX and sets m_cFX
    InitializeEffectList();

    m_cNotMatched = m_cFX;
    return S_OK;
}

BOOL CVidFX1ClassManager::MatchString(const TCHAR *szDevName)
{
    DbgLog((LOG_TRACE,3,TEXT("FX1: MatchString %s"), szDevName));
    USES_CONVERSION;
    for (UINT i = 0; i < m_cFX; i++)
    {
        GUID guid;
	CLSIDFromString((WCHAR *) T2CW(szDevName), &guid);
        if (guid == m_rgFX[i]->guid)
        {
    	    DbgLog((LOG_TRACE,3,TEXT("MATCHED")));
            return TRUE;
        }

    }
    DbgLog((LOG_TRACE,3,TEXT("NOT MATCHED")));
    return FALSE;
}

HRESULT CVidFX1ClassManager::CreateRegKeys(IFilterMapper2 *pFm2)
{
    DbgLog((LOG_TRACE,1,TEXT("FX1: CreateRegKeys")));

    ResetClassManagerKey(CLSID_VideoEffects1Category);
    USES_CONVERSION;
    HRESULT hr = S_OK;

    ReadLegacyDevNames();
    for (UINT i = 0; i < m_cFX; i++)
    {
        WCHAR wszUniq[120];
	StringFromGUID2(m_rgFX[i]->guid, wszUniq, 120);

        DWORD dwFlags = 0;

        REGFILTER2 rf2;
        rf2.dwVersion = 1;
        rf2.dwMerit = MERIT_DO_NOT_USE;
        rf2.cPins = 0;
        rf2.rgPins = NULL;

        IMoniker *pMoniker = 0;
        hr = RegisterClassManagerFilter(
            pFm2,
            CLSID_DXTWrap,
	    // friendly name presented to user
            m_rgFX[i]->wszDescription,
            &pMoniker,
            &CLSID_VideoEffects1Category,
	    // effect GUID is the unique identifier
            wszUniq,
            &rf2);
        if(SUCCEEDED(hr))
        {
            IPropertyBag *pPropBag;
            hr = pMoniker->BindToStorage(
                0, 0, IID_IPropertyBag, (void **)&pPropBag);
            if(SUCCEEDED(hr))
            {
                VARIANT var;
                var.vt = VT_BSTR;
                var.bstrVal = SysAllocString(wszUniq);
                if(var.bstrVal) {
                    hr = pPropBag->Write(T2CW(g_szGUIDBag), &var);
                    SysFreeString(var.bstrVal);
                } else {
                    hr = E_OUTOFMEMORY;
                }
		if (hr == S_OK) {
                    var.vt = VT_I4;
                    var.lVal = 1;	// I am a 1 input effect
                    hr = pPropBag->Write(T2CW(g_szInputsBag), &var);
		}

                pPropBag->Release();
            }
            pMoniker->Release();
        }
	if (FAILED(hr))
	    break;
    }
    return hr;
}


void CVidFX1ClassManager::AddClassToList(HKEY hkClsIdRoot, CLSID &clsid, ULONG Index)
{
    USES_CONVERSION;
    OLECHAR wszGUID[MAX_PATH];
    StringFromGUID2(clsid, wszGUID, MAX_PATH);
    TCHAR *szTcharGUID = W2T(wszGUID);

    m_rgFX[Index] = new FXGuid;
    long cbSizeW = _MAX_PATH * sizeof(WCHAR);
    m_rgFX[Index]->wszDescription = (LPWSTR)CoTaskMemAlloc(cbSizeW);
    m_rgFX[Index]->wszDescription[0] = 0;
    TCHAR szDesc[_MAX_PATH];
    long cbSize = sizeof(szDesc);
    LONG rrv = RegQueryValue(hkClsIdRoot, szTcharGUID, szDesc, &cbSize);
    if (rrv == ERROR_SUCCESS) {
	lstrcpyW(m_rgFX[Index]->wszDescription, T2W(szDesc));
   	DbgLog((LOG_TRACE,1,TEXT("%S"), m_rgFX[Index]->wszDescription));
    }
    m_rgFX[Index]->guid = (GUID)clsid;
    m_cFX++;
}


HRESULT CVidFX1ClassManager::AddCatsToList(ICatInformation *pCatInfo, const GUID &catid)
{
#include "..\..\..\pnp\devenum\util.h"
#define NUM_GUIDS 10	// 10 types of inputs allowed per effect
    USES_CONVERSION;
    IEnumCLSID *pEnumCLSID;
    GUID aguid[NUM_GUIDS];
    ULONG cguid;

    HRESULT hr = pCatInfo->EnumClassesOfCategories(1, (GUID *)&catid,
						0, NULL, &pEnumCLSID);
    if (FAILED(hr)) {
   	DbgLog((LOG_ERROR,1,TEXT("No effects in this category at all")));
	return hr;
    }

    HKEY hkClsIdRoot;
    if (RegOpenKey(HKEY_CLASSES_ROOT, TEXT("CLSID"), &hkClsIdRoot) != ERROR_SUCCESS)
    {
        DbgLog((LOG_ERROR,1,TEXT("Failed to open CLSID registry key")));
        pEnumCLSID->Release();
        return E_OUTOFMEMORY;
    }

    // go through all the effects in the system
    while (1) {
        ULONG ulUsed;
	GUID guid[25];
	ulUsed = 0;
        hr = pEnumCLSID->Next(25, guid, &ulUsed);
	if (FAILED(hr) || ulUsed == 0) {
	    break;
	}
	while (ulUsed-- > 0) {
   	    DbgLog((LOG_TRACE,3,TEXT("Found a possible effect...")));

	    // If this clsid is already in the category, we don't need to query
	    // it and waste countless hours. some DXTs can take 700ms each to
	    // create and query!!

    	    HKEY hk;
    	    OLECHAR szReg[MAX_PATH];
	    lstrcpyW(szReg, T2W(g_szCmRegPath));
    	    OLECHAR szGUID[MAX_PATH];
    	    StringFromGUID2(CLSID_VideoEffects1Category, szGUID,
							MAX_PATH);
    	    lstrcatW(szReg, L"\\");
    	    lstrcatW(szReg, szGUID);
    	    lstrcatW(szReg, L"\\");
    	    StringFromGUID2(guid[ulUsed], szGUID, MAX_PATH);
    	    lstrcatW(szReg, szGUID);
    	    TCHAR *TszReg = W2T(szReg);
    	    TCHAR XX[_MAX_PATH];
    	    long rrv = RegOpenKey(g_hkCmReg, TszReg, &hk);
	    if (rrv == ERROR_SUCCESS) {
	        DWORD cb = sizeof(XX);
    	        rrv = RegQueryValueEx(hk, TEXT("FriendlyName"), NULL, NULL,
						(BYTE *)XX, &cb);
    	        RegCloseKey(hk);
	        if (rrv == ERROR_SUCCESS) {
    	    	    m_rgFX[m_cFX] = new FXGuid;
		    if (m_rgFX[m_cFX] == NULL) {
		        return E_OUTOFMEMORY;
		    }
    	    	    long cbSizeW = _MAX_PATH * sizeof(WCHAR);
    	    	    m_rgFX[m_cFX]->wszDescription =
						(LPWSTR)CoTaskMemAlloc(cbSizeW);
	    	    if (m_rgFX[m_cFX]->wszDescription == NULL) {
		        return E_OUTOFMEMORY;
	    	    }
    	    	    lstrcpyW(m_rgFX[m_cFX]->wszDescription, T2W(XX));
    	    	    m_rgFX[m_cFX]->guid = (GUID)guid[ulUsed];
    	    	    m_cFX++;
    	            DbgLog((LOG_TRACE,2,TEXT("Found in Registry: Saved making it!")));
		    continue;
	        }
	    }

	    // If this clsid is already in the reject registry, we've tried it
	    // and know it doesn't belong. Don't waste up to 800ms creating it!
	    // !!! If I was a good citizen, unregistering would delete this key

    	    RegOpenKey(HKEY_CURRENT_USER, g_szReject, &hk);
	    if (hk) {
    	        StringFromGUID2(CLSID_VideoEffects1Rejects, szReg,
								MAX_PATH);
    	        lstrcatW(szReg, L"\\");
    	        StringFromGUID2(guid[ulUsed], szGUID, MAX_PATH);
    	        lstrcatW(szReg, szGUID);
    	        TszReg = W2T(szReg);
	        long cb = sizeof(XX);
    	        rrv = RegQueryValue(hk, TszReg, XX, &cb);
    	        RegCloseKey(hk);
	        if (rrv == ERROR_SUCCESS) {
    	            DbgLog((LOG_TRACE,2,TEXT("Found in REJECT Registry: Saved making it!")));
		    continue;
	        }
	    }

	    IDXTransform *pDXT;
    	    hr = CoCreateInstance(guid[ulUsed], NULL, CLSCTX_INPROC,
					IID_IDXTransform, (void **)&pDXT);
	    if (hr == S_OK) {
		DWORD dw;
		// find out about input pin #0
    		cguid = NUM_GUIDS;
		hr = pDXT->GetInOutInfo(FALSE, 0, &dw, aguid, &cguid, NULL);
		if (hr == S_OK) {
		    // make sure it can accept a 2D surface input
		    for (ULONG j = 0; j < cguid; j++) {
		        if (IsEqualGUID(aguid[j], IID_IDXSurface))
			    break;
		    }
		    if (j < cguid) {
			// find out about input pin #1
			cguid = NUM_GUIDS;
		        hr = pDXT->GetInOutInfo(FALSE, 1, &dw, aguid,
						&cguid, NULL);
			// if there is no pin 1, or it's optional, this is a
			// 1 input effect
		        if (hr == S_FALSE || (hr == S_OK &&
						(dw & DXINOUTF_OPTIONAL))) {
   	    	            DbgLog((LOG_TRACE,2,TEXT("This can operate with 1 2D input")));
                            AddClassToList(hkClsIdRoot, guid[ulUsed], m_cFX);
			} else {
   	    	            DbgLog((LOG_TRACE,3,TEXT("REJECT: needs 2 inputs")));
		    	    AddToRejectList(guid[ulUsed]);
			}
		    } else {
   	    	        DbgLog((LOG_TRACE,3,TEXT("REJECT: 3D only")));
		    	AddToRejectList(guid[ulUsed]);
		    }
		} else {
		    DbgLog((LOG_TRACE,3,TEXT("REJECT: Can't get pin info")));
		    AddToRejectList(guid[ulUsed]);
		}

		pDXT->Release();
	    } else {
		DbgLog((LOG_TRACE,3,TEXT("REJECT: Can't create it")));
		AddToRejectList(guid[ulUsed]);
	    }
	}
    }

    pEnumCLSID->Release();
    RegCloseKey(hkClsIdRoot);

    return hr;
}


HRESULT CVidFX1ClassManager::AddToRejectList(const GUID &guid)
{
    // Add this CLSID to the reject registry

    USES_CONVERSION;
    HKEY hk;
    OLECHAR szReg[MAX_PATH];
    szReg[0] = 0;
    lstrcatW(szReg, T2W(g_szReject));
    lstrcatW(szReg, L"\\");
    OLECHAR szGUIDFX[MAX_PATH];
    StringFromGUID2(CLSID_VideoEffects1Rejects, szGUIDFX, MAX_PATH);
    lstrcatW(szReg, szGUIDFX);
    lstrcatW(szReg, L"\\");
    StringFromGUID2(guid, szGUIDFX, MAX_PATH);
    lstrcatW(szReg, szGUIDFX);
    TCHAR *TszReg = W2T(szReg);
    RegCreateKey(HKEY_CURRENT_USER, TszReg, &hk);
    if (hk) {
    	DbgLog((LOG_TRACE,3,TEXT("Added to REJECT list")));
        RegCloseKey(hk);
	return NOERROR;
    } else {
    	DbgLog((LOG_TRACE,3,TEXT("ERROR: Can't add to REJECT list")));
	return E_OUTOFMEMORY;
    }
}


HRESULT CVidFX1ClassManager::InitializeEffectList()
{

    // already done
    if (m_cFX)
	return S_OK;

    // You need DXF6 (Chrome 1.0, Win98SP1, or NT5) to get 3D effects
    // !!! After installing DX6, make sure this code runs again!
    m_f3DSupported = FALSE;
    IDirect3DRM *pD3DRM;
    IDirect3DRM3 *pD3DRM3;
    HRESULT hr = m_pfnDirect3DRMCreate(&pD3DRM);
    if (hr == NOERROR) {
	hr = pD3DRM->QueryInterface(IID_IDirect3DRM3, (void **)&pD3DRM3);
	pD3DRM->Release();
        if (hr == NOERROR) {
            DbgLog((LOG_TRACE,1,TEXT("***This OS supports 3D transforms")));
	    pD3DRM3->Release();
	    m_f3DSupported = TRUE;
        }
    }

    ICatInformation *pCatInfo;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL,
			CLSCTX_ALL, IID_ICatInformation, (void **)&pCatInfo);
    if (SUCCEEDED(hr)) {
   	DbgLog((LOG_TRACE,1,TEXT("Initializing 1 input 2D effects")));
        hr = AddCatsToList(pCatInfo, CATID_DXImageTransform);
	if (m_f3DSupported) {
   	    DbgLog((LOG_TRACE,1,TEXT("Initializing 1 input 3D effects")));
            hr = AddCatsToList(pCatInfo, CATID_DX3DTransform);
	}
        pCatInfo->Release();
    } else {
   	DbgLog((LOG_ERROR,1,TEXT("There are no effects at all")));
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\dxtwrap\resource.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
#define IDS_NAME	200
#define IDD_PROPERTIES  201
#define IDC_EFFECTLIST  202
#define IDC_STARTTIME  	203
#define IDC_ENDTIME  	204
#define IDC_CONSTANT  	205
#define IDC_VARIES  	206
#define IDC_LEVEL  	207
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\dxtwrap\dxt.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef __DXTWRAP__
#define __DXTWRAP__

// !!!
#define MAX_EFFECTS 		50
#define MAX_EFFECT_INPUTS 	10
#define MAX_EFFECT_OUTPUTS 	10

#include <dxtrans.h>
#include "..\..\errlog\cerrlog.h"

extern const AMOVIESETUP_FILTER sudDXTWrap;

class CDXTWrap;

typedef struct _QParamData {
    REFERENCE_TIME rtStart;	// when to use this GUID. pData's times are
    REFERENCE_TIME rtStop;	// when a and b are mixed
    GUID EffectGuid;
    IUnknown * pEffectUnk;
    BOOL fCanDoProgress;
    DEXTER_PARAM_DATA Data;
    IDXTransform *pDXT;		// once opened
    _QParamData *pNext;
} QPARAMDATA;

// this stuff is for the non-Dexter DXT wrapper
DEFINE_GUID(CLSID_DXTProperties,
0x1B544c24, 0xFD0B, 0x11ce, 0x8C, 0x63, 0x00, 0xAA, 0x00, 0x44, 0xB5, 0x20);

class CDXTInputPin;
class CDXTOutputPin;

class CMyRaw : public CUnknown, public IDXRawSurface
{
    DXRAWSURFACEINFO m_DXRAW;	// surface to use

public:

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    CMyRaw() : CUnknown(TEXT("Raw Surface"), NULL) {};

    // IDXRawSurface
    HRESULT STDMETHODCALLTYPE GetSurfaceInfo( 
            DXRAWSURFACEINFO __RPC_FAR *pSurfaceInfo);

    HRESULT SetSurfaceInfo(DXRAWSURFACEINFO *pSurfaceInfo);
};



// class for the Tee filter's Input pin
//
class CDXTInputPin : public CBaseInputPin
{
    friend class CDXTOutputPin;
    friend class CDXTWrap;

    CDXTWrap *m_pFilter;

    // the interface used by this pin
    IDXSurface *m_pDXSurface;
    CMyRaw *m_pRaw;	// object to initialize the surface

    BOOL m_fSurfaceFilled;
    IMediaSample *m_pSampleHeld;
    HANDLE m_hEventSurfaceFree;
    LONGLONG m_llSurfaceStart, m_llSurfaceStop;
    CCritSec m_csReceive;
    CCritSec m_csSurface;	// for holding onto samples

public:

    // Constructor and destructor
    CDXTInputPin(TCHAR *pObjName,
                 CDXTWrap *pFilter,
                 HRESULT *phr,
                 LPCWSTR pPinName);

    //~CDXTInputPin();

    // Used to check the input pin connection
    HRESULT CheckMediaType(const CMediaType *pmt);

    HRESULT Active();
    HRESULT Inactive();

    // Pass through calls downstream
    STDMETHODIMP EndOfStream();
    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();
    STDMETHODIMP NewSegment(REFERENCE_TIME tStart, REFERENCE_TIME tStop, double dRate);

    STDMETHODIMP ReceiveCanBlock();

    // Handles the next block of data from the stream
    STDMETHODIMP Receive(IMediaSample *pSample);

    int m_cBuffers;	    // number of buffers in allocator
};


// Class for the filter's Output pins.
//
class CDXTOutputPin : public CBaseOutputPin
{
    friend class CDXTInputPin;
    friend class CDXTWrap;

    CDXTWrap *m_pFilter;

    IDXSurface *m_pDXSurface;

    CMyRaw *m_pRaw;	// object to initialize the surface

    IUnknown *m_pPosition;	// CPosPassThru
public:

    // Constructor and destructor

    CDXTOutputPin(TCHAR *pObjName,
                   CDXTWrap *pTee,
                   HRESULT *phr,
                   LPCWSTR pPinName);

    ~CDXTOutputPin();

    DECLARE_IUNKNOWN

    // CPosPassThru
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    // Check that we can support an output type
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

    HRESULT Active();
    HRESULT Inactive();

    //
    HRESULT DecideBufferSize(IMemAllocator *pMemAllocator,
                              ALLOCATOR_PROPERTIES * ppropInputRequest);

    // Overriden to handle quality messages
    STDMETHODIMP Notify(IBaseFilter *pSender, Quality q);
};

// Class for the DXTransform Wrapper filter

class CDXTWrap: public CCritSec, public CBaseFilter,
		public ISpecifyPropertyPages,
                public IPersistPropertyBag, public CPersistStream,
		public IAMMixEffect,
		public CAMSetErrorLog,
		// for non-Dexter DXT wrapper
		public IAMDXTEffect
{

    DECLARE_IUNKNOWN

    QPARAMDATA *m_pQHead;			// list of cued effects
#ifdef DEBUG
    HRESULT DumpQ();
#endif

    IUnknown *m_punkDXTransform;
    CAUUID m_TransCAUUID;
    GUID m_DefaultEffect;

    BOOL m_fDXTMode;			// instantiated as the old DXT wrapper?

    IDirectDraw *m_pDDraw;
    IDXTransformFactory *m_pDXTransFact;

    // Let the pins access our internal state
    friend class CDXTInputPin;
    friend class CDXTOutputPin;

    // Declare an input pin.
    CDXTInputPin *m_apInput[MAX_EFFECT_INPUTS];
    int m_cInputs;
    CDXTOutputPin *m_apOutput[MAX_EFFECT_INPUTS];
    int m_cOutputs;

    CCritSec m_csDoSomething;
    HRESULT DoSomething();	// the heart that calls the transform
    HRESULT PrimeEffect(REFERENCE_TIME);// set up the correct effect

    AM_MEDIA_TYPE m_mtAccept;

    BYTE *m_pTempBuffer;	// when doing >1 transform at a time

public:

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    // This stuff is for the non-dexter DXT wrapper
    // ISpecifyPropertyPages methods
    STDMETHODIMP GetPages(CAUUID *pPages);

    // IAMDXTEffect stuff
    STDMETHODIMP SetDuration(LONGLONG llStart, LONGLONG llStop);
    STDMETHODIMP GetDuration(LONGLONG *pllStart, LONGLONG *pllStop);

    // IAMMixEffect stuff
    STDMETHODIMP SetMediaType(AM_MEDIA_TYPE *pmt);
    STDMETHODIMP GetMediaType(AM_MEDIA_TYPE *pmt);
    STDMETHODIMP SetNumInputs(int iNumInputs);
    STDMETHODIMP QParamData(REFERENCE_TIME rtStart, REFERENCE_TIME rtStop,
		REFGUID guid, IUnknown *pEffect, DEXTER_PARAM_DATA *pData);
    STDMETHODIMP Reset();
    STDMETHODIMP SetDefaultEffect(GUID *);

    CDXTWrap(TCHAR *pName,LPUNKNOWN pUnk,HRESULT *hr);
    ~CDXTWrap();

    CBasePin *GetPin(int n);
    int GetPinCount();

    // Function needed for the class factory
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    // Send EndOfStream if no input connection
    //STDMETHODIMP Run(REFERENCE_TIME tStart);
    STDMETHODIMP Pause();
    STDMETHODIMP Stop();

    // IPersistPropertyBag methods
    STDMETHOD(Load)(THIS_ LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);
    STDMETHOD(Save)(THIS_ LPPROPERTYBAG pPropBag, BOOL fClearDirty,
                    BOOL fSaveAllProperties);
    STDMETHODIMP InitNew();

    // CPersistStream
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    STDMETHODIMP GetClassID(CLSID *pClsid);
    int SizeMax();
};


// this stuff is for the non-Dexter DXT wrapper
// property page class to show list of installed effects
//
class CPropPage : public CBasePropertyPage
{
    IAMDXTEffect *m_pOpt;    	// object that we are showing options from
    HWND m_hwnd;

public:

   CPropPage(TCHAR *, LPUNKNOWN, HRESULT *);

   // create a new instance of this class
   //
   static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

   HRESULT OnConnect(IUnknown *pUnknown);
   HRESULT OnDisconnect();
   HRESULT OnApplyChanges();
   INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
};

#endif // __DXTWRAP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\gray\stdafx.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <dtbase.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\gray\stdafx.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_)
#define AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED
#define _ATL_STATIC_REGISTRY

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
//
//  To allow us to compile with warning level 4, we need to disable
//  three warnings that ATLCTL generates at this warning level.
//
#pragma warning(disable: 4510 4610 4100)
#include <atlctl.h>
#pragma warning(default: 4510 4610 4100)
#include <DXTmpl.h>
#include <streams.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\dxtwrap\property.cpp ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "dxt.h"
#include <dxtguid.c>	// MUST be included after dxtrans.h
#include "resource.h"

// constructor
//
CPropPage::CPropPage (TCHAR * pszName, LPUNKNOWN punk, HRESULT *phr) :
   CBasePropertyPage(pszName, punk, IDD_PROPERTIES, IDS_NAME)
   ,m_pOpt(NULL)
{
   DbgLog((LOG_TRACE,3,TEXT("CPropPage constructor")));
}

// create a new instance of this class
//
CUnknown *CPropPage::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CPropPage(NAME("DXT Property Page"),pUnk,phr);
}


HRESULT CPropPage::OnConnect(IUnknown *pUnknown)
{
    HRESULT hr = (pUnknown)->QueryInterface(IID_IAMDXTEffect,
                                            (void **)&m_pOpt);
    if (FAILED(hr))
        return E_NOINTERFACE;

    return NOERROR;
}


HRESULT CPropPage::OnDisconnect()
{
    if (m_pOpt)
        m_pOpt->Release();
    m_pOpt = NULL;
    return NOERROR;
}


HRESULT CPropPage::OnApplyChanges()
{
    DbgLog((LOG_TRACE,2,TEXT("Apply")));
    char ach[80];
    LONGLONG llStart, llStop;

    // !!! we're linking to msvcrt
    // !!! UNICODE compile?
    GetDlgItemTextA(m_hwnd, IDC_STARTTIME, ach, 80);
    double d = atof(ach);
    llStart = (LONGLONG)d;
    GetDlgItemTextA(m_hwnd, IDC_ENDTIME, ach, 80);
    d = atof(ach);
    llStop = (LONGLONG)d;
    llStart *= 10000; llStop *= 10000;
    HRESULT hr = m_pOpt->SetDuration(llStart, llStop);
    if (hr != S_OK) {
	MessageBox(NULL, TEXT("Error initializing transform"),
						TEXT("Error"), MB_OK);
    }
    return NOERROR;
}


// Handles the messages for our property window
//
INT_PTR CPropPage::OnReceiveMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = E_FAIL;

    switch (uMsg) {
        case WM_INITDIALOG:

            DbgLog((LOG_TRACE,5,TEXT("Initializing the Dialog Box")));

	    LONGLONG llStart, llStop;
	    TCHAR ach[80];
	    BOOL fCanSetLevel, fVaries;
	    int nPercent, nType, nCaps;
	    float fl;
	    m_pOpt->GetDuration(&llStart, &llStop);
	    llStart /= 10000; llStop /= 10000;
	    wsprintf(ach, TEXT("%d"), (int)llStart);
	    SetDlgItemText(hwnd, IDC_STARTTIME, ach);
	    wsprintf(ach, TEXT("%d"), (int)llStop);
	    SetDlgItemText(hwnd, IDC_ENDTIME, ach);
	    m_hwnd = hwnd;
            return TRUE;

	case WM_COMMAND:
            UINT uID = GET_WM_COMMAND_ID(wParam,lParam);
            UINT uCMD = GET_WM_COMMAND_CMD(wParam,lParam);

	    // we're dirty if anybody plays with these controls
	    if (uID == IDC_STARTTIME || uID == IDC_ENDTIME ||
				uID == IDC_CONSTANT || uID == IDC_VARIES ||
				uID == IDC_LEVEL) {
		m_bDirty = TRUE;
	    }
	    break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\gray\gray.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// DxtGray.cpp : Implementation of CDxtGray
#include "stdafx.h"
#include "GrayDll.h"
#include "Gray.h"
#include <stdlib.h>

BYTE RandomBuffer[777];
long g_Counter = 0;

/////////////////////////////////////////////////////////////////////////////
// CDxtGray

CDxtGray::CDxtGray( )
{
    m_ulMaxImageBands = 1;
    m_ulMaxInputs = 1;
    m_ulNumInRequired = 1;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;
    for( int i = 0 ; i < 777 ; i++ )
    {
        RandomBuffer[i] = rand( );
    }
}

CDxtGray::~CDxtGray( )
{
}

HRESULT CDxtGray::OnSetup( DWORD dwFlags )
{        
    HRESULT hr;
    CDXDBnds InBounds(InputSurface(0), hr);
    m_nInputWidth = InBounds.Width( );
    m_nInputHeight = InBounds.Height( );

    CDXDBnds OutBounds(OutputSurface(), hr );
    m_nOutputWidth = OutBounds.Width( );
    m_nOutputHeight = OutBounds.Height( );

    if( m_nOutputWidth > m_nInputWidth )
    {
        m_nOutputWidth = m_nInputWidth;
    }
    if( m_nOutputHeight > m_nInputHeight )
    {
        m_nOutputHeight = m_nInputHeight;
    }

    return NOERROR;
}

HRESULT CDxtGray::FinalConstruct( )
{
    HRESULT hr;

    m_ulMaxImageBands = 1;
    m_ulMaxInputs = 1;
    m_ulNumInRequired = 1;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;

    hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(), &m_pUnkMarshaler.p );
    return hr;
}

HRESULT CDxtGray::WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue )
{
    HRESULT hr = S_OK;

    //--- Get input sample access pointer for the requested region.
    //    Note: Lock may fail due to a lost surface.
    CComPtr<IDXARGBReadPtr> pInput;
    hr = InputSurface( 0 )->LockSurface( &WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                         IID_IDXARGBReadPtr, (void**)&pInput, NULL );
    if( FAILED( hr ) ) return hr;

    //--- Put a write lock only on the region we are updating so multiple
    //    threads don't conflict.
    //    Note: Lock may fail due to a lost surface.
    CComPtr<IDXARGBReadWritePtr> pOut;
    hr = OutputSurface()->LockSurface( &WI.OutputBnds, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                       IID_IDXARGBReadWritePtr, (void**)&pOut, NULL );
    if( FAILED( hr ) ) return hr;

    //--- Allocate a working buffer
    ULONG Width = WI.DoBnds.Width();
    ULONG Height = WI.DoBnds.Height();

    // allocate a scratch buffer fer us
    //
    DXPMSAMPLE *pOverlayBuffer = DXPMSAMPLE_Alloca( Width );
    DXPMSAMPLE *pScratchBuffer = DXPMSAMPLE_Alloca( Width );

    // no dithering
    //
    if (DoDither())
    {
        return 0;
    }

    float Percent = 1.0;
    get_Progress( &Percent );
    BYTE Bound = Percent * 255;
    if( Bound == 0 )
    {
        Bound = 1;
    }

    for( long OutY = 0 ; OutY < Height ; ++OutY )
    {
        pInput->MoveToRow( OutY );
        pInput->UnpackPremult( pOverlayBuffer, Width, FALSE );

        for( long x = 0 ; x < Width ; x++ )
        {
            pOverlayBuffer[x].Red += RandomBuffer[g_Counter++] % Bound;
            pOverlayBuffer[x].Green += RandomBuffer[g_Counter++] % Bound;
            pOverlayBuffer[x].Blue += RandomBuffer[g_Counter++] % Bound;
            if( g_Counter >= 770 )
            {
                g_Counter = rand( ) % 100;
            }
        }

        pOut->MoveToRow( OutY );
        pOut->PackPremultAndMove( pOverlayBuffer, Width );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\gray\resource.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DxtGrayDll.rc
//
#define IDS_PROJNAME                    100
#define IDR_DxtGray                    101
#define IDS_TITLEDxtGrayPP             102
#define IDS_HELPFILEDxtGrayPP          103
#define IDS_DOCSTRINGDxtGrayPP         104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         205
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\dxtwrap\dxt.cpp ===
/*

This filter wraps DirectX Transforms.  It has the DXT take the bits we receive
and do the transform, and output its bits right into the buffer we deliver
downstream (no extra data copies).

It can host 1 input or 2 input DXTs.  It can host multiple at a time.

For 1 input:  it can host any number of them, each with its own lifetime.  If
these times overlap, it will perform all the effects in sequence.

For 2 input:  it can host any number of them at different times, as long as
the times don't overlap.  (It can be a different DXT at different times)

*/


//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>

// you MUST include these IID's BEFORE including qedit.h because it includes
// these header files and when ddraw.h is included BEFORE encountering an
// <initguid.h>, it will not be included the second time and you will not
// be able to link
//
#ifdef FILTER_DLL
    #include <initguid.h>
    #include <ddrawex.h>
    #include <ddraw.h>
    #include <d3d.h>
    #include <d3drm.h>
#endif

#include <qeditint.h>
#include <qedit.h>

#ifdef FILTER_DLL
    #include "..\..\idl\qedit_i.c"
#endif

#include <dxbounds.h>

#include "dxt.h"

const int TRACE_HIGHEST = 2;
const int TRACE_MEDIUM = 3;
const int TRACE_LOW = 4;
const int TRACE_LOWEST = 5;

const AMOVIESETUP_MEDIATYPE sudPinTypes =
{
    &MEDIATYPE_Video,        // Major CLSID
    &MEDIASUBTYPE_NULL       // Minor type
};

const AMOVIESETUP_PIN psudPins[] =
{
    { L"Input",             // Pin's string name
      FALSE,                // Is it rendered
      FALSE,                // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Output",            // Connects to pin
      1,                    // Number of types
      &sudPinTypes },       // Pin information
    { L"Output",           // Pin's string name
      FALSE,                // Is it rendered
      TRUE,                 // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Input",             // Connects to pin
      1,                    // Number of types
      &sudPinTypes }       // Pin information
};

const AMOVIESETUP_FILTER sudDXTWrap =
{
    &CLSID_DXTWrap,       // CLSID of filter
    L"DirectX Transform Wrapper",          // Filter's name
    MERIT_DO_NOT_USE,       // Filter merit
    2,                      // Number of pins
    psudPins                // Pin information
};

#ifdef FILTER_DLL
//
// Provide the ActiveMovie templates for classes supported by this DLL.
//
CFactoryTemplate g_Templates[] =
{
    {L"DirectX Transform Wrapper",                  &CLSID_DXTWrap,
        CDXTWrap::CreateInstance, NULL, &sudDXTWrap },
    {L"DirectX Transform Wrapper Property Page",    &CLSID_DXTProperties,
	CPropPage::CreateInstance, NULL, NULL}
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);
#endif

// Using this pointer in constructor
#pragma warning(disable:4355)

//
// CreateInstance
//
// Creator function for the class ID
//
CUnknown * WINAPI CDXTWrap::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CDXTWrap(NAME("DirectX Transform Wrapper"), pUnk, phr);
}

// ================================================================
// CDXTWrap Constructor
// ================================================================

CDXTWrap::CDXTWrap(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) :
    m_pQHead(NULL),	// no queued effects
    m_cInputs(0),	// no pins
    m_cOutputs(0),
    m_punkDXTransform(NULL),
    m_pDXTransFact(NULL),
    m_pTempBuffer(NULL),
    m_DefaultEffect( GUID_NULL ),
    // DXTMode means we were created by choosing a specific effect from one of
    // the effects categories.  In this mode, we are always this effect, and we
    // have a property page.  Otherwise, we are created empty with no pins and
    // need to be programmed to be useful.
    m_fDXTMode(FALSE),
    CBaseFilter(NAME("DirectX Transform Wrapper"), pUnk, this, CLSID_DXTWrap),
    CPersistStream(pUnk, phr)
{
    ASSERT(phr);

    DbgLog((LOG_TRACE,3,TEXT("CDXTWrap constructor")));
    // do not accept connections until somebody tells us what media type to use
    ZeroMemory(&m_mtAccept, sizeof(AM_MEDIA_TYPE));
    m_mtAccept.majortype = GUID_NULL;
    m_TransCAUUID.cElems = 0;
    m_TransCAUUID.pElems = NULL;
}


//
// Destructor
//
CDXTWrap::~CDXTWrap()
{
    while (m_cInputs--) delete m_apInput[m_cInputs];
    while (m_cOutputs--) delete m_apOutput[m_cOutputs];
    QPARAMDATA *p = m_pQHead, *p2;
    while (p) {
	p2 = p->pNext;
	if (p->Data.pSetter)
	    p->Data.pSetter->Release();
	delete p;
 	p = p2;
    }
    if (m_punkDXTransform)
	m_punkDXTransform->Release();
    if (m_TransCAUUID.pElems)
	CoTaskMemFree(m_TransCAUUID.pElems);
    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXTWrap destructor")));
    FreeMediaType( m_mtAccept );
}


//
// GetPinCount
//
int CDXTWrap::GetPinCount()
{
    //DbgLog((LOG_TRACE,TRACE_MEDIUM+1,TEXT("GetPinCount = %d"), m_cInputs + m_cOutputs));
    return (m_cInputs + m_cOutputs);
}


//
// GetPin
//
CBasePin *CDXTWrap::GetPin(int n)
{
    //DbgLog((LOG_TRACE,TRACE_MEDIUM+1,TEXT("GetPin(%d)"), n));

    if (n < 0 || n >= m_cInputs + m_cOutputs)
        return NULL ;

    if (n < m_cInputs)
	return m_apInput[n];
    else
	return m_apOutput[n - m_cInputs];
}


// Pause
//
STDMETHODIMP CDXTWrap::Pause()
{
    CAutoLock cObjectLock(m_pLock);
    HRESULT hr;

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXTWrap::Pause")));

    if (m_cInputs == 0) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("NO PINS - nothing to do")));
	return S_OK;
    }
    int j = 0;
    for (int i = 0; i < m_cInputs; i++) {
	if (m_apInput[i]->IsConnected())
	    j++;
    }
    // if anything is connected, everything better be
    if (j > 0 && j < m_cInputs)
	return VFW_E_NOT_CONNECTED;
    if (j > 0 && !m_apOutput[0]->IsConnected())
 	return VFW_E_NOT_CONNECTED;
    if (j == 0 && m_cOutputs && m_apOutput[0]->IsConnected())
 	return VFW_E_NOT_CONNECTED;

    if (m_State == State_Stopped) {

        // Make a transform factory for our pins to use
        hr = CoCreateInstance(CLSID_DXTransformFactory, NULL, CLSCTX_INPROC,
			IID_IDXTransformFactory, (void **)&m_pDXTransFact);
        if (hr != S_OK) {
            DbgLog((LOG_ERROR,1,TEXT("Error instantiating transform factory")));
	    return hr;
	}

	// Let the pins create their DXSurfaces using the factory
        hr = CBaseFilter::Pause();
	if (FAILED(hr)) {
	    m_pDXTransFact->Release();
	    m_pDXTransFact = NULL;
	    return hr;
	}

        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Pause complete")));
	return NOERROR;
    }

    return CBaseFilter::Pause();
}


// Stop
//
STDMETHODIMP CDXTWrap::Stop()
{
    CAutoLock cObjectLock(m_pLock);
    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXTWrap::Stop")));

    // do this now so future receives will fail, or they will blow up after
    // we free everything
    m_State = State_Stopped;

    // Now, call Inactive on every pin

    HRESULT hr = NOERROR;
    int cPins = GetPinCount();
    for (int c = 0; c < cPins; c++) {
	CBasePin *pPin = GetPin(c);
        if (pPin->IsConnected()) {
            HRESULT hrTmp = pPin->Inactive();
            if (FAILED(hrTmp) && SUCCEEDED(hr)) {
                    hr = hrTmp;
            }
        }
    }

    // all done with these !!! leave them open?
    QPARAMDATA *p = m_pQHead;
    while (p) {
        if (p->pDXT)
	    p->pDXT->Release();
        p->pDXT = NULL;
	p = p->pNext;
    }
    if (m_pDXTransFact)
	m_pDXTransFact->Release();
    m_pDXTransFact = NULL;
    if (m_pTempBuffer)
	QzTaskMemFree(m_pTempBuffer);
    m_pTempBuffer = NULL;

    return hr;
}


// IPersistPropertyBag - This means somebody is creating us by choosing an
// 	effect from one of the effect categories.
//
STDMETHODIMP CDXTWrap::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("DXTWrap::Load")));

    CAutoLock cObjectLock(m_pLock);
    if(m_State != State_Stopped) {
        return VFW_E_WRONG_STATE;
    }
    if (pPropBag == NULL) {
	return E_INVALIDARG;
    }
    ASSERT(m_pQHead == NULL);
    if (m_pQHead)
	return E_UNEXPECTED;

    GUID guid;
    int  iNumInputs;
    VARIANT var;
    var.vt = VT_BSTR;
    HRESULT hr = pPropBag->Read(L"guid", &var, 0);
    if(SUCCEEDED(hr)) {
	CLSIDFromString(var.bstrVal, &guid);
        SysFreeString(var.bstrVal);
        var.vt = VT_I4;
        HRESULT hr = pPropBag->Read(L"inputs", &var, 0);
        if(SUCCEEDED(hr))
        {
            DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Entering DXT wrapper Mode...")));

	    // first, we are told how many inputs we have
	    iNumInputs = var.lVal;
	    SetNumInputs(iNumInputs);

	    // by default, the effect lasts for 10 seconds
	    DEXTER_PARAM_DATA dpd;
	    ZeroMemory(&dpd, sizeof(dpd));
	    dpd.rtStart = 0;
	    dpd.rtStop = 10*UNITS;
	    dpd.fSwapInputs = FALSE;
	    hr = QParamData(0, MAX_TIME, guid, NULL, &dpd);
	    if (FAILED(hr)) {
        	DbgLog((LOG_ERROR,1,TEXT("*** ??? Bad Effect ???")));
		return hr;
	    }

	    // we need to keep this effect created for all time, so the property
	    // pages will work.
    	    hr = CoCreateInstance(guid, (IUnknown *)(IBaseFilter *)this,
		CLSCTX_INPROC, IID_IUnknown, (void **)&m_punkDXTransform);
	    if (FAILED(hr)) {
        	DbgLog((LOG_ERROR,1,TEXT("*** Can't create effect")));
		return hr;
	    }

	    // we provide a property page to set more reasonable level/durations
    	    ISpecifyPropertyPages *pSPP;
    	    hr = m_punkDXTransform->QueryInterface(IID_ISpecifyPropertyPages,
							(void **)&pSPP);
    	    if (SUCCEEDED(hr)) {
	        pSPP->GetPages(&m_TransCAUUID);
	        pSPP->Release();
    	    }

	    // we default to this
	    AM_MEDIA_TYPE mt;
	    ZeroMemory(&mt, sizeof(AM_MEDIA_TYPE));
            mt.majortype = MEDIATYPE_Video;
            mt.subtype = MEDIASUBTYPE_RGB32;
            mt.formattype = FORMAT_VideoInfo;
            mt.bFixedSizeSamples = TRUE;
            mt.bTemporalCompression = FALSE;
            mt.pbFormat = (BYTE *)QzTaskMemAlloc(SIZE_PREHEADER +
						sizeof(BITMAPINFOHEADER));
            mt.cbFormat = SIZE_PREHEADER + sizeof(BITMAPINFOHEADER);
            ZeroMemory(mt.pbFormat, mt.cbFormat);
            LPBITMAPINFOHEADER lpbi = HEADER(mt.pbFormat);
            lpbi->biSize = sizeof(BITMAPINFOHEADER);
            lpbi->biCompression = BI_RGB;
            lpbi->biBitCount = 32;
	    lpbi->biWidth = 320;
  	    lpbi->biHeight = 240;
            lpbi->biPlanes = 1;
            lpbi->biSizeImage = DIBSIZE(*lpbi);
            mt.lSampleSize = DIBSIZE(*lpbi);
	    // !!! AvgTimePerFrame?  dwBitRate?
	    SetMediaType(&mt);
	    FreeMediaType(mt);

	    // do this AFTER calling QParamData
	    m_fDXTMode = TRUE;	// instantiated with Load
	}
    }

    // we might be loaded with an empty bag, that's no problem
    return S_OK;
}

#if 0
class CNestedPropertyBag : public IPropertyBag, public CUnknown
{
public:
    DECLARE_IUNKNOWN

    IPropertyBag *m_pBag;
    WCHAR m_wszPrefix[256];
    int m_iPrefixLen;

    CNestedPropertyBag(WCHAR *pwszPrefix, IPropertyBag *pBag) : CUnknown(NAME("property bag"), NULL),
            m_pBag(pBag)
            {  lstrcpyW(m_wszPrefix, pwszPrefix); m_iPrefixLen = lstrlenW(m_wszPrefix); }

    ~CNestedPropertyBag() {  };

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv) {
	if (riid == IID_IPropertyBag) {
	    return GetInterface((IPropertyBag *) this, ppv);
	} else {
	    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
	}
    };

    STDMETHOD(Read)(LPCOLESTR pszPropName, VARIANT *pvar, IErrorLog* pErrorLog) {
        lstrcpyW(m_wszPrefix + m_iPrefixLen, pszPropName);

        HRESULT hr = m_pBag->Read(m_wszPrefix, pvar, pErrorLog);

        m_wszPrefix[m_iPrefixLen] = L'\0';

        return hr;
    }

    STDMETHOD(Write)(LPCOLESTR pszPropName, VARIANT *pVar) {
        lstrcpyW(m_wszPrefix + m_iPrefixLen, pszPropName);

        HRESULT hr = m_pBag->Write(m_wszPrefix, pVar);

        m_wszPrefix[m_iPrefixLen] = L'\0';

        return hr;
    }
};
#endif

STDMETHODIMP CDXTWrap::Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty,
    BOOL fSaveAllProperties)
{
#if 1
    // E_NOTIMPL is not a valid return code as any object implementing
    // this interface must support the entire functionality of the
    // interface. !!!
    return E_NOTIMPL;
#else

// !!! INCOMPLETE - no properties saved, etc.

    VARIANT v;

    V_VT(&v) = VT_I4; V_I4(v) = 2;
    pPropBag->Write(L"version", &v);
    V_VT(&v) = VT_I4; V_I4(v) = m_cInputs;
    pPropBag->Write(L"pins", &v);
    V_VT(&v) = VT_I4; V_I4(v) = m_fDXTMode;
    pPropBag->Write(L"dxtmode", &v);

    // how many effects are queued?
    QPARAMDATA *p = m_pQHead;
    int count = 0;
    while (p) {
        WCHAR wszProp[50];
        wsprintfW(wszProp, L"eff%d", count);

        CNestedPropertyBag pNestedBag(wszProp, pPropBag);




        count++;
    }

    px->count = 0;
    p = m_pQHead;
    while (p) {
	px->qp[px->count] = *p;
	// These pointers can't be persisted
	px->qp[px->count].pNext = NULL;
	px->qp[px->count].pEffect = NULL;
	//px->qp[px->count].Data.pCallback = NULL;
	px->qp[px->count].Data.pSetter = NULL;
	px->qp[px->count].Data.pData = NULL;	// !!!
        px->count++;
	p = p->pNext;
    }
    px->mt = m_mtAccept;
    // Can't persist pointers
    px->mt.pbFormat = NULL;
    px->mt.pUnk = NULL;		// !!!
    // put the media type format at the end of the array
    CopyMemory(&px->qp[px->count], m_mtAccept.pbFormat, m_mtAccept.cbFormat);

    HRESULT hr = pStream->Write(px, savesize, 0);
    QzTaskMemFree(px);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** WriteToStream FAILED")));
        return hr;
    }

#endif
}

STDMETHODIMP CDXTWrap::InitNew()
{
    // fine. just call load
    return S_OK;
}

#ifdef FILTER_DLL
//
// DllRegisterServer
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );
}


//
// DllUnregisterServer
//
STDAPI
DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );
}
#endif


// override this to say what interfaces we support where
//
STDMETHODIMP CDXTWrap::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    // this stuff is for the non-Dexter DXT wrapper
    // for our property page - only offer this for DXT wrapper mode
    if (riid == IID_ISpecifyPropertyPages && m_fDXTMode) {
        return GetInterface((ISpecifyPropertyPages *)this, ppv);
    } else if (riid == IID_IAMDXTEffect) {
        return GetInterface((IAMDXTEffect *)this, ppv);

    // to persist the transform we are using
    } else if (riid == IID_IPersistStream) {
        return GetInterface((IPersistStream *)this, ppv);
    } else if (riid == IID_IPersistPropertyBag) {
        return GetInterface((IPersistPropertyBag *)this, ppv);
    } else if (riid == IID_IAMMixEffect) {
        return GetInterface((IAMMixEffect *)this, ppv);
    } else if (riid == IID_IAMSetErrorLog) {
        return GetInterface((IAMSetErrorLog *)this, ppv);
    }

    // pass it along to the transform - its property page QI's come through us
    if (m_fDXTMode && m_punkDXTransform && riid != IID_IUnknown) {
	HRESULT hr = m_punkDXTransform->QueryInterface(riid, ppv);

  	if (SUCCEEDED(hr))
	    return hr;
    }

    // nope, try the base class.
    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
}


HRESULT VariantFromGuid(VARIANT *pVar, BSTR *pbstr, GUID *pGuid)
{
    WCHAR wszClsid[50];
    StringFromGUID2(*pGuid, wszClsid, 50);
    VariantInit(pVar);
    HRESULT hr = NOERROR;
    *pbstr = SysAllocString( wszClsid );
    if( !pbstr )
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        pVar->vt = VT_BSTR;
        pVar->bstrVal = *pbstr;
    }
    return hr;
}


// This function is called to make sure we have opened and initialized all
// the DXTs we need to use at this point in time (rtStart)
//
// S_OK    == all set up
// S_FALSE == eat this sample, nothing to do
// E_????? == oops
//
HRESULT CDXTWrap::PrimeEffect(REFERENCE_TIME rtStart)
{
    QPARAMDATA *pQ = m_pQHead;
    BOOL fFound = FALSE;
    HRESULT hr;

    // walk through the list of all effects we are hosting
    // make sure that all the effects needed at this time are open
    while (pQ) {
	// oh look, a transform that we need to use at this time
	if (pQ->rtStart <= rtStart && rtStart < pQ->rtStop) {
	    fFound = TRUE;

	    // it hasn't been opened yet!
	    if (pQ->pDXT == NULL) {
    	        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXT: %dms - Setup a new transform"),
					(int)(rtStart / 10000)));

		// In DXT mode, we host one DXT only, and we've already opened
		// it.
    		if (m_fDXTMode && m_punkDXTransform) {
		    // in DXTMode, the effect was already created. Just QI.
        	    hr = m_punkDXTransform->QueryInterface(IID_IDXTransform,
		                                (void **)&pQ->pDXT);
    		} else {
                    if (!pQ->pEffectUnk) {

                        // cannot reuse dxts because we cannot reset
                        // their state

                        hr = CoCreateInstance( pQ->EffectGuid, NULL,
                                               CLSCTX_INPROC, IID_IDXTransform,
                                               (void **)&pQ->pDXT );
                        if (FAILED(hr)) {
                            // the effect they gave us was bad!
                            VARIANT var;
                            BSTR bstr;
                            VariantFromGuid(&var, &bstr, &pQ->EffectGuid);
                            _GenerateError(2, DEX_IDS_INVALID_DXT,
                                           E_INVALIDARG, &var);
                            if (var.bstrVal)
                                SysFreeString(var.bstrVal);
                        }
                        if (FAILED(hr) && (m_DefaultEffect != GUID_NULL)) {
                            // the effect they gave us was bad!  Try default
                            //
                            pQ->EffectGuid = m_DefaultEffect;
                            hr = CoCreateInstance(m_DefaultEffect, NULL,
                                                  CLSCTX_INPROC, IID_IDXTransform,
                                                  (void**) &pQ->pDXT );
                            if (FAILED(hr)) {
                                VARIANT var;
                                BSTR bstr;
                                VariantFromGuid(&var,&bstr,&pQ->EffectGuid);
                                _GenerateError(2,DEX_IDS_INVALID_DEFAULT_DXT
                                               ,E_INVALIDARG, &var);
                                if (var.bstrVal)
                                    SysFreeString(var.bstrVal);
                            }
			}
    		    } else {
			hr = pQ->pEffectUnk->QueryInterface(IID_IDXTransform,
							(void **)&pQ->pDXT);
			// !!! Need to fallback on default if this is bad?
		    }
                }
    		if (FAILED(hr)) {
        	    DbgLog((LOG_ERROR,1,TEXT("*** ERROR making transform")));
		    return hr;
    		}

                // ask the transform if it can REALLY vary over time
                //
                IDXEffect *pDXEffect;
                pQ->fCanDoProgress = TRUE;
                hr = pQ->pDXT->QueryInterface(IID_IDXEffect, (void **)&pDXEffect);
                if (hr != NOERROR)
                {
                    DbgLog((LOG_ERROR,1,TEXT("QI for IDXEffect didn't work, effect will not vary")));
                    pQ->fCanDoProgress = FALSE;
                } else {
		    pDXEffect->Release();
		}

    		// initialize the transform we're hosting with the surfaces.
    		// initialize until we hit an unconnected pin.
    		IUnknown *pIn[MAX_EFFECT_INPUTS];
    		IUnknown *pOut[MAX_EFFECT_OUTPUTS];
    		int cIn = 0, cOut = 0;
    		for (int i = 0; i < m_cInputs; i++) {
		    if (m_apInput[i]->IsConnected()) {
			// maybe we want to switch the inputs around
                        // !?! whoever wrote the following 2 lines of code should be shot.
	    		pIn[i] = m_apInput[pQ->Data.fSwapInputs ? m_cInputs
				 -1 - i : i] ->m_pDXSurface;
	    		cIn++;
		    } else {
	    		break;
		    }
    		}
    		for (i = 0; i < m_cOutputs; i++) {
		    if (m_apOutput[i]->IsConnected()) {
        	        pOut[i] = m_apOutput[i]->m_pDXSurface;
	    		cOut++;
		    } else {
	    		break;
		    }
    		}

    	 	// nothing connected? nothing to do.  If we only have an
    	 	// output connected, we need the CreateTransform to fail so that
    	 	// the renderer won't be expecting frames and hang
    	 	ASSERT(cIn != 0 && cOut != 0);

		// now set the static properties BEFORE INTITIALIZING the
		// transform to avoid this call making it re-initialize
                if (pQ->Data.pSetter) {
                    CComQIPtr< IAMSetErrorLog, &IID_IAMSetErrorLog > pLogger( pQ->Data.pSetter );
                    if( pLogger )
                    {
                        pLogger->put_ErrorLog( m_pErrorLog );
                    }
                    hr = pQ->Data.pSetter->SetProps(pQ->pDXT, -1);
                    if (FAILED(hr)) {
                        DbgLog((LOG_ERROR,0,TEXT("* ERROR setting static properties")));
                    }
                }

    		hr = m_pDXTransFact->InitializeTransform(pQ->pDXT,
					pIn, cIn, pOut, cOut, NULL, NULL);
    		if (hr != S_OK) {
        	    DbgLog((LOG_ERROR,0,TEXT("* ERROR %x transform SETUP"),hr));
		    VARIANT var;
		    BSTR bstr;
		    VariantFromGuid(&var, &bstr, &pQ->EffectGuid);
		    _GenerateError(2, DEX_IDS_BROKEN_DXT, E_INVALIDARG,&var);
		    return hr;
    		}

    		// tell the transform that outputs are uninitialized
    		DWORD dw;
    		hr = pQ->pDXT->GetMiscFlags(&dw);
    		dw &= ~DXTMF_BLEND_WITH_OUTPUT;
    		hr = pQ->pDXT->SetMiscFlags((WORD)dw);
    		if (hr != S_OK) {
        	    DbgLog((LOG_ERROR,0,TEXT("* ERROR setting output flags")));
		    VARIANT var;
		    BSTR bstr;
		    VariantFromGuid(&var, &bstr, &pQ->EffectGuid);
		    _GenerateError(2, DEX_IDS_BROKEN_DXT, E_INVALIDARG,&var);
		    return hr;
    		}

    		DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("*** New Transform is all setup!")));
	    }
	}
	pQ = pQ->pNext;
    }

    // no effect at this time
    if (fFound == FALSE)
	return S_FALSE;

    return S_OK;
}


// This is the function that executes the transform, called once all inputs
// are ready
//
HRESULT CDXTWrap::DoSomething()
{
    HRESULT hr;

    // only want one pin in here at a time
    CAutoLock cObjectLock(&m_csDoSomething);

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXTWrap::DoSomething")));

    // If another pin was waiting for this lock, the work might already have
    // been done by the pin that had the lock

    for (int n = 0; n < m_cInputs; n++) {
	if (m_apInput[n]->IsConnected() &&
					!m_apInput[n]->m_fSurfaceFilled) {
   	    DbgLog((LOG_ERROR,1,TEXT("*** DoSomething has nothing to do")));
	    return NOERROR;
	}
    }

    // give our outputs the same time stamps as our first input
    IMediaSample *pOutSample[MAX_EFFECT_OUTPUTS];
    for (n = 0; n < m_cOutputs; n++) {
	pOutSample[n] = NULL;
    }
    LONGLONG llStart, llStop;
    llStart = m_apInput[0]->m_llSurfaceStart;
    llStop = m_apInput[0]->m_llSurfaceStop;

    // when we calculate when to show an effect, we include newsegment offset.
    // when we deliver downstream, we don't
    // !!! what if the pins have different new segments?
    REFERENCE_TIME DeliverStart = llStart - m_apInput[0]->m_tStart;
    REFERENCE_TIME DeliverStop = llStop - m_apInput[0]->m_tStart;

    // assume we're just going to pass through the data without using a DXT
    BOOL fCallTransform = FALSE;

    // not the first time through the loop of all transforms to call
    BOOL fWasCalled = FALSE;

    QPARAMDATA *pQ = m_pQHead;
    int count = 0;
    int iteration = 0;

    // make sure the right effects for this time are loaded and set up
    hr = PrimeEffect(llStart);
    if (FAILED(hr))
	goto DoError;
    if (hr == S_FALSE)
	goto Swallow;	// nothing to do... eat these samples

    // count how many transforms we need to do consecutively right now
    while (pQ) {
        // this effect is active now! (inside the active period)
        if (pQ->Data.rtStart <= llStart && llStart < pQ->Data.rtStop) {
	    count++;
	}
      pQ = pQ->pNext;
    }

    // we need a temp buffer to do multiple transforms
    if (count > 1 && m_pTempBuffer == NULL) {
	int iSize = m_apInput[0]->m_pSampleHeld->GetActualDataLength();
	m_pTempBuffer = (BYTE *)QzTaskMemAlloc(iSize);
	if (m_pTempBuffer == NULL) {
            hr = E_OUTOFMEMORY;
            goto DoError;
        }
    }

    // Get all our output samples
    for (n = 0; n < m_cOutputs; n++) {
	// !!! we're supposed to deliver immediately after calling this to make
	// the video renderer happy with DDraw, but we're not doing that.
        hr = m_apOutput[n]->GetDeliveryBuffer(&pOutSample[n], &DeliverStart,
							&DeliverStop, 0);
	if (hr != S_OK) {
   	    DbgLog((LOG_ERROR,1,TEXT("Error from GetDeliveryBuffer")));
	    goto DoError;
	}
    }

    // now call all the transforms we need to call, in the right order
    //

    // Here's how it works:  If we are only doing one DXT, we do it from the
    // input to the output.  If we have 2 DXTs to do, we do #1 from the input
    // to a temp buffer, and #2 from the temp buffer to the output.  If we have
    // 3 DXTs to do, we do #1 from the input to the output, #2 from the output
    // to the temp buffer, and #3 from the temp buffer to the output.  (Always
    // make sure we end up in the output buffer, and NEVER hurt the input bits
    // because they are usually read only!  In order to figure out which
    // place to get the input bits, and where to put the output bits, involves
    // basically seeing if the total count of DXTs we are doing, and this
    // current iteration (eg #2 of 3) are both even or both odd, or different.

    // We only allow multiple DXTs to be used at once like this for 1 input
    // effects.  The situation will never come up for 2 input.

    pQ = m_pQHead;
    while (pQ) {

       // this effect is active now! (inside the active period)
       if (pQ->Data.rtStart <= llStart && llStart < pQ->Data.rtStop) {

	  iteration++;	// which transform is this? (total to do is "count")

	  fCallTransform = TRUE;	// we will be calling a transform today
	  fWasCalled = TRUE;

    	  // what % of effect do we want at this time?
    	  float Percent;
    	  if (llStart == pQ->Data.rtStart)
	    Percent = 0.;
    	  else
	    Percent = (float)((llStart - pQ->Data.rtStart)  * 100 /
				(pQ->Data.rtStop - pQ->Data.rtStart)) / 100;
    	  if (Percent < 0.)
	    Percent = 0.;
    	  if (Percent > 1.)
	    Percent = 1.;

          // Tell the transform where all the input surface bits are
    	  for (n = 0; n < m_cInputs && m_apInput[n]->IsConnected(); n++) {

	      DXRAWSURFACEINFO dxraw;

              BYTE *pSrc;
              hr = m_apInput[n]->m_pSampleHeld->GetPointer(&pSrc);
	      ASSERT(hr == S_OK);
              BYTE *pDst;
              hr = pOutSample[0]->GetPointer(&pDst);
	      ASSERT(hr == S_OK);
	      BYTE *p = m_pTempBuffer;

	      // where are the input bits?  depends on which iteration this is
	      if (iteration > 1) {
		  if (count / 2 * 2 == count) {
		      if (iteration / 2 * 2 != iteration)
		    	    p = pDst;
		  } else if (iteration / 2 * 2 == iteration) {
		    	p = pDst;
		  }
	      } else {
		  p = pSrc;
	      }

              // ask our input for it's raw surface interface
              //
	      IDXRawSurface *pRaw;
	      hr = m_apInput[n]->m_pRaw->QueryInterface(
				IID_IDXRawSurface, (void **)&pRaw);
	      if (hr != NOERROR) {
                  DbgLog((LOG_ERROR,1,TEXT("Can't get IDXRawSurface")));
                  goto DoError;
	      }

	      // Tell our DXSurface to use the bits in the media sample
	      // (avoids a copy!)
	      LPBITMAPINFOHEADER lpbi = HEADER(m_apInput[n]->m_mt.Format());
    	      dxraw.pFirstByte = p + DIBWIDTHBYTES(*lpbi) *
						(lpbi->biHeight - 1);

    	      dxraw.lPitch = -(long)DIBWIDTHBYTES(*lpbi);
    	      dxraw.Width = lpbi->biWidth;
    	      dxraw.Height = lpbi->biHeight;
    	      dxraw.pPixelFormat = m_apInput[n]->m_mt.Subtype();

              // since when in 32 bit mode, we really are DDPF_ARGB32, we can
              // just set the subtype

              dxraw.hdc = NULL;
    	      dxraw.dwColorKey = 0;
	      // !!! Will crash for 8 bit input
    	      dxraw.pPalette = NULL;

	      m_apInput[n]->m_pRaw->SetSurfaceInfo(&dxraw);

              // ask our pin's "surface" for an initialization pointer, so we
              // can tell it just below where it's bits are
              //
              IDXARGBSurfaceInit *pInit;
	      hr = m_apInput[n]->m_pDXSurface->QueryInterface(
				IID_IDXARGBSurfaceInit, (void **)&pInit);
	      if (hr != NOERROR) {
                  DbgLog((LOG_ERROR,1,TEXT("Can't get IDXARGBSurfaceInit")));
                  goto DoError;
	      }

              // tell the DXSurface to become the raw surface we just set up
              //
	      hr = pInit->InitFromRawSurface(pRaw);
	      if (hr != NOERROR) {
                  DbgLog((LOG_ERROR,1,TEXT("* Error in InitFromRawSurface")));
	   	  pInit->Release();
	   	  pRaw->Release();
                  goto DoError;
	      }
	      pInit->Release();
	      pRaw->Release();
	  }

          // Tell the transform where all the output surface bits are
    	  for (n = 0; n < m_cOutputs; n++) {

	        DXRAWSURFACEINFO dxraw;

                BYTE *pDst;
                hr = pOutSample[n]->GetPointer(&pDst);
		ASSERT(hr == S_OK);
		BYTE *p = pDst;

		// where do the output bits go?  depends on the iteration
		if (count / 2 * 2 == count) {
		    if (iteration / 2 * 2 != iteration)
		    	p = m_pTempBuffer;
		} else if (iteration / 2 * 2 == iteration) {
		    p = m_pTempBuffer;
		}

	        IDXRawSurface *pRaw;
	        hr = m_apOutput[n]->m_pRaw->QueryInterface(
				IID_IDXRawSurface, (void **)&pRaw);
	        if (hr != NOERROR) {
                    DbgLog((LOG_ERROR,1,TEXT("Can't get IDXRawSurface")));
                    goto DoError;
	        }

	        // Tell our DXSurface to use the bits in the media sample
	        // (avoids a copy!)
	        LPBITMAPINFOHEADER lpbi = HEADER(m_apOutput[n]->m_mt.Format());
    	        dxraw.pFirstByte = p + DIBWIDTHBYTES(*lpbi) *
						(lpbi->biHeight - 1);

    	        dxraw.lPitch = -(long)DIBWIDTHBYTES(*lpbi);
    	        dxraw.Width = lpbi->biWidth;
    	        dxraw.Height = lpbi->biHeight;
    	        dxraw.pPixelFormat = m_apOutput[n]->m_mt.Subtype();

                // since when in 32 bit mode, we really are DDPF_ARGB32, we can
                // just set the subtype

    	        dxraw.hdc = NULL;
    	        dxraw.dwColorKey = 0;
	        // !!! Will crash for 8 bit input
    	        dxraw.pPalette = NULL;

                m_apOutput[n]->m_pRaw->SetSurfaceInfo(&dxraw);

                IDXARGBSurfaceInit *pInit;
	        hr = m_apOutput[n]->m_pDXSurface->QueryInterface(
				IID_IDXARGBSurfaceInit, (void **)&pInit);
	        if (hr != NOERROR) {
                    DbgLog((LOG_ERROR,1,TEXT("Can't get IDXARGBSurfaceInit")));
                    goto DoError;
	        }

	        hr = pInit->InitFromRawSurface(pRaw);
	        if (hr != NOERROR) {
                    DbgLog((LOG_ERROR,1,TEXT("* Error in InitFromRawSurface")));
		    pInit->Release();
		    pRaw->Release();
                    goto DoError;
	        }
	        pInit->Release();
	        pRaw->Release();
	  }

	  if (pQ->fCanDoProgress) {
            IDXEffect *pDXEffect;
            hr = pQ->pDXT->QueryInterface(IID_IDXEffect,
							(void **)&pDXEffect);
            if (hr != NOERROR) {
                DbgLog((LOG_ERROR,1,TEXT("QI for IDXEffect FAILED")));
	        goto DoError;
            }

	    // do we hae specific PROGRESS values we want to set?  Then don't
	    // do the default linear curve
	    BOOL fAvoidProgress = FALSE;
	    if (pQ->Data.pSetter) {
		LONG c;
		DEXTER_PARAM *pParam;
		DEXTER_VALUE *pValue;
		hr = pQ->Data.pSetter->GetProps(&c, &pParam, &pValue);
                ASSERT( !FAILED( hr ) );
		if (SUCCEEDED(hr)) {
		    for (LONG zz=0; zz<c; zz++) {
		        if (!DexCompareW(pParam[zz].Name, L"Progress"))
			    fAvoidProgress = TRUE;
		    }
		    pQ->Data.pSetter->FreeProps(c, pParam, pValue);
		}
                else
                {
                    // !!! should we error log this, Danny?
                    DbgLog((LOG_ERROR,1,TEXT("*** GetProps FAILED!!")));
            	    pDXEffect->Release();
                    goto DoError;
                }
	    }

	    // this will get overridden by the Property Setter if there is one.
	    // Default is a linear curve
	    if (!fAvoidProgress) {
                hr = pDXEffect->put_Progress(Percent);
                if (hr != NOERROR) {
                    DbgLog((LOG_ERROR,1,TEXT("*** put_Progress FAILED!!")));
                }
	    }
            pDXEffect->Release();
	  }

	  // set the varying properties
	  if (pQ->Data.pSetter) {
                CComQIPtr< IAMSetErrorLog, &IID_IAMSetErrorLog > pLogger( pQ->Data.pSetter );
                if( pLogger )
                {
                    pLogger->put_ErrorLog( m_pErrorLog );
                }
                hr = pQ->Data.pSetter->SetProps(pQ->pDXT, llStart -
				                pQ->Data.rtStart);
                if (FAILED(hr)) {
                    DbgLog((LOG_ERROR,0,TEXT("* ERROR setting dynamic properties")));
    	      }
	  }

          long dwTime = timeGetTime();
          hr = pQ->pDXT->Execute(NULL, NULL, NULL);
          dwTime = timeGetTime() - dwTime;
          DbgLog((LOG_TIMING,TRACE_MEDIUM,TEXT("Execute: %dms"), dwTime));
          if (hr != NOERROR) {
              DbgLog((LOG_ERROR,1,TEXT("*** Execute FAILED: %x"), hr));
	      goto DoError;
          }
          DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("EXECUTED Transform: %d%%"),
						(int)(Percent * 100)));

          // Now tell DXT to stop looking in our media sample bits so we can
          // release the samples
          for (n = 0; n < m_cInputs && m_apInput[n]->IsConnected(); n++) {
	      IDXARGBSurfaceInit *pInit;
	      hr = m_apInput[n]->m_pDXSurface->QueryInterface(
				IID_IDXARGBSurfaceInit, (void **)&pInit);
	      if (hr != NOERROR) {
                  DbgLog((LOG_ERROR,1,TEXT("Can't get IDXARGBSurfaceInit")));
                  DbgLog((LOG_ERROR,1,TEXT("*** LEAKING!")));
	          ASSERT(FALSE);
	      } else {
	          pInit->InitFromRawSurface(NULL);
	          pInit->Release();
	      }
          }

          // this only needs doing if we setup the 2D stuff
          for (n = 0; n < m_cOutputs; n++) {
	      IDXARGBSurfaceInit *pInit;
	      hr = m_apOutput[n]->m_pDXSurface->QueryInterface(
				IID_IDXARGBSurfaceInit, (void **)&pInit);
	      if (hr != NOERROR) {
                  DbgLog((LOG_ERROR,1,TEXT("Can't get IDXARGBSurfaceInit")));
                  DbgLog((LOG_ERROR,1,TEXT("*** LEAKING!")));
	          ASSERT(FALSE);
	      } else {
	          pInit->InitFromRawSurface(NULL);
	          pInit->Release();
	      }
          }
      }
      pQ = pQ->pNext;
    }


    // Deliver all of our outputs
    for (n = 0; n < m_cOutputs; n++) {
	BYTE *pDst;
	hr = pOutSample[n]->GetPointer(&pDst);
	if (hr != S_OK) {
   	    DbgLog((LOG_ERROR,1,TEXT("Error from GetPointer")));
	    goto DoError;
	}

	// the output sample will be this big unless otherwise noted
	int iSize = DIBSIZE(*HEADER(m_apOutput[n]->m_mt.Format()));

	if (!fCallTransform) {

	    // If we're not in the active range of a tranform, but still in its
	    // lifetime, we follow this rule:  Before the active range, pass
	    // input A. After the active range, pass input B. There may be more
	    // than one transform alive right now, just use the first one found
	    BOOL fA = FALSE;
	    QPARAMDATA *pQ = m_pQHead;
    	    while (pQ) {
	        if (pQ->rtStart <= llStart && llStart < pQ->rtStop) {
		    if (llStart < pQ->Data.rtStart)
		        fA = TRUE;
		    break;
	        }
	        pQ = pQ->pNext;
	    }

            // Tell the transform where all the input surface bits are
	    LPBYTE pSrc;
	    if (fA) {
                hr = m_apInput[0]->m_pSampleHeld->GetPointer(&pSrc);
		// iSize is needed later in this function!
	        iSize = m_apInput[0]->m_pSampleHeld->GetActualDataLength();
	    } else if (m_cInputs > 1 && m_apInput[1]->IsConnected()) {
                hr = m_apInput[1]->m_pSampleHeld->GetPointer(&pSrc);
	        iSize = m_apInput[1]->m_pSampleHeld->GetActualDataLength();
	    } else {
                hr = m_apInput[0]->m_pSampleHeld->GetPointer(&pSrc);
	        iSize = m_apInput[0]->m_pSampleHeld->GetActualDataLength();
	    }
            if (hr != NOERROR) {
                DbgLog((LOG_ERROR,1,TEXT("*** GetSrc bits Error %x"), hr));
                goto DoError;
            }

	    // COPY memory from the src sample to the output sample
  	    // !!! make it inplace?
  	    // no funny strides?
	    DWORD dwTime = timeGetTime();
	    CopyMemory(pDst, pSrc, iSize);
	    dwTime = timeGetTime() - dwTime;
            DbgLog((LOG_TIMING,TRACE_MEDIUM,TEXT("Only copy: %dms"), dwTime));
        }

	DWORD dwTime = timeGetTime();

	// Set all the sample properties - (make sure iSize has been set)
	pOutSample[n]->SetActualDataLength(iSize);
	pOutSample[n]->SetTime((REFERENCE_TIME *)&DeliverStart,
				(REFERENCE_TIME *)&DeliverStop);
	pOutSample[n]->SetDiscontinuity(FALSE);	// !!! if input #1 is?
	pOutSample[n]->SetSyncPoint(TRUE);
	pOutSample[n]->SetPreroll(FALSE);		// !!! if input #1 is?

	// The video renderer will block us when going from run->pause
	hr = m_apOutput[n]->Deliver(pOutSample[n]);
        if (hr != NOERROR) {
            DbgLog((LOG_ERROR,1,TEXT("Deliver FAILED!")));
            goto DoError;
        }

        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Delivered output %d"), n));
    }

    for (n = 0; n < m_cOutputs; n++) {
	pOutSample[n]->Release();
	pOutSample[n] = NULL;
    }

Swallow:
    // We're done with input #1.  We're done with other inputs whose stop
    // times are not bigger than #1's stop time.
    for (n = 0; n < m_cInputs; n++) {
	// grab 'em all during the next for loop
	m_apInput[n]->m_csSurface.Lock();
    }
    for (n = 0; n < m_cInputs; n++) {
	if (n == 0) {
	    // unblock receive
            DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Done with input #0")));
	    if (m_apInput[n]->m_fSurfaceFilled) {
	        m_apInput[n]->m_fSurfaceFilled = FALSE;
	        m_apInput[n]->m_pSampleHeld->Release();
	        SetEvent(m_apInput[n]->m_hEventSurfaceFree);
	    }
	} else {
	    if (m_apInput[n]->IsConnected() &&
				(m_apInput[n]->m_llSurfaceStop == 0 ||
	    			m_apInput[n]->m_llSurfaceStop <= llStop)) {
	        // unblock receive
                DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Done with input #%d"), n));
	        if (m_apInput[n]->m_fSurfaceFilled) {
	            m_apInput[n]->m_fSurfaceFilled = FALSE;
	            m_apInput[n]->m_pSampleHeld->Release();
	            SetEvent(m_apInput[n]->m_hEventSurfaceFree);
		}
	    }
	}
    }
    for (n = 0; n < m_cInputs; n++) {
	m_apInput[n]->m_csSurface.Unlock();
    }

    return NOERROR;

DoError:
    for (n = 0; n < m_cOutputs; n++) {
        if (pOutSample[n])
            pOutSample[n]->Release();
    }

    // Release all the inputs we're holding, or we'll hang
    for (n = 0; n < m_cInputs; n++) {
	// grab 'em all during the next for loop
	m_apInput[n]->m_csSurface.Lock();
    }
    for (n = 0; n < m_cInputs; n++) {
        // unblock receive
        if (m_apInput[n]->m_fSurfaceFilled) {
            m_apInput[n]->m_fSurfaceFilled = FALSE;
            m_apInput[n]->m_pSampleHeld->Release();
            SetEvent(m_apInput[n]->m_hEventSurfaceFree);
        }
    }
    for (n = 0; n < m_cInputs; n++) {
	m_apInput[n]->m_csSurface.Unlock();
    }

    return hr;

}


		
// this stuff is for the non-Dexter DXT wrapper - we also show DXT pages too
//
STDMETHODIMP CDXTWrap::GetPages(CAUUID *pPages)
{
   CheckPointer(pPages, E_POINTER);
   DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXT::GetPages")));

   // we have one page, and the transform may have some too
   pPages->cElems = 1 + m_TransCAUUID.cElems;
   pPages->pElems = (GUID *) QzTaskMemAlloc(sizeof(GUID) * pPages->cElems);
   if ( ! pPages->pElems)
       return E_OUTOFMEMORY;

   pPages->pElems[0] = CLSID_DXTProperties;
   CopyMemory(&pPages->pElems[1], m_TransCAUUID.pElems,
					sizeof(GUID) * m_TransCAUUID.cElems);
   return NOERROR;
}


// IAMDXTEffect implementation - for the non-Dexter DXT wrapper that only does
// 	one effect

//
HRESULT CDXTWrap::SetDuration(LONGLONG llStart, LONGLONG llStop)
{
    CAutoLock cObjectLock(m_pLock);

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("IAMDXTEffect::SetDuration:")));

    if (m_pQHead == NULL)
	return E_UNEXPECTED;
    ASSERT(m_pQHead->rtStart == 0);
    ASSERT(m_pQHead->rtStop == MAX_TIME);
    m_pQHead->Data.rtStart = llStart;
    m_pQHead->Data.rtStop = llStop;
    return NOERROR;
}


HRESULT CDXTWrap::GetDuration(LONGLONG *pllStart, LONGLONG *pllStop)
{
    CAutoLock cObjectLock(m_pLock);

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("IAMDXTEffect::GetDuration:")));
    CheckPointer(pllStart, E_POINTER);
    CheckPointer(pllStop, E_POINTER);

    if (m_pQHead == NULL)
	return E_UNEXPECTED;
    ASSERT(m_pQHead->rtStart == 0);
    ASSERT(m_pQHead->rtStop == MAX_TIME);

    *pllStart = m_pQHead->Data.rtStart;
    *pllStop = m_pQHead->Data.rtStop;
    return NOERROR;
}



// tell our clsid
//
STDMETHODIMP CDXTWrap::GetClassID(CLSID *pClsid)
{
    CheckPointer(pClsid, E_POINTER);
    *pClsid = CLSID_DXTWrap;
    return S_OK;
}


typedef struct {
    int version;
    int pins;
    BOOL fDXTMode;
    int count;
    int nPropSize;	// # of bytes of properties at the end
    AM_MEDIA_TYPE mt; // format is hidden after the array
    GUID DefaultEffect;
    QPARAMDATA qp[1];
    // properties hidden after the array
} saveThing;

// persist ourself
// we save some random stuff, our media type (sans format), an array of queued
// effects, the format of the media type, and the properties
//
HRESULT CDXTWrap::WriteToStream(IStream *pStream)
{
    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXTWrap::WriteToStream")));

    CheckPointer(pStream, E_POINTER);
    HRESULT hr;
    int count = 0;
    LONG savesize;
    saveThing *px;

    QPARAMDATA *p = m_pQHead;

    LONG cSave = 0;
    LONG cSaveMax = 1000;
    BYTE *pSave = (BYTE *)CoTaskMemAlloc(cSaveMax);
    if (pSave == NULL)
	return E_OUTOFMEMORY;

    // how many effects are queued?  while we're at it, get their properties
    // and their total size (put them all in a big binary glob at pSave)
    while (p) {
	count++;	// count the number of effects in this linked list

	LONG cSaveT = 0;
	BYTE *pSaveT = NULL;

	// get the properties of this effect
	if (p->Data.pSetter) {
	    hr = p->Data.pSetter->SaveToBlob(&cSaveT, &pSaveT);
	    if (FAILED(hr)) {
		CoTaskMemFree(pSave);
		return hr;
	    }
	}

	if (cSaveT + (LONG)sizeof(LONG) + cSave > cSaveMax) {
	    cSaveMax += cSaveT + cSave - cSaveMax + 1000;
	    pSave = (BYTE *)CoTaskMemRealloc(pSave, cSaveMax);
	    if (pSave == NULL) {
		CoTaskMemFree(pSaveT);
		return E_OUTOFMEMORY;
	    }
	}

	*(LONG *)(pSave + cSave) = cSaveT;
	cSave += sizeof(LONG);

	if (cSaveT)
	    CopyMemory(pSave + cSave, pSaveT, cSaveT);
	cSave += cSaveT;

	if (pSaveT)
	    CoTaskMemFree(pSaveT);
	p = p->pNext;
    }
    DbgLog((LOG_TRACE,2,TEXT("CDXT:Total property size: %d"), cSave));

    // how many bytes do we need to save?
    savesize = sizeof(saveThing) + (count - 1) * sizeof(QPARAMDATA) +
					m_mtAccept.cbFormat + cSave;
    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Persisted data is %d bytes"), savesize));
    px = (saveThing *)QzTaskMemAlloc(savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	CoTaskMemFree(pSave);
	return E_OUTOFMEMORY;
    }
    px->version = 2;
    px->pins = m_cInputs;
    px->fDXTMode = m_fDXTMode;
    px->DefaultEffect = m_DefaultEffect;
    px->nPropSize = cSave;
    px->count = 0;

    p = m_pQHead;
    while (p) {
	px->qp[px->count] = *p;
	// These pointers can't be persisted
	px->qp[px->count].pNext = NULL;
	//px->qp[px->count].Data.pCallback = NULL;
	//px->qp[px->count].Data.pData = NULL;	// !!!
	px->qp[px->count].Data.pSetter = NULL;	// can't save them like this
        px->count++;
	p = p->pNext;
    }
    px->mt = m_mtAccept;
    // Can't persist pointers
    px->mt.pbFormat = NULL;
    px->mt.pUnk = NULL;		// !!!

    // put the media type format at the end of the array
    LPBYTE pProps = (LPBYTE)(&px->qp[px->count]);
    CopyMemory(pProps, m_mtAccept.pbFormat, m_mtAccept.cbFormat);
    pProps += m_mtAccept.cbFormat;

    // finally, put the property junk in
    if (cSave)
        CopyMemory(pProps, pSave, cSave);
    if (pSave)
        CoTaskMemFree(pSave);

    hr = pStream->Write(px, savesize, 0);
    QzTaskMemFree(px);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** WriteToStream FAILED")));
        return hr;
    }
    return NOERROR;
}


// load ourself
//
HRESULT CDXTWrap::ReadFromStream(IStream *pStream)
{
    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXTWrap::ReadFromStream")));
    CheckPointer(pStream, E_POINTER);

    Reset();	// start over

    // all we know we have for sure is the beginning of the struct (there may
    // be no queued effects)
    LONG savesize1 = sizeof(saveThing) - sizeof(QPARAMDATA);
    saveThing *px = (saveThing *)QzTaskMemAlloc(savesize1);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	return E_OUTOFMEMORY;
    }

    HRESULT hr = pStream->Read(px, savesize1, 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    if (px->version != 2) {
        DbgLog((LOG_ERROR,1,TEXT("*** ERROR! Old version file")));
        QzTaskMemFree(px);
	return S_OK;
    }

    // now we know how many queued effects are their properties are here and
    // how many more bytes we need to read
    LONG savesize = sizeof(saveThing) + (px->count - 1) * sizeof(QPARAMDATA) +
				 px->mt.cbFormat + px->nPropSize;
    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Persisted data is %d bytes"), savesize));
    DbgLog((LOG_TRACE,2,TEXT("Effect properties: %d bytes"), px->nPropSize));
    px = (saveThing *)QzTaskMemRealloc(px, savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	return E_OUTOFMEMORY;
    }
    hr = pStream->Read(&(px->qp[0]), savesize - savesize1, 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    if (px->pins)
        SetNumInputs(px->pins);

    // find the props
    BYTE *pProps = (BYTE *)&(px->qp[px->count]);
    pProps += px->mt.cbFormat;

    // program all the queued effects, including their properties
    for (int i = 0; i < px->count; i++) {

	LONG cSize = *(LONG *)pProps;
	pProps += sizeof(LONG);
        IPropertySetter *pSetter = NULL;
	if (cSize) {
            hr = CoCreateInstance(CLSID_PropertySetter, NULL, CLSCTX_INPROC,
			IID_IPropertySetter, (void **)&pSetter);
	    if (pSetter == NULL) {
        	QzTaskMemFree(px);
		return E_OUTOFMEMORY;
	    }
	    pSetter->LoadFromBlob(cSize, pProps);
	    pProps += cSize;
	}
	px->qp[i].Data.pSetter = pSetter;
	QParamData(px->qp[i].rtStart, px->qp[i].rtStop, px->qp[i].EffectGuid,
						NULL, &(px->qp[i].Data));
	if (px->qp[i].Data.pSetter)
	    px->qp[i].Data.pSetter->Release();
    }

    // This must go AFTER QParamData is called
    m_fDXTMode = px->fDXTMode;

    // in DXTMode, we have a property page, and we keep the transform open
    // constantly (for the page to work)
    if (m_fDXTMode) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Entering DXT wrapper Mode...")));
	hr = CoCreateInstance(px->qp[0].EffectGuid, (IUnknown *)(IBaseFilter *)this,
		CLSCTX_INPROC, IID_IUnknown, (void **)&m_punkDXTransform);
	if (FAILED(hr)) {
            DbgLog((LOG_ERROR,1,TEXT("*** Can't create effect")));
	    QzTaskMemFree(px);
	    return hr;
	}
    	ISpecifyPropertyPages *pSPP;
    	hr = m_punkDXTransform->QueryInterface(IID_ISpecifyPropertyPages,
							(void **)&pSPP);
    	if (SUCCEEDED(hr)) {
	    pSPP->GetPages(&m_TransCAUUID);
	    pSPP->Release();
    	}
    }

    AM_MEDIA_TYPE mt = px->mt;
    mt.pbFormat = (BYTE *)QzTaskMemAlloc(mt.cbFormat);
    // remember, the format is hidden after the array of queued effects
    CopyMemory(mt.pbFormat, &(px->qp[px->count]), mt.cbFormat);
    SetMediaType(&mt);
    FreeMediaType(mt);

    SetDefaultEffect(&px->DefaultEffect);

    QzTaskMemFree(px);
    SetDirty(FALSE);
    return S_OK;
}


// how big is our save data?
//
int CDXTWrap::SizeMax()
{
    int count = 0;
    int savesize;
    QPARAMDATA *p = m_pQHead;
    while (p) {
	count++;
	p = p->pNext;
    }
    savesize = sizeof(saveThing) + (count - 1) * sizeof(QPARAMDATA) +
						m_mtAccept.cbFormat;
    return savesize;
}


// IAMMixEffect stuff

// get rid of all queued data
//
HRESULT CDXTWrap::Reset()
{
    CAutoLock cObjectLock(m_pLock);
    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXTWrap::Reset")));

    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;

    m_fDXTMode = FALSE;	// can't use DXT wrapper mode anymore

    QPARAMDATA *p = m_pQHead, *p2;
    while (p) {
	p2 = p->pNext;
	if (p->Data.pSetter)
	    p->Data.pSetter->Release();
	if (p->pDXT)
	    p->pDXT->Release();
        if( p->pEffectUnk )
            p->pEffectUnk->Release( );
	delete p;
 	p = p2;
    }
    m_pQHead = NULL;
    SetDirty(TRUE);
    return S_OK;
}


// what media type do we connect with?
//
HRESULT CDXTWrap::SetMediaType(AM_MEDIA_TYPE *pmt)
{
    CAutoLock cObjectLock(m_pLock);
    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXT::SetMediaType")));
    CheckPointer(pmt, E_POINTER);
    CheckPointer(pmt->pbFormat, E_POINTER);

    // somebody already connected?  Too late!
    for (int i = 0; i < m_cInputs; i++) {
	if (m_apInput[i]->IsConnected())
	    return E_UNEXPECTED;
    }
    if (m_cOutputs && m_apOutput[0]->IsConnected())
	return E_UNEXPECTED;

/*
    if (m_mtAccept.majortype != GUID_NULL) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: already called")));
	return E_UNEXPECTED;
    }
*/
    if (pmt->majortype != MEDIATYPE_Video) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: not VIDEO")));
	return E_INVALIDARG;
    }
    // check this is a VIDEOINFOHEADER type
    if (pmt->formattype != FORMAT_VideoInfo) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: format not VIDINFO")));
        return E_INVALIDARG;
    }

    // !!! What if subtype doesn't match biCompression/biBitCount?

    // We only accept RGB
    if (HEADER(pmt->pbFormat)->biCompression != BI_BITFIELDS &&
    			HEADER(pmt->pbFormat)->biCompression != BI_RGB) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: Not RGB")));
	return E_INVALIDARG;
    }
    if (!HEADER(pmt->pbFormat)->biWidth || !HEADER(pmt->pbFormat)->biHeight) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: bad size")));
	return E_INVALIDARG;
    }

    // DXT cannot output 8 bit, so don't allow it

    HRESULT hr = E_INVALIDARG;
    if (HEADER(pmt->pbFormat)->biBitCount == 24)
        hr = NOERROR;
    // !!! better have alpha=11111111, or don't use alpha
    if (HEADER(pmt->pbFormat)->biBitCount == 32)
        hr = NOERROR;
    if (HEADER(pmt->pbFormat)->biBitCount == 16) {
        if (HEADER(pmt->pbFormat)->biCompression == BI_RGB)
            hr = NOERROR;
	else {
	    VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *)pmt->pbFormat;
            if (BITMASKS(pvi)[0] == 0xf800 &&
        	    BITMASKS(pvi)[1] == 0x07e0 &&
        	    BITMASKS(pvi)[2] == 0x001f) {
                hr = NOERROR;
	    }
	}
    }

    if (hr == NOERROR) {
	FreeMediaType(m_mtAccept);
        CopyMediaType(&m_mtAccept, pmt);
	SetDirty(TRUE);
    } else
        DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: bad bitcount/masks")));

    return hr;
}


// what media type are we connecting with?
//
HRESULT CDXTWrap::GetMediaType(AM_MEDIA_TYPE *pmt)
{
    CAutoLock cObjectLock(m_pLock);

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXT::GetMediaType")));
    CheckPointer(pmt, E_POINTER);
    CopyMediaType(pmt, &m_mtAccept);
    return S_OK;
}


// are we a one or two input effect?
//
HRESULT CDXTWrap::SetNumInputs(int nInputs)
{
    CAutoLock cObjectLock(m_pLock);
    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;
    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXTWrap::SetNumInputs %d"), nInputs));

    // already been called
    if (m_cInputs || m_cOutputs) {

        // it's okay if it's the same, as far as I'm concerned
        if( m_cInputs == nInputs ) return NOERROR;

	return E_UNEXPECTED;
    }

    for (int z = 0; z < nInputs; z++) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("making an input pin...")));
	WCHAR wach[80];
	wsprintfW(wach, L"DXT Input %d", m_cInputs);
        m_apInput[m_cInputs] = new CDXTInputPin(NAME("DXT input pin"),
                                          this,              // Owner filter
                                          &hr,               // Result code
                                          wach);             // Pin name

        //  Can't fail. !!! ehr - why not?
        ASSERT(SUCCEEDED(hr));
        if (m_apInput[m_cInputs] == NULL) {
            goto SetNumInputs_Error;
        }
	m_cInputs++;
    }

    // Make an output pin

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("making an output pin...")));
    WCHAR wach[80];
    wsprintfW(wach, L"DXT Output");
    m_apOutput[m_cOutputs] = new CDXTOutputPin(NAME("DXT output pin"),
                                          this,              // Owner filter
                                          &hr,               // Result code
                                          wach);             // Pin name

    //  Can't fail
    ASSERT(SUCCEEDED(hr));
    if (m_apOutput[m_cOutputs] == NULL) {
        goto SetNumInputs_Error;
    }
    m_cOutputs++;

    IncrementPinVersion();	// !!! graphedit still won't notice
    return NOERROR;

SetNumInputs_Error:
    DbgLog((LOG_ERROR,1,TEXT("*** Error making pins")));
    while (m_cInputs--) delete m_apInput[m_cInputs];
    while (m_cOutputs--) delete m_apOutput[m_cOutputs];
    return E_OUTOFMEMORY;
}


// Queue up an effect.  There are 2 start times and 2 stop times.  The lifetime
// of this particular effect is from rtStart to rtStop, and the effect will be
// turned on to some degree between pData->rtStart and pData->rtStop (which must
// be inside the lifetime).  For the lifetime of the effect that the effect is
// not turned out the effect is off (1 input) or all A or all B (2 input)
//
HRESULT CDXTWrap::QParamData(REFERENCE_TIME rtStart, REFERENCE_TIME rtStop, REFGUID guiddummy, IUnknown * pEffectUnk, DEXTER_PARAM_DATA *pData)
{

    // save this off so we can modify it, since a REFGUID is constant
    //
    GUID guid = guiddummy;

    CAutoLock cObjectLock(m_pLock);
    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXTWrap::QParamData")));

    if (m_cInputs == 0) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("NO PINS - error")));
	return E_UNEXPECTED;
    }
    CheckPointer(pData, E_FAIL);

    // times are bogus
    if (rtStop < rtStart || pData->rtStart < rtStart || pData->rtStop > rtStop)
	return E_INVALIDARG;
    if ( IsEqualGUID(guid, GUID_NULL) && !pEffectUnk )
	return E_INVALIDARG;

    if (pData->nVersion != 0)
	return E_INVALIDARG;

    // now queue this in our linked list, sorted in the order given to us for
    // 1 input effects, and sorted by lifetimes that can't overlap for 2 input
    // (1 input effects can have times that overlap, and we will perform
    //  multiple effects at a time)

    QPARAMDATA *p = m_pQHead, *pNew, *pP = NULL;
    if (m_cInputs == 2) {
        while (p && p->rtStart < rtStart) {
	    pP = p;
	    p = p->pNext;
	}
        if (p && p->rtStart < rtStop)
	    return E_INVALIDARG;
        if (pP && pP->rtStop > rtStart)
	    return E_INVALIDARG;
    } else {
        while (p) {
	    pP = p;
	    p = p->pNext;
        }
    }

    pNew = new QPARAMDATA;
    if (pNew == NULL)
	return E_OUTOFMEMORY;
    pNew->Data = *pData;
    if (pNew->Data.pSetter)
        pNew->Data.pSetter->AddRef();	// hold onto this
    pNew->rtStart = rtStart;
    pNew->rtStop = rtStop;
    pNew->fCanDoProgress = FALSE;	// don't know yet;
    pNew->pDXT = NULL;
    pNew->pEffectUnk = NULL;
    pNew->EffectGuid = guid;
    if( pEffectUnk )
    {
        pNew->EffectGuid = GUID_NULL;	// use given instantiated one instead
        pNew->pEffectUnk = pEffectUnk;
        pEffectUnk->AddRef( );
    }
    if (pP)
    {
	pP->pNext = pNew;
    }
    pNew->pNext = NULL;
    if (m_pQHead == NULL || p == m_pQHead)
	m_pQHead = pNew;

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("New Effect successfully queued")));
#ifdef DEBUG
    DumpQ();
#endif

    m_fDXTMode = FALSE;	// not anymore!
    SetDirty(TRUE);

    return S_OK;
}


#ifdef DEBUG
HRESULT CDXTWrap::DumpQ()
{
    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXT::DumpQ")));
    QPARAMDATA *p = m_pQHead;
    while (p) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("%8d-%8d ms"), (int)(p->rtStart / 10000),
						(int)(p->rtStop / 10000)));
	p = p->pNext;
    }
    return S_OK;
}
#endif


// !!! need a way to reset # of pins? (switch too)

// !!! can't get the CAPS of an effect



////////////////////////////////////////////////////////////////////////////
//////////////   INPUT PIN  ////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////


CDXTInputPin::CDXTInputPin(TCHAR *pObjectName, CDXTWrap *pFilter, HRESULT * phr, LPCWSTR pName)
    : CBaseInputPin(pObjectName, pFilter, pFilter->m_pLock, phr, pName)
{
    m_pFilter = pFilter;
    m_pDXSurface = NULL;
    m_fSurfaceFilled = FALSE;
    m_pRaw = NULL;
    m_hEventSurfaceFree = NULL;
}

// Normally, we only accept the media type we were told to accept
// In DXT wrapper mode, we allow a number of RGB types, but all connections must
// be of the same type
//
HRESULT CDXTInputPin::CheckMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);

    DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("CDXTIn::CheckMediaType")));

    if (pmt == NULL || pmt->Format() == NULL) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: type/format is NULL")));
	return E_INVALIDARG;
    }

    // Normal mode - accept only what we were told to
    if (!m_pFilter->m_fDXTMode) {
        if (m_pFilter->m_mtAccept.majortype == GUID_NULL) {
            DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: no type set yet")));
	    return E_INVALIDARG;
        }
        if (pmt->majortype != m_pFilter->m_mtAccept.majortype ||
			pmt->subtype != m_pFilter->m_mtAccept.subtype ||
			pmt->formattype != m_pFilter->m_mtAccept.formattype) {
            DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: GUID mismatch")));
	    return E_INVALIDARG;
        }
        // !!! c runtime
        if (memcmp(HEADER(pmt->pbFormat),HEADER(m_pFilter->m_mtAccept.pbFormat),
					sizeof(BITMAPINFOHEADER))) {
            DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: Invalid BITMAPINFOHEADER")));
	    return E_INVALIDARG;
        }
	return NOERROR;
    }

    // DXT Wrapper mode - all inputs must be the same type

    // we only support MEDIATYPE_Video
    if (*pmt->Type() != MEDIATYPE_Video) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Rejecting: not VIDEO")));
	return E_INVALIDARG;
    }

    // check this is a VIDEOINFOHEADER type
    if (*pmt->FormatType() != FORMAT_VideoInfo) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Rejecting: format not VIDINFO")));
        return E_INVALIDARG;
    }

    // !!! What if subtype doesn't match biCompression/biBitCount?

    // We only accept RGB
    if (HEADER(pmt->Format())->biCompression == BI_BITFIELDS &&
    			HEADER(pmt->Format())->biBitCount != 16) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Rejecting: Invalid BITFIELDS")));
	return E_INVALIDARG;
    }
    if (HEADER(pmt->Format())->biCompression != BI_BITFIELDS &&
    			HEADER(pmt->Format())->biCompression != BI_RGB) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Rejecting: Not RGB")));
	return E_INVALIDARG;
    }

    int nWidth = 0, nHeight = 0, nBitCount = 0;
    DWORD dwCompression = 0;
    for (int n = 0; n < m_pFilter->m_cInputs; n++) {
	if (m_pFilter->m_apInput[n]->IsConnected()) {
	    nWidth = HEADER(m_pFilter->m_apInput[n]->m_mt.Format())->biWidth;
	    nHeight = HEADER(m_pFilter->m_apInput[n]->m_mt.Format())->biHeight;
	    nBitCount = HEADER(m_pFilter->m_apInput[n]->m_mt.Format())->
								biBitCount;
	    dwCompression = HEADER(m_pFilter->m_apInput[n]->m_mt.Format())->
								biCompression;
	    break;
	}
    }
    if (nWidth == 0) {
	if (m_pFilter->m_apOutput[0]->IsConnected()) {
	    nWidth = HEADER(m_pFilter->m_apOutput[0]->m_mt.Format())->biWidth;
	    nHeight = HEADER(m_pFilter->m_apOutput[0]->m_mt.Format())->biHeight;
	    nBitCount = HEADER(m_pFilter->m_apOutput[0]->m_mt.Format())->
								biBitCount;
	    dwCompression = HEADER(m_pFilter->m_apOutput[0]->m_mt.Format())->
								biCompression;
	}
    }

    // all pins must connect with the same size bitmap
    // !!! and same bitcount so we can efficiently pass through (not really
    // imposed by DXT)
    //
    if (nWidth && (nWidth != HEADER(pmt->Format())->biWidth ||
    			nHeight != HEADER(pmt->Format())->biHeight ||
    			nBitCount != HEADER(pmt->Format())->biBitCount ||
    			dwCompression !=HEADER(pmt->Format())->biCompression)) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Rejecting: Formats don't match")));
	return E_INVALIDARG;
    }

    if (HEADER(pmt->Format())->biBitCount == 24)
        return NOERROR;
    // !!! better have alpha=11111111, or don't use alpha
    if (HEADER(pmt->Format())->biBitCount == 32)
        return NOERROR;
    if (HEADER(pmt->Format())->biBitCount == 16) {
        if (HEADER(pmt->Format())->biCompression == BI_RGB)
            return NOERROR;
	VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *)pmt->Format();
        if (BITMASKS(pvi)[0] == 0xf800 &&
        	BITMASKS(pvi)[1] == 0x07e0 &&
        	BITMASKS(pvi)[2] == 0x001f) {
            return NOERROR;
	}
    }
    return E_INVALIDARG;
}


// !!! each input pin will fwd these to all outputs.  Wait until last input
// get it, then send to all?

// EndOfStream
//
HRESULT CDXTInputPin::EndOfStream()
{
    CAutoLock lock_it(m_pLock);
    ASSERT(m_pFilter->m_cOutputs);
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("DXT::EndOfStream")));

// !!! This will ABORT playback if one stream ends early!  We should pass
// through the other stream.  If both streams end early, we'rein trouble!
// (MPEG seeking bug)

// Possible hang in BeginFlush too? Can only 1 pin be flushed?

#if 0
    // unblock receive?
    m_fSurfaceFilled = FALSE;
    m_pSampleHeld->Release();
    SetEvent(m_hEventSurfaceFree);
#endif

    // Walk through the output pins list, sending the message downstream

    for (int n = 0; n < m_pFilter->m_cOutputs; n++) {
        CDXTOutputPin *pOutputPin = m_pFilter->m_apOutput[n];
	ASSERT(pOutputPin);
        if (pOutputPin) {
            hr = pOutputPin->DeliverEndOfStream();
            if (FAILED(hr))
                return hr;
        }
    }
    return CBaseInputPin::EndOfStream();
}


// BeginFlush
//
HRESULT CDXTInputPin::BeginFlush()
{
    HRESULT hr;

    CAutoLock lock_it(m_pLock);
    ASSERT(m_pFilter->m_cOutputs);

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("DXT::BeginFlush")));

    // first, make sure receive will fail from now on
    HRESULT hrD = CBaseInputPin::BeginFlush();

    // unblock receive
    m_csSurface.Lock();
    if (m_fSurfaceFilled) {
        m_fSurfaceFilled = FALSE;
        m_pSampleHeld->Release();
        SetEvent(m_hEventSurfaceFree);
    }
    m_csSurface.Unlock();

    // Walk through the output pins list, sending the message downstream,
    // to unblock the deliver to the renderer
    for (int n = 0; n < m_pFilter->m_cOutputs; n++) {
        CDXTOutputPin *pOutputPin = m_pFilter->m_apOutput[n];
	ASSERT(pOutputPin);
        if (pOutputPin) {
            hr = pOutputPin->DeliverBeginFlush();
            if (FAILED(hr))
                return hr;
        }
    }

    // now make sure Receive has finished
    CAutoLock lock_2(&m_csReceive);

    // make sure Receive didn't hold the sample
    m_csSurface.Lock();
    if (m_fSurfaceFilled) {
        m_fSurfaceFilled = FALSE;
        m_pSampleHeld->Release();
        SetEvent(m_hEventSurfaceFree);
    }
    m_csSurface.Unlock();

    return hrD;
}


// EndFlush
//
HRESULT CDXTInputPin::EndFlush()
{
    CAutoLock lock_it(m_pLock);
    ASSERT(m_pFilter->m_cOutputs);
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("DXT::EndFlush")));

    // Walk through the output pins list, sending the message downstream

    for (int n = 0; n < m_pFilter->m_cOutputs; n++) {
        CDXTOutputPin *pOutputPin = m_pFilter->m_apOutput[n];
	ASSERT(pOutputPin);
        if (pOutputPin) {
            hr = pOutputPin->DeliverEndFlush();
            if (FAILED(hr))
                return hr;
        }
    }
    return CBaseInputPin::EndFlush();
}


//
// NewSegment
//

HRESULT CDXTInputPin::NewSegment(REFERENCE_TIME tStart, REFERENCE_TIME tStop,
                                 double dRate)
{
    // !!! no no no we'll hang CAutoLock lock_it(m_pLock);

    ASSERT(m_pFilter->m_cOutputs);
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXT::NewSegment - %dms - pass it down"),
					(int)(tStart / 10000)));
    // !!! both input pins will pass this down
    for (int n = 0; n < m_pFilter->m_cOutputs; n++) {
        CDXTOutputPin *pOutputPin = m_pFilter->m_apOutput[n];
	ASSERT(pOutputPin);
        if (pOutputPin) {
            hr = pOutputPin->DeliverNewSegment(tStart, tStop, dRate);
            if (FAILED(hr))
                return hr;
        }
    }
    return CBaseInputPin::NewSegment(tStart, tStop, dRate);
}


// our Receive methods can block
STDMETHODIMP CDXTInputPin::ReceiveCanBlock()
{
    return S_OK;
}


//
// Receive
//
// In DEXTER, we're well behaved and both pins will get data at exactly the
// same frame rate.  But this filter is written to work with 2 inputs that
// are at different frame rates (to be useful outside Dexter).  We will use the
// first pin's frame rate and time stamps to decide how often to output samples.
//
// Pin number 1 is the master.  For other pins, if that frame ends before pin
// #1's data starts, it is too early and discarded.  Once all pins have valid
// data, we call the transform (there may be one or 2 inputs)
//
HRESULT CDXTInputPin::Receive(IMediaSample *pSample)
{
    // DEATH if you take the filter crit sect in receive and block
    // CAutoLock lock_it(m_pLock);

    CAutoLock cObjectLock(&m_csReceive);

    LONGLONG llStart = 0, llStop = 0;
    HRESULT hr = pSample->GetTime(&llStart, &llStop);

    // Skew time stamps by new segment values to get the real time
    llStart += m_tStart;
    llStop += m_tStart;
    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("DXT:Skewed Receive time (%d,%d)ms"),
						(int)(llStart / 10000),
						(int)(llStop / 10000)));

    if (!m_pFilter->m_apOutput[0]->IsConnected()) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Receive FAILED: Output not connected")));
	return S_OK;
    }
    // If we're not supposed to receive anymore because we're stopped,
    // waiting on the event will hang forever
    if (m_pFilter->m_State == State_Stopped) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Receive FAILED: Stopped")));
	return VFW_E_WRONG_STATE;
    }

    // this pin already has something waiting to be processed.  Block.
    if (m_fSurfaceFilled) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("DXT: Waiting for surface to be free")));
        WaitForSingleObject(m_hEventSurfaceFree, INFINITE);
    }

    // Check that we still want to receive after waiting - maybe we unblocked
    // because the graph is stopping
    hr = NOERROR;
    hr = CBaseInputPin::Receive(pSample);
    if (hr != NOERROR) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("DXT:Receive base class ERROR!")));
        return hr;
    }

    // the other way we can tell we're stopping and not supposed to continue
    // is if the surface really isn't free after the event was set
    if (m_fSurfaceFilled) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("DXT:Event fired saying STOP!")));
        return S_FALSE;
    }

    // PROTECT our logic deciding what to do
    m_csSurface.Lock();

    // we aren't the first input, and the first input has some data.
    // Throw our data away if it's too early
    if (this != m_pFilter->m_apInput[0] &&
				m_pFilter->m_apInput[0]->m_fSurfaceFilled) {
	if (llStop > 0 && llStop <= m_pFilter->m_apInput[0]->m_llSurfaceStart){
            DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("TOO EARLY: Discard ourself")));
	    m_csSurface.Unlock();
	    return NOERROR;
	}
    }

#if 0	// this is not necessary because the switch will prevent this from
	// being needed (at the moment)
    // When being used with DEXTER, we want to throw input 0 away if we're not
    // the first input and the first input is early, because we know both input
    // pins are supposed to receive matching time stamps.
    m_pFilter->m_apInput[0]->m_csSurface.Lock();
    if (!m_pFilter->m_fDXTMode && this != m_pFilter->m_apInput[0] &&
				m_pFilter->m_apInput[0]->m_fSurfaceFilled) {
	if (m_pFilter->m_apInput[0]->m_llSurfaceStop > 0 &&
		m_pFilter->m_apInput[0]->m_llSurfaceStop <= llStart) {
            DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("0 TOO EARLY: Discard it")));
	    m_pFilter->m_apInput[0]->m_fSurfaceFilled = FALSE;
	    m_pFilter->m_apInput[0]->m_pSampleHeld->Release();
	    SetEvent(m_pFilter->m_apInput[0]->m_hEventSurfaceFree);
	}
    }
    m_pFilter->m_apInput[0]->m_csSurface.Unlock();
#endif

    // we are the first input.  throw others away that are already queued up
    // but that we now realize are too early.
    if (llStop > 0 && this == m_pFilter->m_apInput[0]) {
	for (int i = 1; i < m_pFilter->m_cInputs; i++) {
	    m_pFilter->m_apInput[i]->m_csSurface.Lock();
	    if (m_pFilter->m_apInput[i]->m_fSurfaceFilled &&
			m_pFilter->m_apInput[i]->m_llSurfaceStop > 0 &&
			m_pFilter->m_apInput[i]->m_llSurfaceStop <= llStart) {
                DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Pin #%d TOO EARLY: Discard it"),i));
		m_pFilter->m_apInput[i]->m_fSurfaceFilled = FALSE;
	        m_pFilter->m_apInput[i]->m_pSampleHeld->Release();
		SetEvent(m_pFilter->m_apInput[i]->m_hEventSurfaceFree);
	    }
	    m_pFilter->m_apInput[i]->m_csSurface.Unlock();
	}
    }

    m_pSampleHeld = pSample;
    pSample->AddRef();

    // We have valid data in our surface now.  Next time we'll block
    m_fSurfaceFilled = TRUE;
    m_llSurfaceStart = llStart;	// time stamps of the valid data
    m_llSurfaceStop = llStop;
    ResetEvent(m_hEventSurfaceFree);	// need a new SetEvent

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Input has received something")));

    // not everybody has data yet.  We're done
    for (int i = 0; i < m_pFilter->m_cInputs; i++) {
	if (m_pFilter->m_apInput[i]->IsConnected() &&
				!m_pFilter->m_apInput[i]->m_fSurfaceFilled) {
    	    m_csSurface.Unlock();
	    return NOERROR;
	}
    }

    // OK, should be safe now
    m_csSurface.Unlock();

    // Everybody has data!  Time to call the effect!
    hr = m_pFilter->DoSomething();
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE,1,TEXT("DXT's DoSomething FAILED!!!!!!")));
        // !!! If the Deliver inside DoSomething failed, then technically we shouldn't
        // send this EOS
	m_pFilter->m_apOutput[0]->DeliverEndOfStream();
    }

    return hr;
}


// make a surface we can use for the transform
//
HRESULT CDXTInputPin::Active()
{
    HRESULT hr;
    IDXSurfaceFactory *pF;

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXTIn::Active")));

    ASSERT(!m_fSurfaceFilled);

    // auto reset event - fired to unblock receive
    m_hEventSurfaceFree = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_hEventSurfaceFree == NULL)
	return E_OUTOFMEMORY;

    // Make a surface the same type as our input
    hr = m_pFilter->m_pDXTransFact->QueryInterface(IID_IDXSurfaceFactory,
							(void **)&pF);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("Error making surface factory")));
	CloseHandle(m_hEventSurfaceFree);
        m_hEventSurfaceFree = NULL;
	return hr;
    }

    CDXDBnds bnds;
    bnds.SetXYSize(HEADER(m_mt.Format())->biWidth,
					HEADER(m_mt.Format())->biHeight);

    hr = pF->CreateSurface(NULL, NULL, m_mt.Subtype( ), &bnds, 0, NULL,
				IID_IDXSurface, (void **)&m_pDXSurface);
    pF->Release();
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("In: Error Creating surface")));
	CloseHandle(m_hEventSurfaceFree);
        m_hEventSurfaceFree = NULL;
	return hr;
    }
    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("In: Created surface")));

    m_pRaw = new CMyRaw();
    if (m_pRaw == NULL) {
	CloseHandle(m_hEventSurfaceFree);
        m_hEventSurfaceFree = NULL;
	m_pDXSurface->Release();
	m_pDXSurface = NULL;
 	return E_OUTOFMEMORY;
    }
    m_pRaw->AddRef();

    return CBaseInputPin::Active();
}


HRESULT CDXTInputPin::Inactive()
{
    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("DXTIn::Inactive")));

    // we need to stop every input pin, not just this one, because any receive
    // uses the data from both pins.
    //
    for (int n=0; n<m_pFilter->m_cInputs; n++) {

        // first, unblock all the receives
        SetEvent(m_pFilter->m_apInput[n]->m_hEventSurfaceFree);

        // now make sure that any pending receives are finished so we don't blow
        // up shutting down
        m_pFilter->m_apInput[n]->m_csReceive.Lock();
    }

    for (n=0; n<m_pFilter->m_cInputs; n++) {

        // now make sure receive didn't hold onto a sample
        m_pFilter->m_apInput[n]->m_csSurface.Lock();
        if (m_pFilter->m_apInput[n]->m_fSurfaceFilled) {
            m_pFilter->m_apInput[n]->m_fSurfaceFilled = FALSE;
            m_pFilter->m_apInput[n]->m_pSampleHeld->Release();
            SetEvent(m_pFilter->m_apInput[n]->m_hEventSurfaceFree);
        }
        m_pFilter->m_apInput[n]->m_csSurface.Unlock();

        // Decommit the allocators, to ensure nobody's receives get entered
	// again.  DON'T DO THIS until we've unblocked receive above and
        // released all the samples
        HRESULT hr = m_pFilter->m_apInput[n]->CBaseInputPin::Inactive();
    }

    for (n=0; n<m_pFilter->m_cInputs; n++) {
        m_pFilter->m_apInput[n]->m_csReceive.Unlock();
    }

    // all done with this pin's variables... the other Inactive will do nothing
    // above, but kill its variables below
    //
    if (m_pDXSurface)
	m_pDXSurface->Release();
    m_pDXSurface = NULL;

    if (m_pRaw)
        m_pRaw->Release();
    m_pRaw = NULL;

    // all done
    if (m_hEventSurfaceFree)
    {
        CloseHandle(m_hEventSurfaceFree);
        m_hEventSurfaceFree = NULL;
    }

    return S_OK;
}


STDMETHODIMP CMyRaw::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{

    // our private interface to say what transform to use and when
    if (riid == IID_IDXRawSurface) {
        return GetInterface((IDXRawSurface *)this, ppv);
    }

    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
}

HRESULT STDMETHODCALLTYPE CMyRaw::GetSurfaceInfo(DXRAWSURFACEINFO *pdxraw)
{
    DbgLog((LOG_TRACE,TRACE_MEDIUM+1,TEXT("*** GetSurfaceInfo")));

    if (pdxraw == NULL)
	return E_POINTER;

    *pdxraw = m_DXRAW;
    DbgLog((LOG_TRACE,TRACE_MEDIUM+1,TEXT("giving %x: %dx%d"), pdxraw->pFirstByte,
				pdxraw->Width, pdxraw->Height));
    return NOERROR;
}

HRESULT CMyRaw::SetSurfaceInfo(DXRAWSURFACEINFO *pdxraw)
{
    m_DXRAW = *pdxraw;
    return NOERROR;
}


////////////////////////////////////////////////////////////////////////////
//////////////   OUTPUT PIN  ///////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

CDXTOutputPin::CDXTOutputPin(TCHAR *pObjectName, CDXTWrap *pFilter, HRESULT * phr, LPCWSTR pPinName)
    : CBaseOutputPin(pObjectName, pFilter, pFilter->m_pLock, phr, pPinName)
    , m_pPosition(NULL)
{
    m_pFilter = pFilter;
    m_pDXSurface = NULL;
    m_pRaw = NULL;
}

CDXTOutputPin::~CDXTOutputPin()
{
    if (m_pPosition)
	m_pPosition->Release();
}


//
// DecideBufferSize
//
// This has to be present to override the PURE virtual class base function
//
HRESULT CDXTOutputPin::DecideBufferSize(IMemAllocator *pAllocator,
                                      ALLOCATOR_PROPERTIES * pProperties)
{

    ASSERT(m_mt.IsValid());
    ASSERT(pAllocator);
    ASSERT(pProperties);

    // make sure we have at least 1 buffer
    // !!! more?
    if (pProperties->cBuffers == 0)
        pProperties->cBuffers = 1;

    // set the size of buffers based on the expected output frame size
    if (pProperties->cbBuffer < (LONG)m_mt.GetSampleSize())
        pProperties->cbBuffer = m_mt.GetSampleSize();
    ASSERT(pProperties->cbBuffer);

    ALLOCATOR_PROPERTIES Actual;
    HRESULT hr = pAllocator->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("Error in SetProperties")));
	return hr;
    }

    if (Actual.cbBuffer < pProperties->cbBuffer) {
	// can't use this allocator
        DbgLog((LOG_ERROR,1,TEXT("Can't use allocator - buffer too small")));
	return E_INVALIDARG;
    }

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Using %d buffers of size %d"),
					Actual.cBuffers, Actual.cbBuffer));

    return NOERROR;

}


//
// CheckMediaType
//
// Normally, we only accept the media type we were told to accept
// In DXT wrapper mode, we allow a number of RGB types, but all connections must
// be of the same type
//
HRESULT CDXTOutputPin::CheckMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);

    DbgLog((LOG_TRACE,5,TEXT("CDXTOut::CheckMediaType")));

    if (pmt == NULL || pmt->Format() == NULL) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: type/format is NULL")));
	return E_INVALIDARG;
    }

    // Normal mode - accept only what we were told to
    if (!m_pFilter->m_fDXTMode) {
        if (m_pFilter->m_mtAccept.majortype == GUID_NULL) {
            DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: no type set yet")));
	    return E_INVALIDARG;
        }
        if (pmt->majortype != m_pFilter->m_mtAccept.majortype ||
		    pmt->subtype != m_pFilter->m_mtAccept.subtype ||
		    pmt->formattype != m_pFilter->m_mtAccept.formattype) {
            DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: GUID mismatch")));
	    return E_INVALIDARG;
        }
        // !!! runtime
        if (memcmp(HEADER(pmt->pbFormat),HEADER(m_pFilter->m_mtAccept.pbFormat),
					sizeof(BITMAPINFOHEADER))) {
            DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: Invalid BITMAPINFOHEADER")));
	    return E_INVALIDARG;
        }
	return NOERROR;
    }

    // DXT Wrapper mode - all inputs must be the same type

    // we only support MEDIATYPE_Video
    if (*pmt->Type() != MEDIATYPE_Video) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Rejecting: not VIDEO")));
	return E_INVALIDARG;
    }

    // check this is a VIDEOINFOHEADER type
    if (*pmt->FormatType() != FORMAT_VideoInfo) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Rejecting: format not VIDINFO")));
        return E_INVALIDARG;
    }

    // !!! what if subtype doesn't match biCompression/biBitCount?

    // We only accept RGB
    if (HEADER(pmt->Format())->biCompression == BI_BITFIELDS &&
    			HEADER(pmt->Format())->biBitCount != 16) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Rejecting: Invalid BITFIELDS")));
	return E_INVALIDARG;
    }
    if (HEADER(pmt->Format())->biCompression != BI_BITFIELDS &&
    			HEADER(pmt->Format())->biCompression != BI_RGB) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Rejecting: Not RGB")));
	return E_INVALIDARG;
    }

    // all pins must connect with the same size bitmap
    // !!! and same bitcount so we can efficiently pass through (not really
    // imposed by DXT)
    //
    int nWidth = 0, nHeight = 0, nBitCount = 0;
    DWORD dwCompression = 0;
    for (int n = 0; n < m_pFilter->m_cInputs; n++) {
	if (m_pFilter->m_apInput[n]->IsConnected()) {
	    nWidth = HEADER(m_pFilter->m_apInput[n]->m_mt.Format())->biWidth;
	    nHeight = HEADER(m_pFilter->m_apInput[n]->m_mt.Format())->biHeight;
	    nBitCount = HEADER(m_pFilter->m_apInput[n]->m_mt.Format())->									biBitCount;
	    dwCompression = HEADER(m_pFilter->m_apInput[n]->m_mt.Format())->
								biCompression;
	    break;
        }
    }

    // all pins must connect with the same type
    //
    if (nWidth != HEADER(pmt->Format())->biWidth ||
    			nHeight != HEADER(pmt->Format())->biHeight ||
    			nBitCount != HEADER(pmt->Format())->biBitCount ||
    			dwCompression !=HEADER(pmt->Format())->biCompression) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Reject: formats don't match")));
	return E_INVALIDARG;
    }

    // DXT CANNOT output 8 bit

    if (HEADER(pmt->Format())->biBitCount == 24)
        return NOERROR;
    // !!! better have alpha=11111111, or don't use alpha
    if (HEADER(pmt->Format())->biBitCount == 32)
        return NOERROR;
    if (HEADER(pmt->Format())->biBitCount == 16) {
        if (HEADER(pmt->Format())->biCompression == BI_RGB)
            return NOERROR;
	VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *)pmt->Format();
        if (BITMASKS(pvi)[0] == 0xf800 &&
        	BITMASKS(pvi)[1] == 0x07e0 &&
        	BITMASKS(pvi)[2] == 0x001f) {
            return NOERROR;
	}
    }
    return E_INVALIDARG;
}



//
// GetMediaType - offer what we've been told to use
// 	In DXT Mode, offer the same as our input
//
HRESULT CDXTOutputPin::GetMediaType(int iPosition, CMediaType *pmt)
{
//    LARGE_INTEGER li;
//    VIDEOINFOHEADER *pf;

    DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("*::GetMediaType #%d"), iPosition));

    if (pmt == NULL) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Media type is NULL, no can do")));
	return E_INVALIDARG;
    }

    if (iPosition < 0) {
        return E_INVALIDARG;
    }
    if (iPosition > 0) {
        return VFW_S_NO_MORE_ITEMS;
    }

    if (!m_pFilter->m_fDXTMode) {
        *pmt = m_pFilter->m_mtAccept;
    } else {

	// DXT Mode - offer our input type
        for (int n = 0; n < m_pFilter->m_cInputs; n++) {
            if (m_pFilter->m_apInput[n]->IsConnected()) {
	        *pmt = m_pFilter->m_apInput[n]->m_mt;
	        return NOERROR;
	    }
        }
        return E_UNEXPECTED;
    }

    return NOERROR;
}


//
// SetMediaType
//
HRESULT CDXTOutputPin::SetMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);

    return CBaseOutputPin::SetMediaType(pmt);

}


//
// Notify
//
STDMETHODIMP CDXTOutputPin::Notify(IBaseFilter *pSender, Quality q)
{
    // !!! Quality management is unneccessary?
    return E_NOTIMPL;
}


// Make a DXSurface for the pin to use, the same format as its mediatype
//
HRESULT CDXTOutputPin::Active()
{
    HRESULT hr;
    IDXSurfaceFactory *pF;

    if (1) {
        m_pRaw = new CMyRaw();
        if (m_pRaw == NULL) {
	    // !!! more error checking in this function?
 	    return E_OUTOFMEMORY;
        }
	m_pRaw->AddRef();

        hr = m_pFilter->m_pDXTransFact->QueryInterface(IID_IDXSurfaceFactory,
							(void **)&pF);
        if (hr != NOERROR) {
            DbgLog((LOG_ERROR,1,TEXT("Error making factory")));
	    m_pRaw->Release();
	    m_pRaw = NULL;
 	    return hr;
        }

        CDXDBnds bnds;
        bnds.SetXYSize(HEADER(m_mt.Format())->biWidth,
					HEADER(m_mt.Format())->biHeight);

        hr = pF->CreateSurface(NULL, NULL, m_mt.Subtype( ), &bnds, 0, NULL,
				IID_IDXSurface, (void **)&m_pDXSurface);

        pF->Release();
        if (hr != NOERROR) {
            DbgLog((LOG_ERROR,1,TEXT("Out: Error Creating surface")));
	    m_pRaw->Release();
	    m_pRaw = NULL;
 	    return hr;
        }
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Out: Created 2D surface")));
    }

    return CBaseOutputPin::Active();
}


HRESULT CDXTOutputPin::Inactive()
{
    if (1) {
        if (m_pDXSurface)
	    m_pDXSurface->Release();
        m_pDXSurface = NULL;

	if (m_pRaw)
            m_pRaw->Release();
        m_pRaw = NULL;
    }

    return CBaseOutputPin::Inactive();
}


// !!! Need MULTI-PIN pass thru for 2 input effects!
//
STDMETHODIMP CDXTOutputPin::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IMediaSeeking && m_pFilter->m_cInputs == 1) {
        if (m_pPosition == NULL) {
            HRESULT hr = CreatePosPassThru(
                             GetOwner(),
                             FALSE,
                             (IPin *)m_pFilter->m_apInput[0],
                             &m_pPosition);
            if (FAILED(hr)) {
                return hr;
            }
        }
        return m_pPosition->QueryInterface(riid, ppv);
    } else {
	return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}

STDMETHODIMP CDXTWrap::SetDefaultEffect( GUID * pEffect )
{
    CheckPointer( pEffect, E_POINTER );
    m_DefaultEffect = *pEffect;
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\gray\gray.h ===
#ifndef __Gray_H_
#define __Gray_H_

#ifndef DTBase_h
    #include <DTBase.h>
#endif

#include "resource.h"       // main symbols

#define _BASECOPY_STRING L"Copyright Microsoft Corp. 1998.  Unauthorized duplication of this string is illegal. "

/////////////////////////////////////////////////////////////////////////////
// CDxtGray
class ATL_NO_VTABLE CDxtGray : 
    public CDXBaseNTo1,
    public CComCoClass<CDxtGray, &CLSID_DxtGray>,
    public IDispatchImpl<IDxtGray, &IID_IDxtGray, &LIBID_DxtGrayDLLLib>,
    public IOleObjectDXImpl<CDxtGray>
{
    bool m_bInputIsClean;
    bool m_bOutputIsClean;
    long m_nInputWidth;
    long m_nInputHeight;
    long m_nOutputWidth;
    long m_nOutputHeight;

public:
        DECLARE_POLY_AGGREGATABLE(CDxtGray)
        DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
        DECLARE_REGISTER_DX_TRANSFORM(IDR_DxtGray, CATID_DXImageTransform)
        DECLARE_GET_CONTROLLING_UNKNOWN()

	CDxtGray();
        ~CDxtGray();

//BEGIN_PROP_MAP(CDxtGray)
//END_PROP_MAP()

BEGIN_COM_MAP(CDxtGray)
        // Block CDXBaseNTo1 IObjectSafety implementation because we
        // aren't safe for scripting
        COM_INTERFACE_ENTRY_NOINTERFACE(IObjectSafety) 
        COM_INTERFACE_ENTRY(IDXEffect)
	COM_INTERFACE_ENTRY(IDxtGray)
	COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
        COM_INTERFACE_ENTRY_DXIMPL(IOleObject)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
END_COM_MAP()

    CComPtr<IUnknown> m_pUnkMarshaler;

    // required for ATL
    BOOL            m_bRequiresSave;

    // CDXBaseNTo1 overrides
    //
    HRESULT WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue );
    HRESULT OnSetup( DWORD dwFlags );
    HRESULT FinalConstruct();

    // our helper function
    //
    HRESULT DoEffect( DXSAMPLE * pOut, DXSAMPLE * pInA, DXSAMPLE * pInB, long Samples );

// IDxtGray
public:
};

#endif //__DxtGray_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\pip\stdafx.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <dtbase.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\pip\stdafx.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_)
#define AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED
#define _ATL_STATIC_REGISTRY

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
//
//  To allow us to compile with warning level 4, we need to disable
//  three warnings that ATLCTL generates at this warning level.
//
#pragma warning(disable: 4510 4610 4100)
#include <atlctl.h>
#pragma warning(default: 4510 4610 4100)
#include <DXTmpl.h>
#include <streams.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\gray\graydll.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// DxtGrayDll.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f DxtGrayDllps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
    #include "GrayDll.h"
    #include "GrayDll_i.c"
    #include "Gray.h"

#include <dxtguid.c>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_DxtGray, CDxtGray)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_DxtGrayDLLLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\pip\pip.h ===
// DxtPip.h : Declaration of the CDxtPip

#ifndef __DxtPip_H_
#define __DxtPip_H_

#ifndef DTBase_h
    #include <DTBase.h>
#endif

#include "resource.h"       // main symbols

#define _BASECOPY_STRING L"Copyright Microsoft Corp. 1998.  Unauthorized duplication of this string is illegal. "

/////////////////////////////////////////////////////////////////////////////
// CDxtPip
class ATL_NO_VTABLE CDxtPip : 
    public CDXBaseNTo1,
    public CComCoClass<CDxtPip, &CLSID_DxtPip>,
    public IDispatchImpl<IDxtPip, &IID_IDxtPip, &LIBID_DxtPipDLLLib>,
    public IOleObjectDXImpl<CDxtPip>
{
    bool m_bInputIsClean;
    bool m_bOutputIsClean;
    long m_nInputWidth;
    long m_nInputHeight;
    long m_nOutputWidth;
    long m_nOutputHeight;

public:
        DECLARE_POLY_AGGREGATABLE(CDxtPip)
        DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
        DECLARE_REGISTER_DX_TRANSFORM(IDR_DxtPip, CATID_DXImageTransform)
        DECLARE_GET_CONTROLLING_UNKNOWN()

	CDxtPip();
        ~CDxtPip();

//BEGIN_PROP_MAP(CDxtPip)
//END_PROP_MAP()

BEGIN_COM_MAP(CDxtPip)
        // Block CDXBaseNTo1 IObjectSafety implementation because we
        // aren't safe for scripting
        COM_INTERFACE_ENTRY_NOINTERFACE(IObjectSafety) 
        COM_INTERFACE_ENTRY(IDXEffect)
	COM_INTERFACE_ENTRY(IDxtPip)
	COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
        COM_INTERFACE_ENTRY_DXIMPL(IOleObject)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
END_COM_MAP()

    CComPtr<IUnknown> m_pUnkMarshaler;

    // required for ATL
    BOOL            m_bRequiresSave;

    // CDXBaseNTo1 overrides
    //
    HRESULT WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue );
    HRESULT OnSetup( DWORD dwFlags );
    HRESULT FinalConstruct();

    // our helper function
    //
    HRESULT DoEffect( DXSAMPLE * pOut, DXSAMPLE * pInA, DXSAMPLE * pInB, long Samples );

// IDxtPip
public:
};

#endif //__DxtPip_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\pip\pip.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// DxtPip.cpp : Implementation of CDxtPip
#include "stdafx.h"
#include "PipDll.h"
#include "Pip.h"
#include <math.h>

/////////////////////////////////////////////////////////////////////////////
// CDxtPip

CDxtPip::CDxtPip( )
{
    m_ulMaxImageBands = 1;
    m_ulMaxInputs = 2;
    m_ulNumInRequired = 2;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;
}

CDxtPip::~CDxtPip( )
{
}

HRESULT CDxtPip::OnSetup( DWORD dwFlags )
{        
    HRESULT hr;
    CDXDBnds InBounds(InputSurface(0), hr);
    m_nInputWidth = InBounds.Width( );
    m_nInputHeight = InBounds.Height( );

    CDXDBnds OutBounds(OutputSurface(), hr );
    m_nOutputWidth = OutBounds.Width( );
    m_nOutputHeight = OutBounds.Height( );

    if( m_nOutputWidth > m_nInputWidth )
    {
        m_nOutputWidth = m_nInputWidth;
    }
    if( m_nOutputHeight > m_nInputHeight )
    {
        m_nOutputHeight = m_nInputHeight;
    }

    return NOERROR;
}

HRESULT CDxtPip::FinalConstruct( )
{
    HRESULT hr;

    m_ulMaxImageBands = 1;
    m_ulMaxInputs = 2;
    m_ulNumInRequired = 2;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;

    hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(), &m_pUnkMarshaler.p );
    return hr;
}

HRESULT CDxtPip::WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue )
{
    HRESULT hr = S_OK;

    //--- Get input sample access pointer for the requested region.
    //    Note: Lock may fail due to a lost surface.
    CComPtr<IDXARGBReadPtr> pInA;
    hr = InputSurface( 0 )->LockSurface( &WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                         IID_IDXARGBReadPtr, (void**)&pInA, NULL );
    if( FAILED( hr ) ) return hr;

    CComPtr<IDXARGBReadPtr> pInB;
    hr = InputSurface( 1 )->LockSurface( &WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                         IID_IDXARGBReadPtr, (void**)&pInB, NULL );
    if( FAILED( hr ) ) return hr;


    //--- Put a write lock only on the region we are updating so multiple
    //    threads don't conflict.
    //    Note: Lock may fail due to a lost surface.
    CComPtr<IDXARGBReadWritePtr> pOut;
    hr = OutputSurface()->LockSurface( &WI.OutputBnds, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                       IID_IDXARGBReadWritePtr, (void**)&pOut, NULL );
    if( FAILED( hr ) ) return hr;

    //--- Allocate a working buffer
    ULONG Width = WI.DoBnds.Width();
    ULONG Height = WI.DoBnds.Height();

    // allocate a scratch buffer fer us
    //
    DXPMSAMPLE *pOverlayBuffer = DXPMSAMPLE_Alloca( Width );
    DXPMSAMPLE *pScratchBuffer = DXPMSAMPLE_Alloca( Width );

    // no dithering
    //
    if (DoDither())
    {
        return 0;
    }

    long t1 = timeGetTime( );

    long destx1 = 15;
    long destx2 = Width / 2;
    long desty1 = 15;
    long desty2 = Height / 2;

    ULONG OutY;

    // integer math!
    //
    long dix = Width * 65536 / ( destx2 - destx1 );
    long diy = Height * 65536 / ( desty2 - desty1 );
    long dx = destx2 - destx1;

    // copy background row into dest row
    //
    for( OutY = 0 ; OutY < Height ; ++OutY )
    {
        pInA->MoveToRow( OutY );
        pOut->MoveToRow( OutY );
        pOut->CopyAndMoveBoth( (DXBASESAMPLE*) pScratchBuffer, pInA, Width, FALSE );
    }

    long runy = desty1;

    for( OutY = desty1 ; OutY < desty2 ; OutY++ )
    {
        pOut->MoveToXY( destx1, OutY );
        pInB->MoveToXY( 0, runy >> 16 );
        pInB->UnpackPremult( pOverlayBuffer, Width, FALSE );
        runy += diy;

        // play with the big buffer, rearrange it so it looks like a little buffer
        //
        long j = 0;
        long runx = destx1;
        for( long i = dx ; i > 0 ; i-- )
        {
            pOverlayBuffer[j++] = pOverlayBuffer[runx >> 16];
            runx += dix;
        }

        pOut->PackPremultAndMove( pOverlayBuffer, dx );
    }

    long t2 = timeGetTime( );

    long t3 = t2 - t1;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\pip\pipdll.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// DxtPipDll.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f DxtPipDllps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
    #include "PipDll.h"
    #include "PipDll_i.c"
    #include "Pip.h"

#include <dxtguid.c>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_DxtPip, CDxtPip)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_DxtPipDLLLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\pip\resource.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DxtPipDll.rc
//
#define IDS_PROJNAME                    100
#define IDR_DxtPip                    101
#define IDS_TITLEDxtPipPP             102
#define IDS_HELPFILEDxtPipPP          103
#define IDS_DOCSTRINGDxtPipPP         104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         205
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxtjpegdll\dxtjpeg.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// DxtJpeg.cpp : Implementation of CDxtJpeg
#include <streams.h>
#include "stdafx.h"
#ifdef FILTER_DLL
#include "DxtJpegDll.h"
#else
#include <qeditint.h>
#include <qedit.h>
#endif
#include "DxtJpeg.h"
#pragma warning (disable:4244)

/////////////////////////////////////////////////////////////////////////////
// CDxtJpeg

CDxtJpeg::CDxtJpeg( )
{
    m_ulMaxInputs = 2;
    m_ulNumInRequired = 2;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_pInBufA = NULL;
    m_pInBufB = NULL;
    m_pOutBuf = NULL;
    m_pMaskBuf = NULL;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;
    m_szMaskName[0] = 0;
    m_nMaskNum = 1;
    m_pisImageRes = NULL;
    m_bFlipMaskH = FALSE;
    m_bFlipMaskV = FALSE;
    m_pidxsRawMask = NULL;
    m_ulMaskWidth = 0;
    m_ulMaskHeight = 0;

    memset(&m_ddsd, 0, sizeof(m_ddsd));

    m_ddsd.dwSize = sizeof(m_ddsd);
    m_ddsd.dwFlags = DDSD_CAPS | DDSD_PIXELFORMAT;
    m_ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY;
    m_ddsd.ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    m_ddsd.ddpfPixelFormat.dwFlags = DDPF_RGB;
    m_ddsd.ddpfPixelFormat.dwRGBBitCount = 32;
    m_ddsd.ddpfPixelFormat.dwRBitMask = 0x00ff0000;
    m_ddsd.ddpfPixelFormat.dwGBitMask = 0x0000ff00;
    m_ddsd.ddpfPixelFormat.dwBBitMask = 0x000000ff;

    m_dwFlush = 0x0;

    LoadDefSettings();
}

CDxtJpeg::~CDxtJpeg( )
{
    FreeStuff( );

    // keep this cached
    if (m_pidxsRawMask)
      m_pidxsRawMask->Release();
}

void CDxtJpeg::FreeStuff( )
{
    if( m_pInBufA ) delete [] m_pInBufA;
    m_pInBufA = NULL;
    if( m_pInBufB ) delete [] m_pInBufB;
    m_pInBufB = NULL;
    if( m_pOutBuf ) delete [] m_pOutBuf;
    m_pOutBuf = NULL;
    if( m_pMaskBuf ) delete [] m_pMaskBuf;
    m_pMaskBuf = NULL;

    if (m_pisImageRes)
      m_pisImageRes->Release();
    m_pisImageRes = NULL;

    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;
}

STDMETHODIMP CDxtJpeg::get_MaskNum(long *pVal)
{
    if( DXIsBadWritePtr( pVal, sizeof(*pVal) ) )
    {
        return E_POINTER;
    }
    *pVal = m_nMaskNum;
    return S_OK;
}

STDMETHODIMP CDxtJpeg::put_MaskNum(long newVal)
{
    DbgLog((LOG_TRACE,2,TEXT("JPEG::put_MaskNum to %d"), (int)newVal));
    m_nMaskNum = newVal;
    m_dwFlush |= MASK_FLUSH_CHANGEMASK;
    m_szMaskName[0] = TCHAR('\0');
    return S_OK;
}

STDMETHODIMP CDxtJpeg::get_MaskName(BSTR *pVal)
{
    if( DXIsBadWritePtr( pVal, sizeof(*pVal) ) )
    {
        return E_POINTER;
    }
    *pVal = SysAllocString( m_szMaskName );

    if (!pVal)
        return E_OUTOFMEMORY;

    return S_OK;
}

STDMETHODIMP CDxtJpeg::put_MaskName(BSTR newVal)
{
    if (DexCompareW(m_szMaskName, newVal))
      {
          int cch = lstrlenW(newVal) + 1;
          if(cch > NUMELMS(m_szMaskName)) {
              return E_FAIL;
          }
          DbgLog((LOG_TRACE,2,TEXT("JPEG::put_MaskName")));
          lstrcpyW( m_szMaskName, newVal );
          m_dwFlush |= MASK_FLUSH_CHANGEMASK;
      }

    return S_OK;
}

STDMETHODIMP CDxtJpeg::get_ScaleX(double *pvalue)
{
    if(DXIsBadWritePtr(pvalue, sizeof(*pvalue)))
      return E_POINTER;

    *pvalue = m_xScale;
    return S_OK;
}

STDMETHODIMP CDxtJpeg::put_ScaleX(double value)
{
      if (m_xScale != value)
      {
          m_xScale = value;
          m_dwFlush |= MASK_FLUSH_CHANGEPARMS;
      }

    return S_OK;
}

STDMETHODIMP CDxtJpeg::get_ScaleY(double *pvalue)
{
    if(DXIsBadWritePtr(pvalue, sizeof(*pvalue)))
      return E_POINTER;

    *pvalue = m_yScale;
    return NOERROR;
}

STDMETHODIMP CDxtJpeg::put_ScaleY(double value)
{
    if (m_yScale != value)
      {
          m_yScale = value;
          m_dwFlush |= MASK_FLUSH_CHANGEPARMS;
      }

    return S_OK;
}

STDMETHODIMP CDxtJpeg::get_OffsetX(long *pvalue )
{
    if(DXIsBadWritePtr(pvalue, sizeof(*pvalue)))
      return E_POINTER;

    *pvalue = m_xDisplacement;
    return S_OK;
}

STDMETHODIMP CDxtJpeg::put_OffsetX(long value)
{
    if (m_xDisplacement != value)
      {
          m_xDisplacement = value;
          m_dwFlush |= MASK_FLUSH_CHANGEPARMS;
      }

    return S_OK;
}

STDMETHODIMP CDxtJpeg::get_OffsetY(long *pvalue)
{
    if(DXIsBadWritePtr(pvalue, sizeof(*pvalue)))
      return E_POINTER;

    *pvalue = m_yDisplacement;
    return NOERROR;
}

STDMETHODIMP CDxtJpeg::put_OffsetY(long value)
{
    if (m_yDisplacement != value)
      {
          m_yDisplacement = value;
          m_dwFlush |= MASK_FLUSH_CHANGEPARMS;
      }

    return S_OK;
}

STDMETHODIMP CDxtJpeg::get_ReplicateX(long *pVal)
{
    if( DXIsBadWritePtr( pVal, sizeof(*pVal) ) )
    {
        return E_POINTER;
    }

    *pVal = m_ReplicateX;

	  return S_OK;
}

STDMETHODIMP CDxtJpeg::put_ReplicateX(long newVal)
{
    if (m_ReplicateX != newVal)
      {
          m_ReplicateX = newVal;
          m_dwFlush |= MASK_FLUSH_CHANGEPARMS;
      }

	  return S_OK;
}

STDMETHODIMP CDxtJpeg::get_ReplicateY(long *pVal)
{
    if( DXIsBadWritePtr( pVal, sizeof(*pVal) ) )
    {
        return E_POINTER;
    }

    *pVal = m_ReplicateY;
	return S_OK;
}

STDMETHODIMP CDxtJpeg::put_ReplicateY(long newVal)
{
    if (m_ReplicateY != newVal)
      {
          m_ReplicateY = newVal;
          m_dwFlush |= MASK_FLUSH_CHANGEPARMS;
      }

	  return S_OK;
}

STDMETHODIMP CDxtJpeg::get_BorderColor(long *pVal)
{
    if( DXIsBadWritePtr( pVal, sizeof(*pVal) ) )
    {
        return E_POINTER;
    }

  *pVal = 0;

  *pVal = (m_rgbBorder.rgbRed << 16)+(m_rgbBorder.rgbGreen << 8)+m_rgbBorder.rgbBlue;

	return S_OK;
}

STDMETHODIMP CDxtJpeg::put_BorderColor(long newVal)
{
        m_rgbBorder.rgbRed = (BYTE)((newVal & 0xFF0000) >> 16);
        m_rgbBorder.rgbGreen = (BYTE)((newVal & 0xFF00) >> 8);
        m_rgbBorder.rgbBlue = (BYTE)(newVal & 0xFF);
	return S_OK;
}

STDMETHODIMP CDxtJpeg::get_BorderWidth(long *pVal)
{
    if( DXIsBadWritePtr( pVal, sizeof(*pVal) ) )
    {
        return E_POINTER;
    }

    *pVal = m_lBorderWidth;

	  return S_OK;
}

STDMETHODIMP CDxtJpeg::put_BorderWidth(long newVal)
{
    if (newVal != m_lBorderWidth) {
        m_lBorderWidth = newVal;
    }
    return S_OK;
}


STDMETHODIMP CDxtJpeg::get_BorderSoftness(long *pVal)
{
    if( DXIsBadWritePtr( pVal, sizeof(*pVal) ) )
    {
        return E_POINTER;
    }

    *pVal = m_lBorderSoftness;

	  return S_OK;
}

STDMETHODIMP CDxtJpeg::put_BorderSoftness(long newVal)
{
    if (newVal != m_lBorderSoftness) {
        m_lBorderSoftness = newVal;
    }
    return S_OK;
}

HRESULT CDxtJpeg::OnSetup( DWORD dwFlags )
{
    DbgLog((LOG_TRACE,2,TEXT("JPEG::OnSetup")));

    // delete any stored stuff we have, or memory allocated
    FreeStuff( );

    HRESULT hr = NOERROR;

    CDXDBnds InBounds(InputSurface(0), hr);
    m_nInputWidth = InBounds.Width( );
    m_nInputHeight = InBounds.Height( );

    CDXDBnds OutBounds(OutputSurface(), hr );
    m_nOutputWidth = OutBounds.Width( );
    m_nOutputHeight = OutBounds.Height( );

    if( m_nOutputWidth > m_nInputWidth )
    {
        m_nOutputWidth = m_nInputWidth;
    }
    if( m_nOutputHeight > m_nInputHeight )
    {
        m_nOutputHeight = m_nInputHeight;
    }

    // Load default mask (#1) if nothing...
    if ((m_nMaskNum == 0) && !lstrlenW(m_szMaskName))
      {
        m_dwFlush |= MASK_FLUSH_CHANGEMASK;
        m_nMaskNum = 1;
      }

    return InitializeMask();
}

HRESULT CDxtJpeg::WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue )
{
    DbgLog((LOG_TRACE,3,TEXT("JPEG::WorkProc")));

    if (m_dwFlush) {
        DbgLog((LOG_TRACE,2,TEXT("JPEG::Options have changed!")));
	InitializeMask();
    }

    // !!! Doesn't support non-complete bounds

    HRESULT hr = S_OK;

    //--- Get input sample access pointer for the requested region.
    //    Note: Lock may fail due to a lost surface.

    CComPtr<IDXARGBReadPtr> pInA = NULL;
    CComPtr<IDXARGBReadPtr> pInB = NULL;
    DXSAMPLE * pInBufA = NULL;
    DXSAMPLE * pInBufB = NULL;
    DXNATIVETYPEINFO NativeType;

    long cInputSamples = m_nInputHeight * m_nInputWidth;

    hr = InputSurface( 0 )->LockSurface
        (NULL,
        m_ulLockTimeOut,
        DXLOCKF_READ,
        IID_IDXARGBReadPtr,
        (void**)&pInA,
        NULL
        );
    if( FAILED( hr ) )
    {
        return hr;
    }

// !!! avoid a copy if it's natively 32 bit?

    MakeSureBufAExists( cInputSamples );
    pInBufA = m_pInBufA;
    DXPACKEDRECTDESC x;
    x.pSamples = m_pInBufA;
    x.bPremult = FALSE;
    x.rect.top = 0; x.rect.left = 0;
    x.rect.bottom = m_nInputHeight;
    x.rect.right = m_nInputWidth;
    x.lRowPadding = 0;
    pInA->UnpackRect(&x);

    hr = InputSurface( 1 )->LockSurface
        (NULL,
        m_ulLockTimeOut,
        DXLOCKF_READ,
        IID_IDXARGBReadPtr,
        (void**)&pInB,
        NULL
        );
    if( FAILED( hr ) )
    {
        return hr;
    }

// !!! avoid a copy if it's natively 32 bit?

    MakeSureBufBExists( cInputSamples );
    pInBufB = m_pInBufB;
    x.pSamples = m_pInBufB;
    x.bPremult = FALSE;
    x.rect.top = 0; x.rect.left = 0;
    x.rect.bottom = m_nInputHeight;
    x.rect.right = m_nInputWidth;
    x.lRowPadding = 0;
    pInB->UnpackRect(&x);

    // no dithering !!!

    CComPtr<IDXARGBReadWritePtr> pOut;
    hr = OutputSurface()->LockSurface
        (NULL, // !!! &WI.OutputBnds,
        m_ulLockTimeOut,
        DXLOCKF_READWRITE,
        IID_IDXARGBReadWritePtr,
        (void**)&pOut,
        NULL
        );

    if( FAILED( hr ) )
    {
        return hr;
    }

    // output surface may not be the same size as the input surface
    //

    // !!! SCARY !!!

    IDXSurface * pOutSurface = NULL;
    pOut->GetSurface( IID_IDXSurface, (void**) &pOutSurface );
    DXBNDS RealOutBnds;
    pOutSurface->GetBounds( &RealOutBnds );
    pOutSurface->Release();
    CDXDBnds RealOutBnds2( RealOutBnds );
    long RealOutWidth = RealOutBnds2.Width( );
    long RealOutHeight = RealOutBnds2.Height( );

    // we'll do the effect on a buffer that's as big as our
    // inputs, then pack it into the destination

    // make sure the buffer's big enough
    //
    MakeSureOutBufExists( cInputSamples );

    // do the effect
    //
    DoEffect( m_pOutBuf, pInBufA, pInBufB, cInputSamples );

    // if the output is bigger than our input, then fill it first
    // !!! don't fill the whole thing!
    if (RealOutHeight > m_nInputHeight || RealOutWidth > m_nInputWidth) {

        RECT rc;
        rc.left = 0;
        rc.top = 0;
        rc.right = RealOutWidth;
        rc.bottom = RealOutHeight;
        DXPMSAMPLE FillValue;
        FillValue.Blue = 0;
        FillValue.Red = 0;
        FillValue.Green = 0;
        FillValue.Alpha = 0;
        pOut->FillRect( &rc, FillValue, false );
    }


    DXPACKEDRECTDESC PackedRect;
    RECT rc;

    int h = min(RealOutHeight, m_nInputHeight);
    int w = min(RealOutWidth, m_nInputWidth);
    rc.left = RealOutWidth / 2 - w / 2;
    rc.top = RealOutHeight /2 - h / 2;
    rc.right = rc.left + w;
    rc.bottom = rc.top + h;
    PackedRect.pSamples = (DXBASESAMPLE*)m_pOutBuf;
    if (m_nInputHeight > RealOutHeight)
        PackedRect.pSamples += ((m_nInputHeight - RealOutHeight) / 2) *
                m_nInputWidth;
    if (m_nInputWidth > RealOutWidth)
        PackedRect.pSamples += (m_nInputWidth - RealOutWidth) / 2;
    PackedRect.bPremult = true;
    PackedRect.rect = rc;
    if (m_nInputWidth > RealOutWidth)
        PackedRect.lRowPadding = m_nInputWidth - RealOutWidth;
    else
        PackedRect.lRowPadding = 0;

    pOut->PackRect( &PackedRect );

    return S_OK;
}

HRESULT CDxtJpeg::MakeSureBufAExists( long Samples )
{
    // If it exists, it must be the right size already
    if( m_pInBufA )
    {
        return NOERROR;
    }
    m_pInBufA = new DXSAMPLE[ Samples ];
    if( !m_pInBufA )
    {
        return E_OUTOFMEMORY;
    }
    return NOERROR;
}

HRESULT CDxtJpeg::MakeSureBufBExists( long Samples )
{
    // If it exists, it must be the right size already
    if( m_pInBufB )
    {
        return NOERROR;
    }
    m_pInBufB = new DXSAMPLE[ Samples ];
    if( !m_pInBufB )
    {
        return E_OUTOFMEMORY;
    }
    return NOERROR;
}

HRESULT CDxtJpeg::MakeSureOutBufExists( long Samples )
{
    // If it exists, it must be the right size already
    if( m_pOutBuf )
    {
        return NOERROR;
    }
    m_pOutBuf = new DXSAMPLE[ Samples ];
    if( !m_pOutBuf )
    {
        return E_OUTOFMEMORY;
    }
    return NOERROR;
}

HRESULT CDxtJpeg::DoEffect( DXSAMPLE * pOut, DXSAMPLE * pInA, DXSAMPLE * pInB, long Samples )
{
    if( !m_pMaskBuf )
    {
        return NOERROR;
    }

    float Percent = 0.5;
    get_Progress( &Percent );

    long Threshold = long((256+m_lBorderWidth+m_lBorderSoftness)*Percent)-(m_lBorderWidth+m_lBorderSoftness);

    DXSAMPLE *pA    = pInA;
    DXSAMPLE *pB    = pInB;
    DXSAMPLE *pO    = pOut;
    DXSAMPLE *pMask = m_pMaskBuf;

    DXSAMPLE bc;  // border coloring

    bc.Red = m_rgbBorder.rgbRed;
    bc.Green = m_rgbBorder.rgbGreen;
    bc.Blue = m_rgbBorder.rgbBlue;
    bc.Alpha = 0;

    for (long i = 0; i < Samples; ++i)
      {
        long avg = pMask->Blue;
        long diff = avg - Threshold;

        if( ( diff >= 0 ) && ( diff < m_lBorderWidth+m_lBorderSoftness ) )
        {
            if( m_lBorderWidth == 0 )
            {
                // do an anti-alias based on the difference
                //
                float p = float( diff ) / float( m_lBorderSoftness );
                pO->Blue = (BYTE)(pA->Blue * p + pB->Blue * ( 1.0 - p ));
                pO->Green = (BYTE)(pA->Green * p + pB->Green * ( 1.0 - p ));
                pO->Red = (BYTE)(pA->Red * p + pB->Red * ( 1.0 - p ));
                pO->Alpha = 0;

            }
            else if ( m_lBorderSoftness == 0 )
            {
                pO->Blue = bc.Blue;
                pO->Green = bc.Green;
                pO->Red = bc.Red;
                pO->Alpha = 0;
            }
            else /* both border width and softness */
            {
                if (diff < m_lBorderSoftness/2)  // Blending BC->B
                    {
                      float p = float(diff) / float(m_lBorderSoftness/2);
                      pO->Blue = (BYTE)(bc.Blue * p + pB->Blue * ( 1.0 - p ));
                      pO->Green = (BYTE)(bc.Green * p + pB->Green * ( 1.0 - p ));
                      pO->Red = (BYTE)(bc.Red * p + pB->Red * ( 1.0 - p ));
                      pO->Alpha = 0;
                    }

                else if (diff >= m_lBorderWidth + m_lBorderSoftness/2)  // Blending A->BC
                    {
                      diff -= m_lBorderWidth + m_lBorderSoftness/2;
                      float p = float(diff) / float(m_lBorderSoftness/2);
                      pO->Blue = (BYTE)(pA->Blue * p + bc.Blue * ( 1.0 - p ));
                      pO->Green = (BYTE)(pA->Green * p + bc.Green * ( 1.0 - p ));
                      pO->Red = (BYTE)(pA->Red * p + bc.Red * ( 1.0 - p ));
                      pO->Alpha = 0;
                    }

                else
                    { // Border
                      pO->Blue = bc.Blue;
                      pO->Green = bc.Green;
                      pO->Red = bc.Red;
                      pO->Alpha = bc.Alpha;
                    }
            }

        }
        else
        {
            if( avg >= Threshold )
            {
                *pO = *pA;
            }
            else
            {
                *pO = *pB;
            }
        }
        ++pA;
        ++pB;
        ++pO;
        ++pMask;
      }

    return NOERROR;
}

HRESULT CDxtJpeg::InitializeMask( )
{
    // do we need to do anything?
    if (m_dwFlush == 0)
	return S_OK;

    HRESULT hr = NOERROR;

    if (m_dwFlush & (MASK_FLUSH_CHANGEMASK)) {
      if (409 == m_nMaskNum)
          hr = CreateRandomMask();
      else
          hr = LoadMaskResource();
    }

    if(FAILED(hr))
      return hr;

    m_dwFlush = 0;

    // !!! must call - sets m_pidxsMask
    hr = ScaleByDXTransform();	// do displacement, scale, offset, & replicate

    if (FAILED(hr))
      return hr;

    ULONG GenID = 0;
    IDXARGBReadPtr * pRgbPtr = NULL;

    hr = m_pidxsMask->LockSurface(
        NULL,
        INFINITE,
        DXLOCKF_READ,
        IID_IDXARGBReadPtr,
        (void**) &pRgbPtr,
        &GenID
        );

    if( m_pMaskBuf )
    {
        delete [] m_pMaskBuf;
    }

    m_pMaskBuf = new DXSAMPLE[m_nInputWidth*m_nInputHeight];

    if (NULL == m_pMaskBuf)
        return E_OUTOFMEMORY;

    DXPACKEDRECTDESC dpdd;

    dpdd.pSamples = m_pMaskBuf;
    dpdd.bPremult = FALSE;
    dpdd.rect.top = 0;
    dpdd.rect.left = 0;
    dpdd.rect.bottom = m_nInputHeight;
    dpdd.rect.right = m_nInputWidth;
    dpdd.lRowPadding = 0;

    pRgbPtr->UnpackRect(&dpdd);
    pRgbPtr->Release();

    m_pidxsMask->Release();
    m_pidxsMask = NULL;

    RescaleGrayscale();

    m_dwFlush = 0x00;

    return NOERROR;
}

void CDxtJpeg::MapMaskToResource(long *lMaskNum)
{

  m_bFlipMaskH = FALSE;
  m_bFlipMaskV = FALSE;

  switch(*lMaskNum)

    {

      case   1: /* Base images */
      case   2:
      case   3:
      case   7:
      case   8:
      case  21:
      case  22:
      case  23:
      case  24:
      case  41:
      case  43:
      case  44:
      case  45:
      case  47:
      case  48:
      case  61:
      case  62:
      case  65:
      case  66:
      case  71:
      case  72:
      case  73:
      case  74:
      case 101:
      case 102:
      case 103:
      case 104:
      case 107:
      case 108:
      case 111:
      case 113:
      case 114:
      case 119:
      case 120:
      case 121:
      case 122:
      case 123:
      case 124:
      case 125:
      case 127:
      case 128:
      case 129:
      case 130:
      case 131:
      case 201:
      case 202:
      case 205:
      case 206:
      case 207:
      case 221:
      case 211:
      case 212:
      case 213:
      case 214:
      case 222:
      case 225:
      case 226:
      case 227:
      case 228:
      case 231:
      case 232:
      case 235:
      case 236:
      case 241:
      case 245:
      case 246:
      case 251:
      case 252:
      case 261:
      case 262:
      case 263:
      case 264:
      case 301:
      case 302:
      case 303:
      case 310:
      case 311:
      case 320:
      case 322:
      case 324:
      case 326:
      case 328:
      case 340:
      case 342:
      case 344:
      case 345:
      case 350:
      case 352:
      case 409:
        break;

      case   4: *lMaskNum = 3;   m_bFlipMaskH = TRUE; break;
      case   5: *lMaskNum = 3;   m_bFlipMaskH = TRUE; m_bFlipMaskV = TRUE; break;
      case   6: *lMaskNum = 3;   m_bFlipMaskV = TRUE; break;
      case  25: *lMaskNum = 23;  m_bFlipMaskV = TRUE; break;
      case  26: *lMaskNum = 24;  m_bFlipMaskH = TRUE; break;
      case  42: *lMaskNum = 41;  m_bFlipMaskH = TRUE; break;
      case  46: *lMaskNum = 45;  m_bFlipMaskH = TRUE; break;
      case  63: *lMaskNum = 61;  m_bFlipMaskV = TRUE; break;
      case  64: *lMaskNum = 62;  m_bFlipMaskH = TRUE; break;
      case  67: *lMaskNum = 65;  m_bFlipMaskV = TRUE; break;
      case  68: *lMaskNum = 66;  m_bFlipMaskH = TRUE; break;
      case 105: *lMaskNum = 103; m_bFlipMaskV = TRUE; break;
      case 106: *lMaskNum = 104; m_bFlipMaskH = TRUE; break;
      case 109: *lMaskNum = 107; m_bFlipMaskV = TRUE; break;
      case 110: *lMaskNum = 108; m_bFlipMaskH = TRUE; break;
      case 112: *lMaskNum = 111; m_bFlipMaskV = TRUE; break;
      case 203: *lMaskNum = 201; m_bFlipMaskH = TRUE; m_bFlipMaskV = TRUE; break;
      case 204: *lMaskNum = 202; m_bFlipMaskH = TRUE; m_bFlipMaskV = TRUE; break;
      case 223: *lMaskNum = 221; m_bFlipMaskH = TRUE; m_bFlipMaskV = TRUE; break;
      case 224: *lMaskNum = 222; m_bFlipMaskH = TRUE; m_bFlipMaskV = TRUE; break;
      case 233: *lMaskNum = 231; m_bFlipMaskV = TRUE; break;
      case 234: *lMaskNum = 232; m_bFlipMaskH = TRUE; break;
      case 242: *lMaskNum = 241; m_bFlipMaskV = TRUE; break;
      case 243: *lMaskNum = 241; m_bFlipMaskH = TRUE; m_bFlipMaskV = TRUE; break;
      case 244: *lMaskNum = 241; m_bFlipMaskH = TRUE; break;
      case 253: *lMaskNum = 251; m_bFlipMaskV = TRUE; break;
      case 254: *lMaskNum = 252; m_bFlipMaskH = TRUE; break;
      case 304: *lMaskNum = 303; m_bFlipMaskH = TRUE; break;
      case 305: *lMaskNum = 303; m_bFlipMaskH = TRUE; m_bFlipMaskV = TRUE; break;
      case 306: *lMaskNum = 303; m_bFlipMaskV = TRUE; break;
      case 312: *lMaskNum = 310; m_bFlipMaskH = TRUE; m_bFlipMaskV = TRUE; break;
      case 313: *lMaskNum = 311; m_bFlipMaskH = TRUE; m_bFlipMaskV = TRUE; break;
      case 314: *lMaskNum = 311; m_bFlipMaskH = TRUE; break;
      case 315: *lMaskNum = 310; m_bFlipMaskH = TRUE; break;
      case 316: *lMaskNum = 311; m_bFlipMaskV = TRUE; break;
      case 317: *lMaskNum = 310; m_bFlipMaskV = TRUE; break;
      case 321: *lMaskNum = 320; m_bFlipMaskV = TRUE; break;
      case 323: *lMaskNum = 322; m_bFlipMaskV = TRUE; break;
      case 325: *lMaskNum = 324; m_bFlipMaskH = TRUE; break;
      case 327: *lMaskNum = 326; m_bFlipMaskH = TRUE; break;
      case 329: *lMaskNum = 328; m_bFlipMaskH = TRUE; break;
      case 341: *lMaskNum = 340; m_bFlipMaskV = TRUE; break;
      case 343: *lMaskNum = 342; m_bFlipMaskH = TRUE; break;
      case 351: *lMaskNum = 350; m_bFlipMaskH = TRUE; break;
      case 353: *lMaskNum = 352; m_bFlipMaskH = TRUE; break;

      default:
        *lMaskNum = 1; m_bFlipMaskH = FALSE; m_bFlipMaskV = FALSE;

    }
}

void CDxtJpeg::FlipSmpteMask()
{
    DbgLog((LOG_TRACE,2,TEXT("JPEG::Flip mask")));
    IDXARGBReadWritePtr *prw = NULL;

    ULONG GenID = 0;

    HRESULT hr = m_pidxsRawMask->LockSurface(
        NULL,
        INFINITE,
        DXLOCKF_READWRITE,
        IID_IDXARGBReadWritePtr,
        (void**)&prw,
        &GenID
        );

    DXSAMPLE *pMask = new DXSAMPLE[m_ulMaskWidth*m_ulMaskHeight];

    DXPACKEDRECTDESC x;
    x.pSamples = pMask;
    x.bPremult = FALSE;
    x.rect.top = 0; x.rect.left = 0;
    x.rect.bottom = m_ulMaskHeight;
    x.rect.right = m_ulMaskWidth;
    x.lRowPadding = 0;
    prw->UnpackRect(&x);

    DXSAMPLE *dxs = new DXSAMPLE[m_ulMaskWidth];

    DWORD dwRow1Start = 0;
    DWORD dwRow2Start = m_ulMaskWidth*(m_ulMaskHeight-1);
    DWORD dwNumBytes = sizeof(DXSAMPLE)*m_ulMaskWidth;

    if (m_bFlipMaskV) {
      for (unsigned int h = 0; h < m_ulMaskHeight/2; ++h)
        {
          memcpy(&dxs[0], &pMask[dwRow1Start], dwNumBytes);
          memcpy(&pMask[dwRow1Start], &pMask[dwRow2Start], dwNumBytes);
          memcpy(&pMask[dwRow2Start], &dxs[0], dwNumBytes);
          dwRow1Start += m_ulMaskWidth;
          dwRow2Start -= m_ulMaskWidth;
        }
    }

    if (m_bFlipMaskH) {
      for (unsigned int h = 0; h < m_ulMaskHeight; ++h)
        {
          memcpy(dxs, &pMask[h * m_ulMaskWidth], dwNumBytes);
          for (unsigned int w = 0; w < m_ulMaskWidth / 2; ++w)
            {
	      pMask[h * m_ulMaskWidth + w] = pMask[(h+1)*m_ulMaskWidth - 1 - w];
	      pMask[(h+1)*m_ulMaskWidth - 1 - w] = dxs[w];
            }
        }
    }

    x.bPremult = TRUE;	// faster?
    prw->PackRect(&x);

    prw->Release();

    delete [] dxs;
    delete [] pMask;
}

HRESULT CDxtJpeg::ScaleByDXTransform()
{
    // this function uses m_xScale and m_yScale to determine aspect
    // ratio. m_offsetx and m_offsety causes scaling because we can't
    // clip.

    DbgLog((LOG_TRACE,2,TEXT("JPEG::Scale and Parameterize")));
    float pc1 = m_nInputWidth / (float)m_ReplicateX;     // Precalc (save away resultant)
    float pc2 = m_nInputHeight / (float)m_ReplicateY;    // Precalc (save away resultant)
    float xp0 = pc1+abs(m_xDisplacement)*2;
    float yp0 = pc2+abs(m_yDisplacement)*2;
    float xm0 = m_ulMaskWidth*m_xScale;
    float ym0 = m_ulMaskHeight*m_yScale;

    float xm1;
    float ym1;

    if ((xp0/yp0) >= (xm0/ym0))
      { xm1 = xp0; ym1 = (xp0*ym0)/xm0; }
    else
      { ym1 = yp0; xm1 = (yp0*xm0)/ym0; }

    float x_off = (xm1/2)-m_xDisplacement-(pc1/2);
    float y_off = (ym1/2)-m_yDisplacement-(pc2/2);

    float origin_x = (x_off*m_ulMaskWidth)/xm1;
    float origin_y = (y_off*m_ulMaskHeight)/ym1;

    float extent_x = (pc1*m_ulMaskWidth)/xm1;
    float extent_y = (pc2*m_ulMaskHeight)/ym1;


    CDXDBnds bounds;
    bounds.SetXYSize(m_nInputWidth, m_nInputHeight);

    HRESULT hr = m_cpSurfFact->CreateSurface(
      NULL,
      NULL,
      &DDPF_PMARGB32,
      &bounds,
      0,
      NULL,
      IID_IDXSurface,
      (void**)&m_pidxsMask);

    if(FAILED(hr)) {
        return hr;
    }

    CComPtr<IDXDCLock> pDCLockSrc, pDCLockDest;
    hr = m_pidxsRawMask->LockSurfaceDC(0, INFINITE, DXLOCKF_READ, &pDCLockSrc);
    if(SUCCEEDED(hr)) {
        hr = m_pidxsMask->LockSurfaceDC(0, INFINITE, DXLOCKF_READWRITE, &pDCLockDest);
    }

    if(SUCCEEDED(hr))
    {
        HDC hdcSrc = pDCLockSrc->GetDC();
        HDC hdcDest = pDCLockDest->GetDC();

        // if lock succeeded, we should have a DC
        ASSERT(hdcSrc && hdcDest);

        int x = SetStretchBltMode(hdcDest, COLORONCOLOR);
        ASSERT(x != 0);

        float x1 = 0, y1 = 0;

        for (long i1 = 0; i1 < m_ReplicateY; ++i1)
        {
            // adjust width to compensate for uneven multiples.
            int yWidth = (int)(y1 + pc2 + 0.5) - (int)y1;

            for (long i2 = 0; i2 < m_ReplicateX; ++i2)
            {
                int xWidth = (int)(x1 + pc1 + 0.5) - (int)x1;

                StretchBlt(hdcDest, x1, y1, xWidth, yWidth,
                           hdcSrc, origin_x, origin_y, extent_x, extent_y,
                           SRCCOPY);
                x1 += pc1;
            }
            y1 += pc2;
            x1 = 0;
        }
    }

    if(FAILED(hr))
    {
        m_pidxsMask->Release();
        m_pidxsMask = 0;
    }

    return hr;
}

HRESULT CDxtJpeg::LoadMaskResource()
{
  HRESULT hr = E_FAIL;

  if (m_pidxsRawMask)
    {
        m_pidxsRawMask->Release();
        m_pidxsRawMask = NULL;
    }

  if( ( m_szMaskName[0] == 0 ) && ( m_nMaskNum > 0 ) )

    { // Mask from QEDWIPES.DLL

      long lFakeMask = m_nMaskNum;
      MapMaskToResource(&lFakeMask);

      HINSTANCE m_hMR;

      if (NULL == (m_hMR = LoadLibraryEx(TEXT("qedwipes.dll"), 0, LOAD_LIBRARY_AS_DATAFILE)))
        return hr;

      TCHAR tchResString[15];
      wsprintf(tchResString, TEXT("MASK%u"), lFakeMask);

      HRSRC hrcMask = FindResource(m_hMR, tchResString, TEXT("BINARY"));

      if (NULL != hrcMask)
      {
        HGLOBAL hgMask = LoadResource(m_hMR, hrcMask);
        BYTE *bMask = (BYTE *)LockResource(hgMask);

        // CreateStreamOnHBlobal requires specific memory characteristics: MOVEABLE, ~DISCARDABLE
        HGLOBAL hgMask2 = GlobalAlloc(GHND, SizeofResource(m_hMR, hrcMask));
        if( !hgMask2 )
        {
            FreeLibrary(m_hMR);
            return E_OUTOFMEMORY;
        }
        BYTE *bS = (BYTE *)GlobalLock(hgMask2);
        if( !bS )
        {
            GlobalFree( hgMask2 );
            FreeLibrary(m_hMR);
            return E_OUTOFMEMORY;
        }

        long Size = SizeofResource( m_hMR, hrcMask );

        // Dup image resource bits into CreateStreamOnHGlobal required memory
        memcpy(bS, bMask, Size );

        DbgLog((LOG_TRACE,2,TEXT("JPEG::Hitting the disk")));
        hr = LoadJPEGImage( bS, Size, &m_pidxsRawMask );

        GlobalUnlock(hgMask2);
        GlobalFree(hgMask2);
        FreeLibrary(m_hMR);

      }

    } // Mask from QEDWIPES.DLL

    if (m_szMaskName[0] != 0)
    {
        USES_CONVERSION;
        TCHAR * tf = W2T( m_szMaskName );

        HANDLE hf = CreateFile(
            tf,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            0,
            NULL );
        if( hf == INVALID_HANDLE_VALUE )
        {
            return GetLastError( );
        }

        DWORD ActuallyRead = 0;
        DWORD FileSize = GetFileSize( hf, NULL );
        if( !FileSize )
        {
            return E_INVALIDARG;
        }
        BYTE * pBuffer = new BYTE[FileSize];
        if( !pBuffer )
        {
            CloseHandle( hf );
            return E_OUTOFMEMORY;
        }
        BOOL worked = ReadFile(
            hf,
            pBuffer,
            FileSize,
            &ActuallyRead,
            NULL );
        if( !ActuallyRead )
        {
            return E_INVALIDARG;
        }
        DbgLog((LOG_TRACE,2,TEXT("JPEG::Hitting the disk")));
        hr = LoadJPEGImage( pBuffer, FileSize, &m_pidxsRawMask );
        delete [] pBuffer;
        CloseHandle( hf );
        hr = NOERROR;
    }

    if (SUCCEEDED(hr))
      {
        DXBNDS bounds;

        hr = m_pidxsRawMask->GetBounds(&bounds);

        CDXDBnds Bounds2(bounds);

        m_ulMaskWidth = Bounds2.Width();
        m_ulMaskHeight = Bounds2.Height();

        if (SUCCEEDED(hr) && (m_bFlipMaskV || m_bFlipMaskH))
          FlipSmpteMask();
      }

  return hr;
}

void CDxtJpeg::RescaleGrayscale()
{
  BYTE lowest = 0;
  BYTE highest = 0;

  DbgLog((LOG_TRACE,2,TEXT("JPEG::Rescale colours")));
  long Samples = m_nInputHeight*m_nInputWidth;
  for (long i = 0; i < Samples; ++i)
    {
      lowest = min(m_pMaskBuf[i].Blue, lowest);
      highest = max(m_pMaskBuf[i].Blue, highest);
    }

  float m = 255.0/(highest-lowest);	// for rescale to 0..255
  lowest = 0;
  highest = 0;

  for (i = 0; i < Samples; ++i)
  {
    m_pMaskBuf[i].Red = m_pMaskBuf[i].Green = m_pMaskBuf[i].Blue = (m_pMaskBuf[i].Green*m);
    lowest = min(m_pMaskBuf[i].Blue, lowest);
    highest = max(m_pMaskBuf[i].Blue, highest);
  }
}

HRESULT CDxtJpeg::LoadDefSettings()
{
    m_xDisplacement = 0;
    m_yDisplacement = 0;
    m_xScale = 1.0;
    m_yScale = 1.0;
    m_ReplicateX = 1;
    m_ReplicateY = 1;
    m_rgbBorder.rgbRed = 0;
    m_rgbBorder.rgbGreen = 0;
    m_rgbBorder.rgbBlue = 0;
    m_lBorderWidth = 0;
    m_lBorderSoftness = 0;

    m_dwFlush = MASK_FLUSH_CHANGEMASK;

    return NOERROR;
}

HRESULT CDxtJpeg::CreateRandomMask()
{
    CDXDBnds bounds;

    bounds.SetXYSize(m_nInputWidth, m_nInputHeight);

    if (m_pidxsRawMask)
      m_pidxsRawMask->Release();

    m_pidxsRawMask = NULL;

    HRESULT hr = m_cpSurfFact->CreateSurface(
      NULL,
      NULL,
      &MEDIASUBTYPE_RGB32,
      &bounds,
      0,
      NULL,
      IID_IDXSurface,
      (void**)&m_pidxsRawMask);

    if (FAILED(hr))
      return E_FAIL;

    CComPtr<IDXARGBReadWritePtr> prw = NULL;

    hr = m_pidxsRawMask->LockSurface(NULL,
        m_ulLockTimeOut,
        DXLOCKF_READWRITE,
        IID_IDXARGBReadWritePtr,
        (void**)&prw,
        NULL);

    if (FAILED(hr))
      return E_FAIL;

    unsigned long NumBlocksR = m_nInputWidth >> 4;
    unsigned long NumBlocksC = m_nInputHeight >> 4;
    unsigned long NumBlocks = NumBlocksR*NumBlocksC;

    UINT *BlockPattern = new UINT[NumBlocks];
    if( !BlockPattern )
    {
        return E_OUTOFMEMORY;
    }

    POINT *Point = new POINT[NumBlocks];
    if( !Point )
    {
        delete [] BlockPattern;
        return E_OUTOFMEMORY;
    }

    // "Randomness"
    for (unsigned int i = 0; i < NumBlocks; i++)
      {
        Point[i].x = (i % NumBlocksR)*16/*Block width*/;
        Point[i].y = (i/NumBlocksR)*16/*Block height*/;
        BlockPattern[i] = i;
      }

    unsigned SetLength = NumBlocks-1;
    while (SetLength > 0)
      {
        unsigned int pick = timeGetTime() % SetLength;
        unsigned int swap = BlockPattern[pick];
        BlockPattern[pick] = BlockPattern[SetLength];
        BlockPattern[SetLength] = swap;
        --SetLength;
      }

    DXPMSAMPLE *dxpm = new DXPMSAMPLE[16*16];

    DXPACKEDRECTDESC PackedRect;

    PackedRect.pSamples = dxpm;
    PackedRect.bPremult = FALSE;
    PackedRect.lRowPadding = 0;

    for (i = 0; i < NumBlocks; i++)
      {
        for (int s = 0; s < 16*16; ++s)
          {
            dxpm[s].Red = BYTE(i);
            dxpm[s].Green = BYTE(i);
            dxpm[s].Blue = BYTE(i);
            dxpm[s].Alpha = BYTE(0);
          }
        PackedRect.rect.top = Point[BlockPattern[i]].y;
        PackedRect.rect.left = Point[BlockPattern[i]].x;
        PackedRect.rect.bottom = PackedRect.rect.top+16;
        PackedRect.rect.right = PackedRect.rect.left+16;
        prw->PackRect(&PackedRect);
      }

	// init additional width and height members
    DXBNDS bounds2;
	
	hr = NOERROR;
    hr = m_pidxsRawMask->GetBounds(&bounds2);

	if(SUCCEEDED(hr))
	{
		CDXDBnds Bounds2(bounds2);

		// init the member vars, that are used in the DX Transform (for rescaling)
		m_ulMaskWidth = Bounds2.Width();
		m_ulMaskHeight = Bounds2.Height();
	}

	// clean up memory
    delete [] dxpm;
    delete [] BlockPattern;
    delete [] Point;

	// return success or failure
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxt\pip\pipdll.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Tue Mar 02 13:58:16 1999
 */
/* Compiler settings for E:\quartz\filterus\dexter\dxt\pip\pipdll.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __pipdll_h__
#define __pipdll_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IDxtPip_FWD_DEFINED__
#define __IDxtPip_FWD_DEFINED__
typedef interface IDxtPip IDxtPip;
#endif 	/* __IDxtPip_FWD_DEFINED__ */


#ifndef __DxtPip_FWD_DEFINED__
#define __DxtPip_FWD_DEFINED__

#ifdef __cplusplus
typedef class DxtPip DxtPip;
#else
typedef struct DxtPip DxtPip;
#endif /* __cplusplus */

#endif 	/* __DxtPip_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "dxtrans.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IDxtPip_INTERFACE_DEFINED__
#define __IDxtPip_INTERFACE_DEFINED__

/* interface IDxtPip */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDxtPip;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("423F19B1-C541-11d2-8D3B-00A0C9441E20")
    IDxtPip : public IDXEffect
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDxtPipVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDxtPip __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDxtPip __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDxtPip __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDxtPip __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDxtPip __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDxtPip __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDxtPip __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDxtPip __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDxtPip __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDxtPip __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDxtPip __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDxtPip __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDxtPip __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } IDxtPipVtbl;

    interface IDxtPip
    {
        CONST_VTBL struct IDxtPipVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDxtPip_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDxtPip_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDxtPip_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDxtPip_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDxtPip_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDxtPip_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDxtPip_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDxtPip_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDxtPip_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDxtPip_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDxtPip_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDxtPip_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDxtPip_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDxtPip_INTERFACE_DEFINED__ */



#ifndef __DxtPipDLLLib_LIBRARY_DEFINED__
#define __DxtPipDLLLib_LIBRARY_DEFINED__

/* library DxtPipDLLLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DxtPipDLLLib;

EXTERN_C const CLSID CLSID_DxtPip;

#ifdef __cplusplus

class DECLSPEC_UUID("423F19B0-C541-11d2-8D3B-00A0C9441E20")
DxtPip;
#endif
#endif /* __DxtPipDLLLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxtjpegdll\dxtjpegdll.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// DxtJpegDll.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f DxtJpegDllps.mk in the project directory.


#include <streams.h>

#ifdef FILTER_DLL

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "DxtJpegDll.h"
#include "DxtJpegDll_i.c"
#include "DxtJpeg.h"
#include "DxtJpegPP.h"

#if(_ATL_VER < 0x0300)
#include <atlctl.cpp>
#include <atlwin.cpp>
#endif

#include <dxtguid.c>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_DxtJpeg, CDxtJpeg)
OBJECT_ENTRY(CLSID_DxtJpegPP, CDxtJpegPP)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance /* !!!ATL30 , &LIBID_DXTJPEGDLLLib */);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(/* !!! ATL30 TRUE */);
}

CFactoryTemplate g_Templates[1];
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

#include "DxtJpegPP.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxtjpegdll\dxtjpeg.h ===
// DxtJpeg.h : Declaration of the CDxtJpeg

#ifndef __DXTJPEG_H_
#define __DXTJPEG_H_

#include "resource.h"       // main symbols
#include <dxatlpb.h>
#include <stdio.h>
//#define _INT32_DEFINED   // Keep jpeglib.h from redefining this
#include "..\jpeglib\jpeglib.h"

#define _BASECOPY_STRING L"Copyright Microsoft Corp. 1998.  Unauthorized duplication of this string is illegal. "

/////////////////////////////////////////////////////////////////////////////
// CDxtJpeg
class ATL_NO_VTABLE CDxtJpeg : 
        public CDXBaseNTo1,
	public CComCoClass<CDxtJpeg, &CLSID_DxtJpeg>,
        public CComPropertySupport<CDxtJpeg>,
        public IPersistStorageImpl<CDxtJpeg>,
        public ISpecifyPropertyPagesImpl<CDxtJpeg>,
        public IPersistPropertyBagImpl<CDxtJpeg>,
#ifdef FILTER_DLL
	public IDispatchImpl<IDxtJpeg, &IID_IDxtJpeg, &LIBID_DXTJPEGDLLLib>
#else
	public IDispatchImpl<IDxtJpeg, &IID_IDxtJpeg, &LIBID_DexterLib>
#endif
//	public CComObjectRootEx<CComMultiThreadModel>,
{
    bool m_bInputIsClean;
    bool m_bOutputIsClean;
    DXSAMPLE * m_pInBufA;
    DXSAMPLE * m_pInBufB;
    DXSAMPLE * m_pOutBuf;
    DXSAMPLE * m_pMaskBuf;
    long m_nInputWidth;
    long m_nInputHeight;
    long m_nOutputWidth;
    long m_nOutputHeight;
    WCHAR m_szMaskName[256];
    long m_nBorderMode;
    long m_nMaskNum;
    IStream *m_pisImageRes;
    BOOL m_bFlipMaskH;
    BOOL m_bFlipMaskV;
    long m_xDisplacement;
    long m_yDisplacement;
    double m_xScale;
    double m_yScale;
    long m_ReplicateX;
    long m_ReplicateY;

    IDXSurface *m_pidxsMask;
    IDXSurface *m_pidxsRawMask;

    unsigned long m_ulMaskWidth;
    unsigned long m_ulMaskHeight;

    RGBQUAD m_rgbBorder;

    long m_lBorderWidth;
    long m_lBorderSoftness;

    DDSURFACEDESC m_ddsd;

    DWORD m_dwFlush;

public:
        DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
        DECLARE_REGISTER_DX_TRANSFORM(IDR_DXTJPEG, CATID_DXImageTransform)
        DECLARE_GET_CONTROLLING_UNKNOWN()
        DECLARE_POLY_AGGREGATABLE(CDxtJpeg)

	CDxtJpeg();
        ~CDxtJpeg();

// DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDxtJpeg)
        // Block CDXBaseNTo1 IObjectSafety implementation because we
        // aren't safe for scripting
        COM_INTERFACE_ENTRY_NOINTERFACE(IObjectSafety) 
	COM_INTERFACE_ENTRY(IDxtJpeg)
	COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY(IDXTransform)
#if(_ATL_VER < 0x0300)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
#else
        COM_INTERFACE_ENTRY(IPersistPropertyBag)
        COM_INTERFACE_ENTRY(IPersistStorage)
        COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
#endif
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CDxtJpeg)
    PROP_ENTRY("MaskNum", 1, CLSID_DxtJpegPP)
    PROP_ENTRY("MaskName", 2, CLSID_DxtJpegPP)
    PROP_ENTRY("ScaleX", 3, CLSID_DxtJpegPP)
    PROP_ENTRY("ScaleY", 4, CLSID_DxtJpegPP)
    PROP_ENTRY("OffsetX", 5, CLSID_DxtJpegPP)
    PROP_ENTRY("OffsetY", 6, CLSID_DxtJpegPP)
    PROP_ENTRY("ReplicateX", 7, CLSID_DxtJpegPP)
    PROP_ENTRY("ReplicateY", 8, CLSID_DxtJpegPP)
    PROP_ENTRY("BorderColor", 9, CLSID_DxtJpegPP)
    PROP_ENTRY("BorderWidth", 10, CLSID_DxtJpegPP)
    PROP_ENTRY("BorderSoftness", 11, CLSID_DxtJpegPP)
    PROP_PAGE(CLSID_DxtJpegPP)
END_PROPERTY_MAP()

    STDMETHOD(get_MaskNum)(/*[out, retval]*/ long * pval);
    STDMETHOD(put_MaskNum)(/*[in]*/ long newVal);
    STDMETHOD(get_MaskName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_MaskName)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_ScaleX)(double *);
    STDMETHOD(put_ScaleX)(double);
    STDMETHOD(get_ScaleY)(double *);
    STDMETHOD(put_ScaleY)(double);
    STDMETHOD(get_OffsetX)(long *);
    STDMETHOD(put_OffsetX)(long);
    STDMETHOD(get_OffsetY)(long *);
    STDMETHOD(put_OffsetY)(long);
    STDMETHOD(get_ReplicateY)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_ReplicateY)(/*[in]*/ long newVal);
    STDMETHOD(get_ReplicateX)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_ReplicateX)(/*[in]*/ long newVal);
    STDMETHOD(get_BorderColor)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_BorderColor)(/*[in]*/ long newVal);
    STDMETHOD(get_BorderWidth)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_BorderWidth)(/*[in]*/ long newVal);
    STDMETHOD(get_BorderSoftness)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_BorderSoftness)(/*[in]*/ long newVal);
    STDMETHODIMP ApplyChanges() { return InitializeMask(); }
    STDMETHODIMP LoadDefSettings();

    // required for ATL
    BOOL            m_bRequiresSave;

    // CDXBaseNTo1 overrides
    //
    HRESULT WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue );
    HRESULT OnSetup( DWORD dwFlags );

    // our helper function
    //
    HRESULT _jpeg_create_bitmap2(j_decompress_ptr cinfo, IDXSurface ** ppSurface );
    HRESULT LoadJPEGImage( BYTE * pBuffer, long Size, IDXSurface ** );
    HRESULT DoEffect( DXSAMPLE * pOut, DXSAMPLE * pInA, DXSAMPLE * pInB, long Samples );
    HRESULT MakeSureBufAExists( long Samples );
    HRESULT MakeSureBufBExists( long Samples );
    HRESULT MakeSureOutBufExists( long Samples );
    void FreeStuff( );
    HRESULT InitializeMask();
    void MapMaskToResource(long *);
    void FlipSmpteMask();
    HRESULT ScaleByDXTransform();
    HRESULT LoadMaskResource();
    void RescaleGrayscale();
    HRESULT CreateRandomMask();

};

#define MASK_FLUSH_CHANGEMASK     0x001
#define MASK_FLUSH_CHANGEPARMS    0x002

#endif //__DXTJPEG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxtjpegdll\dxtjpegpp.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// DxtJpegPP.h : Declaration of the CDxtJpegPP

#ifndef __DXTJPEGPP_H_
#define __DXTJPEGPP_H_

#include "resource.h"       // main symbols

EXTERN_C const CLSID CLSID_DxtJpegPP;

/////////////////////////////////////////////////////////////////////////////
// CDxtJpegPP
class ATL_NO_VTABLE CDxtJpegPP :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDxtJpegPP, &CLSID_DxtJpegPP>,
	public IPropertyPageImpl<CDxtJpegPP>,
	public CDialogImpl<CDxtJpegPP>
{
public:
	CDxtJpegPP() 
	{
		m_dwTitleID = IDS_TITLEDxtJpegPP;
		m_dwHelpFileID = IDS_HELPFILEDxtJpegPP;
		m_dwDocStringID = IDS_DOCSTRINGDxtJpegPP;
    m_bNumOverFile = TRUE;
	}

	enum {IDD = IDD_DXTJPEGPP};

DECLARE_REGISTRY_RESOURCEID(IDR_DXTJPEGPP)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDxtJpegPP) 
#if(_ATL_VER < 0x0300)
	COM_INTERFACE_ENTRY_IMPL(IPropertyPage)
#else
	COM_INTERFACE_ENTRY(IPropertyPage)
#endif
END_COM_MAP()

BEGIN_MSG_MAP(CDxtJpegPP)
        COMMAND_HANDLER(IDC_NUMOVERFILE, BN_CLICKED, OnNumOverFile)
        COMMAND_HANDLER(IDC_PICKFILE, BN_CLICKED, OnSelectFile)
        COMMAND_HANDLER(IDC_RESTOREDEFAULTS, BN_CLICKED, OnFactorySettings)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	CHAIN_MSG_MAP(IPropertyPageImpl<CDxtJpegPP>)
END_MSG_MAP()

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled); 
    LRESULT OnNumOverFile(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSelectFile(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnFactorySettings(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    STDMETHOD(Apply)(void);

// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

private:
    // Helper methods
    void SetPPMaskProperties(IDxtJpeg *);
    void SetPPScalingProperties(IDxtJpeg *);
    void SetPPReplicationProperties(IDxtJpeg *);
    void SetPPBorderProperties(IDxtJpeg *);
    void SetMaskPropertiesFromPP(IDxtJpeg *);
    void SetScalingPropertiesFromPP(IDxtJpeg *);
    void SetPReplicationPropertiesFromPP(IDxtJpeg *);
    void SetBorderPropertiesFromPP(IDxtJpeg *);

    BOOL m_bWhyIsApplyCalledTwice;
    BOOL m_bNumOverFile;

};


#endif //__DXTJPEGPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxtjpegdll\dxtjpegpp.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// DxtJpegPP.cpp : Implementation of CDxtJpegPP
#include <streams.h>
#include "stdafx.h"
#ifdef FILTER_DLL
#include "DxtJpegDll.h"
#else
#include <qeditint.h>
#include <qedit.h>
#endif
#include "DxtJpeg.h"
#include "DxtJpegPP.h"
#include <stdio.h>
#pragma warning (disable:4244 4800)

/////////////////////////////////////////////////////////////////////////////
// CDxtJpegPP

LRESULT CDxtJpegPP::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    USES_CONVERSION;
    CComQIPtr<IDxtJpeg, &IID_IDxtJpeg> pOwner( m_ppUnk[0] );

    // Populate scaling, displacement information
    SetPPMaskProperties(pOwner);
    SetPPScalingProperties(pOwner);
    SetPPReplicationProperties(pOwner);
    SetPPBorderProperties(pOwner);

    m_bWhyIsApplyCalledTwice = FALSE;

    return TRUE;
}

STDMETHODIMP CDxtJpegPP::Apply(void)
{
    ATLTRACE(_T("CDxtJpegPP::Apply\n"));
    for (UINT i = 0; i < m_nObjects; i++)
    {
      CComQIPtr<IDxtJpeg, &IID_IDxtJpeg> pOwner( m_ppUnk[0] );

      if (!m_bWhyIsApplyCalledTwice)
        {
            SetMaskPropertiesFromPP(pOwner);
            SetScalingPropertiesFromPP(pOwner);
            SetPReplicationPropertiesFromPP(pOwner);
            SetBorderPropertiesFromPP(pOwner);
            pOwner->ApplyChanges();
            m_bWhyIsApplyCalledTwice = TRUE;
        }
    }

    m_bDirty = FALSE;
    return S_OK;
}

LRESULT CDxtJpegPP::OnNumOverFile(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (m_bNumOverFile)
      SetDlgItemText(IDC_NUMOVERFILE, TEXT(">"));
    else
      SetDlgItemText(IDC_NUMOVERFILE, TEXT("<"));

    m_bNumOverFile = !m_bNumOverFile;

    SetDirty(TRUE);
    bHandled = TRUE;
    return 0;
}

LRESULT CDxtJpegPP::OnSelectFile(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{

    OPENFILENAME ofn;
    TCHAR tReturnName[_MAX_PATH];
    tReturnName[0] = 0;

    memset(&ofn, 0, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = NULL;
    ofn.hInstance = NULL;
    ofn.lpstrFilter = NULL;
    ofn.lpstrFile = tReturnName;
    ofn.nMaxFile = _MAX_PATH;
    ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_LONGNAMES;
    if (!GetOpenFileName(&ofn))
      return FALSE;

    // Nice touch-autoswitch to FILE over NUM
    SetDlgItemText(IDC_NUMOVERFILE, TEXT(">"));
    m_bNumOverFile = FALSE;

    SetDlgItemText(IDC_FILEMASK, ofn.lpstrFile );

    SetDirty(TRUE);
    bHandled = TRUE;
    return 0;
}

LRESULT CDxtJpegPP::OnFactorySettings(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    CComQIPtr<IDxtJpeg, &IID_IDxtJpeg> pOwner( m_ppUnk[0] );

    pOwner->LoadDefSettings();

    SetPPMaskProperties(pOwner);
    SetPPScalingProperties(pOwner);
    SetPPReplicationProperties(pOwner);
    SetPPBorderProperties(pOwner);

    // Nice touch-autoswitch to NUM
    SetDlgItemText(IDC_NUMOVERFILE, TEXT("<"));
    m_bNumOverFile = TRUE;

    SetDirty(TRUE);
    bHandled = TRUE;
    return 0;
}

void CDxtJpegPP::SetPPMaskProperties(IDxtJpeg *punk)
{
    USES_CONVERSION;
    TCHAR convert[10];
    long lResult;

    punk->get_MaskNum(&lResult);
    wsprintf(convert, TEXT("%u"), lResult);
    SetDlgItemText(IDC_SMPTE_EDIT, convert);

    BSTR MaskName;
    punk->get_MaskName(&MaskName);
    TCHAR * tMaskName = W2T( MaskName );
    SetDlgItemText(IDC_FILEMASK, tMaskName);
    SysFreeString(MaskName);
}

void CDxtJpegPP::SetPPScalingProperties(IDxtJpeg *punk)
{
    DOUBLE dbNum;

    punk->get_ScaleX(&dbNum);
    SetDlgItemInt(IDC_XSCALE, UINT(dbNum*100.0), FALSE);

    punk->get_ScaleY(&dbNum);
    SetDlgItemInt(IDC_YSCALE, UINT(dbNum*100.0), FALSE);

    LONG lNum;

    punk->get_OffsetX(&lNum);
    SetDlgItemInt(IDC_XDISPLACEMENT, int(lNum), TRUE);

    punk->get_OffsetY(&lNum);
    SetDlgItemInt(IDC_YDISPLACEMENT, int(lNum), TRUE);
}

void CDxtJpegPP::SetPPReplicationProperties(IDxtJpeg *punk)
{
    long lResult;

    punk->get_ReplicateX(&lResult);
    SetDlgItemInt(IDC_REPLICATE_X, UINT(lResult), FALSE);

    punk->get_ReplicateY(&lResult);
    SetDlgItemInt(IDC_REPLICATE_Y, UINT(lResult), FALSE);
}

void CDxtJpegPP::SetPPBorderProperties(IDxtJpeg *punk)
{
    long l;

    punk->get_BorderWidth(&l);
    SetDlgItemInt(IDC_BORDERWIDTH, (int)l);

    punk->get_BorderSoftness(&l);
    SetDlgItemInt(IDC_BORDERSOFTNESS, (int)l);

    punk->get_BorderColor(&l);

    SetDlgItemInt(IDC_BORDER_R, (int)((l & 0xFF0000) >> 16));
    SetDlgItemInt(IDC_BORDER_G, (int)((l & 0xFF00) >> 8));
    SetDlgItemInt(IDC_BORDER_B, (int)(l & 0xFF));
}

void CDxtJpegPP::SetMaskPropertiesFromPP(IDxtJpeg *punk)
{
  if (m_bNumOverFile)
    punk->put_MaskNum(UINT(GetDlgItemInt(IDC_SMPTE_EDIT, NULL, FALSE)));

  if (!m_bNumOverFile)
    {
      BSTR bstr;
      if (GetDlgItemText(IDC_FILEMASK, bstr))
        {
          punk->put_MaskName(bstr);
          SysFreeString(bstr);
        }
    }
}

void CDxtJpegPP::SetScalingPropertiesFromPP(IDxtJpeg *punk)
{
  punk->put_ScaleX(DOUBLE(GetDlgItemInt(IDC_XSCALE, NULL, FALSE))/100.0);
  punk->put_ScaleY(DOUBLE(GetDlgItemInt(IDC_YSCALE, NULL, FALSE))/100.0);
  punk->put_OffsetX(LONG(GetDlgItemInt(IDC_XDISPLACEMENT, NULL, TRUE)));
  punk->put_OffsetY(LONG(GetDlgItemInt(IDC_YDISPLACEMENT, NULL, TRUE)));
}

void CDxtJpegPP::SetPReplicationPropertiesFromPP(IDxtJpeg *punk)
{
  punk->put_ReplicateX(GetDlgItemInt(IDC_REPLICATE_X, NULL, FALSE));
  punk->put_ReplicateY(GetDlgItemInt(IDC_REPLICATE_Y, NULL, FALSE));
}

void CDxtJpegPP::SetBorderPropertiesFromPP(IDxtJpeg *punk)
{
  punk->put_BorderWidth(LONG(GetDlgItemInt(IDC_BORDERWIDTH, NULL, FALSE)));
  punk->put_BorderSoftness(LONG(GetDlgItemInt(IDC_BORDERSOFTNESS, NULL, FALSE)));
  punk->put_BorderColor(LONG(
      ((UINT(GetDlgItemInt(IDC_BORDER_R, NULL, FALSE)) & 0xFF) << 16)+
      ((UINT(GetDlgItemInt(IDC_BORDER_G, NULL, FALSE)) & 0xFF) << 8)+
      ((UINT(GetDlgItemInt(IDC_BORDER_B, NULL, FALSE)) & 0xFF))
      ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxtjpegdll\resource.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dxtjpegdll.rc
//
#define IDR_DXTJPEG                     1101
#define IDS_TITLEDxtJpegPP              1102
#define IDS_HELPFILEDxtJpegPP           1103
#define IDS_DOCSTRINGDxtJpegPP          1104
#define IDR_DXTJPEGPP                   1105
#define IDD_DXTJPEGPP                   1106
#define IDC_BROWSE                      1111
#define IDC_MASK_NAME                   1112
#define IDC_THRESHOLD                   1113
#define IDC_DO_BORDER                   1114
#define IDC_SMPTE_EDIT                  1115
#define IDC_XSCALE                      1117
#define IDC_YSCALE                      1118
#define IDC_XDISPLACEMENT               1119
#define IDC_YDISPLACEMENT               1120
#define IDC_REPLICATE_X                 1121
#define IDC_REPLICATE_Y                 1122
#define IDC_BORDERED                    1123
#define IDC_BORDERWIDTH                 1124
#define IDC_BORDER_DESC1                1125
#define IDC_BORDER_R                    1126
#define IDC_BORDER_G                    1127
#define IDC_BORDER_B                    1128
#define IDC_STATIC_BR                   1129
#define IDC_STATIC_BG                   1130
#define IDC_STATIC_BB                   1131
#define IDC_PICKFILE                    1132
#define IDC_FILEMASK                    1133
#define IDC_BORDERSOFTNESS              1134
#define IDC_BORDER_DESC2                1135
#define IDC_RESTOREDEFAULTS             1136
#define IDC_NUMOVERFILE                 1137


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        1138
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         1138
#define _APS_NEXT_SYMED_VALUE           1108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxtjpegdll\loadjpg.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include "stdafx.h"
#ifdef FILTER_DLL
#include "DxtJpegDll.h"
#else
#include <qeditint.h>
#include <qedit.h>
#endif
#include "dxtjpeg.h"
#include <setjmp.h>
extern WORD DibNumColors (VOID FAR *pv);

// tonycan: #defines to get this to compile
#define Assert( x )         ASSERT( x )
#define ThrowIfFailed( x )  ( x )

/////////////////////////////////////////////////////////////////////////
struct my_error_mgr
{
  struct jpeg_error_mgr pub;
  jmp_buf setjmp_buffer;
};

typedef struct my_error_mgr * my_error_ptr;

////////////////////////////////////////////////////////////////////////
METHODDEF(void) my_error_exit ( j_common_ptr cinfo)
{
  my_error_ptr myerr = (my_error_ptr) cinfo->err;

/* Return control to the setjmp point */
  longjmp(myerr->setjmp_buffer, 1);
}

//////////////////////////////////////////////////////////////////////////
HRESULT CDxtJpeg::_jpeg_create_bitmap2(j_decompress_ptr cinfo, IDXSurface ** ppSurface )
{
    int width = cinfo->output_width;

    CDXDBnds bounds;

    bounds.SetXYSize( width, cinfo->output_height );

    HRESULT hr = m_cpSurfFact->CreateSurface(
        NULL,
        NULL,
        &MEDIASUBTYPE_RGB32,
        &bounds,
        0,
        NULL,
        IID_IDXSurface,
        (void**) ppSurface );

    if(FAILED(hr )) {
        return hr;
    }

    CComPtr<IDXARGBReadWritePtr> prw = NULL;

    hr = (*ppSurface)->LockSurface(
        NULL,
        m_ulLockTimeOut,
        DXLOCKF_READWRITE,
        IID_IDXARGBReadWritePtr,
        (void**)&prw,
        NULL);



    // The compressor has not quantized color (and we're either a
    // grey scale or a 24bpp image)
    //

    // Make sure it's a format we can handle. (BUGBUG - For now, we only handle
    // 24bpp color)
    //
    int byteperpix = cinfo->out_color_components;
    int bytes_per_line = ((width * byteperpix) + 3) & -4;

    BYTE * TripArray = new BYTE[width*3];
    DXSAMPLE * QuadArray = new DXSAMPLE[width];

    while (cinfo->output_scanline < cinfo->output_height)
    {
        jpeg_read_scanlines( cinfo, &TripArray, 1 );
        // transfer Triple to the surface buffer
        long ii = 0;
        for( int i = 0 ; i < width ; i++ )
        {
            if( byteperpix == 1 )
            {
                QuadArray[i].Red = TripArray[ii];
                QuadArray[i].Blue = TripArray[ii];
                QuadArray[i].Green = TripArray[ii++];
                QuadArray[i].Alpha = 255;
            }
            else
            {
                QuadArray[i].Red = TripArray[ii++];
                QuadArray[i].Blue = TripArray[ii++];
                QuadArray[i].Green = TripArray[ii++];
                QuadArray[i].Alpha = 255;
            }
        }
        prw->PackAndMove( QuadArray, width );
    }

    delete [] TripArray;
    delete [] QuadArray;

    return NOERROR;
}

struct jpegsource : public jpeg_source_mgr
{
    BYTE * m_pBuffer;
    long m_nSize;
    long m_nRead;
    CCritSec m_Lock;

    // STATIC FUNCTIONS
    //
    static void init_source2( j_decompress_ptr pDecompressStruct )
    {
        jpegsource * pSrc = (jpegsource*) pDecompressStruct->src;
        pSrc->init_source3( pDecompressStruct );
    }

    static boolean fill_input_buffer2( j_decompress_ptr pDecompressStruct )
    {
        jpegsource * pSrc = (jpegsource*) pDecompressStruct->src;
        return pSrc->fill_input_buffer3( pDecompressStruct );
    }

    static void skip_input_data2( j_decompress_ptr pDecompressStruct, long num_bytes )
    {
        jpegsource * pSrc = (jpegsource*) pDecompressStruct->src;
        pSrc->skip_input_data3( pDecompressStruct, num_bytes );
    }

    static boolean resync_to_restart2( j_decompress_ptr pDecompressStruct, int desired )
    {
        jpegsource * pSrc = (jpegsource*) pDecompressStruct->src;
        return pSrc->resync_to_restart3( pDecompressStruct, desired );
    }

    static void term_source2( j_decompress_ptr pDecompressStruct )
    {
        jpegsource * pSrc = (jpegsource*) pDecompressStruct->src;
        pSrc->term_source3( pDecompressStruct );
    }

    // REAL FUNCTIONS
    //
    void init_source3( j_decompress_ptr pDecompressStruct )
    {
        int i = 0;
    }

    boolean fill_input_buffer3( j_decompress_ptr pDecompressStruct )
    {
        long ReadSize = m_nSize - m_nRead;
        if( ReadSize == 0 )
        {
            return false;
        }
        if( ReadSize > 128 )
        {
            ReadSize = 128;
        }
        bytes_in_buffer = ReadSize;
        next_input_byte = (JOCTET*) m_pBuffer + m_nRead;
        m_nRead += ReadSize;
        return true;
    }

    void skip_input_data3( j_decompress_ptr pDecompressStruct, long nBytes )
    {
        if( nBytes > 0 )
        {
            while( ULONG( nBytes ) > bytes_in_buffer )
            {
                nBytes -= bytes_in_buffer;
                fill_input_buffer3( pDecompressStruct );
            }

            next_input_byte += nBytes;
            bytes_in_buffer -= nBytes;
        }
    }

    boolean resync_to_restart3( j_decompress_ptr pDecompressStruct, int desired )
    {
        return false;
    }

    void term_source3( j_decompress_ptr pDecompressStruct )
    {
        int i = 0;
    }

    jpegsource( BYTE * pBuffer, long Size )
    {
        m_nRead = 0;
        m_pBuffer = pBuffer;
        m_nSize = Size;
        next_input_byte = NULL;
        bytes_in_buffer = 0;
        init_source = init_source2;
        fill_input_buffer = fill_input_buffer2;
        skip_input_data = skip_input_data2;
        resync_to_restart = jpeg_resync_to_restart;
        term_source = term_source2;
    }

};

HRESULT CDxtJpeg::LoadJPEGImage( BYTE * pBuffer, long Size, IDXSurface ** ppSurface )
{
    // blank struct
    //
    struct jpeg_decompress_struct cinfo; //the IJG jpeg structure
    struct my_error_mgr jerr;

    // Step 1: allocate and initialize JPEG decompression object
    // We set up the normal JPEG error routines, then override error_exit.
    //
    cinfo.err = jpeg_std_error(&jerr.pub);
    jerr.pub.error_exit = my_error_exit;

    // Establish the setjmp return context for my_error_exit to use.
    // If we get here, the JPEG code has signaled an error.
    // We need to clean up the JPEG object, close the input file, and return.
    //
    if( setjmp( jerr.setjmp_buffer ) )
    {
        jpeg_destroy_decompress( &cinfo );
        //XXXX HACKHACKHACK return -1 to stop the import from attempting to use
        //XXXX HACKHACKHACK the jpeg plugin, remove this code when it works and
        //XXXX HACKHACKHACK return NULL instead
        return E_FAIL;
    }

    // Now we can initialize the JPEG decompression object.
    //
    jpeg_create_decompress( &cinfo );

    /* Step 2: specify data source (eg, a file) */

    jpegsource oursource( pBuffer, Size );
    cinfo.src = &oursource;


    /* Step 3: read file parameters with jpeg_read_header() */

    jpeg_read_header( &cinfo, TRUE );
    /* We can ignore the return value from jpeg_read_header since
     *   (a) suspension is not possible with the stdio data source, and
     *   (b) we passed TRUE to reject a tables-only JPEG file as an error.
     * See libjpeg.doc for more info.
    */

    /* Step 4: set parameters for decompression */
    if( cinfo.out_color_space == JCS_GRAYSCALE )
    {
        cinfo.quantize_colors = TRUE;
    }

    /* In this example, we don't need to change any of the defaults set by
     * jpeg_read_header(), so we do nothing here.
    */

    /* Step 5: Start decompressor */

    jpeg_start_decompress( &cinfo );
    /* We can ignore the return value since suspension is not possible
    * with the stdio data source.
    */

    /* Step 6: while (scan lines remain to be read) */
    /*           jpeg_read_scanlines(...); */
    HRESULT hr = _jpeg_create_bitmap2( &cinfo, ppSurface );

    if(SUCCEEDED(hr))
    {
        /* Step 7: Finish decompression */

        jpeg_finish_decompress( &cinfo );

        /* Step 8: Release JPEG decompression object */
        jpeg_destroy_decompress( &cinfo );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxtjpegdll\stdafx.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include <streams.h>
#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <dtbase.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxtkey\dxtkey.h ===
// DxtKey.h : Declaration of the CDxtKey

#ifndef __DXTKEY_H_
#define __DXTKEY_H_

#include "resource.h"       // main symbols
#include <dxatlpb.h>

#define _BASECOPY_STRING L"Copyright Microsoft Corp. 1998.  Unauthorized duplication of this string is illegal. "

//##############################################################################################3
//X: does not care the value
//A: foreground image
//B: background image
//O: output image
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//iKeyType()     |iHueOrLuminance()| dwRGBA       | iSimilarity()| iBlend()|iThreshold()|iCutOff()|bInvert(I) |iSoftWidth()     |iSoftColor()              |iGain()  | bProgress( P)|
//---------------|-----------------|--------------|--------------|---------|------------|---------|-----------|-----------------|--------------------------|---------|--------------|
//  _RGB         |X                |   0x00RGB    | S=0-100      | L=0-100 |X           |X        |TRUE/FALSE |0-0.5*imageWidth |<0, used background image |  X      | p=0.o to 1.0 |
//               |                 |              |              |         |            |         |           |                 |>=0 to 0xFFFFFFFF         |
//
//  bottom  = (A.R*(100-S)/100 << 16 ) | (  A.G*(100-S)/100 << 8 ) |(  A.B*(100-S)/100  )
//  top     = ((A.R+(0xff-A.R)*S/100) <<16 ) |( A.G+(0xff-A.G*S/100) <<8) | (A.B+(0xff-A.B)*S/100) )
// 
//if(I==FLASE)
//{
//   if( bottom<= A  &&  A<= Top )  O= ( B*(100-L*)/100 + A*L/100 )*P + A*(1-P);      
//   else O=A;
// }
// else
// {
//   if( bottom>= A  || A>= Top )  O= ( B*(100-L*)/100 + A*L/100 )*P + A*(1-P);      
//   else O=A;
// }
//    
//---------------|---------------- |--------------|--------------|---------|------------|---------|------------------------------------------------------------------
//_NONRED        |
//---------------|-----------------|--------------|--------------|---------|------------|-------- |-----------|-----------------|--------------------------|---------|---------------
//_LUMINANCE     |L=0- 255         |  X           |   X          |  X      |T=0-100     | C=0-100 |TRUE/FALSE |                 |                          | G       |   P            
//               |                 |              |              |         |
//  if(I==FALSE)
//          if( PixLuminance* G<= L*(100-T)/100 )  O=(B*(100-C)/100 + A*C/100)*P +A*(1-P)    
//          else O=A;
//  esle
//          if( PixLuminance* G >=L*(100-T)/100 )  O=(B*(100-C)/100 + A*C/100)*P +A*(1-P)     
//          else O=A;
//
//---------------|-----------------|--------------|--------------|---------|------------------------------------------------------------------------------------------------------
//  _HUE         |H=0-255          |  X           |  X           |  X      |T=1-100     | C=0-100 |TRUE/FALSE |                 |                          | G       |   P            
//
//  if(I==FALSE)
//          if( PixHue* G<= H*(100-T)/100 ) O=(B*(100-C)/100 + A*C/100)*P +A*(1-P)     
//          else O=A;
//  esle
//          if( PixHue* G >=H*(100-T)/100 ) O=(B*(100-C)/100 + A*C/100)*P +A*(1-P)     
//          else O=A;

//---------------|-----------------|--------------|----------------------------------------------------------------------------------------------------------------------
// DXTKEY_ALPHA  | X               | X            |   X          |  X      |X          | X         |TRUE/FALSE |                 |                          | X       |   X            
//
// if(I++TURE)
// {
//  pixel.Red   =A.Red  *(int)A.Alpha) & 0xff00 ) >>8);  //it should be divied by 255, used 256 as fast algorithem
//  pixel.Green =A.Green*(int)A.Alpha) & 0xff00 ) >>8);
//  pixel.Blue  =A.Blue *(int)A.Alpha) & 0xff00 ) >>8);
// }
//  else
// {
//  pixel.Red   =A.Red  *(0xff-(int)A.Alpha))& 0xff00 ) >>8);
//  pixel.Green =A.Green*(0xff-(int)A.Alpha)) & 0xff00 ) >>8);
//  pixel.Blue  =A.Blue *(oxff-(int)A.Alpha)) & 0xff00 )) >>8);
//  pixel.Alpha =A.Alpha*(0xff-(int)A.Alpha)) & 0xff00 ) >>8);
//  }
// O->OverArrayAndMove( B, pixle, Width );
//            
//---------------|-----------------|--------------|----------------------------------------------------------------------------------------------------------------------
// DXTKEY_ALPHA  | X               | X            |   X          |  X      |X          | X         |TRUE/FALSE |                 |                          | X       |   X            
//DXTKEY_PREMULT_ALPHA,  
//------------------------------------------------------------------------------------------------------------------------------------------------

typedef struct 
{
    int     iKeyType;       //keytype;          for all keys

    int     iHue;             //Hue
    int     iLuminance;          //Lumanice 
    DWORD   dwRGBA;         //RGB color,        only for _RGB, _NONRED

    int     iSimilarity;    //-1: not 

    BOOL  bInvert;        //I, except  Alpha Key
} DXTKEY;

// moved to idl.
#if 0

enum{
DXTKEY_RGB,        
//DXTKEY_RGBDIFF,        //will take out,covered by _RGB
//DXTKEY_BLUE,           //will take out,covered by _RGB
//DXTKEY_GREEN,          //will take out,covered by _RGB          
DXTKEY_NONRED,         
DXTKEY_LUMINANCE,      
//DXTKEY_MULTIPLY,       //TWICE
//DXTKEY_SCREEN,         //TWICE
DXTKEY_ALPHA,          
//DXTKEY_PREMULT_ALPHA,  //included in _ALPHA
//DXTKEY_IMAGE_MAT,      //TWICE
//DXTKEY_DIFF_MAT,       //twicE
//DXTKEY_TRACK_MAT,      //not supported
DXTKEY_HUE};

#endif


/////////////////////////////////////////////////////////////////////////////
// CDxtKey
class ATL_NO_VTABLE CDxtKey : 
        public CDXBaseNTo1,
	public CComCoClass<CDxtKey, &CLSID_DxtKey>,
        public CComPropertySupport<CDxtKey>,
        public IOleObjectDXImpl<CDxtKey>,
        public IPersistStorageImpl<CDxtKey>,
        public ISpecifyPropertyPagesImpl<CDxtKey>,
        public IPersistPropertyBagImpl<CDxtKey>,
#ifdef FILTER_DLL
    public IDispatchImpl<IDxtKey, &IID_IDxtKey, &LIBID_DxtKeyDLLLib>
#else
	public IDispatchImpl<IDxtKey, &IID_IDxtKey, &LIBID_DexterLib>
#endif
{
    bool m_bInputIsClean;
    bool m_bOutputIsClean;
    long m_nInputWidth;
    long m_nInputHeight;
    long m_nOutputWidth;
    long m_nOutputHeight;

    //key
    DXTKEY m_Key;
public:
    DECLARE_POLY_AGGREGATABLE(CDxtKey)
    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
    DECLARE_REGISTER_DX_TRANSFORM(IDR_DXTKEY, CATID_DXImageTransform)
    DECLARE_GET_CONTROLLING_UNKNOWN()
    
    CDxtKey();
    ~CDxtKey();

BEGIN_COM_MAP(CDxtKey)
    // Block CDXBaseNTo1 IObjectSafety implementation because we
    // aren't safe for scripting
    COM_INTERFACE_ENTRY_NOINTERFACE(IObjectSafety) 
    COM_INTERFACE_ENTRY(IDXEffect)
    COM_INTERFACE_ENTRY(IDxtKey)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
    COM_INTERFACE_ENTRY_DXIMPL(IOleObject)
#if(_ATL_VER < 0x0300)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
#else
        COM_INTERFACE_ENTRY(IPersistPropertyBag)
        COM_INTERFACE_ENTRY(IPersistStorage)
        COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
#endif
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CDxtKey)
    PROP_ENTRY("KeyType",         1, CLSID_DxtKeyPP)
    PROP_ENTRY("Hue", 2, CLSID_DxtKeyPP)
    PROP_ENTRY("Luminance", 3, CLSID_DxtKeyPP)
    PROP_ENTRY("RGB",            4, CLSID_DxtKeyPP)
    PROP_ENTRY("Similarity", 5, CLSID_DxtKeyPP)
    PROP_ENTRY("Invert", 6, CLSID_DxtKeyPP)
    PROP_PAGE(CLSID_DxtKeyPP)
END_PROPERTY_MAP()

    STDMETHOD(get_KeyType) ( int *);
    STDMETHOD(put_KeyType) ( int);
    STDMETHOD(get_Hue)(int *);
    STDMETHOD(put_Hue)(int );
    STDMETHOD(get_Luminance)(int *);
    STDMETHOD(put_Luminance)(int );
    STDMETHOD(get_RGB)(DWORD *);
    STDMETHOD(put_RGB)(DWORD );
    STDMETHOD(get_Similarity)(int *);
    STDMETHOD(put_Similarity)(int);
    STDMETHOD(get_Invert)(BOOL *);
    STDMETHOD(put_Invert)(BOOL);

    CComPtr<IUnknown> m_pUnkMarshaler;

    // required for ATL
    BOOL            m_bRequiresSave;

    // CDXBaseNTo1 overrides
    //
    HRESULT WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue );
    HRESULT OnSetup( DWORD dwFlags );
    HRESULT FinalConstruct();

    // our helper function
    //
    void FreeStuff( );
    void DefaultKey(); //init m_Key


// IDxtKey
public:
};

#endif //__DxtKey_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxtkey\dxtkeydll.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// DxtKeyDll.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f DxtKeyDllps.mk in the project directory.

#include <streams.h>

#ifdef FILTER_DLL
#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "DxtKeyDll.h"
#include "DxtKeyDll_i.c"
#include "DxtKey.h"

#if(_ATL_VER < 0x0300)
#include <atlctl.cpp>
#include <atlwin.cpp>
#endif


#include <dxtguid.c>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_DxtKey, CDxtKey)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance/* !!!ATL30 , &LIBID_DXTKEYDLLLib */);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(/* !!! ATL30 TRUE */);
}

CFactoryTemplate g_Templates[1];
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxtjpegdll\stdafx.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_)
#define AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_APARTMENT_THREADED
#ifndef _ATL_STATIC_REGISTRY
#define _ATL_STATIC_REGISTRY
#endif

// get around problem of windowsx.h and atlwin.h not liking each other
#undef SubclassWindow

#include <atlbase.h>
#pragma intrinsic(memset, memcpy)

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>

#include <DXTmpl.h>
#include <dtbase.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxtkey\dxtkey.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// DxtKey.cpp : Implementation of CDxtKey
#include <streams.h>
#include "stdafx.h"
#ifdef FILTER_DLL
#include "DxtKeyDll.h"
#else
#include <qeditint.h>
#include <qedit.h>
#endif
#include "DxtKey.h"
#pragma warning (disable:4244)


void Key_RGB( DXSAMPLE* pSrcBack, DXSAMPLE* pSrcFore, DXTKEY *pKey,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut );
void Key_Black( DXSAMPLE* pSrcBack, DXSAMPLE* pSrcFore,DXTKEY *pKey,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut );
void Key_XRGB( DXSAMPLE* pSrcBack, DXSAMPLE* pSrcFore, DXTKEY *pKey, float Percent,
               ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut );
void Key_Alpha( DXSAMPLE* pSrcBack, DXSAMPLE* pSrcFore,DXPMSAMPLE* pOverlay,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut );
void Key_PMAlpha( DXSAMPLE* pSrcBack,DXPMSAMPLE* pOverlay,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut );
void Key_Luma( DXSAMPLE* pSrcBack, DXSAMPLE* pSrcFore,DXTKEY *pKey, float Percent,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut );
void Key_Hue( DXSAMPLE* pSrcBack, DXSAMPLE* pSrcFore,DXTKEY *pKey, float Percent,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut );

/////////////////////////////////////////////////////////////////////////////
// CDxtKey

CDxtKey::CDxtKey( )
{
    m_ulMaxImageBands = 1;
    m_ulMaxInputs = 2;
    m_ulNumInRequired = 2;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;

    //init m_key
    DefaultKey();


}

CDxtKey::~CDxtKey( )
{
    FreeStuff( );
}

void CDxtKey::DefaultKey()
{
    m_Key.iKeyType =DXTKEY_ALPHA;    //keytype;     for all keys
    m_Key.iHue    =0;               //Hue  , only for _HUE keys
    m_Key.iLuminance    =0;               //Luminance  , only for _LUMINANCE keys
    m_Key.dwRGBA   =0;    //RGB color,  only for _RGB, _NONRED

    m_Key.iSimilarity =0;

    m_Key.bInvert=FALSE;        //I, every key except  Alpha Key
}

void CDxtKey::FreeStuff( )
{
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;
}

HRESULT CDxtKey::OnSetup( DWORD dwFlags )
{
    // delete any stored stuff we have, or memory allocated
    //
    FreeStuff( );

    HRESULT hr;
    CDXDBnds InBounds(InputSurface(0), hr);
    m_nInputWidth = InBounds.Width( );
    m_nInputHeight = InBounds.Height( );

    CDXDBnds OutBounds(OutputSurface(), hr );
    m_nOutputWidth = OutBounds.Width( );
    m_nOutputHeight = OutBounds.Height( );

    if( m_nOutputWidth > m_nInputWidth )
    {
        m_nOutputWidth = m_nInputWidth;
    }
    if( m_nOutputHeight > m_nInputHeight )
    {
        m_nOutputHeight = m_nInputHeight;
    }

    return NOERROR;
}

HRESULT CDxtKey::FinalConstruct( )
{
    HRESULT hr;

    m_ulMaxImageBands = 1;
    m_ulMaxInputs = 2;
    m_ulNumInRequired = 2;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;

    hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(), &m_pUnkMarshaler.p );
    return hr;
}

HRESULT CDxtKey::WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue )
{
    HRESULT hr = S_OK;
    DXSAMPLEFORMATENUM Format;
    DXNATIVETYPEINFO NativeType;

    //--- Get input sample access pointer for the requested region.
    //    Note: Lock may fail due to a lost surface.
    CComPtr<IDXARGBReadPtr> pInA;
    hr = InputSurface( 0 )->LockSurface( &WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                         IID_IDXARGBReadPtr, (void**)&pInA, NULL );
    if( FAILED( hr ) ) return hr;


    CComPtr<IDXARGBReadPtr> pInB;
    hr = InputSurface( 1 )->LockSurface( &WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                         IID_IDXARGBReadPtr, (void**)&pInB, NULL );
    if( FAILED( hr ) ) return hr;


    //--- Put a write lock only on the region we are updating so multiple
    //    threads don't conflict.
    //    Note: Lock may fail due to a lost surface.
    CComPtr<IDXARGBReadWritePtr> pOut;
    hr = OutputSurface()->LockSurface( &WI.OutputBnds, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                       IID_IDXARGBReadWritePtr, (void**)&pOut, NULL );
    if( FAILED( hr ) ) return hr;

//    ASSERT(WI.DoBnds.Width() == WI.OutputBnds.Width());
//    Format = pInA->GetNativeType( &NativeType );
//    ASSERT(Format==DXPF_PMARGB32  || Format==DXPF_ARGB32 );
//    Format = pInB->GetNativeType( &NativeType );
//    ASSERT(Format==DXPF_PMARGB32  || Format==DXPF_ARGB32 );


    //--- Allocate a working buffer
    ULONG Width = WI.DoBnds.Width();
    ULONG Height = WI.DoBnds.Height();

    // allocate a scratch buffer fer us
    //
    DXPMSAMPLE *pOverlayBuffer = DXPMSAMPLE_Alloca( Width );
    DXPMSAMPLE *pScratchBuffer = DXPMSAMPLE_Alloca( Width );
    DXSAMPLE   *pChromaBuffer =  DXSAMPLE_Alloca( Width );

    // no dithering
    //
    if (DoDither())
    {
        return 0;
    }

    ULONG OutY;
    ULONG OutX;

    if( m_Key.iKeyType ==DXTKEY_ALPHA )
    {
        //m_Key.bInvert;       not supported in Alpha Key

        Format = pInB->GetNativeType( &NativeType );
        if( ( Format == DXPF_PMARGB32  ) )
            //alpha premultiplied
            Key_PMAlpha( (DXSAMPLE*)pScratchBuffer,pOverlayBuffer,
                         Width,Height,pInA,pInB,pOut);
        else
            Key_Alpha( (DXSAMPLE*)pScratchBuffer, pChromaBuffer, pOverlayBuffer,
              Width, Height,pInA, pInB,pOut );

    }
    else if(m_Key.iKeyType == DXTKEY_RGB)
    {

        if(m_Key.iSimilarity )
        {
            float Percent = 1.0;
            get_Progress( &Percent );

            Key_XRGB( (DXSAMPLE*)pScratchBuffer,pChromaBuffer, &m_Key, Percent,
                         Width,Height,pInA,pInB,pOut);
        }
        else
        {
            //no blending, no similarity, no threshold, no cutoff
            m_Key.dwRGBA |=0xff000000;  //ignore alpha channel

            if(m_Key.dwRGBA & 0x00FFFFFF)
            {
                Key_RGB( (DXSAMPLE*)pScratchBuffer,pChromaBuffer,&m_Key,
                         Width,Height,pInA,pInB,pOut);
            }
            else
                Key_Black((DXSAMPLE*)pScratchBuffer,pChromaBuffer,&m_Key,
                         Width,Height,pInA,pInB,pOut);
        }
    }
    else if(m_Key.iKeyType==DXTKEY_NONRED)
    {
        for( OutY = 0 ; OutY < Height ; ++OutY )
        {

            // copy background row into dest row
            pOut->MoveToRow( OutY );
            pInA->MoveToRow( OutY );
            pOut->CopyAndMoveBoth( (DXBASESAMPLE*) pScratchBuffer, pInA, Width, FALSE );
            pOut->MoveToRow( OutY );

            //
            // unpack the overlay and what the heck, the original values, too.
            //
            pInB->MoveToXY( 0, OutY );
            pInB->UnpackPremult( pOverlayBuffer, Width, FALSE );
            pInB->Unpack( pChromaBuffer, Width, FALSE );

            float Percent = 1.0;
            get_Progress( &Percent );

            //
            // convert the src's blue bits into an alpha value
            //
            for( OutX = 0; OutX < Width ; ++OutX )
            {
                long rb = pChromaBuffer[OutX].Blue - pChromaBuffer[OutX].Red;
                long gb = pChromaBuffer[OutX].Blue - pChromaBuffer[OutX].Green;

                if( rb > 30 || gb > 30 )
                {
                    if( rb > 70 || gb > 70 )
                    {
                        // very blue!
                        // completely transparent!
                        *( (DWORD *)(&(pOverlayBuffer[OutX])) )= 0;
                    }
                    else
                    {
                        double T = 1.0;

                        // do a quick search left or right to see if we find more blue
                        //
                        bool found = false;
                        if( ( OutX > 11 ) && ( OutX < ( Width - 11 ) ) )
                        {
                            for( ULONG j = OutX - 10 ; j < OutX + 10 ; j++ )
                            {
                                long rb = pChromaBuffer[j].Blue - pChromaBuffer[j].Red;
                                long gb = pChromaBuffer[j].Blue - pChromaBuffer[j].Green;
                                if( rb > 70 && gb > 70 )
                                {
                                    found = true;
                                }
                            }
                        }
                        if( found )
                        {
                            // vary the transparency of the colors based on how
                            // much blue is left

                            // first subtract off the blue itself, it's at least 70 above something
                            //
                            pOverlayBuffer[OutX].Blue -= 70;

                        // the rest of the blue's value determines how transparent everything
                        // else is. Blue is from 0 to 185. The MORE blue we have, the more transparent it should be.

                            T = ( 185.0 - pOverlayBuffer[OutX].Blue ) / 185.0;

                            T /= 3.0;

                        }

                        pOverlayBuffer[OutX].Red   =(DXPMSAMPLE)( (double)(pOverlayBuffer[OutX].Red)  *T* Percent );
                        pOverlayBuffer[OutX].Green =(DXPMSAMPLE)( (double)(pOverlayBuffer[OutX].Green)*T* Percent);
                        pOverlayBuffer[OutX].Blue  =(DXPMSAMPLE)( (double)(pOverlayBuffer[OutX].Blue) *T* Percent);
                        pOverlayBuffer[OutX].Alpha =(DXPMSAMPLE)( (double)(pOverlayBuffer[OutX].Alpha)*T* Percent);
                    }//if(rb>70)

                }// if( rb > 30 || gb > 30 )
            } // for i

            // blend the src (B) back into the destination
            pOut->OverArrayAndMove( pScratchBuffer, pOverlayBuffer, Width );

        } // End for
    }
    else if(m_Key.iKeyType==DXTKEY_LUMINANCE)
    {
        float Percent = 1.0;
        get_Progress( &Percent );

        Key_Luma( (DXSAMPLE*)pScratchBuffer,pChromaBuffer,&m_Key,Percent,
                   Width, Height,
                   pInA, pInB, pOut );
    }
    else if(m_Key.iKeyType==DXTKEY_HUE)
    {
        float Percent = 1.0;
        get_Progress( &Percent );

        Key_Hue( (DXSAMPLE*)pScratchBuffer, pChromaBuffer,&m_Key,Percent,
                 Width, Height, pInA, pInB,pOut);
    }
    else
    {
        //default to alpha blend
        Key_Alpha( (DXSAMPLE*)pScratchBuffer, pChromaBuffer, pOverlayBuffer,
              Width, Height,pInA, pInB,pOut );
    }

    return S_OK;
}

//
// IDXTKey
//
STDMETHODIMP CDxtKey::get_KeyType ( int *piKeyType)
{
    CheckPointer(piKeyType, E_POINTER);
    *piKeyType=m_Key.iKeyType;
    return NOERROR;
}

STDMETHODIMP CDxtKey::put_KeyType ( int iKeyType)
{
    m_Key.iKeyType=iKeyType;
    return NOERROR;
}

STDMETHODIMP CDxtKey::get_Hue(int *pHue)
{
    CheckPointer(pHue, E_POINTER);
    *pHue=m_Key.iHue;
    return NOERROR;
}

STDMETHODIMP CDxtKey::put_Hue(int iHue)
{
    m_Key.iHue=iHue;
    return NOERROR;
}

STDMETHODIMP CDxtKey::get_Luminance(int *pLuminance)
{
    CheckPointer(pLuminance, E_POINTER);
    *pLuminance=m_Key.iLuminance;
    return NOERROR;
}

STDMETHODIMP CDxtKey::put_Luminance(int iLuminance)
{
    m_Key.iLuminance=iLuminance;
    return NOERROR;
}

STDMETHODIMP CDxtKey::get_RGB(DWORD *pdwRGB)
{
    CheckPointer(pdwRGB, E_POINTER);
    *pdwRGB=m_Key.dwRGBA;
    return NOERROR;
}

STDMETHODIMP CDxtKey::put_RGB(DWORD dwRGB)
{
    m_Key.dwRGBA=dwRGB;
    return NOERROR;
}

STDMETHODIMP CDxtKey::get_Similarity(int *piSimilarity)
{
    CheckPointer(piSimilarity, E_POINTER);
    *piSimilarity=m_Key.iSimilarity;
    return NOERROR;
}
STDMETHODIMP CDxtKey::put_Similarity(int iSimilarity)
{
    m_Key.iSimilarity=iSimilarity;
    return NOERROR;
}


STDMETHODIMP CDxtKey::get_Invert(BOOL *pbInvert)
{
    CheckPointer(pbInvert, E_POINTER);
    *pbInvert=m_Key.bInvert;
    return NOERROR;
}
STDMETHODIMP CDxtKey::put_Invert(BOOL bInvert)
{
    m_Key.bInvert=bInvert;
    return NOERROR;
}

//
// put (DWORD *)in front of a DXSAMPLE to speed up the calc
//

//
// this is a RGB color key  which does not key for black color
// no blending, no similarity, no threshold, no cutoff

void Key_RGB( DXSAMPLE* pSrcBack, DXSAMPLE* pSrcFore,DXTKEY *pKey,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut )
{
    ULONG OutY;
    ULONG OutX;

    DWORD dwKey=pKey->dwRGBA &0x00FFFFFF;;

    if(pKey->bInvert==FALSE)
    {
    for( OutY = 0 ; OutY < Height ; ++OutY )
    {
        // unpack background
        pInA->MoveToRow( OutY );
        pInA->Unpack(pSrcBack, Width, FALSE );

        //unpack foreground
        pInB->MoveToRow( OutY );
        pInB->Unpack( pSrcFore, Width, FALSE );


        for( OutX = 0 ; OutX < Width ; ++OutX )
        {
            if( ( *(DWORD *)(&pSrcFore[OutX]) & 0x00FFFFFF ) != dwKey )
                *( (DWORD *)(&pSrcBack[OutX]) )=*(DWORD *)(&pSrcFore[OutX]);
        }

        pOut->MoveToRow( OutY );
        pOut->PackAndMove(pSrcBack,Width);
    }
    }
    else
    {
    for( OutY = 0 ; OutY < Height ; ++OutY )
    {
        // unpack background
        pInA->MoveToRow( OutY );
        pInA->Unpack(pSrcBack, Width, FALSE );

        //unpack foreground
        pInB->MoveToRow( OutY );
        pInB->Unpack( pSrcFore, Width, FALSE );


        for( OutX = 0 ; OutX < Width ; ++OutX )
        {
             if( ( *(DWORD *)(&pSrcFore[OutX]) & 0x00FFFFFF ) == dwKey )
                  *( (DWORD *)(&pSrcBack[OutX]) )=*(DWORD *)(&pSrcFore[OutX]);
        }

        pOut->MoveToRow( OutY );
        pOut->PackAndMove(pSrcBack,Width);
    }
    }

}

void Key_Black( DXSAMPLE* pSrcBack, DXSAMPLE* pSrcFore,DXTKEY *pKey,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut )
{
    ULONG OutY;
    ULONG OutX;

    //black key
    if(pKey->bInvert==FALSE)
    for( OutY = 0 ; OutY < Height ; ++OutY )
    {
        // unpack A
        pInA->MoveToRow( OutY );
        pInA->Unpack(pSrcBack, Width, FALSE );

        // unpack B
        pInB->MoveToRow( OutY );
        pInB->Unpack( pSrcFore, Width, FALSE );

        for( OutX = 0 ; OutX < Width ; ++OutX )
        {
            if( *(DWORD *)(&pSrcFore[OutX]) & 0x00FFFFFF  )
            *( (DWORD *)(&pSrcBack[OutX]) )=*(DWORD *)(&pSrcFore[OutX]);
        }

        // blend the src (B) back into the destination
        pOut->MoveToRow( OutY );
        pOut->PackAndMove(pSrcBack,Width);
    }
    else
    for( OutY = 0 ; OutY < Height ; ++OutY )
    {
        // unpack A
        pInA->MoveToRow( OutY );
        pInA->Unpack(pSrcBack, Width, FALSE );

        // unpack B
        pInB->MoveToRow( OutY );
        pInB->Unpack( pSrcFore, Width, FALSE );

        for( OutX = 0 ; OutX < Width ; ++OutX )
        {
            if( *(DWORD *)(&pSrcFore[OutX]) & 0x00FFFFFF  )
            *( (DWORD *)(&pSrcFore[OutX]) )=*(DWORD *)(&pSrcBack[OutX]);
        }

        // blend the src (B) back into the destination
        pOut->MoveToRow( OutY );
        pOut->PackAndMove(pSrcFore,Width);
    }
}

void Key_XRGB( DXSAMPLE* pSrcBack, DXSAMPLE* pSrcFore, DXTKEY *pKey, float Percent,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut )
{
    ULONG OutY;
    ULONG OutX;

    DWORD dwRedMin = 255;
    DWORD dwGreenMin = 255;
    DWORD dwBlueMin = 255;
    DWORD dwTmp;
    DWORD dwRedMax = 0;
    DWORD dwGreenMax = 0;
    DWORD dwBlueMax = 0;

    BYTE *pB= (BYTE*)&(pKey->dwRGBA);


    if(pKey->iSimilarity)
    {
        dwRedMin   =*(pB+2)*(100-pKey->iSimilarity)/100;
        dwGreenMin =*(pB+1)*(100-pKey->iSimilarity)/100;
        dwBlueMin  = *pB   *(100-pKey->iSimilarity)/100;

        dwTmp=0xFF*pKey->iSimilarity/100;

        dwRedMax    =dwTmp+dwRedMin;
        dwGreenMax  =dwTmp+dwGreenMin;
        dwBlueMax   =dwTmp+dwBlueMin;

    }

 if(pKey->bInvert==FALSE)
 {
    if( pKey->iSimilarity && (Percent==1.0) )
    for( OutY = 0 ; OutY < Height ; ++OutY )
    {

        // unpack background
        pInA->MoveToRow( OutY );
        pInA->Unpack(pSrcBack, Width, FALSE );

        //unpack foreground
        pInB->MoveToRow( OutY );
        pInB->Unpack( pSrcFore, Width, FALSE );

        for( OutX = 0 ; OutX < Width ; ++OutX )
        {

            if( (pSrcFore[OutX].Red   < dwRedMin  ) || (pSrcFore[OutX].Red > dwRedMax ) ||
                (pSrcFore[OutX].Green < dwGreenMin) || (pSrcFore[OutX].Green > dwGreenMax ) ||
                (pSrcFore[OutX].Blue  < dwBlueMin ) || (pSrcFore[OutX].Blue > dwBlueMax)  )
                    *(DWORD *)(&pSrcBack[OutX]) = *(DWORD *)(&pSrcFore[OutX]);
        }

        pOut->MoveToRow( OutY );
        pOut->PackAndMove(pSrcBack,Width);
    }
    else   if(pKey->iSimilarity && (Percent==1.0))
    for( OutY = 0 ; OutY < Height ; ++OutY )
    {

        // unpack background
        pInA->MoveToRow( OutY );
        pInA->Unpack(pSrcBack, Width, FALSE );

        //unpack foreground
        pInB->MoveToRow( OutY );
        pInB->Unpack( pSrcFore, Width, FALSE );

        for( OutX = 0 ; OutX < Width ; ++OutX )
        {
            if( (pSrcFore[OutX].Red   < dwRedMin  ) || (pSrcFore[OutX].Red > dwRedMax ) ||
                (pSrcFore[OutX].Green < dwGreenMin) || (pSrcFore[OutX].Green > dwGreenMax ) ||
                (pSrcFore[OutX].Blue  < dwBlueMin ) || (pSrcFore[OutX].Blue > dwBlueMax)  )
                    *(DWORD *)(&pSrcBack[OutX])=*(DWORD *)(&pSrcBack[OutX])/2 +
                                      *(DWORD *)(&pSrcFore[OutX])/2;
        }

        pOut->MoveToRow( OutY );
        pOut->PackAndMove(pSrcBack,Width);
    }
    else
    for( OutY = 0 ; OutY < Height ; ++OutY )
    {

        // unpack background
        pInA->MoveToRow( OutY );
        pInA->Unpack(pSrcBack, Width, FALSE );

        //unpack foreground
        pInB->MoveToRow( OutY );
        pInB->Unpack( pSrcFore, Width, FALSE );


        for( OutX = 0 ; OutX < Width ; ++OutX )
        {
            if( (pSrcFore[OutX].Red   < dwRedMin  ) || (pSrcFore[OutX].Red > dwRedMax ) ||
                (pSrcFore[OutX].Green < dwGreenMin) || (pSrcFore[OutX].Green > dwGreenMax ) ||
                (pSrcFore[OutX].Blue  < dwBlueMin ) || (pSrcFore[OutX].Blue > dwBlueMax)  )
                    *(DWORD *)(&pSrcBack[OutX])= ( *(DWORD *)(&pSrcBack[OutX])/2 +
                                    *(DWORD *)(&pSrcFore[OutX])/2 )*Percent +
                                    *(DWORD *)(&pSrcFore[OutX])*(1-Percent);
        }

        pOut->MoveToRow( OutY );
        pOut->PackAndMove(pSrcBack,Width);
    }
 }
 else
 {
    if( pKey->iSimilarity && (Percent==1.0) )
    for( OutY = 0 ; OutY < Height ; ++OutY )
    {

        // unpack background
        pInA->MoveToRow( OutY );
        pInA->Unpack(pSrcBack, Width, FALSE );

        //unpack foreground
        pInB->MoveToRow( OutY );
        pInB->Unpack( pSrcFore, Width, FALSE );

        for( OutX = 0 ; OutX < Width ; ++OutX )
        {

            if( (pSrcFore[OutX].Red   < dwRedMin  ) || (pSrcFore[OutX].Red > dwRedMax ) ||
                (pSrcFore[OutX].Green < dwGreenMin) || (pSrcFore[OutX].Green > dwGreenMax ) ||
                (pSrcFore[OutX].Blue  < dwBlueMin ) || (pSrcFore[OutX].Blue > dwBlueMax)  )
                    *(DWORD *)(&pSrcFore [OutX]) = *(DWORD *)(&pSrcBack[OutX]);
        }

        pOut->MoveToRow( OutY );
        pOut->PackAndMove(pSrcFore,Width);
    }
    else   if(pKey->iSimilarity && (Percent==1.0))
    for( OutY = 0 ; OutY < Height ; ++OutY )
    {

        // unpack background
        pInA->MoveToRow( OutY );
        pInA->Unpack(pSrcBack, Width, FALSE );

        //unpack foreground
        pInB->MoveToRow( OutY );
        pInB->Unpack( pSrcFore, Width, FALSE );

        for( OutX = 0 ; OutX < Width ; ++OutX )
        {

            if( (pSrcFore[OutX].Red   < dwRedMin  ) || (pSrcFore[OutX].Red > dwRedMax ) ||
                (pSrcFore[OutX].Green < dwGreenMin) || (pSrcFore[OutX].Green > dwGreenMax ) ||
                (pSrcFore[OutX].Blue  < dwBlueMin ) || (pSrcFore[OutX].Blue > dwBlueMax)  )
                   *(DWORD *)(&pSrcFore[OutX])=*(DWORD *)(&pSrcFore[OutX])/2 +
                                     *(DWORD *)(&pSrcBack[OutX])/2;
        }

        pOut->MoveToRow( OutY );
        pOut->PackAndMove(pSrcFore,Width);
    }
    else
    for( OutY = 0 ; OutY < Height ; ++OutY )
    {

        // unpack background
        pInA->MoveToRow( OutY );
        pInA->Unpack(pSrcBack, Width, FALSE );

        //unpack foreground
        pInB->MoveToRow( OutY );
        pInB->Unpack( pSrcFore, Width, FALSE );

        for( OutX = 0 ; OutX < Width ; ++OutX )
        {
            if( (pSrcFore[OutX].Red   >=dwRedMin  ) && (pSrcFore[OutX].Red <= dwRedMax ) &&
                (pSrcFore[OutX].Green >=dwGreenMin) && (pSrcFore[OutX].Green <= dwGreenMax ) &&
                (pSrcFore[OutX].Blue  >=dwBlueMin ) && (pSrcFore[OutX].Blue <= dwBlueMax)   )
                    *(DWORD *)(&pSrcFore[OutX])= ( *(DWORD *)(&pSrcFore[OutX])/2 +
                                    *(DWORD *)(&pSrcBack[OutX])/2)*Percent +
                                    *(DWORD *)(&pSrcBack[OutX])*(1-Percent);
        }

        pOut->MoveToRow( OutY );
        pOut->PackAndMove(pSrcFore,Width);
    }
 }
}

void Key_PMAlpha( DXSAMPLE* pSrcBack, DXPMSAMPLE* pSrcFore,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB,IDXARGBReadWritePtr *pOut )
{
    ULONG OutY;
    ULONG OutX;

    for( OutY = 0 ; OutY < Height ; ++OutY )
    {
        // copy background row into dest row
        pOut->MoveToRow( OutY );
        pInA->MoveToRow( OutY );
        pOut->CopyAndMoveBoth( (DXBASESAMPLE*) pSrcBack, pInA, Width, FALSE );

        // unpack the overlay and what the heck, the original values, too.
        //
        pInB->MoveToRow( OutY );
        pInB->UnpackPremult( pSrcFore, Width, FALSE );

        // blend the src (B) back into the destination
        pOut->MoveToRow( OutY );
        pOut->OverArrayAndMove( pSrcBack, pSrcFore, Width );
    }
}

void Key_Alpha( DXSAMPLE* pSrcBack, DXSAMPLE* pSrcFore,DXPMSAMPLE* pOverlay,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut )
{
    ULONG OutY;
    ULONG OutX;

    // foreground image has to have alpha value in every pixel
    for( OutY = 0 ; OutY < Height ; ++OutY )
    {
        // copy background row into dest row
        pOut->MoveToRow( OutY );
        pInA->MoveToRow( OutY );
        pOut->CopyAndMoveBoth( (DXBASESAMPLE*) pSrcBack, pInA, Width, FALSE );

        // unpack original value
        //
        pInB->MoveToRow( OutY );
        pInB->UnpackPremult( (DXPMSAMPLE*) pSrcFore, Width, FALSE );

        // blend the src (B) back into the destination
        pOut->MoveToRow( OutY );
        pOut->OverArrayAndMove( pSrcBack, (DXPMSAMPLE*) pSrcFore, Width );
    }
}

#define HMAX  360
#define LMAX  100
#define SMAX  100
#define RGBMAX  255
#define UNDEFINED 0 /* Hue is undefined if Saturation is 0 (grey-scale) */



void Key_Luma( DXSAMPLE* pSrcBack, DXSAMPLE* pSrcFore,DXTKEY *pKey,float Percent,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut )
{
    ULONG OutY;
    ULONG OutX;


    for( OutY = 0 ; OutY < Height ; ++OutY )
    {
        // unpack original value
        pInA->MoveToRow( OutY );
        pInA->Unpack( pSrcBack, Width, FALSE );

        // unpack original value
        pInB->MoveToRow( OutY );
        pInB->Unpack( pSrcFore, Width, FALSE );


        for( OutX = 0 ; OutX < Width ; ++OutX )
        {

            SHORT R, G, B;                 // input RGB values
            SHORT cMax,cMin;               // max and min RGB values
            SHORT cDif;
            SHORT iHue; //, iSaturation, iLuminance;

            //
            //  get R, G, and B out of DWORD.
            //
            R = pSrcFore[OutX].Red;
            G = pSrcFore[OutX].Green;
            B = pSrcFore[OutX].Blue;

            //
            //  Calculate lightness.
            //
            cMax = max(max(R, G), B);
            cMin = min(min(R, G), B);
            long iLuminance = (cMax + cMin)/2;  //fLuminance is now 0-255
            iLuminance = iLuminance * LMAX / RGBMAX; //fLuminance is now 0-100

            if( !pKey->bInvert && iLuminance != pKey->iLuminance ||
                pKey->bInvert && iLuminance ==  pKey->iLuminance )
            {
                *( (DWORD*)(&pSrcBack[OutX]) )=*(&pSrcFore[OutX]);
            }
            else if(Percent != -1)
            {
                pSrcBack[OutX].Red= pSrcFore[OutX].Red +
                    ((LONG)pSrcBack[OutX].Red - (LONG)pSrcFore[OutX].Red) * Percent ;

                pSrcBack[OutX].Green= pSrcFore[OutX].Green +
                    ((LONG)pSrcBack[OutX].Green - (LONG)pSrcFore[OutX].Green) * Percent ;

                pSrcBack[OutX].Blue= pSrcFore[OutX].Blue +
                    ((LONG)pSrcBack[OutX].Blue - (LONG)pSrcFore[OutX].Blue) * Percent ;
            }
        }

        pOut->MoveToRow( OutY );
        pOut->PackAndMove(pSrcBack,Width);
    }
}


void Key_Hue( DXSAMPLE* pSrcBack, DXSAMPLE* pSrcFore,DXTKEY *pKey, float Percent,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut)
{

    ULONG OutY;
    ULONG OutX;

    BYTE M,m,r,g,b;
    int iHue;

    for( OutY = 0 ; OutY < Height ; ++OutY )
    {
        // unpack original value
        pInA->MoveToRow( OutY );
        pInA->Unpack( pSrcBack, Width, FALSE );

        // unpack original value
        pInB->MoveToRow( OutY );
        pInB->Unpack( pSrcFore, Width, FALSE );

        //calc hue
        for( OutX = 0 ; OutX < Width ; ++OutX )
        {

            SHORT R, G, B;                 // input RGB values
            SHORT cMax,cMin;               // max and min RGB values
            SHORT cDif;
            SHORT iHue; //, iSaturation, iLuminance;

            //
            //  get R, G, and B out of DWORD.
            //
            R = pSrcFore[OutX].Red;
            G = pSrcFore[OutX].Green;
            B = pSrcFore[OutX].Blue;

            //
            //  Calculate lightness.
            //
            cMax = max(max(R, G), B);
            cMin = min(min(R, G), B);
//                 iLuminance = (cMax + cMin)/2;  //fLuminance is now 0-127
//  		   iLuminance /= ((RGBMAX / 2) / LMAX); //fLuminance is now 0-100

            cDif = cMax - cMin;
            if (!cDif)
            {
                //
                //  r = g = b --> Achromatic case.
                //
                iHue = UNDEFINED;                 // hue
//                  iSaturation = 0;
            }
            else
            {
                //
                //  Chromatic case.
                //

                //
                //  Luminance.
                //

                //
                //  Saturation.
                //

//                  if (iLuminance < 50)
//                  {
//                      //(0-1)     = (0-1  - 0- 1) / (0-1  + 0-1 );
//                      //          = (1    -  0  ) / ( 1 +  0 ); 1 max
//                      //			= (1 - 1)       / ( 1 + 1 ); 0 min
//                      //			=
//                      iSaturation = ((cMax - cMin) / (cMax + cMin)) / (RGBMAX / SMAX);
//                  }
//                  else
//                  {
//                      iSaturation = ((cMax - cMin) / (2.0 - cMax - cMin)) / (RGBMAX / SMAX);
//                  }

                //
                //  Hue.
                //

                if (R == cMax)
                {
                    //(0-60(?)) = (0-255 - 0-255) / (0-255 - 0-255)
                    //        =
                    iHue = ((double)(G - B) / (double)(cMax - cMin)) * 60.0;
                }
                else if (G == cMax) // pure green is 120
                {
                    iHue = 120 + ((double)(B - R) / (double)(cMax - cMin) * 60.0);
                }
                else  // (B == cMax)  pure blue is 240
                {
                    iHue = 240 + ((double)(R - G) / (double)(cMax - cMin)) * 60.0;
                }

                // bHue contained 0-6, where each was a vertices of HSL hexagon
                //  multiply by 60 degrees to find where bHue was in complete 360

                if (iHue < 0)
                {
                    //
                    //  This can occur when R == cMax and G is > B.
                    //
                    iHue += HMAX;
                }
                if (iHue >= HMAX)
                {
                    iHue -= HMAX;
                }
            }

            if( !pKey->bInvert && iHue != pKey->iHue ||
                pKey->bInvert && iHue ==  pKey->iHue )
            {
                *( (DWORD*)(&pSrcBack[OutX]) )=*(&pSrcFore[OutX]);
            }
            else if(Percent != -1)
            {
                pSrcBack[OutX].Red= pSrcFore[OutX].Red +
                    ((LONG)pSrcBack[OutX].Red - (LONG)pSrcFore[OutX].Red) * Percent ;

                pSrcBack[OutX].Green= pSrcFore[OutX].Green +
                    ((LONG)pSrcBack[OutX].Green - (LONG)pSrcFore[OutX].Green) * Percent ;

                pSrcBack[OutX].Blue= pSrcFore[OutX].Blue +
                    ((LONG)pSrcBack[OutX].Blue - (LONG)pSrcFore[OutX].Blue) * Percent ;
            }
        }

        pOut->MoveToRow( OutY );
        pOut->PackAndMove(pSrcBack,Width);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxtkey\dxtkeypp.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// DxtKeyPP.cpp : Implementation of CDxtKeyPP
#include <streams.h>
#include "stdafx.h"
#ifdef FILTER_DLL
#include "DxtKeyDll.h"
#else
#include <qeditint.h>
#include <qedit.h>
#endif
#include "DxtKeyPP.h"
#pragma warning (disable:4244 4800)

/////////////////////////////////////////////////////////////////////////////
// CDxtKeyPP

LRESULT CDxtKeyPP::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    USES_CONVERSION;
    CComQIPtr<IDxtKey, &IID_IDxtKey> pOwner( m_ppUnk[0] );


    // keytype
//    SetKeyTypeProperty(pOwner);

    DWORD dw;
    pOwner->get_Hue((int *)&dw);
    SetDlgItemText(IDC_DXTKEYEDITRED, TEXT("0"));
    SetDlgItemText(IDC_DXTKEYEDITGREEN, TEXT("0"));
    SetDlgItemText(IDC_DXTKEYEDITBLUE, TEXT("0"));
    SetDlgItemText(IDC_DXTKEYEDITALPHA, TEXT("0"));

    //set all slider at start point

    return TRUE;
}

STDMETHODIMP CDxtKeyPP::Apply(void)
{
    ATLTRACE(_T("CDxtKeyPP::Apply\n"));
    for (UINT i = 0; i < m_nObjects; i++)
    {
      CComQIPtr<IDxtKey, &IID_IDxtKey> pOwner( m_ppUnk[0] );
    }

    m_bDirty = FALSE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxtkey\resource.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dxtkeydll.rc
//
#define IDS_DXTKEY                      1300
#define IDC_DXTKEY_RGB                  1301
#define IDC_DXTKEY_NONRED               1305
#define IDC_DXTKEY_LUMINANCE            1306
#define IDC_DXTKEY_ALPHA                1309
#define IDC_DXTKEY_PREMULT_ALPHA        1310
#define IDR_DXTKEY                      1320
#define IDR_DXTKEYPP                    1321
#define IDS_TITLEDxtKEYPP               1322
#define IDS_HELPFILEDxtKEYPP            1323
#define IDS_DOCSTRINGDxtKEYPP           1324
#define IDD_DXTKEYDLG                   1325
#define IDC_DXTKEYCOMBO                 1326
#define IDC_DXTKEYSLIDERSIMILAR         1327
#define IDC_DXTKEYSLIDERBLIND           1328
#define IDC_DXTKEYSLIDERTHRESHOLD       1329
#define IDC_DXTKEYSLIDERCUTOFF          1330
#define IDC_DXTKEYEDITRED               1331
#define IDC_DXTKEYEDITGREEN             1332
#define IDC_DXTKEYEDITBLUE              1333
#define IDC_DXTKEYEDITALPHA             1334

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         235
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxtkey\dxtkeypp.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// DxtKeyPP.h : Declaration of the CDxtKeyPP

#ifndef __DXTKEYPP_H_
#define __DXTKEYPP_H_

#include "resource.h"       // main symbols

EXTERN_C const CLSID CLSID_DxtKeyPP;

/////////////////////////////////////////////////////////////////////////////
// CDxtKeyPP
class ATL_NO_VTABLE CDxtKeyPP :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDxtKeyPP, &CLSID_DxtKeyPP>,
	public IPropertyPageImpl<CDxtKeyPP>,
	public CDialogImpl<CDxtKeyPP>
{
public:
    CDxtKeyPP() 
    {
    	m_dwTitleID = IDS_TITLEDxtKEYPP;
	m_dwHelpFileID = IDS_HELPFILEDxtKEYPP;
	m_dwDocStringID = IDS_DOCSTRINGDxtKEYPP;
    }

    enum {IDD = IDD_DXTKEYDLG};
	
DECLARE_REGISTRY_RESOURCEID(IDR_DXTKEYPP)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDxtKeyPP) 
#if(_ATL_VER < 0x0300)
	COM_INTERFACE_ENTRY_IMPL(IPropertyPage)
#else
	COM_INTERFACE_ENTRY(IPropertyPage)
#endif
END_COM_MAP()

BEGIN_MSG_MAP(CDxtKeyPP)
        //init
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	CHAIN_MSG_MAP(IPropertyPageImpl<CDxtKeyPP>)
END_MSG_MAP()

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled); 
    //IPropertyPage
    STDMETHOD(Apply)(void);

private:
    // Helper methods

};


#endif //__DXTKEYPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxtkey\stdafx.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information
#include <streams.h>
#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <dtbase.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\dxtkey\stdafx.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_)
#define AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_APARTMENT_THREADED
#ifndef _ATL_STATIC_REGISTRY
#define _ATL_STATIC_REGISTRY
#endif

// get around problem of windowsx.h and atlwin.h not liking each other
#undef SubclassWindow

#include <atlbase.h>
#pragma intrinsic(memset, memcpy)

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <DXTmpl.h>
#include <dtbase.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\frc\frc.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

class CSkewPassThru;     // IMediaSeeking support
class CFRCWorker;
class CFrmRateConverter;

extern const AMOVIESETUP_FILTER sudFrmRateConv;

class CFRCWorker : public CAMThread
{

    CFrmRateConverter * m_pFRC;

public:
    enum Command { CMD_RUN, CMD_STOP, CMD_EXIT };

private:
    // type-corrected overrides of communication funcs
    Command GetRequest() {
	return (Command) CAMThread::GetRequest();
    };

    BOOL CheckRequest(Command * pCom) {
	return CAMThread::CheckRequest( (DWORD *) pCom);
    };

    HRESULT DoRunLoop(void);

public:
    CFRCWorker();

    HRESULT Create(CFrmRateConverter * pFRC);

    DWORD ThreadProc();

    // commands we can give the thread
    HRESULT Run();
    HRESULT Stop();

    HRESULT Exit();
};


class CFrmRateConverter : public CTransInPlaceFilter,
		public IDexterSequencer ,public ISpecifyPropertyPages,
		public CPersistStream
{
    friend class CFrmRateConverterOutputPin;
    friend class CFrmRateConverterInputPin;
    //friend class CFrmRateInputAllocator;
    friend class CSkewPassThru;
    friend class CFRCWorker;

public:
    CFrmRateConverter(TCHAR *, LPUNKNOWN, REFCLSID clsid, HRESULT *);
    ~CFrmRateConverter();

    DECLARE_IUNKNOWN;

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN punk, HRESULT *phr);
    
    // Reveals IDexterSequencer
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    CBasePin *GetPin(int n);

    // Overrriden from CTransformFilter base class
    
    // override this to customize the transform process
    
    HRESULT Transform(IMediaSample *pSample) { return NOERROR ;};
    HRESULT Receive(IMediaSample *pSample);
    HRESULT CheckInputType(const CMediaType *mtIn);
    // not allowed HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);
    HRESULT EndOfStream();
    HRESULT NewSegment(
                        REFERENCE_TIME tStart,
                        REFERENCE_TIME tStop,
                        double dRate);

    HRESULT StartStreaming();
    HRESULT StopStreaming();
    STDMETHODIMP Stop();
    HRESULT BeginFlush();
    HRESULT EndFlush();

    HRESULT NextSegment(BOOL);
    HRESULT SeekNextSegment();

    // These implement the custom IDexterSequencer interface
    // FrmRate == FrmPerSecond
    STDMETHODIMP get_OutputFrmRate(double *dpFrmRate);
    STDMETHODIMP put_OutputFrmRate(double dFrmRate);
    STDMETHODIMP ClearStartStopSkew();
    STDMETHODIMP AddStartStopSkew(REFERENCE_TIME Start, REFERENCE_TIME Stop,
				  REFERENCE_TIME Skew, double dRate);
    STDMETHODIMP GetStartStopSkewCount(int *pCount);
    STDMETHODIMP GetStartStopSkew(REFERENCE_TIME *pStart, REFERENCE_TIME *pStop,
				  REFERENCE_TIME *pSkew, double *pdRate);
    STDMETHODIMP get_MediaType( AM_MEDIA_TYPE * pMediaType );
    STDMETHODIMP put_MediaType( const AM_MEDIA_TYPE * pMediaType );

    // ISpecifyPropertyPages
    STDMETHODIMP GetPages (CAUUID *);

    // Constructor
    CFrmRateConverter(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr);

    // CPersistStream
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    STDMETHODIMP GetClassID(CLSID *pClsid);
    int SizeMax();

protected:

    CFrmRateConverterOutputPin *OutputPin()
    {
        return (CFrmRateConverterOutputPin *)m_pOutput;
    };
   
    double	m_dOutputFrmRate;	    // Output frm rate

    // StartStopSkew stuff

    typedef struct {
        REFERENCE_TIME rtMStart;
        REFERENCE_TIME rtMStop;
        REFERENCE_TIME rtSkew;
        REFERENCE_TIME rtTLStart;
        REFERENCE_TIME rtTLStop;
        double dRate;
    } FRCSKEW;

    FRCSKEW *m_pSkew;
    int m_cTimes;	// valid # of items in array
    int m_cMaxTimes;	// space allocated for this many

    int m_nCurSeg;	// current index of array being played
    int m_nSeekCurSeg;	// new value being set by the seek

    CMemAllocator *m_pUpAllocator;  // to get buffers to upsample into

    LONGLONG m_llOutputSampleCnt;

    REFERENCE_TIME m_rtLastSeek;	// last timeline time seek command
    REFERENCE_TIME m_rtNewLastSeek;	// what m_rtLastSeek is going to be

    LONGLONG m_llStartFrameOffset;	// after a seek, the first frame sent
					// (in timeline time)

    BOOL m_fSeeking;		// in the middle of seeking?
    HANDLE m_hEventSeek;	// wait before accepting data

    CMediaType m_mtAccept;	// accept only this type
    bool m_bMediaTypeSetByUser; // is m_mtAccept valid?

    CFRCWorker m_worker;	// worker thread for re-using sources
    HANDLE m_hEventThread;	// OK, time to wake up
    BOOL m_fThreadMustDie;
    BOOL m_fThreadCanSeek;
    BOOL m_fSpecialSeek;
    CCritSec m_csThread;

    BOOL m_fJustLate;	// we just got a late notification
    Quality m_qJustLate;// (and it was this one)

    BOOL m_fStopPushing;
    BOOL m_fFlushWithoutSeek;

    // hack to correct for broken parsers that don't send end time right
    BOOL m_fParserHack;	// do we do this hack at all?
    IMediaSample *m_pHackSample[2];	// we keep 2 samples around
    int m_nHackCur;			// which sample we use right now

    REFERENCE_TIME m_rtNewSeg;

#if 0	// my attempt to make sources not have to be seekable
    BOOL m_fCantSeek;	// the source upstream can't be seeked
    HRESULT FakeSeek(REFERENCE_TIME);	// deal with that
    REFERENCE_TIME m_rtFakeSeekOffset;
#endif

#ifdef NOFLUSH
    BOOL m_fExpectNewSeg;
    BOOL m_fSurpriseNewSeg;
    REFERENCE_TIME m_rtSurpriseStart;
    REFERENCE_TIME m_rtSurpriseStop;
#endif

}; // FrmRateConverter


//
// CFrmRateConverterOutputPin class
//
class CFrmRateConverterOutputPin : public CTransInPlaceOutputPin
{
    friend class CFrmRateConverter;
    friend class CFrmRateConverterInputPin;
    //friend class CFrmRateInputAllocator;

public:
    CFrmRateConverterOutputPin( TCHAR *pObjectName
                             , CFrmRateConverter *pFrmRateConverter
                             , HRESULT * phr
                             , LPCWSTR pName
                             );

    ~CFrmRateConverterOutputPin();

    STDMETHODIMP ReceiveAllocator(IMemAllocator * pAllocator, BOOL bReadOnly);
    HRESULT DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc);

    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **); //for IMediaSeeking
    // Overriden to handle quality messages
    STDMETHODIMP Notify(IBaseFilter *pSender, Quality q);

   
private:
    CFrmRateConverter     *m_pFrmRateConverter;
    CSkewPassThru	  *m_pSkewPassThru;

    
};

class CFrcPropertyPage : public CBasePropertyPage
{
    public:

      static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    private:

      INT_PTR OnReceiveMessage (HWND, UINT ,WPARAM ,LPARAM);

      HRESULT OnConnect (IUnknown *);
      HRESULT OnDisconnect (void);
      HRESULT OnActivate (void);
      HRESULT OnDeactivate (void);
      HRESULT OnApplyChanges (void);

      void SetDirty (void);

      CFrcPropertyPage (LPUNKNOWN, HRESULT *);

      void GetControlValues (void);

      IDexterSequencer *m_pifrc;

      // Temporary variables (until OK/Apply)

      double          m_dFrameRate;
      double          m_dRate;
      REFERENCE_TIME  m_rtSkew;
      REFERENCE_TIME  m_rtMediaStart;
      REFERENCE_TIME  m_rtMediaStop;
      BOOL            m_bInitialized;

};



//
// CFrmRateConverterInputPin class - override GetAllocator
//
class CFrmRateConverterInputPin : public CTransInPlaceInputPin 
{
    friend class CFrmRateConverter;
    friend class CFrmRateConverterOutputPin;
    //friend class CFrmRateInputAllocator;

public:
    CFrmRateConverterInputPin( TCHAR *pObjectName
                             , CFrmRateConverter *pFrmRateConverter
                             , HRESULT * phr
                             , LPCWSTR pName
                             );

    ~CFrmRateConverterInputPin();

    // we still need this class to peek at m_pAllocator
    //CFrmRateInputAllocator *m_pFakeAllocator;
    //STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator);
    STDMETHODIMP NotifyAllocator(IMemAllocator * pAllocator, BOOL bReadOnly);

};


// we only need this if the switch isn't the allocator for its downstream
// connections
#if 0

class CFrmRateInputAllocator : public CMemAllocator
{
    friend class CFrmRateConverter;
    friend class CFrmRateConverterOutputPin;
    friend class CFrmRateConverterInputPin;

public:

    CFrmRateInputAllocator(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr);
    ~CFrmRateInputAllocator();

    STDMETHODIMP GetBuffer(IMediaSample **ppBuffer, REFERENCE_TIME *pStartTime,
                                  REFERENCE_TIME *pEndTime, DWORD dwFlags);
    STDMETHODIMP SetProperties(ALLOCATOR_PROPERTIES *, ALLOCATOR_PROPERTIES *);
    STDMETHODIMP Commit();
    STDMETHODIMP Decommit();

protected:
    IMemAllocator *m_pRealAllocator;
    IMemAllocator *m_pBonusAllocator;
    CFrmRateConverterInputPin *m_pPin;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\errlog\cerrlog.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef __CERRLOG_H__
#define __CERRLOG_H__

// for those projects who have not yet included this
//
#include <atlbase.h>

class CAMSetErrorLog : public IAMSetErrorLog
{
public:

    CComPtr< IAMErrorLog > m_pErrorLog;

public:

    CAMSetErrorLog( )
    {
    }

    // IAMSetErrorLog
    //
    STDMETHODIMP put_ErrorLog( IAMErrorLog * pLog )
    {
        m_pErrorLog = pLog;
        return 0;
    }

    STDMETHODIMP get_ErrorLog( IAMErrorLog ** ppLog )
    {
        CheckPointer( ppLog, E_POINTER );
        *ppLog = m_pErrorLog;
        if( *ppLog )
        {
            (*ppLog)->AddRef( );
        }
        return 0;
    }

    // public helper functions
    //
    STDMETHODIMP _GenerateError( long Priority, long ErrorStringId, HRESULT ErrorCode, VARIANT * pExtraInfo = NULL )
    {
        if( !m_pErrorLog )
        {
            return ErrorCode;
        }

    /*
        if( Priority > 1 )
        {
            return ErrorCode;
        }
    */

	// many errors are really just out of memory errors
	if (ErrorCode == E_OUTOFMEMORY)
	    ErrorStringId = DEX_IDS_OUTOFMEMORY;

        TCHAR tBuffer[256];
        tBuffer[0] = 0;
        LoadString( g_hInst, ErrorStringId, tBuffer, 256 );
        USES_CONVERSION;
        WCHAR * w = T2W( tBuffer );
        HRESULT hr = 0;

        CComBSTR bbb( w );
        hr = m_pErrorLog->LogError( Priority, bbb, ErrorStringId, ErrorCode, pExtraInfo );

        return hr;
    }

    STDMETHODIMP _GenerateError( long Priority, WCHAR * pErrorString, long ErrorStringId, HRESULT ErrorCode, VARIANT * pExtraInfo = NULL )
    {
        if( !m_pErrorLog )
        {
            return ErrorCode;
        }

    /*
        if( Priority > 1 )
        {
            return ErrorCode;
        }
    */

	HRESULT hr;

	// many errors are really just out of memory errors
	if (ErrorCode == E_OUTOFMEMORY) 
        {
            CComBSTR bbb( L"Out of memory" );
            hr = m_pErrorLog->LogError(Priority, bbb, DEX_IDS_OUTOFMEMORY, ErrorCode, pExtraInfo);
	} else 
        {
            CComBSTR bbb( pErrorString );
            hr = m_pErrorLog->LogError( Priority, bbb, ErrorStringId, ErrorCode, pExtraInfo );
	}
        return hr;
    }
};

#endif //__CERRLOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\frc\pthru.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "FRC.h"
#include "PThru.h"
#include "..\util\conv.cxx"

const int TRACE_HIGHEST = 2;
const int TRACE_MEDIUM = 3;
const int TRACE_LOW = 4;
const int TRACE_LOWEST = 5;

BOOL SafeSetEvent(HANDLE h);

CSkewPassThru::CSkewPassThru(const TCHAR *pName,
			   LPUNKNOWN pUnk,
			   HRESULT *phr,
			   IPin *pPin,
			   CFrmRateConverter *pFrm) :
    CPosPassThru(pName,pUnk, phr, pPin),
    m_pFrm( pFrm )
{
}

// Expose our IMediaSeeking interfaces
STDMETHODIMP
CSkewPassThru::NonDelegatingQueryInterface(REFIID riid,void **ppv)
{
    CheckPointer(ppv,E_POINTER);
    *ppv = NULL;

    if (riid == IID_IMediaSeeking)
    {
	return GetInterface( static_cast<IMediaSeeking *>(this), ppv);
    }
    else {
	//we only support the IID_DIMediaSeeking
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


// fix a clip time into timeline time, bounding it by the legal area
// Only works for the current segment
//
HRESULT CSkewPassThru::FixTime(REFERENCE_TIME *prt,  int nCurSeg)
{
    CheckPointer(prt, E_POINTER);

    REFERENCE_TIME rtStart, rtStop, rtSkew;
    rtSkew = m_pFrm->m_pSkew[nCurSeg].rtSkew;
    rtStart = m_pFrm->m_pSkew[nCurSeg].rtMStart;
    rtStop = m_pFrm->m_pSkew[nCurSeg].rtMStop;
    if (*prt < rtStart)
	*prt = rtStart;
    if (*prt > rtStop)
	*prt = rtStop;
    *prt = (REFERENCE_TIME)(rtStart + rtSkew + (*prt - rtStart) /
				 	m_pFrm->m_pSkew[nCurSeg].dRate);
    return S_OK;
}


// fix a timeline time back into clip time, bounding it by the legal area
// of a segment.
// If it's in between segments, use the beginning of the next segment
// Returns the segment it's in
// Optionally, round the time DOWN to a frame boundary before skewing. This
// makes sure seeking to a spot gives the same frame as playing up to that
// spot does (for the down sampling case)
//
int CSkewPassThru::FixTimeBack(REFERENCE_TIME *prt, BOOL fRound)
{
    CheckPointer(prt, E_POINTER);
    REFERENCE_TIME rtStart, rtStop, rtSkew;
    REFERENCE_TIME rtTLStart, rtTLStop;
    double dRate;

    if (m_pFrm->m_cTimes == 0) {
	ASSERT(FALSE);
	return 0;
    }

    if (fRound)
    {
        LONGLONG llOffset = Time2Frame( *prt, m_pFrm->m_dOutputFrmRate );
    	*prt = Frame2Time( llOffset, m_pFrm->m_dOutputFrmRate );
    }

    REFERENCE_TIME rtSave;
    for (int z = 0; z < m_pFrm->m_cTimes; z++) {
        rtSkew = m_pFrm->m_pSkew[z].rtSkew;
        rtStart = m_pFrm->m_pSkew[z].rtMStart;
        rtStop = m_pFrm->m_pSkew[z].rtMStop;
        dRate = m_pFrm->m_pSkew[z].dRate;
	rtTLStart = rtStart + rtSkew;
	rtTLStop = rtStart + rtSkew +
			(REFERENCE_TIME) ((rtStop - rtStart) / dRate);
	if (*prt < rtTLStart) {
	    *prt = rtStart;
	    break;
	} else if (*prt >= rtTLStop) {
	    // just in case there is no next segment, this is the final value
	    rtSave = rtStop;
	} else {
    	    *prt = (REFERENCE_TIME)(rtStart + (*prt - (rtStart + rtSkew)) *
								dRate);
	    break;
	}
    }
    if (z == m_pFrm->m_cTimes) {
	z--;
	*prt = rtSave;
    }
    return z;
}


// --- IMediaSeeking methods ----------

STDMETHODIMP
CSkewPassThru::GetCapabilities(DWORD * pCaps)
{
    return CPosPassThru::GetCapabilities(pCaps);

#if 0
    CheckPointer(pCaps,E_POINTER);
    // we always know the current position
    *pCaps =     AM_SEEKING_CanSeekAbsolute
		   | AM_SEEKING_CanSeekForwards
		   | AM_SEEKING_CanSeekBackwards
		   | AM_SEEKING_CanGetCurrentPos
		   | AM_SEEKING_CanGetStopPos
		   | AM_SEEKING_CanGetDuration
		   | AM_SEEKING_CanDoSegments
		   | AM_SEEKING_Source;
    return S_OK;
#endif
}


STDMETHODIMP
CSkewPassThru::CheckCapabilities(DWORD * pCaps)
{
    return CPosPassThru::CheckCapabilities(pCaps);
#if 0
    CheckPointer(pCaps,E_POINTER);

    DWORD dwMask = 0;
    GetCapabilities(&dwMask);
    *pCaps &= dwMask;

    return S_OK;
#endif
}


STDMETHODIMP
CSkewPassThru::IsFormatSupported(const GUID * pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    return (*pFormat == TIME_FORMAT_MEDIA_TIME) ? S_OK : S_FALSE;
}

STDMETHODIMP
CSkewPassThru::QueryPreferredFormat(GUID *pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    *pFormat = TIME_FORMAT_MEDIA_TIME;
    return S_OK;
}

STDMETHODIMP
CSkewPassThru::SetTimeFormat(const GUID * pFormat)
{
    CheckPointer(pFormat,E_POINTER);

    if(*pFormat == TIME_FORMAT_MEDIA_TIME)
	return S_OK;
    else
	return E_FAIL;
}

STDMETHODIMP
CSkewPassThru::GetTimeFormat(GUID *pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    *pFormat = TIME_FORMAT_MEDIA_TIME ;
    return S_OK;
}

STDMETHODIMP
CSkewPassThru::IsUsingTimeFormat(const GUID * pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    if (*pFormat == TIME_FORMAT_MEDIA_TIME)
	return S_OK;
    else
	return S_FALSE;
}

// The biggie!
//
STDMETHODIMP
CSkewPassThru::SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
			  , LONGLONG * pStop, DWORD StopFlags )
{
    // make sure our re-using sources thread isn't seeking at the moment.
    // Wait till it's done, so the app seek happens last, and that the thread
    // won't seek anymore from now on

    CAutoLock cAutolock(&m_pFrm->m_csThread);

    // make sure the state doesn't change while doing this
    CAutoLock c(&m_pFrm->m_csFilter);

    m_pFrm->m_fThreadCanSeek = FALSE;

    HRESULT hr;
    REFERENCE_TIME rtStart, rtStop = MAX_TIME;
    int nCurSeg = m_pFrm->m_nCurSeg;

    // we don't do segments
    if ((CurrentFlags & AM_SEEKING_Segment) ||
				(StopFlags & AM_SEEKING_Segment)) {
    	DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("FRC: ERROR-Seek used EC_ENDOFSEGMENT!")));
	return E_INVALIDARG;
    }

    // figure out where we're seeking to, and add skew to make it in timeline
    // time

    // !!! We ignore stop times, because of the way we re-use sources and play
    // things in segments.  We will always send a stop time upstream equal to
    // the end of the current segment, and only pay attention to changes in the
    // start time.  This will work only because the switch will ignore things
    // we send after we were supposed to stop and stop us.

    DWORD dwFlags = (CurrentFlags & AM_SEEKING_PositioningBitsMask);
    if (dwFlags == AM_SEEKING_AbsolutePositioning) {
	CheckPointer(pCurrent, E_POINTER);
	rtStart = *pCurrent;
	// round seek request to nearest output frame
	nCurSeg = FixTimeBack(&rtStart, TRUE);
    } else if (dwFlags == AM_SEEKING_RelativePositioning) {
	CheckPointer(pCurrent, E_POINTER);
	hr = CPosPassThru::GetCurrentPosition(&rtStart);
	if (hr != S_OK)
	    return hr;
	FixTime(&rtStart, m_pFrm->m_nCurSeg);
	rtStart += *pCurrent;
	// round seek request to nearest output frame
	nCurSeg = FixTimeBack(&rtStart, TRUE);
    } else if (dwFlags) {
    	DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Switch::Invalid Current Seek flags")));
	return E_INVALIDARG;
    }

// we're not going to set an end time
#if 0
    // stop at the end of the segment we seeked into (1/2 second HACK for
    // MPEG and broken splitters!!!)
    rtStop = m_pFrm->m_prtStop[nCurSeg] + 5000000;
#endif

    // nothing to do
    if (!(CurrentFlags & AM_SEEKING_PositioningBitsMask)) {
	return S_OK;
    }

    DWORD CFlags = CurrentFlags & ~AM_SEEKING_PositioningBitsMask;
    DWORD SFlags = StopFlags & ~AM_SEEKING_PositioningBitsMask;
    CFlags |= AM_SEEKING_AbsolutePositioning;
    SFlags |= AM_SEEKING_AbsolutePositioning;
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("FRC: Seek from %d to %dms"),
					(int)(rtStart / 10000),
					(int)(rtStop / 10000)));

    // note we're seeking during the flush that this will generate
    m_pFrm->m_fSeeking = TRUE;

    // we can't set the LastSeek variable until we've been flushed, and old
    // data has stopped arriving.  It must be set between the flush and the
    // next NewSegment call, so we'll set it in EndFlush to this value
    m_pFrm->m_rtNewLastSeek = rtStart;
    FixTime(&m_pFrm->m_rtNewLastSeek, nCurSeg);

    // the flush generated by the seek below needs to know this
    m_pFrm->m_nSeekCurSeg = nCurSeg;

#ifdef NOFLUSH
    m_pFrm->m_fExpectNewSeg = TRUE;       // seek will cause one
#endif

    // I know we were asked to play until time n, but I'm going to tell it to
    // play all the way to the end.  If there's a gap in the file, and the stop
    // time is during the gap, we won't get enough samples to fill the whole
    // playing time.  If we play until the end, we'll get the first sample
    // after the gap, notice it's after the time we originally wanted to stop
    // at, and send the frame we get to fill the gap, which is better than
    // sending nothing (we have to send samples without gaps, or the switch
    // won't work).  The alternative is to copy every frame, and resend copies
    // of the last thing we got if we see an EOS too early (less efficient)
    // or to create black frames and send them to fill the gap (that would
    // only work for mediatypes we knew about, something I hesitate to do).
    hr = CPosPassThru::SetPositions(&rtStart, CFlags, NULL, 0);

    // We assume all Dexter sources are seekable
    if (hr != S_OK) {
        DbgLog((LOG_ERROR,TRACE_HIGHEST,TEXT("FRC SEEK FAILED")));
	//m_pFrm->FakeSeek(rtStart);
    }

#ifdef NOFLUSH
    if (m_pFrm->m_fSurpriseNewSeg) {
    	DbgLog((LOG_TRACE,1,TEXT("Seek:Sending SURPRISE NewSeg now")));
        m_pFrm->CTransInPlaceFilter::NewSegment(m_pFrm->m_rtSurpriseStart,
                                        m_pFrm->m_rtSurpriseStop, 1);
        m_pFrm->m_fSurpriseNewSeg = FALSE;
    }
#endif

    // if the push thread was stopped, we won't get flushed, and this won't
    // have been updated
    // !!! I ASSUME the push thread won't be started until this thread does it
    // when this function returns, or there is a race condition
    m_pFrm->m_rtLastSeek = m_pFrm->m_rtNewLastSeek;

    // !!! if we ever support Rate, we need to take the seek rate into account
    hr = CPosPassThru::SetRate(1.0);

    // all done
    m_pFrm->m_fSeeking = FALSE;

    // reset same stuff we reset when we start streaming
    m_pFrm->m_llOutputSampleCnt = 0;

    // in case we weren't flushed
    m_pFrm->m_nCurSeg = nCurSeg;

    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("FRC:Seeked into segment %d, rate = %d/100"), nCurSeg,
				(int)(m_pFrm->m_pSkew[nCurSeg].dRate * 100)));

    // (see comment about sharing a source filter at the top of audpack.cpp)
    // We were waiting for this seek, ever since we got a surprise flush.
    // Now that the switch knows about the seek, we can resume sending it
    // new data, and allow Receive to be entered (set the Seek event)
    // being careful to set all our variables up BEFORE releasing the hounds
    //
    if (m_pFrm->m_fFlushWithoutSeek) {
	m_pFrm->m_fFlushWithoutSeek = FALSE;
    	DbgLog((LOG_TRACE,1,TEXT("SURPRISE FLUSH followed by a SEEK - OK to resume")));

        // DO NOT FLUSH! The push thread has already started delivering the new
        // post-seek data... flushing will kill it and hang us!
	
    } else if (m_pFrm->m_State == State_Paused) {
	// Set this so that if a flush ever happens without a seek later,
	// we'll know that flush was AFTER the seek, not before
	m_pFrm->m_fFlushWithoutSeek = TRUE;
    }

    // only now that the above calculations were made, can we accept data again
    SafeSetEvent(m_pFrm->m_hEventSeek);

    return S_OK;
}

STDMETHODIMP
CSkewPassThru::GetPositions(LONGLONG *pCurrent, LONGLONG * pStop)
{
    HRESULT hr=CPosPassThru::GetPositions(pCurrent, pStop);
    if(hr== S_OK)
    {
	FixTime(pCurrent, m_pFrm->m_nCurSeg);
	FixTime(pStop, m_pFrm->m_nCurSeg);
    }
    return hr;
}

STDMETHODIMP
CSkewPassThru::GetCurrentPosition(LONGLONG *pCurrent)
{
    HRESULT hr = CPosPassThru::GetCurrentPosition(pCurrent);
    if(hr== S_OK)
    {
	FixTime(pCurrent, m_pFrm->m_nCurSeg);
    }
    return hr;
}

STDMETHODIMP
CSkewPassThru::GetStopPosition(LONGLONG *pStop)
{
    HRESULT hr=CPosPassThru::GetStopPosition(pStop);
    if( hr == S_OK)
    {
	FixTime(pStop, m_pFrm->m_nCurSeg);
    }
    return hr;
}

STDMETHODIMP
CSkewPassThru::GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest )
{
    CheckPointer(pEarliest, E_POINTER);
    CheckPointer(pLatest, E_POINTER);
    *pEarliest = m_pFrm->m_pSkew[m_pFrm->m_nCurSeg].rtMStart;
    *pLatest = m_pFrm->m_pSkew[m_pFrm->m_nCurSeg].rtMStop;
    FixTime(pEarliest, m_pFrm->m_nCurSeg);
    FixTime(pLatest, m_pFrm->m_nCurSeg);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\frc\frc.cpp ===
// !!! The MEDIA TIMES are not fixed up!  This could mess up live data!

/*

This video frame rate converter will perfectly correct time stamps to be at the
new frame rate (specified as a double, not in UNITS), with no error propagation.
It is an IN-PLACE transform that does not copy any data, just munges time stamps
and delivers some frames more than once.  Thus it allows itself to be in pass through mode with read-only buffers since it doesn't actually touch them.

It supports IDexterSequencer

It also delivers only the piece of a file you want, not the entire file.
It also skews time stamps linearly by a set amount.  For instance, if you are
doing an editing project and want the part of a movie from 15 to 25 seconds to
play starting at 30 seconds into your project, you set m_rtMediaStart to 15,
m_rtMediaStop to 25, and m_rtSkew to 15.  This filter will send a NewSegment
of 30 seconds, and then just the frames from 15 to 25 seconds of this movie,
time stamped starting at 0.

If you wish to play a 10 second video clip in only 5 seconds of timeline time,
this filter will pass a rate upstream, and do the rate change. (also does
slo motion)

#if 0
We also do fancy allocator stuff:  Normally the upstream filter calls GetBuffer
directly on the downstream filter, bypassing us.  That is bad, we need to make
the timestamps on GetBuffer what they will be when we call Receive, or the
downstream switch misbehaves, so we have a special fake allocator that sees
the GetBuffer request, and passes it downstream with corrected time stamps.
#endif

An output frame rate of 0 is a special thing... we will NOT do any frame rate
converting... for example, if we are doing smart recompression and need to
pass compressed data along without modifying it in any way, we'll do the
skewing, to fix the media times to timeline time, but we will never upsample
or downsample

*/

// NOTES ON SHARING A SOURCE FILTER:  The same source filter may be used in
// the video group, and the audio group, to avoid opening it twice. Seeking
// such a graph is complicated.  For the AVI parser, here's the behaviour...
// a seek on the video pin is obeyed, and seeks on the audio pin are ignored.
// (they better be identical anyway).  So what happens if the video switch is
// seeked first, is that that will cause the splitter to flush and send the
// new data to the audio branch, much to the surprise of the audio branch.
// Then later, the audio switch will see the seek, and the audio chain will
// ignore it.
// If the audio switch is seeked first, then we will see the seek, but nothing
// will happen, and then later when the video group is seeked, the audio chain
// will get flushed, and new data delivered, again, much to our surprise.
//
// So, if we get flushed during a seek, that's the normal case.  But now there
// are 2 other cases:
// 1. We get flushed out of nowhere. Wait for the seek we know is coming, and
//    then allow ourself to deliver data again (we need to wait for the switch
//    to be expecting the new data)
// 2. We get a seek, then a surprise flush.  We can start sending new data right
//    away without waiting for another seek.


//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//
// Summary
//
// This is a Frame Rate Converter Filter
//
//
// Files/
//
// FRC.cpp              Main filter and outputpin code
// FRC.h                Class definition for the filter and output pin
// PThru.cpp            CSkewPassThru class which supports IMediaSeeking
// PThru.h              Class definition for the CSkewClass
//
// Base classes used
//
// CTransInPlaceFilter  A transform filter with one input and output pin
//
//

#include <windows.h>
#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#ifdef FILTER_DLL
#include <initguid.h>
#endif
#include "FRC.h"
#include "PThru.h"
#include "resource.h"
#include "..\util\conv.cxx"
#include "..\util\filfuncs.h"
#include "..\util\perf_defs.h"

// for time stamp rounding errors (1ms)
#define FUDGE 10000

// Setup information
const AMOVIESETUP_MEDIATYPE sudPinTypes =
{
    &MEDIATYPE_Video,       // Major type
    &MEDIASUBTYPE_NULL      // Minor type
};

const AMOVIESETUP_PIN sudpPins[] =
{
    { L"Input",             // Pins string name
      FALSE,                // Is it rendered
      FALSE,                // Is it an output
      FALSE,                // Are we allowed none
      FALSE,                // And allowed many
      &CLSID_NULL,          // Connects to filter
      NULL,                 // Connects to pin
      1,                    // Number of types
      &sudPinTypes          // Pin information
    },
    { L"Output",            // Pins string name
      FALSE,                // Is it rendered
      TRUE,                 // Is it an output
      FALSE,                // Are we allowed none
      FALSE,                // And allowed many
      &CLSID_NULL,          // Connects to filter
      NULL,                 // Connects to pin
      1,                    // Number of types
      &sudPinTypes          // Pin information
    }
};

const AMOVIESETUP_FILTER sudFrmRateConv =
{
    &CLSID_FrmRateConverter,         // Filter CLSID
    L"Frame Rate Converter",       // String name
    MERIT_DO_NOT_USE,       // Filter merit
    2,                      // Number of pins
    sudpPins                // Pin information
};


#ifdef FILTER_DLL

//----------------------------------------------------------------------------
// Creator function for the class ID
//----------------------------------------------------------------------------

// List of class IDs and creator functions for the class factory. This
// provides the link between the OLE entry point in the DLL and an object
// being created. The class factory will call the static CreateInstance

CFactoryTemplate g_Templates[] = {
    { L"Frame Rate Converter"
    , &CLSID_FrmRateConverter
    , CFrmRateConverter::CreateInstance
    , NULL
    , &sudFrmRateConv },
    {
      L"Frame Rate Converter Property Page",
      &CLSID_FRCProp,
      CFrcPropertyPage::CreateInstance
    }


};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);


//
// DllRegisterServer
//
// Handles sample registry and unregistry
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );

} // DllRegisterServer


//
// DllUnregisterServer
//
STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );

} // DllUnregisterServer

#endif

const int TRACE_HIGHEST = 2;
const int TRACE_MEDIUM = 3;
const int TRACE_LOW = 4;
const int TRACE_LOWEST = 5;

BOOL SafeResetEvent(HANDLE h);
BOOL SafeSetEvent(HANDLE h);
    
//
// Constructor
//
CFrmRateConverter::CFrmRateConverter(TCHAR *tszName,
		   LPUNKNOWN punk,
		   REFCLSID clsid,
		   HRESULT *phr) :
    CTransInPlaceFilter(tszName, punk, CLSID_FrmRateConverter, phr),
    CPersistStream(punk, phr),
    m_dOutputFrmRate(15.0),	// default output frame rate
    m_pSkew(NULL),
    m_cTimes(0),
    m_cMaxTimes(0),
    m_rtLastSeek(-1),		// nobody has seeked us yet
    m_fSeeking(FALSE),		// not seeking now
    m_bMediaTypeSetByUser(false),
    m_fSpecialSeek(FALSE),
    m_fJustLate(FALSE),
    m_fStopPushing(FALSE),
    m_fFlushWithoutSeek(FALSE),
    m_fParserHack(FALSE),
    m_fThreadMustDie(FALSE),
    m_pUpAllocator(NULL),
    //m_fCantSeek(FALSE),
    //m_rtFakeSeekOffset(0),
    m_nHackCur(0)
#ifdef NOFLUSH
    , m_fSurpriseNewSeg(FALSE)
#endif
    , m_hEventSeek(0)
    , m_hEventThread(0)
{
    m_pHackSample[0] = NULL;
    m_pHackSample[1] = NULL;

    ZeroMemory(&m_mtAccept, sizeof(AM_MEDIA_TYPE));
    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("CFrmRateConverter::CFrmRateConverter")));

    // by default, play the movie normally
    AddStartStopSkew(0, MAX_TIME, 0, 1.0);
    m_nCurSeg = 0;

} // (Constructor)


CFrmRateConverter::~CFrmRateConverter()
{
    if (m_pSkew)
	QzTaskMemFree(m_pSkew);

    ASSERT(m_hEventThread == 0);
    ASSERT(m_hEventSeek == 0);
}


//
// CreateInstance
//
// Provide the way for COM to create a FrmRateConverter object
//
CUnknown *CFrmRateConverter::CreateInstance(LPUNKNOWN punk, HRESULT *phr)
{
    CFrmRateConverter *pNewObject = new CFrmRateConverter(NAME("Frame Rate Converter"),
							punk,
							CLSID_FrmRateConverter,
							phr);
    if (pNewObject == NULL) {
	*phr = E_OUTOFMEMORY;
    }
    return pNewObject;

} // CreateInstance


//
// NonDelegatingQueryInterface
//
// Reveals IIPEffect and ISpecifyPropertyPages
//
STDMETHODIMP CFrmRateConverter::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CheckPointer(ppv,E_POINTER);

    if (IsEqualIID(IID_ISpecifyPropertyPages, riid)) {
      return GetInterface((ISpecifyPropertyPages *)this, ppv);
    } else if (riid == IID_IDexterSequencer) {
	return GetInterface((IDexterSequencer *) this, ppv);
    } else if (riid == IID_IPersistStream) {
	return GetInterface((IPersistStream *) this, ppv);
    } else {
	return CTransInPlaceFilter::NonDelegatingQueryInterface(riid, ppv);
    }
} // NonDelegatingQueryInterface




HRESULT CFrmRateConverter::NextSegment(BOOL fUseOtherThread)
{
    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("FRC:Done Segment %d"), m_nCurSeg));

    if (m_nCurSeg < m_cTimes) {
        m_nCurSeg++;
    }

    if (m_nCurSeg == m_cTimes) {
        DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("FRC:ALL done")));
	// deliver EOS only after all segs done
	CTransInPlaceFilter::EndOfStream();
	return S_OK;
    }

    // WE CANNOT SEEK ON the source's pushing thread, or you hang.
    // (That's just the rule).  So we have a separate thread that can seek
    // for us in that case.  Let's wake it up.
    if (fUseOtherThread) {
        m_fThreadCanSeek = TRUE;
        SetEvent(m_hEventThread);
    } else {
	m_fThreadCanSeek = TRUE;
	hr = SeekNextSegment();
    }

    return hr;
}


#if 0 // my attempt at making sources not have to be seekable
// our source can't seek.  We better pretend it can, and do the work for it,
// or Dexter won't work with this source.  We'll send flushes, and a NewSeg,
// and in Receive, we'll pretend we received time stamps 0 based.
//
HRESULT CFrmRateConverter::FakeSeek(REFERENCE_TIME rtStart)
{
    m_pInput->BeginFlush();
    m_pInput->EndFlush();
    m_pInput->NewSegment(rtStart, MAX_TIME / 100, 1.0);
    m_fCantSeek = TRUE;
    return S_OK;
}
#endif


// called by our special thread to do the seek to the next segment
//
HRESULT CFrmRateConverter::SeekNextSegment()
{
    // our thread can't seek at the same time the app seeks us
    CAutoLock cAutolock(&m_csThread);

    // it is not safe for our thread to seek
    if (!m_fThreadCanSeek) {
	return S_OK;
    }
    m_fThreadCanSeek = FALSE;

    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("FRC:Delayed Seek for NextSegment")));

    // in timeline time (which includes skew), this is where we are starting
    m_rtNewLastSeek = m_pSkew[m_nCurSeg].rtTLStart;
    m_nSeekCurSeg = m_nCurSeg;	// EndFlush looks at this

    // ??? will we get a new seg for sure?

    // note we're seeking during the flush that this will generate
    m_fSeeking = TRUE;
    m_fSpecialSeek = TRUE;

    IMediaSeeking *pMS;
    IPin *pPin = m_pInput->GetConnected();
    HRESULT hr = pPin->QueryInterface(IID_IMediaSeeking, (void **)&pMS);

    // sources have to support seeking right now
    if (FAILED(hr)) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("FRC SEEK FAILED")));
	//FakeSeek(m_prtStart[m_nCurSeg]);
	//goto OK;
	return E_FAIL;
    }

    // Make sure we're talking MEDIA TIME
    hr = pMS->SetTimeFormat(&TIME_FORMAT_MEDIA_TIME);
    // this will FAIL if we're not stopped, and that's OK

// we're not going to set a stop time
#if 0
    // what's the real stop time?
    if (m_prtStop[m_nCurSeg] == MAX_TIME) {
        hr = pMS->GetStopPosition(&m_prtStop[m_nCurSeg]);
        if (FAILED(hr)) {
	    m_prtStop[m_nCurSeg] = 3600*UNITS;	// !!! one hour OK?
        }
        DbgLog((LOG_TRACE, TRACE_MEDIUM, TEXT("Real Stop time is %d"), (int)
				(m_prtStop[m_nCurSeg] / 10000)));
    }
#endif

    // we don't tell the source to change the rate.  We do it ourself.  We may
    // be sharing this source with somebody else, who will panic if the rate
    // is not 1.

    hr = pMS->SetRate(1.0);

#if 0
    // seek to the piece of movie we're interested in
    // !!! HACK for MPEG... it sends 1/2s less than we ask for, so we better
    // ask for too much or the big switch will hang being shortchanged.
    REFERENCE_TIME stop = m_pSkew[m_nCurSeg].rtStop;
    stop += 5000000;	// !!! wastes too much time?
#endif

    // I know we were asked to play until time n, but I'm going to tell it to
    // play all the way to the end.  If there's a gap in the file, and the stop
    // time is during the gap, we won't get enough samples to fill the whole
    // playing time.  If we play until the end, we'll get the first sample
    // after the gap, notice it's after the time we originally wanted to stop
    // at, and send the frame we get to fill the gap, which is better than
    // sending nothing (we have to send samples without gaps, or the switch
    // won't work).  The alternative is to copy every frame, and resend copies
    // of the last thing we got if we see an EOS too early (less efficient)
    // or to create black frames and send them to fill the gap (that would
    // only work for mediatypes we knew about, something I hesitate to do).
    hr = pMS->SetPositions(&m_pSkew[m_nCurSeg].rtMStart,
			AM_SEEKING_AbsolutePositioning, NULL, 0);
    if (hr != S_OK) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("FRC SEEK FAILED")));
	//FakeSeek(m_prtStart[m_nCurSeg]);
	pMS->Release();
	return hr;
    }

    pMS->Release();

    // if the push thread was stopped, we won't get flushed, and this won't
    // have been updated
    // !!! I ASSUME the push thread won't be started until this thread does it
    // when this function returns, or there is a race condition
    m_rtLastSeek = m_rtNewLastSeek;

    // all done
    m_fSpecialSeek = FALSE;
    m_fSeeking = FALSE;

    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("Seg=%d  Seeking source to %d,%d ms"),
				m_nCurSeg,
				(int)(m_pSkew[m_nCurSeg].rtMStart / 10000),
				(int)(m_pSkew[m_nCurSeg].rtMStop / 10000)));

    // reset same stuff we reset when we start streaming
    m_llOutputSampleCnt = 0;

    // only now that the above calculations were made, can we accept data again
    SetEvent(m_hEventSeek);

    return S_OK;
}


// Fix the time stamps, deliver this frame 0, 1 or more times to convert the
// frame rate
// When run, all time stamps we send are 0 based.  The new segment will reflect
// what piece of the movie this is and the skew
//
HRESULT CFrmRateConverter::Receive(IMediaSample *pSample)
{
    // Stop pushing data to me!
    if (m_fStopPushing) {
        //return m_fCantSeek ? S_OK : E_FAIL;
	return E_FAIL;
    }

    HRESULT hr = S_OK;

    ASSERT(pSample);

    // make sure we're ready to accept data
    WaitForSingleObject(m_hEventSeek, INFINITE);

    if (m_nCurSeg == m_cTimes)
        //return m_fCantSeek ? S_OK : E_FAIL;
	return E_FAIL;

    //  EAT preroll before the switch sees it and maybe gets confused
    if (pSample->IsPreroll() == S_OK)
	return NOERROR;

    // make sure sample size is not zero
    if (!pSample->GetActualDataLength())
	return NOERROR;

    // Get sample start and stop time
    REFERENCE_TIME trStart, trStop;
    pSample->GetTime(&trStart, &trStop);

#if 0	// my attempt to make sources not have to be seekable
    // we tried to seek but couldn't.  Change all time stamps to be zero based
    if (m_fCantSeek) {
	if (m_llOutputSampleCnt == 0) {
	    m_rtFakeSeekOffset = trStart;
            DbgLog((LOG_TRACE,TRACE_LOW,TEXT("FRC:CantSeek:New time offset=%d"),
					(int)(m_rtFakeSeekOffset / 10000)));
	}
	trStart -= m_rtFakeSeekOffset;
	trStop -= m_rtFakeSeekOffset;
    }
#endif

    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("FRC::Receive Start=%d Stop=%d ms"),
		(int)(trStart / 10000), (int)(trStop / 10000)));

    CFrmRateConverterInputPin *pIn = (CFrmRateConverterInputPin *)m_pInput;

    REFERENCE_TIME rtPinNewSeg = pIn->CurrentStartTime();

if (m_dOutputFrmRate) {

    // Calculate received sample's stop time in TL time... we are doing any
    // rate changing, since we don't ask the source to
    REFERENCE_TIME rtStop = (REFERENCE_TIME)(rtPinNewSeg + trStop);
    rtStop = (REFERENCE_TIME)(m_pSkew[m_nCurSeg].rtTLStart +
				(rtStop - m_pSkew[m_nCurSeg].rtMStart) /
				m_pSkew[m_nCurSeg].dRate);
    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("Stop is %d"), (int)(rtStop / 10000)));

    // calculate how many times to deliver this frame based on the output FPS
    // and the output time. StopFrame should ROUND UP.
    LONGLONG StopFrame = RoundUpTime2Frame(rtStop , m_dOutputFrmRate);
    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("Duplicate this frame until %d"), (int)StopFrame));

    REFERENCE_TIME trOutStart, trOutStop;

    BOOL fRepeat = FALSE;

    // Deliver this 0, 1 or more times, until we've delivered all we're supposed
    // to
    while (m_llOutputSampleCnt + m_llStartFrameOffset < StopFrame)
    {
	// calc the output sample's start time
	trOutStart = Frame2Time( m_llOutputSampleCnt + m_llStartFrameOffset,
							m_dOutputFrmRate );

	// !!! If I got this math wrong, I'm toast

	// if this time stamp is too early, or too late, avoid sending it and
	// calling GetBuffer or it will conflict with valid time stamps in
	// a different segment.
	//
	int nAvoid = 0;
	if (trOutStart < m_pSkew[m_nCurSeg].rtTLStart) {
	    nAvoid = 1;
	}

	// if this time stamp is too late, avoid sending it (allow for rounding
	// error !!!)
	if (trOutStart + FUDGE >= m_pSkew[m_nCurSeg].rtTLStop) {
	    nAvoid = 2; // STOP PUSHING
	}

	trOutStart -= m_rtNewSeg;

        // calc the output sample's stop time
	trOutStop = Frame2Time( m_llOutputSampleCnt + m_llStartFrameOffset + 1, m_dOutputFrmRate );
	trOutStop -= m_rtNewSeg;

	CFrmRateConverterInputPin *pInput=(CFrmRateConverterInputPin*)m_pInput;

	// the sample we're going to actually send
	IMediaSample *pUseMe = pSample;
	BOOL fRelease_pUseMe = FALSE;

	// !!! We'll CRASH in every case except the downstream filter owning
	// the allocator, and being the BIG SWITCH !!!
	//
	//ASSERT(pInput->m_pAllocator == pInput->m_pFakeAllocator);

	// This is the first time through the loop.  We need to copy every
	// sample delivered to us.  EVEN IF WE'RE AVOIDING SENDING IT, so
	// that if the first thing we get (and don't avoid) is too late, we
	// can use this
	//
	// !!! If it wasn't too scary a change for millenium, I would avoid this
	// data copy if there is a resizer or COCO in front of me, by trying to
	// get 2 buffers in the allocator, and AddRef'ing instead of copying!
	//	
    	if (!fRepeat && m_fParserHack) {
	    DbgLog((LOG_TRACE,TRACE_LOW,TEXT("FRC:GetBuffer to make a copy (hack)")));
	    //hr = pInput->m_pFakeAllocator->GetBuffer(
	    hr = m_pUpAllocator->GetBuffer(
				&m_pHackSample[m_nHackCur],
				&trOutStart, &trOutStop, 0);
	    if (FAILED(hr)) {
		break;
	    }
	    LPBYTE pSrc, pDst;
	    hr = pSample->GetPointer(&pSrc);
	    ASSERT(SUCCEEDED(hr));
	    int count = pSample->GetActualDataLength();
	    hr = m_pHackSample[m_nHackCur]->GetPointer(&pDst);
	    ASSERT(SUCCEEDED(hr));
	    CopyMemory(pDst, pSrc, count);
	    m_pHackSample[m_nHackCur]->SetActualDataLength(count);
	}

	if (!nAvoid) {

	    // which buffer do we deliver?
	    // We need to pass a special flag to the switch saying allow POOL
	    // buffers to be given, otherwise we'll hang because we can only
	    // get one buffer at a time sometimes, and we already have one !!!
	    //
	    if (trOutStop <= trStart + rtPinNewSeg + m_pSkew[m_nCurSeg].rtSkew -
			m_rtNewSeg && m_fParserHack &&
			m_pHackSample[1 - m_nHackCur]) {
	        // this sample starts later than the current time.  Good thing
	        // we have the last thing delivered to us still hanging around.
	        // We'll deliver that again. (This fixes slide shows with the
	        // broken ASF parser that doesn't set end times)
		pUseMe = m_pHackSample[1 - m_nHackCur];
	        DbgLog((LOG_TRACE,TRACE_LOW,TEXT("FRC:HACK-use old sample")));
	    } else if (m_fParserHack) {
	        // We had to copy the current sample.  Might as well send the
	        // COPY NOT the ORIGINAL, so we don't send a read only buffer
	        // and can buffer ahead
		pUseMe = m_pHackSample[m_nHackCur];
	    } else {
		// use what we just received
		pUseMe = pSample;
	    }

	    if (fRepeat) {
	        // this is not the first time through the loop.  We need ANOTHER
	        // sample to deliver (it's against the law to deliver the same
	        // sample twice with different time stamps. it needs to be a new
	        // sample. So we need to get a fresh buffer from our allocator
	        fRelease_pUseMe = TRUE;
		IMediaSample *pSrcSample = pUseMe;
	        DbgLog((LOG_TRACE,TRACE_LOW,TEXT("FRC:GetBuffer(upsample)")));
	        //hr = pInput->m_pFakeAllocator->GetBuffer(
	        hr = m_pUpAllocator->GetBuffer(
				&pUseMe, &trOutStart, &trOutStop, 0);
		if (FAILED(hr)) {
		    break;
	        }
	        LPBYTE pSrc, pDst;
	        hr = pSrcSample->GetPointer(&pSrc);
	        ASSERT(SUCCEEDED(hr));
	        int count = pSrcSample->GetActualDataLength();
	        hr = pUseMe->GetPointer(&pDst);
	        ASSERT(SUCCEEDED(hr));
	        CopyMemory(pDst, pSrc, count);
	        pUseMe->SetActualDataLength(count);
	    }

	    //set sample time
	    pUseMe->SetTime( (REFERENCE_TIME*)&trOutStart,
						(REFERENCE_TIME*)&trOutStop);
	    pUseMe->SetMediaType( NULL );
	    pUseMe->SetSyncPoint(TRUE);
	    pUseMe->SetPreroll( FALSE );
	    pUseMe->SetDiscontinuity(FALSE);

	    // some broken decoders give us the wrong DataLen.  Fix it up
	    // or VidEdit won't be able to edit the output file we create, and
	    // wouldn't that be a disaster.

	    CFrmRateConverterInputPin *pIn = (CFrmRateConverterInputPin *)m_pInput;

	    LPBITMAPINFOHEADER lpbi = HEADER(pIn->m_mt.Format());
    	    if (IsEqualGUID(*pIn->m_mt.FormatType(), FORMAT_VideoInfo)) {
		if (lpbi->biCompression <= BI_BITFIELDS) {
		    pUseMe->SetActualDataLength(DIBSIZE(*lpbi));
		}
	    }

	    DbgLog((LOG_TRACE, TRACE_MEDIUM, TEXT("FRC: Deliver %I64d,%I64d Cur=%d"),
			trOutStart,
			trOutStop,
			(int)m_llOutputSampleCnt));

	    // deliver
	    hr = OutputPin()->Deliver(pUseMe);

	    if (fRelease_pUseMe) {
		pUseMe->Release();
	    }

	    // uh - oh!  We're behind
    	    if (m_fJustLate) {
    		REFERENCE_TIME rt = m_qJustLate.Late;
		m_fJustLate = FALSE;
		if (rt > 0) {
		    LONGLONG llSkip = Time2Frame(rt, m_dOutputFrmRate) - 1;
            	    DbgLog((LOG_TRACE,2,TEXT("FRC: SKIP %d frames"),
							(int)llSkip));
		    m_llOutputSampleCnt += llSkip;
		}
    	    }

	} else {
            DbgLog((LOG_TRACE, TRACE_MEDIUM, TEXT("CFrmRate::ALL done - AVOID DELIVER")));

            // avoid because too early ==> keep going
            // avoid because too late  ==> stop pushing
            if (nAvoid == 2) {
                EndOfStream();
                m_fStopPushing = TRUE;
                hr = E_FAIL;
            } else {
	        hr = S_OK;
            }
	}

        // an ordinary flush makes deliver return a SUCCESS code, in which case
        // this will GRIND DEXTER TO A HALT if we consider that a failure!
	if (FAILED(hr)) {
	    // we still get delivered frames after failing receive, making the
	    // wrong frame show up on the output, so we better ensure that
	    // we won't send anything more after this
	    m_fStopPushing = TRUE;
        }
        if (hr != S_OK) {
	    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("FRC: Deliver failed")));
	    break;
	}

	// update frm cnt
	m_llOutputSampleCnt++;
	fRepeat = TRUE;
    }	// while

    // ping pong
    if (m_fParserHack) {
	m_nHackCur = 1 - m_nHackCur;
	if (m_pHackSample[m_nHackCur]) {
	    m_pHackSample[m_nHackCur]->Release();
	    m_pHackSample[m_nHackCur] = NULL;
	}
    }

    return hr;

  // there is no output frame rate.. do NOT frame rate convert
} else {

    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("FRC:SKEW ONLY")));

    // time stamps incl. their own NewSeg and skew
    trStart += rtPinNewSeg + m_pSkew[m_nCurSeg].rtSkew;
    trStop += rtPinNewSeg + m_pSkew[m_nCurSeg].rtSkew;

    // When delivering two segments in the mode when we don't change any
    // time stamps, we might end up sending the first frame of segment 2 with
    // a lower time stamp than the last frame of segment 1, thus going back
    // in time.  Since time stamps aren't fixed up nice.  Let's say the break
    // between segments is at 2000ms.  The last frame of segment 1 might be
    // as high as 1999, and the first frame of segment 2 could be as much as
    // 1/2 frame time back from 2000, say 1966.  Thus we make sure the first
    // time stamp ever delivered in a segment is never earlier than the time
    // the segment was supposed to start
    // Of course, if the entire frame is too early, just eat it
    //
    if (trStop <= m_pSkew[m_nCurSeg].rtTLStart) {
	return NOERROR;
    } else if (trStart < m_pSkew[m_nCurSeg].rtTLStart) {
	trStart = m_pSkew[m_nCurSeg].rtTLStart;
    }

    // time stamps relative to what the downstream guy thinks the NewSeg is
    trStart -= m_rtNewSeg;
    trStop -= m_rtNewSeg;

    pSample->SetTime(&trStart, &trStop);

    // the source is happily pushing an infinite # of frames at us in pass-thru
    // mode.  It's up to us to notice that we've got a time stamp later than
    // we need, and to stop the pushing

    REFERENCE_TIME rtTLStop = m_pSkew[m_nCurSeg].rtTLStop;
    if (m_rtNewSeg + trStart > rtTLStop + FUDGE) {
	DbgLog((LOG_TRACE, TRACE_LOW, TEXT("FRC: Received enough - Finished a segment")));
	EndOfStream();
	// We can't trust sources to stop pushing, and unfortunately, Dexter
	// will hang if it doesn't. (Seeking ourself to the next segment doesn't
	// let the flush go downstream or it confuses other filters, so we
	// have to make sure the push thread can't ever block).
	// So, from now on, fail any calls to GetBuffer or Receive
	m_fStopPushing = TRUE;
        //return m_fCantSeek ? S_OK : E_FAIL;
	return E_FAIL;
    }

    hr = OutputPin()->Deliver(pSample);
    if (m_fJustLate) {
	// if delivering ended up sending a quality message, reset it
	m_fJustLate = FALSE;
    }
    // an ordinary flush makes deliver return a SUCCESS code, in which case
    // this will GRIND DEXTER TO A HALT if we consider that a failure!
    if (FAILED(hr)) {
	DbgLog((LOG_TRACE, TRACE_LOW, TEXT("FRC: Deliver failed")));
	// we still get delivered frames after failing receive, making the
	// wrong frame show up on the output, so we better ensure that
	// we won't send anything more after this
	m_fStopPushing = TRUE;
    }
    return hr;
}

} // Receive



HRESULT CFrmRateConverter::StartStreaming()
{
    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("FRC::StartStreaming")));

    // hack to copy every sample we get so that if a parser is broken, and
    // the end time is set wrong, we still see that frame until the next frame
    // time, instead of seeing the next frame way early (slide shows will be
    // broken in ASF without this).  Bad: extra memory copy  Good: eliminates
    // using 1 R/O buffer, so Dexter can run ahead and buffer and smooth out
    // glitches due to slow effects.  Also fixes slide shows.  Hack is only
    // for the non-smart recompression case when we have a frame rate.  If we
    // don't, we're dealing with compressed data and shouldn't do this hack
    //
    IBaseFilter *pF = GetStartFilterOfChain(m_pInput);
    if (pF) {
	CLSID clsid;
        HRESULT hr = pF->GetClassID(&clsid);
	if (m_dOutputFrmRate && hr == S_OK && clsid == CLSID_WMAsfReader) {
	    m_fParserHack = TRUE;
    	    DbgLog((LOG_TRACE,TRACE_HIGHEST,TEXT("FRC:COPY EVERYTHING to fix ASF bug and allow buffering ahead")));
	}
    }

    // if we were stopped when this was set, it will not be reset, since we
    // won't have gotten an EndFlush from the seek trying to start us again
    m_fStopPushing = FALSE;	// OK to deliver to me again

#ifdef NOFLUSH
    m_fExpectNewSeg = TRUE;     // we'll get one now
    m_fSurpriseNewSeg = FALSE;
#endif

    if (m_cTimes == 0)
	return E_UNEXPECTED;

    // make the event BEFORE creating the thread.. it uses this!
    m_hEventThread = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_hEventThread == NULL) {
	return E_OUTOFMEMORY;
    }

    m_hEventSeek = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (m_hEventSeek == NULL) {
	CloseHandle(m_hEventThread);
	m_hEventThread = NULL;
	return E_OUTOFMEMORY;
    }

    // We need a thread to seek on if we are re-using our source
    if (m_cTimes > 1) {
	m_fThreadMustDie = FALSE;
	m_fThreadCanSeek = FALSE;
        if (m_worker.Create(this)) {
            m_worker.Run();
	}
    }

#ifdef DEBUG
    // before we begin, make sure all timeline times are on a frame boundary
    // !!! Play.  Stop.  Change the frame rate.  Play. These numbers will drift.
    //
    if (m_dOutputFrmRate) {
        for (int z=0; z<m_cTimes; z++)
        {
	    // !!! actually align instead of asserting?
    	    LONGLONG llOffset = Time2Frame( m_pSkew[z].rtTLStart,
                                                m_dOutputFrmRate );
    	    REFERENCE_TIME rtTest = Frame2Time( llOffset, m_dOutputFrmRate );
	    ASSERT(rtTest == m_pSkew[z].rtTLStart);
#if 0	// this assert will fire (rounding error)
    	    REFERENCE_TIME rt = m_prtStart[z] + m_prtSkew[z] +
			(REFERENCE_TIME) ((m_prtStop[z] - m_prtStart[z]) /
			m_pdRate[z]);
    	    llOffset = Time2Frame( rt, m_dOutputFrmRate );
    	    rtTest = Frame2Time( llOffset, m_dOutputFrmRate );
	    ASSERT(rtTest == rt);
#endif
	}
    }
#endif

    // stuff to reset
    m_llOutputSampleCnt		= 0;
    m_fFlushWithoutSeek = FALSE;

    GUID guid;
    IPin *pPin = m_pInput->GetConnected();
    if (pPin == NULL)
        return CTransInPlaceFilter:: StartStreaming();

    // if we weren't seeked, but we're just playing ordinarily, we never
    // seeked upstream to get the piece of movie we're interested in.  Do it now
    //
    if (m_rtLastSeek < 0) {
	ASSERT(m_nCurSeg == 0);
	m_nCurSeg--;
	NextSegment(FALSE);
    }

    // when we upsample, we need a buffer to upsample into.  Make an allocator
    //
    HRESULT hr = S_OK;
    m_pUpAllocator = new CMemAllocator(NAME("UpSample Allocator"), NULL, &hr);
    if (m_pUpAllocator == NULL) {
        return E_OUTOFMEMORY;
    }
    m_pUpAllocator->AddRef();
    ALLOCATOR_PROPERTIES a, b;
    ((CFrmRateConverterInputPin *)m_pInput)->m_pAllocator->GetProperties(&a);
    // Normally 1 is enough, but if we're copying every sample, we need 2
    // Don't waste memory! There could be hundreds of FRC's in the graph!
    a.cBuffers = m_fParserHack ? 3 : 1;
    m_pUpAllocator->SetProperties(&a, &b);
    hr = m_pUpAllocator->Commit();
    if (FAILED(hr))
        return hr;
	
    return CTransInPlaceFilter::StartStreaming();
}


HRESULT CFrmRateConverter::StopStreaming()
{
    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("FRC::StopStreaming")));

    // release our hack stuff
    if (m_pHackSample[0]) m_pHackSample[0]->Release();
    if (m_pHackSample[1]) m_pHackSample[1]->Release();
    m_pHackSample[0] = NULL;
    m_pHackSample[1] = NULL;
    m_nHackCur = 0;

    if (m_hEventSeek) {
        CloseHandle(m_hEventSeek);
        m_hEventSeek = 0;
    }
    if (m_hEventThread) {
        CloseHandle(m_hEventThread);
        m_hEventThread = 0;
    }

    if (m_pUpAllocator) {
        m_pUpAllocator->Release();
        m_pUpAllocator = NULL;
    }

    return CTransInPlaceFilter:: StopStreaming();
}


HRESULT CFrmRateConverter::Stop()
{
    // If we have a thread, kill it. This thread can take our filter critsec,
    // so we must do this OUTSIDE of that crit sec!
    if (m_hEventThread && m_cTimes > 1) {
	m_fThreadMustDie = TRUE;
	SetEvent(m_hEventThread);
	m_worker.Stop();
	m_worker.Exit();
	m_worker.Close();
    }

    CAutoLock lck1(&m_csFilter);
    if (m_State == State_Stopped) {
        return NOERROR;
    }

    // Succeed the Stop if we are not completely connected

    ASSERT(m_pInput == NULL || m_pOutput != NULL);
    if (m_pInput == NULL || m_pInput->IsConnected() == FALSE ||
        m_pOutput->IsConnected() == FALSE) {
                m_State = State_Stopped;
                m_bEOSDelivered = FALSE;
                return NOERROR;
    }

    ASSERT(m_pInput);
    ASSERT(m_pOutput);

    // decommit the input pin before locking or we can deadlock
    m_pInput->Inactive();
    m_pUpAllocator->Decommit(); // this will unblock receive, which might be
                                // stuck in GetBuffer

    // make all future GetBuffer and Receive calls fail, and make sure one isn't
    // executing now
    m_fStopPushing = TRUE;
    CAutoLock lck2(&m_csReceive);

    m_pOutput->Inactive();

    // allow a class derived from CTransformFilter
    // to know about starting and stopping streaming

    HRESULT hr = StopStreaming();
    if (SUCCEEDED(hr)) {
	// complete the state transition
	m_State = State_Stopped;
	m_bEOSDelivered = FALSE;
    }
    return hr;
}


// Irregardless of what new segment we get, we are correcting time stamps,
// so we send a new segment downstream of simply the piece of movie we're
// going to start sending plus the skew
//
// !!! Do we need to swallow new segments coming when we seek ourself? (and
//     fix the time stamps again?)
HRESULT CFrmRateConverter::NewSegment(
			REFERENCE_TIME tStart,
			REFERENCE_TIME tStop,
			double dRate)
{
    // ignore - we're all done, and m_nCurSeg is an invalid value to use
    if (m_nCurSeg == m_cTimes)
        return S_OK;

    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("CFrmRateConverter::NewSegment %d-%dms"),
			(int)(tStart / 10000), (int)(tStop / 10000)));

    // release our hack stuff, ready to start again
    if (m_pHackSample[0]) m_pHackSample[0]->Release();
    if (m_pHackSample[1]) m_pHackSample[1]->Release();
    m_pHackSample[0] = NULL;
    m_pHackSample[1] = NULL;
    m_nHackCur = 0;

    // convert to timeline time
    REFERENCE_TIME rtNewStart, rtNewStop;
    if (m_rtLastSeek < 0) {
	// Never been seeked, so this is the beginning of what we're sending
        rtNewStart = m_pSkew[m_nCurSeg].rtTLStart;
        rtNewStop = m_pSkew[m_nCurSeg].rtTLStart +
			(REFERENCE_TIME) ((tStop - tStart) / dRate);
    } else {
        // Skew the #'s, and send 'em on!
	rtNewStart = tStart;
        rtNewStop = tStop;
        if (rtNewStart < m_pSkew[m_nCurSeg].rtMStart)
	    rtNewStart = m_pSkew[m_nCurSeg].rtMStart;
        if (rtNewStart > m_pSkew[m_nCurSeg].rtMStop)
	    rtNewStart = m_pSkew[m_nCurSeg].rtMStop;
        rtNewStart = (REFERENCE_TIME)(m_pSkew[m_nCurSeg].rtTLStart +
		        (rtNewStart - m_pSkew[m_nCurSeg].rtMStart) /
                        m_pSkew[m_nCurSeg].dRate);
        if (rtNewStop < m_pSkew[m_nCurSeg].rtMStart)
	    rtNewStop = m_pSkew[m_nCurSeg].rtMStart;
        if (rtNewStop > m_pSkew[m_nCurSeg].rtMStop)
	    rtNewStop = m_pSkew[m_nCurSeg].rtMStop;
        rtNewStop = (REFERENCE_TIME)(m_pSkew[m_nCurSeg].rtTLStart +
		 (rtNewStop - m_pSkew[m_nCurSeg].rtMStart) /
		 m_pSkew[m_nCurSeg].dRate);

	m_rtLastSeek = rtNewStart;	// pretend we were seeked here
    }
    m_rtNewSeg = rtNewStart;

    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("NewSeg:Skewing %dms to %dms"),
			(int)(tStart / 10000), (int)(rtNewStart / 10000)));

    if( m_dOutputFrmRate )
    {
        // What frame were we seeked into?  That's the first frame to send
        m_llStartFrameOffset = Time2Frame(m_rtNewSeg, m_dOutputFrmRate);
        DbgLog((LOG_TRACE, TRACE_LOW, TEXT("Seek was to frame %d"),
						    (int)m_llStartFrameOffset));
    }
    else
    {
        m_llStartFrameOffset = 0;
    }

#ifdef NOFLUSH
    // special stuff not necessary if we got a surprise flush too
    if (m_fExpectNewSeg || m_fFlushWithoutSeek) {
        // we might get 2 in a row
        // m_fExpectNewSeg = FALSE;
        return CTransInPlaceFilter::NewSegment( rtNewStart, rtNewStop, dRate );
    } else {
        // we weren't expecting a NewSeg.  It must mean that we are sharing
        // a parser with a video group that got seeked, and seeked us.  We will
        // get seeked too, eventually, and then send this NewSeg on.  Until then
        // do not deliver anything to the switch, it will screw it up. It does
        // not know about the seek yet.
    	DbgLog((LOG_TRACE,1,TEXT("Got SURPRISE NewSeg! Stop Delivering until Seek")));
        m_fSurpriseNewSeg = TRUE;
        m_rtSurpriseStart = rtNewStart;
        m_rtSurpriseStop = rtNewStop;
        ResetEvent(m_hEventSeek);
        return S_OK;
    }
#else
    return CTransInPlaceFilter::NewSegment( rtNewStart, rtNewStop, dRate );
#endif
}


HRESULT CFrmRateConverter::EndOfStream()
{
    if (m_fStopPushing) {
        DbgLog((LOG_TRACE,TRACE_HIGHEST,TEXT("FRC: Ignoring bogus EOS")));
	return S_OK;
    }

    // ignore - we're all done, and m_nCurSeg is an invalid value to use
    if (m_nCurSeg == m_cTimes)
        return S_OK;

    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("*FRC::EndOfStream")));

    // If we're dealing with ASF, the WM SDK reader is broken in many ways.
    // It reports all stream lengths as the maximum length of any stream, it
    // doesn't actually give you each stream's length.  So we may run out of
    // data earlier than we expect, which would hang the switch.  Luckily,
    // because of ANOTHER WMSDK bug not setting the stop time of samples,
    // we're already holding a sample around we can send now.
    //
    // if we don't have a frame rate, we are dealing with compressed types
    // and can't/shouldn't do this
    while (m_dOutputFrmRate) {

	// !!! This is the same code as Receive

	HRESULT hr;
	int nAvoid = 0;
	REFERENCE_TIME trOutStart, trOutStop;

	// calc the output sample's start time
	trOutStart = Frame2Time( m_llOutputSampleCnt + m_llStartFrameOffset,
							m_dOutputFrmRate );

	// if this time stamp is too early or too late, avoid sending it
	// or it will conflict with valid time stamps in a different segment.
	//
	if (trOutStart < m_pSkew[m_nCurSeg].rtTLStart) {
	    nAvoid = 1;
	}
	// FUDGE = avoid rounding error
	if (trOutStart + FUDGE >= m_pSkew[m_nCurSeg].rtTLStop) {
	    nAvoid = 2; // ALL DONE!
	}

	trOutStart -= m_rtNewSeg;
	trOutStop = Frame2Time(m_llOutputSampleCnt + m_llStartFrameOffset + 1,
							m_dOutputFrmRate);
	trOutStop -= m_rtNewSeg;

	if (!nAvoid) {

	    // the sample we're going to actually send
	    IMediaSample *pUseMe;

	    // !!! We'll CRASH in every case except the downstream filter owning
	    // the allocator, and being the BIG SWITCH !!!

	    CFrmRateConverterInputPin *pInput = (CFrmRateConverterInputPin *)m_pInput;

	    //ASSERT(pInput->m_pAllocator == pInput->m_pFakeAllocator);

	    DbgLog((LOG_TRACE,TRACE_LOW,TEXT("FRC:Send shortchanged frame")));
	    //hr = pInput->m_pFakeAllocator->GetBuffer(
	    hr = m_pUpAllocator->GetBuffer(
				&pUseMe, &trOutStart, &trOutStop, 0);
	    if (FAILED(hr)) {
	        break;
	    }
	    LPBYTE pSrc, pDst;
	    int count;
	    // if we have a frame sitting around to use, GREAT!  Else, make
	    // a black frame, I guess
	    hr = pUseMe->GetPointer(&pDst);
	    ASSERT(SUCCEEDED(hr));
    	    if (m_fParserHack && m_pHackSample[1 - m_nHackCur]) {
	        hr = m_pHackSample[1 - m_nHackCur]->GetPointer(&pSrc);
	        ASSERT(SUCCEEDED(hr));
	        count = m_pHackSample[1 - m_nHackCur]->GetActualDataLength();
	        CopyMemory(pDst, pSrc, count);
	    } else {
		// !!! will break when FRC starts accepting compressed types
		count = pUseMe->GetSize();
		ZeroMemory(pDst, count);
	    }
	    pUseMe->SetActualDataLength(count);

	    pUseMe->SetTime( (REFERENCE_TIME*)&trOutStart,
				(REFERENCE_TIME*)&trOutStop);
	    pUseMe->SetMediaType( NULL );
	    pUseMe->SetSyncPoint(TRUE);
	    pUseMe->SetPreroll( FALSE );
	    pUseMe->SetDiscontinuity(FALSE);

	    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("FRC: Deliver %d,%d Cur=%d"),
			(int)(trOutStart / 10000),
			(int)(trOutStop / 10000),
			(int)m_llOutputSampleCnt));

	    hr = OutputPin()->Deliver(pUseMe);

	    pUseMe->Release();

	    // uh - oh!  We're behind
    	    if (m_fJustLate) {
    		REFERENCE_TIME rt = m_qJustLate.Late;
		m_fJustLate = FALSE;
		if (rt > 0) {
		    LONGLONG llSkip = Time2Frame(rt, m_dOutputFrmRate) - 1;
            	    DbgLog((LOG_TRACE,2,TEXT("FRC: SKIP %d frames"),
							(int)llSkip));
		    m_llOutputSampleCnt += llSkip;
		}
    	    }
	} else {
	    hr = (nAvoid == 2) ? E_FAIL : S_OK;
	}

	if (hr != S_OK) {
	    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("FRC: Deliver failed")));
	    break;
	}

	// update frm cnt
	m_llOutputSampleCnt++;
    }

    // release our hack stuff
    if (m_pHackSample[0]) m_pHackSample[0]->Release();
    if (m_pHackSample[1]) m_pHackSample[1]->Release();
    m_pHackSample[0] = NULL;
    m_pHackSample[1] = NULL;
    m_nHackCur = 0;

    NextSegment(TRUE);
    // DON'T signal end of stream to the switch until ALL segments are done
    return S_OK;
}


HRESULT CFrmRateConverter::BeginFlush()
{
    // make sure Receive is not blocked
    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("FRC:BeginFlush")));
    HRESULT hr = S_OK;
    SafeSetEvent(m_hEventSeek);

    // don't flush the switch for our special seek that re-uses a source!
    if (!m_fSpecialSeek) {
        hr = CTransInPlaceFilter::BeginFlush();
    }

    CAutoLock foo(&m_csReceive);

    // flushing must reset this so that a real seek will kill a pending
    // segment seek, or else the segment seek will hang (won't flush the switch)
    // Must happen AFTER we know receive is done, and won't set this again
    m_fThreadCanSeek = FALSE;

    // if we get flushed without a seek having been made, that's a surprise.
    // It hopefully means the other chain of our shared source caused the seek
    if (m_fSeeking) {
	m_fFlushWithoutSeek = FALSE;
    } else {
	// wait for EndFlush to set m_fFlushWithoutSeek
    }

    return hr;
}


HRESULT CFrmRateConverter::EndFlush()
{

    // LIGOS sends bogus ones of these
    if (!m_pInput->IsFlushing())
        return S_OK;

    // wait until we're ready to accept data again.  block receive
    if (m_fSeeking) {
	m_rtLastSeek = m_rtNewLastSeek;	// time to update this before NewSeg
	m_nCurSeg = m_nSeekCurSeg; // NewSeg about to arrive needs this set
        SafeResetEvent(m_hEventSeek);
    } else {
	// This needs to be set before the NewSeg that's about to arrive after
	// the flush.  When sharing a source, we never have multiple segments
	m_nCurSeg = 0;	
	if (m_fFlushWithoutSeek) {
	    // If this is set, we've already seen a seek.  Now that the flush
	    // has arrived, we're done
    	    DbgLog((LOG_TRACE,2,TEXT("OK to proceed")));
	    m_fFlushWithoutSeek = FALSE;
	} else {
	    // We haven't seen a seek yet.  This is a surprise flush
    	    DbgLog((LOG_TRACE,2,TEXT("state=2. Wait for Seek")));
    	    SafeResetEvent(m_hEventSeek);
	    m_fFlushWithoutSeek = TRUE;
	}
    }

    m_fStopPushing = FALSE;	// OK to deliver to me again

    // If we got flushed without seeking, it probably means our shared source
    // got seeked by the other stream.  We'll get a seek later, and only then
    // can we resume delivering, or the switch won't be ready to receive the
    // new data yet.

    // don't flush the switch for our special seek that re-uses a source!
    if (!m_fSpecialSeek) {
        CTransInPlaceFilter::EndFlush();
    }
    return S_OK;
}


// Check the input type is OK - return an error otherwise

HRESULT CFrmRateConverter::CheckInputType(const CMediaType *pmt)
{
    if (!IsEqualGUID(*pmt->Type(), MEDIATYPE_Video))
    {
        return VFW_E_INVALIDMEDIATYPE;
    }


    // if user hasn't set a particular format, then accept it
    //
    if( !m_bMediaTypeSetByUser )
    {
        return NOERROR;
    }

    // !!! I can't seem to compare the whole format and ever succeed

    if( pmt->cbFormat < m_mtAccept.cbFormat )
    {
        return E_INVALIDARG;
    }


    if (!IsEqualGUID(*pmt->Subtype(), *m_mtAccept.Subtype()))
    {
        return VFW_E_INVALIDMEDIATYPE;
    }

    if (!IsEqualGUID(*pmt->FormatType(), *m_mtAccept.FormatType()))
    {
        return VFW_E_INVALIDMEDIATYPE;
    }

    // !!! I can't interpret anything but this right now
    if (!IsEqualGUID(*pmt->FormatType(), FORMAT_VideoInfo))
    {
        return VFW_E_INVALIDMEDIATYPE;
    }

    VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *) pmt->Format();
    LPBITMAPINFOHEADER lpbi = HEADER(pvi);
    LPBITMAPINFOHEADER lpbiAccept=HEADER((VIDEOINFOHEADER*)m_mtAccept.Format());

    if( lpbi->biBitCount != lpbiAccept->biBitCount )
    {
        return VFW_E_INVALIDMEDIATYPE;
    }

    if( lpbi->biHeight != lpbiAccept->biHeight ) {
        return VFW_E_INVALIDMEDIATYPE;
    }

    if( lpbi->biCompression != lpbiAccept->biCompression )
    {
	// the colour converter advertises 555 using BI_BITFIELDS!
	if (lpbi->biCompression == BI_BITFIELDS && lpbiAccept->biCompression ==
			BI_RGB && lpbi->biBitCount == 16) {
	    LPDWORD lp = (LPDWORD)(lpbi+1);
	    if (*lp==0x7c00 && *(lp+1)==0x03e0 && *(lp+2)==0x001f)
		return NOERROR;
	}
        return VFW_E_INVALIDMEDIATYPE;
    }

    return NOERROR;
}


CBasePin *CFrmRateConverter::GetPin(int n)
{
    HRESULT hr = S_OK;

    // Create an input pin if not already done

    if (m_pInput == NULL) {

	m_pInput = new CFrmRateConverterInputPin(
					NAME("FrmRateConverter input pin")
					, this        // Owner filter
					, &hr         // Result code
					, L"Input"    // Pin name
					);

	// Constructor can't fail
	ASSERT(SUCCEEDED(hr));
    }

    // Create an output pin if not already done

    if (m_pInput!=NULL && m_pOutput == NULL) {

	m_pOutput = new CFrmRateConverterOutputPin( NAME("FrmRateConverter output pin")
					      , this       // Owner filter
					      , &hr        // Result code
					      , L"Output"  // Pin name
					      );

	// a failed return code should delete the object

	ASSERT(SUCCEEDED(hr));
	if (m_pOutput == NULL) {
	    delete m_pInput;
	    m_pInput = NULL;
	}
    }

    // Return the appropriate pin

    ASSERT (n>=0 && n<=1);
    if (n == 0) {
	return m_pInput;
    } else if (n==1) {
	return m_pOutput;
    } else {
	return NULL;
    }

} // GetPin



// IPersistStream

// tell our clsid
//
STDMETHODIMP CFrmRateConverter::GetClassID(CLSID *pClsid)
{
    CheckPointer(pClsid, E_POINTER);
    *pClsid = CLSID_FrmRateConverter;
    return S_OK;
}

typedef struct _FRCSave {
    int version;
    double dFrmRate;
    int cTimes;
} FRCSave;

// persist ourself
//
HRESULT CFrmRateConverter::WriteToStream(IStream *pStream)
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("CFrmRateConverter::WriteToStream")));

    CheckPointer(pStream, E_POINTER);

    int savesize = sizeof(FRCSave) + m_cTimes * sizeof(FRCSKEW);
    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("Persisted data is %d bytes"), savesize));

    FRCSave *px = (FRCSave *)QzTaskMemAlloc(savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	return E_OUTOFMEMORY;
    }
    px->version = 1;
    px->dFrmRate = m_dOutputFrmRate;
    px->cTimes = m_cTimes;

    BYTE *pb;
    pb=(BYTE *)(px)+sizeof(FRCSave);
    if (m_cTimes) {
        CopyMemory(pb, m_pSkew, sizeof(FRCSKEW) * m_cTimes);
        pb += sizeof(FRCSKEW) * m_cTimes;
    }

    HRESULT hr = pStream->Write(px, savesize, 0);
    QzTaskMemFree(px);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** FRC: WriteToStream FAILED")));
        return hr;
    }
    return NOERROR;
}


// load ourself
//
HRESULT CFrmRateConverter::ReadFromStream(IStream *pStream)
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("FRC::ReadFromStream")));

    CheckPointer(pStream, E_POINTER);

    int savesize=sizeof(FRCSave);

    // we don't yet know how many saved connections there are
    // all we know we have for sure is the beginning of the struct
    FRCSave *px = (FRCSave *)QzTaskMemAlloc(savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	return E_OUTOFMEMORY;
    }

    HRESULT hr = pStream->Read(px, savesize, 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    put_OutputFrmRate(px->dFrmRate);

    // how much saved data was there, really?  Get the rest
    savesize += px->cTimes * sizeof(FRCSKEW);
    px = (FRCSave *)QzTaskMemRealloc(px, savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
        return E_OUTOFMEMORY;
    }

    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("Persisted data is %d bytes"), savesize));

    BYTE *pb;
    pb=(BYTE *)(px)+sizeof(FRCSave) ;
    hr = pStream->Read(pb, (savesize-sizeof(FRCSave)), 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    ClearStartStopSkew();
    for (int z=0; z<px->cTimes; z++) {
        FRCSKEW *pSkew = (FRCSKEW *)pb;
	REFERENCE_TIME rtStart = pSkew->rtMStart;
	REFERENCE_TIME rtStop = pSkew->rtMStop;
	REFERENCE_TIME rtSkew = pSkew->rtSkew;
	double dRate = pSkew->dRate;
        AddStartStopSkew(rtStart, rtStop, rtSkew, dRate);
	pb += sizeof(FRCSKEW);
    }

    QzTaskMemFree(px);
    SetDirty(FALSE);
    return S_OK;
}


// how big is our save data?
//
int CFrmRateConverter::SizeMax()
{
    return sizeof(FRCSave) + m_cTimes * 3 * sizeof(REFERENCE_TIME) +
			    m_cTimes * sizeof(double);
}



//
// IDexterSequencer implementation
//


//
// get_OutputFrmRate(double *PFS)
//
// Return the current FrmRateSpeed
STDMETHODIMP CFrmRateConverter::get_OutputFrmRate(double *dpFrmRate)
{
    CAutoLock cAutolock(&m_csFilter);
    CheckPointer(dpFrmRate,E_POINTER);
    *dpFrmRate = m_dOutputFrmRate;
    return NOERROR;
}


//
// put_OutputFrmRate
//
// A frame rate of 0 means do NOT do any frame rate conversion, just skewing
//
STDMETHODIMP CFrmRateConverter::put_OutputFrmRate(double dFrmRate)
{
    CAutoLock cAutolock(&m_csFilter);
    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;

    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("CFrmRate::put_OutputFrmRate to %d/10 fps"),
						(int)(dFrmRate * 10)));
    m_dOutputFrmRate = dFrmRate;
    SetDirty(TRUE);
    return NOERROR;
}


STDMETHODIMP CFrmRateConverter::ClearStartStopSkew()
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("CFrmRate::ClearStartStopSkew")));
    CAutoLock cAutolock(&m_csFilter);

    //can not change duration if our filter is not currently stopped
    if(!IsStopped() )
      return VFW_E_WRONG_STATE;

    if (m_pSkew)
	QzTaskMemFree(m_pSkew);
    m_pSkew= NULL;

    m_cTimes = 0;
    m_cMaxTimes = 0;
    SetDirty(TRUE);

    return NOERROR;
}

// add this skew sorted by timeline time into our list
//
STDMETHODIMP CFrmRateConverter::AddStartStopSkew(REFERENCE_TIME Start, REFERENCE_TIME Stop, REFERENCE_TIME Skew, double dRate)
{
    CAutoLock cAutolock(&m_csFilter);

    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("CFrmRate::ADD Start %d  Stop %d  Skew %d ms  Rate %d/100"),
				(int)(Start / 10000), (int)(Stop / 10000),
				(int)(Skew / 10000), (int)(dRate * 100)));

    //can not change times if our filter is not currently stopped
    if(!IsStopped() )
	return VFW_E_WRONG_STATE;

    if (m_cTimes == m_cMaxTimes) {
	m_cMaxTimes += 10;
	if (m_pSkew)
	    m_pSkew = (FRCSKEW *)QzTaskMemRealloc(m_pSkew,
					m_cMaxTimes * sizeof(FRCSKEW));
	else
	    m_pSkew = (FRCSKEW *)QzTaskMemAlloc(
					m_cMaxTimes * sizeof(FRCSKEW));
	if (m_pSkew == NULL) {
	    m_cMaxTimes = 0;
	    return E_OUTOFMEMORY;
	}
    }

    // if the rate is 0, then just set the last skew's stop time to
    // the one we're passing in
    //
    if( dRate == 0.0 )
    {
        // go look for the time we want to extend
        //
#ifdef DEBUG
        bool fHosed = true;
#endif
        for( int z = 0 ; z < m_cTimes ; z++ ) {
            REFERENCE_TIME rtLastTLStart = m_pSkew[z].rtTLStart;
            REFERENCE_TIME rtLastTLStop = m_pSkew[z].rtTLStop;

            if( AreTimesAndRateReallyClose( rtLastTLStop, Start + Skew,
                m_pSkew[z].rtMStop, Start, 0.0, 0.0, m_dOutputFrmRate ) )
            {
                m_pSkew[z].rtMStop += Stop - Start;
                m_pSkew[z].rtTLStop = m_pSkew[z].rtMStart + m_pSkew[z].rtSkew +
                    (REFERENCE_TIME)((m_pSkew[z].rtMStop - m_pSkew[z].rtMStart)
                                / m_pSkew[z].dRate);
                // the above math will have a rounding error, and rtTLStop won't
                // be frame aligned, so we better fix that
                LONGLONG ll = RoundTime2Frame(m_pSkew[z].rtTLStop, m_dOutputFrmRate);
                m_pSkew[z].rtTLStop = Frame2Time(ll, m_dOutputFrmRate);

#ifdef DEBUG
                fHosed = false;
#endif
                break;
            }
        }
#ifdef DEBUG
        if (fHosed) ASSERT(FALSE);  // we're dead
#endif
    }
    else
    {
        // merge it sorted by timeline time into the list
        //
        for (int z=0; z<m_cTimes; z++)
        {
	    if (Start + Skew < m_pSkew[z].rtTLStart)
            {
    	        for (int y = m_cTimes - 1; y >= z; y--)
                {
    		    m_pSkew[y + 1] = m_pSkew[y];
	        }
	        break;
	    }
        }

        m_pSkew[z].rtMStart = Start;
        m_pSkew[z].rtMStop = Stop;
        m_pSkew[z].rtSkew = Skew;
        m_pSkew[z].dRate = dRate;
        m_pSkew[z].rtTLStart = Start + Skew;
        m_pSkew[z].rtTLStop = Start + Skew +
                    (REFERENCE_TIME)((Stop - Start) / dRate);

        m_cTimes++;
    }

#if 0	// do this only if cleared and then re-added?
    // need to recalc last seek time if we were seeked and then this is changed
    // !!! sync with Seek command!
    if (m_rtLastSeek >= 0)
	m_rtLastSeek += (Skew - m_rtSkew);
#endif

    SetDirty(TRUE);
    return S_OK;
}


STDMETHODIMP CFrmRateConverter::GetStartStopSkewCount(int *pCount)
{
    CheckPointer(pCount, E_POINTER);
    *pCount = m_cTimes;
    return NOERROR;
}


STDMETHODIMP CFrmRateConverter::GetStartStopSkew(REFERENCE_TIME *pStart, REFERENCE_TIME *pStop, REFERENCE_TIME *pSkew, double *pdRate)
{
    CAutoLock cAutolock(&m_csFilter);

    CheckPointer(pStart,E_POINTER);
    CheckPointer(pStop,E_POINTER);
    CheckPointer(pSkew,E_POINTER);
    CheckPointer(pdRate,E_POINTER);

    for (int i = 0; i < m_cTimes; i++) {
        pStart[i] = m_pSkew[i].rtMStart;
        pStop[i] = m_pSkew[i].rtMStop;
        pSkew[i] = m_pSkew[i].rtSkew;
        pdRate[i] = m_pSkew[i].dRate;
    }

    return NOERROR;
}


STDMETHODIMP CFrmRateConverter::get_MediaType( AM_MEDIA_TYPE *pmt )
{
    CAutoLock cAutolock(&m_csFilter);
    CheckPointer(pmt, E_POINTER);
    if (!m_bMediaTypeSetByUser)
	return E_UNEXPECTED;
    CopyMediaType(pmt, &m_mtAccept);
    return S_OK;
}

STDMETHODIMP CFrmRateConverter::put_MediaType(const AM_MEDIA_TYPE *pmt)
{
    CAutoLock cAutolock(&m_csFilter);
    CheckPointer(pmt, E_POINTER);
    if (m_State != State_Stopped)
        return VFW_E_NOT_STOPPED;

    if (m_pInput && m_pInput->IsConnected())
        return VFW_E_ALREADY_CONNECTED;

    if (m_pOutput && m_pOutput->IsConnected())
        return VFW_E_ALREADY_CONNECTED;

    FreeMediaType(m_mtAccept);
    CopyMediaType(&m_mtAccept, pmt);
    SetDirty(TRUE);
    m_bMediaTypeSetByUser = true;
    return S_OK;
}


// --- ISpecifyPropertyPages ---

STDMETHODIMP CFrmRateConverter::GetPages (CAUUID *pPages)

  { // GetPages //

    pPages->cElems = 1;
    pPages->pElems = (GUID *)CoTaskMemAlloc(sizeof(GUID));

    if (pPages->pElems == NULL)
	return E_OUTOFMEMORY;

    *(pPages->pElems) = CLSID_FRCProp;

    return NOERROR;

  } // GetPages

//////////////////////////////////////////////////////////////////////////
//
// CFrmRateConverterOutputPin
//
//////////////////////////////////////////////////////////////////////////
CFrmRateConverterOutputPin::CFrmRateConverterOutputPin(TCHAR       *pObjectName,
		   CFrmRateConverter *pBaseFilter,
		   HRESULT     *phr,
		   LPCWSTR      pPinName)
    : CTransInPlaceOutputPin(pObjectName, pBaseFilter, phr, pPinName),
      m_pFrmRateConverter(pBaseFilter),
      m_pSkewPassThru(NULL)
{
    ASSERT(pBaseFilter);
    DbgLog((LOG_TRACE, TRACE_MEDIUM, TEXT("CFrmRateConverterOutputPin::CFrmRateConverterOutputPin()")));

}

CFrmRateConverterOutputPin::~CFrmRateConverterOutputPin()
{
    if( m_pSkewPassThru)
	delete m_pSkewPassThru;
    DbgLog((LOG_TRACE, TRACE_MEDIUM, TEXT("CFrmRateConverterOutputPin::~CFrmRateConverterOutputPin()")));
}

//
// NonDelegatingQueryInterface
//
STDMETHODIMP CFrmRateConverterOutputPin::NonDelegatingQueryInterface (REFIID riid, void ** ppv)
{
    CheckPointer(ppv,E_POINTER);
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    *ppv = NULL;

    if (riid == IID_IMediaSeeking ) {
	//
	// Create a seeking implementation
	//
	ASSERT(m_pFrmRateConverter->m_pInput != NULL);

	if (m_pSkewPassThru == NULL)
	{
	    HRESULT hr = S_OK;
	    m_pSkewPassThru = new  CSkewPassThru (NAME("Skew Pass Through"),
					GetOwner(),
					&hr,
				     (IPin *)m_pFrmRateConverter->m_pInput,
				     m_pFrmRateConverter);

	    if (FAILED(hr)) {
		return hr;
	    }
	}
	 return m_pSkewPassThru->NonDelegatingQueryInterface(riid, ppv);
    }
    else {
	return CTransInPlaceOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}



/* Receive notifications from our own input pin as to which allocator we
   are actually going to use.  Only call if we are connected downstream.
   Propagate the choice to any connected downstream input pin.
*/
HRESULT
CFrmRateConverterOutputPin::ReceiveAllocator(IMemAllocator * pAllocator, BOOL bReadOnly)
{
    ASSERT( IsConnected() );
    ALLOCATOR_PROPERTIES Props, Actual;

    // Overridden to allow read only pass through case, since we don't actually
    // touch any data, just the time stamps.

    // Propagate the allocator.
    // It's possible that the old and the new are the same thing.
    // AddRef before release ensures that we don't unload it.
    pAllocator->AddRef();
    if (m_pAllocator != NULL)
         m_pAllocator->Release();

    m_pAllocator = pAllocator;

    CFrmRateConverter *pTIPFilter = (CFrmRateConverter *)m_pTIPFilter;
    CFrmRateConverterInputPin *pIn = (CFrmRateConverterInputPin *)pTIPFilter->m_pInput;

#if 0
    if (m_pAllocator == pIn->m_pFakeAllocator) {
        DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("FRC:FAKE allocator passthru")));
        DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("give downstream its REAL allocator")));
	pAllocator = pIn->m_pAllocator;
    }
#endif

    // Propagate the allocator downstream
    return m_pInputPin->NotifyAllocator(pAllocator, bReadOnly);

} // receiveAllocator



// OVERRIDDEN because A->TIP->B won't work if B has special allocator
// requirements.  A->TIP uses a normal A allocator.  Then when connected to B,
// it's given to B who rejects it.  I need to see what B wants and fix A's
// allocator to provide it.
//
HRESULT
CFrmRateConverterOutputPin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    // Note that *ppAlloc is almost certainly identical to m_Allocator

    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("CFrmRateOut::DecideAllocator")));

    HRESULT hr = NOERROR;

    // If our input pin has an allocator and it's read/write then we use it.
    // Failing that we try to get one from downstream.
    *ppAlloc = NULL;

    bool fNeedToConfigureAllocator = false;

    CFrmRateConverter *pTIP = (CFrmRateConverter *)m_pTIPFilter;
    if (pTIP->InputPin()) {
        if (!pTIP->InputPin()->ReadOnly()) {
            *ppAlloc = pTIP->InputPin()->PeekAllocator();
        }
    }

    if (*ppAlloc!=NULL) {
        // don't need to configure allocator -- upstream filter has
        // already configured it
        (*ppAlloc)->AddRef();
    } else {
        hr = VFW_E_NO_ALLOCATOR;
        if ( IsConnected() ) {
            // Get an addreffed allocator from the downstream input pin.
            hr = m_pInputPin->GetAllocator( ppAlloc );
            fNeedToConfigureAllocator = true;
        }
    }


    if (*ppAlloc==NULL) {
        // Can't get one from upstream or downstream, so must use our own.

        hr = InitAllocator(ppAlloc);
        fNeedToConfigureAllocator = true;
    }

    if(FAILED(hr))
        return hr;

    ASSERT( *ppAlloc != NULL );

    if (fNeedToConfigureAllocator) {

        ALLOCATOR_PROPERTIES prop;
        ZeroMemory(&prop, sizeof(prop));

        // Try to get requirements from downstream
        pPin->GetAllocatorRequirements(&prop);

        // if he doesn't care about alignment, then set it to 1
        if (prop.cbAlign == 0) {
            prop.cbAlign = 1;
        }

        hr = DecideBufferSize(*ppAlloc, &prop);

        if (FAILED(hr)) {
            (*ppAlloc)->Release();
            *ppAlloc = NULL;
        }
    } else {
	// !!! OVERRIDE FOR THIS:

        ALLOCATOR_PROPERTIES b, a, c;
        pPin->GetAllocatorRequirements(&b);
        if (b.cbAlign == 0) {
            b.cbAlign = 1;
        }
	(*ppAlloc)->GetProperties(&a);
	if (b.cbAlign > a.cbAlign || b.cbPrefix > a.cbPrefix) {
    	    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("B needs a bigger allocator")));
	    a.cbPrefix = b.cbPrefix;
	    a.cbAlign = b.cbAlign;
	    hr = (*ppAlloc)->SetProperties(&a, &c);
	    if (FAILED(hr) || c.cbPrefix < a.cbPrefix || c.cbAlign < a.cbAlign){
		(*ppAlloc)->Release();
		*ppAlloc = NULL;
    		DbgLog((LOG_ERROR,1,TEXT("*ERROR: Can't fix A's allocator")));
		return hr;
	    }
    	    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("A's allocator successfully grown")));
	}
    }

    // Tell the downstream input pin
    // !!! OVERRIDE to fix this bug
    return pPin->NotifyAllocator(*ppAlloc, pTIP->InputPin()->ReadOnly());

} // DecideAllocator



//
// Notify
//
STDMETHODIMP CFrmRateConverterOutputPin::Notify(IBaseFilter *pSender, Quality q)
{
    // called in Receive.  Taking the filter lock will hang
    // CAutoLock lock_it(m_pLock);

    DbgLog((LOG_TRACE,1,TEXT("!!! FRC: Notify")));

    m_pFrmRateConverter->m_fJustLate = TRUE;
    m_pFrmRateConverter->m_qJustLate = q;

    // make the render keep trying to make up time, too
    return E_NOTIMPL;
}


CFrmRateConverterInputPin::CFrmRateConverterInputPin(TCHAR *pObjectName,
		   CFrmRateConverter *pBaseFilter,
		   HRESULT     *phr,
		   LPCWSTR      pPinName)
    : CTransInPlaceInputPin(pObjectName, pBaseFilter, phr, pPinName)
      // , m_pFakeAllocator(NULL)
{
    DbgLog((LOG_TRACE, TRACE_MEDIUM, TEXT("CFrmRateIn::CFrmRateIn")));
}

CFrmRateConverterInputPin::~CFrmRateConverterInputPin()
{
    DbgLog((LOG_TRACE, TRACE_MEDIUM, TEXT("CFrmRateIn::~CFrmRateIn")));
#if 0
    if (m_pFakeAllocator)
	m_pFakeAllocator->Release();
#endif
}


#if 0	// not necessary.  The switch is always the allocator for its output
	// pin connections.  Otherwise, this IS necessary

// !!! DecideAllocator could call downstream filter's GetAllocator too, and
// !!! give us trouble us?

// We need our own allocator to do something fancy
// with the time stamps in GetBuffer.  Since we change the time stamps after
// calling GetBuffer and before Deliver, and the big switcher expects them to
// be the same, we need to get fancy, or hang.
//
STDMETHODIMP CFrmRateConverterInputPin::GetAllocator(IMemAllocator ** ppAllocator)
{
    CheckPointer(ppAllocator,E_POINTER);
    ValidateReadWritePtr(ppAllocator,sizeof(IMemAllocator *));
    CAutoLock cObjectLock(m_pLock);
    CFrmRateConverter *pTIPFilter = (CFrmRateConverter *)m_pTIPFilter;

    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("CFrmRateIn:GetAllocator")));

    if ( pTIPFilter->m_pOutput->IsConnected() ){
	HRESULT hr = pTIPFilter->OutputPin()->ConnectedIMemInputPin()
					       ->GetAllocator( ppAllocator );
	if (SUCCEEDED(hr)) {
	    // the downstream GetAllocator will have done AddRef on it

	    if (m_pFakeAllocator == NULL) {
	        CFrmRateInputAllocator *pMemObject = new CFrmRateInputAllocator(
				NAME("Frame Rate input allocator"), NULL, &hr);
	        if (pMemObject == NULL) {
		    (*ppAllocator)->Release();
		    return E_OUTOFMEMORY;
	        }
	        if (FAILED(hr)) {
		    ASSERT(pMemObject);
		    delete pMemObject;
		    (*ppAllocator)->Release();
		    return hr;
	        }

	        /*  We AddRef() our own allocator */
		m_pFakeAllocator = pMemObject;
	        m_pFakeAllocator->m_pPin = this;
	        m_pFakeAllocator->AddRef();
	        m_pFakeAllocator->m_pRealAllocator = NULL;
	        DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("Created a FAKE Allocator")));
	    }

	    // Tell upstream pin to use our fake allocator.. we'll pass on
	    // requests to the downstream pin's allocator and intercept them
	    if (m_pFakeAllocator->m_pRealAllocator)
		m_pFakeAllocator->m_pRealAllocator->Release();
	    m_pFakeAllocator->m_pRealAllocator = *ppAllocator;
	    *ppAllocator = m_pFakeAllocator;
	    (*ppAllocator)->AddRef();
	    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("Returning the FAKE Allocator, will use the downstream one")));

	    return hr;
	}
	else {
	    *ppAllocator = pTIPFilter->OutputPin()->PeekAllocator();
	    (*ppAllocator)->AddRef();
	    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("CFrmRateIn:GetAllocator - Using NORMAL Allocator")));
	    return S_OK;
	}

    }

    return VFW_E_NO_ALLOCATOR;

} // GetAllocator

#endif


// I seem to need to override this but not change a thing or things don't work!
//
STDMETHODIMP CFrmRateConverterInputPin::NotifyAllocator(
    IMemAllocator * pAllocator,
    BOOL bReadOnly)
{
    HRESULT hr;
    CheckPointer(pAllocator,E_POINTER);
    ValidateReadPtr(pAllocator,sizeof(IMemAllocator));

    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("CFrmRateIn:NotifyAllocator")));

    m_bReadOnly = bReadOnly;

    CAutoLock cObjectLock(m_pLock);

    // It's possible that the old and the new are the same thing.
    // AddRef before release ensures that we don't unload it.
    pAllocator->AddRef();

    if( m_pAllocator != NULL )
        m_pAllocator->Release();

    m_pAllocator = pAllocator;    // We have an allocator for the input pin

//#ifdef DEBUG
#if 0
    if (m_pAllocator == m_pFakeAllocator)
        DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("Using the FAKE allocator")));
    else
        DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("Using a normal allocator")));
#endif

    // Propagate the decision downstream - do this always, even if it's
    // a read-only allocator.  The Receive function will take what it can.
    CFrmRateConverter *pTIPFilter = (CFrmRateConverter *)m_pTIPFilter;
    if (pTIPFilter->OutputPin()->IsConnected()) {
        hr = pTIPFilter->OutputPin()->ReceiveAllocator(pAllocator, bReadOnly);
        if (FAILED(hr)) {
            // The output connection would be messed up by this input connection
            // so refuse it!
            return hr;
        }
    }

    return NOERROR;

} // NotifyAllocator


#if 0

CFrmRateInputAllocator::CFrmRateInputAllocator(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) :
	CMemAllocator(pName, pUnk, phr),
	m_pRealAllocator(NULL),
	m_pBonusAllocator(NULL)
{
    // !!! *phr = CreateMemoryAllocator(&m_pBonusAllocator);
}


CFrmRateInputAllocator::~CFrmRateInputAllocator()
{
    //DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("Releasing the FAKE allocator")));
    m_pRealAllocator->Release();
    // !!! m_pBonusAllocator->Release();
}


// Receive will munge the time stamps.  Munge it NOW how it will be in Receive
//
// !!! Maybe receive won't be called after GetBuffer!!!
//
STDMETHODIMP CFrmRateInputAllocator::GetBuffer(IMediaSample **ppBuffer, REFERENCE_TIME *pStartTime,
				  REFERENCE_TIME *pEndTime, DWORD dwFlags)
{
    CFrmRateConverter *pFilter = (CFrmRateConverter *)(m_pPin->m_pFilter);

    // Don't let stop close this event before we start waiting on it
    {
        CAutoLock lck2(&m_csReceive);

        // Stop pushing data to me!
        if (m_pPin->m_bFlushing || pFilter->m_fStopPushing) {
	    return E_FAIL;
        }

        // make sure we're ready to accept data
        WaitForSingleObject(pFilter->m_hEventSeek, INFINITE);
    }

    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("FRC: FAKE GetBuffer called")));

    // we have nothing to do, we're all done
    if (pFilter->m_nCurSeg == pFilter->m_cTimes) {
	return E_FAIL;
    }

if (pFilter->m_dOutputFrmRate) {
    // Calculate the time stamps receive will put on this buffer EXACTLY THE
    // SAME WAY RECEIVE DOES!!!
    //
    REFERENCE_TIME trStart, trStop;
    LONGLONG llOffset;

    llOffset = Time2Frame( pFilter->m_rtNewSeg, pFilter->m_dOutputFrmRate );
    trStart = Frame2Time( pFilter->m_llOutputSampleCnt + llOffset, pFilter->m_dOutputFrmRate );

#if 0	// !!! this will fire, a source may send us data a little too early
        // I hope this won't mess up the switch; I don't think it will
    // A time stamp too early will not get delivered.  But is it bad to
    // call GetBuffer? We can't avoid it by returning E_FAIL!
    ASSERT(trStart >= pFilter->m_prtStart[pFilter->m_nCurSeg] +
				pFilter->m_prtSkew[pFilter->m_nCurSeg]);
#endif

    // !!! If I got this math wrong, I'm toast

    // if this time stamp is too late, avoid sending it and
    // calling GetBuffer or it will conflict with valid time stamps in
    // a different segment.

    // it this time stamp is too late, avoid sending it (!!! allows for rounding
    // error)
    BOOL fAvoid = FALSE;
    if (trStart + FUDGE >= pFilter->m_pSkew[pFilter->m_nCurSeg].rtTLStop) {
	fAvoid = TRUE;
    }

    if (fAvoid) {
        DbgLog((LOG_TRACE, TRACE_LOW, TEXT("FRC:AVOIDING GetBuffer, time=%d"),
					(int)(trStart / 10000)));
	// since we are failing the deliver, the source won't send EOS
	pFilter->EndOfStream();	// on to the next segment now
	// We can't trust sources to stop pushing
	pFilter->m_fStopPushing = TRUE;
	return E_FAIL; // !!!
    }

    trStart -= pFilter->m_rtNewSeg;
    trStop = Frame2Time( pFilter->m_llOutputSampleCnt + llOffset + 1,
						pFilter->m_dOutputFrmRate );
    trStop -= pFilter->m_rtNewSeg;

    // Now delegate
    return m_pRealAllocator->GetBuffer(ppBuffer, &trStart, &trStop, dwFlags);

// We're not altering time stamps, nothing special to do
} else {
    return m_pRealAllocator->GetBuffer(ppBuffer, pStartTime, pEndTime, dwFlags);
}
}

STDMETHODIMP CFrmRateInputAllocator::SetProperties(ALLOCATOR_PROPERTIES *pReq, ALLOCATOR_PROPERTIES *pAct)

{
    m_pRealAllocator->SetProperties(pReq, pAct);
    // !!! This needs enough buffers not to hang!
    // !!! m_pBonusAllocator->SetProperties(pReq, pAct);
    // do this so GetProperties doesn't need to be overridden
    return CMemAllocator::SetProperties(pReq, pAct);
}


STDMETHODIMP CFrmRateInputAllocator::Commit()
{
    HRESULT hr = m_pRealAllocator->Commit();
    //if (SUCCEEDED(hr))
	// !!! hr = m_pBonusAllocator->Commit();
    return hr;
}


STDMETHODIMP CFrmRateInputAllocator::Decommit()
{
    HRESULT hr = m_pRealAllocator->Decommit();
    //if (SUCCEEDED(hr))
	// !!! hr = m_pBonusAllocator->Decommit();
    return hr;
}

#endif




CFRCWorker::CFRCWorker()
{
}

HRESULT CFRCWorker::Create(CFrmRateConverter *pFRC)
{
    m_pFRC = pFRC;

    return CAMThread::Create();
}

HRESULT CFRCWorker::Run()
{
    return CallWorker(CMD_RUN);
}

HRESULT CFRCWorker::Stop()
{
    return CallWorker(CMD_STOP);
}

HRESULT CFRCWorker::Exit()
{
    return CallWorker(CMD_EXIT);
}



// called on the worker thread to do all the work. Thread exits when this
// function returns.
DWORD CFRCWorker::ThreadProc()
{
    BOOL bExit = FALSE;

#ifdef CHANGE_THREAD_PRIORITIES
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL);
#endif

    QzInitialize(NULL);

    while (!bExit) {

	Command cmd = GetRequest();

	switch (cmd) {

	case CMD_EXIT:
	    bExit = TRUE;
	    Reply(NOERROR);
	    break;

	case CMD_RUN:
	    Reply(NOERROR);
	    DoRunLoop();
	    break;

	case CMD_STOP:
	    Reply(NOERROR);
	    break;

	default:
	    Reply(E_NOTIMPL);
	    break;
	}
    }

    QzUninitialize();

    return NOERROR;
}

HRESULT CFRCWorker::DoRunLoop()
{
    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE, TRACE_MEDIUM, TEXT("FRC:entering worker thread")));

    while (1) {
	Command com;
	if (CheckRequest(&com)) {
	    if (com == CMD_STOP)
		break;
	}

	// no more blocking if we're waiting to get stopped
	if (!m_pFRC->m_fThreadMustDie) {
            WaitForSingleObject(m_pFRC->m_hEventThread, INFINITE);
	}

	// might have gotten set while we were blocked
	if (!m_pFRC->m_fThreadMustDie && m_pFRC->m_fThreadCanSeek) {
	    // !!! This might fail (SetRate fails) we'll just hang!
	    m_pFRC->SeekNextSegment();
	}
    }

    DbgLog((LOG_TRACE, TRACE_MEDIUM, TEXT("FRC:getting ready to leave worker thread")));

    return hr;
}

// helper functions until we can fix m_hEventSeek being set 

BOOL SafeSetEvent(HANDLE h)
{
    if(h != 0) {
        return SetEvent(h);
    }
    DbgLog((LOG_ERROR, 1, TEXT("setting null handle")));
    return TRUE;
}
        
BOOL SafeResetEvent(HANDLE h)
{
    if(h != 0) {
        return ResetEvent(h);
    }
    DbgLog((LOG_ERROR, 1, TEXT("resetting null handle")));
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\frc\resource.h ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#define IDD_FRAMECONVERSION 600
#define IDC_EDIT_RATE       609
#define IDC_EDIT_FRMRATE    610
#define IDC_EDIT_SKEW       611
#define IDC_EDIT_START      612
#define IDC_EDIT_STOP       613
#define IDS_FRCPROP_TITLE   620
#ifndef IDC_STATIC
#define IDC_STATIC          -1
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\frc\prop.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <windows.h>
#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "FRC.h"
#include "PThru.h"
#include "resource.h"

//////////////////////////////////////////////////////////////////////////
//
// CFrcPropertyPage
//
//////////////////////////////////////////////////////////////////////////

//
// CreateInstance
//
CUnknown *CFrcPropertyPage::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)

  { // CreateInstance //

    CUnknown *punk = new CFrcPropertyPage(lpunk, phr);

    if (NULL == punk)
	    *phr = E_OUTOFMEMORY;

    return punk;

  } // CreateInstance //

CFrcPropertyPage::CFrcPropertyPage(LPUNKNOWN pUnk, HRESULT *phr) : CBasePropertyPage(NAME("Frame Rate Converter Property Page"), pUnk, IDD_FRAMECONVERSION, IDS_FRCPROP_TITLE), m_pifrc(NULL), m_bInitialized(FALSE)

  { // Constructor //
  } // Constructor //

void CFrcPropertyPage::SetDirty()

  { // SetDirty //

      m_bDirty = TRUE;

      if (m_pPageSite)
	m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);

  } // SetDirty //

HRESULT CFrcPropertyPage::OnActivate (void)

  { // OnActivate //

    m_bInitialized = TRUE;

    return NOERROR;

  } // OnActivate //

HRESULT CFrcPropertyPage::OnDeactivate (void)

  { // OnDeactivate //

    m_bInitialized = FALSE;

    GetControlValues();

    return NOERROR;

  } // OnDeactivate //

INT_PTR CFrcPropertyPage::OnReceiveMessage (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)

  { // OnReceiveMessage //

    ASSERT(m_pifrc != NULL);

    switch(uMsg)

      { // Switch

	case WM_COMMAND:

	  if (!m_bInitialized)
	    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);

	  m_bDirty = TRUE;

	  if (m_pPageSite)
	    m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);

	  return TRUE;

        case WM_INITDIALOG:
          SetDlgItemInt(hwnd, IDC_EDIT_FRMRATE,(int)(m_dFrameRate * 100),FALSE);
          SetDlgItemInt(hwnd, IDC_EDIT_RATE,(int)(m_dRate * 100),FALSE);
          SetDlgItemInt(hwnd, IDC_EDIT_SKEW, (int)(m_rtSkew / 10000), TRUE);
          SetDlgItemInt(hwnd, IDC_EDIT_START, (int)(m_rtMediaStart / 10000),
									FALSE);
          SetDlgItemInt(hwnd, IDC_EDIT_STOP, (int)(m_rtMediaStop / 10000),
									FALSE);
          return TRUE;
          break;

	default:
	  return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
	  break;

      } // Switch

  } // OnReceiveMessage //

HRESULT CFrcPropertyPage::OnConnect (IUnknown *pUnknown)

  { // OnConnect //

    pUnknown->QueryInterface(IID_IDexterSequencer, (void **)&m_pifrc);

    ASSERT(m_pifrc != NULL);

    // Defaults from filter's current values (via IDexterSequencer)
    m_pifrc->get_OutputFrmRate(&m_dFrameRate);

    // !!! we only support one start/stop/skew in this prop page
    int c;
    m_pifrc->GetStartStopSkewCount(&c);

    REFERENCE_TIME *pStart = (REFERENCE_TIME *)QzTaskMemAlloc(c * 3 *
				sizeof(REFERENCE_TIME) + c * sizeof(double));
    if (pStart == NULL) {
	return E_OUTOFMEMORY;
    }
    REFERENCE_TIME *pStop = pStart + c;
    REFERENCE_TIME *pSkew = pStop + c;
    double *pRate = (double *)(pSkew + c);

    m_pifrc->GetStartStopSkew(pStart, pStop, pSkew, pRate);

    m_rtMediaStart = *pStart;
    m_rtMediaStop = *pStop;
    m_rtSkew = *pSkew;
    m_dRate = *pRate;

    m_bInitialized = FALSE;

    QzTaskMemFree(pStart);

    return NOERROR;

  } // OnConnect //

HRESULT CFrcPropertyPage::OnDisconnect()

  { // OnDisconnect //

    if (m_pifrc)

      { // Release

	m_pifrc->Release();
	m_pifrc = NULL;

      } // Release

    m_bInitialized = FALSE;

    return NOERROR;

  } // OnDisconnect //

HRESULT CFrcPropertyPage::OnApplyChanges()

  { // OnApplyChanges //

    ASSERT(m_pifrc != NULL);

    GetControlValues();

    // !!! we only support one start/stop/skew right now

    m_pifrc->put_OutputFrmRate(m_dFrameRate);
    m_pifrc->ClearStartStopSkew();
    m_pifrc->AddStartStopSkew(m_rtMediaStart, m_rtMediaStop, m_rtSkew, m_dRate);

    return NOERROR;

  } // OnApplyChanges //

void CFrcPropertyPage::GetControlValues (void)

  { // GetControlValues //

    int n;

    // Frame rate
    n = GetDlgItemInt(m_Dlg, IDC_EDIT_FRMRATE, NULL, FALSE);
    m_dFrameRate = (double)(n / 100.);

    // Playback rate
    n = GetDlgItemInt(m_Dlg, IDC_EDIT_RATE, NULL, FALSE);
    m_dRate = (double)(n / 100.);

    // Skew
    n = GetDlgItemInt(m_Dlg, IDC_EDIT_SKEW, NULL, TRUE);
    m_rtSkew = (REFERENCE_TIME)n * 10000;

    // Media times
    n = GetDlgItemInt(m_Dlg, IDC_EDIT_START, NULL, FALSE);
    m_rtMediaStart = (REFERENCE_TIME)n * 10000;
    n = GetDlgItemInt(m_Dlg, IDC_EDIT_STOP, NULL, FALSE);
    m_rtMediaStop = (REFERENCE_TIME)n * 10000;

  } // GetControlValues //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\frc\pthru.h ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
class CFrmRateConverter;

// {DBF8F620-53F0-11d2-9EE6-006008039E37}
DEFINE_GUID(CLSID_SkewPassThru, 
0xdbf8f620, 0x53f0, 0x11d2, 0x9e, 0xe6, 0x0, 0x60, 0x8, 0x3, 0x9e, 0x37);

class CSkewPassThru : public CPosPassThru
		    
{
    friend class CFrmRateConverter;
    friend class CFrmRateConverterOutputPin;

public:

    CSkewPassThru(const TCHAR *, LPUNKNOWN, HRESULT*, IPin *, CFrmRateConverter *pFrm);

    //only support IMediaSeeking
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    // IMediaSeeking methods
    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities ); 
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);	
    STDMETHODIMP GetTimeFormat(GUID *pFormat);		    
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);  
    STDMETHODIMP IsFormatSupported( const GUID * pFormat); 
    STDMETHODIMP QueryPreferredFormat( GUID *pFormat);	    
    
    STDMETHODIMP SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
                             , LONGLONG * pStop, DWORD StopFlags );

    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );
    STDMETHODIMP GetCurrentPosition( LONGLONG * pCurrent );
    STDMETHODIMP GetStopPosition( LONGLONG * pStop );
    STDMETHODIMP GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest );
    STDMETHODIMP GetPreroll( LONGLONG *pllPreroll ) { if( pllPreroll) *pllPreroll =0; return S_OK; };
    
    //methods we do not support
    STDMETHODIMP SetRate( double dRate)	    { return E_NOTIMPL; };
    // STDMETHODIMP GetRate( double * pdRate); //use the base class
    STDMETHODIMP ConvertTimeFormat(LONGLONG * pTarget, const GUID * pTargetFormat,
				   LONGLONG    Source, const GUID * pSourceFormat ){ return E_NOTIMPL ;};


private:
    
    // converts clip time to timeline time
    HRESULT FixTime(REFERENCE_TIME *prt, int nCurSeg);
    // converts timeline time to clip time
    int FixTimeBack(REFERENCE_TIME *prt, BOOL fRound);

    // allow CSkewPassThru access FrmRateConverter's m_rtSetStart, m_rtSetStop throught get_StartStop()
    CFrmRateConverter	*m_pFrm;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\gcache\gcacheman.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// gcacheman.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f gcachemanps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"

#ifdef FILTER_DLL

    #include <qeditint.h>
    #include <qedit.h>
    #include "qedit_i.c"
    #include "GrfCache.h"

    CComModule _Module;

    BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_GrfCache, CGrfCache)
    END_OBJECT_MAP()

    /////////////////////////////////////////////////////////////////////////////
    // DLL Entry Point

    extern "C"
    BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
    {
        if (dwReason == DLL_PROCESS_ATTACH)
        {
            _Module.Init(ObjectMap, hInstance);
            DisableThreadLibraryCalls(hInstance);
        }
        else if (dwReason == DLL_PROCESS_DETACH)
            _Module.Term();
        return TRUE;    // ok
    }

    /////////////////////////////////////////////////////////////////////////////
    // Used to determine whether the DLL can be unloaded by OLE

    STDAPI DllCanUnloadNow(void)
    {
        return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
    }

    /////////////////////////////////////////////////////////////////////////////
    // Returns a class factory to create an object of the requested type
    STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
    {
        return _Module.GetClassObject(rclsid, riid, ppv);
    }

    /////////////////////////////////////////////////////////////////////////////
    // DllRegisterServer - Adds entries to the system registry

    STDAPI DllRegisterServer(void)
    {
        return _Module.RegisterServer(TRUE);
    }

    /////////////////////////////////////////////////////////////////////////////
    // DllUnregisterServer - Removes entries from the system registry

    STDAPI DllUnregisterServer(void)
    {
        return _Module.UnregisterServer();
    }


#endif // #ifdef FILTER_DLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\gcache\stdafx.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef FILTER_DLL
    #ifdef _ATL_STATIC_REGISTRY
        #include <statreg.h>
        #include <statreg.cpp>
    #endif
    #include <atlimpl.cpp>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\idl\dexhelp.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
extern void DexterRemoveChain( IPin * pPin1, IPin * pPin2 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\gcache\resource.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by gcacheman.rc
//
#define IDR_GRFCACHE                    1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           1002
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\gcache\grfcache.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// GrfCache.h : Declaration of the CGrfCache

#ifndef __GRFCACHE_H_
#define __GRFCACHE_H_

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CGrfCache
class ATL_NO_VTABLE CGrfCache : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CGrfCache, &CLSID_GrfCache>,
    public IDispatchImpl<IGrfCache, &IID_IGrfCache, &LIBID_DexterLib>
{
    CComQIPtr< IGraphBuilder, &IID_IGraphBuilder > m_pGraph;

public:

    CGrfCache();
    ~CGrfCache();

DECLARE_REGISTRY_RESOURCEID(IDR_GRFCACHE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CGrfCache)
    COM_INTERFACE_ENTRY(IGrfCache)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IGrfCache
public:
    STDMETHOD(DoConnectionsNow)();
    STDMETHOD(SetGraph)(const IGraphBuilder * pGraph);
    STDMETHOD(ConnectPins)(IGrfCache * ChainNext, LONGLONG PinID1, const IPin * pPin1, LONGLONG PinID2, const IPin * pPin2);
    STDMETHOD(AddFilter)(IGrfCache * ChainNext, LONGLONG ID, const IBaseFilter * pFilter, LPCWSTR pName);
};

#endif //__GRFCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\gcache\stdafx.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__AE9472B5_B0C3_11D2_8D24_00A0C9441E20__INCLUDED_)
#define AFX_STDAFX_H__AE9472B5_B0C3_11D2_8D24_00A0C9441E20__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__AE9472B5_B0C3_11D2_8D24_00A0C9441E20__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\gcache\grfcache.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// GrfCache.cpp : Implementation of CGrfCache
#include "stdafx.h"
#include <qeditint.h>
#include <qedit.h>
#include "GrfCache.h"

/////////////////////////////////////////////////////////////////////////////
// CGrfCache

CGrfCache::CGrfCache( )
{
}

CGrfCache::~CGrfCache( )
{
}

STDMETHODIMP CGrfCache::AddFilter( IGrfCache * pChainNext, LONGLONG ID, const IBaseFilter * pFilter, LPCWSTR pName )
{
    // THIS cache manager doesn't chain anyone. We're the last in the chain.
    //
    if( pChainNext )
    {
        return E_INVALIDARG;
    }

    if( !m_pGraph )
    {
        return E_INVALIDARG;
    }

    HRESULT hr = 0;
    hr = m_pGraph->AddFilter( (IBaseFilter*) pFilter, pName );

    return hr;
}

STDMETHODIMP CGrfCache::ConnectPins( IGrfCache * pChainNext, LONGLONG PinID1, const IPin *pPin1, LONGLONG PinID2, const IPin *pPin2)
{
    // THIS cache manager doesn't chain anyone. We're the last in the chain.
    //
    if( pChainNext )
    {
        return E_INVALIDARG;
    }

    if( !m_pGraph )
    {
        return E_INVALIDARG;
    }

    HRESULT hr = 0;

    if( !pPin2 )
    {
        hr = m_pGraph->Render( (IPin*) pPin1 );
    }
    else
    {
        hr = m_pGraph->Connect( (IPin*) pPin1, (IPin*) pPin2 );
    }

    return hr;
}

STDMETHODIMP CGrfCache::SetGraph(const IGraphBuilder  *pGraph)
{
    m_pGraph.Release( );
    m_pGraph = (IGraphBuilder*) pGraph;

    return S_OK;
}

STDMETHODIMP CGrfCache::DoConnectionsNow()
{
	// TODO: Add your implementation code here

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\cderror.h ===
/*
 * cderror.h
 *
 * Copyright (C) 1994, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file defines the error and message codes for the cjpeg/djpeg
 * applications.  These strings are not needed as part of the JPEG library
 * proper.
 * Edit this file to add new codes, or to translate the message strings to
 * some other language.
 */

/*
 * To define the enum list of message codes, include this file without
 * defining macro JMESSAGE.  To create a message string table, include it
 * again with a suitable JMESSAGE definition (see jerror.c for an example).
 */
#ifndef JMESSAGE
#ifndef CDERROR_H
#define CDERROR_H
/* First time through, define the enum list */
#define JMAKE_ENUM_LIST
#else
/* Repeated inclusions of this file are no-ops unless JMESSAGE is defined */
#define JMESSAGE(code,string)
#endif /* CDERROR_H */
#endif /* JMESSAGE */

#ifdef JMAKE_ENUM_LIST

typedef enum {

#define JMESSAGE(code,string)	code ,

#endif /* JMAKE_ENUM_LIST */

JMESSAGE(JMSG_FIRSTADDONCODE=1000, NULL) /* Must be first entry! */

#ifdef BMP_SUPPORTED
JMESSAGE(JERR_BMP_BADCMAP, "Unsupported BMP colormap format")
JMESSAGE(JERR_BMP_BADDEPTH, "Only 8- and 24-bit BMP files are supported")
JMESSAGE(JERR_BMP_BADHEADER, "Invalid BMP file: bad header length")
JMESSAGE(JERR_BMP_BADPLANES, "Invalid BMP file: biPlanes not equal to 1")
JMESSAGE(JERR_BMP_COLORSPACE, "BMP output must be grayscale or RGB")
JMESSAGE(JERR_BMP_COMPRESSED, "Sorry, compressed BMPs not yet supported")
JMESSAGE(JERR_BMP_NOT, "Not a BMP file - does not start with BM")
JMESSAGE(JTRC_BMP, "%ux%u 24-bit BMP image")
JMESSAGE(JTRC_BMP_MAPPED, "%ux%u 8-bit colormapped BMP image")
JMESSAGE(JTRC_BMP_OS2, "%ux%u 24-bit OS2 BMP image")
JMESSAGE(JTRC_BMP_OS2_MAPPED, "%ux%u 8-bit colormapped OS2 BMP image")
#endif /* BMP_SUPPORTED */

#ifdef GIF_SUPPORTED
JMESSAGE(JERR_GIF_BUG, "GIF output got confused")
JMESSAGE(JERR_GIF_CODESIZE, "Bogus GIF codesize %d")
JMESSAGE(JERR_GIF_COLORSPACE, "GIF output must be grayscale or RGB")
JMESSAGE(JERR_GIF_IMAGENOTFOUND, "Too few images in GIF file")
JMESSAGE(JERR_GIF_NOT, "Not a GIF file")
JMESSAGE(JTRC_GIF, "%ux%ux%d GIF image")
JMESSAGE(JTRC_GIF_BADVERSION,
	 "Warning: unexpected GIF version number '%c%c%c'")
JMESSAGE(JTRC_GIF_EXTENSION, "Ignoring GIF extension block of type 0x%02x")
JMESSAGE(JTRC_GIF_NONSQUARE, "Caution: nonsquare pixels in input")
JMESSAGE(JWRN_GIF_BADDATA, "Corrupt data in GIF file")
JMESSAGE(JWRN_GIF_CHAR, "Bogus char 0x%02x in GIF file, ignoring")
JMESSAGE(JWRN_GIF_ENDCODE, "Premature end of GIF image")
JMESSAGE(JWRN_GIF_NOMOREDATA, "Ran out of GIF bits")
#endif /* GIF_SUPPORTED */

#ifdef PPM_SUPPORTED
JMESSAGE(JERR_PPM_COLORSPACE, "PPM output must be grayscale or RGB")
JMESSAGE(JERR_PPM_NONNUMERIC, "Nonnumeric data in PPM file")
JMESSAGE(JERR_PPM_NOT, "Not a PPM file")
JMESSAGE(JTRC_PGM, "%ux%u PGM image")
JMESSAGE(JTRC_PGM_TEXT, "%ux%u text PGM image")
JMESSAGE(JTRC_PPM, "%ux%u PPM image")
JMESSAGE(JTRC_PPM_TEXT, "%ux%u text PPM image")
#endif /* PPM_SUPPORTED */

#ifdef RLE_SUPPORTED
JMESSAGE(JERR_RLE_BADERROR, "Bogus error code from RLE library")
JMESSAGE(JERR_RLE_COLORSPACE, "RLE output must be grayscale or RGB")
JMESSAGE(JERR_RLE_DIMENSIONS, "Image dimensions (%ux%u) too large for RLE")
JMESSAGE(JERR_RLE_EMPTY, "Empty RLE file")
JMESSAGE(JERR_RLE_EOF, "Premature EOF in RLE header")
JMESSAGE(JERR_RLE_MEM, "Insufficient memory for RLE header")
JMESSAGE(JERR_RLE_NOT, "Not an RLE file")
JMESSAGE(JERR_RLE_TOOMANYCHANNELS, "Cannot handle %d output channels for RLE")
JMESSAGE(JERR_RLE_UNSUPPORTED, "Cannot handle this RLE setup")
JMESSAGE(JTRC_RLE, "%ux%u full-color RLE file")
JMESSAGE(JTRC_RLE_FULLMAP, "%ux%u full-color RLE file with map of length %d")
JMESSAGE(JTRC_RLE_GRAY, "%ux%u grayscale RLE file")
JMESSAGE(JTRC_RLE_MAPGRAY, "%ux%u grayscale RLE file with map of length %d")
JMESSAGE(JTRC_RLE_MAPPED, "%ux%u colormapped RLE file with map of length %d")
#endif /* RLE_SUPPORTED */

#ifdef TARGA_SUPPORTED
JMESSAGE(JERR_TGA_BADCMAP, "Unsupported Targa colormap format")
JMESSAGE(JERR_TGA_BADPARMS, "Invalid or unsupported Targa file")
JMESSAGE(JERR_TGA_COLORSPACE, "Targa output must be grayscale or RGB")
JMESSAGE(JTRC_TGA, "%ux%u RGB Targa image")
JMESSAGE(JTRC_TGA_GRAY, "%ux%u grayscale Targa image")
JMESSAGE(JTRC_TGA_MAPPED, "%ux%u colormapped Targa image")
#else
JMESSAGE(JERR_TGA_NOTCOMP, "Targa support was not compiled")
#endif /* TARGA_SUPPORTED */

JMESSAGE(JERR_BAD_CMAP_FILE,
	 "Color map file is invalid or of unsupported format")
JMESSAGE(JERR_TOO_MANY_COLORS,
	 "Output file format cannot handle %d colormap entries")
JMESSAGE(JERR_UNGETC_FAILED, "ungetc failed")
#ifdef TARGA_SUPPORTED
JMESSAGE(JERR_UNKNOWN_FORMAT,
	 "Unrecognized input file format --- perhaps you need -targa")
#else
JMESSAGE(JERR_UNKNOWN_FORMAT, "Unrecognized input file format")
#endif
JMESSAGE(JERR_UNSUPPORTED_FORMAT, "Unsupported output file format")

#ifdef JMAKE_ENUM_LIST

  JMSG_LASTADDONCODE
} ADDON_MESSAGE_CODE;

#undef JMAKE_ENUM_LIST
#endif /* JMAKE_ENUM_LIST */

/* Zap JMESSAGE macro so that future re-inclusions do nothing by default */
#undef JMESSAGE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\cdjpeg.h ===
/*
 * cdjpeg.h
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains common declarations for the sample applications
 * cjpeg and djpeg.  It is NOT used by the core JPEG library.
 */

#define JPEG_CJPEG_DJPEG	/* define proper options in jconfig.h */
#define JPEG_INTERNAL_OPTIONS	/* cjpeg.c,djpeg.c need to see xxx_SUPPORTED */
#include "jinclude.h"
#include "jpeglib.h"
#include "jerror.h"		/* get library error codes too */
#include "cderror.h"		/* get application-specific error codes */


/*
 * Object interface for cjpeg's source file decoding modules
 */

typedef struct cjpeg_source_struct * cjpeg_source_ptr;

struct cjpeg_source_struct {
  JMETHOD(void, start_input, (j_compress_ptr cinfo,
			      cjpeg_source_ptr sinfo));
  JMETHOD(JDIMENSION, get_pixel_rows, (j_compress_ptr cinfo,
				       cjpeg_source_ptr sinfo));
  JMETHOD(void, finish_input, (j_compress_ptr cinfo,
			       cjpeg_source_ptr sinfo));

  FILE *input_file;

  JSAMPARRAY buffer;
  JDIMENSION buffer_height;
};


/*
 * Object interface for djpeg's output file encoding modules
 */

typedef struct djpeg_dest_struct * djpeg_dest_ptr;

struct djpeg_dest_struct {
  /* start_output is called after jpeg_start_decompress finishes.
   * The color map will be ready at this time, if one is needed.
   */
  JMETHOD(void, start_output, (j_decompress_ptr cinfo,
			       djpeg_dest_ptr dinfo));
  /* Emit the specified number of pixel rows from the buffer. */
  JMETHOD(void, put_pixel_rows, (j_decompress_ptr cinfo,
				 djpeg_dest_ptr dinfo,
				 JDIMENSION rows_supplied));
  /* Finish up at the end of the image. */
  JMETHOD(void, finish_output, (j_decompress_ptr cinfo,
				djpeg_dest_ptr dinfo));

  /* Target file spec; filled in by djpeg.c after object is created. */
  FILE * output_file;

  /* Output pixel-row buffer.  Created by module init or start_output.
   * Width is cinfo->output_width * cinfo->output_components;
   * height is buffer_height.
   */
  JSAMPARRAY buffer;
  JDIMENSION buffer_height;
};


/*
 * cjpeg/djpeg may need to perform extra passes to convert to or from
 * the source/destination file format.  The JPEG library does not know
 * about these passes, but we'd like them to be counted by the progress
 * monitor.  We use an expanded progress monitor object to hold the
 * additional pass count.
 */

struct cdjpeg_progress_mgr {
  struct jpeg_progress_mgr pub;	/* fields known to JPEG library */
  int completed_extra_passes;	/* extra passes completed */
  int total_extra_passes;	/* total extra */
  /* last printed percentage stored here to avoid multiple printouts */
  int percent_done;
};

typedef struct cdjpeg_progress_mgr * cd_progress_ptr;


/* Short forms of external names for systems with brain-damaged linkers. */

#ifdef NEED_SHORT_EXTERNAL_NAMES
#define jinit_read_bmp		jIRdBMP
#define jinit_write_bmp		jIWrBMP
#define jinit_read_gif		jIRdGIF
#define jinit_write_gif		jIWrGIF
#define jinit_read_ppm		jIRdPPM
#define jinit_write_ppm		jIWrPPM
#define jinit_read_rle		jIRdRLE
#define jinit_write_rle		jIWrRLE
#define jinit_read_targa	jIRdTarga
#define jinit_write_targa	jIWrTarga
#define read_quant_tables	RdQTables
#define read_scan_script	RdScnScript
#define set_quant_slots		SetQSlots
#define set_sample_factors	SetSFacts
#define read_color_map		RdCMap
#define enable_signal_catcher	EnSigCatcher
#define start_progress_monitor	StProgMon
#define end_progress_monitor	EnProgMon
#define read_stdin		RdStdin
#define write_stdout		WrStdout
#endif /* NEED_SHORT_EXTERNAL_NAMES */

/* Module selection routines for I/O modules. */

EXTERN(cjpeg_source_ptr) jinit_read_bmp JPP((j_compress_ptr cinfo));
EXTERN(djpeg_dest_ptr) jinit_write_bmp JPP((j_decompress_ptr cinfo,
					    boolean is_os2));
EXTERN(cjpeg_source_ptr) jinit_read_gif JPP((j_compress_ptr cinfo));
EXTERN(djpeg_dest_ptr) jinit_write_gif JPP((j_decompress_ptr cinfo));
EXTERN(cjpeg_source_ptr) jinit_read_ppm JPP((j_compress_ptr cinfo));
EXTERN(djpeg_dest_ptr) jinit_write_ppm JPP((j_decompress_ptr cinfo));
EXTERN(cjpeg_source_ptr) jinit_read_rle JPP((j_compress_ptr cinfo));
EXTERN(djpeg_dest_ptr) jinit_write_rle JPP((j_decompress_ptr cinfo));
EXTERN(cjpeg_source_ptr) jinit_read_targa JPP((j_compress_ptr cinfo));
EXTERN(djpeg_dest_ptr) jinit_write_targa JPP((j_decompress_ptr cinfo));

/* cjpeg support routines (in rdswitch.c) */

EXTERN(boolean) read_quant_tables JPP((j_compress_ptr cinfo, char * filename,
				    int scale_factor, boolean force_baseline));
EXTERN(boolean) read_scan_script JPP((j_compress_ptr cinfo, char * filename));
EXTERN(boolean) set_quant_slots JPP((j_compress_ptr cinfo, char *arg));
EXTERN(boolean) set_sample_factors JPP((j_compress_ptr cinfo, char *arg));

/* djpeg support routines (in rdcolmap.c) */

EXTERN(void) read_color_map JPP((j_decompress_ptr cinfo, FILE * infile));

/* common support routines (in cdjpeg.c) */

EXTERN(void) enable_signal_catcher JPP((j_common_ptr cinfo));
EXTERN(void) start_progress_monitor JPP((j_common_ptr cinfo,
					 cd_progress_ptr progress));
EXTERN(void) end_progress_monitor JPP((j_common_ptr cinfo));
EXTERN(boolean) keymatch JPP((char * arg, const char * keyword, int minchars));
EXTERN(FILE *) read_stdin JPP((void));
EXTERN(FILE *) write_stdout JPP((void));

/* miscellaneous useful macros */

#ifdef DONT_USE_B_MODE		/* define mode parameters for fopen() */
#define READ_BINARY	"r"
#define WRITE_BINARY	"w"
#else
#define READ_BINARY	"rb"
#define WRITE_BINARY	"wb"
#endif

#ifndef EXIT_FAILURE		/* define exit() codes if not provided */
#define EXIT_FAILURE  1
#endif
#ifndef EXIT_SUCCESS
#ifdef VMS
#define EXIT_SUCCESS  1		/* VMS is very nonstandard */
#else
#define EXIT_SUCCESS  0
#endif
#endif
#ifndef EXIT_WARNING
#ifdef VMS
#define EXIT_WARNING  1		/* VMS is very nonstandard */
#else
#define EXIT_WARNING  2
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\example.c ===
/*
 * example.c
 *
 * This file illustrates how to use the IJG code as a subroutine library
 * to read or write JPEG image files.  You should look at this code in
 * conjunction with the documentation file libjpeg.doc.
 *
 * This code will not do anything useful as-is, but it may be helpful as a
 * skeleton for constructing routines that call the JPEG library.  
 *
 * We present these routines in the same coding style used in the JPEG code
 * (ANSI function definitions, etc); but you are of course free to code your
 * routines in a different style if you prefer.
 */

#include <stdio.h>

/*
 * Include file for users of JPEG library.
 * You will need to have included system headers that define at least
 * the typedefs FILE and size_t before you can include jpeglib.h.
 * (stdio.h is sufficient on ANSI-conforming systems.)
 * You may also wish to include "jerror.h".
 */

#include "jpeglib.h"

/*
 * <setjmp.h> is used for the optional error recovery mechanism shown in
 * the second part of the example.
 */

#include <setjmp.h>



/******************** JPEG COMPRESSION SAMPLE INTERFACE *******************/

/* This half of the example shows how to feed data into the JPEG compressor.
 * We present a minimal version that does not worry about refinements such
 * as error recovery (the JPEG code will just exit() if it gets an error).
 */


/*
 * IMAGE DATA FORMATS:
 *
 * The standard input image format is a rectangular array of pixels, with
 * each pixel having the same number of "component" values (color channels).
 * Each pixel row is an array of JSAMPLEs (which typically are unsigned chars).
 * If you are working with color data, then the color values for each pixel
 * must be adjacent in the row; for example, R,G,B,R,G,B,R,G,B,... for 24-bit
 * RGB color.
 *
 * For this example, we'll assume that this data structure matches the way
 * our application has stored the image in memory, so we can just pass a
 * pointer to our image buffer.  In particular, let's say that the image is
 * RGB color and is described by:
 */

extern JSAMPLE * image_buffer;	/* Points to large array of R,G,B-order data */
extern int image_height;	/* Number of rows in image */
extern int image_width;		/* Number of columns in image */


/*
 * Sample routine for JPEG compression.  We assume that the target file name
 * and a compression quality factor are passed in.
 */

GLOBAL(void)
write_JPEG_file (char * filename, int quality)
{
  /* This struct contains the JPEG compression parameters and pointers to
   * working space (which is allocated as needed by the JPEG library).
   * It is possible to have several such structures, representing multiple
   * compression/decompression processes, in existence at once.  We refer
   * to any one struct (and its associated working data) as a "JPEG object".
   */
  struct jpeg_compress_struct cinfo;
  /* This struct represents a JPEG error handler.  It is declared separately
   * because applications often want to supply a specialized error handler
   * (see the second half of this file for an example).  But here we just
   * take the easy way out and use the standard error handler, which will
   * print a message on stderr and call exit() if compression fails.
   * Note that this struct must live as long as the main JPEG parameter
   * struct, to avoid dangling-pointer problems.
   */
  struct jpeg_error_mgr jerr;
  /* More stuff */
  FILE * outfile;		/* target file */
  JSAMPROW row_pointer[1];	/* pointer to JSAMPLE row[s] */
  int row_stride;		/* physical row width in image buffer */

  /* Step 1: allocate and initialize JPEG compression object */

  /* We have to set up the error handler first, in case the initialization
   * step fails.  (Unlikely, but it could happen if you are out of memory.)
   * This routine fills in the contents of struct jerr, and returns jerr's
   * address which we place into the link field in cinfo.
   */
  cinfo.err = jpeg_std_error(&jerr);
  /* Now we can initialize the JPEG compression object. */
  jpeg_create_compress(&cinfo);

  /* Step 2: specify data destination (eg, a file) */
  /* Note: steps 2 and 3 can be done in either order. */

  /* Here we use the library-supplied code to send compressed data to a
   * stdio stream.  You can also write your own code to do something else.
   * VERY IMPORTANT: use "b" option to fopen() if you are on a machine that
   * requires it in order to write binary files.
   */
  if ((outfile = fopen(filename, "wb")) == NULL) {
    fprintf(stderr, "can't open %s\n", filename);
    exit(1);
  }
  jpeg_stdio_dest(&cinfo, outfile);

  /* Step 3: set parameters for compression */

  /* First we supply a description of the input image.
   * Four fields of the cinfo struct must be filled in:
   */
  cinfo.image_width = image_width; 	/* image width and height, in pixels */
  cinfo.image_height = image_height;
  cinfo.input_components = 3;		/* # of color components per pixel */
  cinfo.in_color_space = JCS_RGB; 	/* colorspace of input image */
  /* Now use the library's routine to set default compression parameters.
   * (You must set at least cinfo.in_color_space before calling this,
   * since the defaults depend on the source color space.)
   */
  jpeg_set_defaults(&cinfo);
  /* Now you can set any non-default parameters you wish to.
   * Here we just illustrate the use of quality (quantization table) scaling:
   */
  jpeg_set_quality(&cinfo, quality, TRUE /* limit to baseline-JPEG values */);

  /* Step 4: Start compressor */

  /* TRUE ensures that we will write a complete interchange-JPEG file.
   * Pass TRUE unless you are very sure of what you're doing.
   */
  jpeg_start_compress(&cinfo, TRUE);

  /* Step 5: while (scan lines remain to be written) */
  /*           jpeg_write_scanlines(...); */

  /* Here we use the library's state variable cinfo.next_scanline as the
   * loop counter, so that we don't have to keep track ourselves.
   * To keep things simple, we pass one scanline per call; you can pass
   * more if you wish, though.
   */
  row_stride = image_width * 3;	/* JSAMPLEs per row in image_buffer */

  while (cinfo.next_scanline < cinfo.image_height) {
    /* jpeg_write_scanlines expects an array of pointers to scanlines.
     * Here the array is only one element long, but you could pass
     * more than one scanline at a time if that's more convenient.
     */
    row_pointer[0] = & image_buffer[cinfo.next_scanline * row_stride];
    (void) jpeg_write_scanlines(&cinfo, row_pointer, 1);
  }

  /* Step 6: Finish compression */

  jpeg_finish_compress(&cinfo);
  /* After finish_compress, we can close the output file. */
  fclose(outfile);

  /* Step 7: release JPEG compression object */

  /* This is an important step since it will release a good deal of memory. */
  jpeg_destroy_compress(&cinfo);

  /* And we're done! */
}


/*
 * SOME FINE POINTS:
 *
 * In the above loop, we ignored the return value of jpeg_write_scanlines,
 * which is the number of scanlines actually written.  We could get away
 * with this because we were only relying on the value of cinfo.next_scanline,
 * which will be incremented correctly.  If you maintain additional loop
 * variables then you should be careful to increment them properly.
 * Actually, for output to a stdio stream you needn't worry, because
 * then jpeg_write_scanlines will write all the lines passed (or else exit
 * with a fatal error).  Partial writes can only occur if you use a data
 * destination module that can demand suspension of the compressor.
 * (If you don't know what that's for, you don't need it.)
 *
 * If the compressor requires full-image buffers (for entropy-coding
 * optimization or a multi-scan JPEG file), it will create temporary
 * files for anything that doesn't fit within the maximum-memory setting.
 * (Note that temp files are NOT needed if you use the default parameters.)
 * On some systems you may need to set up a signal handler to ensure that
 * temporary files are deleted if the program is interrupted.  See libjpeg.doc.
 *
 * Scanlines MUST be supplied in top-to-bottom order if you want your JPEG
 * files to be compatible with everyone else's.  If you cannot readily read
 * your data in that order, you'll need an intermediate array to hold the
 * image.  See rdtarga.c or rdbmp.c for examples of handling bottom-to-top
 * source data using the JPEG code's internal virtual-array mechanisms.
 */



/******************** JPEG DECOMPRESSION SAMPLE INTERFACE *******************/

/* This half of the example shows how to read data from the JPEG decompressor.
 * It's a bit more refined than the above, in that we show:
 *   (a) how to modify the JPEG library's standard error-reporting behavior;
 *   (b) how to allocate workspace using the library's memory manager.
 *
 * Just to make this example a little different from the first one, we'll
 * assume that we do not intend to put the whole image into an in-memory
 * buffer, but to send it line-by-line someplace else.  We need a one-
 * scanline-high JSAMPLE array as a work buffer, and we will let the JPEG
 * memory manager allocate it for us.  This approach is actually quite useful
 * because we don't need to remember to deallocate the buffer separately: it
 * will go away automatically when the JPEG object is cleaned up.
 */


/*
 * ERROR HANDLING:
 *
 * The JPEG library's standard error handler (jerror.c) is divided into
 * several "methods" which you can override individually.  This lets you
 * adjust the behavior without duplicating a lot of code, which you might
 * have to update with each future release.
 *
 * Our example here shows how to override the "error_exit" method so that
 * control is returned to the library's caller when a fatal error occurs,
 * rather than calling exit() as the standard error_exit method does.
 *
 * We use C's setjmp/longjmp facility to return control.  This means that the
 * routine which calls the JPEG library must first execute a setjmp() call to
 * establish the return point.  We want the replacement error_exit to do a
 * longjmp().  But we need to make the setjmp buffer accessible to the
 * error_exit routine.  To do this, we make a private extension of the
 * standard JPEG error handler object.  (If we were using C++, we'd say we
 * were making a subclass of the regular error handler.)
 *
 * Here's the extended error handler struct:
 */

struct my_error_mgr {
  struct jpeg_error_mgr pub;	/* "public" fields */

  jmp_buf setjmp_buffer;	/* for return to caller */
};

typedef struct my_error_mgr * my_error_ptr;

/*
 * Here's the routine that will replace the standard error_exit method:
 */

METHODDEF(void)
my_error_exit (j_common_ptr cinfo)
{
  /* cinfo->err really points to a my_error_mgr struct, so coerce pointer */
  my_error_ptr myerr = (my_error_ptr) cinfo->err;

  /* Always display the message. */
  /* We could postpone this until after returning, if we chose. */
  (*cinfo->err->output_message) (cinfo);

  /* Return control to the setjmp point */
  longjmp(myerr->setjmp_buffer, 1);
}


/*
 * Sample routine for JPEG decompression.  We assume that the source file name
 * is passed in.  We want to return 1 on success, 0 on error.
 */


GLOBAL(int)
read_JPEG_file (char * filename)
{
  /* This struct contains the JPEG decompression parameters and pointers to
   * working space (which is allocated as needed by the JPEG library).
   */
  struct jpeg_decompress_struct cinfo;
  /* We use our private extension JPEG error handler.
   * Note that this struct must live as long as the main JPEG parameter
   * struct, to avoid dangling-pointer problems.
   */
  struct my_error_mgr jerr;
  /* More stuff */
  FILE * infile;		/* source file */
  JSAMPARRAY buffer;		/* Output row buffer */
  int row_stride;		/* physical row width in output buffer */

  /* In this example we want to open the input file before doing anything else,
   * so that the setjmp() error recovery below can assume the file is open.
   * VERY IMPORTANT: use "b" option to fopen() if you are on a machine that
   * requires it in order to read binary files.
   */

  if ((infile = fopen(filename, "rb")) == NULL) {
    fprintf(stderr, "can't open %s\n", filename);
    return 0;
  }

  /* Step 1: allocate and initialize JPEG decompression object */

  /* We set up the normal JPEG error routines, then override error_exit. */
  cinfo.err = jpeg_std_error(&jerr.pub);
  jerr.pub.error_exit = my_error_exit;
  /* Establish the setjmp return context for my_error_exit to use. */
  if (setjmp(jerr.setjmp_buffer)) {
    /* If we get here, the JPEG code has signaled an error.
     * We need to clean up the JPEG object, close the input file, and return.
     */
    jpeg_destroy_decompress(&cinfo);
    fclose(infile);
    return 0;
  }
  /* Now we can initialize the JPEG decompression object. */
  jpeg_create_decompress(&cinfo);

  /* Step 2: specify data source (eg, a file) */

  jpeg_stdio_src(&cinfo, infile);

  /* Step 3: read file parameters with jpeg_read_header() */

  (void) jpeg_read_header(&cinfo, TRUE);
  /* We can ignore the return value from jpeg_read_header since
   *   (a) suspension is not possible with the stdio data source, and
   *   (b) we passed TRUE to reject a tables-only JPEG file as an error.
   * See libjpeg.doc for more info.
   */

  /* Step 4: set parameters for decompression */

  /* In this example, we don't need to change any of the defaults set by
   * jpeg_read_header(), so we do nothing here.
   */

  /* Step 5: Start decompressor */

  (void) jpeg_start_decompress(&cinfo);
  /* We can ignore the return value since suspension is not possible
   * with the stdio data source.
   */

  /* We may need to do some setup of our own at this point before reading
   * the data.  After jpeg_start_decompress() we have the correct scaled
   * output image dimensions available, as well as the output colormap
   * if we asked for color quantization.
   * In this example, we need to make an output work buffer of the right size.
   */ 
  /* JSAMPLEs per row in output buffer */
  row_stride = cinfo.output_width * cinfo.output_components;
  /* Make a one-row-high sample array that will go away when done with image */
  buffer = (*cinfo.mem->alloc_sarray)
		((j_common_ptr) &cinfo, JPOOL_IMAGE, row_stride, 1);

  /* Step 6: while (scan lines remain to be read) */
  /*           jpeg_read_scanlines(...); */

  /* Here we use the library's state variable cinfo.output_scanline as the
   * loop counter, so that we don't have to keep track ourselves.
   */
  while (cinfo.output_scanline < cinfo.output_height) {
    /* jpeg_read_scanlines expects an array of pointers to scanlines.
     * Here the array is only one element long, but you could ask for
     * more than one scanline at a time if that's more convenient.
     */
    (void) jpeg_read_scanlines(&cinfo, buffer, 1);
    /* Assume put_scanline_someplace wants a pointer and sample count. */
    put_scanline_someplace(buffer[0], row_stride);
  }

  /* Step 7: Finish decompression */

  (void) jpeg_finish_decompress(&cinfo);
  /* We can ignore the return value since suspension is not possible
   * with the stdio data source.
   */

  /* Step 8: Release JPEG decompression object */

  /* This is an important step since it will release a good deal of memory. */
  jpeg_destroy_decompress(&cinfo);

  /* After finish_decompress, we can close the input file.
   * Here we postpone it until after no more JPEG errors are possible,
   * so as to simplify the setjmp error logic above.  (Actually, I don't
   * think that jpeg_destroy can do an error exit, but why assume anything...)
   */
  fclose(infile);

  /* At this point you may want to check to see whether any corrupt-data
   * warnings occurred (test whether jerr.pub.num_warnings is nonzero).
   */

  /* And we're done! */
  return 1;
}


/*
 * SOME FINE POINTS:
 *
 * In the above code, we ignored the return value of jpeg_read_scanlines,
 * which is the number of scanlines actually read.  We could get away with
 * this because we asked for only one line at a time and we weren't using
 * a suspending data source.  See libjpeg.doc for more info.
 *
 * We cheated a bit by calling alloc_sarray() after jpeg_start_decompress();
 * we should have done it beforehand to ensure that the space would be
 * counted against the JPEG max_memory setting.  In some systems the above
 * code would risk an out-of-memory error.  However, in general we don't
 * know the output image dimensions before jpeg_start_decompress(), unless we
 * call jpeg_calc_output_dimensions().  See libjpeg.doc for more about this.
 *
 * Scanlines are returned in the same order as they appear in the JPEG file,
 * which is standardly top-to-bottom.  If you must emit data bottom-to-top,
 * you can use one of the virtual arrays provided by the JPEG memory manager
 * to invert the data.  See wrbmp.c for an example.
 *
 * As with compression, some operating modes may require temporary files.
 * On some systems you may need to set up a signal handler to ensure that
 * temporary files are deleted if the program is interrupted.  See libjpeg.doc.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\djpeg.c ===
/*
 * djpeg.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains a command-line user interface for the JPEG decompressor.
 * It should work on any system with Unix- or MS-DOS-style command lines.
 *
 * Two different command line styles are permitted, depending on the
 * compile-time switch TWO_FILE_COMMANDLINE:
 *	djpeg [options]  inputfile outputfile
 *	djpeg [options]  [inputfile]
 * In the second style, output is always to standard output, which you'd
 * normally redirect to a file or pipe to some other program.  Input is
 * either from a named file or from standard input (typically redirected).
 * The second style is convenient on Unix but is unhelpful on systems that
 * don't support pipes.  Also, you MUST use the first style if your system
 * doesn't do binary I/O to stdin/stdout.
 * To simplify script writing, the "-outfile" switch is provided.  The syntax
 *	djpeg [options]  -outfile outputfile  inputfile
 * works regardless of which command line style is used.
 */

#include "cdjpeg.h"		/* Common decls for cjpeg/djpeg applications */
#include "jversion.h"		/* for version message */

#include <ctype.h>		/* to declare isprint() */

#ifdef USE_CCOMMAND		/* command-line reader for Macintosh */
#ifdef __MWERKS__
#include <SIOUX.h>              /* Metrowerks needs this */
#include <console.h>		/* ... and this */
#endif
#ifdef THINK_C
#include <console.h>		/* Think declares it here */
#endif
#endif


/* Create the add-on message string table. */

#define JMESSAGE(code,string)	string ,

static const char * const cdjpeg_message_table[] = {
#include "cderror.h"
  NULL
};


/*
 * This list defines the known output image formats
 * (not all of which need be supported by a given version).
 * You can change the default output format by defining DEFAULT_FMT;
 * indeed, you had better do so if you undefine PPM_SUPPORTED.
 */

typedef enum {
	FMT_BMP,		/* BMP format (Windows flavor) */
	FMT_GIF,		/* GIF format */
	FMT_OS2,		/* BMP format (OS/2 flavor) */
	FMT_PPM,		/* PPM/PGM (PBMPLUS formats) */
	FMT_RLE,		/* RLE format */
	FMT_TARGA,		/* Targa format */
	FMT_TIFF		/* TIFF format */
} IMAGE_FORMATS;

#ifndef DEFAULT_FMT		/* so can override from CFLAGS in Makefile */
#define DEFAULT_FMT	FMT_PPM
#endif

static IMAGE_FORMATS requested_fmt;


/*
 * Argument-parsing code.
 * The switch parser is designed to be useful with DOS-style command line
 * syntax, ie, intermixed switches and file names, where only the switches
 * to the left of a given file name affect processing of that file.
 * The main program in this file doesn't actually use this capability...
 */


static const char * progname;	/* program name for error messages */
static char * outfilename;	/* for -outfile switch */


LOCAL(void)
usage (void)
/* complain about bad command line */
{
  fprintf(stderr, "usage: %s [switches] ", progname);
#ifdef TWO_FILE_COMMANDLINE
  fprintf(stderr, "inputfile outputfile\n");
#else
  fprintf(stderr, "[inputfile]\n");
#endif

  fprintf(stderr, "Switches (names may be abbreviated):\n");
  fprintf(stderr, "  -colors N      Reduce image to no more than N colors\n");
  fprintf(stderr, "  -fast          Fast, low-quality processing\n");
  fprintf(stderr, "  -grayscale     Force grayscale output\n");
#ifdef IDCT_SCALING_SUPPORTED
  fprintf(stderr, "  -scale M/N     Scale output image by fraction M/N, eg, 1/8\n");
#endif
#ifdef BMP_SUPPORTED
  fprintf(stderr, "  -bmp           Select BMP output format (Windows style)%s\n",
	  (DEFAULT_FMT == FMT_BMP ? " (default)" : ""));
#endif
#ifdef GIF_SUPPORTED
  fprintf(stderr, "  -gif           Select GIF output format%s\n",
	  (DEFAULT_FMT == FMT_GIF ? " (default)" : ""));
#endif
#ifdef BMP_SUPPORTED
  fprintf(stderr, "  -os2           Select BMP output format (OS/2 style)%s\n",
	  (DEFAULT_FMT == FMT_OS2 ? " (default)" : ""));
#endif
#ifdef PPM_SUPPORTED
  fprintf(stderr, "  -pnm           Select PBMPLUS (PPM/PGM) output format%s\n",
	  (DEFAULT_FMT == FMT_PPM ? " (default)" : ""));
#endif
#ifdef RLE_SUPPORTED
  fprintf(stderr, "  -rle           Select Utah RLE output format%s\n",
	  (DEFAULT_FMT == FMT_RLE ? " (default)" : ""));
#endif
#ifdef TARGA_SUPPORTED
  fprintf(stderr, "  -targa         Select Targa output format%s\n",
	  (DEFAULT_FMT == FMT_TARGA ? " (default)" : ""));
#endif
  fprintf(stderr, "Switches for advanced users:\n");
#ifdef DCT_ISLOW_SUPPORTED
  fprintf(stderr, "  -dct int       Use integer DCT method%s\n",
	  (JDCT_DEFAULT == JDCT_ISLOW ? " (default)" : ""));
#endif
#ifdef DCT_IFAST_SUPPORTED
  fprintf(stderr, "  -dct fast      Use fast integer DCT (less accurate)%s\n",
	  (JDCT_DEFAULT == JDCT_IFAST ? " (default)" : ""));
#endif
#ifdef DCT_FLOAT_SUPPORTED
  fprintf(stderr, "  -dct float     Use floating-point DCT method%s\n",
	  (JDCT_DEFAULT == JDCT_FLOAT ? " (default)" : ""));
#endif
  fprintf(stderr, "  -dither fs     Use F-S dithering (default)\n");
  fprintf(stderr, "  -dither none   Don't use dithering in quantization\n");
  fprintf(stderr, "  -dither ordered  Use ordered dither (medium speed, quality)\n");
#ifdef QUANT_2PASS_SUPPORTED
  fprintf(stderr, "  -map FILE      Map to colors used in named image file\n");
#endif
  fprintf(stderr, "  -nosmooth      Don't use high-quality upsampling\n");
#ifdef QUANT_1PASS_SUPPORTED
  fprintf(stderr, "  -onepass       Use 1-pass quantization (fast, low quality)\n");
#endif
  fprintf(stderr, "  -maxmemory N   Maximum memory to use (in kbytes)\n");
  fprintf(stderr, "  -outfile name  Specify name for output file\n");
  fprintf(stderr, "  -verbose  or  -debug   Emit debug output\n");
  exit(EXIT_FAILURE);
}


LOCAL(int)
parse_switches (j_decompress_ptr cinfo, int argc, char **argv,
		int last_file_arg_seen, boolean for_real)
/* Parse optional switches.
 * Returns argv[] index of first file-name argument (== argc if none).
 * Any file names with indexes <= last_file_arg_seen are ignored;
 * they have presumably been processed in a previous iteration.
 * (Pass 0 for last_file_arg_seen on the first or only iteration.)
 * for_real is FALSE on the first (dummy) pass; we may skip any expensive
 * processing.
 */
{
  int argn;
  char * arg;

  /* Set up default JPEG parameters. */
  requested_fmt = DEFAULT_FMT;	/* set default output file format */
  outfilename = NULL;
  cinfo->err->trace_level = 0;

  /* Scan command line options, adjust parameters */

  for (argn = 1; argn < argc; argn++) {
    arg = argv[argn];
    if (*arg != '-') {
      /* Not a switch, must be a file name argument */
      if (argn <= last_file_arg_seen) {
	outfilename = NULL;	/* -outfile applies to just one input file */
	continue;		/* ignore this name if previously processed */
      }
      break;			/* else done parsing switches */
    }
    arg++;			/* advance past switch marker character */

    if (keymatch(arg, "bmp", 1)) {
      /* BMP output format. */
      requested_fmt = FMT_BMP;

    } else if (keymatch(arg, "colors", 1) || keymatch(arg, "colours", 1) ||
	       keymatch(arg, "quantize", 1) || keymatch(arg, "quantise", 1)) {
      /* Do color quantization. */
      int val;

      if (++argn >= argc)	/* advance to next argument */
	usage();
      if (sscanf(argv[argn], "%d", &val) != 1)
	usage();
      cinfo->desired_number_of_colors = val;
      cinfo->quantize_colors = TRUE;

    } else if (keymatch(arg, "dct", 2)) {
      /* Select IDCT algorithm. */
      if (++argn >= argc)	/* advance to next argument */
	usage();
      if (keymatch(argv[argn], "int", 1)) {
	cinfo->dct_method = JDCT_ISLOW;
      } else if (keymatch(argv[argn], "fast", 2)) {
	cinfo->dct_method = JDCT_IFAST;
      } else if (keymatch(argv[argn], "float", 2)) {
	cinfo->dct_method = JDCT_FLOAT;
      } else
	usage();

    } else if (keymatch(arg, "dither", 2)) {
      /* Select dithering algorithm. */
      if (++argn >= argc)	/* advance to next argument */
	usage();
      if (keymatch(argv[argn], "fs", 2)) {
	cinfo->dither_mode = JDITHER_FS;
      } else if (keymatch(argv[argn], "none", 2)) {
	cinfo->dither_mode = JDITHER_NONE;
      } else if (keymatch(argv[argn], "ordered", 2)) {
	cinfo->dither_mode = JDITHER_ORDERED;
      } else
	usage();

    } else if (keymatch(arg, "debug", 1) || keymatch(arg, "verbose", 1)) {
      /* Enable debug printouts. */
      /* On first -d, print version identification */
      static boolean printed_version = FALSE;

      if (! printed_version) {
	fprintf(stderr, "Independent JPEG Group's DJPEG, version %s\n%s\n",
		JVERSION, JCOPYRIGHT);
	printed_version = TRUE;
      }
      cinfo->err->trace_level++;

    } else if (keymatch(arg, "fast", 1)) {
      /* Select recommended processing options for quick-and-dirty output. */
      cinfo->two_pass_quantize = FALSE;
      cinfo->dither_mode = JDITHER_ORDERED;
      if (! cinfo->quantize_colors) /* don't override an earlier -colors */
	cinfo->desired_number_of_colors = 216;
      cinfo->dct_method = JDCT_FASTEST;
      cinfo->do_fancy_upsampling = FALSE;

    } else if (keymatch(arg, "gif", 1)) {
      /* GIF output format. */
      requested_fmt = FMT_GIF;

    } else if (keymatch(arg, "grayscale", 2) || keymatch(arg, "greyscale",2)) {
      /* Force monochrome output. */
      cinfo->out_color_space = JCS_GRAYSCALE;

    } else if (keymatch(arg, "map", 3)) {
      /* Quantize to a color map taken from an input file. */
      if (++argn >= argc)	/* advance to next argument */
	usage();
      if (for_real) {		/* too expensive to do twice! */
#ifdef QUANT_2PASS_SUPPORTED	/* otherwise can't quantize to supplied map */
	FILE * mapfile;

	if ((mapfile = fopen(argv[argn], READ_BINARY)) == NULL) {
	  fprintf(stderr, "%s: can't open %s\n", progname, argv[argn]);
	  exit(EXIT_FAILURE);
	}
	read_color_map(cinfo, mapfile);
	fclose(mapfile);
	cinfo->quantize_colors = TRUE;
#else
	ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
      }

    } else if (keymatch(arg, "maxmemory", 3)) {
      /* Maximum memory in Kb (or Mb with 'm'). */
      long lval;
      char ch = 'x';

      if (++argn >= argc)	/* advance to next argument */
	usage();
      if (sscanf(argv[argn], "%ld%c", &lval, &ch) < 1)
	usage();
      if (ch == 'm' || ch == 'M')
	lval *= 1000L;
      cinfo->mem->max_memory_to_use = lval * 1000L;

    } else if (keymatch(arg, "nosmooth", 3)) {
      /* Suppress fancy upsampling */
      cinfo->do_fancy_upsampling = FALSE;

    } else if (keymatch(arg, "onepass", 3)) {
      /* Use fast one-pass quantization. */
      cinfo->two_pass_quantize = FALSE;

    } else if (keymatch(arg, "os2", 3)) {
      /* BMP output format (OS/2 flavor). */
      requested_fmt = FMT_OS2;

    } else if (keymatch(arg, "outfile", 4)) {
      /* Set output file name. */
      if (++argn >= argc)	/* advance to next argument */
	usage();
      outfilename = argv[argn];	/* save it away for later use */

    } else if (keymatch(arg, "pnm", 1) || keymatch(arg, "ppm", 1)) {
      /* PPM/PGM output format. */
      requested_fmt = FMT_PPM;

    } else if (keymatch(arg, "rle", 1)) {
      /* RLE output format. */
      requested_fmt = FMT_RLE;

    } else if (keymatch(arg, "scale", 1)) {
      /* Scale the output image by a fraction M/N. */
      if (++argn >= argc)	/* advance to next argument */
	usage();
      if (sscanf(argv[argn], "%d/%d",
		 &cinfo->scale_num, &cinfo->scale_denom) != 2)
	usage();

    } else if (keymatch(arg, "targa", 1)) {
      /* Targa output format. */
      requested_fmt = FMT_TARGA;

    } else {
      usage();			/* bogus switch */
    }
  }

  return argn;			/* return index of next arg (file name) */
}


/*
 * Marker processor for COM markers.
 * This replaces the library's built-in processor, which just skips the marker.
 * We want to print out the marker as text, if possible.
 * Note this code relies on a non-suspending data source.
 */

LOCAL(unsigned int)
jpeg_getc (j_decompress_ptr cinfo)
/* Read next byte */
{
  struct jpeg_source_mgr * datasrc = cinfo->src;

  if (datasrc->bytes_in_buffer == 0) {
    if (! (*datasrc->fill_input_buffer) (cinfo))
      ERREXIT(cinfo, JERR_CANT_SUSPEND);
  }
  datasrc->bytes_in_buffer--;
  return GETJOCTET(*datasrc->next_input_byte++);
}


METHODDEF(boolean)
COM_handler (j_decompress_ptr cinfo)
{
  boolean traceit = (cinfo->err->trace_level >= 1);
  INT32 length;
  unsigned int ch;
  unsigned int lastch = 0;

  length = jpeg_getc(cinfo) << 8;
  length += jpeg_getc(cinfo);
  length -= 2;			/* discount the length word itself */

  if (traceit)
    fprintf(stderr, "Comment, length %ld:\n", (long) length);

  while (--length >= 0) {
    ch = jpeg_getc(cinfo);
    if (traceit) {
      /* Emit the character in a readable form.
       * Nonprintables are converted to \nnn form,
       * while \ is converted to \\.
       * Newlines in CR, CR/LF, or LF form will be printed as one newline.
       */
      if (ch == '\r') {
	fprintf(stderr, "\n");
      } else if (ch == '\n') {
	if (lastch != '\r')
	  fprintf(stderr, "\n");
      } else if (ch == '\\') {
	fprintf(stderr, "\\\\");
      } else if (isprint(ch)) {
	putc(ch, stderr);
      } else {
	fprintf(stderr, "\\%03o", ch);
      }
      lastch = ch;
    }
  }

  if (traceit)
    fprintf(stderr, "\n");

  return TRUE;
}


/*
 * The main program.
 */

int
main (int argc, char **argv)
{
  struct jpeg_decompress_struct cinfo;
  struct jpeg_error_mgr jerr;
#ifdef PROGRESS_REPORT
  struct cdjpeg_progress_mgr progress;
#endif
  int file_index;
  djpeg_dest_ptr dest_mgr = NULL;
  FILE * input_file;
  FILE * output_file;
  JDIMENSION num_scanlines;

  /* On Mac, fetch a command line. */
#ifdef USE_CCOMMAND
  argc = ccommand(&argv);
#endif

  progname = argv[0];
  if (progname == NULL || progname[0] == 0)
    progname = "djpeg";		/* in case C library doesn't provide it */

  /* Initialize the JPEG decompression object with default error handling. */
  cinfo.err = jpeg_std_error(&jerr);
  jpeg_create_decompress(&cinfo);
  /* Add some application-specific error messages (from cderror.h) */
  jerr.addon_message_table = cdjpeg_message_table;
  jerr.first_addon_message = JMSG_FIRSTADDONCODE;
  jerr.last_addon_message = JMSG_LASTADDONCODE;
  /* Insert custom COM marker processor. */
  jpeg_set_marker_processor(&cinfo, JPEG_COM, COM_handler);

  /* Now safe to enable signal catcher. */
#ifdef NEED_SIGNAL_CATCHER
  enable_signal_catcher((j_common_ptr) &cinfo);
#endif

  /* Scan command line to find file names. */
  /* It is convenient to use just one switch-parsing routine, but the switch
   * values read here are ignored; we will rescan the switches after opening
   * the input file.
   * (Exception: tracing level set here controls verbosity for COM markers
   * found during jpeg_read_header...)
   */

  file_index = parse_switches(&cinfo, argc, argv, 0, FALSE);

#ifdef TWO_FILE_COMMANDLINE
  /* Must have either -outfile switch or explicit output file name */
  if (outfilename == NULL) {
    if (file_index != argc-2) {
      fprintf(stderr, "%s: must name one input and one output file\n",
	      progname);
      usage();
    }
    outfilename = argv[file_index+1];
  } else {
    if (file_index != argc-1) {
      fprintf(stderr, "%s: must name one input and one output file\n",
	      progname);
      usage();
    }
  }
#else
  /* Unix style: expect zero or one file name */
  if (file_index < argc-1) {
    fprintf(stderr, "%s: only one input file\n", progname);
    usage();
  }
#endif /* TWO_FILE_COMMANDLINE */

  /* Open the input file. */
  if (file_index < argc) {
    if ((input_file = fopen(argv[file_index], READ_BINARY)) == NULL) {
      fprintf(stderr, "%s: can't open %s\n", progname, argv[file_index]);
      exit(EXIT_FAILURE);
    }
  } else {
    /* default input file is stdin */
    input_file = read_stdin();
  }

  /* Open the output file. */
  if (outfilename != NULL) {
    if ((output_file = fopen(outfilename, WRITE_BINARY)) == NULL) {
      fprintf(stderr, "%s: can't open %s\n", progname, outfilename);
      exit(EXIT_FAILURE);
    }
  } else {
    /* default output file is stdout */
    output_file = write_stdout();
  }

#ifdef PROGRESS_REPORT
  start_progress_monitor((j_common_ptr) &cinfo, &progress);
#endif

  /* Specify data source for decompression */
  jpeg_stdio_src(&cinfo, input_file);

  /* Read file header, set default decompression parameters */
  (void) jpeg_read_header(&cinfo, TRUE);

  /* Adjust default decompression parameters by re-parsing the options */
  file_index = parse_switches(&cinfo, argc, argv, 0, TRUE);

  /* Initialize the output module now to let it override any crucial
   * option settings (for instance, GIF wants to force color quantization).
   */
  switch (requested_fmt) {
#ifdef BMP_SUPPORTED
  case FMT_BMP:
    dest_mgr = jinit_write_bmp(&cinfo, FALSE);
    break;
  case FMT_OS2:
    dest_mgr = jinit_write_bmp(&cinfo, TRUE);
    break;
#endif
#ifdef GIF_SUPPORTED
  case FMT_GIF:
    dest_mgr = jinit_write_gif(&cinfo);
    break;
#endif
#ifdef PPM_SUPPORTED
  case FMT_PPM:
    dest_mgr = jinit_write_ppm(&cinfo);
    break;
#endif
#ifdef RLE_SUPPORTED
  case FMT_RLE:
    dest_mgr = jinit_write_rle(&cinfo);
    break;
#endif
#ifdef TARGA_SUPPORTED
  case FMT_TARGA:
    dest_mgr = jinit_write_targa(&cinfo);
    break;
#endif
  default:
    ERREXIT(&cinfo, JERR_UNSUPPORTED_FORMAT);
    break;
  }
  dest_mgr->output_file = output_file;

  /* Start decompressor */
  (void) jpeg_start_decompress(&cinfo);

  /* Write output file header */
  (*dest_mgr->start_output) (&cinfo, dest_mgr);

  /* Process data */
  while (cinfo.output_scanline < cinfo.output_height) {
    num_scanlines = jpeg_read_scanlines(&cinfo, dest_mgr->buffer,
					dest_mgr->buffer_height);
    (*dest_mgr->put_pixel_rows) (&cinfo, dest_mgr, num_scanlines);
  }

#ifdef PROGRESS_REPORT
  /* Hack: count final pass as done in case finish_output does an extra pass.
   * The library won't have updated completed_passes.
   */
  progress.pub.completed_passes = progress.pub.total_passes;
#endif

  /* Finish decompression and release memory.
   * I must do it in this order because output module has allocated memory
   * of lifespan JPOOL_IMAGE; it needs to finish before releasing memory.
   */
  (*dest_mgr->finish_output) (&cinfo, dest_mgr);
  (void) jpeg_finish_decompress(&cinfo);
  jpeg_destroy_decompress(&cinfo);

  /* Close files, if we opened them */
  if (input_file != stdin)
    fclose(input_file);
  if (output_file != stdout)
    fclose(output_file);

#ifdef PROGRESS_REPORT
  end_progress_monitor((j_common_ptr) &cinfo);
#endif

  /* All done. */
  exit(jerr.num_warnings ? EXIT_WARNING : EXIT_SUCCESS);
  return 0;			/* suppress no-return-value warnings */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\cdjpeg.c ===
/*
 * cdjpeg.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains common support routines used by the IJG application
 * programs (cjpeg, djpeg, jpegtran).
 */

#include "cdjpeg.h"		/* Common decls for cjpeg/djpeg applications */
#include <ctype.h>		/* to declare isupper(), tolower() */
#ifdef NEED_SIGNAL_CATCHER
#include <signal.h>		/* to declare signal() */
#endif
#ifdef USE_SETMODE
#include <fcntl.h>		/* to declare setmode()'s parameter macros */
/* If you have setmode() but not <io.h>, just delete this line: */
#include <io.h>			/* to declare setmode() */
#endif


/*
 * Signal catcher to ensure that temporary files are removed before aborting.
 * NB: for Amiga Manx C this is actually a global routine named _abort();
 * we put "#define signal_catcher _abort" in jconfig.h.  Talk about bogus...
 */

#ifdef NEED_SIGNAL_CATCHER

static j_common_ptr sig_cinfo;

void				/* must be global for Manx C */
signal_catcher (int signum)
{
  if (sig_cinfo != NULL) {
    if (sig_cinfo->err != NULL) /* turn off trace output */
      sig_cinfo->err->trace_level = 0;
    jpeg_destroy(sig_cinfo);	/* clean up memory allocation & temp files */
  }
  exit(EXIT_FAILURE);
}


GLOBAL(void)
enable_signal_catcher (j_common_ptr cinfo)
{
  sig_cinfo = cinfo;
  signal(SIGINT, signal_catcher);
#ifdef SIGTERM			/* not all systems have SIGTERM */
  signal(SIGTERM, signal_catcher);
#endif
}

#endif


/*
 * Optional progress monitor: display a percent-done figure on stderr.
 */

#ifdef PROGRESS_REPORT

METHODDEF(void)
progress_monitor (j_common_ptr cinfo)
{
  cd_progress_ptr prog = (cd_progress_ptr) cinfo->progress;
  int total_passes = prog->pub.total_passes + prog->total_extra_passes;
  int percent_done = (int) (prog->pub.pass_counter*100L/prog->pub.pass_limit);

  if (percent_done != prog->percent_done) {
    prog->percent_done = percent_done;
    if (total_passes > 1) {
      fprintf(stderr, "\rPass %d/%d: %3d%% ",
	      prog->pub.completed_passes + prog->completed_extra_passes + 1,
	      total_passes, percent_done);
    } else {
      fprintf(stderr, "\r %3d%% ", percent_done);
    }
    fflush(stderr);
  }
}


GLOBAL(void)
start_progress_monitor (j_common_ptr cinfo, cd_progress_ptr progress)
{
  /* Enable progress display, unless trace output is on */
  if (cinfo->err->trace_level == 0) {
    progress->pub.progress_monitor = progress_monitor;
    progress->completed_extra_passes = 0;
    progress->total_extra_passes = 0;
    progress->percent_done = -1;
    cinfo->progress = &progress->pub;
  }
}


GLOBAL(void)
end_progress_monitor (j_common_ptr cinfo)
{
  /* Clear away progress display */
  if (cinfo->err->trace_level == 0) {
    fprintf(stderr, "\r                \r");
    fflush(stderr);
  }
}

#endif


/*
 * Case-insensitive matching of possibly-abbreviated keyword switches.
 * keyword is the constant keyword (must be lower case already),
 * minchars is length of minimum legal abbreviation.
 */

GLOBAL(boolean)
keymatch (char * arg, const char * keyword, int minchars)
{
  register int ca, ck;
  register int nmatched = 0;

  while ((ca = *arg++) != '\0') {
    if ((ck = *keyword++) == '\0')
      return FALSE;		/* arg longer than keyword, no good */
    if (isupper(ca))		/* force arg to lcase (assume ck is already) */
      ca = tolower(ca);
    if (ca != ck)
      return FALSE;		/* no good */
    nmatched++;			/* count matched characters */
  }
  /* reached end of argument; fail if it's too short for unique abbrev */
  if (nmatched < minchars)
    return FALSE;
  return TRUE;			/* A-OK */
}


/*
 * Routines to establish binary I/O mode for stdin and stdout.
 * Non-Unix systems often require some hacking to get out of text mode.
 */

GLOBAL(FILE *)
read_stdin (void)
{
  FILE * input_file = stdin;

#ifdef USE_SETMODE		/* need to hack file mode? */
  setmode(fileno(stdin), O_BINARY);
#endif
#ifdef USE_FDOPEN		/* need to re-open in binary mode? */
  if ((input_file = fdopen(fileno(stdin), READ_BINARY)) == NULL) {
    fprintf(stderr, "Cannot reopen stdin\n");
    exit(EXIT_FAILURE);
  }
#endif
  return input_file;
}


GLOBAL(FILE *)
write_stdout (void)
{
  FILE * output_file = stdout;

#ifdef USE_SETMODE		/* need to hack file mode? */
  setmode(fileno(stdout), O_BINARY);
#endif
#ifdef USE_FDOPEN		/* need to re-open in binary mode? */
  if ((output_file = fdopen(fileno(stdout), WRITE_BINARY)) == NULL) {
    fprintf(stderr, "Cannot reopen stdout\n");
    exit(EXIT_FAILURE);
  }
#endif
  return output_file;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\jcapimin.c ===
/*
 * jcapimin.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains application interface code for the compression half
 * of the JPEG library.  These are the "minimum" API routines that may be
 * needed in either the normal full-compression case or the transcoding-only
 * case.
 *
 * Most of the routines intended to be called directly by an application
 * are in this file or in jcapistd.c.  But also see jcparam.c for
 * parameter-setup helper routines, jcomapi.c for routines shared by
 * compression and decompression, and jctrans.c for the transcoding case.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/*
 * Initialization of a JPEG compression object.
 * The error manager must already be set up (in case memory manager fails).
 */

GLOBAL(void)
jpeg_CreateCompress (j_compress_ptr cinfo, int version, size_t structsize)
{
  int i;

  /* Guard against version mismatches between library and caller. */
  cinfo->mem = NULL;		/* so jpeg_destroy knows mem mgr not called */
  if (version != JPEG_LIB_VERSION)
    ERREXIT2(cinfo, JERR_BAD_LIB_VERSION, JPEG_LIB_VERSION, version);
  if (structsize != SIZEOF(struct jpeg_compress_struct))
    ERREXIT2(cinfo, JERR_BAD_STRUCT_SIZE, 
	     (int) SIZEOF(struct jpeg_compress_struct), (int) structsize);

  /* For debugging purposes, zero the whole master structure.
   * But error manager pointer is already there, so save and restore it.
   */
  {
    struct jpeg_error_mgr * err = cinfo->err;
    MEMZERO(cinfo, SIZEOF(struct jpeg_compress_struct));
    cinfo->err = err;
  }
  cinfo->is_decompressor = FALSE;

  /* Initialize a memory manager instance for this object */
  jinit_memory_mgr((j_common_ptr) cinfo);

  /* Zero out pointers to permanent structures. */
  cinfo->progress = NULL;
  cinfo->dest = NULL;

  cinfo->comp_info = NULL;

  for (i = 0; i < NUM_QUANT_TBLS; i++)
    cinfo->quant_tbl_ptrs[i] = NULL;

  for (i = 0; i < NUM_HUFF_TBLS; i++) {
    cinfo->dc_huff_tbl_ptrs[i] = NULL;
    cinfo->ac_huff_tbl_ptrs[i] = NULL;
  }

  cinfo->input_gamma = 1.0;	/* in case application forgets */

  /* OK, I'm ready */
  cinfo->global_state = CSTATE_START;
}


/*
 * Destruction of a JPEG compression object
 */

GLOBAL(void)
jpeg_destroy_compress (j_compress_ptr cinfo)
{
  jpeg_destroy((j_common_ptr) cinfo); /* use common routine */
}


/*
 * Abort processing of a JPEG compression operation,
 * but don't destroy the object itself.
 */

GLOBAL(void)
jpeg_abort_compress (j_compress_ptr cinfo)
{
  jpeg_abort((j_common_ptr) cinfo); /* use common routine */
}


/*
 * Forcibly suppress or un-suppress all quantization and Huffman tables.
 * Marks all currently defined tables as already written (if suppress)
 * or not written (if !suppress).  This will control whether they get emitted
 * by a subsequent jpeg_start_compress call.
 *
 * This routine is exported for use by applications that want to produce
 * abbreviated JPEG datastreams.  It logically belongs in jcparam.c, but
 * since it is called by jpeg_start_compress, we put it here --- otherwise
 * jcparam.o would be linked whether the application used it or not.
 */

GLOBAL(void)
jpeg_suppress_tables (j_compress_ptr cinfo, boolean suppress)
{
  int i;
  JQUANT_TBL * qtbl;
  JHUFF_TBL * htbl;

  for (i = 0; i < NUM_QUANT_TBLS; i++) {
    if ((qtbl = cinfo->quant_tbl_ptrs[i]) != NULL)
      qtbl->sent_table = suppress;
  }

  for (i = 0; i < NUM_HUFF_TBLS; i++) {
    if ((htbl = cinfo->dc_huff_tbl_ptrs[i]) != NULL)
      htbl->sent_table = suppress;
    if ((htbl = cinfo->ac_huff_tbl_ptrs[i]) != NULL)
      htbl->sent_table = suppress;
  }
}


/*
 * Finish JPEG compression.
 *
 * If a multipass operating mode was selected, this may do a great deal of
 * work including most of the actual output.
 */

GLOBAL(void)
jpeg_finish_compress (j_compress_ptr cinfo)
{
  JDIMENSION iMCU_row;

  if (cinfo->global_state == CSTATE_SCANNING ||
      cinfo->global_state == CSTATE_RAW_OK) {
    /* Terminate first pass */
    if (cinfo->next_scanline < cinfo->image_height)
      ERREXIT(cinfo, JERR_TOO_LITTLE_DATA);
    (*cinfo->master->finish_pass) (cinfo);
  } else if (cinfo->global_state != CSTATE_WRCOEFS)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  /* Perform any remaining passes */
  while (! cinfo->master->is_last_pass) {
    (*cinfo->master->prepare_for_pass) (cinfo);
    for (iMCU_row = 0; iMCU_row < cinfo->total_iMCU_rows; iMCU_row++) {
      if (cinfo->progress != NULL) {
	cinfo->progress->pass_counter = (long) iMCU_row;
	cinfo->progress->pass_limit = (long) cinfo->total_iMCU_rows;
	(*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
      }
      /* We bypass the main controller and invoke coef controller directly;
       * all work is being done from the coefficient buffer.
       */
      if (! (*cinfo->coef->compress_data) (cinfo, (JSAMPIMAGE) NULL))
	ERREXIT(cinfo, JERR_CANT_SUSPEND);
    }
    (*cinfo->master->finish_pass) (cinfo);
  }
  /* Write EOI, do final cleanup */
  (*cinfo->marker->write_file_trailer) (cinfo);
  (*cinfo->dest->term_destination) (cinfo);
  /* We can use jpeg_abort to release memory and reset global_state */
  jpeg_abort((j_common_ptr) cinfo);
}


/*
 * Write a special marker.
 * This is only recommended for writing COM or APPn markers.
 * Must be called after jpeg_start_compress() and before
 * first call to jpeg_write_scanlines() or jpeg_write_raw_data().
 */

GLOBAL(void)
jpeg_write_marker (j_compress_ptr cinfo, int marker,
		   const JOCTET *dataptr, unsigned int datalen)
{
  if (cinfo->next_scanline != 0 ||
      (cinfo->global_state != CSTATE_SCANNING &&
       cinfo->global_state != CSTATE_RAW_OK &&
       cinfo->global_state != CSTATE_WRCOEFS))
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);

  (*cinfo->marker->write_any_marker) (cinfo, marker, dataptr, datalen);
}


/*
 * Alternate compression function: just write an abbreviated table file.
 * Before calling this, all parameters and a data destination must be set up.
 *
 * To produce a pair of files containing abbreviated tables and abbreviated
 * image data, one would proceed as follows:
 *
 *		initialize JPEG object
 *		set JPEG parameters
 *		set destination to table file
 *		jpeg_write_tables(cinfo);
 *		set destination to image file
 *		jpeg_start_compress(cinfo, FALSE);
 *		write data...
 *		jpeg_finish_compress(cinfo);
 *
 * jpeg_write_tables has the side effect of marking all tables written
 * (same as jpeg_suppress_tables(..., TRUE)).  Thus a subsequent start_compress
 * will not re-emit the tables unless it is passed write_all_tables=TRUE.
 */

GLOBAL(void)
jpeg_write_tables (j_compress_ptr cinfo)
{
  if (cinfo->global_state != CSTATE_START)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);

  /* (Re)initialize error mgr and destination modules */
  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
  (*cinfo->dest->init_destination) (cinfo);
  /* Initialize the marker writer ... bit of a crock to do it here. */
  jinit_marker_writer(cinfo);
  /* Write them tables! */
  (*cinfo->marker->write_tables_only) (cinfo);
  /* And clean up. */
  (*cinfo->dest->term_destination) (cinfo);
  /* We can use jpeg_abort to release memory. */
  jpeg_abort((j_common_ptr) cinfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\cjpeg.c ===
/*
 * cjpeg.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains a command-line user interface for the JPEG compressor.
 * It should work on any system with Unix- or MS-DOS-style command lines.
 *
 * Two different command line styles are permitted, depending on the
 * compile-time switch TWO_FILE_COMMANDLINE:
 *	cjpeg [options]  inputfile outputfile
 *	cjpeg [options]  [inputfile]
 * In the second style, output is always to standard output, which you'd
 * normally redirect to a file or pipe to some other program.  Input is
 * either from a named file or from standard input (typically redirected).
 * The second style is convenient on Unix but is unhelpful on systems that
 * don't support pipes.  Also, you MUST use the first style if your system
 * doesn't do binary I/O to stdin/stdout.
 * To simplify script writing, the "-outfile" switch is provided.  The syntax
 *	cjpeg [options]  -outfile outputfile  inputfile
 * works regardless of which command line style is used.
 */

#include "cdjpeg.h"		/* Common decls for cjpeg/djpeg applications */
#include "jversion.h"		/* for version message */

#ifdef USE_CCOMMAND		/* command-line reader for Macintosh */
#ifdef __MWERKS__
#include <SIOUX.h>              /* Metrowerks needs this */
#include <console.h>		/* ... and this */
#endif
#ifdef THINK_C
#include <console.h>		/* Think declares it here */
#endif
#endif


/* Create the add-on message string table. */

#define JMESSAGE(code,string)	string ,

static const char * const cdjpeg_message_table[] = {
#include "cderror.h"
  NULL
};


/*
 * This routine determines what format the input file is,
 * and selects the appropriate input-reading module.
 *
 * To determine which family of input formats the file belongs to,
 * we may look only at the first byte of the file, since C does not
 * guarantee that more than one character can be pushed back with ungetc.
 * Looking at additional bytes would require one of these approaches:
 *     1) assume we can fseek() the input file (fails for piped input);
 *     2) assume we can push back more than one character (works in
 *        some C implementations, but unportable);
 *     3) provide our own buffering (breaks input readers that want to use
 *        stdio directly, such as the RLE library);
 * or  4) don't put back the data, and modify the input_init methods to assume
 *        they start reading after the start of file (also breaks RLE library).
 * #1 is attractive for MS-DOS but is untenable on Unix.
 *
 * The most portable solution for file types that can't be identified by their
 * first byte is to make the user tell us what they are.  This is also the
 * only approach for "raw" file types that contain only arbitrary values.
 * We presently apply this method for Targa files.  Most of the time Targa
 * files start with 0x00, so we recognize that case.  Potentially, however,
 * a Targa file could start with any byte value (byte 0 is the length of the
 * seldom-used ID field), so we provide a switch to force Targa input mode.
 */

static boolean is_targa;	/* records user -targa switch */


LOCAL(cjpeg_source_ptr)
select_file_type (j_compress_ptr cinfo, FILE * infile)
{
  int c;

  if (is_targa) {
#ifdef TARGA_SUPPORTED
    return jinit_read_targa(cinfo);
#else
    ERREXIT(cinfo, JERR_TGA_NOTCOMP);
#endif
  }

  if ((c = getc(infile)) == EOF)
    ERREXIT(cinfo, JERR_INPUT_EMPTY);
  if (ungetc(c, infile) == EOF)
    ERREXIT(cinfo, JERR_UNGETC_FAILED);

  switch (c) {
#ifdef BMP_SUPPORTED
  case 'B':
    return jinit_read_bmp(cinfo);
#endif
#ifdef GIF_SUPPORTED
  case 'G':
    return jinit_read_gif(cinfo);
#endif
#ifdef PPM_SUPPORTED
  case 'P':
    return jinit_read_ppm(cinfo);
#endif
#ifdef RLE_SUPPORTED
  case 'R':
    return jinit_read_rle(cinfo);
#endif
#ifdef TARGA_SUPPORTED
  case 0x00:
    return jinit_read_targa(cinfo);
#endif
  default:
    ERREXIT(cinfo, JERR_UNKNOWN_FORMAT);
    break;
  }

  return NULL;			/* suppress compiler warnings */
}


/*
 * Argument-parsing code.
 * The switch parser is designed to be useful with DOS-style command line
 * syntax, ie, intermixed switches and file names, where only the switches
 * to the left of a given file name affect processing of that file.
 * The main program in this file doesn't actually use this capability...
 */


static const char * progname;	/* program name for error messages */
static char * outfilename;	/* for -outfile switch */


LOCAL(void)
usage (void)
/* complain about bad command line */
{
  fprintf(stderr, "usage: %s [switches] ", progname);
#ifdef TWO_FILE_COMMANDLINE
  fprintf(stderr, "inputfile outputfile\n");
#else
  fprintf(stderr, "[inputfile]\n");
#endif

  fprintf(stderr, "Switches (names may be abbreviated):\n");
  fprintf(stderr, "  -quality N     Compression quality (0..100; 5-95 is useful range)\n");
  fprintf(stderr, "  -grayscale     Create monochrome JPEG file\n");
#ifdef ENTROPY_OPT_SUPPORTED
  fprintf(stderr, "  -optimize      Optimize Huffman table (smaller file, but slow compression)\n");
#endif
#ifdef C_PROGRESSIVE_SUPPORTED
  fprintf(stderr, "  -progressive   Create progressive JPEG file\n");
#endif
#ifdef TARGA_SUPPORTED
  fprintf(stderr, "  -targa         Input file is Targa format (usually not needed)\n");
#endif
  fprintf(stderr, "Switches for advanced users:\n");
#ifdef DCT_ISLOW_SUPPORTED
  fprintf(stderr, "  -dct int       Use integer DCT method%s\n",
	  (JDCT_DEFAULT == JDCT_ISLOW ? " (default)" : ""));
#endif
#ifdef DCT_IFAST_SUPPORTED
  fprintf(stderr, "  -dct fast      Use fast integer DCT (less accurate)%s\n",
	  (JDCT_DEFAULT == JDCT_IFAST ? " (default)" : ""));
#endif
#ifdef DCT_FLOAT_SUPPORTED
  fprintf(stderr, "  -dct float     Use floating-point DCT method%s\n",
	  (JDCT_DEFAULT == JDCT_FLOAT ? " (default)" : ""));
#endif
  fprintf(stderr, "  -restart N     Set restart interval in rows, or in blocks with B\n");
#ifdef INPUT_SMOOTHING_SUPPORTED
  fprintf(stderr, "  -smooth N      Smooth dithered input (N=1..100 is strength)\n");
#endif
  fprintf(stderr, "  -maxmemory N   Maximum memory to use (in kbytes)\n");
  fprintf(stderr, "  -outfile name  Specify name for output file\n");
  fprintf(stderr, "  -verbose  or  -debug   Emit debug output\n");
  fprintf(stderr, "Switches for wizards:\n");
#ifdef C_ARITH_CODING_SUPPORTED
  fprintf(stderr, "  -arithmetic    Use arithmetic coding\n");
#endif
  fprintf(stderr, "  -baseline      Force baseline output\n");
  fprintf(stderr, "  -qtables file  Use quantization tables given in file\n");
  fprintf(stderr, "  -qslots N[,...]    Set component quantization tables\n");
  fprintf(stderr, "  -sample HxV[,...]  Set component sampling factors\n");
#ifdef C_MULTISCAN_FILES_SUPPORTED
  fprintf(stderr, "  -scans file    Create multi-scan JPEG per script file\n");
#endif
  exit(EXIT_FAILURE);
}


LOCAL(int)
parse_switches (j_compress_ptr cinfo, int argc, char **argv,
		int last_file_arg_seen, boolean for_real)
/* Parse optional switches.
 * Returns argv[] index of first file-name argument (== argc if none).
 * Any file names with indexes <= last_file_arg_seen are ignored;
 * they have presumably been processed in a previous iteration.
 * (Pass 0 for last_file_arg_seen on the first or only iteration.)
 * for_real is FALSE on the first (dummy) pass; we may skip any expensive
 * processing.
 */
{
  int argn;
  char * arg;
  int quality;			/* -quality parameter */
  int q_scale_factor;		/* scaling percentage for -qtables */
  boolean force_baseline;
  boolean simple_progressive;
  char * qtablefile = NULL;	/* saves -qtables filename if any */
  char * qslotsarg = NULL;	/* saves -qslots parm if any */
  char * samplearg = NULL;	/* saves -sample parm if any */
  char * scansarg = NULL;	/* saves -scans parm if any */

  /* Set up default JPEG parameters. */
  /* Note that default -quality level need not, and does not,
   * match the default scaling for an explicit -qtables argument.
   */
  quality = 75;			/* default -quality value */
  q_scale_factor = 100;		/* default to no scaling for -qtables */
  force_baseline = FALSE;	/* by default, allow 16-bit quantizers */
  simple_progressive = FALSE;
  is_targa = FALSE;
  outfilename = NULL;
  cinfo->err->trace_level = 0;

  /* Scan command line options, adjust parameters */

  for (argn = 1; argn < argc; argn++) {
    arg = argv[argn];
    if (*arg != '-') {
      /* Not a switch, must be a file name argument */
      if (argn <= last_file_arg_seen) {
	outfilename = NULL;	/* -outfile applies to just one input file */
	continue;		/* ignore this name if previously processed */
      }
      break;			/* else done parsing switches */
    }
    arg++;			/* advance past switch marker character */

    if (keymatch(arg, "arithmetic", 1)) {
      /* Use arithmetic coding. */
#ifdef C_ARITH_CODING_SUPPORTED
      cinfo->arith_code = TRUE;
#else
      fprintf(stderr, "%s: sorry, arithmetic coding not supported\n",
	      progname);
      exit(EXIT_FAILURE);
#endif

    } else if (keymatch(arg, "baseline", 1)) {
      /* Force baseline output (8-bit quantizer values). */
      force_baseline = TRUE;

    } else if (keymatch(arg, "dct", 2)) {
      /* Select DCT algorithm. */
      if (++argn >= argc)	/* advance to next argument */
	usage();
      if (keymatch(argv[argn], "int", 1)) {
	cinfo->dct_method = JDCT_ISLOW;
      } else if (keymatch(argv[argn], "fast", 2)) {
	cinfo->dct_method = JDCT_IFAST;
      } else if (keymatch(argv[argn], "float", 2)) {
	cinfo->dct_method = JDCT_FLOAT;
      } else
	usage();

    } else if (keymatch(arg, "debug", 1) || keymatch(arg, "verbose", 1)) {
      /* Enable debug printouts. */
      /* On first -d, print version identification */
      static boolean printed_version = FALSE;

      if (! printed_version) {
	fprintf(stderr, "Independent JPEG Group's CJPEG, version %s\n%s\n",
		JVERSION, JCOPYRIGHT);
	printed_version = TRUE;
      }
      cinfo->err->trace_level++;

    } else if (keymatch(arg, "grayscale", 2) || keymatch(arg, "greyscale",2)) {
      /* Force a monochrome JPEG file to be generated. */
      jpeg_set_colorspace(cinfo, JCS_GRAYSCALE);

    } else if (keymatch(arg, "maxmemory", 3)) {
      /* Maximum memory in Kb (or Mb with 'm'). */
      long lval;
      char ch = 'x';

      if (++argn >= argc)	/* advance to next argument */
	usage();
      if (sscanf(argv[argn], "%ld%c", &lval, &ch) < 1)
	usage();
      if (ch == 'm' || ch == 'M')
	lval *= 1000L;
      cinfo->mem->max_memory_to_use = lval * 1000L;

    } else if (keymatch(arg, "optimize", 1) || keymatch(arg, "optimise", 1)) {
      /* Enable entropy parm optimization. */
#ifdef ENTROPY_OPT_SUPPORTED
      cinfo->optimize_coding = TRUE;
#else
      fprintf(stderr, "%s: sorry, entropy optimization was not compiled\n",
	      progname);
      exit(EXIT_FAILURE);
#endif

    } else if (keymatch(arg, "outfile", 4)) {
      /* Set output file name. */
      if (++argn >= argc)	/* advance to next argument */
	usage();
      outfilename = argv[argn];	/* save it away for later use */

    } else if (keymatch(arg, "progressive", 1)) {
      /* Select simple progressive mode. */
#ifdef C_PROGRESSIVE_SUPPORTED
      simple_progressive = TRUE;
      /* We must postpone execution until num_components is known. */
#else
      fprintf(stderr, "%s: sorry, progressive output was not compiled\n",
	      progname);
      exit(EXIT_FAILURE);
#endif

    } else if (keymatch(arg, "quality", 1)) {
      /* Quality factor (quantization table scaling factor). */
      if (++argn >= argc)	/* advance to next argument */
	usage();
      if (sscanf(argv[argn], "%d", &quality) != 1)
	usage();
      /* Change scale factor in case -qtables is present. */
      q_scale_factor = jpeg_quality_scaling(quality);

    } else if (keymatch(arg, "qslots", 2)) {
      /* Quantization table slot numbers. */
      if (++argn >= argc)	/* advance to next argument */
	usage();
      qslotsarg = argv[argn];
      /* Must delay setting qslots until after we have processed any
       * colorspace-determining switches, since jpeg_set_colorspace sets
       * default quant table numbers.
       */

    } else if (keymatch(arg, "qtables", 2)) {
      /* Quantization tables fetched from file. */
      if (++argn >= argc)	/* advance to next argument */
	usage();
      qtablefile = argv[argn];
      /* We postpone actually reading the file in case -quality comes later. */

    } else if (keymatch(arg, "restart", 1)) {
      /* Restart interval in MCU rows (or in MCUs with 'b'). */
      long lval;
      char ch = 'x';

      if (++argn >= argc)	/* advance to next argument */
	usage();
      if (sscanf(argv[argn], "%ld%c", &lval, &ch) < 1)
	usage();
      if (lval < 0 || lval > 65535L)
	usage();
      if (ch == 'b' || ch == 'B') {
	cinfo->restart_interval = (unsigned int) lval;
	cinfo->restart_in_rows = 0; /* else prior '-restart n' overrides me */
      } else {
	cinfo->restart_in_rows = (int) lval;
	/* restart_interval will be computed during startup */
      }

    } else if (keymatch(arg, "sample", 2)) {
      /* Set sampling factors. */
      if (++argn >= argc)	/* advance to next argument */
	usage();
      samplearg = argv[argn];
      /* Must delay setting sample factors until after we have processed any
       * colorspace-determining switches, since jpeg_set_colorspace sets
       * default sampling factors.
       */

    } else if (keymatch(arg, "scans", 2)) {
      /* Set scan script. */
#ifdef C_MULTISCAN_FILES_SUPPORTED
      if (++argn >= argc)	/* advance to next argument */
	usage();
      scansarg = argv[argn];
      /* We must postpone reading the file in case -progressive appears. */
#else
      fprintf(stderr, "%s: sorry, multi-scan output was not compiled\n",
	      progname);
      exit(EXIT_FAILURE);
#endif

    } else if (keymatch(arg, "smooth", 2)) {
      /* Set input smoothing factor. */
      int val;

      if (++argn >= argc)	/* advance to next argument */
	usage();
      if (sscanf(argv[argn], "%d", &val) != 1)
	usage();
      if (val < 0 || val > 100)
	usage();
      cinfo->smoothing_factor = val;

    } else if (keymatch(arg, "targa", 1)) {
      /* Input file is Targa format. */
      is_targa = TRUE;

    } else {
      usage();			/* bogus switch */
    }
  }

  /* Post-switch-scanning cleanup */

  if (for_real) {

    /* Set quantization tables for selected quality. */
    /* Some or all may be overridden if -qtables is present. */
    jpeg_set_quality(cinfo, quality, force_baseline);

    if (qtablefile != NULL)	/* process -qtables if it was present */
      if (! read_quant_tables(cinfo, qtablefile,
			      q_scale_factor, force_baseline))
	usage();

    if (qslotsarg != NULL)	/* process -qslots if it was present */
      if (! set_quant_slots(cinfo, qslotsarg))
	usage();

    if (samplearg != NULL)	/* process -sample if it was present */
      if (! set_sample_factors(cinfo, samplearg))
	usage();

#ifdef C_PROGRESSIVE_SUPPORTED
    if (simple_progressive)	/* process -progressive; -scans can override */
      jpeg_simple_progression(cinfo);
#endif

#ifdef C_MULTISCAN_FILES_SUPPORTED
    if (scansarg != NULL)	/* process -scans if it was present */
      if (! read_scan_script(cinfo, scansarg))
	usage();
#endif
  }

  return argn;			/* return index of next arg (file name) */
}


/*
 * The main program.
 */

int
main (int argc, char **argv)
{
  struct jpeg_compress_struct cinfo;
  struct jpeg_error_mgr jerr;
#ifdef PROGRESS_REPORT
  struct cdjpeg_progress_mgr progress;
#endif
  int file_index;
  cjpeg_source_ptr src_mgr;
  FILE * input_file;
  FILE * output_file;
  JDIMENSION num_scanlines;

  /* On Mac, fetch a command line. */
#ifdef USE_CCOMMAND
  argc = ccommand(&argv);
#endif

  progname = argv[0];
  if (progname == NULL || progname[0] == 0)
    progname = "cjpeg";		/* in case C library doesn't provide it */

  /* Initialize the JPEG compression object with default error handling. */
  cinfo.err = jpeg_std_error(&jerr);
  jpeg_create_compress(&cinfo);
  /* Add some application-specific error messages (from cderror.h) */
  jerr.addon_message_table = cdjpeg_message_table;
  jerr.first_addon_message = JMSG_FIRSTADDONCODE;
  jerr.last_addon_message = JMSG_LASTADDONCODE;

  /* Now safe to enable signal catcher. */
#ifdef NEED_SIGNAL_CATCHER
  enable_signal_catcher((j_common_ptr) &cinfo);
#endif

  /* Initialize JPEG parameters.
   * Much of this may be overridden later.
   * In particular, we don't yet know the input file's color space,
   * but we need to provide some value for jpeg_set_defaults() to work.
   */

  cinfo.in_color_space = JCS_RGB; /* arbitrary guess */
  jpeg_set_defaults(&cinfo);

  /* Scan command line to find file names.
   * It is convenient to use just one switch-parsing routine, but the switch
   * values read here are ignored; we will rescan the switches after opening
   * the input file.
   */

  file_index = parse_switches(&cinfo, argc, argv, 0, FALSE);

#ifdef TWO_FILE_COMMANDLINE
  /* Must have either -outfile switch or explicit output file name */
  if (outfilename == NULL) {
    if (file_index != argc-2) {
      fprintf(stderr, "%s: must name one input and one output file\n",
	      progname);
      usage();
    }
    outfilename = argv[file_index+1];
  } else {
    if (file_index != argc-1) {
      fprintf(stderr, "%s: must name one input and one output file\n",
	      progname);
      usage();
    }
  }
#else
  /* Unix style: expect zero or one file name */
  if (file_index < argc-1) {
    fprintf(stderr, "%s: only one input file\n", progname);
    usage();
  }
#endif /* TWO_FILE_COMMANDLINE */

  /* Open the input file. */
  if (file_index < argc) {
    if ((input_file = fopen(argv[file_index], READ_BINARY)) == NULL) {
      fprintf(stderr, "%s: can't open %s\n", progname, argv[file_index]);
      exit(EXIT_FAILURE);
    }
  } else {
    /* default input file is stdin */
    input_file = read_stdin();
  }

  /* Open the output file. */
  if (outfilename != NULL) {
    if ((output_file = fopen(outfilename, WRITE_BINARY)) == NULL) {
      fprintf(stderr, "%s: can't open %s\n", progname, outfilename);
      exit(EXIT_FAILURE);
    }
  } else {
    /* default output file is stdout */
    output_file = write_stdout();
  }

#ifdef PROGRESS_REPORT
  start_progress_monitor((j_common_ptr) &cinfo, &progress);
#endif

  /* Figure out the input file format, and set up to read it. */
  src_mgr = select_file_type(&cinfo, input_file);
  src_mgr->input_file = input_file;

  /* Read the input file header to obtain file size & colorspace. */
  (*src_mgr->start_input) (&cinfo, src_mgr);

  /* Now that we know input colorspace, fix colorspace-dependent defaults */
  jpeg_default_colorspace(&cinfo);

  /* Adjust default compression parameters by re-parsing the options */
  file_index = parse_switches(&cinfo, argc, argv, 0, TRUE);

  /* Specify data destination for compression */
  jpeg_stdio_dest(&cinfo, output_file);

  /* Start compressor */
  jpeg_start_compress(&cinfo, TRUE);

  /* Process data */
  while (cinfo.next_scanline < cinfo.image_height) {
    num_scanlines = (*src_mgr->get_pixel_rows) (&cinfo, src_mgr);
    (void) jpeg_write_scanlines(&cinfo, src_mgr->buffer, num_scanlines);
  }

  /* Finish compression and release memory */
  (*src_mgr->finish_input) (&cinfo, src_mgr);
  jpeg_finish_compress(&cinfo);
  jpeg_destroy_compress(&cinfo);

  /* Close files, if we opened them */
  if (input_file != stdin)
    fclose(input_file);
  if (output_file != stdout)
    fclose(output_file);

#ifdef PROGRESS_REPORT
  end_progress_monitor((j_common_ptr) &cinfo);
#endif

  /* All done. */
  exit(jerr.num_warnings ? EXIT_WARNING : EXIT_SUCCESS);
  return 0;			/* suppress no-return-value warnings */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\ckconfig.c ===
/*
 * ckconfig.c
 *
 * Copyright (C) 1991-1994, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 */

/*
 * This program is intended to help you determine how to configure the JPEG
 * software for installation on a particular system.  The idea is to try to
 * compile and execute this program.  If your compiler fails to compile the
 * program, make changes as indicated in the comments below.  Once you can
 * compile the program, run it, and it will produce a "jconfig.h" file for
 * your system.
 *
 * As a general rule, each time you try to compile this program,
 * pay attention only to the *first* error message you get from the compiler.
 * Many C compilers will issue lots of spurious error messages once they
 * have gotten confused.  Go to the line indicated in the first error message,
 * and read the comments preceding that line to see what to change.
 *
 * Almost all of the edits you may need to make to this program consist of
 * changing a line that reads "#define SOME_SYMBOL" to "#undef SOME_SYMBOL",
 * or vice versa.  This is called defining or undefining that symbol.
 */


/* First we must see if your system has the include files we need.
 * We start out with the assumption that your system has all the ANSI-standard
 * include files.  If you get any error trying to include one of these files,
 * undefine the corresponding HAVE_xxx symbol.
 */

#define HAVE_STDDEF_H		/* replace 'define' by 'undef' if error here */
#ifdef HAVE_STDDEF_H		/* next line will be skipped if you undef... */
#include <stddef.h>
#endif

#define HAVE_STDLIB_H		/* same thing for stdlib.h */
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#include <stdio.h>		/* If you ain't got this, you ain't got C. */

/* We have to see if your string functions are defined by
 * strings.h (old BSD convention) or string.h (everybody else).
 * We try the non-BSD convention first; define NEED_BSD_STRINGS
 * if the compiler says it can't find string.h.
 */

#undef NEED_BSD_STRINGS

#ifdef NEED_BSD_STRINGS
#include <strings.h>
#else
#include <string.h>
#endif

/* On some systems (especially older Unix machines), type size_t is
 * defined only in the include file <sys/types.h>.  If you get a failure
 * on the size_t test below, try defining NEED_SYS_TYPES_H.
 */

#undef NEED_SYS_TYPES_H		/* start by assuming we don't need it */
#ifdef NEED_SYS_TYPES_H
#include <sys/types.h>
#endif


/* Usually type size_t is defined in one of the include files we've included
 * above.  If not, you'll get an error on the "typedef size_t my_size_t;" line.
 * In that case, first try defining NEED_SYS_TYPES_H just above.
 * If that doesn't work, you'll have to search through your system library
 * to figure out which include file defines "size_t".  Look for a line that
 * says "typedef something-or-other size_t;".  Then, change the line below
 * that says "#include <someincludefile.h>" to instead include the file
 * you found size_t in, and define NEED_SPECIAL_INCLUDE.  If you can't find
 * type size_t anywhere, try replacing "#include <someincludefile.h>" with
 * "typedef unsigned int size_t;".
 */

#undef NEED_SPECIAL_INCLUDE	/* assume we DON'T need it, for starters */

#ifdef NEED_SPECIAL_INCLUDE
#include <someincludefile.h>
#endif

typedef size_t my_size_t;	/* The payoff: do we have size_t now? */


/* The next question is whether your compiler supports ANSI-style function
 * prototypes.  You need to know this in order to choose between using
 * makefile.ansi and using makefile.unix.
 * The #define line below is set to assume you have ANSI function prototypes.
 * If you get an error in this group of lines, undefine HAVE_PROTOTYPES.
 */

#define HAVE_PROTOTYPES

#ifdef HAVE_PROTOTYPES
int testfunction (int arg1, int * arg2); /* check prototypes */

struct methods_struct {		/* check method-pointer declarations */
  int (*error_exit) (char *msgtext);
  int (*trace_message) (char *msgtext);
  int (*another_method) (void);
};

int testfunction (int arg1, int * arg2) /* check definitions */
{
  return arg2[arg1];
}

int test2function (void)	/* check void arg list */
{
  return 0;
}
#endif


/* Now we want to find out if your compiler knows what "unsigned char" means.
 * If you get an error on the "unsigned char un_char;" line,
 * then undefine HAVE_UNSIGNED_CHAR.
 */

#define HAVE_UNSIGNED_CHAR

#ifdef HAVE_UNSIGNED_CHAR
unsigned char un_char;
#endif


/* Now we want to find out if your compiler knows what "unsigned short" means.
 * If you get an error on the "unsigned short un_short;" line,
 * then undefine HAVE_UNSIGNED_SHORT.
 */

#define HAVE_UNSIGNED_SHORT

#ifdef HAVE_UNSIGNED_SHORT
unsigned short un_short;
#endif


/* Now we want to find out if your compiler understands type "void".
 * If you get an error anywhere in here, undefine HAVE_VOID.
 */

#define HAVE_VOID

#ifdef HAVE_VOID
/* Caution: a C++ compiler will insist on complete prototypes */
typedef void * void_ptr;	/* check void * */
#ifdef HAVE_PROTOTYPES		/* check ptr to function returning void */
typedef void (*void_func) (int a, int b);
#else
typedef void (*void_func) ();
#endif

#ifdef HAVE_PROTOTYPES		/* check void function result */
void test3function (void_ptr arg1, void_func arg2)
#else
void test3function (arg1, arg2)
     void_ptr arg1;
     void_func arg2;
#endif
{
  char * locptr = (char *) arg1; /* check casting to and from void * */
  arg1 = (void *) locptr;
  (*arg2) (1, 2);		/* check call of fcn returning void */
}
#endif


/* Now we want to find out if your compiler knows what "const" means.
 * If you get an error here, undefine HAVE_CONST.
 */

#define HAVE_CONST

#ifdef HAVE_CONST
static const int carray[3] = {1, 2, 3};

#ifdef HAVE_PROTOTYPES
int test4function (const int arg1)
#else
int test4function (arg1)
     const int arg1;
#endif
{
  return carray[arg1];
}
#endif


/* If you get an error or warning about this structure definition,
 * define INCOMPLETE_TYPES_BROKEN.
 */

#undef INCOMPLETE_TYPES_BROKEN

#ifndef INCOMPLETE_TYPES_BROKEN
typedef struct undefined_structure * undef_struct_ptr;
#endif


/* If you get an error about duplicate names,
 * define NEED_SHORT_EXTERNAL_NAMES.
 */

#undef NEED_SHORT_EXTERNAL_NAMES

#ifndef NEED_SHORT_EXTERNAL_NAMES

int possibly_duplicate_function ()
{
  return 0;
}

int possibly_dupli_function ()
{
  return 1;
}

#endif



/************************************************************************
 *  OK, that's it.  You should not have to change anything beyond this
 *  point in order to compile and execute this program.  (You might get
 *  some warnings, but you can ignore them.)
 *  When you run the program, it will make a couple more tests that it
 *  can do automatically, and then it will create jconfig.h and print out
 *  any additional suggestions it has.
 ************************************************************************
 */


#ifdef HAVE_PROTOTYPES
int is_char_signed (int arg)
#else
int is_char_signed (arg)
     int arg;
#endif
{
  if (arg == 189) {		/* expected result for unsigned char */
    return 0;			/* type char is unsigned */
  }
  else if (arg != -67) {	/* expected result for signed char */
    printf("Hmm, it seems 'char' is not eight bits wide on your machine.\n");
    printf("I fear the JPEG software will not work at all.\n\n");
  }
  return 1;			/* assume char is signed otherwise */
}


#ifdef HAVE_PROTOTYPES
int is_shifting_signed (long arg)
#else
int is_shifting_signed (arg)
     long arg;
#endif
/* See whether right-shift on a long is signed or not. */
{
  long res = arg >> 4;

  if (res == -0x7F7E80CL) {	/* expected result for signed shift */
    return 1;			/* right shift is signed */
  }
  /* see if unsigned-shift hack will fix it. */
  /* we can't just test exact value since it depends on width of long... */
  res |= (~0L) << (32-4);
  if (res == -0x7F7E80CL) {	/* expected result now? */
    return 0;			/* right shift is unsigned */
  }
  printf("Right shift isn't acting as I expect it to.\n");
  printf("I fear the JPEG software will not work at all.\n\n");
  return 0;			/* try it with unsigned anyway */
}


#ifdef HAVE_PROTOTYPES
int main (int argc, char ** argv)
#else
int main (argc, argv)
     int argc;
     char ** argv;
#endif
{
  char signed_char_check = (char) (-67);
  FILE *outfile;

  /* Attempt to write jconfig.h */
  if ((outfile = fopen("jconfig.h", "w")) == NULL) {
    printf("Failed to write jconfig.h\n");
    return 1;
  }

  /* Write out all the info */
  fprintf(outfile, "/* jconfig.h --- generated by ckconfig.c */\n");
  fprintf(outfile, "/* see jconfig.doc for explanations */\n\n");
#ifdef HAVE_PROTOTYPES
  fprintf(outfile, "#define HAVE_PROTOTYPES\n");
#else
  fprintf(outfile, "#undef HAVE_PROTOTYPES\n");
#endif
#ifdef HAVE_UNSIGNED_CHAR
  fprintf(outfile, "#define HAVE_UNSIGNED_CHAR\n");
#else
  fprintf(outfile, "#undef HAVE_UNSIGNED_CHAR\n");
#endif
#ifdef HAVE_UNSIGNED_SHORT
  fprintf(outfile, "#define HAVE_UNSIGNED_SHORT\n");
#else
  fprintf(outfile, "#undef HAVE_UNSIGNED_SHORT\n");
#endif
#ifdef HAVE_VOID
  fprintf(outfile, "/* #define void char */\n");
#else
  fprintf(outfile, "#define void char\n");
#endif
#ifdef HAVE_CONST
  fprintf(outfile, "/* #define const */\n");
#else
  fprintf(outfile, "#define const\n");
#endif
  if (is_char_signed((int) signed_char_check))
    fprintf(outfile, "#undef CHAR_IS_UNSIGNED\n");
  else
    fprintf(outfile, "#define CHAR_IS_UNSIGNED\n");
#ifdef HAVE_STDDEF_H
  fprintf(outfile, "#define HAVE_STDDEF_H\n");
#else
  fprintf(outfile, "#undef HAVE_STDDEF_H\n");
#endif
#ifdef HAVE_STDLIB_H
  fprintf(outfile, "#define HAVE_STDLIB_H\n");
#else
  fprintf(outfile, "#undef HAVE_STDLIB_H\n");
#endif
#ifdef NEED_BSD_STRINGS
  fprintf(outfile, "#define NEED_BSD_STRINGS\n");
#else
  fprintf(outfile, "#undef NEED_BSD_STRINGS\n");
#endif
#ifdef NEED_SYS_TYPES_H
  fprintf(outfile, "#define NEED_SYS_TYPES_H\n");
#else
  fprintf(outfile, "#undef NEED_SYS_TYPES_H\n");
#endif
  fprintf(outfile, "#undef NEED_FAR_POINTERS\n");
#ifdef NEED_SHORT_EXTERNAL_NAMES
  fprintf(outfile, "#define NEED_SHORT_EXTERNAL_NAMES\n");
#else
  fprintf(outfile, "#undef NEED_SHORT_EXTERNAL_NAMES\n");
#endif
#ifdef INCOMPLETE_TYPES_BROKEN
  fprintf(outfile, "#define INCOMPLETE_TYPES_BROKEN\n");
#else
  fprintf(outfile, "#undef INCOMPLETE_TYPES_BROKEN\n");
#endif
  fprintf(outfile, "\n#ifdef JPEG_INTERNALS\n\n");
  if (is_shifting_signed(-0x7F7E80B1L))
    fprintf(outfile, "#undef RIGHT_SHIFT_IS_UNSIGNED\n");
  else
    fprintf(outfile, "#define RIGHT_SHIFT_IS_UNSIGNED\n");
  fprintf(outfile, "\n#endif /* JPEG_INTERNALS */\n");
  fprintf(outfile, "\n#ifdef JPEG_CJPEG_DJPEG\n\n");
  fprintf(outfile, "#define BMP_SUPPORTED		/* BMP image file format */\n");
  fprintf(outfile, "#define GIF_SUPPORTED		/* GIF image file format */\n");
  fprintf(outfile, "#define PPM_SUPPORTED		/* PBMPLUS PPM/PGM image file format */\n");
  fprintf(outfile, "#undef RLE_SUPPORTED		/* Utah RLE image file format */\n");
  fprintf(outfile, "#define TARGA_SUPPORTED		/* Targa image file format */\n\n");
  fprintf(outfile, "#undef TWO_FILE_COMMANDLINE	/* You may need this on non-Unix systems */\n");
  fprintf(outfile, "#undef NEED_SIGNAL_CATCHER	/* Define this if you use jmemname.c */\n");
  fprintf(outfile, "#undef DONT_USE_B_MODE\n");
  fprintf(outfile, "/* #define PROGRESS_REPORT */	/* optional */\n");
  fprintf(outfile, "\n#endif /* JPEG_CJPEG_DJPEG */\n");

  /* Close the jconfig.h file */
  fclose(outfile);

  /* User report */
  printf("Configuration check for Independent JPEG Group's software done.\n");
  printf("\nI have written the jconfig.h file for you.\n\n");
#ifdef HAVE_PROTOTYPES
  printf("You should use makefile.ansi as the starting point for your Makefile.\n");
#else
  printf("You should use makefile.unix as the starting point for your Makefile.\n");
#endif

#ifdef NEED_SPECIAL_INCLUDE
  printf("\nYou'll need to change jconfig.h to include the system include file\n");
  printf("that you found type size_t in, or add a direct definition of type\n");
  printf("size_t if that's what you used.  Just add it to the end.\n");
#endif

  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\jcapistd.c ===
/*
 * jcapistd.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains application interface code for the compression half
 * of the JPEG library.  These are the "standard" API routines that are
 * used in the normal full-compression case.  They are not used by a
 * transcoding-only application.  Note that if an application links in
 * jpeg_start_compress, it will end up linking in the entire compressor.
 * We thus must separate this file from jcapimin.c to avoid linking the
 * whole compression library into a transcoder.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/*
 * Compression initialization.
 * Before calling this, all parameters and a data destination must be set up.
 *
 * We require a write_all_tables parameter as a failsafe check when writing
 * multiple datastreams from the same compression object.  Since prior runs
 * will have left all the tables marked sent_table=TRUE, a subsequent run
 * would emit an abbreviated stream (no tables) by default.  This may be what
 * is wanted, but for safety's sake it should not be the default behavior:
 * programmers should have to make a deliberate choice to emit abbreviated
 * images.  Therefore the documentation and examples should encourage people
 * to pass write_all_tables=TRUE; then it will take active thought to do the
 * wrong thing.
 */

GLOBAL(void)
jpeg_start_compress (j_compress_ptr cinfo, boolean write_all_tables)
{
  if (cinfo->global_state != CSTATE_START)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);

  if (write_all_tables)
    jpeg_suppress_tables(cinfo, FALSE);	/* mark all tables to be written */

  /* (Re)initialize error mgr and destination modules */
  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
  (*cinfo->dest->init_destination) (cinfo);
  /* Perform master selection of active modules */
  jinit_compress_master(cinfo);
  /* Set up for the first pass */
  (*cinfo->master->prepare_for_pass) (cinfo);
  /* Ready for application to drive first pass through jpeg_write_scanlines
   * or jpeg_write_raw_data.
   */
  cinfo->next_scanline = 0;
  cinfo->global_state = (cinfo->raw_data_in ? CSTATE_RAW_OK : CSTATE_SCANNING);
}


/*
 * Write some scanlines of data to the JPEG compressor.
 *
 * The return value will be the number of lines actually written.
 * This should be less than the supplied num_lines only in case that
 * the data destination module has requested suspension of the compressor,
 * or if more than image_height scanlines are passed in.
 *
 * Note: we warn about excess calls to jpeg_write_scanlines() since
 * this likely signals an application programmer error.  However,
 * excess scanlines passed in the last valid call are *silently* ignored,
 * so that the application need not adjust num_lines for end-of-image
 * when using a multiple-scanline buffer.
 */

GLOBAL(JDIMENSION)
jpeg_write_scanlines (j_compress_ptr cinfo, JSAMPARRAY scanlines,
		      JDIMENSION num_lines)
{
  JDIMENSION row_ctr, rows_left;

  if (cinfo->global_state != CSTATE_SCANNING)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  if (cinfo->next_scanline >= cinfo->image_height)
    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);

  /* Call progress monitor hook if present */
  if (cinfo->progress != NULL) {
    cinfo->progress->pass_counter = (long) cinfo->next_scanline;
    cinfo->progress->pass_limit = (long) cinfo->image_height;
    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
  }

  /* Give master control module another chance if this is first call to
   * jpeg_write_scanlines.  This lets output of the frame/scan headers be
   * delayed so that application can write COM, etc, markers between
   * jpeg_start_compress and jpeg_write_scanlines.
   */
  if (cinfo->master->call_pass_startup)
    (*cinfo->master->pass_startup) (cinfo);

  /* Ignore any extra scanlines at bottom of image. */
  rows_left = cinfo->image_height - cinfo->next_scanline;
  if (num_lines > rows_left)
    num_lines = rows_left;

  row_ctr = 0;
  (*cinfo->main->process_data) (cinfo, scanlines, &row_ctr, num_lines);
  cinfo->next_scanline += row_ctr;
  return row_ctr;
}


/*
 * Alternate entry point to write raw data.
 * Processes exactly one iMCU row per call, unless suspended.
 */

GLOBAL(JDIMENSION)
jpeg_write_raw_data (j_compress_ptr cinfo, JSAMPIMAGE data,
		     JDIMENSION num_lines)
{
  JDIMENSION lines_per_iMCU_row;

  if (cinfo->global_state != CSTATE_RAW_OK)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  if (cinfo->next_scanline >= cinfo->image_height) {
    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);
    return 0;
  }

  /* Call progress monitor hook if present */
  if (cinfo->progress != NULL) {
    cinfo->progress->pass_counter = (long) cinfo->next_scanline;
    cinfo->progress->pass_limit = (long) cinfo->image_height;
    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
  }

  /* Give master control module another chance if this is first call to
   * jpeg_write_raw_data.  This lets output of the frame/scan headers be
   * delayed so that application can write COM, etc, markers between
   * jpeg_start_compress and jpeg_write_raw_data.
   */
  if (cinfo->master->call_pass_startup)
    (*cinfo->master->pass_startup) (cinfo);

  /* Verify that at least one iMCU row has been passed. */
  lines_per_iMCU_row = cinfo->max_v_samp_factor * DCTSIZE;
  if (num_lines < lines_per_iMCU_row)
    ERREXIT(cinfo, JERR_BUFFER_SIZE);

  /* Directly compress the row. */
  if (! (*cinfo->coef->compress_data) (cinfo, data)) {
    /* If compressor did not consume the whole row, suspend processing. */
    return 0;
  }

  /* OK, we processed one iMCU row. */
  cinfo->next_scanline += lines_per_iMCU_row;
  return lines_per_iMCU_row;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\jcinit.c ===
/*
 * jcinit.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains initialization logic for the JPEG compressor.
 * This routine is in charge of selecting the modules to be executed and
 * making an initialization call to each one.
 *
 * Logically, this code belongs in jcmaster.c.  It's split out because
 * linking this routine implies linking the entire compression library.
 * For a transcoding-only application, we want to be able to use jcmaster.c
 * without linking in the whole library.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/*
 * Master selection of compression modules.
 * This is done once at the start of processing an image.  We determine
 * which modules will be used and give them appropriate initialization calls.
 */

GLOBAL(void)
jinit_compress_master (j_compress_ptr cinfo)
{
  /* Initialize master control (includes parameter checking/processing) */
  jinit_c_master_control(cinfo, FALSE /* full compression */);

  /* Preprocessing */
  if (! cinfo->raw_data_in) {
    jinit_color_converter(cinfo);
    jinit_downsampler(cinfo);
    jinit_c_prep_controller(cinfo, FALSE /* never need full buffer here */);
  }
  /* Forward DCT */
  jinit_forward_dct(cinfo);
  /* Entropy encoding: either Huffman or arithmetic coding. */
  if (cinfo->arith_code) {
    ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
  } else {
    if (cinfo->progressive_mode) {
#ifdef C_PROGRESSIVE_SUPPORTED
      jinit_phuff_encoder(cinfo);
#else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
    } else
      jinit_huff_encoder(cinfo);
  }

  /* Need a full-image coefficient buffer in any multi-pass mode. */
  jinit_c_coef_controller(cinfo,
			  (cinfo->num_scans > 1 || cinfo->optimize_coding));
  jinit_c_main_controller(cinfo, FALSE /* never need full buffer here */);

  jinit_marker_writer(cinfo);

  /* We can now tell the memory manager to allocate virtual arrays. */
  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);

  /* Write the datastream header (SOI) immediately.
   * Frame and scan headers are postponed till later.
   * This lets application insert special markers after the SOI.
   */
  (*cinfo->marker->write_file_header) (cinfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\jccolor.c ===
/*
 * jccolor.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains input colorspace conversion routines.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/* Private subobject */

typedef struct {
  struct jpeg_color_converter pub; /* public fields */

  /* Private state for RGB->YCC conversion */
  INT32 * rgb_ycc_tab;		/* => table for RGB to YCbCr conversion */
} my_color_converter;

typedef my_color_converter * my_cconvert_ptr;


/**************** RGB -> YCbCr conversion: most common case **************/

/*
 * YCbCr is defined per CCIR 601-1, except that Cb and Cr are
 * normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.
 * The conversion equations to be implemented are therefore
 *	Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
 *	Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B  + CENTERJSAMPLE
 *	Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B  + CENTERJSAMPLE
 * (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.)
 * Note: older versions of the IJG code used a zero offset of MAXJSAMPLE/2,
 * rather than CENTERJSAMPLE, for Cb and Cr.  This gave equal positive and
 * negative swings for Cb/Cr, but meant that grayscale values (Cb=Cr=0)
 * were not represented exactly.  Now we sacrifice exact representation of
 * maximum red and maximum blue in order to get exact grayscales.
 *
 * To avoid floating-point arithmetic, we represent the fractional constants
 * as integers scaled up by 2^16 (about 4 digits precision); we have to divide
 * the products by 2^16, with appropriate rounding, to get the correct answer.
 *
 * For even more speed, we avoid doing any multiplications in the inner loop
 * by precalculating the constants times R,G,B for all possible values.
 * For 8-bit JSAMPLEs this is very reasonable (only 256 entries per table);
 * for 12-bit samples it is still acceptable.  It's not very reasonable for
 * 16-bit samples, but if you want lossless storage you shouldn't be changing
 * colorspace anyway.
 * The CENTERJSAMPLE offsets and the rounding fudge-factor of 0.5 are included
 * in the tables to save adding them separately in the inner loop.
 */

#define SCALEBITS	16	/* speediest right-shift on some machines */
#define CBCR_OFFSET	((INT32) CENTERJSAMPLE << SCALEBITS)
#define ONE_HALF	((INT32) 1 << (SCALEBITS-1))
#define FIX(x)		((INT32) ((x) * (1L<<SCALEBITS) + 0.5))

/* We allocate one big table and divide it up into eight parts, instead of
 * doing eight alloc_small requests.  This lets us use a single table base
 * address, which can be held in a register in the inner loops on many
 * machines (more than can hold all eight addresses, anyway).
 */

#define R_Y_OFF		0			/* offset to R => Y section */
#define G_Y_OFF		(1*(MAXJSAMPLE+1))	/* offset to G => Y section */
#define B_Y_OFF		(2*(MAXJSAMPLE+1))	/* etc. */
#define R_CB_OFF	(3*(MAXJSAMPLE+1))
#define G_CB_OFF	(4*(MAXJSAMPLE+1))
#define B_CB_OFF	(5*(MAXJSAMPLE+1))
#define R_CR_OFF	B_CB_OFF		/* B=>Cb, R=>Cr are the same */
#define G_CR_OFF	(6*(MAXJSAMPLE+1))
#define B_CR_OFF	(7*(MAXJSAMPLE+1))
#define TABLE_SIZE	(8*(MAXJSAMPLE+1))


/*
 * Initialize for RGB->YCC colorspace conversion.
 */

METHODDEF(void)
rgb_ycc_start (j_compress_ptr cinfo)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  INT32 * rgb_ycc_tab;
  INT32 i;

  /* Allocate and fill in the conversion tables. */
  cconvert->rgb_ycc_tab = rgb_ycc_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(TABLE_SIZE * SIZEOF(INT32)));

  for (i = 0; i <= MAXJSAMPLE; i++) {
    rgb_ycc_tab[i+R_Y_OFF] = FIX(0.29900) * i;
    rgb_ycc_tab[i+G_Y_OFF] = FIX(0.58700) * i;
    rgb_ycc_tab[i+B_Y_OFF] = FIX(0.11400) * i     + ONE_HALF;
    rgb_ycc_tab[i+R_CB_OFF] = (-FIX(0.16874)) * i;
    rgb_ycc_tab[i+G_CB_OFF] = (-FIX(0.33126)) * i;
    /* We use a rounding fudge-factor of 0.5-epsilon for Cb and Cr.
     * This ensures that the maximum output will round to MAXJSAMPLE
     * not MAXJSAMPLE+1, and thus that we don't have to range-limit.
     */
    rgb_ycc_tab[i+B_CB_OFF] = FIX(0.50000) * i    + CBCR_OFFSET + ONE_HALF-1;
/*  B=>Cb and R=>Cr tables are the same
    rgb_ycc_tab[i+R_CR_OFF] = FIX(0.50000) * i    + CBCR_OFFSET + ONE_HALF-1;
*/
    rgb_ycc_tab[i+G_CR_OFF] = (-FIX(0.41869)) * i;
    rgb_ycc_tab[i+B_CR_OFF] = (-FIX(0.08131)) * i;
  }
}


/*
 * Convert some rows of samples to the JPEG colorspace.
 *
 * Note that we change from the application's interleaved-pixel format
 * to our internal noninterleaved, one-plane-per-component format.
 * The input buffer is therefore three times as wide as the output buffer.
 *
 * A starting row offset is provided only for the output buffer.  The caller
 * can easily adjust the passed input_buf value to accommodate any row
 * offset required on that side.
 */

METHODDEF(void)
rgb_ycc_convert (j_compress_ptr cinfo,
		 JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
		 JDIMENSION output_row, int num_rows)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  register int r, g, b;
  register INT32 * ctab = cconvert->rgb_ycc_tab;
  register JSAMPROW inptr;
  register JSAMPROW outptr0, outptr1, outptr2;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->image_width;

  while (--num_rows >= 0) {
    inptr = *input_buf++;
    outptr0 = output_buf[0][output_row];
    outptr1 = output_buf[1][output_row];
    outptr2 = output_buf[2][output_row];
    output_row++;
    for (col = 0; col < num_cols; col++) {
      r = GETJSAMPLE(inptr[RGB_RED]);
      g = GETJSAMPLE(inptr[RGB_GREEN]);
      b = GETJSAMPLE(inptr[RGB_BLUE]);
      inptr += RGB_PIXELSIZE;
      /* If the inputs are 0..MAXJSAMPLE, the outputs of these equations
       * must be too; we do not need an explicit range-limiting operation.
       * Hence the value being shifted is never negative, and we don't
       * need the general RIGHT_SHIFT macro.
       */
      /* Y */
      outptr0[col] = (JSAMPLE)
		((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
		 >> SCALEBITS);
      /* Cb */
      outptr1[col] = (JSAMPLE)
		((ctab[r+R_CB_OFF] + ctab[g+G_CB_OFF] + ctab[b+B_CB_OFF])
		 >> SCALEBITS);
      /* Cr */
      outptr2[col] = (JSAMPLE)
		((ctab[r+R_CR_OFF] + ctab[g+G_CR_OFF] + ctab[b+B_CR_OFF])
		 >> SCALEBITS);
    }
  }
}


/**************** Cases other than RGB -> YCbCr **************/


/*
 * Convert some rows of samples to the JPEG colorspace.
 * This version handles RGB->grayscale conversion, which is the same
 * as the RGB->Y portion of RGB->YCbCr.
 * We assume rgb_ycc_start has been called (we only use the Y tables).
 */

METHODDEF(void)
rgb_gray_convert (j_compress_ptr cinfo,
		  JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
		  JDIMENSION output_row, int num_rows)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  register int r, g, b;
  register INT32 * ctab = cconvert->rgb_ycc_tab;
  register JSAMPROW inptr;
  register JSAMPROW outptr;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->image_width;

  while (--num_rows >= 0) {
    inptr = *input_buf++;
    outptr = output_buf[0][output_row];
    output_row++;
    for (col = 0; col < num_cols; col++) {
      r = GETJSAMPLE(inptr[RGB_RED]);
      g = GETJSAMPLE(inptr[RGB_GREEN]);
      b = GETJSAMPLE(inptr[RGB_BLUE]);
      inptr += RGB_PIXELSIZE;
      /* Y */
      outptr[col] = (JSAMPLE)
		((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
		 >> SCALEBITS);
    }
  }
}


/*
 * Convert some rows of samples to the JPEG colorspace.
 * This version handles Adobe-style CMYK->YCCK conversion,
 * where we convert R=1-C, G=1-M, and B=1-Y to YCbCr using the same
 * conversion as above, while passing K (black) unchanged.
 * We assume rgb_ycc_start has been called.
 */

METHODDEF(void)
cmyk_ycck_convert (j_compress_ptr cinfo,
		   JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
		   JDIMENSION output_row, int num_rows)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  register int r, g, b;
  register INT32 * ctab = cconvert->rgb_ycc_tab;
  register JSAMPROW inptr;
  register JSAMPROW outptr0, outptr1, outptr2, outptr3;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->image_width;

  while (--num_rows >= 0) {
    inptr = *input_buf++;
    outptr0 = output_buf[0][output_row];
    outptr1 = output_buf[1][output_row];
    outptr2 = output_buf[2][output_row];
    outptr3 = output_buf[3][output_row];
    output_row++;
    for (col = 0; col < num_cols; col++) {
      r = MAXJSAMPLE - GETJSAMPLE(inptr[0]);
      g = MAXJSAMPLE - GETJSAMPLE(inptr[1]);
      b = MAXJSAMPLE - GETJSAMPLE(inptr[2]);
      /* K passes through as-is */
      outptr3[col] = inptr[3];	/* don't need GETJSAMPLE here */
      inptr += 4;
      /* If the inputs are 0..MAXJSAMPLE, the outputs of these equations
       * must be too; we do not need an explicit range-limiting operation.
       * Hence the value being shifted is never negative, and we don't
       * need the general RIGHT_SHIFT macro.
       */
      /* Y */
      outptr0[col] = (JSAMPLE)
		((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
		 >> SCALEBITS);
      /* Cb */
      outptr1[col] = (JSAMPLE)
		((ctab[r+R_CB_OFF] + ctab[g+G_CB_OFF] + ctab[b+B_CB_OFF])
		 >> SCALEBITS);
      /* Cr */
      outptr2[col] = (JSAMPLE)
		((ctab[r+R_CR_OFF] + ctab[g+G_CR_OFF] + ctab[b+B_CR_OFF])
		 >> SCALEBITS);
    }
  }
}


/*
 * Convert some rows of samples to the JPEG colorspace.
 * This version handles grayscale output with no conversion.
 * The source can be either plain grayscale or YCbCr (since Y == gray).
 */

METHODDEF(void)
grayscale_convert (j_compress_ptr cinfo,
		   JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
		   JDIMENSION output_row, int num_rows)
{
  register JSAMPROW inptr;
  register JSAMPROW outptr;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->image_width;
  int instride = cinfo->input_components;

  while (--num_rows >= 0) {
    inptr = *input_buf++;
    outptr = output_buf[0][output_row];
    output_row++;
    for (col = 0; col < num_cols; col++) {
      outptr[col] = inptr[0];	/* don't need GETJSAMPLE() here */
      inptr += instride;
    }
  }
}


/*
 * Convert some rows of samples to the JPEG colorspace.
 * This version handles multi-component colorspaces without conversion.
 * We assume input_components == num_components.
 */

METHODDEF(void)
null_convert (j_compress_ptr cinfo,
	      JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
	      JDIMENSION output_row, int num_rows)
{
  register JSAMPROW inptr;
  register JSAMPROW outptr;
  register JDIMENSION col;
  register int ci;
  int nc = cinfo->num_components;
  JDIMENSION num_cols = cinfo->image_width;

  while (--num_rows >= 0) {
    /* It seems fastest to make a separate pass for each component. */
    for (ci = 0; ci < nc; ci++) {
      inptr = *input_buf;
      outptr = output_buf[ci][output_row];
      for (col = 0; col < num_cols; col++) {
	outptr[col] = inptr[ci]; /* don't need GETJSAMPLE() here */
	inptr += nc;
      }
    }
    input_buf++;
    output_row++;
  }
}


/*
 * Empty method for start_pass.
 */

METHODDEF(void)
null_method (j_compress_ptr cinfo)
{
  /* no work needed */
}


/*
 * Module initialization routine for input colorspace conversion.
 */

GLOBAL(void)
jinit_color_converter (j_compress_ptr cinfo)
{
  my_cconvert_ptr cconvert;

  cconvert = (my_cconvert_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_color_converter));
  cinfo->cconvert = (struct jpeg_color_converter *) cconvert;
  /* set start_pass to null method until we find out differently */
  cconvert->pub.start_pass = null_method;

  /* Make sure input_components agrees with in_color_space */
  switch (cinfo->in_color_space) {
  case JCS_GRAYSCALE:
    if (cinfo->input_components != 1)
      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
    break;

  case JCS_RGB:
#if RGB_PIXELSIZE != 3
    if (cinfo->input_components != RGB_PIXELSIZE)
      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
    break;
#endif /* else share code with YCbCr */

  case JCS_YCbCr:
    if (cinfo->input_components != 3)
      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
    break;

  case JCS_CMYK:
  case JCS_YCCK:
    if (cinfo->input_components != 4)
      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
    break;

  default:			/* JCS_UNKNOWN can be anything */
    if (cinfo->input_components < 1)
      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
    break;
  }

  /* Check num_components, set conversion method based on requested space */
  switch (cinfo->jpeg_color_space) {
  case JCS_GRAYSCALE:
    if (cinfo->num_components != 1)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    if (cinfo->in_color_space == JCS_GRAYSCALE)
      cconvert->pub.color_convert = grayscale_convert;
    else if (cinfo->in_color_space == JCS_RGB) {
      cconvert->pub.start_pass = rgb_ycc_start;
      cconvert->pub.color_convert = rgb_gray_convert;
    } else if (cinfo->in_color_space == JCS_YCbCr)
      cconvert->pub.color_convert = grayscale_convert;
    else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;

  case JCS_RGB:
    if (cinfo->num_components != 3)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    if (cinfo->in_color_space == JCS_RGB && RGB_PIXELSIZE == 3)
      cconvert->pub.color_convert = null_convert;
    else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;

  case JCS_YCbCr:
    if (cinfo->num_components != 3)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    if (cinfo->in_color_space == JCS_RGB) {
      cconvert->pub.start_pass = rgb_ycc_start;
      cconvert->pub.color_convert = rgb_ycc_convert;
    } else if (cinfo->in_color_space == JCS_YCbCr)
      cconvert->pub.color_convert = null_convert;
    else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;

  case JCS_CMYK:
    if (cinfo->num_components != 4)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    if (cinfo->in_color_space == JCS_CMYK)
      cconvert->pub.color_convert = null_convert;
    else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;

  case JCS_YCCK:
    if (cinfo->num_components != 4)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    if (cinfo->in_color_space == JCS_CMYK) {
      cconvert->pub.start_pass = rgb_ycc_start;
      cconvert->pub.color_convert = cmyk_ycck_convert;
    } else if (cinfo->in_color_space == JCS_YCCK)
      cconvert->pub.color_convert = null_convert;
    else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;

  default:			/* allow null conversion of JCS_UNKNOWN */
    if (cinfo->jpeg_color_space != cinfo->in_color_space ||
	cinfo->num_components != cinfo->input_components)
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    cconvert->pub.color_convert = null_convert;
    break;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\jchuff.c ===
/*
 * jchuff.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains Huffman entropy encoding routines.
 *
 * Much of the complexity here has to do with supporting output suspension.
 * If the data destination module demands suspension, we want to be able to
 * back up to the start of the current MCU.  To do this, we copy state
 * variables into local working storage, and update them back to the
 * permanent JPEG objects only upon successful completion of an MCU.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"
#include "jchuff.h"		/* Declarations shared with jcphuff.c */


/* Expanded entropy encoder object for Huffman encoding.
 *
 * The savable_state subrecord contains fields that change within an MCU,
 * but must not be updated permanently until we complete the MCU.
 */

typedef struct {
  INT32 put_buffer;		/* current bit-accumulation buffer */
  int put_bits;			/* # of bits now in it */
  int last_dc_val[MAX_COMPS_IN_SCAN]; /* last DC coef for each component */
} savable_state;

/* This macro is to work around compilers with missing or broken
 * structure assignment.  You'll need to fix this code if you have
 * such a compiler and you change MAX_COMPS_IN_SCAN.
 */

#ifndef NO_STRUCT_ASSIGN
#define ASSIGN_STATE(dest,src)  ((dest) = (src))
#else
#if MAX_COMPS_IN_SCAN == 4
#define ASSIGN_STATE(dest,src)  \
	((dest).put_buffer = (src).put_buffer, \
	 (dest).put_bits = (src).put_bits, \
	 (dest).last_dc_val[0] = (src).last_dc_val[0], \
	 (dest).last_dc_val[1] = (src).last_dc_val[1], \
	 (dest).last_dc_val[2] = (src).last_dc_val[2], \
	 (dest).last_dc_val[3] = (src).last_dc_val[3])
#endif
#endif


typedef struct {
  struct jpeg_entropy_encoder pub; /* public fields */

  savable_state saved;		/* Bit buffer & DC state at start of MCU */

  /* These fields are NOT loaded into local working state. */
  unsigned int restarts_to_go;	/* MCUs left in this restart interval */
  int next_restart_num;		/* next restart number to write (0-7) */

  /* Pointers to derived tables (these workspaces have image lifespan) */
  c_derived_tbl * dc_derived_tbls[NUM_HUFF_TBLS];
  c_derived_tbl * ac_derived_tbls[NUM_HUFF_TBLS];

#ifdef ENTROPY_OPT_SUPPORTED	/* Statistics tables for optimization */
  long * dc_count_ptrs[NUM_HUFF_TBLS];
  long * ac_count_ptrs[NUM_HUFF_TBLS];
#endif
} huff_entropy_encoder;

typedef huff_entropy_encoder * huff_entropy_ptr;

/* Working state while writing an MCU.
 * This struct contains all the fields that are needed by subroutines.
 */

typedef struct {
  JOCTET * next_output_byte;	/* => next byte to write in buffer */
  size_t free_in_buffer;	/* # of byte spaces remaining in buffer */
  savable_state cur;		/* Current bit buffer & DC state */
  j_compress_ptr cinfo;		/* dump_buffer needs access to this */
} working_state;


/* Forward declarations */
METHODDEF(boolean) encode_mcu_huff JPP((j_compress_ptr cinfo,
					JBLOCKROW *MCU_data));
METHODDEF(void) finish_pass_huff JPP((j_compress_ptr cinfo));
#ifdef ENTROPY_OPT_SUPPORTED
METHODDEF(boolean) encode_mcu_gather JPP((j_compress_ptr cinfo,
					  JBLOCKROW *MCU_data));
METHODDEF(void) finish_pass_gather JPP((j_compress_ptr cinfo));
#endif


/*
 * Initialize for a Huffman-compressed scan.
 * If gather_statistics is TRUE, we do not output anything during the scan,
 * just count the Huffman symbols used and generate Huffman code tables.
 */

METHODDEF(void)
start_pass_huff (j_compress_ptr cinfo, boolean gather_statistics)
{
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
  int ci, dctbl, actbl;
  jpeg_component_info * compptr;

  if (gather_statistics) {
#ifdef ENTROPY_OPT_SUPPORTED
    entropy->pub.encode_mcu = encode_mcu_gather;
    entropy->pub.finish_pass = finish_pass_gather;
#else
    ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
  } else {
    entropy->pub.encode_mcu = encode_mcu_huff;
    entropy->pub.finish_pass = finish_pass_huff;
  }

  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    compptr = cinfo->cur_comp_info[ci];
    dctbl = compptr->dc_tbl_no;
    actbl = compptr->ac_tbl_no;
    /* Make sure requested tables are present */
    /* (In gather mode, tables need not be allocated yet) */
    if (dctbl < 0 || dctbl >= NUM_HUFF_TBLS ||
	(cinfo->dc_huff_tbl_ptrs[dctbl] == NULL && !gather_statistics))
      ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, dctbl);
    if (actbl < 0 || actbl >= NUM_HUFF_TBLS ||
	(cinfo->ac_huff_tbl_ptrs[actbl] == NULL && !gather_statistics))
      ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, actbl);
    if (gather_statistics) {
#ifdef ENTROPY_OPT_SUPPORTED
      /* Allocate and zero the statistics tables */
      /* Note that jpeg_gen_optimal_table expects 257 entries in each table! */
      if (entropy->dc_count_ptrs[dctbl] == NULL)
	entropy->dc_count_ptrs[dctbl] = (long *)
	  (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				      257 * SIZEOF(long));
      MEMZERO(entropy->dc_count_ptrs[dctbl], 257 * SIZEOF(long));
      if (entropy->ac_count_ptrs[actbl] == NULL)
	entropy->ac_count_ptrs[actbl] = (long *)
	  (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				      257 * SIZEOF(long));
      MEMZERO(entropy->ac_count_ptrs[actbl], 257 * SIZEOF(long));
#endif
    } else {
      /* Compute derived values for Huffman tables */
      /* We may do this more than once for a table, but it's not expensive */
      jpeg_make_c_derived_tbl(cinfo, cinfo->dc_huff_tbl_ptrs[dctbl],
			      & entropy->dc_derived_tbls[dctbl]);
      jpeg_make_c_derived_tbl(cinfo, cinfo->ac_huff_tbl_ptrs[actbl],
			      & entropy->ac_derived_tbls[actbl]);
    }
    /* Initialize DC predictions to 0 */
    entropy->saved.last_dc_val[ci] = 0;
  }

  /* Initialize bit buffer to empty */
  entropy->saved.put_buffer = 0;
  entropy->saved.put_bits = 0;

  /* Initialize restart stuff */
  entropy->restarts_to_go = cinfo->restart_interval;
  entropy->next_restart_num = 0;
}


/*
 * Compute the derived values for a Huffman table.
 * Note this is also used by jcphuff.c.
 */

GLOBAL(void)
jpeg_make_c_derived_tbl (j_compress_ptr cinfo, JHUFF_TBL * htbl,
			 c_derived_tbl ** pdtbl)
{
  c_derived_tbl *dtbl;
  int p, i, l, lastp, si;
  char huffsize[257];
  unsigned int huffcode[257];
  unsigned int code;

  /* Allocate a workspace if we haven't already done so. */
  if (*pdtbl == NULL)
    *pdtbl = (c_derived_tbl *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  SIZEOF(c_derived_tbl));
  dtbl = *pdtbl;
  
  /* Figure C.1: make table of Huffman code length for each symbol */
  /* Note that this is in code-length order. */

  p = 0;
  for (l = 1; l <= 16; l++) {
    for (i = 1; i <= (int) htbl->bits[l]; i++)
      huffsize[p++] = (char) l;
  }
  huffsize[p] = 0;
  lastp = p;
  
  /* Figure C.2: generate the codes themselves */
  /* Note that this is in code-length order. */
  
  code = 0;
  si = huffsize[0];
  p = 0;
  while (huffsize[p]) {
    while (((int) huffsize[p]) == si) {
      huffcode[p++] = code;
      code++;
    }
    code <<= 1;
    si++;
  }
  
  /* Figure C.3: generate encoding tables */
  /* These are code and size indexed by symbol value */

  /* Set any codeless symbols to have code length 0;
   * this allows emit_bits to detect any attempt to emit such symbols.
   */
  MEMZERO(dtbl->ehufsi, SIZEOF(dtbl->ehufsi));

  for (p = 0; p < lastp; p++) {
    dtbl->ehufco[htbl->huffval[p]] = huffcode[p];
    dtbl->ehufsi[htbl->huffval[p]] = huffsize[p];
  }
}


/* Outputting bytes to the file */

/* Emit a byte, taking 'action' if must suspend. */
#define emit_byte(state,val,action)  \
	{ *(state)->next_output_byte++ = (JOCTET) (val);  \
	  if (--(state)->free_in_buffer == 0)  \
	    if (! dump_buffer(state))  \
	      { action; } }


LOCAL(boolean)
dump_buffer (working_state * state)
/* Empty the output buffer; return TRUE if successful, FALSE if must suspend */
{
  struct jpeg_destination_mgr * dest = state->cinfo->dest;

  if (! (*dest->empty_output_buffer) (state->cinfo))
    return FALSE;
  /* After a successful buffer dump, must reset buffer pointers */
  state->next_output_byte = dest->next_output_byte;
  state->free_in_buffer = dest->free_in_buffer;
  return TRUE;
}


/* Outputting bits to the file */

/* Only the right 24 bits of put_buffer are used; the valid bits are
 * left-justified in this part.  At most 16 bits can be passed to emit_bits
 * in one call, and we never retain more than 7 bits in put_buffer
 * between calls, so 24 bits are sufficient.
 */

INLINE
LOCAL(boolean)
emit_bits (working_state * state, unsigned int code, int size)
/* Emit some bits; return TRUE if successful, FALSE if must suspend */
{
  /* This routine is heavily used, so it's worth coding tightly. */
  register INT32 put_buffer = (INT32) code;
  register int put_bits = state->cur.put_bits;

  /* if size is 0, caller used an invalid Huffman table entry */
  if (size == 0)
    ERREXIT(state->cinfo, JERR_HUFF_MISSING_CODE);

  put_buffer &= (((INT32) 1)<<size) - 1; /* mask off any extra bits in code */
  
  put_bits += size;		/* new number of bits in buffer */
  
  put_buffer <<= 24 - put_bits; /* align incoming bits */

  put_buffer |= state->cur.put_buffer; /* and merge with old buffer contents */
  
  while (put_bits >= 8) {
    int c = (int) ((put_buffer >> 16) & 0xFF);
    
    emit_byte(state, c, return FALSE);
    if (c == 0xFF) {		/* need to stuff a zero byte? */
      emit_byte(state, 0, return FALSE);
    }
    put_buffer <<= 8;
    put_bits -= 8;
  }

  state->cur.put_buffer = put_buffer; /* update state variables */
  state->cur.put_bits = put_bits;

  return TRUE;
}


LOCAL(boolean)
flush_bits (working_state * state)
{
  if (! emit_bits(state, 0x7F, 7)) /* fill any partial byte with ones */
    return FALSE;
  state->cur.put_buffer = 0;	/* and reset bit-buffer to empty */
  state->cur.put_bits = 0;
  return TRUE;
}


/* Encode a single block's worth of coefficients */

LOCAL(boolean)
encode_one_block (working_state * state, JCOEFPTR block, int last_dc_val,
		  c_derived_tbl *dctbl, c_derived_tbl *actbl)
{
  register int temp, temp2;
  register int nbits;
  register int k, r, i;
  
  /* Encode the DC coefficient difference per section F.1.2.1 */
  
  temp = temp2 = block[0] - last_dc_val;

  if (temp < 0) {
    temp = -temp;		/* temp is abs value of input */
    /* For a negative input, want temp2 = bitwise complement of abs(input) */
    /* This code assumes we are on a two's complement machine */
    temp2--;
  }
  
  /* Find the number of bits needed for the magnitude of the coefficient */
  nbits = 0;
  while (temp) {
    nbits++;
    temp >>= 1;
  }
  
  /* Emit the Huffman-coded symbol for the number of bits */
  if (! emit_bits(state, dctbl->ehufco[nbits], dctbl->ehufsi[nbits]))
    return FALSE;

  /* Emit that number of bits of the value, if positive, */
  /* or the complement of its magnitude, if negative. */
  if (nbits)			/* emit_bits rejects calls with size 0 */
    if (! emit_bits(state, (unsigned int) temp2, nbits))
      return FALSE;

  /* Encode the AC coefficients per section F.1.2.2 */
  
  r = 0;			/* r = run length of zeros */
  
  for (k = 1; k < DCTSIZE2; k++) {
    if ((temp = block[jpeg_natural_order[k]]) == 0) {
      r++;
    } else {
      /* if run length > 15, must emit special run-length-16 codes (0xF0) */
      while (r > 15) {
	if (! emit_bits(state, actbl->ehufco[0xF0], actbl->ehufsi[0xF0]))
	  return FALSE;
	r -= 16;
      }

      temp2 = temp;
      if (temp < 0) {
	temp = -temp;		/* temp is abs value of input */
	/* This code assumes we are on a two's complement machine */
	temp2--;
      }
      
      /* Find the number of bits needed for the magnitude of the coefficient */
      nbits = 1;		/* there must be at least one 1 bit */
      while ((temp >>= 1))
	nbits++;
      
      /* Emit Huffman symbol for run length / number of bits */
      i = (r << 4) + nbits;
      if (! emit_bits(state, actbl->ehufco[i], actbl->ehufsi[i]))
	return FALSE;

      /* Emit that number of bits of the value, if positive, */
      /* or the complement of its magnitude, if negative. */
      if (! emit_bits(state, (unsigned int) temp2, nbits))
	return FALSE;
      
      r = 0;
    }
  }

  /* If the last coef(s) were zero, emit an end-of-block code */
  if (r > 0)
    if (! emit_bits(state, actbl->ehufco[0], actbl->ehufsi[0]))
      return FALSE;

  return TRUE;
}


/*
 * Emit a restart marker & resynchronize predictions.
 */

LOCAL(boolean)
emit_restart (working_state * state, int restart_num)
{
  int ci;

  if (! flush_bits(state))
    return FALSE;

  emit_byte(state, 0xFF, return FALSE);
  emit_byte(state, JPEG_RST0 + restart_num, return FALSE);

  /* Re-initialize DC predictions to 0 */
  for (ci = 0; ci < state->cinfo->comps_in_scan; ci++)
    state->cur.last_dc_val[ci] = 0;

  /* The restart counter is not updated until we successfully write the MCU. */

  return TRUE;
}


/*
 * Encode and output one MCU's worth of Huffman-compressed coefficients.
 */

METHODDEF(boolean)
encode_mcu_huff (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
{
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
  working_state state;
  int blkn, ci;
  jpeg_component_info * compptr;

  /* Load up working state */
  state.next_output_byte = cinfo->dest->next_output_byte;
  state.free_in_buffer = cinfo->dest->free_in_buffer;
  ASSIGN_STATE(state.cur, entropy->saved);
  state.cinfo = cinfo;

  /* Emit restart marker if needed */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0)
      if (! emit_restart(&state, entropy->next_restart_num))
	return FALSE;
  }

  /* Encode the MCU data blocks */
  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
    ci = cinfo->MCU_membership[blkn];
    compptr = cinfo->cur_comp_info[ci];
    if (! encode_one_block(&state,
			   MCU_data[blkn][0], state.cur.last_dc_val[ci],
			   entropy->dc_derived_tbls[compptr->dc_tbl_no],
			   entropy->ac_derived_tbls[compptr->ac_tbl_no]))
      return FALSE;
    /* Update last_dc_val */
    state.cur.last_dc_val[ci] = MCU_data[blkn][0][0];
  }

  /* Completed MCU, so update state */
  cinfo->dest->next_output_byte = state.next_output_byte;
  cinfo->dest->free_in_buffer = state.free_in_buffer;
  ASSIGN_STATE(entropy->saved, state.cur);

  /* Update restart-interval state too */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0) {
      entropy->restarts_to_go = cinfo->restart_interval;
      entropy->next_restart_num++;
      entropy->next_restart_num &= 7;
    }
    entropy->restarts_to_go--;
  }

  return TRUE;
}


/*
 * Finish up at the end of a Huffman-compressed scan.
 */

METHODDEF(void)
finish_pass_huff (j_compress_ptr cinfo)
{
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
  working_state state;

  /* Load up working state ... flush_bits needs it */
  state.next_output_byte = cinfo->dest->next_output_byte;
  state.free_in_buffer = cinfo->dest->free_in_buffer;
  ASSIGN_STATE(state.cur, entropy->saved);
  state.cinfo = cinfo;

  /* Flush out the last data */
  if (! flush_bits(&state))
    ERREXIT(cinfo, JERR_CANT_SUSPEND);

  /* Update state */
  cinfo->dest->next_output_byte = state.next_output_byte;
  cinfo->dest->free_in_buffer = state.free_in_buffer;
  ASSIGN_STATE(entropy->saved, state.cur);
}


/*
 * Huffman coding optimization.
 *
 * This actually is optimization, in the sense that we find the best possible
 * Huffman table(s) for the given data.  We first scan the supplied data and
 * count the number of uses of each symbol that is to be Huffman-coded.
 * (This process must agree with the code above.)  Then we build an
 * optimal Huffman coding tree for the observed counts.
 *
 * The JPEG standard requires Huffman codes to be no more than 16 bits long.
 * If some symbols have a very small but nonzero probability, the Huffman tree
 * must be adjusted to meet the code length restriction.  We currently use
 * the adjustment method suggested in the JPEG spec.  This method is *not*
 * optimal; it may not choose the best possible limited-length code.  But
 * since the symbols involved are infrequently used, it's not clear that
 * going to extra trouble is worthwhile.
 */

#ifdef ENTROPY_OPT_SUPPORTED


/* Process a single block's worth of coefficients */

LOCAL(void)
htest_one_block (JCOEFPTR block, int last_dc_val,
		 long dc_counts[], long ac_counts[])
{
  register int temp;
  register int nbits;
  register int k, r;
  
  /* Encode the DC coefficient difference per section F.1.2.1 */
  
  temp = block[0] - last_dc_val;
  if (temp < 0)
    temp = -temp;
  
  /* Find the number of bits needed for the magnitude of the coefficient */
  nbits = 0;
  while (temp) {
    nbits++;
    temp >>= 1;
  }

  /* Count the Huffman symbol for the number of bits */
  dc_counts[nbits]++;
  
  /* Encode the AC coefficients per section F.1.2.2 */
  
  r = 0;			/* r = run length of zeros */
  
  for (k = 1; k < DCTSIZE2; k++) {
    if ((temp = block[jpeg_natural_order[k]]) == 0) {
      r++;
    } else {
      /* if run length > 15, must emit special run-length-16 codes (0xF0) */
      while (r > 15) {
	ac_counts[0xF0]++;
	r -= 16;
      }
      
      /* Find the number of bits needed for the magnitude of the coefficient */
      if (temp < 0)
	temp = -temp;
      
      /* Find the number of bits needed for the magnitude of the coefficient */
      nbits = 1;		/* there must be at least one 1 bit */
      while ((temp >>= 1))
	nbits++;
      
      /* Count Huffman symbol for run length / number of bits */
      ac_counts[(r << 4) + nbits]++;
      
      r = 0;
    }
  }

  /* If the last coef(s) were zero, emit an end-of-block code */
  if (r > 0)
    ac_counts[0]++;
}


/*
 * Trial-encode one MCU's worth of Huffman-compressed coefficients.
 * No data is actually output, so no suspension return is possible.
 */

METHODDEF(boolean)
encode_mcu_gather (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
{
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
  int blkn, ci;
  jpeg_component_info * compptr;

  /* Take care of restart intervals if needed */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0) {
      /* Re-initialize DC predictions to 0 */
      for (ci = 0; ci < cinfo->comps_in_scan; ci++)
	entropy->saved.last_dc_val[ci] = 0;
      /* Update restart state */
      entropy->restarts_to_go = cinfo->restart_interval;
    }
    entropy->restarts_to_go--;
  }

  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
    ci = cinfo->MCU_membership[blkn];
    compptr = cinfo->cur_comp_info[ci];
    htest_one_block(MCU_data[blkn][0], entropy->saved.last_dc_val[ci],
		    entropy->dc_count_ptrs[compptr->dc_tbl_no],
		    entropy->ac_count_ptrs[compptr->ac_tbl_no]);
    entropy->saved.last_dc_val[ci] = MCU_data[blkn][0][0];
  }

  return TRUE;
}


/*
 * Generate the optimal coding for the given counts, fill htbl.
 * Note this is also used by jcphuff.c.
 */

GLOBAL(void)
jpeg_gen_optimal_table (j_compress_ptr cinfo, JHUFF_TBL * htbl, long freq[])
{
#define MAX_CLEN 32		/* assumed maximum initial code length */
  UINT8 bits[MAX_CLEN+1];	/* bits[k] = # of symbols with code length k */
  int codesize[257];		/* codesize[k] = code length of symbol k */
  int others[257];		/* next symbol in current branch of tree */
  int c1, c2;
  int p, i, j;
  long v;

  /* This algorithm is explained in section K.2 of the JPEG standard */

  MEMZERO(bits, SIZEOF(bits));
  MEMZERO(codesize, SIZEOF(codesize));
  for (i = 0; i < 257; i++)
    others[i] = -1;		/* init links to empty */
  
  freq[256] = 1;		/* make sure there is a nonzero count */
  /* Including the pseudo-symbol 256 in the Huffman procedure guarantees
   * that no real symbol is given code-value of all ones, because 256
   * will be placed in the largest codeword category.
   */

  /* Huffman's basic algorithm to assign optimal code lengths to symbols */

  for (;;) {
    /* Find the smallest nonzero frequency, set c1 = its symbol */
    /* In case of ties, take the larger symbol number */
    c1 = -1;
    v = 1000000000L;
    for (i = 0; i <= 256; i++) {
      if (freq[i] && freq[i] <= v) {
	v = freq[i];
	c1 = i;
      }
    }

    /* Find the next smallest nonzero frequency, set c2 = its symbol */
    /* In case of ties, take the larger symbol number */
    c2 = -1;
    v = 1000000000L;
    for (i = 0; i <= 256; i++) {
      if (freq[i] && freq[i] <= v && i != c1) {
	v = freq[i];
	c2 = i;
      }
    }

    /* Done if we've merged everything into one frequency */
    if (c2 < 0)
      break;
    
    /* Else merge the two counts/trees */
    freq[c1] += freq[c2];
    freq[c2] = 0;

    /* Increment the codesize of everything in c1's tree branch */
    codesize[c1]++;
    while (others[c1] >= 0) {
      c1 = others[c1];
      codesize[c1]++;
    }
    
    others[c1] = c2;		/* chain c2 onto c1's tree branch */
    
    /* Increment the codesize of everything in c2's tree branch */
    codesize[c2]++;
    while (others[c2] >= 0) {
      c2 = others[c2];
      codesize[c2]++;
    }
  }

  /* Now count the number of symbols of each code length */
  for (i = 0; i <= 256; i++) {
    if (codesize[i]) {
      /* The JPEG standard seems to think that this can't happen, */
      /* but I'm paranoid... */
      if (codesize[i] > MAX_CLEN)
	ERREXIT(cinfo, JERR_HUFF_CLEN_OVERFLOW);

      bits[codesize[i]]++;
    }
  }

  /* JPEG doesn't allow symbols with code lengths over 16 bits, so if the pure
   * Huffman procedure assigned any such lengths, we must adjust the coding.
   * Here is what the JPEG spec says about how this next bit works:
   * Since symbols are paired for the longest Huffman code, the symbols are
   * removed from this length category two at a time.  The prefix for the pair
   * (which is one bit shorter) is allocated to one of the pair; then,
   * skipping the BITS entry for that prefix length, a code word from the next
   * shortest nonzero BITS entry is converted into a prefix for two code words
   * one bit longer.
   */
  
  for (i = MAX_CLEN; i > 16; i--) {
    while (bits[i] > 0) {
      j = i - 2;		/* find length of new prefix to be used */
      while (bits[j] == 0)
	j--;
      
      bits[i] -= 2;		/* remove two symbols */
      bits[i-1]++;		/* one goes in this length */
      bits[j+1] += 2;		/* two new symbols in this length */
      bits[j]--;		/* symbol of this length is now a prefix */
    }
  }

  /* Remove the count for the pseudo-symbol 256 from the largest codelength */
  while (bits[i] == 0)		/* find largest codelength still in use */
    i--;
  bits[i]--;
  
  /* Return final symbol counts (only for lengths 0..16) */
  MEMCOPY(htbl->bits, bits, SIZEOF(htbl->bits));
  
  /* Return a list of the symbols sorted by code length */
  /* It's not real clear to me why we don't need to consider the codelength
   * changes made above, but the JPEG spec seems to think this works.
   */
  p = 0;
  for (i = 1; i <= MAX_CLEN; i++) {
    for (j = 0; j <= 255; j++) {
      if (codesize[j] == i) {
	htbl->huffval[p] = (UINT8) j;
	p++;
      }
    }
  }

  /* Set sent_table FALSE so updated table will be written to JPEG file. */
  htbl->sent_table = FALSE;
}


/*
 * Finish up a statistics-gathering pass and create the new Huffman tables.
 */

METHODDEF(void)
finish_pass_gather (j_compress_ptr cinfo)
{
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
  int ci, dctbl, actbl;
  jpeg_component_info * compptr;
  JHUFF_TBL **htblptr;
  boolean did_dc[NUM_HUFF_TBLS];
  boolean did_ac[NUM_HUFF_TBLS];

  /* It's important not to apply jpeg_gen_optimal_table more than once
   * per table, because it clobbers the input frequency counts!
   */
  MEMZERO(did_dc, SIZEOF(did_dc));
  MEMZERO(did_ac, SIZEOF(did_ac));

  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    compptr = cinfo->cur_comp_info[ci];
    dctbl = compptr->dc_tbl_no;
    actbl = compptr->ac_tbl_no;
    if (! did_dc[dctbl]) {
      htblptr = & cinfo->dc_huff_tbl_ptrs[dctbl];
      if (*htblptr == NULL)
	*htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
      jpeg_gen_optimal_table(cinfo, *htblptr, entropy->dc_count_ptrs[dctbl]);
      did_dc[dctbl] = TRUE;
    }
    if (! did_ac[actbl]) {
      htblptr = & cinfo->ac_huff_tbl_ptrs[actbl];
      if (*htblptr == NULL)
	*htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
      jpeg_gen_optimal_table(cinfo, *htblptr, entropy->ac_count_ptrs[actbl]);
      did_ac[actbl] = TRUE;
    }
  }
}


#endif /* ENTROPY_OPT_SUPPORTED */


/*
 * Module initialization routine for Huffman entropy encoding.
 */

GLOBAL(void)
jinit_huff_encoder (j_compress_ptr cinfo)
{
  huff_entropy_ptr entropy;
  int i;

  entropy = (huff_entropy_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(huff_entropy_encoder));
  cinfo->entropy = (struct jpeg_entropy_encoder *) entropy;
  entropy->pub.start_pass = start_pass_huff;

  /* Mark tables unallocated */
  for (i = 0; i < NUM_HUFF_TBLS; i++) {
    entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
#ifdef ENTROPY_OPT_SUPPORTED
    entropy->dc_count_ptrs[i] = entropy->ac_count_ptrs[i] = NULL;
#endif
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\jcmainct.c ===
/*
 * jcmainct.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains the main buffer controller for compression.
 * The main buffer lies between the pre-processor and the JPEG
 * compressor proper; it holds downsampled data in the JPEG colorspace.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/* Note: currently, there is no operating mode in which a full-image buffer
 * is needed at this step.  If there were, that mode could not be used with
 * "raw data" input, since this module is bypassed in that case.  However,
 * we've left the code here for possible use in special applications.
 */
#undef FULL_MAIN_BUFFER_SUPPORTED


/* Private buffer controller object */

typedef struct {
  struct jpeg_c_main_controller pub; /* public fields */

  JDIMENSION cur_iMCU_row;	/* number of current iMCU row */
  JDIMENSION rowgroup_ctr;	/* counts row groups received in iMCU row */
  boolean suspended;		/* remember if we suspended output */
  J_BUF_MODE pass_mode;		/* current operating mode */

  /* If using just a strip buffer, this points to the entire set of buffers
   * (we allocate one for each component).  In the full-image case, this
   * points to the currently accessible strips of the virtual arrays.
   */
  JSAMPARRAY buffer[MAX_COMPONENTS];

#ifdef FULL_MAIN_BUFFER_SUPPORTED
  /* If using full-image storage, this array holds pointers to virtual-array
   * control blocks for each component.  Unused if not full-image storage.
   */
  jvirt_sarray_ptr whole_image[MAX_COMPONENTS];
#endif
} my_main_controller;

typedef my_main_controller * my_main_ptr;


/* Forward declarations */
METHODDEF(void) process_data_simple_main
	JPP((j_compress_ptr cinfo, JSAMPARRAY input_buf,
	     JDIMENSION *in_row_ctr, JDIMENSION in_rows_avail));
#ifdef FULL_MAIN_BUFFER_SUPPORTED
METHODDEF(void) process_data_buffer_main
	JPP((j_compress_ptr cinfo, JSAMPARRAY input_buf,
	     JDIMENSION *in_row_ctr, JDIMENSION in_rows_avail));
#endif


/*
 * Initialize for a processing pass.
 */

METHODDEF(void)
start_pass_main (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
{
  my_main_ptr main = (my_main_ptr) cinfo->main;

  /* Do nothing in raw-data mode. */
  if (cinfo->raw_data_in)
    return;

  main->cur_iMCU_row = 0;	/* initialize counters */
  main->rowgroup_ctr = 0;
  main->suspended = FALSE;
  main->pass_mode = pass_mode;	/* save mode for use by process_data */

  switch (pass_mode) {
  case JBUF_PASS_THRU:
#ifdef FULL_MAIN_BUFFER_SUPPORTED
    if (main->whole_image[0] != NULL)
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
#endif
    main->pub.process_data = process_data_simple_main;
    break;
#ifdef FULL_MAIN_BUFFER_SUPPORTED
  case JBUF_SAVE_SOURCE:
  case JBUF_CRANK_DEST:
  case JBUF_SAVE_AND_PASS:
    if (main->whole_image[0] == NULL)
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
    main->pub.process_data = process_data_buffer_main;
    break;
#endif
  default:
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
    break;
  }
}


/*
 * Process some data.
 * This routine handles the simple pass-through mode,
 * where we have only a strip buffer.
 */

METHODDEF(void)
process_data_simple_main (j_compress_ptr cinfo,
			  JSAMPARRAY input_buf, JDIMENSION *in_row_ctr,
			  JDIMENSION in_rows_avail)
{
  my_main_ptr main = (my_main_ptr) cinfo->main;

  while (main->cur_iMCU_row < cinfo->total_iMCU_rows) {
    /* Read input data if we haven't filled the main buffer yet */
    if (main->rowgroup_ctr < DCTSIZE)
      (*cinfo->prep->pre_process_data) (cinfo,
					input_buf, in_row_ctr, in_rows_avail,
					main->buffer, &main->rowgroup_ctr,
					(JDIMENSION) DCTSIZE);

    /* If we don't have a full iMCU row buffered, return to application for
     * more data.  Note that preprocessor will always pad to fill the iMCU row
     * at the bottom of the image.
     */
    if (main->rowgroup_ctr != DCTSIZE)
      return;

    /* Send the completed row to the compressor */
    if (! (*cinfo->coef->compress_data) (cinfo, main->buffer)) {
      /* If compressor did not consume the whole row, then we must need to
       * suspend processing and return to the application.  In this situation
       * we pretend we didn't yet consume the last input row; otherwise, if
       * it happened to be the last row of the image, the application would
       * think we were done.
       */
      if (! main->suspended) {
	(*in_row_ctr)--;
	main->suspended = TRUE;
      }
      return;
    }
    /* We did finish the row.  Undo our little suspension hack if a previous
     * call suspended; then mark the main buffer empty.
     */
    if (main->suspended) {
      (*in_row_ctr)++;
      main->suspended = FALSE;
    }
    main->rowgroup_ctr = 0;
    main->cur_iMCU_row++;
  }
}


#ifdef FULL_MAIN_BUFFER_SUPPORTED

/*
 * Process some data.
 * This routine handles all of the modes that use a full-size buffer.
 */

METHODDEF(void)
process_data_buffer_main (j_compress_ptr cinfo,
			  JSAMPARRAY input_buf, JDIMENSION *in_row_ctr,
			  JDIMENSION in_rows_avail)
{
  my_main_ptr main = (my_main_ptr) cinfo->main;
  int ci;
  jpeg_component_info *compptr;
  boolean writing = (main->pass_mode != JBUF_CRANK_DEST);

  while (main->cur_iMCU_row < cinfo->total_iMCU_rows) {
    /* Realign the virtual buffers if at the start of an iMCU row. */
    if (main->rowgroup_ctr == 0) {
      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
	   ci++, compptr++) {
	main->buffer[ci] = (*cinfo->mem->access_virt_sarray)
	  ((j_common_ptr) cinfo, main->whole_image[ci],
	   main->cur_iMCU_row * (compptr->v_samp_factor * DCTSIZE),
	   (JDIMENSION) (compptr->v_samp_factor * DCTSIZE), writing);
      }
      /* In a read pass, pretend we just read some source data. */
      if (! writing) {
	*in_row_ctr += cinfo->max_v_samp_factor * DCTSIZE;
	main->rowgroup_ctr = DCTSIZE;
      }
    }

    /* If a write pass, read input data until the current iMCU row is full. */
    /* Note: preprocessor will pad if necessary to fill the last iMCU row. */
    if (writing) {
      (*cinfo->prep->pre_process_data) (cinfo,
					input_buf, in_row_ctr, in_rows_avail,
					main->buffer, &main->rowgroup_ctr,
					(JDIMENSION) DCTSIZE);
      /* Return to application if we need more data to fill the iMCU row. */
      if (main->rowgroup_ctr < DCTSIZE)
	return;
    }

    /* Emit data, unless this is a sink-only pass. */
    if (main->pass_mode != JBUF_SAVE_SOURCE) {
      if (! (*cinfo->coef->compress_data) (cinfo, main->buffer)) {
	/* If compressor did not consume the whole row, then we must need to
	 * suspend processing and return to the application.  In this situation
	 * we pretend we didn't yet consume the last input row; otherwise, if
	 * it happened to be the last row of the image, the application would
	 * think we were done.
	 */
	if (! main->suspended) {
	  (*in_row_ctr)--;
	  main->suspended = TRUE;
	}
	return;
      }
      /* We did finish the row.  Undo our little suspension hack if a previous
       * call suspended; then mark the main buffer empty.
       */
      if (main->suspended) {
	(*in_row_ctr)++;
	main->suspended = FALSE;
      }
    }

    /* If get here, we are done with this iMCU row.  Mark buffer empty. */
    main->rowgroup_ctr = 0;
    main->cur_iMCU_row++;
  }
}

#endif /* FULL_MAIN_BUFFER_SUPPORTED */


/*
 * Initialize main buffer controller.
 */

GLOBAL(void)
jinit_c_main_controller (j_compress_ptr cinfo, boolean need_full_buffer)
{
  my_main_ptr main;
  int ci;
  jpeg_component_info *compptr;

  main = (my_main_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_main_controller));
  cinfo->main = (struct jpeg_c_main_controller *) main;
  main->pub.start_pass = start_pass_main;

  /* We don't need to create a buffer in raw-data mode. */
  if (cinfo->raw_data_in)
    return;

  /* Create the buffer.  It holds downsampled data, so each component
   * may be of a different size.
   */
  if (need_full_buffer) {
#ifdef FULL_MAIN_BUFFER_SUPPORTED
    /* Allocate a full-image virtual array for each component */
    /* Note we pad the bottom to a multiple of the iMCU height */
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
	 ci++, compptr++) {
      main->whole_image[ci] = (*cinfo->mem->request_virt_sarray)
	((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,
	 compptr->width_in_blocks * DCTSIZE,
	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
				(long) compptr->v_samp_factor) * DCTSIZE,
	 (JDIMENSION) (compptr->v_samp_factor * DCTSIZE));
    }
#else
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
#endif
  } else {
#ifdef FULL_MAIN_BUFFER_SUPPORTED
    main->whole_image[0] = NULL; /* flag for no virtual arrays */
#endif
    /* Allocate a strip buffer for each component */
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
	 ci++, compptr++) {
      main->buffer[ci] = (*cinfo->mem->alloc_sarray)
	((j_common_ptr) cinfo, JPOOL_IMAGE,
	 compptr->width_in_blocks * DCTSIZE,
	 (JDIMENSION) (compptr->v_samp_factor * DCTSIZE));
    }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\jccoefct.c ===
/*
 * jccoefct.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains the coefficient buffer controller for compression.
 * This controller is the top level of the JPEG compressor proper.
 * The coefficient buffer lies between forward-DCT and entropy encoding steps.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/* We use a full-image coefficient buffer when doing Huffman optimization,
 * and also for writing multiple-scan JPEG files.  In all cases, the DCT
 * step is run during the first pass, and subsequent passes need only read
 * the buffered coefficients.
 */
#ifdef ENTROPY_OPT_SUPPORTED
#define FULL_COEF_BUFFER_SUPPORTED
#else
#ifdef C_MULTISCAN_FILES_SUPPORTED
#define FULL_COEF_BUFFER_SUPPORTED
#endif
#endif


/* Private buffer controller object */

typedef struct {
  struct jpeg_c_coef_controller pub; /* public fields */

  JDIMENSION iMCU_row_num;	/* iMCU row # within image */
  JDIMENSION mcu_ctr;		/* counts MCUs processed in current row */
  int MCU_vert_offset;		/* counts MCU rows within iMCU row */
  int MCU_rows_per_iMCU_row;	/* number of such rows needed */

  /* For single-pass compression, it's sufficient to buffer just one MCU
   * (although this may prove a bit slow in practice).  We allocate a
   * workspace of C_MAX_BLOCKS_IN_MCU coefficient blocks, and reuse it for each
   * MCU constructed and sent.  (On 80x86, the workspace is FAR even though
   * it's not really very big; this is to keep the module interfaces unchanged
   * when a large coefficient buffer is necessary.)
   * In multi-pass modes, this array points to the current MCU's blocks
   * within the virtual arrays.
   */
  JBLOCKROW MCU_buffer[C_MAX_BLOCKS_IN_MCU];

  /* In multi-pass modes, we need a virtual block array for each component. */
  jvirt_barray_ptr whole_image[MAX_COMPONENTS];
} my_coef_controller;

typedef my_coef_controller * my_coef_ptr;


/* Forward declarations */
METHODDEF(boolean) compress_data
    JPP((j_compress_ptr cinfo, JSAMPIMAGE input_buf));
#ifdef FULL_COEF_BUFFER_SUPPORTED
METHODDEF(boolean) compress_first_pass
    JPP((j_compress_ptr cinfo, JSAMPIMAGE input_buf));
METHODDEF(boolean) compress_output
    JPP((j_compress_ptr cinfo, JSAMPIMAGE input_buf));
#endif


LOCAL(void)
start_iMCU_row (j_compress_ptr cinfo)
/* Reset within-iMCU-row counters for a new row */
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;

  /* In an interleaved scan, an MCU row is the same as an iMCU row.
   * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
   * But at the bottom of the image, process only what's left.
   */
  if (cinfo->comps_in_scan > 1) {
    coef->MCU_rows_per_iMCU_row = 1;
  } else {
    if (coef->iMCU_row_num < (cinfo->total_iMCU_rows-1))
      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;
    else
      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;
  }

  coef->mcu_ctr = 0;
  coef->MCU_vert_offset = 0;
}


/*
 * Initialize for a processing pass.
 */

METHODDEF(void)
start_pass_coef (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;

  coef->iMCU_row_num = 0;
  start_iMCU_row(cinfo);

  switch (pass_mode) {
  case JBUF_PASS_THRU:
    if (coef->whole_image[0] != NULL)
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
    coef->pub.compress_data = compress_data;
    break;
#ifdef FULL_COEF_BUFFER_SUPPORTED
  case JBUF_SAVE_AND_PASS:
    if (coef->whole_image[0] == NULL)
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
    coef->pub.compress_data = compress_first_pass;
    break;
  case JBUF_CRANK_DEST:
    if (coef->whole_image[0] == NULL)
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
    coef->pub.compress_data = compress_output;
    break;
#endif
  default:
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
    break;
  }
}


/*
 * Process some data in the single-pass case.
 * We process the equivalent of one fully interleaved MCU row ("iMCU" row)
 * per call, ie, v_samp_factor block rows for each component in the image.
 * Returns TRUE if the iMCU row is completed, FALSE if suspended.
 *
 * NB: input_buf contains a plane for each component in image.
 * For single pass, this is the same as the components in the scan.
 */

METHODDEF(boolean)
compress_data (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  JDIMENSION MCU_col_num;	/* index of current MCU within row */
  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
  int blkn, bi, ci, yindex, yoffset, blockcnt;
  JDIMENSION ypos, xpos;
  jpeg_component_info *compptr;

  /* Loop to write as much as one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
       yoffset++) {
    for (MCU_col_num = coef->mcu_ctr; MCU_col_num <= last_MCU_col;
	 MCU_col_num++) {
      /* Determine where data comes from in input_buf and do the DCT thing.
       * Each call on forward_DCT processes a horizontal row of DCT blocks
       * as wide as an MCU; we rely on having allocated the MCU_buffer[] blocks
       * sequentially.  Dummy blocks at the right or bottom edge are filled in
       * specially.  The data in them does not matter for image reconstruction,
       * so we fill them with values that will encode to the smallest amount of
       * data, viz: all zeroes in the AC entries, DC entries equal to previous
       * block's DC value.  (Thanks to Thomas Kinsman for this idea.)
       */
      blkn = 0;
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
	compptr = cinfo->cur_comp_info[ci];
	blockcnt = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
						: compptr->last_col_width;
	xpos = MCU_col_num * compptr->MCU_sample_width;
	ypos = yoffset * DCTSIZE; /* ypos == (yoffset+yindex) * DCTSIZE */
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
	  if (coef->iMCU_row_num < last_iMCU_row ||
	      yoffset+yindex < compptr->last_row_height) {
	    (*cinfo->fdct->forward_DCT) (cinfo, compptr,
					 input_buf[ci], coef->MCU_buffer[blkn],
					 ypos, xpos, (JDIMENSION) blockcnt);
	    if (blockcnt < compptr->MCU_width) {
	      /* Create some dummy blocks at the right edge of the image. */
	      jzero_far((void FAR *) coef->MCU_buffer[blkn + blockcnt],
			(compptr->MCU_width - blockcnt) * SIZEOF(JBLOCK));
	      for (bi = blockcnt; bi < compptr->MCU_width; bi++) {
		coef->MCU_buffer[blkn+bi][0][0] = coef->MCU_buffer[blkn+bi-1][0][0];
	      }
	    }
	  } else {
	    /* Create a row of dummy blocks at the bottom of the image. */
	    jzero_far((void FAR *) coef->MCU_buffer[blkn],
		      compptr->MCU_width * SIZEOF(JBLOCK));
	    for (bi = 0; bi < compptr->MCU_width; bi++) {
	      coef->MCU_buffer[blkn+bi][0][0] = coef->MCU_buffer[blkn-1][0][0];
	    }
	  }
	  blkn += compptr->MCU_width;
	  ypos += DCTSIZE;
	}
      }
      /* Try to write the MCU.  In event of a suspension failure, we will
       * re-DCT the MCU on restart (a bit inefficient, could be fixed...)
       */
      if (! (*cinfo->entropy->encode_mcu) (cinfo, coef->MCU_buffer)) {
	/* Suspension forced; update state counters and exit */
	coef->MCU_vert_offset = yoffset;
	coef->mcu_ctr = MCU_col_num;
	return FALSE;
      }
    }
    /* Completed an MCU row, but perhaps not an iMCU row */
    coef->mcu_ctr = 0;
  }
  /* Completed the iMCU row, advance counters for next one */
  coef->iMCU_row_num++;
  start_iMCU_row(cinfo);
  return TRUE;
}


#ifdef FULL_COEF_BUFFER_SUPPORTED

/*
 * Process some data in the first pass of a multi-pass case.
 * We process the equivalent of one fully interleaved MCU row ("iMCU" row)
 * per call, ie, v_samp_factor block rows for each component in the image.
 * This amount of data is read from the source buffer, DCT'd and quantized,
 * and saved into the virtual arrays.  We also generate suitable dummy blocks
 * as needed at the right and lower edges.  (The dummy blocks are constructed
 * in the virtual arrays, which have been padded appropriately.)  This makes
 * it possible for subsequent passes not to worry about real vs. dummy blocks.
 *
 * We must also emit the data to the entropy encoder.  This is conveniently
 * done by calling compress_output() after we've loaded the current strip
 * of the virtual arrays.
 *
 * NB: input_buf contains a plane for each component in image.  All
 * components are DCT'd and loaded into the virtual arrays in this pass.
 * However, it may be that only a subset of the components are emitted to
 * the entropy encoder during this first pass; be careful about looking
 * at the scan-dependent variables (MCU dimensions, etc).
 */

METHODDEF(boolean)
compress_first_pass (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
  JDIMENSION blocks_across, MCUs_across, MCUindex;
  int bi, ci, h_samp_factor, block_row, block_rows, ndummy;
  JCOEF lastDC;
  jpeg_component_info *compptr;
  JBLOCKARRAY buffer;
  JBLOCKROW thisblockrow, lastblockrow;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Align the virtual buffer for this component. */
    buffer = (*cinfo->mem->access_virt_barray)
      ((j_common_ptr) cinfo, coef->whole_image[ci],
       coef->iMCU_row_num * compptr->v_samp_factor,
       (JDIMENSION) compptr->v_samp_factor, TRUE);
    /* Count non-dummy DCT block rows in this iMCU row. */
    if (coef->iMCU_row_num < last_iMCU_row)
      block_rows = compptr->v_samp_factor;
    else {
      /* NB: can't use last_row_height here, since may not be set! */
      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
      if (block_rows == 0) block_rows = compptr->v_samp_factor;
    }
    blocks_across = compptr->width_in_blocks;
    h_samp_factor = compptr->h_samp_factor;
    /* Count number of dummy blocks to be added at the right margin. */
    ndummy = (int) (blocks_across % h_samp_factor);
    if (ndummy > 0)
      ndummy = h_samp_factor - ndummy;
    /* Perform DCT for all non-dummy blocks in this iMCU row.  Each call
     * on forward_DCT processes a complete horizontal row of DCT blocks.
     */
    for (block_row = 0; block_row < block_rows; block_row++) {
      thisblockrow = buffer[block_row];
      (*cinfo->fdct->forward_DCT) (cinfo, compptr,
				   input_buf[ci], thisblockrow,
				   (JDIMENSION) (block_row * DCTSIZE),
				   (JDIMENSION) 0, blocks_across);
      if (ndummy > 0) {
	/* Create dummy blocks at the right edge of the image. */
	thisblockrow += blocks_across; /* => first dummy block */
	jzero_far((void FAR *) thisblockrow, ndummy * SIZEOF(JBLOCK));
	lastDC = thisblockrow[-1][0];
	for (bi = 0; bi < ndummy; bi++) {
	  thisblockrow[bi][0] = lastDC;
	}
      }
    }
    /* If at end of image, create dummy block rows as needed.
     * The tricky part here is that within each MCU, we want the DC values
     * of the dummy blocks to match the last real block's DC value.
     * This squeezes a few more bytes out of the resulting file...
     */
    if (coef->iMCU_row_num == last_iMCU_row) {
      blocks_across += ndummy;	/* include lower right corner */
      MCUs_across = blocks_across / h_samp_factor;
      for (block_row = block_rows; block_row < compptr->v_samp_factor;
	   block_row++) {
	thisblockrow = buffer[block_row];
	lastblockrow = buffer[block_row-1];
	jzero_far((void FAR *) thisblockrow,
		  (size_t) (blocks_across * SIZEOF(JBLOCK)));
	for (MCUindex = 0; MCUindex < MCUs_across; MCUindex++) {
	  lastDC = lastblockrow[h_samp_factor-1][0];
	  for (bi = 0; bi < h_samp_factor; bi++) {
	    thisblockrow[bi][0] = lastDC;
	  }
	  thisblockrow += h_samp_factor; /* advance to next MCU in row */
	  lastblockrow += h_samp_factor;
	}
      }
    }
  }
  /* NB: compress_output will increment iMCU_row_num if successful.
   * A suspension return will result in redoing all the work above next time.
   */

  /* Emit data to the entropy encoder, sharing code with subsequent passes */
  return compress_output(cinfo, input_buf);
}


/*
 * Process some data in subsequent passes of a multi-pass case.
 * We process the equivalent of one fully interleaved MCU row ("iMCU" row)
 * per call, ie, v_samp_factor block rows for each component in the scan.
 * The data is obtained from the virtual arrays and fed to the entropy coder.
 * Returns TRUE if the iMCU row is completed, FALSE if suspended.
 *
 * NB: input_buf is ignored; it is likely to be a NULL pointer.
 */

METHODDEF(boolean)
compress_output (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  JDIMENSION MCU_col_num;	/* index of current MCU within row */
  int blkn, ci, xindex, yindex, yoffset;
  JDIMENSION start_col;
  JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];
  JBLOCKROW buffer_ptr;
  jpeg_component_info *compptr;

  /* Align the virtual buffers for the components used in this scan.
   * NB: during first pass, this is safe only because the buffers will
   * already be aligned properly, so jmemmgr.c won't need to do any I/O.
   */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    compptr = cinfo->cur_comp_info[ci];
    buffer[ci] = (*cinfo->mem->access_virt_barray)
      ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],
       coef->iMCU_row_num * compptr->v_samp_factor,
       (JDIMENSION) compptr->v_samp_factor, FALSE);
  }

  /* Loop to process one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
       yoffset++) {
    for (MCU_col_num = coef->mcu_ctr; MCU_col_num < cinfo->MCUs_per_row;
	 MCU_col_num++) {
      /* Construct list of pointers to DCT blocks belonging to this MCU */
      blkn = 0;			/* index of current DCT block within MCU */
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
	compptr = cinfo->cur_comp_info[ci];
	start_col = MCU_col_num * compptr->MCU_width;
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
	  buffer_ptr = buffer[ci][yindex+yoffset] + start_col;
	  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {
	    coef->MCU_buffer[blkn++] = buffer_ptr++;
	  }
	}
      }
      /* Try to write the MCU. */
      if (! (*cinfo->entropy->encode_mcu) (cinfo, coef->MCU_buffer)) {
	/* Suspension forced; update state counters and exit */
	coef->MCU_vert_offset = yoffset;
	coef->mcu_ctr = MCU_col_num;
	return FALSE;
      }
    }
    /* Completed an MCU row, but perhaps not an iMCU row */
    coef->mcu_ctr = 0;
  }
  /* Completed the iMCU row, advance counters for next one */
  coef->iMCU_row_num++;
  start_iMCU_row(cinfo);
  return TRUE;
}

#endif /* FULL_COEF_BUFFER_SUPPORTED */


/*
 * Initialize coefficient buffer controller.
 */

GLOBAL(void)
jinit_c_coef_controller (j_compress_ptr cinfo, boolean need_full_buffer)
{
  my_coef_ptr coef;

  coef = (my_coef_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_coef_controller));
  cinfo->coef = (struct jpeg_c_coef_controller *) coef;
  coef->pub.start_pass = start_pass_coef;

  /* Create the coefficient buffer. */
  if (need_full_buffer) {
#ifdef FULL_COEF_BUFFER_SUPPORTED
    /* Allocate a full-image virtual array for each component, */
    /* padded to a multiple of samp_factor DCT blocks in each direction. */
    int ci;
    jpeg_component_info *compptr;

    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
	 ci++, compptr++) {
      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
	((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,
	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
				(long) compptr->h_samp_factor),
	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
				(long) compptr->v_samp_factor),
	 (JDIMENSION) compptr->v_samp_factor);
    }
#else
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
#endif
  } else {
    /* We only need a single-MCU buffer. */
    JBLOCKROW buffer;
    int i;

    buffer = (JBLOCKROW)
      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  C_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));
    for (i = 0; i < C_MAX_BLOCKS_IN_MCU; i++) {
      coef->MCU_buffer[i] = buffer + i;
    }
    coef->whole_image[0] = NULL; /* flag for no virtual arrays */
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\jcdctmgr.c ===
/*
 * jcdctmgr.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains the forward-DCT management logic.
 * This code selects a particular DCT implementation to be used,
 * and it performs related housekeeping chores including coefficient
 * quantization.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"
#include "jdct.h"		/* Private declarations for DCT subsystem */


/* Private subobject for this module */

typedef struct {
  struct jpeg_forward_dct pub;	/* public fields */

  /* Pointer to the DCT routine actually in use */
  forward_DCT_method_ptr do_dct;

  /* The actual post-DCT divisors --- not identical to the quant table
   * entries, because of scaling (especially for an unnormalized DCT).
   * Each table is given in normal array order.
   */
  DCTELEM * divisors[NUM_QUANT_TBLS];

#ifdef DCT_FLOAT_SUPPORTED
  /* Same as above for the floating-point case. */
  float_DCT_method_ptr do_float_dct;
  FAST_FLOAT * float_divisors[NUM_QUANT_TBLS];
#endif
} my_fdct_controller;

typedef my_fdct_controller * my_fdct_ptr;


/*
 * Initialize for a processing pass.
 * Verify that all referenced Q-tables are present, and set up
 * the divisor table for each one.
 * In the current implementation, DCT of all components is done during
 * the first pass, even if only some components will be output in the
 * first scan.  Hence all components should be examined here.
 */

METHODDEF(void)
start_pass_fdctmgr (j_compress_ptr cinfo)
{
  my_fdct_ptr fdct = (my_fdct_ptr) cinfo->fdct;
  int ci, qtblno, i;
  jpeg_component_info *compptr;
  JQUANT_TBL * qtbl;
  DCTELEM * dtbl;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    qtblno = compptr->quant_tbl_no;
    /* Make sure specified quantization table is present */
    if (qtblno < 0 || qtblno >= NUM_QUANT_TBLS ||
	cinfo->quant_tbl_ptrs[qtblno] == NULL)
      ERREXIT1(cinfo, JERR_NO_QUANT_TABLE, qtblno);
    qtbl = cinfo->quant_tbl_ptrs[qtblno];
    /* Compute divisors for this quant table */
    /* We may do this more than once for same table, but it's not a big deal */
    switch (cinfo->dct_method) {
#ifdef DCT_ISLOW_SUPPORTED
    case JDCT_ISLOW:
      /* For LL&M IDCT method, divisors are equal to raw quantization
       * coefficients multiplied by 8 (to counteract scaling).
       */
      if (fdct->divisors[qtblno] == NULL) {
	fdct->divisors[qtblno] = (DCTELEM *)
	  (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				      DCTSIZE2 * SIZEOF(DCTELEM));
      }
      dtbl = fdct->divisors[qtblno];
      for (i = 0; i < DCTSIZE2; i++) {
	dtbl[i] = ((DCTELEM) qtbl->quantval[i]) << 3;
      }
      break;
#endif
#ifdef DCT_IFAST_SUPPORTED
    case JDCT_IFAST:
      {
	/* For AA&N IDCT method, divisors are equal to quantization
	 * coefficients scaled by scalefactor[row]*scalefactor[col], where
	 *   scalefactor[0] = 1
	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
	 * We apply a further scale factor of 8.
	 */
#define CONST_BITS 14
	static const INT16 aanscales[DCTSIZE2] = {
	  /* precomputed values scaled up by 14 bits */
	  16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,
	  22725, 31521, 29692, 26722, 22725, 17855, 12299,  6270,
	  21407, 29692, 27969, 25172, 21407, 16819, 11585,  5906,
	  19266, 26722, 25172, 22654, 19266, 15137, 10426,  5315,
	  16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,
	  12873, 17855, 16819, 15137, 12873, 10114,  6967,  3552,
	   8867, 12299, 11585, 10426,  8867,  6967,  4799,  2446,
	   4520,  6270,  5906,  5315,  4520,  3552,  2446,  1247
	};
	SHIFT_TEMPS

	if (fdct->divisors[qtblno] == NULL) {
	  fdct->divisors[qtblno] = (DCTELEM *)
	    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
					DCTSIZE2 * SIZEOF(DCTELEM));
	}
	dtbl = fdct->divisors[qtblno];
	for (i = 0; i < DCTSIZE2; i++) {
	  dtbl[i] = (DCTELEM)
	    DESCALE(MULTIPLY16V16((INT32) qtbl->quantval[i],
				  (INT32) aanscales[i]),
		    CONST_BITS-3);
	}
      }
      break;
#endif
#ifdef DCT_FLOAT_SUPPORTED
    case JDCT_FLOAT:
      {
	/* For float AA&N IDCT method, divisors are equal to quantization
	 * coefficients scaled by scalefactor[row]*scalefactor[col], where
	 *   scalefactor[0] = 1
	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
	 * We apply a further scale factor of 8.
	 * What's actually stored is 1/divisor so that the inner loop can
	 * use a multiplication rather than a division.
	 */
	FAST_FLOAT * fdtbl;
	int row, col;
	static const double aanscalefactor[DCTSIZE] = {
	  1.0, 1.387039845, 1.306562965, 1.175875602,
	  1.0, 0.785694958, 0.541196100, 0.275899379
	};

	if (fdct->float_divisors[qtblno] == NULL) {
	  fdct->float_divisors[qtblno] = (FAST_FLOAT *)
	    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
					DCTSIZE2 * SIZEOF(FAST_FLOAT));
	}
	fdtbl = fdct->float_divisors[qtblno];
	i = 0;
	for (row = 0; row < DCTSIZE; row++) {
	  for (col = 0; col < DCTSIZE; col++) {
	    fdtbl[i] = (FAST_FLOAT)
	      (1.0 / (((double) qtbl->quantval[i] *
		       aanscalefactor[row] * aanscalefactor[col] * 8.0)));
	    i++;
	  }
	}
      }
      break;
#endif
    default:
      ERREXIT(cinfo, JERR_NOT_COMPILED);
      break;
    }
  }
}


/*
 * Perform forward DCT on one or more blocks of a component.
 *
 * The input samples are taken from the sample_data[] array starting at
 * position start_row/start_col, and moving to the right for any additional
 * blocks. The quantized coefficients are returned in coef_blocks[].
 */

METHODDEF(void)
forward_DCT (j_compress_ptr cinfo, jpeg_component_info * compptr,
	     JSAMPARRAY sample_data, JBLOCKROW coef_blocks,
	     JDIMENSION start_row, JDIMENSION start_col,
	     JDIMENSION num_blocks)
/* This version is used for integer DCT implementations. */
{
  /* This routine is heavily used, so it's worth coding it tightly. */
  my_fdct_ptr fdct = (my_fdct_ptr) cinfo->fdct;
  forward_DCT_method_ptr do_dct = fdct->do_dct;
  DCTELEM * divisors = fdct->divisors[compptr->quant_tbl_no];
  DCTELEM workspace[DCTSIZE2];	/* work area for FDCT subroutine */
  JDIMENSION bi;

  sample_data += start_row;	/* fold in the vertical offset once */

  for (bi = 0; bi < num_blocks; bi++, start_col += DCTSIZE) {
    /* Load data into workspace, applying unsigned->signed conversion */
    { register DCTELEM *workspaceptr;
      register JSAMPROW elemptr;
      register int elemr;

      workspaceptr = workspace;
      for (elemr = 0; elemr < DCTSIZE; elemr++) {
	elemptr = sample_data[elemr] + start_col;
#if DCTSIZE == 8		/* unroll the inner loop */
	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
#else
	{ register int elemc;
	  for (elemc = DCTSIZE; elemc > 0; elemc--) {
	    *workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
	  }
	}
#endif
      }
    }

    /* Perform the DCT */
    (*do_dct) (workspace);

    /* Quantize/descale the coefficients, and store into coef_blocks[] */
    { register DCTELEM temp, qval;
      register int i;
      register JCOEFPTR output_ptr = coef_blocks[bi];

      for (i = 0; i < DCTSIZE2; i++) {
	qval = divisors[i];
	temp = workspace[i];
	/* Divide the coefficient value by qval, ensuring proper rounding.
	 * Since C does not specify the direction of rounding for negative
	 * quotients, we have to force the dividend positive for portability.
	 *
	 * In most files, at least half of the output values will be zero
	 * (at default quantization settings, more like three-quarters...)
	 * so we should ensure that this case is fast.  On many machines,
	 * a comparison is enough cheaper than a divide to make a special test
	 * a win.  Since both inputs will be nonnegative, we need only test
	 * for a < b to discover whether a/b is 0.
	 * If your machine's division is fast enough, define FAST_DIVIDE.
	 */
#ifdef FAST_DIVIDE
#define DIVIDE_BY(a,b)	a /= b
#else
#define DIVIDE_BY(a,b)	if (a >= b) a /= b; else a = 0
#endif
	if (temp < 0) {
	  temp = -temp;
	  temp += qval>>1;	/* for rounding */
	  DIVIDE_BY(temp, qval);
	  temp = -temp;
	} else {
	  temp += qval>>1;	/* for rounding */
	  DIVIDE_BY(temp, qval);
	}
	output_ptr[i] = (JCOEF) temp;
      }
    }
  }
}


#ifdef DCT_FLOAT_SUPPORTED

METHODDEF(void)
forward_DCT_float (j_compress_ptr cinfo, jpeg_component_info * compptr,
		   JSAMPARRAY sample_data, JBLOCKROW coef_blocks,
		   JDIMENSION start_row, JDIMENSION start_col,
		   JDIMENSION num_blocks)
/* This version is used for floating-point DCT implementations. */
{
  /* This routine is heavily used, so it's worth coding it tightly. */
  my_fdct_ptr fdct = (my_fdct_ptr) cinfo->fdct;
  float_DCT_method_ptr do_dct = fdct->do_float_dct;
  FAST_FLOAT * divisors = fdct->float_divisors[compptr->quant_tbl_no];
  FAST_FLOAT workspace[DCTSIZE2]; /* work area for FDCT subroutine */
  JDIMENSION bi;

  sample_data += start_row;	/* fold in the vertical offset once */

  for (bi = 0; bi < num_blocks; bi++, start_col += DCTSIZE) {
    /* Load data into workspace, applying unsigned->signed conversion */
    { register FAST_FLOAT *workspaceptr;
      register JSAMPROW elemptr;
      register int elemr;

      workspaceptr = workspace;
      for (elemr = 0; elemr < DCTSIZE; elemr++) {
	elemptr = sample_data[elemr] + start_col;
#if DCTSIZE == 8		/* unroll the inner loop */
	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
#else
	{ register int elemc;
	  for (elemc = DCTSIZE; elemc > 0; elemc--) {
	    *workspaceptr++ = (FAST_FLOAT)
	      (GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
	  }
	}
#endif
      }
    }

    /* Perform the DCT */
    (*do_dct) (workspace);

    /* Quantize/descale the coefficients, and store into coef_blocks[] */
    { register FAST_FLOAT temp;
      register int i;
      register JCOEFPTR output_ptr = coef_blocks[bi];

      for (i = 0; i < DCTSIZE2; i++) {
	/* Apply the quantization and scaling factor */
	temp = workspace[i] * divisors[i];
	/* Round to nearest integer.
	 * Since C does not specify the direction of rounding for negative
	 * quotients, we have to force the dividend positive for portability.
	 * The maximum coefficient size is +-16K (for 12-bit data), so this
	 * code should work for either 16-bit or 32-bit ints.
	 */
	output_ptr[i] = (JCOEF) ((int) (temp + (FAST_FLOAT) 16384.5) - 16384);
      }
    }
  }
}

#endif /* DCT_FLOAT_SUPPORTED */


/*
 * Initialize FDCT manager.
 */

GLOBAL(void)
jinit_forward_dct (j_compress_ptr cinfo)
{
  my_fdct_ptr fdct;
  int i;

  fdct = (my_fdct_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_fdct_controller));
  cinfo->fdct = (struct jpeg_forward_dct *) fdct;
  fdct->pub.start_pass = start_pass_fdctmgr;

  switch (cinfo->dct_method) {
#ifdef DCT_ISLOW_SUPPORTED
  case JDCT_ISLOW:
    fdct->pub.forward_DCT = forward_DCT;
    fdct->do_dct = jpeg_fdct_islow;
    break;
#endif
#ifdef DCT_IFAST_SUPPORTED
  case JDCT_IFAST:
    fdct->pub.forward_DCT = forward_DCT;
    fdct->do_dct = jpeg_fdct_ifast;
    break;
#endif
#ifdef DCT_FLOAT_SUPPORTED
  case JDCT_FLOAT:
    fdct->pub.forward_DCT = forward_DCT_float;
    fdct->do_float_dct = jpeg_fdct_float;
    break;
#endif
  default:
    ERREXIT(cinfo, JERR_NOT_COMPILED);
    break;
  }

  /* Mark divisor tables unallocated */
  for (i = 0; i < NUM_QUANT_TBLS; i++) {
    fdct->divisors[i] = NULL;
#ifdef DCT_FLOAT_SUPPORTED
    fdct->float_divisors[i] = NULL;
#endif
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\jchuff.h ===
/*
 * jchuff.h
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains declarations for Huffman entropy encoding routines
 * that are shared between the sequential encoder (jchuff.c) and the
 * progressive encoder (jcphuff.c).  No other modules need to see these.
 */

/* Derived data constructed for each Huffman table */

typedef struct {
  unsigned int ehufco[256];	/* code for each symbol */
  char ehufsi[256];		/* length of code for each symbol */
  /* If no code has been allocated for a symbol S, ehufsi[S] contains 0 */
} c_derived_tbl;

/* Short forms of external names for systems with brain-damaged linkers. */

#ifdef NEED_SHORT_EXTERNAL_NAMES
#define jpeg_make_c_derived_tbl	jMkCDerived
#define jpeg_gen_optimal_table	jGenOptTbl
#endif /* NEED_SHORT_EXTERNAL_NAMES */

/* Expand a Huffman table definition into the derived format */
EXTERN(void) jpeg_make_c_derived_tbl
	JPP((j_compress_ptr cinfo, JHUFF_TBL * htbl, c_derived_tbl ** pdtbl));

/* Generate an optimal table definition given the specified counts */
EXTERN(void) jpeg_gen_optimal_table
	JPP((j_compress_ptr cinfo, JHUFF_TBL * htbl, long freq[]));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\jcmarker.c ===
/*
 * jcmarker.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains routines to write JPEG datastream markers.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


typedef enum {			/* JPEG marker codes */
  M_SOF0  = 0xc0,
  M_SOF1  = 0xc1,
  M_SOF2  = 0xc2,
  M_SOF3  = 0xc3,
  
  M_SOF5  = 0xc5,
  M_SOF6  = 0xc6,
  M_SOF7  = 0xc7,
  
  M_JPG   = 0xc8,
  M_SOF9  = 0xc9,
  M_SOF10 = 0xca,
  M_SOF11 = 0xcb,
  
  M_SOF13 = 0xcd,
  M_SOF14 = 0xce,
  M_SOF15 = 0xcf,
  
  M_DHT   = 0xc4,
  
  M_DAC   = 0xcc,
  
  M_RST0  = 0xd0,
  M_RST1  = 0xd1,
  M_RST2  = 0xd2,
  M_RST3  = 0xd3,
  M_RST4  = 0xd4,
  M_RST5  = 0xd5,
  M_RST6  = 0xd6,
  M_RST7  = 0xd7,
  
  M_SOI   = 0xd8,
  M_EOI   = 0xd9,
  M_SOS   = 0xda,
  M_DQT   = 0xdb,
  M_DNL   = 0xdc,
  M_DRI   = 0xdd,
  M_DHP   = 0xde,
  M_EXP   = 0xdf,
  
  M_APP0  = 0xe0,
  M_APP1  = 0xe1,
  M_APP2  = 0xe2,
  M_APP3  = 0xe3,
  M_APP4  = 0xe4,
  M_APP5  = 0xe5,
  M_APP6  = 0xe6,
  M_APP7  = 0xe7,
  M_APP8  = 0xe8,
  M_APP9  = 0xe9,
  M_APP10 = 0xea,
  M_APP11 = 0xeb,
  M_APP12 = 0xec,
  M_APP13 = 0xed,
  M_APP14 = 0xee,
  M_APP15 = 0xef,
  
  M_JPG0  = 0xf0,
  M_JPG13 = 0xfd,
  M_COM   = 0xfe,
  
  M_TEM   = 0x01,
  
  M_ERROR = 0x100
} JPEG_MARKER;


/*
 * Basic output routines.
 *
 * Note that we do not support suspension while writing a marker.
 * Therefore, an application using suspension must ensure that there is
 * enough buffer space for the initial markers (typ. 600-700 bytes) before
 * calling jpeg_start_compress, and enough space to write the trailing EOI
 * (a few bytes) before calling jpeg_finish_compress.  Multipass compression
 * modes are not supported at all with suspension, so those two are the only
 * points where markers will be written.
 */

LOCAL(void)
emit_byte (j_compress_ptr cinfo, int val)
/* Emit a byte */
{
  struct jpeg_destination_mgr * dest = cinfo->dest;

  *(dest->next_output_byte)++ = (JOCTET) val;
  if (--dest->free_in_buffer == 0) {
    if (! (*dest->empty_output_buffer) (cinfo))
      ERREXIT(cinfo, JERR_CANT_SUSPEND);
  }
}


LOCAL(void)
emit_marker (j_compress_ptr cinfo, JPEG_MARKER mark)
/* Emit a marker code */
{
  emit_byte(cinfo, 0xFF);
  emit_byte(cinfo, (int) mark);
}


LOCAL(void)
emit_2bytes (j_compress_ptr cinfo, int value)
/* Emit a 2-byte integer; these are always MSB first in JPEG files */
{
  emit_byte(cinfo, (value >> 8) & 0xFF);
  emit_byte(cinfo, value & 0xFF);
}


/*
 * Routines to write specific marker types.
 */

LOCAL(int)
emit_dqt (j_compress_ptr cinfo, int index)
/* Emit a DQT marker */
/* Returns the precision used (0 = 8bits, 1 = 16bits) for baseline checking */
{
  JQUANT_TBL * qtbl = cinfo->quant_tbl_ptrs[index];
  int prec;
  int i;

  if (qtbl == NULL)
    ERREXIT1(cinfo, JERR_NO_QUANT_TABLE, index);

  prec = 0;
  for (i = 0; i < DCTSIZE2; i++) {
    if (qtbl->quantval[i] > 255)
      prec = 1;
  }

  if (! qtbl->sent_table) {
    emit_marker(cinfo, M_DQT);

    emit_2bytes(cinfo, prec ? DCTSIZE2*2 + 1 + 2 : DCTSIZE2 + 1 + 2);

    emit_byte(cinfo, index + (prec<<4));

    for (i = 0; i < DCTSIZE2; i++) {
      /* The table entries must be emitted in zigzag order. */
      unsigned int qval = qtbl->quantval[jpeg_natural_order[i]];
      if (prec)
	emit_byte(cinfo, qval >> 8);
      emit_byte(cinfo, qval & 0xFF);
    }

    qtbl->sent_table = TRUE;
  }

  return prec;
}


LOCAL(void)
emit_dht (j_compress_ptr cinfo, int index, boolean is_ac)
/* Emit a DHT marker */
{
  JHUFF_TBL * htbl;
  int length, i;
  
  if (is_ac) {
    htbl = cinfo->ac_huff_tbl_ptrs[index];
    index += 0x10;		/* output index has AC bit set */
  } else {
    htbl = cinfo->dc_huff_tbl_ptrs[index];
  }

  if (htbl == NULL)
    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, index);
  
  if (! htbl->sent_table) {
    emit_marker(cinfo, M_DHT);
    
    length = 0;
    for (i = 1; i <= 16; i++)
      length += htbl->bits[i];
    
    emit_2bytes(cinfo, length + 2 + 1 + 16);
    emit_byte(cinfo, index);
    
    for (i = 1; i <= 16; i++)
      emit_byte(cinfo, htbl->bits[i]);
    
    for (i = 0; i < length; i++)
      emit_byte(cinfo, htbl->huffval[i]);
    
    htbl->sent_table = TRUE;
  }
}


LOCAL(void)
emit_dac (j_compress_ptr cinfo)
/* Emit a DAC marker */
/* Since the useful info is so small, we want to emit all the tables in */
/* one DAC marker.  Therefore this routine does its own scan of the table. */
{
#ifdef C_ARITH_CODING_SUPPORTED
  char dc_in_use[NUM_ARITH_TBLS];
  char ac_in_use[NUM_ARITH_TBLS];
  int length, i;
  jpeg_component_info *compptr;
  
  for (i = 0; i < NUM_ARITH_TBLS; i++)
    dc_in_use[i] = ac_in_use[i] = 0;
  
  for (i = 0; i < cinfo->comps_in_scan; i++) {
    compptr = cinfo->cur_comp_info[i];
    dc_in_use[compptr->dc_tbl_no] = 1;
    ac_in_use[compptr->ac_tbl_no] = 1;
  }
  
  length = 0;
  for (i = 0; i < NUM_ARITH_TBLS; i++)
    length += dc_in_use[i] + ac_in_use[i];
  
  emit_marker(cinfo, M_DAC);
  
  emit_2bytes(cinfo, length*2 + 2);
  
  for (i = 0; i < NUM_ARITH_TBLS; i++) {
    if (dc_in_use[i]) {
      emit_byte(cinfo, i);
      emit_byte(cinfo, cinfo->arith_dc_L[i] + (cinfo->arith_dc_U[i]<<4));
    }
    if (ac_in_use[i]) {
      emit_byte(cinfo, i + 0x10);
      emit_byte(cinfo, cinfo->arith_ac_K[i]);
    }
  }
#endif /* C_ARITH_CODING_SUPPORTED */
}


LOCAL(void)
emit_dri (j_compress_ptr cinfo)
/* Emit a DRI marker */
{
  emit_marker(cinfo, M_DRI);
  
  emit_2bytes(cinfo, 4);	/* fixed length */

  emit_2bytes(cinfo, (int) cinfo->restart_interval);
}


LOCAL(void)
emit_sof (j_compress_ptr cinfo, JPEG_MARKER code)
/* Emit a SOF marker */
{
  int ci;
  jpeg_component_info *compptr;
  
  emit_marker(cinfo, code);
  
  emit_2bytes(cinfo, 3 * cinfo->num_components + 2 + 5 + 1); /* length */

  /* Make sure image isn't bigger than SOF field can handle */
  if ((long) cinfo->image_height > 65535L ||
      (long) cinfo->image_width > 65535L)
    ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, (unsigned int) 65535);

  emit_byte(cinfo, cinfo->data_precision);
  emit_2bytes(cinfo, (int) cinfo->image_height);
  emit_2bytes(cinfo, (int) cinfo->image_width);

  emit_byte(cinfo, cinfo->num_components);

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    emit_byte(cinfo, compptr->component_id);
    emit_byte(cinfo, (compptr->h_samp_factor << 4) + compptr->v_samp_factor);
    emit_byte(cinfo, compptr->quant_tbl_no);
  }
}


LOCAL(void)
emit_sos (j_compress_ptr cinfo)
/* Emit a SOS marker */
{
  int i, td, ta;
  jpeg_component_info *compptr;
  
  emit_marker(cinfo, M_SOS);
  
  emit_2bytes(cinfo, 2 * cinfo->comps_in_scan + 2 + 1 + 3); /* length */
  
  emit_byte(cinfo, cinfo->comps_in_scan);
  
  for (i = 0; i < cinfo->comps_in_scan; i++) {
    compptr = cinfo->cur_comp_info[i];
    emit_byte(cinfo, compptr->component_id);
    td = compptr->dc_tbl_no;
    ta = compptr->ac_tbl_no;
    if (cinfo->progressive_mode) {
      /* Progressive mode: only DC or only AC tables are used in one scan;
       * furthermore, Huffman coding of DC refinement uses no table at all.
       * We emit 0 for unused field(s); this is recommended by the P&M text
       * but does not seem to be specified in the standard.
       */
      if (cinfo->Ss == 0) {
	ta = 0;			/* DC scan */
	if (cinfo->Ah != 0 && !cinfo->arith_code)
	  td = 0;		/* no DC table either */
      } else {
	td = 0;			/* AC scan */
      }
    }
    emit_byte(cinfo, (td << 4) + ta);
  }

  emit_byte(cinfo, cinfo->Ss);
  emit_byte(cinfo, cinfo->Se);
  emit_byte(cinfo, (cinfo->Ah << 4) + cinfo->Al);
}


LOCAL(void)
emit_jfif_app0 (j_compress_ptr cinfo)
/* Emit a JFIF-compliant APP0 marker */
{
  /*
   * Length of APP0 block	(2 bytes)
   * Block ID			(4 bytes - ASCII "JFIF")
   * Zero byte			(1 byte to terminate the ID string)
   * Version Major, Minor	(2 bytes - 0x01, 0x01)
   * Units			(1 byte - 0x00 = none, 0x01 = inch, 0x02 = cm)
   * Xdpu			(2 bytes - dots per unit horizontal)
   * Ydpu			(2 bytes - dots per unit vertical)
   * Thumbnail X size		(1 byte)
   * Thumbnail Y size		(1 byte)
   */
  
  emit_marker(cinfo, M_APP0);
  
  emit_2bytes(cinfo, 2 + 4 + 1 + 2 + 1 + 2 + 2 + 1 + 1); /* length */

  emit_byte(cinfo, 0x4A);	/* Identifier: ASCII "JFIF" */
  emit_byte(cinfo, 0x46);
  emit_byte(cinfo, 0x49);
  emit_byte(cinfo, 0x46);
  emit_byte(cinfo, 0);
  /* We currently emit version code 1.01 since we use no 1.02 features.
   * This may avoid complaints from some older decoders.
   */
  emit_byte(cinfo, 1);		/* Major version */
  emit_byte(cinfo, 1);		/* Minor version */
  emit_byte(cinfo, cinfo->density_unit); /* Pixel size information */
  emit_2bytes(cinfo, (int) cinfo->X_density);
  emit_2bytes(cinfo, (int) cinfo->Y_density);
  emit_byte(cinfo, 0);		/* No thumbnail image */
  emit_byte(cinfo, 0);
}


LOCAL(void)
emit_adobe_app14 (j_compress_ptr cinfo)
/* Emit an Adobe APP14 marker */
{
  /*
   * Length of APP14 block	(2 bytes)
   * Block ID			(5 bytes - ASCII "Adobe")
   * Version Number		(2 bytes - currently 100)
   * Flags0			(2 bytes - currently 0)
   * Flags1			(2 bytes - currently 0)
   * Color transform		(1 byte)
   *
   * Although Adobe TN 5116 mentions Version = 101, all the Adobe files
   * now in circulation seem to use Version = 100, so that's what we write.
   *
   * We write the color transform byte as 1 if the JPEG color space is
   * YCbCr, 2 if it's YCCK, 0 otherwise.  Adobe's definition has to do with
   * whether the encoder performed a transformation, which is pretty useless.
   */
  
  emit_marker(cinfo, M_APP14);
  
  emit_2bytes(cinfo, 2 + 5 + 2 + 2 + 2 + 1); /* length */

  emit_byte(cinfo, 0x41);	/* Identifier: ASCII "Adobe" */
  emit_byte(cinfo, 0x64);
  emit_byte(cinfo, 0x6F);
  emit_byte(cinfo, 0x62);
  emit_byte(cinfo, 0x65);
  emit_2bytes(cinfo, 100);	/* Version */
  emit_2bytes(cinfo, 0);	/* Flags0 */
  emit_2bytes(cinfo, 0);	/* Flags1 */
  switch (cinfo->jpeg_color_space) {
  case JCS_YCbCr:
    emit_byte(cinfo, 1);	/* Color transform = 1 */
    break;
  case JCS_YCCK:
    emit_byte(cinfo, 2);	/* Color transform = 2 */
    break;
  default:
    emit_byte(cinfo, 0);	/* Color transform = 0 */
    break;
  }
}


/*
 * This routine is exported for possible use by applications.
 * The intended use is to emit COM or APPn markers after calling
 * jpeg_start_compress() and before the first jpeg_write_scanlines() call
 * (hence, after write_file_header but before write_frame_header).
 * Other uses are not guaranteed to produce desirable results.
 */

METHODDEF(void)
write_any_marker (j_compress_ptr cinfo, int marker,
		  const JOCTET *dataptr, unsigned int datalen)
/* Emit an arbitrary marker with parameters */
{
  if (datalen <= (unsigned int) 65533) { /* safety check */
    emit_marker(cinfo, (JPEG_MARKER) marker);
  
    emit_2bytes(cinfo, (int) (datalen + 2)); /* total length */

    while (datalen--) {
      emit_byte(cinfo, *dataptr);
      dataptr++;
    }
  }
}


/*
 * Write datastream header.
 * This consists of an SOI and optional APPn markers.
 * We recommend use of the JFIF marker, but not the Adobe marker,
 * when using YCbCr or grayscale data.  The JFIF marker should NOT
 * be used for any other JPEG colorspace.  The Adobe marker is helpful
 * to distinguish RGB, CMYK, and YCCK colorspaces.
 * Note that an application can write additional header markers after
 * jpeg_start_compress returns.
 */

METHODDEF(void)
write_file_header (j_compress_ptr cinfo)
{
  emit_marker(cinfo, M_SOI);	/* first the SOI */

  if (cinfo->write_JFIF_header)	/* next an optional JFIF APP0 */
    emit_jfif_app0(cinfo);
  if (cinfo->write_Adobe_marker) /* next an optional Adobe APP14 */
    emit_adobe_app14(cinfo);
}


/*
 * Write frame header.
 * This consists of DQT and SOFn markers.
 * Note that we do not emit the SOF until we have emitted the DQT(s).
 * This avoids compatibility problems with incorrect implementations that
 * try to error-check the quant table numbers as soon as they see the SOF.
 */

METHODDEF(void)
write_frame_header (j_compress_ptr cinfo)
{
  int ci, prec;
  boolean is_baseline;
  jpeg_component_info *compptr;
  
  /* Emit DQT for each quantization table.
   * Note that emit_dqt() suppresses any duplicate tables.
   */
  prec = 0;
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    prec += emit_dqt(cinfo, compptr->quant_tbl_no);
  }
  /* now prec is nonzero iff there are any 16-bit quant tables. */

  /* Check for a non-baseline specification.
   * Note we assume that Huffman table numbers won't be changed later.
   */
  if (cinfo->arith_code || cinfo->progressive_mode ||
      cinfo->data_precision != 8) {
    is_baseline = FALSE;
  } else {
    is_baseline = TRUE;
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
	 ci++, compptr++) {
      if (compptr->dc_tbl_no > 1 || compptr->ac_tbl_no > 1)
	is_baseline = FALSE;
    }
    if (prec && is_baseline) {
      is_baseline = FALSE;
      /* If it's baseline except for quantizer size, warn the user */
      TRACEMS(cinfo, 0, JTRC_16BIT_TABLES);
    }
  }

  /* Emit the proper SOF marker */
  if (cinfo->arith_code) {
    emit_sof(cinfo, M_SOF9);	/* SOF code for arithmetic coding */
  } else {
    if (cinfo->progressive_mode)
      emit_sof(cinfo, M_SOF2);	/* SOF code for progressive Huffman */
    else if (is_baseline)
      emit_sof(cinfo, M_SOF0);	/* SOF code for baseline implementation */
    else
      emit_sof(cinfo, M_SOF1);	/* SOF code for non-baseline Huffman file */
  }
}


/*
 * Write scan header.
 * This consists of DHT or DAC markers, optional DRI, and SOS.
 * Compressed data will be written following the SOS.
 */

METHODDEF(void)
write_scan_header (j_compress_ptr cinfo)
{
  int i;
  jpeg_component_info *compptr;

  if (cinfo->arith_code) {
    /* Emit arith conditioning info.  We may have some duplication
     * if the file has multiple scans, but it's so small it's hardly
     * worth worrying about.
     */
    emit_dac(cinfo);
  } else {
    /* Emit Huffman tables.
     * Note that emit_dht() suppresses any duplicate tables.
     */
    for (i = 0; i < cinfo->comps_in_scan; i++) {
      compptr = cinfo->cur_comp_info[i];
      if (cinfo->progressive_mode) {
	/* Progressive mode: only DC or only AC tables are used in one scan */
	if (cinfo->Ss == 0) {
	  if (cinfo->Ah == 0)	/* DC needs no table for refinement scan */
	    emit_dht(cinfo, compptr->dc_tbl_no, FALSE);
	} else {
	  emit_dht(cinfo, compptr->ac_tbl_no, TRUE);
	}
      } else {
	/* Sequential mode: need both DC and AC tables */
	emit_dht(cinfo, compptr->dc_tbl_no, FALSE);
	emit_dht(cinfo, compptr->ac_tbl_no, TRUE);
      }
    }
  }

  /* Emit DRI if required --- note that DRI value could change for each scan.
   * If it doesn't, a tiny amount of space is wasted in multiple-scan files.
   * We assume DRI will never be nonzero for one scan and zero for a later one.
   */
  if (cinfo->restart_interval)
    emit_dri(cinfo);

  emit_sos(cinfo);
}


/*
 * Write datastream trailer.
 */

METHODDEF(void)
write_file_trailer (j_compress_ptr cinfo)
{
  emit_marker(cinfo, M_EOI);
}


/*
 * Write an abbreviated table-specification datastream.
 * This consists of SOI, DQT and DHT tables, and EOI.
 * Any table that is defined and not marked sent_table = TRUE will be
 * emitted.  Note that all tables will be marked sent_table = TRUE at exit.
 */

METHODDEF(void)
write_tables_only (j_compress_ptr cinfo)
{
  int i;

  emit_marker(cinfo, M_SOI);

  for (i = 0; i < NUM_QUANT_TBLS; i++) {
    if (cinfo->quant_tbl_ptrs[i] != NULL)
      (void) emit_dqt(cinfo, i);
  }

  if (! cinfo->arith_code) {
    for (i = 0; i < NUM_HUFF_TBLS; i++) {
      if (cinfo->dc_huff_tbl_ptrs[i] != NULL)
	emit_dht(cinfo, i, FALSE);
      if (cinfo->ac_huff_tbl_ptrs[i] != NULL)
	emit_dht(cinfo, i, TRUE);
    }
  }

  emit_marker(cinfo, M_EOI);
}


/*
 * Initialize the marker writer module.
 */

GLOBAL(void)
jinit_marker_writer (j_compress_ptr cinfo)
{
  /* Create the subobject */
  cinfo->marker = (struct jpeg_marker_writer *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(struct jpeg_marker_writer));
  /* Initialize method pointers */
  cinfo->marker->write_any_marker = write_any_marker;
  cinfo->marker->write_file_header = write_file_header;
  cinfo->marker->write_frame_header = write_frame_header;
  cinfo->marker->write_scan_header = write_scan_header;
  cinfo->marker->write_file_trailer = write_file_trailer;
  cinfo->marker->write_tables_only = write_tables_only;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\jcomapi.c ===
/*
 * jcomapi.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains application interface routines that are used for both
 * compression and decompression.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/*
 * Abort processing of a JPEG compression or decompression operation,
 * but don't destroy the object itself.
 *
 * For this, we merely clean up all the nonpermanent memory pools.
 * Note that temp files (virtual arrays) are not allowed to belong to
 * the permanent pool, so we will be able to close all temp files here.
 * Closing a data source or destination, if necessary, is the application's
 * responsibility.
 */

GLOBAL(void)
jpeg_abort (j_common_ptr cinfo)
{
  int pool;

  /* Releasing pools in reverse order might help avoid fragmentation
   * with some (brain-damaged) malloc libraries.
   */
  for (pool = JPOOL_NUMPOOLS-1; pool > JPOOL_PERMANENT; pool--) {
    (*cinfo->mem->free_pool) (cinfo, pool);
  }

  /* Reset overall state for possible reuse of object */
  cinfo->global_state = (cinfo->is_decompressor ? DSTATE_START : CSTATE_START);
}


/*
 * Destruction of a JPEG object.
 *
 * Everything gets deallocated except the master jpeg_compress_struct itself
 * and the error manager struct.  Both of these are supplied by the application
 * and must be freed, if necessary, by the application.  (Often they are on
 * the stack and so don't need to be freed anyway.)
 * Closing a data source or destination, if necessary, is the application's
 * responsibility.
 */

GLOBAL(void)
jpeg_destroy (j_common_ptr cinfo)
{
  /* We need only tell the memory manager to release everything. */
  /* NB: mem pointer is NULL if memory mgr failed to initialize. */
  if (cinfo->mem != NULL)
    (*cinfo->mem->self_destruct) (cinfo);
  cinfo->mem = NULL;		/* be safe if jpeg_destroy is called twice */
  cinfo->global_state = 0;	/* mark it destroyed */
}


/*
 * Convenience routines for allocating quantization and Huffman tables.
 * (Would jutils.c be a more reasonable place to put these?)
 */

GLOBAL(JQUANT_TBL *)
jpeg_alloc_quant_table (j_common_ptr cinfo)
{
  JQUANT_TBL *tbl;

  tbl = (JQUANT_TBL *)
    (*cinfo->mem->alloc_small) (cinfo, JPOOL_PERMANENT, SIZEOF(JQUANT_TBL));
  tbl->sent_table = FALSE;	/* make sure this is false in any new table */
  return tbl;
}


GLOBAL(JHUFF_TBL *)
jpeg_alloc_huff_table (j_common_ptr cinfo)
{
  JHUFF_TBL *tbl;

  tbl = (JHUFF_TBL *)
    (*cinfo->mem->alloc_small) (cinfo, JPOOL_PERMANENT, SIZEOF(JHUFF_TBL));
  tbl->sent_table = FALSE;	/* make sure this is false in any new table */
  return tbl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\jcmaster.c ===
/*
 * jcmaster.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains master control logic for the JPEG compressor.
 * These routines are concerned with parameter validation, initial setup,
 * and inter-pass control (determining the number of passes and the work 
 * to be done in each pass).
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/* Private state */

typedef enum {
	main_pass,		/* input data, also do first output step */
	huff_opt_pass,		/* Huffman code optimization pass */
	output_pass		/* data output pass */
} c_pass_type;

typedef struct {
  struct jpeg_comp_master pub;	/* public fields */

  c_pass_type pass_type;	/* the type of the current pass */

  int pass_number;		/* # of passes completed */
  int total_passes;		/* total # of passes needed */

  int scan_number;		/* current index in scan_info[] */
} my_comp_master;

typedef my_comp_master * my_master_ptr;


/*
 * Support routines that do various essential calculations.
 */

LOCAL(void)
initial_setup (j_compress_ptr cinfo)
/* Do computations that are needed before master selection phase */
{
  int ci;
  jpeg_component_info *compptr;
  long samplesperrow;
  JDIMENSION jd_samplesperrow;

  /* Sanity check on image dimensions */
  if (cinfo->image_height <= 0 || cinfo->image_width <= 0
      || cinfo->num_components <= 0 || cinfo->input_components <= 0)
    ERREXIT(cinfo, JERR_EMPTY_IMAGE);

  /* Make sure image isn't bigger than I can handle */
  if ((long) cinfo->image_height > (long) JPEG_MAX_DIMENSION ||
      (long) cinfo->image_width > (long) JPEG_MAX_DIMENSION)
    ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, (unsigned int) JPEG_MAX_DIMENSION);

  /* Width of an input scanline must be representable as JDIMENSION. */
  samplesperrow = (long) cinfo->image_width * (long) cinfo->input_components;
  jd_samplesperrow = (JDIMENSION) samplesperrow;
  if ((long) jd_samplesperrow != samplesperrow)
    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);

  /* For now, precision must match compiled-in value... */
  if (cinfo->data_precision != BITS_IN_JSAMPLE)
    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);

  /* Check that number of components won't exceed internal array sizes */
  if (cinfo->num_components > MAX_COMPONENTS)
    ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,
	     MAX_COMPONENTS);

  /* Compute maximum sampling factors; check factor validity */
  cinfo->max_h_samp_factor = 1;
  cinfo->max_v_samp_factor = 1;
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    if (compptr->h_samp_factor<=0 || compptr->h_samp_factor>MAX_SAMP_FACTOR ||
	compptr->v_samp_factor<=0 || compptr->v_samp_factor>MAX_SAMP_FACTOR)
      ERREXIT(cinfo, JERR_BAD_SAMPLING);
    cinfo->max_h_samp_factor = MAX(cinfo->max_h_samp_factor,
				   compptr->h_samp_factor);
    cinfo->max_v_samp_factor = MAX(cinfo->max_v_samp_factor,
				   compptr->v_samp_factor);
  }

  /* Compute dimensions of components */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Fill in the correct component_index value; don't rely on application */
    compptr->component_index = ci;
    /* For compression, we never do DCT scaling. */
    compptr->DCT_scaled_size = DCTSIZE;
    /* Size in DCT blocks */
    compptr->width_in_blocks = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
    compptr->height_in_blocks = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
		    (long) (cinfo->max_v_samp_factor * DCTSIZE));
    /* Size in samples */
    compptr->downsampled_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
		    (long) cinfo->max_h_samp_factor);
    compptr->downsampled_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
		    (long) cinfo->max_v_samp_factor);
    /* Mark component needed (this flag isn't actually used for compression) */
    compptr->component_needed = TRUE;
  }

  /* Compute number of fully interleaved MCU rows (number of times that
   * main controller will call coefficient controller).
   */
  cinfo->total_iMCU_rows = (JDIMENSION)
    jdiv_round_up((long) cinfo->image_height,
		  (long) (cinfo->max_v_samp_factor*DCTSIZE));
}


#ifdef C_MULTISCAN_FILES_SUPPORTED

LOCAL(void)
validate_script (j_compress_ptr cinfo)
/* Verify that the scan script in cinfo->scan_info[] is valid; also
 * determine whether it uses progressive JPEG, and set cinfo->progressive_mode.
 */
{
  const jpeg_scan_info * scanptr;
  int scanno, ncomps, ci, coefi, thisi;
  int Ss, Se, Ah, Al;
  boolean component_sent[MAX_COMPONENTS];
#ifdef C_PROGRESSIVE_SUPPORTED
  int * last_bitpos_ptr;
  int last_bitpos[MAX_COMPONENTS][DCTSIZE2];
  /* -1 until that coefficient has been seen; then last Al for it */
#endif

  if (cinfo->num_scans <= 0)
    ERREXIT1(cinfo, JERR_BAD_SCAN_SCRIPT, 0);

  /* For sequential JPEG, all scans must have Ss=0, Se=DCTSIZE2-1;
   * for progressive JPEG, no scan can have this.
   */
  scanptr = cinfo->scan_info;
  if (scanptr->Ss != 0 || scanptr->Se != DCTSIZE2-1) {
#ifdef C_PROGRESSIVE_SUPPORTED
    cinfo->progressive_mode = TRUE;
    last_bitpos_ptr = & last_bitpos[0][0];
    for (ci = 0; ci < cinfo->num_components; ci++) 
      for (coefi = 0; coefi < DCTSIZE2; coefi++)
	*last_bitpos_ptr++ = -1;
#else
    ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
  } else {
    cinfo->progressive_mode = FALSE;
    for (ci = 0; ci < cinfo->num_components; ci++) 
      component_sent[ci] = FALSE;
  }

  for (scanno = 1; scanno <= cinfo->num_scans; scanptr++, scanno++) {
    /* Validate component indexes */
    ncomps = scanptr->comps_in_scan;
    if (ncomps <= 0 || ncomps > MAX_COMPS_IN_SCAN)
      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, ncomps, MAX_COMPS_IN_SCAN);
    for (ci = 0; ci < ncomps; ci++) {
      thisi = scanptr->component_index[ci];
      if (thisi < 0 || thisi >= cinfo->num_components)
	ERREXIT1(cinfo, JERR_BAD_SCAN_SCRIPT, scanno);
      /* Components must appear in SOF order within each scan */
      if (ci > 0 && thisi <= scanptr->component_index[ci-1])
	ERREXIT1(cinfo, JERR_BAD_SCAN_SCRIPT, scanno);
    }
    /* Validate progression parameters */
    Ss = scanptr->Ss;
    Se = scanptr->Se;
    Ah = scanptr->Ah;
    Al = scanptr->Al;
    if (cinfo->progressive_mode) {
#ifdef C_PROGRESSIVE_SUPPORTED
      if (Ss < 0 || Ss >= DCTSIZE2 || Se < Ss || Se >= DCTSIZE2 ||
	  Ah < 0 || Ah > 13 || Al < 0 || Al > 13)
	ERREXIT1(cinfo, JERR_BAD_PROG_SCRIPT, scanno);
      if (Ss == 0) {
	if (Se != 0)		/* DC and AC together not OK */
	  ERREXIT1(cinfo, JERR_BAD_PROG_SCRIPT, scanno);
      } else {
	if (ncomps != 1)	/* AC scans must be for only one component */
	  ERREXIT1(cinfo, JERR_BAD_PROG_SCRIPT, scanno);
      }
      for (ci = 0; ci < ncomps; ci++) {
	last_bitpos_ptr = & last_bitpos[scanptr->component_index[ci]][0];
	if (Ss != 0 && last_bitpos_ptr[0] < 0) /* AC without prior DC scan */
	  ERREXIT1(cinfo, JERR_BAD_PROG_SCRIPT, scanno);
	for (coefi = Ss; coefi <= Se; coefi++) {
	  if (last_bitpos_ptr[coefi] < 0) {
	    /* first scan of this coefficient */
	    if (Ah != 0)
	      ERREXIT1(cinfo, JERR_BAD_PROG_SCRIPT, scanno);
	  } else {
	    /* not first scan */
	    if (Ah != last_bitpos_ptr[coefi] || Al != Ah-1)
	      ERREXIT1(cinfo, JERR_BAD_PROG_SCRIPT, scanno);
	  }
	  last_bitpos_ptr[coefi] = Al;
	}
      }
#endif
    } else {
      /* For sequential JPEG, all progression parameters must be these: */
      if (Ss != 0 || Se != DCTSIZE2-1 || Ah != 0 || Al != 0)
	ERREXIT1(cinfo, JERR_BAD_PROG_SCRIPT, scanno);
      /* Make sure components are not sent twice */
      for (ci = 0; ci < ncomps; ci++) {
	thisi = scanptr->component_index[ci];
	if (component_sent[thisi])
	  ERREXIT1(cinfo, JERR_BAD_SCAN_SCRIPT, scanno);
	component_sent[thisi] = TRUE;
      }
    }
  }

  /* Now verify that everything got sent. */
  if (cinfo->progressive_mode) {
#ifdef C_PROGRESSIVE_SUPPORTED
    /* For progressive mode, we only check that at least some DC data
     * got sent for each component; the spec does not require that all bits
     * of all coefficients be transmitted.  Would it be wiser to enforce
     * transmission of all coefficient bits??
     */
    for (ci = 0; ci < cinfo->num_components; ci++) {
      if (last_bitpos[ci][0] < 0)
	ERREXIT(cinfo, JERR_MISSING_DATA);
    }
#endif
  } else {
    for (ci = 0; ci < cinfo->num_components; ci++) {
      if (! component_sent[ci])
	ERREXIT(cinfo, JERR_MISSING_DATA);
    }
  }
}

#endif /* C_MULTISCAN_FILES_SUPPORTED */


LOCAL(void)
select_scan_parameters (j_compress_ptr cinfo)
/* Set up the scan parameters for the current scan */
{
  int ci;

#ifdef C_MULTISCAN_FILES_SUPPORTED
  if (cinfo->scan_info != NULL) {
    /* Prepare for current scan --- the script is already validated */
    my_master_ptr master = (my_master_ptr) cinfo->master;
    const jpeg_scan_info * scanptr = cinfo->scan_info + master->scan_number;

    cinfo->comps_in_scan = scanptr->comps_in_scan;
    for (ci = 0; ci < scanptr->comps_in_scan; ci++) {
      cinfo->cur_comp_info[ci] =
	&cinfo->comp_info[scanptr->component_index[ci]];
    }
    cinfo->Ss = scanptr->Ss;
    cinfo->Se = scanptr->Se;
    cinfo->Ah = scanptr->Ah;
    cinfo->Al = scanptr->Al;
  }
  else
#endif
  {
    /* Prepare for single sequential-JPEG scan containing all components */
    if (cinfo->num_components > MAX_COMPS_IN_SCAN)
      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,
	       MAX_COMPS_IN_SCAN);
    cinfo->comps_in_scan = cinfo->num_components;
    for (ci = 0; ci < cinfo->num_components; ci++) {
      cinfo->cur_comp_info[ci] = &cinfo->comp_info[ci];
    }
    cinfo->Ss = 0;
    cinfo->Se = DCTSIZE2-1;
    cinfo->Ah = 0;
    cinfo->Al = 0;
  }
}


LOCAL(void)
per_scan_setup (j_compress_ptr cinfo)
/* Do computations that are needed before processing a JPEG scan */
/* cinfo->comps_in_scan and cinfo->cur_comp_info[] are already set */
{
  int ci, mcublks, tmp;
  jpeg_component_info *compptr;
  
  if (cinfo->comps_in_scan == 1) {
    
    /* Noninterleaved (single-component) scan */
    compptr = cinfo->cur_comp_info[0];
    
    /* Overall image size in MCUs */
    cinfo->MCUs_per_row = compptr->width_in_blocks;
    cinfo->MCU_rows_in_scan = compptr->height_in_blocks;
    
    /* For noninterleaved scan, always one block per MCU */
    compptr->MCU_width = 1;
    compptr->MCU_height = 1;
    compptr->MCU_blocks = 1;
    compptr->MCU_sample_width = DCTSIZE;
    compptr->last_col_width = 1;
    /* For noninterleaved scans, it is convenient to define last_row_height
     * as the number of block rows present in the last iMCU row.
     */
    tmp = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
    if (tmp == 0) tmp = compptr->v_samp_factor;
    compptr->last_row_height = tmp;
    
    /* Prepare array describing MCU composition */
    cinfo->blocks_in_MCU = 1;
    cinfo->MCU_membership[0] = 0;
    
  } else {
    
    /* Interleaved (multi-component) scan */
    if (cinfo->comps_in_scan <= 0 || cinfo->comps_in_scan > MAX_COMPS_IN_SCAN)
      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->comps_in_scan,
	       MAX_COMPS_IN_SCAN);
    
    /* Overall image size in MCUs */
    cinfo->MCUs_per_row = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width,
		    (long) (cinfo->max_h_samp_factor*DCTSIZE));
    cinfo->MCU_rows_in_scan = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height,
		    (long) (cinfo->max_v_samp_factor*DCTSIZE));
    
    cinfo->blocks_in_MCU = 0;
    
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
      compptr = cinfo->cur_comp_info[ci];
      /* Sampling factors give # of blocks of component in each MCU */
      compptr->MCU_width = compptr->h_samp_factor;
      compptr->MCU_height = compptr->v_samp_factor;
      compptr->MCU_blocks = compptr->MCU_width * compptr->MCU_height;
      compptr->MCU_sample_width = compptr->MCU_width * DCTSIZE;
      /* Figure number of non-dummy blocks in last MCU column & row */
      tmp = (int) (compptr->width_in_blocks % compptr->MCU_width);
      if (tmp == 0) tmp = compptr->MCU_width;
      compptr->last_col_width = tmp;
      tmp = (int) (compptr->height_in_blocks % compptr->MCU_height);
      if (tmp == 0) tmp = compptr->MCU_height;
      compptr->last_row_height = tmp;
      /* Prepare array describing MCU composition */
      mcublks = compptr->MCU_blocks;
      if (cinfo->blocks_in_MCU + mcublks > C_MAX_BLOCKS_IN_MCU)
	ERREXIT(cinfo, JERR_BAD_MCU_SIZE);
      while (mcublks-- > 0) {
	cinfo->MCU_membership[cinfo->blocks_in_MCU++] = ci;
      }
    }
    
  }

  /* Convert restart specified in rows to actual MCU count. */
  /* Note that count must fit in 16 bits, so we provide limiting. */
  if (cinfo->restart_in_rows > 0) {
    long nominal = (long) cinfo->restart_in_rows * (long) cinfo->MCUs_per_row;
    cinfo->restart_interval = (unsigned int) MIN(nominal, 65535L);
  }
}


/*
 * Per-pass setup.
 * This is called at the beginning of each pass.  We determine which modules
 * will be active during this pass and give them appropriate start_pass calls.
 * We also set is_last_pass to indicate whether any more passes will be
 * required.
 */

METHODDEF(void)
prepare_for_pass (j_compress_ptr cinfo)
{
  my_master_ptr master = (my_master_ptr) cinfo->master;

  switch (master->pass_type) {
  case main_pass:
    /* Initial pass: will collect input data, and do either Huffman
     * optimization or data output for the first scan.
     */
    select_scan_parameters(cinfo);
    per_scan_setup(cinfo);
    if (! cinfo->raw_data_in) {
      (*cinfo->cconvert->start_pass) (cinfo);
      (*cinfo->downsample->start_pass) (cinfo);
      (*cinfo->prep->start_pass) (cinfo, JBUF_PASS_THRU);
    }
    (*cinfo->fdct->start_pass) (cinfo);
    (*cinfo->entropy->start_pass) (cinfo, cinfo->optimize_coding);
    (*cinfo->coef->start_pass) (cinfo,
				(master->total_passes > 1 ?
				 JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));
    (*cinfo->main->start_pass) (cinfo, JBUF_PASS_THRU);
    if (cinfo->optimize_coding) {
      /* No immediate data output; postpone writing frame/scan headers */
      master->pub.call_pass_startup = FALSE;
    } else {
      /* Will write frame/scan headers at first jpeg_write_scanlines call */
      master->pub.call_pass_startup = TRUE;
    }
    break;
#ifdef ENTROPY_OPT_SUPPORTED
  case huff_opt_pass:
    /* Do Huffman optimization for a scan after the first one. */
    select_scan_parameters(cinfo);
    per_scan_setup(cinfo);
    if (cinfo->Ss != 0 || cinfo->Ah == 0 || cinfo->arith_code) {
      (*cinfo->entropy->start_pass) (cinfo, TRUE);
      (*cinfo->coef->start_pass) (cinfo, JBUF_CRANK_DEST);
      master->pub.call_pass_startup = FALSE;
      break;
    }
    /* Special case: Huffman DC refinement scans need no Huffman table
     * and therefore we can skip the optimization pass for them.
     */
    master->pass_type = output_pass;
    master->pass_number++;
    /*FALLTHROUGH*/
#endif
  case output_pass:
    /* Do a data-output pass. */
    /* We need not repeat per-scan setup if prior optimization pass did it. */
    if (! cinfo->optimize_coding) {
      select_scan_parameters(cinfo);
      per_scan_setup(cinfo);
    }
    (*cinfo->entropy->start_pass) (cinfo, FALSE);
    (*cinfo->coef->start_pass) (cinfo, JBUF_CRANK_DEST);
    /* We emit frame/scan headers now */
    if (master->scan_number == 0)
      (*cinfo->marker->write_frame_header) (cinfo);
    (*cinfo->marker->write_scan_header) (cinfo);
    master->pub.call_pass_startup = FALSE;
    break;
  default:
    ERREXIT(cinfo, JERR_NOT_COMPILED);
  }

  master->pub.is_last_pass = (master->pass_number == master->total_passes-1);

  /* Set up progress monitor's pass info if present */
  if (cinfo->progress != NULL) {
    cinfo->progress->completed_passes = master->pass_number;
    cinfo->progress->total_passes = master->total_passes;
  }
}


/*
 * Special start-of-pass hook.
 * This is called by jpeg_write_scanlines if call_pass_startup is TRUE.
 * In single-pass processing, we need this hook because we don't want to
 * write frame/scan headers during jpeg_start_compress; we want to let the
 * application write COM markers etc. between jpeg_start_compress and the
 * jpeg_write_scanlines loop.
 * In multi-pass processing, this routine is not used.
 */

METHODDEF(void)
pass_startup (j_compress_ptr cinfo)
{
  cinfo->master->call_pass_startup = FALSE; /* reset flag so call only once */

  (*cinfo->marker->write_frame_header) (cinfo);
  (*cinfo->marker->write_scan_header) (cinfo);
}


/*
 * Finish up at end of pass.
 */

METHODDEF(void)
finish_pass_master (j_compress_ptr cinfo)
{
  my_master_ptr master = (my_master_ptr) cinfo->master;

  /* The entropy coder always needs an end-of-pass call,
   * either to analyze statistics or to flush its output buffer.
   */
  (*cinfo->entropy->finish_pass) (cinfo);

  /* Update state for next pass */
  switch (master->pass_type) {
  case main_pass:
    /* next pass is either output of scan 0 (after optimization)
     * or output of scan 1 (if no optimization).
     */
    master->pass_type = output_pass;
    if (! cinfo->optimize_coding)
      master->scan_number++;
    break;
  case huff_opt_pass:
    /* next pass is always output of current scan */
    master->pass_type = output_pass;
    break;
  case output_pass:
    /* next pass is either optimization or output of next scan */
    if (cinfo->optimize_coding)
      master->pass_type = huff_opt_pass;
    master->scan_number++;
    break;
  }

  master->pass_number++;
}


/*
 * Initialize master compression control.
 */

GLOBAL(void)
jinit_c_master_control (j_compress_ptr cinfo, boolean transcode_only)
{
  my_master_ptr master;

  master = (my_master_ptr)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  SIZEOF(my_comp_master));
  cinfo->master = (struct jpeg_comp_master *) master;
  master->pub.prepare_for_pass = prepare_for_pass;
  master->pub.pass_startup = pass_startup;
  master->pub.finish_pass = finish_pass_master;
  master->pub.is_last_pass = FALSE;

  /* Validate parameters, determine derived values */
  initial_setup(cinfo);

  if (cinfo->scan_info != NULL) {
#ifdef C_MULTISCAN_FILES_SUPPORTED
    validate_script(cinfo);
#else
    ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
  } else {
    cinfo->progressive_mode = FALSE;
    cinfo->num_scans = 1;
  }

  if (cinfo->progressive_mode)	/*  TEMPORARY HACK ??? */
    cinfo->optimize_coding = TRUE; /* assume default tables no good for progressive mode */

  /* Initialize my private state */
  if (transcode_only) {
    /* no main pass in transcoding */
    if (cinfo->optimize_coding)
      master->pass_type = huff_opt_pass;
    else
      master->pass_type = output_pass;
  } else {
    /* for normal compression, first pass is always this type: */
    master->pass_type = main_pass;
  }
  master->scan_number = 0;
  master->pass_number = 0;
  if (cinfo->optimize_coding)
    master->total_passes = cinfo->num_scans * 2;
  else
    master->total_passes = cinfo->num_scans;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\jcparam.c ===
/*
 * jcparam.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains optional default-setting code for the JPEG compressor.
 * Applications do not have to use this file, but those that don't use it
 * must know a lot more about the innards of the JPEG code.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/*
 * Quantization table setup routines
 */

GLOBAL(void)
jpeg_add_quant_table (j_compress_ptr cinfo, int which_tbl,
		      const unsigned int *basic_table,
		      int scale_factor, boolean force_baseline)
/* Define a quantization table equal to the basic_table times
 * a scale factor (given as a percentage).
 * If force_baseline is TRUE, the computed quantization table entries
 * are limited to 1..255 for JPEG baseline compatibility.
 */
{
  JQUANT_TBL ** qtblptr = & cinfo->quant_tbl_ptrs[which_tbl];
  int i;
  long temp;

  /* Safety check to ensure start_compress not called yet. */
  if (cinfo->global_state != CSTATE_START)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);

  if (*qtblptr == NULL)
    *qtblptr = jpeg_alloc_quant_table((j_common_ptr) cinfo);

  for (i = 0; i < DCTSIZE2; i++) {
    temp = ((long) basic_table[i] * scale_factor + 50L) / 100L;
    /* limit the values to the valid range */
    if (temp <= 0L) temp = 1L;
    if (temp > 32767L) temp = 32767L; /* max quantizer needed for 12 bits */
    if (force_baseline && temp > 255L)
      temp = 255L;		/* limit to baseline range if requested */
    (*qtblptr)->quantval[i] = (UINT16) temp;
  }

  /* Initialize sent_table FALSE so table will be written to JPEG file. */
  (*qtblptr)->sent_table = FALSE;
}


GLOBAL(void)
jpeg_set_linear_quality (j_compress_ptr cinfo, int scale_factor,
			 boolean force_baseline)
/* Set or change the 'quality' (quantization) setting, using default tables
 * and a straight percentage-scaling quality scale.  In most cases it's better
 * to use jpeg_set_quality (below); this entry point is provided for
 * applications that insist on a linear percentage scaling.
 */
{
  /* These are the sample quantization tables given in JPEG spec section K.1.
   * The spec says that the values given produce "good" quality, and
   * when divided by 2, "very good" quality.
   */
  static const unsigned int std_luminance_quant_tbl[DCTSIZE2] = {
    16,  11,  10,  16,  24,  40,  51,  61,
    12,  12,  14,  19,  26,  58,  60,  55,
    14,  13,  16,  24,  40,  57,  69,  56,
    14,  17,  22,  29,  51,  87,  80,  62,
    18,  22,  37,  56,  68, 109, 103,  77,
    24,  35,  55,  64,  81, 104, 113,  92,
    49,  64,  78,  87, 103, 121, 120, 101,
    72,  92,  95,  98, 112, 100, 103,  99
  };
  static const unsigned int std_chrominance_quant_tbl[DCTSIZE2] = {
    17,  18,  24,  47,  99,  99,  99,  99,
    18,  21,  26,  66,  99,  99,  99,  99,
    24,  26,  56,  99,  99,  99,  99,  99,
    47,  66,  99,  99,  99,  99,  99,  99,
    99,  99,  99,  99,  99,  99,  99,  99,
    99,  99,  99,  99,  99,  99,  99,  99,
    99,  99,  99,  99,  99,  99,  99,  99,
    99,  99,  99,  99,  99,  99,  99,  99
  };

  /* Set up two quantization tables using the specified scaling */
  jpeg_add_quant_table(cinfo, 0, std_luminance_quant_tbl,
		       scale_factor, force_baseline);
  jpeg_add_quant_table(cinfo, 1, std_chrominance_quant_tbl,
		       scale_factor, force_baseline);
}


GLOBAL(int)
jpeg_quality_scaling (int quality)
/* Convert a user-specified quality rating to a percentage scaling factor
 * for an underlying quantization table, using our recommended scaling curve.
 * The input 'quality' factor should be 0 (terrible) to 100 (very good).
 */
{
  /* Safety limit on quality factor.  Convert 0 to 1 to avoid zero divide. */
  if (quality <= 0) quality = 1;
  if (quality > 100) quality = 100;

  /* The basic table is used as-is (scaling 100) for a quality of 50.
   * Qualities 50..100 are converted to scaling percentage 200 - 2*Q;
   * note that at Q=100 the scaling is 0, which will cause jpeg_add_quant_table
   * to make all the table entries 1 (hence, minimum quantization loss).
   * Qualities 1..50 are converted to scaling percentage 5000/Q.
   */
  if (quality < 50)
    quality = 5000 / quality;
  else
    quality = 200 - quality*2;

  return quality;
}


GLOBAL(void)
jpeg_set_quality (j_compress_ptr cinfo, int quality, boolean force_baseline)
/* Set or change the 'quality' (quantization) setting, using default tables.
 * This is the standard quality-adjusting entry point for typical user
 * interfaces; only those who want detailed control over quantization tables
 * would use the preceding three routines directly.
 */
{
  /* Convert user 0-100 rating to percentage scaling */
  quality = jpeg_quality_scaling(quality);

  /* Set up standard quality tables */
  jpeg_set_linear_quality(cinfo, quality, force_baseline);
}


/*
 * Huffman table setup routines
 */

LOCAL(void)
add_huff_table (j_compress_ptr cinfo,
		JHUFF_TBL **htblptr, const UINT8 *bits, const UINT8 *val)
/* Define a Huffman table */
{
  if (*htblptr == NULL)
    *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
  
  MEMCOPY((*htblptr)->bits, bits, SIZEOF((*htblptr)->bits));
  MEMCOPY((*htblptr)->huffval, val, SIZEOF((*htblptr)->huffval));

  /* Initialize sent_table FALSE so table will be written to JPEG file. */
  (*htblptr)->sent_table = FALSE;
}


LOCAL(void)
std_huff_tables (j_compress_ptr cinfo)
/* Set up the standard Huffman tables (cf. JPEG standard section K.3) */
/* IMPORTANT: these are only valid for 8-bit data precision! */
{
  static const UINT8 bits_dc_luminance[17] =
    { /* 0-base */ 0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
  static const UINT8 val_dc_luminance[] =
    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
  
  static const UINT8 bits_dc_chrominance[17] =
    { /* 0-base */ 0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 };
  static const UINT8 val_dc_chrominance[] =
    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
  
  static const UINT8 bits_ac_luminance[17] =
    { /* 0-base */ 0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d };
  static const UINT8 val_ac_luminance[] =
    { 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,
      0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,
      0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08,
      0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0,
      0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16,
      0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28,
      0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
      0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
      0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
      0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
      0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
      0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
      0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,
      0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
      0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6,
      0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5,
      0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4,
      0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2,
      0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea,
      0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
      0xf9, 0xfa };
  
  static const UINT8 bits_ac_chrominance[17] =
    { /* 0-base */ 0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77 };
  static const UINT8 val_ac_chrominance[] =
    { 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21,
      0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,
      0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91,
      0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0,
      0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34,
      0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26,
      0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38,
      0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
      0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
      0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
      0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
      0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
      0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96,
      0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5,
      0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4,
      0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3,
      0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2,
      0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda,
      0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9,
      0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
      0xf9, 0xfa };
  
  add_huff_table(cinfo, &cinfo->dc_huff_tbl_ptrs[0],
		 bits_dc_luminance, val_dc_luminance);
  add_huff_table(cinfo, &cinfo->ac_huff_tbl_ptrs[0],
		 bits_ac_luminance, val_ac_luminance);
  add_huff_table(cinfo, &cinfo->dc_huff_tbl_ptrs[1],
		 bits_dc_chrominance, val_dc_chrominance);
  add_huff_table(cinfo, &cinfo->ac_huff_tbl_ptrs[1],
		 bits_ac_chrominance, val_ac_chrominance);
}


/*
 * Default parameter setup for compression.
 *
 * Applications that don't choose to use this routine must do their
 * own setup of all these parameters.  Alternately, you can call this
 * to establish defaults and then alter parameters selectively.  This
 * is the recommended approach since, if we add any new parameters,
 * your code will still work (they'll be set to reasonable defaults).
 */

GLOBAL(void)
jpeg_set_defaults (j_compress_ptr cinfo)
{
  int i;

  /* Safety check to ensure start_compress not called yet. */
  if (cinfo->global_state != CSTATE_START)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);

  /* Allocate comp_info array large enough for maximum component count.
   * Array is made permanent in case application wants to compress
   * multiple images at same param settings.
   */
  if (cinfo->comp_info == NULL)
    cinfo->comp_info = (jpeg_component_info *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
				  MAX_COMPONENTS * SIZEOF(jpeg_component_info));

  /* Initialize everything not dependent on the color space */

  cinfo->data_precision = BITS_IN_JSAMPLE;
  /* Set up two quantization tables using default quality of 75 */
  jpeg_set_quality(cinfo, 75, TRUE);
  /* Set up two Huffman tables */
  std_huff_tables(cinfo);

  /* Initialize default arithmetic coding conditioning */
  for (i = 0; i < NUM_ARITH_TBLS; i++) {
    cinfo->arith_dc_L[i] = 0;
    cinfo->arith_dc_U[i] = 1;
    cinfo->arith_ac_K[i] = 5;
  }

  /* Default is no multiple-scan output */
  cinfo->scan_info = NULL;
  cinfo->num_scans = 0;

  /* Expect normal source image, not raw downsampled data */
  cinfo->raw_data_in = FALSE;

  /* Use Huffman coding, not arithmetic coding, by default */
  cinfo->arith_code = FALSE;

  /* By default, don't do extra passes to optimize entropy coding */
  cinfo->optimize_coding = FALSE;
  /* The standard Huffman tables are only valid for 8-bit data precision.
   * If the precision is higher, force optimization on so that usable
   * tables will be computed.  This test can be removed if default tables
   * are supplied that are valid for the desired precision.
   */
  if (cinfo->data_precision > 8)
    cinfo->optimize_coding = TRUE;

  /* By default, use the simpler non-cosited sampling alignment */
  cinfo->CCIR601_sampling = FALSE;

  /* No input smoothing */
  cinfo->smoothing_factor = 0;

  /* DCT algorithm preference */
  cinfo->dct_method = JDCT_DEFAULT;

  /* No restart markers */
  cinfo->restart_interval = 0;
  cinfo->restart_in_rows = 0;

  /* Fill in default JFIF marker parameters.  Note that whether the marker
   * will actually be written is determined by jpeg_set_colorspace.
   */
  cinfo->density_unit = 0;	/* Pixel size is unknown by default */
  cinfo->X_density = 1;		/* Pixel aspect ratio is square by default */
  cinfo->Y_density = 1;

  /* Choose JPEG colorspace based on input space, set defaults accordingly */

  jpeg_default_colorspace(cinfo);
}


/*
 * Select an appropriate JPEG colorspace for in_color_space.
 */

GLOBAL(void)
jpeg_default_colorspace (j_compress_ptr cinfo)
{
  switch (cinfo->in_color_space) {
  case JCS_GRAYSCALE:
    jpeg_set_colorspace(cinfo, JCS_GRAYSCALE);
    break;
  case JCS_RGB:
    jpeg_set_colorspace(cinfo, JCS_YCbCr);
    break;
  case JCS_YCbCr:
    jpeg_set_colorspace(cinfo, JCS_YCbCr);
    break;
  case JCS_CMYK:
    jpeg_set_colorspace(cinfo, JCS_CMYK); /* By default, no translation */
    break;
  case JCS_YCCK:
    jpeg_set_colorspace(cinfo, JCS_YCCK);
    break;
  case JCS_UNKNOWN:
    jpeg_set_colorspace(cinfo, JCS_UNKNOWN);
    break;
  default:
    ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
  }
}


/*
 * Set the JPEG colorspace, and choose colorspace-dependent default values.
 */

GLOBAL(void)
jpeg_set_colorspace (j_compress_ptr cinfo, J_COLOR_SPACE colorspace)
{
  jpeg_component_info * compptr;
  int ci;

#define SET_COMP(index,id,hsamp,vsamp,quant,dctbl,actbl)  \
  (compptr = &cinfo->comp_info[index], \
   compptr->component_id = (id), \
   compptr->h_samp_factor = (hsamp), \
   compptr->v_samp_factor = (vsamp), \
   compptr->quant_tbl_no = (quant), \
   compptr->dc_tbl_no = (dctbl), \
   compptr->ac_tbl_no = (actbl) )

  /* Safety check to ensure start_compress not called yet. */
  if (cinfo->global_state != CSTATE_START)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);

  /* For all colorspaces, we use Q and Huff tables 0 for luminance components,
   * tables 1 for chrominance components.
   */

  cinfo->jpeg_color_space = colorspace;

  cinfo->write_JFIF_header = FALSE; /* No marker for non-JFIF colorspaces */
  cinfo->write_Adobe_marker = FALSE; /* write no Adobe marker by default */

  switch (colorspace) {
  case JCS_GRAYSCALE:
    cinfo->write_JFIF_header = TRUE; /* Write a JFIF marker */
    cinfo->num_components = 1;
    /* JFIF specifies component ID 1 */
    SET_COMP(0, 1, 1,1, 0, 0,0);
    break;
  case JCS_RGB:
    cinfo->write_Adobe_marker = TRUE; /* write Adobe marker to flag RGB */
    cinfo->num_components = 3;
    SET_COMP(0, 0x52 /* 'R' */, 1,1, 0, 0,0);
    SET_COMP(1, 0x47 /* 'G' */, 1,1, 0, 0,0);
    SET_COMP(2, 0x42 /* 'B' */, 1,1, 0, 0,0);
    break;
  case JCS_YCbCr:
    cinfo->write_JFIF_header = TRUE; /* Write a JFIF marker */
    cinfo->num_components = 3;
    /* JFIF specifies component IDs 1,2,3 */
    /* We default to 2x2 subsamples of chrominance */
    SET_COMP(0, 1, 2,2, 0, 0,0);
    SET_COMP(1, 2, 1,1, 1, 1,1);
    SET_COMP(2, 3, 1,1, 1, 1,1);
    break;
  case JCS_CMYK:
    cinfo->write_Adobe_marker = TRUE; /* write Adobe marker to flag CMYK */
    cinfo->num_components = 4;
    SET_COMP(0, 0x43 /* 'C' */, 1,1, 0, 0,0);
    SET_COMP(1, 0x4D /* 'M' */, 1,1, 0, 0,0);
    SET_COMP(2, 0x59 /* 'Y' */, 1,1, 0, 0,0);
    SET_COMP(3, 0x4B /* 'K' */, 1,1, 0, 0,0);
    break;
  case JCS_YCCK:
    cinfo->write_Adobe_marker = TRUE; /* write Adobe marker to flag YCCK */
    cinfo->num_components = 4;
    SET_COMP(0, 1, 2,2, 0, 0,0);
    SET_COMP(1, 2, 1,1, 1, 1,1);
    SET_COMP(2, 3, 1,1, 1, 1,1);
    SET_COMP(3, 4, 2,2, 0, 0,0);
    break;
  case JCS_UNKNOWN:
    cinfo->num_components = cinfo->input_components;
    if (cinfo->num_components < 1 || cinfo->num_components > MAX_COMPONENTS)
      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,
	       MAX_COMPONENTS);
    for (ci = 0; ci < cinfo->num_components; ci++) {
      SET_COMP(ci, ci, 1,1, 0, 0,0);
    }
    break;
  default:
    ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
  }
}


#ifdef C_PROGRESSIVE_SUPPORTED

LOCAL(jpeg_scan_info *)
fill_a_scan (jpeg_scan_info * scanptr, int ci,
	     int Ss, int Se, int Ah, int Al)
/* Support routine: generate one scan for specified component */
{
  scanptr->comps_in_scan = 1;
  scanptr->component_index[0] = ci;
  scanptr->Ss = Ss;
  scanptr->Se = Se;
  scanptr->Ah = Ah;
  scanptr->Al = Al;
  scanptr++;
  return scanptr;
}

LOCAL(jpeg_scan_info *)
fill_scans (jpeg_scan_info * scanptr, int ncomps,
	    int Ss, int Se, int Ah, int Al)
/* Support routine: generate one scan for each component */
{
  int ci;

  for (ci = 0; ci < ncomps; ci++) {
    scanptr->comps_in_scan = 1;
    scanptr->component_index[0] = ci;
    scanptr->Ss = Ss;
    scanptr->Se = Se;
    scanptr->Ah = Ah;
    scanptr->Al = Al;
    scanptr++;
  }
  return scanptr;
}

LOCAL(jpeg_scan_info *)
fill_dc_scans (jpeg_scan_info * scanptr, int ncomps, int Ah, int Al)
/* Support routine: generate interleaved DC scan if possible, else N scans */
{
  int ci;

  if (ncomps <= MAX_COMPS_IN_SCAN) {
    /* Single interleaved DC scan */
    scanptr->comps_in_scan = ncomps;
    for (ci = 0; ci < ncomps; ci++)
      scanptr->component_index[ci] = ci;
    scanptr->Ss = scanptr->Se = 0;
    scanptr->Ah = Ah;
    scanptr->Al = Al;
    scanptr++;
  } else {
    /* Noninterleaved DC scan for each component */
    scanptr = fill_scans(scanptr, ncomps, 0, 0, Ah, Al);
  }
  return scanptr;
}


/*
 * Create a recommended progressive-JPEG script.
 * cinfo->num_components and cinfo->jpeg_color_space must be correct.
 */

GLOBAL(void)
jpeg_simple_progression (j_compress_ptr cinfo)
{
  int ncomps = cinfo->num_components;
  int nscans;
  jpeg_scan_info * scanptr;

  /* Safety check to ensure start_compress not called yet. */
  if (cinfo->global_state != CSTATE_START)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);

  /* Figure space needed for script.  Calculation must match code below! */
  if (ncomps == 3 && cinfo->jpeg_color_space == JCS_YCbCr) {
    /* Custom script for YCbCr color images. */
    nscans = 10;
  } else {
    /* All-purpose script for other color spaces. */
    if (ncomps > MAX_COMPS_IN_SCAN)
      nscans = 6 * ncomps;	/* 2 DC + 4 AC scans per component */
    else
      nscans = 2 + 4 * ncomps;	/* 2 DC scans; 4 AC scans per component */
  }

  /* Allocate space for script. */
  /* We use permanent pool just in case application re-uses script. */
  scanptr = (jpeg_scan_info *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
				nscans * SIZEOF(jpeg_scan_info));
  cinfo->scan_info = scanptr;
  cinfo->num_scans = nscans;

  if (ncomps == 3 && cinfo->jpeg_color_space == JCS_YCbCr) {
    /* Custom script for YCbCr color images. */
    /* Initial DC scan */
    scanptr = fill_dc_scans(scanptr, ncomps, 0, 1);
    /* Initial AC scan: get some luma data out in a hurry */
    scanptr = fill_a_scan(scanptr, 0, 1, 5, 0, 2);
    /* Chroma data is too small to be worth expending many scans on */
    scanptr = fill_a_scan(scanptr, 2, 1, 63, 0, 1);
    scanptr = fill_a_scan(scanptr, 1, 1, 63, 0, 1);
    /* Complete spectral selection for luma AC */
    scanptr = fill_a_scan(scanptr, 0, 6, 63, 0, 2);
    /* Refine next bit of luma AC */
    scanptr = fill_a_scan(scanptr, 0, 1, 63, 2, 1);
    /* Finish DC successive approximation */
    scanptr = fill_dc_scans(scanptr, ncomps, 1, 0);
    /* Finish AC successive approximation */
    scanptr = fill_a_scan(scanptr, 2, 1, 63, 1, 0);
    scanptr = fill_a_scan(scanptr, 1, 1, 63, 1, 0);
    /* Luma bottom bit comes last since it's usually largest scan */
    scanptr = fill_a_scan(scanptr, 0, 1, 63, 1, 0);
  } else {
    /* All-purpose script for other color spaces. */
    /* Successive approximation first pass */
    scanptr = fill_dc_scans(scanptr, ncomps, 0, 1);
    scanptr = fill_scans(scanptr, ncomps, 1, 5, 0, 2);
    scanptr = fill_scans(scanptr, ncomps, 6, 63, 0, 2);
    /* Successive approximation second pass */
    scanptr = fill_scans(scanptr, ncomps, 1, 63, 2, 1);
    /* Successive approximation final pass */
    scanptr = fill_dc_scans(scanptr, ncomps, 1, 0);
    scanptr = fill_scans(scanptr, ncomps, 1, 63, 1, 0);
  }
}

#endif /* C_PROGRESSIVE_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\jcphuff.c ===
/*
 * jcphuff.c
 *
 * Copyright (C) 1995-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains Huffman entropy encoding routines for progressive JPEG.
 *
 * We do not support output suspension in this module, since the library
 * currently does not allow multiple-scan files to be written with output
 * suspension.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"
#include "jchuff.h"		/* Declarations shared with jchuff.c */

#ifdef C_PROGRESSIVE_SUPPORTED

/* Expanded entropy encoder object for progressive Huffman encoding. */

typedef struct {
  struct jpeg_entropy_encoder pub; /* public fields */

  /* Mode flag: TRUE for optimization, FALSE for actual data output */
  boolean gather_statistics;

  /* Bit-level coding status.
   * next_output_byte/free_in_buffer are local copies of cinfo->dest fields.
   */
  JOCTET * next_output_byte;	/* => next byte to write in buffer */
  size_t free_in_buffer;	/* # of byte spaces remaining in buffer */
  INT32 put_buffer;		/* current bit-accumulation buffer */
  int put_bits;			/* # of bits now in it */
  j_compress_ptr cinfo;		/* link to cinfo (needed for dump_buffer) */

  /* Coding status for DC components */
  int last_dc_val[MAX_COMPS_IN_SCAN]; /* last DC coef for each component */

  /* Coding status for AC components */
  int ac_tbl_no;		/* the table number of the single component */
  unsigned int EOBRUN;		/* run length of EOBs */
  unsigned int BE;		/* # of buffered correction bits before MCU */
  char * bit_buffer;		/* buffer for correction bits (1 per char) */
  /* packing correction bits tightly would save some space but cost time... */

  unsigned int restarts_to_go;	/* MCUs left in this restart interval */
  int next_restart_num;		/* next restart number to write (0-7) */

  /* Pointers to derived tables (these workspaces have image lifespan).
   * Since any one scan codes only DC or only AC, we only need one set
   * of tables, not one for DC and one for AC.
   */
  c_derived_tbl * derived_tbls[NUM_HUFF_TBLS];

  /* Statistics tables for optimization; again, one set is enough */
  long * count_ptrs[NUM_HUFF_TBLS];
} phuff_entropy_encoder;

typedef phuff_entropy_encoder * phuff_entropy_ptr;

/* MAX_CORR_BITS is the number of bits the AC refinement correction-bit
 * buffer can hold.  Larger sizes may slightly improve compression, but
 * 1000 is already well into the realm of overkill.
 * The minimum safe size is 64 bits.
 */

#define MAX_CORR_BITS  1000	/* Max # of correction bits I can buffer */

/* IRIGHT_SHIFT is like RIGHT_SHIFT, but works on int rather than INT32.
 * We assume that int right shift is unsigned if INT32 right shift is,
 * which should be safe.
 */

#ifdef RIGHT_SHIFT_IS_UNSIGNED
#define ISHIFT_TEMPS	int ishift_temp;
#define IRIGHT_SHIFT(x,shft)  \
	((ishift_temp = (x)) < 0 ? \
	 (ishift_temp >> (shft)) | ((~0) << (16-(shft))) : \
	 (ishift_temp >> (shft)))
#else
#define ISHIFT_TEMPS
#define IRIGHT_SHIFT(x,shft)	((x) >> (shft))
#endif

/* Forward declarations */
METHODDEF(boolean) encode_mcu_DC_first JPP((j_compress_ptr cinfo,
					    JBLOCKROW *MCU_data));
METHODDEF(boolean) encode_mcu_AC_first JPP((j_compress_ptr cinfo,
					    JBLOCKROW *MCU_data));
METHODDEF(boolean) encode_mcu_DC_refine JPP((j_compress_ptr cinfo,
					     JBLOCKROW *MCU_data));
METHODDEF(boolean) encode_mcu_AC_refine JPP((j_compress_ptr cinfo,
					     JBLOCKROW *MCU_data));
METHODDEF(void) finish_pass_phuff JPP((j_compress_ptr cinfo));
METHODDEF(void) finish_pass_gather_phuff JPP((j_compress_ptr cinfo));


/*
 * Initialize for a Huffman-compressed scan using progressive JPEG.
 */

METHODDEF(void)
start_pass_phuff (j_compress_ptr cinfo, boolean gather_statistics)
{  
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
  boolean is_DC_band;
  int ci, tbl;
  jpeg_component_info * compptr;

  entropy->cinfo = cinfo;
  entropy->gather_statistics = gather_statistics;

  is_DC_band = (cinfo->Ss == 0);

  /* We assume jcmaster.c already validated the scan parameters. */

  /* Select execution routines */
  if (cinfo->Ah == 0) {
    if (is_DC_band)
      entropy->pub.encode_mcu = encode_mcu_DC_first;
    else
      entropy->pub.encode_mcu = encode_mcu_AC_first;
  } else {
    if (is_DC_band)
      entropy->pub.encode_mcu = encode_mcu_DC_refine;
    else {
      entropy->pub.encode_mcu = encode_mcu_AC_refine;
      /* AC refinement needs a correction bit buffer */
      if (entropy->bit_buffer == NULL)
	entropy->bit_buffer = (char *)
	  (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				      MAX_CORR_BITS * SIZEOF(char));
    }
  }
  if (gather_statistics)
    entropy->pub.finish_pass = finish_pass_gather_phuff;
  else
    entropy->pub.finish_pass = finish_pass_phuff;

  /* Only DC coefficients may be interleaved, so cinfo->comps_in_scan = 1
   * for AC coefficients.
   */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    compptr = cinfo->cur_comp_info[ci];
    /* Initialize DC predictions to 0 */
    entropy->last_dc_val[ci] = 0;
    /* Make sure requested tables are present */
    /* (In gather mode, tables need not be allocated yet) */
    if (is_DC_band) {
      if (cinfo->Ah != 0)	/* DC refinement needs no table */
	continue;
      tbl = compptr->dc_tbl_no;
      if (tbl < 0 || tbl >= NUM_HUFF_TBLS ||
	  (cinfo->dc_huff_tbl_ptrs[tbl] == NULL && !gather_statistics))
	ERREXIT1(cinfo,JERR_NO_HUFF_TABLE, tbl);
    } else {
      entropy->ac_tbl_no = tbl = compptr->ac_tbl_no;
      if (tbl < 0 || tbl >= NUM_HUFF_TBLS ||
          (cinfo->ac_huff_tbl_ptrs[tbl] == NULL && !gather_statistics))
        ERREXIT1(cinfo,JERR_NO_HUFF_TABLE, tbl);
    }
    if (gather_statistics) {
      /* Allocate and zero the statistics tables */
      /* Note that jpeg_gen_optimal_table expects 257 entries in each table! */
      if (entropy->count_ptrs[tbl] == NULL)
	entropy->count_ptrs[tbl] = (long *)
	  (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				      257 * SIZEOF(long));
      MEMZERO(entropy->count_ptrs[tbl], 257 * SIZEOF(long));
    } else {
      /* Compute derived values for Huffman tables */
      /* We may do this more than once for a table, but it's not expensive */
      if (is_DC_band)
        jpeg_make_c_derived_tbl(cinfo, cinfo->dc_huff_tbl_ptrs[tbl],
				& entropy->derived_tbls[tbl]);
      else
        jpeg_make_c_derived_tbl(cinfo, cinfo->ac_huff_tbl_ptrs[tbl],
				& entropy->derived_tbls[tbl]);
    }
  }

  /* Initialize AC stuff */
  entropy->EOBRUN = 0;
  entropy->BE = 0;

  /* Initialize bit buffer to empty */
  entropy->put_buffer = 0;
  entropy->put_bits = 0;

  /* Initialize restart stuff */
  entropy->restarts_to_go = cinfo->restart_interval;
  entropy->next_restart_num = 0;
}


/* Outputting bytes to the file.
 * NB: these must be called only when actually outputting,
 * that is, entropy->gather_statistics == FALSE.
 */

/* Emit a byte */
#define emit_byte(entropy,val)  \
	{ *(entropy)->next_output_byte++ = (JOCTET) (val);  \
	  if (--(entropy)->free_in_buffer == 0)  \
	    dump_buffer(entropy); }


LOCAL(void)
dump_buffer (phuff_entropy_ptr entropy)
/* Empty the output buffer; we do not support suspension in this module. */
{
  struct jpeg_destination_mgr * dest = entropy->cinfo->dest;

  if (! (*dest->empty_output_buffer) (entropy->cinfo))
    ERREXIT(entropy->cinfo, JERR_CANT_SUSPEND);
  /* After a successful buffer dump, must reset buffer pointers */
  entropy->next_output_byte = dest->next_output_byte;
  entropy->free_in_buffer = dest->free_in_buffer;
}


/* Outputting bits to the file */

/* Only the right 24 bits of put_buffer are used; the valid bits are
 * left-justified in this part.  At most 16 bits can be passed to emit_bits
 * in one call, and we never retain more than 7 bits in put_buffer
 * between calls, so 24 bits are sufficient.
 */

INLINE
LOCAL(void)
emit_bits (phuff_entropy_ptr entropy, unsigned int code, int size)
/* Emit some bits, unless we are in gather mode */
{
  /* This routine is heavily used, so it's worth coding tightly. */
  register INT32 put_buffer = (INT32) code;
  register int put_bits = entropy->put_bits;

  /* if size is 0, caller used an invalid Huffman table entry */
  if (size == 0)
    ERREXIT(entropy->cinfo, JERR_HUFF_MISSING_CODE);

  if (entropy->gather_statistics)
    return;			/* do nothing if we're only getting stats */

  put_buffer &= (((INT32) 1)<<size) - 1; /* mask off any extra bits in code */
  
  put_bits += size;		/* new number of bits in buffer */
  
  put_buffer <<= 24 - put_bits; /* align incoming bits */

  put_buffer |= entropy->put_buffer; /* and merge with old buffer contents */

  while (put_bits >= 8) {
    int c = (int) ((put_buffer >> 16) & 0xFF);
    
    emit_byte(entropy, c);
    if (c == 0xFF) {		/* need to stuff a zero byte? */
      emit_byte(entropy, 0);
    }
    put_buffer <<= 8;
    put_bits -= 8;
  }

  entropy->put_buffer = put_buffer; /* update variables */
  entropy->put_bits = put_bits;
}


LOCAL(void)
flush_bits (phuff_entropy_ptr entropy)
{
  emit_bits(entropy, 0x7F, 7); /* fill any partial byte with ones */
  entropy->put_buffer = 0;     /* and reset bit-buffer to empty */
  entropy->put_bits = 0;
}


/*
 * Emit (or just count) a Huffman symbol.
 */

INLINE
LOCAL(void)
emit_symbol (phuff_entropy_ptr entropy, int tbl_no, int symbol)
{
  if (entropy->gather_statistics)
    entropy->count_ptrs[tbl_no][symbol]++;
  else {
    c_derived_tbl * tbl = entropy->derived_tbls[tbl_no];
    emit_bits(entropy, tbl->ehufco[symbol], tbl->ehufsi[symbol]);
  }
}


/*
 * Emit bits from a correction bit buffer.
 */

LOCAL(void)
emit_buffered_bits (phuff_entropy_ptr entropy, char * bufstart,
		    unsigned int nbits)
{
  if (entropy->gather_statistics)
    return;			/* no real work */

  while (nbits > 0) {
    emit_bits(entropy, (unsigned int) (*bufstart), 1);
    bufstart++;
    nbits--;
  }
}


/*
 * Emit any pending EOBRUN symbol.
 */

LOCAL(void)
emit_eobrun (phuff_entropy_ptr entropy)
{
  register int temp, nbits;

  if (entropy->EOBRUN > 0) {	/* if there is any pending EOBRUN */
    temp = entropy->EOBRUN;
    nbits = 0;
    while ((temp >>= 1))
      nbits++;

    emit_symbol(entropy, entropy->ac_tbl_no, nbits << 4);
    if (nbits)
      emit_bits(entropy, entropy->EOBRUN, nbits);

    entropy->EOBRUN = 0;

    /* Emit any buffered correction bits */
    emit_buffered_bits(entropy, entropy->bit_buffer, entropy->BE);
    entropy->BE = 0;
  }
}


/*
 * Emit a restart marker & resynchronize predictions.
 */

LOCAL(void)
emit_restart (phuff_entropy_ptr entropy, int restart_num)
{
  int ci;

  emit_eobrun(entropy);

  if (! entropy->gather_statistics) {
    flush_bits(entropy);
    emit_byte(entropy, 0xFF);
    emit_byte(entropy, JPEG_RST0 + restart_num);
  }

  if (entropy->cinfo->Ss == 0) {
    /* Re-initialize DC predictions to 0 */
    for (ci = 0; ci < entropy->cinfo->comps_in_scan; ci++)
      entropy->last_dc_val[ci] = 0;
  } else {
    /* Re-initialize all AC-related fields to 0 */
    entropy->EOBRUN = 0;
    entropy->BE = 0;
  }
}


/*
 * MCU encoding for DC initial scan (either spectral selection,
 * or first pass of successive approximation).
 */

METHODDEF(boolean)
encode_mcu_DC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
{
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
  register int temp, temp2;
  register int nbits;
  int blkn, ci;
  int Al = cinfo->Al;
  JBLOCKROW block;
  jpeg_component_info * compptr;
  ISHIFT_TEMPS

  entropy->next_output_byte = cinfo->dest->next_output_byte;
  entropy->free_in_buffer = cinfo->dest->free_in_buffer;

  /* Emit restart marker if needed */
  if (cinfo->restart_interval)
    if (entropy->restarts_to_go == 0)
      emit_restart(entropy, entropy->next_restart_num);

  /* Encode the MCU data blocks */
  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
    block = MCU_data[blkn];
    ci = cinfo->MCU_membership[blkn];
    compptr = cinfo->cur_comp_info[ci];

    /* Compute the DC value after the required point transform by Al.
     * This is simply an arithmetic right shift.
     */
    temp2 = IRIGHT_SHIFT((int) ((*block)[0]), Al);

    /* DC differences are figured on the point-transformed values. */
    temp = temp2 - entropy->last_dc_val[ci];
    entropy->last_dc_val[ci] = temp2;

    /* Encode the DC coefficient difference per section G.1.2.1 */
    temp2 = temp;
    if (temp < 0) {
      temp = -temp;		/* temp is abs value of input */
      /* For a negative input, want temp2 = bitwise complement of abs(input) */
      /* This code assumes we are on a two's complement machine */
      temp2--;
    }
    
    /* Find the number of bits needed for the magnitude of the coefficient */
    nbits = 0;
    while (temp) {
      nbits++;
      temp >>= 1;
    }
    
    /* Count/emit the Huffman-coded symbol for the number of bits */
    emit_symbol(entropy, compptr->dc_tbl_no, nbits);
    
    /* Emit that number of bits of the value, if positive, */
    /* or the complement of its magnitude, if negative. */
    if (nbits)			/* emit_bits rejects calls with size 0 */
      emit_bits(entropy, (unsigned int) temp2, nbits);
  }

  cinfo->dest->next_output_byte = entropy->next_output_byte;
  cinfo->dest->free_in_buffer = entropy->free_in_buffer;

  /* Update restart-interval state too */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0) {
      entropy->restarts_to_go = cinfo->restart_interval;
      entropy->next_restart_num++;
      entropy->next_restart_num &= 7;
    }
    entropy->restarts_to_go--;
  }

  return TRUE;
}


/*
 * MCU encoding for AC initial scan (either spectral selection,
 * or first pass of successive approximation).
 */

METHODDEF(boolean)
encode_mcu_AC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
{
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
  register int temp, temp2;
  register int nbits;
  register int r, k;
  int Se = cinfo->Se;
  int Al = cinfo->Al;
  JBLOCKROW block;

  entropy->next_output_byte = cinfo->dest->next_output_byte;
  entropy->free_in_buffer = cinfo->dest->free_in_buffer;

  /* Emit restart marker if needed */
  if (cinfo->restart_interval)
    if (entropy->restarts_to_go == 0)
      emit_restart(entropy, entropy->next_restart_num);

  /* Encode the MCU data block */
  block = MCU_data[0];

  /* Encode the AC coefficients per section G.1.2.2, fig. G.3 */
  
  r = 0;			/* r = run length of zeros */
   
  for (k = cinfo->Ss; k <= Se; k++) {
    if ((temp = (*block)[jpeg_natural_order[k]]) == 0) {
      r++;
      continue;
    }
    /* We must apply the point transform by Al.  For AC coefficients this
     * is an integer division with rounding towards 0.  To do this portably
     * in C, we shift after obtaining the absolute value; so the code is
     * interwoven with finding the abs value (temp) and output bits (temp2).
     */
    if (temp < 0) {
      temp = -temp;		/* temp is abs value of input */
      temp >>= Al;		/* apply the point transform */
      /* For a negative coef, want temp2 = bitwise complement of abs(coef) */
      temp2 = ~temp;
    } else {
      temp >>= Al;		/* apply the point transform */
      temp2 = temp;
    }
    /* Watch out for case that nonzero coef is zero after point transform */
    if (temp == 0) {
      r++;
      continue;
    }

    /* Emit any pending EOBRUN */
    if (entropy->EOBRUN > 0)
      emit_eobrun(entropy);
    /* if run length > 15, must emit special run-length-16 codes (0xF0) */
    while (r > 15) {
      emit_symbol(entropy, entropy->ac_tbl_no, 0xF0);
      r -= 16;
    }

    /* Find the number of bits needed for the magnitude of the coefficient */
    nbits = 1;			/* there must be at least one 1 bit */
    while ((temp >>= 1))
      nbits++;

    /* Count/emit Huffman symbol for run length / number of bits */
    emit_symbol(entropy, entropy->ac_tbl_no, (r << 4) + nbits);

    /* Emit that number of bits of the value, if positive, */
    /* or the complement of its magnitude, if negative. */
    emit_bits(entropy, (unsigned int) temp2, nbits);

    r = 0;			/* reset zero run length */
  }

  if (r > 0) {			/* If there are trailing zeroes, */
    entropy->EOBRUN++;		/* count an EOB */
    if (entropy->EOBRUN == 0x7FFF)
      emit_eobrun(entropy);	/* force it out to avoid overflow */
  }

  cinfo->dest->next_output_byte = entropy->next_output_byte;
  cinfo->dest->free_in_buffer = entropy->free_in_buffer;

  /* Update restart-interval state too */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0) {
      entropy->restarts_to_go = cinfo->restart_interval;
      entropy->next_restart_num++;
      entropy->next_restart_num &= 7;
    }
    entropy->restarts_to_go--;
  }

  return TRUE;
}


/*
 * MCU encoding for DC successive approximation refinement scan.
 * Note: we assume such scans can be multi-component, although the spec
 * is not very clear on the point.
 */

METHODDEF(boolean)
encode_mcu_DC_refine (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
{
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
  register int temp;
  int blkn;
  int Al = cinfo->Al;
  JBLOCKROW block;

  entropy->next_output_byte = cinfo->dest->next_output_byte;
  entropy->free_in_buffer = cinfo->dest->free_in_buffer;

  /* Emit restart marker if needed */
  if (cinfo->restart_interval)
    if (entropy->restarts_to_go == 0)
      emit_restart(entropy, entropy->next_restart_num);

  /* Encode the MCU data blocks */
  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
    block = MCU_data[blkn];

    /* We simply emit the Al'th bit of the DC coefficient value. */
    temp = (*block)[0];
    emit_bits(entropy, (unsigned int) (temp >> Al), 1);
  }

  cinfo->dest->next_output_byte = entropy->next_output_byte;
  cinfo->dest->free_in_buffer = entropy->free_in_buffer;

  /* Update restart-interval state too */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0) {
      entropy->restarts_to_go = cinfo->restart_interval;
      entropy->next_restart_num++;
      entropy->next_restart_num &= 7;
    }
    entropy->restarts_to_go--;
  }

  return TRUE;
}


/*
 * MCU encoding for AC successive approximation refinement scan.
 */

METHODDEF(boolean)
encode_mcu_AC_refine (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
{
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
  register int temp;
  register int r, k;
  int EOB;
  char *BR_buffer;
  unsigned int BR;
  int Se = cinfo->Se;
  int Al = cinfo->Al;
  JBLOCKROW block;
  int absvalues[DCTSIZE2];

  entropy->next_output_byte = cinfo->dest->next_output_byte;
  entropy->free_in_buffer = cinfo->dest->free_in_buffer;

  /* Emit restart marker if needed */
  if (cinfo->restart_interval)
    if (entropy->restarts_to_go == 0)
      emit_restart(entropy, entropy->next_restart_num);

  /* Encode the MCU data block */
  block = MCU_data[0];

  /* It is convenient to make a pre-pass to determine the transformed
   * coefficients' absolute values and the EOB position.
   */
  EOB = 0;
  for (k = cinfo->Ss; k <= Se; k++) {
    temp = (*block)[jpeg_natural_order[k]];
    /* We must apply the point transform by Al.  For AC coefficients this
     * is an integer division with rounding towards 0.  To do this portably
     * in C, we shift after obtaining the absolute value.
     */
    if (temp < 0)
      temp = -temp;		/* temp is abs value of input */
    temp >>= Al;		/* apply the point transform */
    absvalues[k] = temp;	/* save abs value for main pass */
    if (temp == 1)
      EOB = k;			/* EOB = index of last newly-nonzero coef */
  }

  /* Encode the AC coefficients per section G.1.2.3, fig. G.7 */
  
  r = 0;			/* r = run length of zeros */
  BR = 0;			/* BR = count of buffered bits added now */
  BR_buffer = entropy->bit_buffer + entropy->BE; /* Append bits to buffer */

  for (k = cinfo->Ss; k <= Se; k++) {
    if ((temp = absvalues[k]) == 0) {
      r++;
      continue;
    }

    /* Emit any required ZRLs, but not if they can be folded into EOB */
    while (r > 15 && k <= EOB) {
      /* emit any pending EOBRUN and the BE correction bits */
      emit_eobrun(entropy);
      /* Emit ZRL */
      emit_symbol(entropy, entropy->ac_tbl_no, 0xF0);
      r -= 16;
      /* Emit buffered correction bits that must be associated with ZRL */
      emit_buffered_bits(entropy, BR_buffer, BR);
      BR_buffer = entropy->bit_buffer; /* BE bits are gone now */
      BR = 0;
    }

    /* If the coef was previously nonzero, it only needs a correction bit.
     * NOTE: a straight translation of the spec's figure G.7 would suggest
     * that we also need to test r > 15.  But if r > 15, we can only get here
     * if k > EOB, which implies that this coefficient is not 1.
     */
    if (temp > 1) {
      /* The correction bit is the next bit of the absolute value. */
      BR_buffer[BR++] = (char) (temp & 1);
      continue;
    }

    /* Emit any pending EOBRUN and the BE correction bits */
    emit_eobrun(entropy);

    /* Count/emit Huffman symbol for run length / number of bits */
    emit_symbol(entropy, entropy->ac_tbl_no, (r << 4) + 1);

    /* Emit output bit for newly-nonzero coef */
    temp = ((*block)[jpeg_natural_order[k]] < 0) ? 0 : 1;
    emit_bits(entropy, (unsigned int) temp, 1);

    /* Emit buffered correction bits that must be associated with this code */
    emit_buffered_bits(entropy, BR_buffer, BR);
    BR_buffer = entropy->bit_buffer; /* BE bits are gone now */
    BR = 0;
    r = 0;			/* reset zero run length */
  }

  if (r > 0 || BR > 0) {	/* If there are trailing zeroes, */
    entropy->EOBRUN++;		/* count an EOB */
    entropy->BE += BR;		/* concat my correction bits to older ones */
    /* We force out the EOB if we risk either:
     * 1. overflow of the EOB counter;
     * 2. overflow of the correction bit buffer during the next MCU.
     */
    if (entropy->EOBRUN == 0x7FFF || entropy->BE > (MAX_CORR_BITS-DCTSIZE2+1))
      emit_eobrun(entropy);
  }

  cinfo->dest->next_output_byte = entropy->next_output_byte;
  cinfo->dest->free_in_buffer = entropy->free_in_buffer;

  /* Update restart-interval state too */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0) {
      entropy->restarts_to_go = cinfo->restart_interval;
      entropy->next_restart_num++;
      entropy->next_restart_num &= 7;
    }
    entropy->restarts_to_go--;
  }

  return TRUE;
}


/*
 * Finish up at the end of a Huffman-compressed progressive scan.
 */

METHODDEF(void)
finish_pass_phuff (j_compress_ptr cinfo)
{   
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;

  entropy->next_output_byte = cinfo->dest->next_output_byte;
  entropy->free_in_buffer = cinfo->dest->free_in_buffer;

  /* Flush out any buffered data */
  emit_eobrun(entropy);
  flush_bits(entropy);

  cinfo->dest->next_output_byte = entropy->next_output_byte;
  cinfo->dest->free_in_buffer = entropy->free_in_buffer;
}


/*
 * Finish up a statistics-gathering pass and create the new Huffman tables.
 */

METHODDEF(void)
finish_pass_gather_phuff (j_compress_ptr cinfo)
{
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
  boolean is_DC_band;
  int ci, tbl;
  jpeg_component_info * compptr;
  JHUFF_TBL **htblptr;
  boolean did[NUM_HUFF_TBLS];

  /* Flush out buffered data (all we care about is counting the EOB symbol) */
  emit_eobrun(entropy);

  is_DC_band = (cinfo->Ss == 0);

  /* It's important not to apply jpeg_gen_optimal_table more than once
   * per table, because it clobbers the input frequency counts!
   */
  MEMZERO(did, SIZEOF(did));

  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    compptr = cinfo->cur_comp_info[ci];
    if (is_DC_band) {
      if (cinfo->Ah != 0)	/* DC refinement needs no table */
	continue;
      tbl = compptr->dc_tbl_no;
    } else {
      tbl = compptr->ac_tbl_no;
    }
    if (! did[tbl]) {
      if (is_DC_band)
        htblptr = & cinfo->dc_huff_tbl_ptrs[tbl];
      else
        htblptr = & cinfo->ac_huff_tbl_ptrs[tbl];
      if (*htblptr == NULL)
        *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
      jpeg_gen_optimal_table(cinfo, *htblptr, entropy->count_ptrs[tbl]);
      did[tbl] = TRUE;
    }
  }
}


/*
 * Module initialization routine for progressive Huffman entropy encoding.
 */

GLOBAL(void)
jinit_phuff_encoder (j_compress_ptr cinfo)
{
  phuff_entropy_ptr entropy;
  int i;

  entropy = (phuff_entropy_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(phuff_entropy_encoder));
  cinfo->entropy = (struct jpeg_entropy_encoder *) entropy;
  entropy->pub.start_pass = start_pass_phuff;

  /* Mark tables unallocated */
  for (i = 0; i < NUM_HUFF_TBLS; i++) {
    entropy->derived_tbls[i] = NULL;
    entropy->count_ptrs[i] = NULL;
  }
  entropy->bit_buffer = NULL;	/* needed only in AC refinement scan */
}

#endif /* C_PROGRESSIVE_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\jcsample.c ===
/*
 * jcsample.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains downsampling routines.
 *
 * Downsampling input data is counted in "row groups".  A row group
 * is defined to be max_v_samp_factor pixel rows of each component,
 * from which the downsampler produces v_samp_factor sample rows.
 * A single row group is processed in each call to the downsampler module.
 *
 * The downsampler is responsible for edge-expansion of its output data
 * to fill an integral number of DCT blocks horizontally.  The source buffer
 * may be modified if it is helpful for this purpose (the source buffer is
 * allocated wide enough to correspond to the desired output width).
 * The caller (the prep controller) is responsible for vertical padding.
 *
 * The downsampler may request "context rows" by setting need_context_rows
 * during startup.  In this case, the input arrays will contain at least
 * one row group's worth of pixels above and below the passed-in data;
 * the caller will create dummy rows at image top and bottom by replicating
 * the first or last real pixel row.
 *
 * An excellent reference for image resampling is
 *   Digital Image Warping, George Wolberg, 1990.
 *   Pub. by IEEE Computer Society Press, Los Alamitos, CA. ISBN 0-8186-8944-7.
 *
 * The downsampling algorithm used here is a simple average of the source
 * pixels covered by the output pixel.  The hi-falutin sampling literature
 * refers to this as a "box filter".  In general the characteristics of a box
 * filter are not very good, but for the specific cases we normally use (1:1
 * and 2:1 ratios) the box is equivalent to a "triangle filter" which is not
 * nearly so bad.  If you intend to use other sampling ratios, you'd be well
 * advised to improve this code.
 *
 * A simple input-smoothing capability is provided.  This is mainly intended
 * for cleaning up color-dithered GIF input files (if you find it inadequate,
 * we suggest using an external filtering program such as pnmconvol).  When
 * enabled, each input pixel P is replaced by a weighted sum of itself and its
 * eight neighbors.  P's weight is 1-8*SF and each neighbor's weight is SF,
 * where SF = (smoothing_factor / 1024).
 * Currently, smoothing is only supported for 2h2v sampling factors.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/* Pointer to routine to downsample a single component */
typedef JMETHOD(void, downsample1_ptr,
		(j_compress_ptr cinfo, jpeg_component_info * compptr,
		 JSAMPARRAY input_data, JSAMPARRAY output_data));

/* Private subobject */

typedef struct {
  struct jpeg_downsampler pub;	/* public fields */

  /* Downsampling method pointers, one per component */
  downsample1_ptr methods[MAX_COMPONENTS];
} my_downsampler;

typedef my_downsampler * my_downsample_ptr;


/*
 * Initialize for a downsampling pass.
 */

METHODDEF(void)
start_pass_downsample (j_compress_ptr cinfo)
{
  /* no work for now */
}


/*
 * Expand a component horizontally from width input_cols to width output_cols,
 * by duplicating the rightmost samples.
 */

LOCAL(void)
expand_right_edge (JSAMPARRAY image_data, int num_rows,
		   JDIMENSION input_cols, JDIMENSION output_cols)
{
  register JSAMPROW ptr;
  register JSAMPLE pixval;
  register int count;
  int row;
  int numcols = (int) (output_cols - input_cols);

  if (numcols > 0) {
    for (row = 0; row < num_rows; row++) {
      ptr = image_data[row] + input_cols;
      pixval = ptr[-1];		/* don't need GETJSAMPLE() here */
      for (count = numcols; count > 0; count--)
	*ptr++ = pixval;
    }
  }
}


/*
 * Do downsampling for a whole row group (all components).
 *
 * In this version we simply downsample each component independently.
 */

METHODDEF(void)
sep_downsample (j_compress_ptr cinfo,
		JSAMPIMAGE input_buf, JDIMENSION in_row_index,
		JSAMPIMAGE output_buf, JDIMENSION out_row_group_index)
{
  my_downsample_ptr downsample = (my_downsample_ptr) cinfo->downsample;
  int ci;
  jpeg_component_info * compptr;
  JSAMPARRAY in_ptr, out_ptr;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    in_ptr = input_buf[ci] + in_row_index;
    out_ptr = output_buf[ci] + (out_row_group_index * compptr->v_samp_factor);
    (*downsample->methods[ci]) (cinfo, compptr, in_ptr, out_ptr);
  }
}


/*
 * Downsample pixel values of a single component.
 * One row group is processed per call.
 * This version handles arbitrary integral sampling ratios, without smoothing.
 * Note that this version is not actually used for customary sampling ratios.
 */

METHODDEF(void)
int_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
		JSAMPARRAY input_data, JSAMPARRAY output_data)
{
  int inrow, outrow, h_expand, v_expand, numpix, numpix2, h, v;
  JDIMENSION outcol, outcol_h;	/* outcol_h == outcol*h_expand */
  JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
  JSAMPROW inptr, outptr;
  INT32 outvalue;

  h_expand = cinfo->max_h_samp_factor / compptr->h_samp_factor;
  v_expand = cinfo->max_v_samp_factor / compptr->v_samp_factor;
  numpix = h_expand * v_expand;
  numpix2 = numpix/2;

  /* Expand input data enough to let all the output samples be generated
   * by the standard loop.  Special-casing padded output would be more
   * efficient.
   */
  expand_right_edge(input_data, cinfo->max_v_samp_factor,
		    cinfo->image_width, output_cols * h_expand);

  inrow = 0;
  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {
    outptr = output_data[outrow];
    for (outcol = 0, outcol_h = 0; outcol < output_cols;
	 outcol++, outcol_h += h_expand) {
      outvalue = 0;
      for (v = 0; v < v_expand; v++) {
	inptr = input_data[inrow+v] + outcol_h;
	for (h = 0; h < h_expand; h++) {
	  outvalue += (INT32) GETJSAMPLE(*inptr++);
	}
      }
      *outptr++ = (JSAMPLE) ((outvalue + numpix2) / numpix);
    }
    inrow += v_expand;
  }
}


/*
 * Downsample pixel values of a single component.
 * This version handles the special case of a full-size component,
 * without smoothing.
 */

METHODDEF(void)
fullsize_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
		     JSAMPARRAY input_data, JSAMPARRAY output_data)
{
  /* Copy the data */
  jcopy_sample_rows(input_data, 0, output_data, 0,
		    cinfo->max_v_samp_factor, cinfo->image_width);
  /* Edge-expand */
  expand_right_edge(output_data, cinfo->max_v_samp_factor,
		    cinfo->image_width, compptr->width_in_blocks * DCTSIZE);
}


/*
 * Downsample pixel values of a single component.
 * This version handles the common case of 2:1 horizontal and 1:1 vertical,
 * without smoothing.
 *
 * A note about the "bias" calculations: when rounding fractional values to
 * integer, we do not want to always round 0.5 up to the next integer.
 * If we did that, we'd introduce a noticeable bias towards larger values.
 * Instead, this code is arranged so that 0.5 will be rounded up or down at
 * alternate pixel locations (a simple ordered dither pattern).
 */

METHODDEF(void)
h2v1_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
		 JSAMPARRAY input_data, JSAMPARRAY output_data)
{
  int outrow;
  JDIMENSION outcol;
  JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
  register JSAMPROW inptr, outptr;
  register int bias;

  /* Expand input data enough to let all the output samples be generated
   * by the standard loop.  Special-casing padded output would be more
   * efficient.
   */
  expand_right_edge(input_data, cinfo->max_v_samp_factor,
		    cinfo->image_width, output_cols * 2);

  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {
    outptr = output_data[outrow];
    inptr = input_data[outrow];
    bias = 0;			/* bias = 0,1,0,1,... for successive samples */
    for (outcol = 0; outcol < output_cols; outcol++) {
      *outptr++ = (JSAMPLE) ((GETJSAMPLE(*inptr) + GETJSAMPLE(inptr[1])
			      + bias) >> 1);
      bias ^= 1;		/* 0=>1, 1=>0 */
      inptr += 2;
    }
  }
}


/*
 * Downsample pixel values of a single component.
 * This version handles the standard case of 2:1 horizontal and 2:1 vertical,
 * without smoothing.
 */

METHODDEF(void)
h2v2_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
		 JSAMPARRAY input_data, JSAMPARRAY output_data)
{
  int inrow, outrow;
  JDIMENSION outcol;
  JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
  register JSAMPROW inptr0, inptr1, outptr;
  register int bias;

  /* Expand input data enough to let all the output samples be generated
   * by the standard loop.  Special-casing padded output would be more
   * efficient.
   */
  expand_right_edge(input_data, cinfo->max_v_samp_factor,
		    cinfo->image_width, output_cols * 2);

  inrow = 0;
  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {
    outptr = output_data[outrow];
    inptr0 = input_data[inrow];
    inptr1 = input_data[inrow+1];
    bias = 1;			/* bias = 1,2,1,2,... for successive samples */
    for (outcol = 0; outcol < output_cols; outcol++) {
      *outptr++ = (JSAMPLE) ((GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[1]) +
			      GETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[1])
			      + bias) >> 2);
      bias ^= 3;		/* 1=>2, 2=>1 */
      inptr0 += 2; inptr1 += 2;
    }
    inrow += 2;
  }
}


#ifdef INPUT_SMOOTHING_SUPPORTED

/*
 * Downsample pixel values of a single component.
 * This version handles the standard case of 2:1 horizontal and 2:1 vertical,
 * with smoothing.  One row of context is required.
 */

METHODDEF(void)
h2v2_smooth_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
			JSAMPARRAY input_data, JSAMPARRAY output_data)
{
  int inrow, outrow;
  JDIMENSION colctr;
  JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
  register JSAMPROW inptr0, inptr1, above_ptr, below_ptr, outptr;
  INT32 membersum, neighsum, memberscale, neighscale;

  /* Expand input data enough to let all the output samples be generated
   * by the standard loop.  Special-casing padded output would be more
   * efficient.
   */
  expand_right_edge(input_data - 1, cinfo->max_v_samp_factor + 2,
		    cinfo->image_width, output_cols * 2);

  /* We don't bother to form the individual "smoothed" input pixel values;
   * we can directly compute the output which is the average of the four
   * smoothed values.  Each of the four member pixels contributes a fraction
   * (1-8*SF) to its own smoothed image and a fraction SF to each of the three
   * other smoothed pixels, therefore a total fraction (1-5*SF)/4 to the final
   * output.  The four corner-adjacent neighbor pixels contribute a fraction
   * SF to just one smoothed pixel, or SF/4 to the final output; while the
   * eight edge-adjacent neighbors contribute SF to each of two smoothed
   * pixels, or SF/2 overall.  In order to use integer arithmetic, these
   * factors are scaled by 2^16 = 65536.
   * Also recall that SF = smoothing_factor / 1024.
   */

  memberscale = 16384 - cinfo->smoothing_factor * 80; /* scaled (1-5*SF)/4 */
  neighscale = cinfo->smoothing_factor * 16; /* scaled SF/4 */

  inrow = 0;
  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {
    outptr = output_data[outrow];
    inptr0 = input_data[inrow];
    inptr1 = input_data[inrow+1];
    above_ptr = input_data[inrow-1];
    below_ptr = input_data[inrow+2];

    /* Special case for first column: pretend column -1 is same as column 0 */
    membersum = GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[1]) +
		GETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[1]);
    neighsum = GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[1]) +
	       GETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[1]) +
	       GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[2]) +
	       GETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[2]);
    neighsum += neighsum;
    neighsum += GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[2]) +
		GETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[2]);
    membersum = membersum * memberscale + neighsum * neighscale;
    *outptr++ = (JSAMPLE) ((membersum + 32768) >> 16);
    inptr0 += 2; inptr1 += 2; above_ptr += 2; below_ptr += 2;

    for (colctr = output_cols - 2; colctr > 0; colctr--) {
      /* sum of pixels directly mapped to this output element */
      membersum = GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[1]) +
		  GETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[1]);
      /* sum of edge-neighbor pixels */
      neighsum = GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[1]) +
		 GETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[1]) +
		 GETJSAMPLE(inptr0[-1]) + GETJSAMPLE(inptr0[2]) +
		 GETJSAMPLE(inptr1[-1]) + GETJSAMPLE(inptr1[2]);
      /* The edge-neighbors count twice as much as corner-neighbors */
      neighsum += neighsum;
      /* Add in the corner-neighbors */
      neighsum += GETJSAMPLE(above_ptr[-1]) + GETJSAMPLE(above_ptr[2]) +
		  GETJSAMPLE(below_ptr[-1]) + GETJSAMPLE(below_ptr[2]);
      /* form final output scaled up by 2^16 */
      membersum = membersum * memberscale + neighsum * neighscale;
      /* round, descale and output it */
      *outptr++ = (JSAMPLE) ((membersum + 32768) >> 16);
      inptr0 += 2; inptr1 += 2; above_ptr += 2; below_ptr += 2;
    }

    /* Special case for last column */
    membersum = GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[1]) +
		GETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[1]);
    neighsum = GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[1]) +
	       GETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[1]) +
	       GETJSAMPLE(inptr0[-1]) + GETJSAMPLE(inptr0[1]) +
	       GETJSAMPLE(inptr1[-1]) + GETJSAMPLE(inptr1[1]);
    neighsum += neighsum;
    neighsum += GETJSAMPLE(above_ptr[-1]) + GETJSAMPLE(above_ptr[1]) +
		GETJSAMPLE(below_ptr[-1]) + GETJSAMPLE(below_ptr[1]);
    membersum = membersum * memberscale + neighsum * neighscale;
    *outptr = (JSAMPLE) ((membersum + 32768) >> 16);

    inrow += 2;
  }
}


/*
 * Downsample pixel values of a single component.
 * This version handles the special case of a full-size component,
 * with smoothing.  One row of context is required.
 */

METHODDEF(void)
fullsize_smooth_downsample (j_compress_ptr cinfo, jpeg_component_info *compptr,
			    JSAMPARRAY input_data, JSAMPARRAY output_data)
{
  int outrow;
  JDIMENSION colctr;
  JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
  register JSAMPROW inptr, above_ptr, below_ptr, outptr;
  INT32 membersum, neighsum, memberscale, neighscale;
  int colsum, lastcolsum, nextcolsum;

  /* Expand input data enough to let all the output samples be generated
   * by the standard loop.  Special-casing padded output would be more
   * efficient.
   */
  expand_right_edge(input_data - 1, cinfo->max_v_samp_factor + 2,
		    cinfo->image_width, output_cols);

  /* Each of the eight neighbor pixels contributes a fraction SF to the
   * smoothed pixel, while the main pixel contributes (1-8*SF).  In order
   * to use integer arithmetic, these factors are multiplied by 2^16 = 65536.
   * Also recall that SF = smoothing_factor / 1024.
   */

  memberscale = 65536L - cinfo->smoothing_factor * 512L; /* scaled 1-8*SF */
  neighscale = cinfo->smoothing_factor * 64; /* scaled SF */

  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {
    outptr = output_data[outrow];
    inptr = input_data[outrow];
    above_ptr = input_data[outrow-1];
    below_ptr = input_data[outrow+1];

    /* Special case for first column */
    colsum = GETJSAMPLE(*above_ptr++) + GETJSAMPLE(*below_ptr++) +
	     GETJSAMPLE(*inptr);
    membersum = GETJSAMPLE(*inptr++);
    nextcolsum = GETJSAMPLE(*above_ptr) + GETJSAMPLE(*below_ptr) +
		 GETJSAMPLE(*inptr);
    neighsum = colsum + (colsum - membersum) + nextcolsum;
    membersum = membersum * memberscale + neighsum * neighscale;
    *outptr++ = (JSAMPLE) ((membersum + 32768) >> 16);
    lastcolsum = colsum; colsum = nextcolsum;

    for (colctr = output_cols - 2; colctr > 0; colctr--) {
      membersum = GETJSAMPLE(*inptr++);
      above_ptr++; below_ptr++;
      nextcolsum = GETJSAMPLE(*above_ptr) + GETJSAMPLE(*below_ptr) +
		   GETJSAMPLE(*inptr);
      neighsum = lastcolsum + (colsum - membersum) + nextcolsum;
      membersum = membersum * memberscale + neighsum * neighscale;
      *outptr++ = (JSAMPLE) ((membersum + 32768) >> 16);
      lastcolsum = colsum; colsum = nextcolsum;
    }

    /* Special case for last column */
    membersum = GETJSAMPLE(*inptr);
    neighsum = lastcolsum + (colsum - membersum) + colsum;
    membersum = membersum * memberscale + neighsum * neighscale;
    *outptr = (JSAMPLE) ((membersum + 32768) >> 16);

  }
}

#endif /* INPUT_SMOOTHING_SUPPORTED */


/*
 * Module initialization routine for downsampling.
 * Note that we must select a routine for each component.
 */

GLOBAL(void)
jinit_downsampler (j_compress_ptr cinfo)
{
  my_downsample_ptr downsample;
  int ci;
  jpeg_component_info * compptr;
  boolean smoothok = TRUE;

  downsample = (my_downsample_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_downsampler));
  cinfo->downsample = (struct jpeg_downsampler *) downsample;
  downsample->pub.start_pass = start_pass_downsample;
  downsample->pub.downsample = sep_downsample;
  downsample->pub.need_context_rows = FALSE;

  if (cinfo->CCIR601_sampling)
    ERREXIT(cinfo, JERR_CCIR601_NOTIMPL);

  /* Verify we can handle the sampling factors, and set up method pointers */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    if (compptr->h_samp_factor == cinfo->max_h_samp_factor &&
	compptr->v_samp_factor == cinfo->max_v_samp_factor) {
#ifdef INPUT_SMOOTHING_SUPPORTED
      if (cinfo->smoothing_factor) {
	downsample->methods[ci] = fullsize_smooth_downsample;
	downsample->pub.need_context_rows = TRUE;
      } else
#endif
	downsample->methods[ci] = fullsize_downsample;
    } else if (compptr->h_samp_factor * 2 == cinfo->max_h_samp_factor &&
	       compptr->v_samp_factor == cinfo->max_v_samp_factor) {
      smoothok = FALSE;
      downsample->methods[ci] = h2v1_downsample;
    } else if (compptr->h_samp_factor * 2 == cinfo->max_h_samp_factor &&
	       compptr->v_samp_factor * 2 == cinfo->max_v_samp_factor) {
#ifdef INPUT_SMOOTHING_SUPPORTED
      if (cinfo->smoothing_factor) {
	downsample->methods[ci] = h2v2_smooth_downsample;
	downsample->pub.need_context_rows = TRUE;
      } else
#endif
	downsample->methods[ci] = h2v2_downsample;
    } else if ((cinfo->max_h_samp_factor % compptr->h_samp_factor) == 0 &&
	       (cinfo->max_v_samp_factor % compptr->v_samp_factor) == 0) {
      smoothok = FALSE;
      downsample->methods[ci] = int_downsample;
    } else
      ERREXIT(cinfo, JERR_FRACT_SAMPLE_NOTIMPL);
  }

#ifdef INPUT_SMOOTHING_SUPPORTED
  if (cinfo->smoothing_factor && !smoothok)
    TRACEMS(cinfo, 0, JTRC_SMOOTH_NOTIMPL);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\jcprepct.c ===
/*
 * jcprepct.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains the compression preprocessing controller.
 * This controller manages the color conversion, downsampling,
 * and edge expansion steps.
 *
 * Most of the complexity here is associated with buffering input rows
 * as required by the downsampler.  See the comments at the head of
 * jcsample.c for the downsampler's needs.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/* At present, jcsample.c can request context rows only for smoothing.
 * In the future, we might also need context rows for CCIR601 sampling
 * or other more-complex downsampling procedures.  The code to support
 * context rows should be compiled only if needed.
 */
#ifdef INPUT_SMOOTHING_SUPPORTED
#define CONTEXT_ROWS_SUPPORTED
#endif


/*
 * For the simple (no-context-row) case, we just need to buffer one
 * row group's worth of pixels for the downsampling step.  At the bottom of
 * the image, we pad to a full row group by replicating the last pixel row.
 * The downsampler's last output row is then replicated if needed to pad
 * out to a full iMCU row.
 *
 * When providing context rows, we must buffer three row groups' worth of
 * pixels.  Three row groups are physically allocated, but the row pointer
 * arrays are made five row groups high, with the extra pointers above and
 * below "wrapping around" to point to the last and first real row groups.
 * This allows the downsampler to access the proper context rows.
 * At the top and bottom of the image, we create dummy context rows by
 * copying the first or last real pixel row.  This copying could be avoided
 * by pointer hacking as is done in jdmainct.c, but it doesn't seem worth the
 * trouble on the compression side.
 */


/* Private buffer controller object */

typedef struct {
  struct jpeg_c_prep_controller pub; /* public fields */

  /* Downsampling input buffer.  This buffer holds color-converted data
   * until we have enough to do a downsample step.
   */
  JSAMPARRAY color_buf[MAX_COMPONENTS];

  JDIMENSION rows_to_go;	/* counts rows remaining in source image */
  int next_buf_row;		/* index of next row to store in color_buf */

#ifdef CONTEXT_ROWS_SUPPORTED	/* only needed for context case */
  int this_row_group;		/* starting row index of group to process */
  int next_buf_stop;		/* downsample when we reach this index */
#endif
} my_prep_controller;

typedef my_prep_controller * my_prep_ptr;


/*
 * Initialize for a processing pass.
 */

METHODDEF(void)
start_pass_prep (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
{
  my_prep_ptr prep = (my_prep_ptr) cinfo->prep;

  if (pass_mode != JBUF_PASS_THRU)
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);

  /* Initialize total-height counter for detecting bottom of image */
  prep->rows_to_go = cinfo->image_height;
  /* Mark the conversion buffer empty */
  prep->next_buf_row = 0;
#ifdef CONTEXT_ROWS_SUPPORTED
  /* Preset additional state variables for context mode.
   * These aren't used in non-context mode, so we needn't test which mode.
   */
  prep->this_row_group = 0;
  /* Set next_buf_stop to stop after two row groups have been read in. */
  prep->next_buf_stop = 2 * cinfo->max_v_samp_factor;
#endif
}


/*
 * Expand an image vertically from height input_rows to height output_rows,
 * by duplicating the bottom row.
 */

LOCAL(void)
expand_bottom_edge (JSAMPARRAY image_data, JDIMENSION num_cols,
		    int input_rows, int output_rows)
{
  register int row;

  for (row = input_rows; row < output_rows; row++) {
    jcopy_sample_rows(image_data, input_rows-1, image_data, row,
		      1, num_cols);
  }
}


/*
 * Process some data in the simple no-context case.
 *
 * Preprocessor output data is counted in "row groups".  A row group
 * is defined to be v_samp_factor sample rows of each component.
 * Downsampling will produce this much data from each max_v_samp_factor
 * input rows.
 */

METHODDEF(void)
pre_process_data (j_compress_ptr cinfo,
		  JSAMPARRAY input_buf, JDIMENSION *in_row_ctr,
		  JDIMENSION in_rows_avail,
		  JSAMPIMAGE output_buf, JDIMENSION *out_row_group_ctr,
		  JDIMENSION out_row_groups_avail)
{
  my_prep_ptr prep = (my_prep_ptr) cinfo->prep;
  int numrows, ci;
  JDIMENSION inrows;
  jpeg_component_info * compptr;

  while (*in_row_ctr < in_rows_avail &&
	 *out_row_group_ctr < out_row_groups_avail) {
    /* Do color conversion to fill the conversion buffer. */
    inrows = in_rows_avail - *in_row_ctr;
    numrows = cinfo->max_v_samp_factor - prep->next_buf_row;
    numrows = (int) MIN((JDIMENSION) numrows, inrows);
    (*cinfo->cconvert->color_convert) (cinfo, input_buf + *in_row_ctr,
				       prep->color_buf,
				       (JDIMENSION) prep->next_buf_row,
				       numrows);
    *in_row_ctr += numrows;
    prep->next_buf_row += numrows;
    prep->rows_to_go -= numrows;
    /* If at bottom of image, pad to fill the conversion buffer. */
    if (prep->rows_to_go == 0 &&
	prep->next_buf_row < cinfo->max_v_samp_factor) {
      for (ci = 0; ci < cinfo->num_components; ci++) {
	expand_bottom_edge(prep->color_buf[ci], cinfo->image_width,
			   prep->next_buf_row, cinfo->max_v_samp_factor);
      }
      prep->next_buf_row = cinfo->max_v_samp_factor;
    }
    /* If we've filled the conversion buffer, empty it. */
    if (prep->next_buf_row == cinfo->max_v_samp_factor) {
      (*cinfo->downsample->downsample) (cinfo,
					prep->color_buf, (JDIMENSION) 0,
					output_buf, *out_row_group_ctr);
      prep->next_buf_row = 0;
      (*out_row_group_ctr)++;
    }
    /* If at bottom of image, pad the output to a full iMCU height.
     * Note we assume the caller is providing a one-iMCU-height output buffer!
     */
    if (prep->rows_to_go == 0 &&
	*out_row_group_ctr < out_row_groups_avail) {
      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
	   ci++, compptr++) {
	expand_bottom_edge(output_buf[ci],
			   compptr->width_in_blocks * DCTSIZE,
			   (int) (*out_row_group_ctr * compptr->v_samp_factor),
			   (int) (out_row_groups_avail * compptr->v_samp_factor));
      }
      *out_row_group_ctr = out_row_groups_avail;
      break;			/* can exit outer loop without test */
    }
  }
}


#ifdef CONTEXT_ROWS_SUPPORTED

/*
 * Process some data in the context case.
 */

METHODDEF(void)
pre_process_context (j_compress_ptr cinfo,
		     JSAMPARRAY input_buf, JDIMENSION *in_row_ctr,
		     JDIMENSION in_rows_avail,
		     JSAMPIMAGE output_buf, JDIMENSION *out_row_group_ctr,
		     JDIMENSION out_row_groups_avail)
{
  my_prep_ptr prep = (my_prep_ptr) cinfo->prep;
  int numrows, ci;
  int buf_height = cinfo->max_v_samp_factor * 3;
  JDIMENSION inrows;

  while (*out_row_group_ctr < out_row_groups_avail) {
    if (*in_row_ctr < in_rows_avail) {
      /* Do color conversion to fill the conversion buffer. */
      inrows = in_rows_avail - *in_row_ctr;
      numrows = prep->next_buf_stop - prep->next_buf_row;
      numrows = (int) MIN((JDIMENSION) numrows, inrows);
      (*cinfo->cconvert->color_convert) (cinfo, input_buf + *in_row_ctr,
					 prep->color_buf,
					 (JDIMENSION) prep->next_buf_row,
					 numrows);
      /* Pad at top of image, if first time through */
      if (prep->rows_to_go == cinfo->image_height) {
	for (ci = 0; ci < cinfo->num_components; ci++) {
	  int row;
	  for (row = 1; row <= cinfo->max_v_samp_factor; row++) {
	    jcopy_sample_rows(prep->color_buf[ci], 0,
			      prep->color_buf[ci], -row,
			      1, cinfo->image_width);
	  }
	}
      }
      *in_row_ctr += numrows;
      prep->next_buf_row += numrows;
      prep->rows_to_go -= numrows;
    } else {
      /* Return for more data, unless we are at the bottom of the image. */
      if (prep->rows_to_go != 0)
	break;
      /* When at bottom of image, pad to fill the conversion buffer. */
      if (prep->next_buf_row < prep->next_buf_stop) {
	for (ci = 0; ci < cinfo->num_components; ci++) {
	  expand_bottom_edge(prep->color_buf[ci], cinfo->image_width,
			     prep->next_buf_row, prep->next_buf_stop);
	}
	prep->next_buf_row = prep->next_buf_stop;
      }
    }
    /* If we've gotten enough data, downsample a row group. */
    if (prep->next_buf_row == prep->next_buf_stop) {
      (*cinfo->downsample->downsample) (cinfo,
					prep->color_buf,
					(JDIMENSION) prep->this_row_group,
					output_buf, *out_row_group_ctr);
      (*out_row_group_ctr)++;
      /* Advance pointers with wraparound as necessary. */
      prep->this_row_group += cinfo->max_v_samp_factor;
      if (prep->this_row_group >= buf_height)
	prep->this_row_group = 0;
      if (prep->next_buf_row >= buf_height)
	prep->next_buf_row = 0;
      prep->next_buf_stop = prep->next_buf_row + cinfo->max_v_samp_factor;
    }
  }
}


/*
 * Create the wrapped-around downsampling input buffer needed for context mode.
 */

LOCAL(void)
create_context_buffer (j_compress_ptr cinfo)
{
  my_prep_ptr prep = (my_prep_ptr) cinfo->prep;
  int rgroup_height = cinfo->max_v_samp_factor;
  int ci, i;
  jpeg_component_info * compptr;
  JSAMPARRAY true_buffer, fake_buffer;

  /* Grab enough space for fake row pointers for all the components;
   * we need five row groups' worth of pointers for each component.
   */
  fake_buffer = (JSAMPARRAY)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(cinfo->num_components * 5 * rgroup_height) *
				SIZEOF(JSAMPROW));

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Allocate the actual buffer space (3 row groups) for this component.
     * We make the buffer wide enough to allow the downsampler to edge-expand
     * horizontally within the buffer, if it so chooses.
     */
    true_buffer = (*cinfo->mem->alloc_sarray)
      ((j_common_ptr) cinfo, JPOOL_IMAGE,
       (JDIMENSION) (((long) compptr->width_in_blocks * DCTSIZE *
		      cinfo->max_h_samp_factor) / compptr->h_samp_factor),
       (JDIMENSION) (3 * rgroup_height));
    /* Copy true buffer row pointers into the middle of the fake row array */
    MEMCOPY(fake_buffer + rgroup_height, true_buffer,
	    3 * rgroup_height * SIZEOF(JSAMPROW));
    /* Fill in the above and below wraparound pointers */
    for (i = 0; i < rgroup_height; i++) {
      fake_buffer[i] = true_buffer[2 * rgroup_height + i];
      fake_buffer[4 * rgroup_height + i] = true_buffer[i];
    }
    prep->color_buf[ci] = fake_buffer + rgroup_height;
    fake_buffer += 5 * rgroup_height; /* point to space for next component */
  }
}

#endif /* CONTEXT_ROWS_SUPPORTED */


/*
 * Initialize preprocessing controller.
 */

GLOBAL(void)
jinit_c_prep_controller (j_compress_ptr cinfo, boolean need_full_buffer)
{
  my_prep_ptr prep;
  int ci;
  jpeg_component_info * compptr;

  if (need_full_buffer)		/* safety check */
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);

  prep = (my_prep_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_prep_controller));
  cinfo->prep = (struct jpeg_c_prep_controller *) prep;
  prep->pub.start_pass = start_pass_prep;

  /* Allocate the color conversion buffer.
   * We make the buffer wide enough to allow the downsampler to edge-expand
   * horizontally within the buffer, if it so chooses.
   */
  if (cinfo->downsample->need_context_rows) {
    /* Set up to provide context rows */
#ifdef CONTEXT_ROWS_SUPPORTED
    prep->pub.pre_process_data = pre_process_context;
    create_context_buffer(cinfo);
#else
    ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
  } else {
    /* No context, just make it tall enough for one row group */
    prep->pub.pre_process_data = pre_process_data;
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
	 ci++, compptr++) {
      prep->color_buf[ci] = (*cinfo->mem->alloc_sarray)
	((j_common_ptr) cinfo, JPOOL_IMAGE,
	 (JDIMENSION) (((long) compptr->width_in_blocks * DCTSIZE *
			cinfo->max_h_samp_factor) / compptr->h_samp_factor),
	 (JDIMENSION) cinfo->max_v_samp_factor);
    }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\jconfig.h ===
/*
 * jconfig.doc
 *
 * Copyright (C) 1991-1994, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file documents the configuration options that are required to
 * customize the JPEG software for a particular system.
 *
 * The actual configuration options for a particular installation are stored
 * in jconfig.h.  On many machines, jconfig.h can be generated automatically
 * or copied from one of the "canned" jconfig files that we supply.  But if
 * you need to generate a jconfig.h file by hand, this file tells you how.
 *
 * DO NOT EDIT THIS FILE --- IT WON'T ACCOMPLISH ANYTHING.
 * EDIT A COPY NAMED JCONFIG.H.
 */


/*
 * These symbols indicate the properties of your machine or compiler.
 * #define the symbol if yes, #undef it if no.
 */
#define HAVE_BOOLEAN
typedef unsigned char boolean;

/* Does your compiler support function prototypes?
 * (If not, you also need to use ansi2knr, see install.doc)
 */
#define HAVE_PROTOTYPES

/* Does your compiler support the declaration "unsigned char" ?
 * How about "unsigned short" ?
 */
#define HAVE_UNSIGNED_CHAR
#define HAVE_UNSIGNED_SHORT

/* Define "void" as "char" if your compiler doesn't know about type void.
 * NOTE: be sure to define void such that "void *" represents the most general
 * pointer type, e.g., that returned by malloc().
 */
/* #define void char */

/* Define "const" as empty if your compiler doesn't know the "const" keyword.
 */
/* #define const */

/* Define this if an ordinary "char" type is unsigned.
 * If you're not sure, leaving it undefined will work at some cost in speed.
 * If you defined HAVE_UNSIGNED_CHAR then the speed difference is minimal.
 */
#undef CHAR_IS_UNSIGNED

/* Define this if your system has an ANSI-conforming <stddef.h> file.
 */
#define HAVE_STDDEF_H

/* Define this if your system has an ANSI-conforming <stdlib.h> file.
 */
#define HAVE_STDLIB_H

/* Define this if your system does not have an ANSI/SysV <string.h>,
 * but does have a BSD-style <strings.h>.
 */
#undef NEED_BSD_STRINGS

/* Define this if your system does not provide typedef size_t in any of the
 * ANSI-standard places (stddef.h, stdlib.h, or stdio.h), but places it in
 * <sys/types.h> instead.
 */
#undef NEED_SYS_TYPES_H

/* For 80x86 machines, you need to define NEED_FAR_POINTERS,
 * unless you are using a large-data memory model or 80386 flat-memory mode.
 * On less brain-damaged CPUs this symbol must not be defined.
 * (Defining this symbol causes large data structures to be referenced through
 * "far" pointers and to be allocated with a special version of malloc.)
 */
#undef NEED_FAR_POINTERS
#undef FAR
#define FAR

/* Define this if your linker needs global names to be unique in less
 * than the first 15 characters.
 */
#undef NEED_SHORT_EXTERNAL_NAMES

/* Although a real ANSI C compiler can deal perfectly well with pointers to
 * unspecified structures (see "incomplete types" in the spec), a few pre-ANSI
 * and pseudo-ANSI compilers get confused.  To keep one of these bozos happy,
 * define INCOMPLETE_TYPES_BROKEN.  This is not recommended unless you
 * actually get "missing structure definition" warnings or errors while
 * compiling the JPEG code.
 */
#undef INCOMPLETE_TYPES_BROKEN

/*
 * The following options affect code selection within the JPEG library,
 * but they don't need to be visible to applications using the library.
 * To minimize application namespace pollution, the symbols won't be
 * defined unless JPEG_INTERNALS has been defined.
 */
#ifdef JPEG_INTERNALS

/* Define this if your compiler implements ">>" on signed values as a logical
 * (unsigned) shift; leave it undefined if ">>" is a signed (arithmetic) shift,
 * which is the normal and rational definition.
 */
#undef RIGHT_SHIFT_IS_UNSIGNED

/* Because sizeof(double) = 10 on 68K Mac						*/
/* see ALIGN_TYPE definitiion in jmemmgr.c for details.			*/
#if defined(MAC) && !defined(POWERPC)
#define ALIGN_TYPE long
#endif /* defined(MAC) && !defined(POWERPC) */

#endif /* JPEG_INTERNALS */

/*
 * The remaining options do not affect the JPEG library proper,
 * but only the sample applications cjpeg/djpeg (see cjpeg.c, djpeg.c).
 * Other applications can ignore these.
 */
#ifdef JPEG_CJPEG_DJPEG

/* These defines indicate which image (non-JPEG) file formats are allowed. */

#define BMP_SUPPORTED		/* BMP image file format */
#define GIF_SUPPORTED		/* GIF image file format */
#define PPM_SUPPORTED		/* PBMPLUS PPM/PGM image file format */
#undef RLE_SUPPORTED		/* Utah RLE image file format */
#define TARGA_SUPPORTED		/* Targa image file format */

/* Define this if you want to name both input and output files on the command
 * line, rather than using stdout and optionally stdin.  You MUST do this if
 * your system can't cope with binary I/O to stdin/stdout.  See comments at
 * head of cjpeg.c or djpeg.c.
 */
#undef TWO_FILE_COMMANDLINE

/* Define this if your system needs explicit cleanup of temporary files.
 * This is crucial under MS-DOS, where the temporary "files" may be areas
 * of extended memory; on most other systems it's not as important.
 */
#undef NEED_SIGNAL_CATCHER

/* By default, we open image files with fopen(...,"rb") or fopen(...,"wb").
 * This is necessary on systems that distinguish text files from binary files,
 * and is harmless on most systems that don't.  If you have one of the rare
 * systems that complains about the "b" spec, define this symbol.
 */
#undef DONT_USE_B_MODE

/* Define this if you want percent-done progress reports from cjpeg/djpeg.
 */
#undef PROGRESS_REPORT

#endif /* JPEG_CJPEG_DJPEG */

#define SHORTxSHORT_32
#define INLINE  __inline

#define USE_SETMODE		    /* Microsoft has setmode() */
#define _NTSDK              /* Non-ANSI names for compatibility */
#define J_SIZEOF(x) SIZEOF(x)
#define NO_GETENV
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\jdapistd.c ===
/*
 * jdapistd.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains application interface code for the decompression half
 * of the JPEG library.  These are the "standard" API routines that are
 * used in the normal full-decompression case.  They are not used by a
 * transcoding-only application.  Note that if an application links in
 * jpeg_start_decompress, it will end up linking in the entire decompressor.
 * We thus must separate this file from jdapimin.c to avoid linking the
 * whole decompression library into a transcoder.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/* Forward declarations */
LOCAL(boolean) output_pass_setup JPP((j_decompress_ptr cinfo));


/*
 * Decompression initialization.
 * jpeg_read_header must be completed before calling this.
 *
 * If a multipass operating mode was selected, this will do all but the
 * last pass, and thus may take a great deal of time.
 *
 * Returns FALSE if suspended.  The return value need be inspected only if
 * a suspending data source is used.
 */

GLOBAL(boolean)
jpeg_start_decompress (j_decompress_ptr cinfo)
{
  if (cinfo->global_state == DSTATE_READY) {
    /* First call: initialize master control, select active modules */
    jinit_master_decompress(cinfo);
    if (cinfo->buffered_image) {
      /* No more work here; expecting jpeg_start_output next */
      cinfo->global_state = DSTATE_BUFIMAGE;
      return TRUE;
    }
    cinfo->global_state = DSTATE_PRELOAD;
  }
  if (cinfo->global_state == DSTATE_PRELOAD) {
    /* If file has multiple scans, absorb them all into the coef buffer */
    if (cinfo->inputctl->has_multiple_scans) {
#ifdef D_MULTISCAN_FILES_SUPPORTED
      for (;;) {
	int retcode;
	/* Call progress monitor hook if present */
	if (cinfo->progress != NULL)
	  (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
	/* Absorb some more input */
	retcode = (*cinfo->inputctl->consume_input) (cinfo);
	if (retcode == JPEG_SUSPENDED)
	  return FALSE;
	if (retcode == JPEG_REACHED_EOI)
	  break;
	/* Advance progress counter if appropriate */
	if (cinfo->progress != NULL &&
	    (retcode == JPEG_ROW_COMPLETED || retcode == JPEG_REACHED_SOS)) {
	  if (++cinfo->progress->pass_counter >= cinfo->progress->pass_limit) {
	    /* jdmaster underestimated number of scans; ratchet up one scan */
	    cinfo->progress->pass_limit += (long) cinfo->total_iMCU_rows;
	  }
	}
      }
#else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif /* D_MULTISCAN_FILES_SUPPORTED */
    }
    cinfo->output_scan_number = cinfo->input_scan_number;
  } else if (cinfo->global_state != DSTATE_PRESCAN)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  /* Perform any dummy output passes, and set up for the final pass */
  return output_pass_setup(cinfo);
}


/*
 * Set up for an output pass, and perform any dummy pass(es) needed.
 * Common subroutine for jpeg_start_decompress and jpeg_start_output.
 * Entry: global_state = DSTATE_PRESCAN only if previously suspended.
 * Exit: If done, returns TRUE and sets global_state for proper output mode.
 *       If suspended, returns FALSE and sets global_state = DSTATE_PRESCAN.
 */

LOCAL(boolean)
output_pass_setup (j_decompress_ptr cinfo)
{
  if (cinfo->global_state != DSTATE_PRESCAN) {
    /* First call: do pass setup */
    (*cinfo->master->prepare_for_output_pass) (cinfo);
    cinfo->output_scanline = 0;
    cinfo->global_state = DSTATE_PRESCAN;
  }
  /* Loop over any required dummy passes */
  while (cinfo->master->is_dummy_pass) {
#ifdef QUANT_2PASS_SUPPORTED
    /* Crank through the dummy pass */
    while (cinfo->output_scanline < cinfo->output_height) {
      JDIMENSION last_scanline;
      /* Call progress monitor hook if present */
      if (cinfo->progress != NULL) {
	cinfo->progress->pass_counter = (long) cinfo->output_scanline;
	cinfo->progress->pass_limit = (long) cinfo->output_height;
	(*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
      }
      /* Process some data */
      last_scanline = cinfo->output_scanline;
      (*cinfo->main->process_data) (cinfo, (JSAMPARRAY) NULL,
				    &cinfo->output_scanline, (JDIMENSION) 0);
      if (cinfo->output_scanline == last_scanline)
	return FALSE;		/* No progress made, must suspend */
    }
    /* Finish up dummy pass, and set up for another one */
    (*cinfo->master->finish_output_pass) (cinfo);
    (*cinfo->master->prepare_for_output_pass) (cinfo);
    cinfo->output_scanline = 0;
#else
    ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif /* QUANT_2PASS_SUPPORTED */
  }
  /* Ready for application to drive output pass through
   * jpeg_read_scanlines or jpeg_read_raw_data.
   */
  cinfo->global_state = cinfo->raw_data_out ? DSTATE_RAW_OK : DSTATE_SCANNING;
  return TRUE;
}


/*
 * Read some scanlines of data from the JPEG decompressor.
 *
 * The return value will be the number of lines actually read.
 * This may be less than the number requested in several cases,
 * including bottom of image, data source suspension, and operating
 * modes that emit multiple scanlines at a time.
 *
 * Note: we warn about excess calls to jpeg_read_scanlines() since
 * this likely signals an application programmer error.  However,
 * an oversize buffer (max_lines > scanlines remaining) is not an error.
 */

GLOBAL(JDIMENSION)
jpeg_read_scanlines (j_decompress_ptr cinfo, JSAMPARRAY scanlines,
		     JDIMENSION max_lines)
{
  JDIMENSION row_ctr;

  if (cinfo->global_state != DSTATE_SCANNING)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  if (cinfo->output_scanline >= cinfo->output_height) {
    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);
    return 0;
  }

  /* Call progress monitor hook if present */
  if (cinfo->progress != NULL) {
    cinfo->progress->pass_counter = (long) cinfo->output_scanline;
    cinfo->progress->pass_limit = (long) cinfo->output_height;
    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
  }

  /* Process some data */
  row_ctr = 0;
  (*cinfo->main->process_data) (cinfo, scanlines, &row_ctr, max_lines);
  cinfo->output_scanline += row_ctr;
  return row_ctr;
}


/*
 * Alternate entry point to read raw data.
 * Processes exactly one iMCU row per call, unless suspended.
 */

GLOBAL(JDIMENSION)
jpeg_read_raw_data (j_decompress_ptr cinfo, JSAMPIMAGE data,
		    JDIMENSION max_lines)
{
  JDIMENSION lines_per_iMCU_row;

  if (cinfo->global_state != DSTATE_RAW_OK)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  if (cinfo->output_scanline >= cinfo->output_height) {
    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);
    return 0;
  }

  /* Call progress monitor hook if present */
  if (cinfo->progress != NULL) {
    cinfo->progress->pass_counter = (long) cinfo->output_scanline;
    cinfo->progress->pass_limit = (long) cinfo->output_height;
    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
  }

  /* Verify that at least one iMCU row can be returned. */
  lines_per_iMCU_row = cinfo->max_v_samp_factor * cinfo->min_DCT_scaled_size;
  if (max_lines < lines_per_iMCU_row)
    ERREXIT(cinfo, JERR_BUFFER_SIZE);

  /* Decompress directly into user's buffer. */
  if (! (*cinfo->coef->decompress_data) (cinfo, data))
    return 0;			/* suspension forced, can do nothing more */

  /* OK, we processed one iMCU row. */
  cinfo->output_scanline += lines_per_iMCU_row;
  return lines_per_iMCU_row;
}


/* Additional entry points for buffered-image mode. */

#ifdef D_MULTISCAN_FILES_SUPPORTED

/*
 * Initialize for an output pass in buffered-image mode.
 */

GLOBAL(boolean)
jpeg_start_output (j_decompress_ptr cinfo, int scan_number)
{
  if (cinfo->global_state != DSTATE_BUFIMAGE &&
      cinfo->global_state != DSTATE_PRESCAN)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  /* Limit scan number to valid range */
  if (scan_number <= 0)
    scan_number = 1;
  if (cinfo->inputctl->eoi_reached &&
      scan_number > cinfo->input_scan_number)
    scan_number = cinfo->input_scan_number;
  cinfo->output_scan_number = scan_number;
  /* Perform any dummy output passes, and set up for the real pass */
  return output_pass_setup(cinfo);
}


/*
 * Finish up after an output pass in buffered-image mode.
 *
 * Returns FALSE if suspended.  The return value need be inspected only if
 * a suspending data source is used.
 */

GLOBAL(boolean)
jpeg_finish_output (j_decompress_ptr cinfo)
{
  if ((cinfo->global_state == DSTATE_SCANNING ||
       cinfo->global_state == DSTATE_RAW_OK) && cinfo->buffered_image) {
    /* Terminate this pass. */
    /* We do not require the whole pass to have been completed. */
    (*cinfo->master->finish_output_pass) (cinfo);
    cinfo->global_state = DSTATE_BUFPOST;
  } else if (cinfo->global_state != DSTATE_BUFPOST) {
    /* BUFPOST = repeat call after a suspension, anything else is error */
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  }
  /* Read markers looking for SOS or EOI */
  while (cinfo->input_scan_number <= cinfo->output_scan_number &&
	 ! cinfo->inputctl->eoi_reached) {
    if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)
      return FALSE;		/* Suspend, come back later */
  }
  cinfo->global_state = DSTATE_BUFIMAGE;
  return TRUE;
}

#endif /* D_MULTISCAN_FILES_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\jdapimin.c ===
/*
 * jdapimin.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains application interface code for the decompression half
 * of the JPEG library.  These are the "minimum" API routines that may be
 * needed in either the normal full-decompression case or the
 * transcoding-only case.
 *
 * Most of the routines intended to be called directly by an application
 * are in this file or in jdapistd.c.  But also see jcomapi.c for routines
 * shared by compression and decompression, and jdtrans.c for the transcoding
 * case.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/*
 * Initialization of a JPEG decompression object.
 * The error manager must already be set up (in case memory manager fails).
 */

GLOBAL(void)
jpeg_CreateDecompress (j_decompress_ptr cinfo, int version, size_t structsize)
{
  int i;

  /* Guard against version mismatches between library and caller. */
  cinfo->mem = NULL;		/* so jpeg_destroy knows mem mgr not called */
  if (version != JPEG_LIB_VERSION)
    ERREXIT2(cinfo, JERR_BAD_LIB_VERSION, JPEG_LIB_VERSION, version);
  if (structsize != SIZEOF(struct jpeg_decompress_struct))
    ERREXIT2(cinfo, JERR_BAD_STRUCT_SIZE, 
	     (int) SIZEOF(struct jpeg_decompress_struct), (int) structsize);

  /* For debugging purposes, zero the whole master structure.
   * But error manager pointer is already there, so save and restore it.
   */
  {
    struct jpeg_error_mgr * err = cinfo->err;
    MEMZERO(cinfo, SIZEOF(struct jpeg_decompress_struct));
    cinfo->err = err;
  }
  cinfo->is_decompressor = TRUE;

  /* Initialize a memory manager instance for this object */
  jinit_memory_mgr((j_common_ptr) cinfo);

  /* Zero out pointers to permanent structures. */
  cinfo->progress = NULL;
  cinfo->src = NULL;

  for (i = 0; i < NUM_QUANT_TBLS; i++)
    cinfo->quant_tbl_ptrs[i] = NULL;

  for (i = 0; i < NUM_HUFF_TBLS; i++) {
    cinfo->dc_huff_tbl_ptrs[i] = NULL;
    cinfo->ac_huff_tbl_ptrs[i] = NULL;
  }

  /* Initialize marker processor so application can override methods
   * for COM, APPn markers before calling jpeg_read_header.
   */
  jinit_marker_reader(cinfo);

  /* And initialize the overall input controller. */
  jinit_input_controller(cinfo);

  /* Check for MMX machine if necessary */
/*    if (vfMMXMachine == 2) */
/*        vfMMXMachine = (boolean)IsMMX(); */
      
  /* OK, I'm ready */
  cinfo->global_state = DSTATE_START;
}


/*
 * Destruction of a JPEG decompression object
 */

GLOBAL(void)
jpeg_destroy_decompress (j_decompress_ptr cinfo)
{
  jpeg_destroy((j_common_ptr) cinfo); /* use common routine */
}


/*
 * Abort processing of a JPEG decompression operation,
 * but don't destroy the object itself.
 */

GLOBAL(void)
jpeg_abort_decompress (j_decompress_ptr cinfo)
{
  jpeg_abort((j_common_ptr) cinfo); /* use common routine */
}


/*
 * Install a special processing method for COM or APPn markers.
 */

GLOBAL(void)
jpeg_set_marker_processor (j_decompress_ptr cinfo, int marker_code,
			   jpeg_marker_parser_method routine)
{
  if (marker_code == JPEG_COM)
    cinfo->marker->process_COM = routine;
  else if (marker_code >= JPEG_APP0 && marker_code <= JPEG_APP0+15)
    cinfo->marker->process_APPn[marker_code-JPEG_APP0] = routine;
  else
    ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, marker_code);
}


/*
 * Set default decompression parameters.
 */

LOCAL(void)
default_decompress_parms (j_decompress_ptr cinfo)
{
  /* Guess the input colorspace, and set output colorspace accordingly. */
  /* (Wish JPEG committee had provided a real way to specify this...) */
  /* Note application may override our guesses. */
  switch (cinfo->num_components) {
  case 1:
    cinfo->jpeg_color_space = JCS_GRAYSCALE;
    cinfo->out_color_space = JCS_GRAYSCALE;
    break;
    
  case 3:
    if (cinfo->saw_JFIF_marker) {
      cinfo->jpeg_color_space = JCS_YCbCr; /* JFIF implies YCbCr */
    } else if (cinfo->saw_Adobe_marker) {
      switch (cinfo->Adobe_transform) {
      case 0:
	cinfo->jpeg_color_space = JCS_RGB;
	break;
      case 1:
	cinfo->jpeg_color_space = JCS_YCbCr;
	break;
      default:
	WARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);
	cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */
	break;
      }
    } else {
      /* Saw no special markers, try to guess from the component IDs */
      int cid0 = cinfo->comp_info[0].component_id;
      int cid1 = cinfo->comp_info[1].component_id;
      int cid2 = cinfo->comp_info[2].component_id;

      if (cid0 == 1 && cid1 == 2 && cid2 == 3)
	cinfo->jpeg_color_space = JCS_YCbCr; /* assume JFIF w/out marker */
      else if (cid0 == 82 && cid1 == 71 && cid2 == 66)
	cinfo->jpeg_color_space = JCS_RGB; /* ASCII 'R', 'G', 'B' */
      else {
	TRACEMS3(cinfo, 1, JTRC_UNKNOWN_IDS, cid0, cid1, cid2);
	cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */
      }
    }
    /* Always guess RGB is proper output colorspace. */
    cinfo->out_color_space = JCS_RGB;
    break;
    
  case 4:
    if (cinfo->saw_Adobe_marker) {
      switch (cinfo->Adobe_transform) {
      case 0:
	cinfo->jpeg_color_space = JCS_CMYK;
	break;
      case 2:
	cinfo->jpeg_color_space = JCS_YCCK;
	break;
      default:
	WARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);
	cinfo->jpeg_color_space = JCS_YCCK; /* assume it's YCCK */
	break;
      }
    } else {
      /* No special markers, assume straight CMYK. */
      cinfo->jpeg_color_space = JCS_CMYK;
    }
    cinfo->out_color_space = JCS_CMYK;
    break;
    
  default:
    cinfo->jpeg_color_space = JCS_UNKNOWN;
    cinfo->out_color_space = JCS_UNKNOWN;
    break;
  }

  /* Set defaults for other decompression parameters. */
  cinfo->scale_num = 1;		/* 1:1 scaling */
  cinfo->scale_denom = 1;
  cinfo->output_gamma = 1.0;
  cinfo->buffered_image = FALSE;
  cinfo->raw_data_out = FALSE;
  cinfo->dct_method = JDCT_DEFAULT;
  cinfo->do_fancy_upsampling = TRUE;
  cinfo->do_block_smoothing = TRUE;
  cinfo->quantize_colors = FALSE;
  /* We set these in case application only sets quantize_colors. */
  cinfo->dither_mode = JDITHER_FS;
#ifdef QUANT_2PASS_SUPPORTED
  cinfo->two_pass_quantize = TRUE;
#else
  cinfo->two_pass_quantize = FALSE;
#endif
  cinfo->desired_number_of_colors = 256;
  cinfo->colormap = NULL;
  /* Initialize for no mode change in buffered-image mode. */
  cinfo->enable_1pass_quant = FALSE;
  cinfo->enable_external_quant = FALSE;
  cinfo->enable_2pass_quant = FALSE;
}


/*
 * Decompression startup: read start of JPEG datastream to see what's there.
 * Need only initialize JPEG object and supply a data source before calling.
 *
 * This routine will read as far as the first SOS marker (ie, actual start of
 * compressed data), and will save all tables and parameters in the JPEG
 * object.  It will also initialize the decompression parameters to default
 * values, and finally return JPEG_HEADER_OK.  On return, the application may
 * adjust the decompression parameters and then call jpeg_start_decompress.
 * (Or, if the application only wanted to determine the image parameters,
 * the data need not be decompressed.  In that case, call jpeg_abort or
 * jpeg_destroy to release any temporary space.)
 * If an abbreviated (tables only) datastream is presented, the routine will
 * return JPEG_HEADER_TABLES_ONLY upon reaching EOI.  The application may then
 * re-use the JPEG object to read the abbreviated image datastream(s).
 * It is unnecessary (but OK) to call jpeg_abort in this case.
 * The JPEG_SUSPENDED return code only occurs if the data source module
 * requests suspension of the decompressor.  In this case the application
 * should load more source data and then re-call jpeg_read_header to resume
 * processing.
 * If a non-suspending data source is used and require_image is TRUE, then the
 * return code need not be inspected since only JPEG_HEADER_OK is possible.
 *
 * This routine is now just a front end to jpeg_consume_input, with some
 * extra error checking.
 */

GLOBAL(int)
jpeg_read_header (j_decompress_ptr cinfo, boolean require_image)
{
  int retcode;

  if (cinfo->global_state != DSTATE_START &&
      cinfo->global_state != DSTATE_INHEADER)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);

  retcode = jpeg_consume_input(cinfo);

  switch (retcode) {
  case JPEG_REACHED_SOS:
    retcode = JPEG_HEADER_OK;
    break;
  case JPEG_REACHED_EOI:
    if (require_image)		/* Complain if application wanted an image */
      ERREXIT(cinfo, JERR_NO_IMAGE);
    /* Reset to start state; it would be safer to require the application to
     * call jpeg_abort, but we can't change it now for compatibility reasons.
     * A side effect is to free any temporary memory (there shouldn't be any).
     */
    jpeg_abort((j_common_ptr) cinfo); /* sets state = DSTATE_START */
    retcode = JPEG_HEADER_TABLES_ONLY;
    break;
  case JPEG_SUSPENDED:
    /* no work */
    break;
  }

  return retcode;
}


/*
 * Consume data in advance of what the decompressor requires.
 * This can be called at any time once the decompressor object has
 * been created and a data source has been set up.
 *
 * This routine is essentially a state machine that handles a couple
 * of critical state-transition actions, namely initial setup and
 * transition from header scanning to ready-for-start_decompress.
 * All the actual input is done via the input controller's consume_input
 * method.
 */

GLOBAL(int)
jpeg_consume_input (j_decompress_ptr cinfo)
{
  int retcode = JPEG_SUSPENDED;

  /* NB: every possible DSTATE value should be listed in this switch */
  switch (cinfo->global_state) {
  case DSTATE_START:
    /* Start-of-datastream actions: reset appropriate modules */
    (*cinfo->inputctl->reset_input_controller) (cinfo);
    /* Initialize application's data source module */
    (*cinfo->src->init_source) (cinfo);
    cinfo->global_state = DSTATE_INHEADER;
    /*FALLTHROUGH*/
  case DSTATE_INHEADER:
    retcode = (*cinfo->inputctl->consume_input) (cinfo);
    if (retcode == JPEG_REACHED_SOS) { /* Found SOS, prepare to decompress */
      /* Set up default parameters based on header data */
      default_decompress_parms(cinfo);
      /* Set global state: ready for start_decompress */
      cinfo->global_state = DSTATE_READY;
    }
    break;
  case DSTATE_READY:
    /* Can't advance past first SOS until start_decompress is called */
    retcode = JPEG_REACHED_SOS;
    break;
  case DSTATE_PRELOAD:
  case DSTATE_PRESCAN:
  case DSTATE_SCANNING:
  case DSTATE_RAW_OK:
  case DSTATE_BUFIMAGE:
  case DSTATE_BUFPOST:
  case DSTATE_STOPPING:
    retcode = (*cinfo->inputctl->consume_input) (cinfo);
    break;
  default:
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  }
  return retcode;
}


/*
 * Have we finished reading the input file?
 */

GLOBAL(boolean)
jpeg_input_complete (j_decompress_ptr cinfo)
{
  /* Check for valid jpeg object */
  if (cinfo->global_state < DSTATE_START ||
      cinfo->global_state > DSTATE_STOPPING)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  return cinfo->inputctl->eoi_reached;
}


/*
 * Is there more than one scan?
 */

GLOBAL(boolean)
jpeg_has_multiple_scans (j_decompress_ptr cinfo)
{
  /* Only valid after jpeg_read_header completes */
  if (cinfo->global_state < DSTATE_READY ||
      cinfo->global_state > DSTATE_STOPPING)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  return cinfo->inputctl->has_multiple_scans;
}


/*
 * Finish JPEG decompression.
 *
 * This will normally just verify the file trailer and release temp storage.
 *
 * Returns FALSE if suspended.  The return value need be inspected only if
 * a suspending data source is used.
 */

GLOBAL(boolean)
jpeg_finish_decompress (j_decompress_ptr cinfo)
{
  if ((cinfo->global_state == DSTATE_SCANNING ||
       cinfo->global_state == DSTATE_RAW_OK) && ! cinfo->buffered_image) {
    /* Terminate final pass of non-buffered mode */
    if (cinfo->output_scanline < cinfo->output_height)
      ERREXIT(cinfo, JERR_TOO_LITTLE_DATA);
    (*cinfo->master->finish_output_pass) (cinfo);
    cinfo->global_state = DSTATE_STOPPING;
  } else if (cinfo->global_state == DSTATE_BUFIMAGE) {
    /* Finishing after a buffered-image operation */
    cinfo->global_state = DSTATE_STOPPING;
  } else if (cinfo->global_state != DSTATE_STOPPING) {
    /* STOPPING = repeat call after a suspension, anything else is error */
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  }
  /* Read until EOI */
  while (! cinfo->inputctl->eoi_reached) {
    if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)
      return FALSE;		/* Suspend, come back later */
  }
  /* Do final cleanup */
  (*cinfo->src->term_source) (cinfo);
  /* We can use jpeg_abort to release memory and reset global_state */
  jpeg_abort((j_common_ptr) cinfo);
  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\jctrans.c ===
/*
 * jctrans.c
 *
 * Copyright (C) 1995-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains library routines for transcoding compression,
 * that is, writing raw DCT coefficient arrays to an output JPEG file.
 * The routines in jcapimin.c will also be needed by a transcoder.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/* Forward declarations */
LOCAL(void) transencode_master_selection
	JPP((j_compress_ptr cinfo, jvirt_barray_ptr * coef_arrays));
LOCAL(void) transencode_coef_controller
	JPP((j_compress_ptr cinfo, jvirt_barray_ptr * coef_arrays));


/*
 * Compression initialization for writing raw-coefficient data.
 * Before calling this, all parameters and a data destination must be set up.
 * Call jpeg_finish_compress() to actually write the data.
 *
 * The number of passed virtual arrays must match cinfo->num_components.
 * Note that the virtual arrays need not be filled or even realized at
 * the time write_coefficients is called; indeed, if the virtual arrays
 * were requested from this compression object's memory manager, they
 * typically will be realized during this routine and filled afterwards.
 */

GLOBAL(void)
jpeg_write_coefficients (j_compress_ptr cinfo, jvirt_barray_ptr * coef_arrays)
{
  if (cinfo->global_state != CSTATE_START)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  /* Mark all tables to be written */
  jpeg_suppress_tables(cinfo, FALSE);
  /* (Re)initialize error mgr and destination modules */
  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
  (*cinfo->dest->init_destination) (cinfo);
  /* Perform master selection of active modules */
  transencode_master_selection(cinfo, coef_arrays);
  /* Wait for jpeg_finish_compress() call */
  cinfo->next_scanline = 0;	/* so jpeg_write_marker works */
  cinfo->global_state = CSTATE_WRCOEFS;
}


/*
 * Initialize the compression object with default parameters,
 * then copy from the source object all parameters needed for lossless
 * transcoding.  Parameters that can be varied without loss (such as
 * scan script and Huffman optimization) are left in their default states.
 */

GLOBAL(void)
jpeg_copy_critical_parameters (j_decompress_ptr srcinfo,
			       j_compress_ptr dstinfo)
{
  JQUANT_TBL ** qtblptr;
  jpeg_component_info *incomp, *outcomp;
  JQUANT_TBL *c_quant, *slot_quant;
  int tblno, ci, coefi;

  /* Safety check to ensure start_compress not called yet. */
  if (dstinfo->global_state != CSTATE_START)
    ERREXIT1(dstinfo, JERR_BAD_STATE, dstinfo->global_state);
  /* Copy fundamental image dimensions */
  dstinfo->image_width = srcinfo->image_width;
  dstinfo->image_height = srcinfo->image_height;
  dstinfo->input_components = srcinfo->num_components;
  dstinfo->in_color_space = srcinfo->jpeg_color_space;
  /* Initialize all parameters to default values */
  jpeg_set_defaults(dstinfo);
  /* jpeg_set_defaults may choose wrong colorspace, eg YCbCr if input is RGB.
   * Fix it to get the right header markers for the image colorspace.
   */
  jpeg_set_colorspace(dstinfo, srcinfo->jpeg_color_space);
  dstinfo->data_precision = srcinfo->data_precision;
  dstinfo->CCIR601_sampling = srcinfo->CCIR601_sampling;
  /* Copy the source's quantization tables. */
  for (tblno = 0; tblno < NUM_QUANT_TBLS; tblno++) {
    if (srcinfo->quant_tbl_ptrs[tblno] != NULL) {
      qtblptr = & dstinfo->quant_tbl_ptrs[tblno];
      if (*qtblptr == NULL)
	*qtblptr = jpeg_alloc_quant_table((j_common_ptr) dstinfo);
      MEMCOPY((*qtblptr)->quantval,
	      srcinfo->quant_tbl_ptrs[tblno]->quantval,
	      SIZEOF((*qtblptr)->quantval));
      (*qtblptr)->sent_table = FALSE;
    }
  }
  /* Copy the source's per-component info.
   * Note we assume jpeg_set_defaults has allocated the dest comp_info array.
   */
  dstinfo->num_components = srcinfo->num_components;
  if (dstinfo->num_components < 1 || dstinfo->num_components > MAX_COMPONENTS)
    ERREXIT2(dstinfo, JERR_COMPONENT_COUNT, dstinfo->num_components,
	     MAX_COMPONENTS);
  for (ci = 0, incomp = srcinfo->comp_info, outcomp = dstinfo->comp_info;
       ci < dstinfo->num_components; ci++, incomp++, outcomp++) {
    outcomp->component_id = incomp->component_id;
    outcomp->h_samp_factor = incomp->h_samp_factor;
    outcomp->v_samp_factor = incomp->v_samp_factor;
    outcomp->quant_tbl_no = incomp->quant_tbl_no;
    /* Make sure saved quantization table for component matches the qtable
     * slot.  If not, the input file re-used this qtable slot.
     * IJG encoder currently cannot duplicate this.
     */
    tblno = outcomp->quant_tbl_no;
    if (tblno < 0 || tblno >= NUM_QUANT_TBLS ||
	srcinfo->quant_tbl_ptrs[tblno] == NULL)
      ERREXIT1(dstinfo, JERR_NO_QUANT_TABLE, tblno);
    slot_quant = srcinfo->quant_tbl_ptrs[tblno];
    c_quant = incomp->quant_table;
    if (c_quant != NULL) {
      for (coefi = 0; coefi < DCTSIZE2; coefi++) {
	if (c_quant->quantval[coefi] != slot_quant->quantval[coefi])
	  ERREXIT1(dstinfo, JERR_MISMATCHED_QUANT_TABLE, tblno);
      }
    }
    /* Note: we do not copy the source's Huffman table assignments;
     * instead we rely on jpeg_set_colorspace to have made a suitable choice.
     */
  }
}


/*
 * Master selection of compression modules for transcoding.
 * This substitutes for jcinit.c's initialization of the full compressor.
 */

LOCAL(void)
transencode_master_selection (j_compress_ptr cinfo,
			      jvirt_barray_ptr * coef_arrays)
{
  /* Although we don't actually use input_components for transcoding,
   * jcmaster.c's initial_setup will complain if input_components is 0.
   */
  cinfo->input_components = 1;
  /* Initialize master control (includes parameter checking/processing) */
  jinit_c_master_control(cinfo, TRUE /* transcode only */);

  /* Entropy encoding: either Huffman or arithmetic coding. */
  if (cinfo->arith_code) {
    ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
  } else {
    if (cinfo->progressive_mode) {
#ifdef C_PROGRESSIVE_SUPPORTED
      jinit_phuff_encoder(cinfo);
#else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
    } else
      jinit_huff_encoder(cinfo);
  }

  /* We need a special coefficient buffer controller. */
  transencode_coef_controller(cinfo, coef_arrays);

  jinit_marker_writer(cinfo);

  /* We can now tell the memory manager to allocate virtual arrays. */
  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);

  /* Write the datastream header (SOI) immediately.
   * Frame and scan headers are postponed till later.
   * This lets application insert special markers after the SOI.
   */
  (*cinfo->marker->write_file_header) (cinfo);
}


/*
 * The rest of this file is a special implementation of the coefficient
 * buffer controller.  This is similar to jccoefct.c, but it handles only
 * output from presupplied virtual arrays.  Furthermore, we generate any
 * dummy padding blocks on-the-fly rather than expecting them to be present
 * in the arrays.
 */

/* Private buffer controller object */

typedef struct {
  struct jpeg_c_coef_controller pub; /* public fields */

  JDIMENSION iMCU_row_num;	/* iMCU row # within image */
  JDIMENSION mcu_ctr;		/* counts MCUs processed in current row */
  int MCU_vert_offset;		/* counts MCU rows within iMCU row */
  int MCU_rows_per_iMCU_row;	/* number of such rows needed */

  /* Virtual block array for each component. */
  jvirt_barray_ptr * whole_image;

  /* Workspace for constructing dummy blocks at right/bottom edges. */
  JBLOCKROW dummy_buffer[C_MAX_BLOCKS_IN_MCU];
} my_coef_controller;

typedef my_coef_controller * my_coef_ptr;


LOCAL(void)
start_iMCU_row (j_compress_ptr cinfo)
/* Reset within-iMCU-row counters for a new row */
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;

  /* In an interleaved scan, an MCU row is the same as an iMCU row.
   * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
   * But at the bottom of the image, process only what's left.
   */
  if (cinfo->comps_in_scan > 1) {
    coef->MCU_rows_per_iMCU_row = 1;
  } else {
    if (coef->iMCU_row_num < (cinfo->total_iMCU_rows-1))
      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;
    else
      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;
  }

  coef->mcu_ctr = 0;
  coef->MCU_vert_offset = 0;
}


/*
 * Initialize for a processing pass.
 */

METHODDEF(void)
start_pass_coef (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;

  if (pass_mode != JBUF_CRANK_DEST)
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);

  coef->iMCU_row_num = 0;
  start_iMCU_row(cinfo);
}


/*
 * Process some data.
 * We process the equivalent of one fully interleaved MCU row ("iMCU" row)
 * per call, ie, v_samp_factor block rows for each component in the scan.
 * The data is obtained from the virtual arrays and fed to the entropy coder.
 * Returns TRUE if the iMCU row is completed, FALSE if suspended.
 *
 * NB: input_buf is ignored; it is likely to be a NULL pointer.
 */

METHODDEF(boolean)
compress_output (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  JDIMENSION MCU_col_num;	/* index of current MCU within row */
  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
  int blkn, ci, xindex, yindex, yoffset, blockcnt;
  JDIMENSION start_col;
  JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];
  JBLOCKROW MCU_buffer[C_MAX_BLOCKS_IN_MCU];
  JBLOCKROW buffer_ptr;
  jpeg_component_info *compptr;

  /* Align the virtual buffers for the components used in this scan. */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    compptr = cinfo->cur_comp_info[ci];
    buffer[ci] = (*cinfo->mem->access_virt_barray)
      ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],
       coef->iMCU_row_num * compptr->v_samp_factor,
       (JDIMENSION) compptr->v_samp_factor, FALSE);
  }

  /* Loop to process one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
       yoffset++) {
    for (MCU_col_num = coef->mcu_ctr; MCU_col_num < cinfo->MCUs_per_row;
	 MCU_col_num++) {
      /* Construct list of pointers to DCT blocks belonging to this MCU */
      blkn = 0;			/* index of current DCT block within MCU */
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
	compptr = cinfo->cur_comp_info[ci];
	start_col = MCU_col_num * compptr->MCU_width;
	blockcnt = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
						: compptr->last_col_width;
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
	  if (coef->iMCU_row_num < last_iMCU_row ||
	      yindex+yoffset < compptr->last_row_height) {
	    /* Fill in pointers to real blocks in this row */
	    buffer_ptr = buffer[ci][yindex+yoffset] + start_col;
	    for (xindex = 0; xindex < blockcnt; xindex++)
	      MCU_buffer[blkn++] = buffer_ptr++;
	  } else {
	    /* At bottom of image, need a whole row of dummy blocks */
	    xindex = 0;
	  }
	  /* Fill in any dummy blocks needed in this row.
	   * Dummy blocks are filled in the same way as in jccoefct.c:
	   * all zeroes in the AC entries, DC entries equal to previous
	   * block's DC value.  The init routine has already zeroed the
	   * AC entries, so we need only set the DC entries correctly.
	   */
	  for (; xindex < compptr->MCU_width; xindex++) {
	    MCU_buffer[blkn] = coef->dummy_buffer[blkn];
	    MCU_buffer[blkn][0][0] = MCU_buffer[blkn-1][0][0];
	    blkn++;
	  }
	}
      }
      /* Try to write the MCU. */
      if (! (*cinfo->entropy->encode_mcu) (cinfo, MCU_buffer)) {
	/* Suspension forced; update state counters and exit */
	coef->MCU_vert_offset = yoffset;
	coef->mcu_ctr = MCU_col_num;
	return FALSE;
      }
    }
    /* Completed an MCU row, but perhaps not an iMCU row */
    coef->mcu_ctr = 0;
  }
  /* Completed the iMCU row, advance counters for next one */
  coef->iMCU_row_num++;
  start_iMCU_row(cinfo);
  return TRUE;
}


/*
 * Initialize coefficient buffer controller.
 *
 * Each passed coefficient array must be the right size for that
 * coefficient: width_in_blocks wide and height_in_blocks high,
 * with unitheight at least v_samp_factor.
 */

LOCAL(void)
transencode_coef_controller (j_compress_ptr cinfo,
			     jvirt_barray_ptr * coef_arrays)
{
  my_coef_ptr coef;
  JBLOCKROW buffer;
  int i;

  coef = (my_coef_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_coef_controller));
  cinfo->coef = (struct jpeg_c_coef_controller *) coef;
  coef->pub.start_pass = start_pass_coef;
  coef->pub.compress_data = compress_output;

  /* Save pointer to virtual arrays */
  coef->whole_image = coef_arrays;

  /* Allocate and pre-zero space for dummy DCT blocks. */
  buffer = (JBLOCKROW)
    (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				C_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));
  jzero_far((void FAR *) buffer, C_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));
  for (i = 0; i < C_MAX_BLOCKS_IN_MCU; i++) {
    coef->dummy_buffer[i] = buffer + i;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\jdatadst.c ===
/*
 * jdatadst.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains compression data destination routines for the case of
 * emitting JPEG data to a file (or any stdio stream).  While these routines
 * are sufficient for most applications, some will want to use a different
 * destination manager.
 * IMPORTANT: we assume that fwrite() will correctly transcribe an array of
 * JOCTETs into 8-bit-wide elements on external storage.  If char is wider
 * than 8 bits on your machine, you may need to do some tweaking.
 */

/* this is not a core library module, so it doesn't define JPEG_INTERNALS */
#include "jinclude.h"
#include "jpeglib.h"
#include "jerror.h"


/* Expanded data destination object for stdio output */

typedef struct {
  struct jpeg_destination_mgr pub; /* public fields */

  FILE * outfile;		/* target stream */
  JOCTET * buffer;		/* start of buffer */
} my_destination_mgr;

typedef my_destination_mgr * my_dest_ptr;

#define OUTPUT_BUF_SIZE  4096	/* choose an efficiently fwrite'able size */


/*
 * Initialize destination --- called by jpeg_start_compress
 * before any data is actually written.
 */

METHODDEF(void)
init_destination (j_compress_ptr cinfo)
{
  my_dest_ptr dest = (my_dest_ptr) cinfo->dest;

  /* Allocate the output buffer --- it will be released when done with image */
  dest->buffer = (JOCTET *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  OUTPUT_BUF_SIZE * SIZEOF(JOCTET));

  dest->pub.next_output_byte = dest->buffer;
  dest->pub.free_in_buffer = OUTPUT_BUF_SIZE;
}


/*
 * Empty the output buffer --- called whenever buffer fills up.
 *
 * In typical applications, this should write the entire output buffer
 * (ignoring the current state of next_output_byte & free_in_buffer),
 * reset the pointer & count to the start of the buffer, and return TRUE
 * indicating that the buffer has been dumped.
 *
 * In applications that need to be able to suspend compression due to output
 * overrun, a FALSE return indicates that the buffer cannot be emptied now.
 * In this situation, the compressor will return to its caller (possibly with
 * an indication that it has not accepted all the supplied scanlines).  The
 * application should resume compression after it has made more room in the
 * output buffer.  Note that there are substantial restrictions on the use of
 * suspension --- see the documentation.
 *
 * When suspending, the compressor will back up to a convenient restart point
 * (typically the start of the current MCU). next_output_byte & free_in_buffer
 * indicate where the restart point will be if the current call returns FALSE.
 * Data beyond this point will be regenerated after resumption, so do not
 * write it out when emptying the buffer externally.
 */

METHODDEF(boolean)
empty_output_buffer (j_compress_ptr cinfo)
{
  my_dest_ptr dest = (my_dest_ptr) cinfo->dest;

  if (JFWRITE(dest->outfile, dest->buffer, OUTPUT_BUF_SIZE) !=
      (size_t) OUTPUT_BUF_SIZE)
    ERREXIT(cinfo, JERR_FILE_WRITE);

  dest->pub.next_output_byte = dest->buffer;
  dest->pub.free_in_buffer = OUTPUT_BUF_SIZE;

  return TRUE;
}


/*
 * Terminate destination --- called by jpeg_finish_compress
 * after all data has been written.  Usually needs to flush buffer.
 *
 * NB: *not* called by jpeg_abort or jpeg_destroy; surrounding
 * application must deal with any cleanup that should happen even
 * for error exit.
 */

METHODDEF(void)
term_destination (j_compress_ptr cinfo)
{
  my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
  size_t datacount = OUTPUT_BUF_SIZE - dest->pub.free_in_buffer;

  /* Write any data remaining in the buffer */
  if (datacount > 0) {
    if (JFWRITE(dest->outfile, dest->buffer, datacount) != datacount)
      ERREXIT(cinfo, JERR_FILE_WRITE);
  }
  fflush(dest->outfile);
  /* Make sure we wrote the output file OK */
  if (ferror(dest->outfile))
    ERREXIT(cinfo, JERR_FILE_WRITE);
}


/*
 * Prepare for output to a stdio stream.
 * The caller must have already opened the stream, and is responsible
 * for closing it after finishing compression.
 */

GLOBAL(void)
jpeg_stdio_dest (j_compress_ptr cinfo, FILE * outfile)
{
  my_dest_ptr dest;

  /* The destination object is made permanent so that multiple JPEG images
   * can be written to the same file without re-executing jpeg_stdio_dest.
   * This makes it dangerous to use this manager and a different destination
   * manager serially with the same JPEG object, because their private object
   * sizes may be different.  Caveat programmer.
   */
  if (cinfo->dest == NULL) {	/* first time for this JPEG object? */
    cinfo->dest = (struct jpeg_destination_mgr *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
				  SIZEOF(my_destination_mgr));
  }

  dest = (my_dest_ptr) cinfo->dest;
  dest->pub.init_destination = init_destination;
  dest->pub.empty_output_buffer = empty_output_buffer;
  dest->pub.term_destination = term_destination;
  dest->outfile = outfile;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\jdcoefct.c ===
/*
 * jdcoefct.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains the coefficient buffer controller for decompression.
 * This controller is the top level of the JPEG decompressor proper.
 * The coefficient buffer lies between entropy decoding and inverse-DCT steps.
 *
 * In buffered-image mode, this controller is the interface between
 * input-oriented processing and output-oriented processing.
 * Also, the input side (only) is used when reading a file for transcoding.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"

/* Block smoothing is only applicable for progressive JPEG, so: */
#ifndef D_PROGRESSIVE_SUPPORTED
#undef BLOCK_SMOOTHING_SUPPORTED
#endif

/* Private buffer controller object */

typedef struct {
  struct jpeg_d_coef_controller pub; /* public fields */

  /* These variables keep track of the current location of the input side. */
  /* cinfo->input_iMCU_row is also used for this. */
  JDIMENSION MCU_ctr;		/* counts MCUs processed in current row */
  int MCU_vert_offset;		/* counts MCU rows within iMCU row */
  int MCU_rows_per_iMCU_row;	/* number of such rows needed */

  /* The output side's location is represented by cinfo->output_iMCU_row. */

  /* In single-pass modes, it's sufficient to buffer just one MCU.
   * We allocate a workspace of D_MAX_BLOCKS_IN_MCU coefficient blocks,
   * and let the entropy decoder write into that workspace each time.
   * (On 80x86, the workspace is FAR even though it's not really very big;
   * this is to keep the module interfaces unchanged when a large coefficient
   * buffer is necessary.)
   * In multi-pass modes, this array points to the current MCU's blocks
   * within the virtual arrays; it is used only by the input side.
   */
  JBLOCKROW MCU_buffer[D_MAX_BLOCKS_IN_MCU];

#ifdef D_MULTISCAN_FILES_SUPPORTED
  /* In multi-pass modes, we need a virtual block array for each component. */
  jvirt_barray_ptr whole_image[MAX_COMPONENTS];
#endif

#ifdef BLOCK_SMOOTHING_SUPPORTED
  /* When doing block smoothing, we latch coefficient Al values here */
  int * coef_bits_latch;
#define SAVED_COEFS  6		/* we save coef_bits[0..5] */
#endif
} my_coef_controller;

typedef my_coef_controller * my_coef_ptr;

/* Forward declarations */
METHODDEF(int) decompress_onepass
	JPP((j_decompress_ptr cinfo, JSAMPIMAGE output_buf));
#ifdef D_MULTISCAN_FILES_SUPPORTED
METHODDEF(int) decompress_data
	JPP((j_decompress_ptr cinfo, JSAMPIMAGE output_buf));
#endif
#ifdef BLOCK_SMOOTHING_SUPPORTED
LOCAL(boolean) smoothing_ok JPP((j_decompress_ptr cinfo));
METHODDEF(int) decompress_smooth_data
	JPP((j_decompress_ptr cinfo, JSAMPIMAGE output_buf));
#endif


LOCAL(void)
start_iMCU_row (j_decompress_ptr cinfo)
/* Reset within-iMCU-row counters for a new row (input side) */
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;

  /* In an interleaved scan, an MCU row is the same as an iMCU row.
   * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
   * But at the bottom of the image, process only what's left.
   */
  if (cinfo->comps_in_scan > 1) {
    coef->MCU_rows_per_iMCU_row = 1;
  } else {
    if (cinfo->input_iMCU_row < (cinfo->total_iMCU_rows-1))
      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;
    else
      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;
  }

  coef->MCU_ctr = 0;
  coef->MCU_vert_offset = 0;
}


/*
 * Initialize for an input processing pass.
 */

METHODDEF(void)
start_input_pass (j_decompress_ptr cinfo)
{
  cinfo->input_iMCU_row = 0;
  start_iMCU_row(cinfo);
}


/*
 * Initialize for an output processing pass.
 */

METHODDEF(void)
start_output_pass (j_decompress_ptr cinfo)
{
#ifdef BLOCK_SMOOTHING_SUPPORTED
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;

  /* If multipass, check to see whether to use block smoothing on this pass */
  if (coef->pub.coef_arrays != NULL) {
    if (cinfo->do_block_smoothing && smoothing_ok(cinfo))
      coef->pub.decompress_data = decompress_smooth_data;
    else
      coef->pub.decompress_data = decompress_data;
  }
#endif
  cinfo->output_iMCU_row = 0;
}


/*
 * Decompress and return some data in the single-pass case.
 * Always attempts to emit one fully interleaved MCU row ("iMCU" row).
 * Input and output must run in lockstep since we have only a one-MCU buffer.
 * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
 *
 * NB: output_buf contains a plane for each component in image.
 * For single pass, this is the same as the components in the scan.
 */

METHODDEF(int)
decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  JDIMENSION MCU_col_num;	/* index of current MCU within row */
  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
  int blkn, ci, xindex, yindex, yoffset, useful_width;
  JSAMPARRAY output_ptr;
  JDIMENSION start_col, output_col;
  jpeg_component_info *compptr;
  inverse_DCT_method_ptr inverse_DCT;

  /* Loop to process as much as one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
       yoffset++) {
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;
	 MCU_col_num++) {
      /* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */
      jzero_far((void FAR *) coef->MCU_buffer[0],
		(size_t) (cinfo->blocks_in_MCU * SIZEOF(JBLOCK)));
      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
	/* Suspension forced; update state counters and exit */
	coef->MCU_vert_offset = yoffset;
	coef->MCU_ctr = MCU_col_num;
	return JPEG_SUSPENDED;
      }
      /* Determine where data should go in output_buf and do the IDCT thing.
       * We skip dummy blocks at the right and bottom edges (but blkn gets
       * incremented past them!).  Note the inner loop relies on having
       * allocated the MCU_buffer[] blocks sequentially.
       */
      blkn = 0;			/* index of current DCT block within MCU */
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
	compptr = cinfo->cur_comp_info[ci];
	/* Don't bother to IDCT an uninteresting component. */
	if (! compptr->component_needed) {
	  blkn += compptr->MCU_blocks;
	  continue;
	}
	inverse_DCT = cinfo->idct->inverse_DCT[compptr->component_index];
	useful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
						    : compptr->last_col_width;
	output_ptr = output_buf[ci] + yoffset * compptr->DCT_scaled_size;
	start_col = MCU_col_num * compptr->MCU_sample_width;
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
	  if (cinfo->input_iMCU_row < last_iMCU_row ||
	      yoffset+yindex < compptr->last_row_height) {
	    output_col = start_col;
	    for (xindex = 0; xindex < useful_width; xindex++) {
	      (*inverse_DCT) (cinfo, compptr,
			      (JCOEFPTR) coef->MCU_buffer[blkn+xindex],
			      output_ptr, output_col);
	      output_col += compptr->DCT_scaled_size;
	    }
	  }
	  blkn += compptr->MCU_width;
	  output_ptr += compptr->DCT_scaled_size;
	}
      }
    }
    /* Completed an MCU row, but perhaps not an iMCU row */
    coef->MCU_ctr = 0;
  }
  /* Completed the iMCU row, advance counters for next one */
  cinfo->output_iMCU_row++;
  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
    start_iMCU_row(cinfo);
    return JPEG_ROW_COMPLETED;
  }
  /* Completed the scan */
  (*cinfo->inputctl->finish_input_pass) (cinfo);
  return JPEG_SCAN_COMPLETED;
}


/*
 * Dummy consume-input routine for single-pass operation.
 */

METHODDEF(int)
dummy_consume_data (j_decompress_ptr cinfo)
{
  return JPEG_SUSPENDED;	/* Always indicate nothing was done */
}


#ifdef D_MULTISCAN_FILES_SUPPORTED

/*
 * Consume input data and store it in the full-image coefficient buffer.
 * We read as much as one fully interleaved MCU row ("iMCU" row) per call,
 * ie, v_samp_factor block rows for each component in the scan.
 * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
 */

METHODDEF(int)
consume_data (j_decompress_ptr cinfo)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  JDIMENSION MCU_col_num;	/* index of current MCU within row */
  int blkn, ci, xindex, yindex, yoffset;
  JDIMENSION start_col;
  JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];
  JBLOCKROW buffer_ptr;
  jpeg_component_info *compptr;

  /* Align the virtual buffers for the components used in this scan. */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    compptr = cinfo->cur_comp_info[ci];
    buffer[ci] = (*cinfo->mem->access_virt_barray)
      ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],
       cinfo->input_iMCU_row * compptr->v_samp_factor,
       (JDIMENSION) compptr->v_samp_factor, TRUE);
    /* Note: entropy decoder expects buffer to be zeroed,
     * but this is handled automatically by the memory manager
     * because we requested a pre-zeroed array.
     */
  }

  /* Loop to process one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
       yoffset++) {
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;
	 MCU_col_num++) {
      /* Construct list of pointers to DCT blocks belonging to this MCU */
      blkn = 0;			/* index of current DCT block within MCU */
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
	compptr = cinfo->cur_comp_info[ci];
	start_col = MCU_col_num * compptr->MCU_width;
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
	  buffer_ptr = buffer[ci][yindex+yoffset] + start_col;
	  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {
	    coef->MCU_buffer[blkn++] = buffer_ptr++;
	  }
	}
      }
      /* Try to fetch the MCU. */
      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
	/* Suspension forced; update state counters and exit */
	coef->MCU_vert_offset = yoffset;
	coef->MCU_ctr = MCU_col_num;
	return JPEG_SUSPENDED;
      }
    }
    /* Completed an MCU row, but perhaps not an iMCU row */
    coef->MCU_ctr = 0;
  }
  /* Completed the iMCU row, advance counters for next one */
  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
    start_iMCU_row(cinfo);
    return JPEG_ROW_COMPLETED;
  }
  /* Completed the scan */
  (*cinfo->inputctl->finish_input_pass) (cinfo);
  return JPEG_SCAN_COMPLETED;
}


/*
 * Decompress and return some data in the multi-pass case.
 * Always attempts to emit one fully interleaved MCU row ("iMCU" row).
 * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
 *
 * NB: output_buf contains a plane for each component in image.
 */

METHODDEF(int)
decompress_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
  JDIMENSION block_num;
  int ci, block_row, block_rows;
  JBLOCKARRAY buffer;
  JBLOCKROW buffer_ptr;
  JSAMPARRAY output_ptr;
  JDIMENSION output_col;
  jpeg_component_info *compptr;
  inverse_DCT_method_ptr inverse_DCT;

  /* Force some input to be done if we are getting ahead of the input. */
  while (cinfo->input_scan_number < cinfo->output_scan_number ||
	 (cinfo->input_scan_number == cinfo->output_scan_number &&
	  cinfo->input_iMCU_row <= cinfo->output_iMCU_row)) {
    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
      return JPEG_SUSPENDED;
  }

  /* OK, output from the virtual arrays. */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Don't bother to IDCT an uninteresting component. */
    if (! compptr->component_needed)
      continue;
    /* Align the virtual buffer for this component. */
    buffer = (*cinfo->mem->access_virt_barray)
      ((j_common_ptr) cinfo, coef->whole_image[ci],
       cinfo->output_iMCU_row * compptr->v_samp_factor,
       (JDIMENSION) compptr->v_samp_factor, FALSE);
    /* Count non-dummy DCT block rows in this iMCU row. */
    if (cinfo->output_iMCU_row < last_iMCU_row)
      block_rows = compptr->v_samp_factor;
    else {
      /* NB: can't use last_row_height here; it is input-side-dependent! */
      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
      if (block_rows == 0) block_rows = compptr->v_samp_factor;
    }
    inverse_DCT = cinfo->idct->inverse_DCT[ci];
    output_ptr = output_buf[ci];
    /* Loop over all DCT blocks to be processed. */
    for (block_row = 0; block_row < block_rows; block_row++) {
      buffer_ptr = buffer[block_row];
      output_col = 0;
      for (block_num = 0; block_num < compptr->width_in_blocks; block_num++) {
	(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) buffer_ptr,
			output_ptr, output_col);
	buffer_ptr++;
	output_col += compptr->DCT_scaled_size;
      }
      output_ptr += compptr->DCT_scaled_size;
    }
  }

  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)
    return JPEG_ROW_COMPLETED;
  return JPEG_SCAN_COMPLETED;
}

#endif /* D_MULTISCAN_FILES_SUPPORTED */


#ifdef BLOCK_SMOOTHING_SUPPORTED

/*
 * This code applies interblock smoothing as described by section K.8
 * of the JPEG standard: the first 5 AC coefficients are estimated from
 * the DC values of a DCT block and its 8 neighboring blocks.
 * We apply smoothing only for progressive JPEG decoding, and only if
 * the coefficients it can estimate are not yet known to full precision.
 */

/* Natural-order array positions of the first 5 zigzag-order coefficients */
#define Q01_POS  1
#define Q10_POS  8
#define Q20_POS  16
#define Q11_POS  9
#define Q02_POS  2

/*
 * Determine whether block smoothing is applicable and safe.
 * We also latch the current states of the coef_bits[] entries for the
 * AC coefficients; otherwise, if the input side of the decompressor
 * advances into a new scan, we might think the coefficients are known
 * more accurately than they really are.
 */

LOCAL(boolean)
smoothing_ok (j_decompress_ptr cinfo)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  boolean smoothing_useful = FALSE;
  int ci, coefi;
  jpeg_component_info *compptr;
  JQUANT_TBL * qtable;
  int * coef_bits;
  int * coef_bits_latch;

  if (! cinfo->progressive_mode || cinfo->coef_bits == NULL)
    return FALSE;

  /* Allocate latch area if not already done */
  if (coef->coef_bits_latch == NULL)
    coef->coef_bits_latch = (int *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  cinfo->num_components *
				  (SAVED_COEFS * SIZEOF(int)));
  coef_bits_latch = coef->coef_bits_latch;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* All components' quantization values must already be latched. */
    if ((qtable = compptr->quant_table) == NULL)
      return FALSE;
    /* Verify DC & first 5 AC quantizers are nonzero to avoid zero-divide. */
    if (qtable->quantval[0] == 0 ||
	qtable->quantval[Q01_POS] == 0 ||
	qtable->quantval[Q10_POS] == 0 ||
	qtable->quantval[Q20_POS] == 0 ||
	qtable->quantval[Q11_POS] == 0 ||
	qtable->quantval[Q02_POS] == 0)
      return FALSE;
    /* DC values must be at least partly known for all components. */
    coef_bits = cinfo->coef_bits[ci];
    if (coef_bits[0] < 0)
      return FALSE;
    /* Block smoothing is helpful if some AC coefficients remain inaccurate. */
    for (coefi = 1; coefi <= 5; coefi++) {
      coef_bits_latch[coefi] = coef_bits[coefi];
      if (coef_bits[coefi] != 0)
	smoothing_useful = TRUE;
    }
    coef_bits_latch += SAVED_COEFS;
  }

  return smoothing_useful;
}


/*
 * Variant of decompress_data for use when doing block smoothing.
 */

METHODDEF(int)
decompress_smooth_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
  JDIMENSION block_num, last_block_column;
  int ci, block_row, block_rows, access_rows;
  JBLOCKARRAY buffer;
  JBLOCKROW buffer_ptr, prev_block_row, next_block_row;
  JSAMPARRAY output_ptr;
  JDIMENSION output_col;
  jpeg_component_info *compptr;
  inverse_DCT_method_ptr inverse_DCT;
  boolean first_row, last_row;
  JBLOCK workspace;
  int *coef_bits;
  JQUANT_TBL *quanttbl;
  INT32 Q00,Q01,Q02,Q10,Q11,Q20, num;
  int DC1,DC2,DC3,DC4,DC5,DC6,DC7,DC8,DC9;
  int Al, pred;

  /* Force some input to be done if we are getting ahead of the input. */
  while (cinfo->input_scan_number <= cinfo->output_scan_number &&
	 ! cinfo->inputctl->eoi_reached) {
    if (cinfo->input_scan_number == cinfo->output_scan_number) {
      /* If input is working on current scan, we ordinarily want it to
       * have completed the current row.  But if input scan is DC,
       * we want it to keep one row ahead so that next block row's DC
       * values are up to date.
       */
      JDIMENSION delta = (cinfo->Ss == 0) ? 1 : 0;
      if (cinfo->input_iMCU_row > cinfo->output_iMCU_row+delta)
	break;
    }
    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
      return JPEG_SUSPENDED;
  }

  /* OK, output from the virtual arrays. */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Don't bother to IDCT an uninteresting component. */
    if (! compptr->component_needed)
      continue;
    /* Count non-dummy DCT block rows in this iMCU row. */
    if (cinfo->output_iMCU_row < last_iMCU_row) {
      block_rows = compptr->v_samp_factor;
      access_rows = block_rows * 2; /* this and next iMCU row */
      last_row = FALSE;
    } else {
      /* NB: can't use last_row_height here; it is input-side-dependent! */
      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
      if (block_rows == 0) block_rows = compptr->v_samp_factor;
      access_rows = block_rows; /* this iMCU row only */
      last_row = TRUE;
    }
    /* Align the virtual buffer for this component. */
    if (cinfo->output_iMCU_row > 0) {
      access_rows += compptr->v_samp_factor; /* prior iMCU row too */
      buffer = (*cinfo->mem->access_virt_barray)
	((j_common_ptr) cinfo, coef->whole_image[ci],
	 (cinfo->output_iMCU_row - 1) * compptr->v_samp_factor,
	 (JDIMENSION) access_rows, FALSE);
      buffer += compptr->v_samp_factor;	/* point to current iMCU row */
      first_row = FALSE;
    } else {
      buffer = (*cinfo->mem->access_virt_barray)
	((j_common_ptr) cinfo, coef->whole_image[ci],
	 (JDIMENSION) 0, (JDIMENSION) access_rows, FALSE);
      first_row = TRUE;
    }
    /* Fetch component-dependent info */
    coef_bits = coef->coef_bits_latch + (ci * SAVED_COEFS);
    quanttbl = compptr->quant_table;
    Q00 = quanttbl->quantval[0];
    Q01 = quanttbl->quantval[Q01_POS];
    Q10 = quanttbl->quantval[Q10_POS];
    Q20 = quanttbl->quantval[Q20_POS];
    Q11 = quanttbl->quantval[Q11_POS];
    Q02 = quanttbl->quantval[Q02_POS];
    inverse_DCT = cinfo->idct->inverse_DCT[ci];
    output_ptr = output_buf[ci];
    /* Loop over all DCT blocks to be processed. */
    for (block_row = 0; block_row < block_rows; block_row++) {
      buffer_ptr = buffer[block_row];
      if (first_row && block_row == 0)
	prev_block_row = buffer_ptr;
      else
	prev_block_row = buffer[block_row-1];
      if (last_row && block_row == block_rows-1)
	next_block_row = buffer_ptr;
      else
	next_block_row = buffer[block_row+1];
      /* We fetch the surrounding DC values using a sliding-register approach.
       * Initialize all nine here so as to do the right thing on narrow pics.
       */
      DC1 = DC2 = DC3 = (int) prev_block_row[0][0];
      DC4 = DC5 = DC6 = (int) buffer_ptr[0][0];
      DC7 = DC8 = DC9 = (int) next_block_row[0][0];
      output_col = 0;
      last_block_column = compptr->width_in_blocks - 1;
      for (block_num = 0; block_num <= last_block_column; block_num++) {
	/* Fetch current DCT block into workspace so we can modify it. */
	jcopy_block_row(buffer_ptr, (JBLOCKROW) workspace, (JDIMENSION) 1);
	/* Update DC values */
	if (block_num < last_block_column) {
	  DC3 = (int) prev_block_row[1][0];
	  DC6 = (int) buffer_ptr[1][0];
	  DC9 = (int) next_block_row[1][0];
	}
	/* Compute coefficient estimates per K.8.
	 * An estimate is applied only if coefficient is still zero,
	 * and is not known to be fully accurate.
	 */
	/* AC01 */
	if ((Al=coef_bits[1]) != 0 && workspace[1] == 0) {
	  num = 36 * Q00 * (DC4 - DC6);
	  if (num >= 0) {
	    pred = (int) (((Q01<<7) + num) / (Q01<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	  } else {
	    pred = (int) (((Q01<<7) - num) / (Q01<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	    pred = -pred;
	  }
	  workspace[1] = (JCOEF) pred;
	}
	/* AC10 */
	if ((Al=coef_bits[2]) != 0 && workspace[8] == 0) {
	  num = 36 * Q00 * (DC2 - DC8);
	  if (num >= 0) {
	    pred = (int) (((Q10<<7) + num) / (Q10<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	  } else {
	    pred = (int) (((Q10<<7) - num) / (Q10<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	    pred = -pred;
	  }
	  workspace[8] = (JCOEF) pred;
	}
	/* AC20 */
	if ((Al=coef_bits[3]) != 0 && workspace[16] == 0) {
	  num = 9 * Q00 * (DC2 + DC8 - 2*DC5);
	  if (num >= 0) {
	    pred = (int) (((Q20<<7) + num) / (Q20<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	  } else {
	    pred = (int) (((Q20<<7) - num) / (Q20<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	    pred = -pred;
	  }
	  workspace[16] = (JCOEF) pred;
	}
	/* AC11 */
	if ((Al=coef_bits[4]) != 0 && workspace[9] == 0) {
	  num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);
	  if (num >= 0) {
	    pred = (int) (((Q11<<7) + num) / (Q11<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	  } else {
	    pred = (int) (((Q11<<7) - num) / (Q11<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	    pred = -pred;
	  }
	  workspace[9] = (JCOEF) pred;
	}
	/* AC02 */
	if ((Al=coef_bits[5]) != 0 && workspace[2] == 0) {
	  num = 9 * Q00 * (DC4 + DC6 - 2*DC5);
	  if (num >= 0) {
	    pred = (int) (((Q02<<7) + num) / (Q02<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	  } else {
	    pred = (int) (((Q02<<7) - num) / (Q02<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	    pred = -pred;
	  }
	  workspace[2] = (JCOEF) pred;
	}
	/* OK, do the IDCT */
	(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) workspace,
			output_ptr, output_col);
	/* Advance for next column */
	DC1 = DC2; DC2 = DC3;
	DC4 = DC5; DC5 = DC6;
	DC7 = DC8; DC8 = DC9;
	buffer_ptr++, prev_block_row++, next_block_row++;
	output_col += compptr->DCT_scaled_size;
      }
      output_ptr += compptr->DCT_scaled_size;
    }
  }

  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)
    return JPEG_ROW_COMPLETED;
  return JPEG_SCAN_COMPLETED;
}

#endif /* BLOCK_SMOOTHING_SUPPORTED */


/*
 * Initialize coefficient buffer controller.
 */

GLOBAL(void)
jinit_d_coef_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
{
  my_coef_ptr coef;

  coef = (my_coef_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_coef_controller));
  cinfo->coef = (struct jpeg_d_coef_controller *) coef;
  coef->pub.start_input_pass = start_input_pass;
  coef->pub.start_output_pass = start_output_pass;
#ifdef BLOCK_SMOOTHING_SUPPORTED
  coef->coef_bits_latch = NULL;
#endif

  /* Create the coefficient buffer. */
  if (need_full_buffer) {
#ifdef D_MULTISCAN_FILES_SUPPORTED
    /* Allocate a full-image virtual array for each component, */
    /* padded to a multiple of samp_factor DCT blocks in each direction. */
    /* Note we ask for a pre-zeroed array. */
    int ci, access_rows;
    jpeg_component_info *compptr;

    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
	 ci++, compptr++) {
      access_rows = compptr->v_samp_factor;
#ifdef BLOCK_SMOOTHING_SUPPORTED
      /* If block smoothing could be used, need a bigger window */
      if (cinfo->progressive_mode)
	access_rows *= 3;
#endif
      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
	((j_common_ptr) cinfo, JPOOL_IMAGE, TRUE,
	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
				(long) compptr->h_samp_factor),
	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
				(long) compptr->v_samp_factor),
	 (JDIMENSION) access_rows);
    }
    coef->pub.consume_data = consume_data;
    coef->pub.decompress_data = decompress_data;
    coef->pub.coef_arrays = coef->whole_image; /* link to virtual arrays */
#else
    ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
  } else {
    /* We only need a single-MCU buffer. */
    JBLOCKROW buffer;
    int i;

    buffer = (JBLOCKROW)
      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  D_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));
    for (i = 0; i < D_MAX_BLOCKS_IN_MCU; i++) {
      coef->MCU_buffer[i] = buffer + i;
    }
    coef->pub.consume_data = dummy_consume_data;
    coef->pub.decompress_data = decompress_onepass;
    coef->pub.coef_arrays = NULL; /* flag for no virtual arrays */
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\jpeglib\jdatasrc.c ===
/*
 * jdatasrc.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains decompression data source routines for the case of
 * reading JPEG data from a file (or any stdio stream).  While these routines
 * are sufficient for most applications, some will want to use a different
 * source manager.
 * IMPORTANT: we assume that fread() will correctly transcribe an array of
 * JOCTETs from 8-bit-wide elements on external storage.  If char is wider
 * than 8 bits on your machine, you may need to do some tweaking.
 */

/* this is not a core library module, so it doesn't define JPEG_INTERNALS */
#include "jinclude.h"
#include "jpeglib.h"
#include "jerror.h"


/* Expanded data source object for stdio input */

typedef struct {
  struct jpeg_source_mgr pub;	/* public fields */

  FILE * infile;		/* source stream */
  JOCTET * buffer;		/* start of buffer */
  boolean start_of_file;	/* have we gotten any data yet? */
} my_source_mgr;

typedef my_source_mgr * my_src_ptr;

#define INPUT_BUF_SIZE  4096	/* choose an efficiently fread'able size */


/*
 * Initialize source --- called by jpeg_read_header
 * before any data is actually read.
 */

METHODDEF(void)
init_source (j_decompress_ptr cinfo)
{
  my_src_ptr src = (my_src_ptr) cinfo->src;

  /* We reset the empty-input-file flag for each image,
   * but we don't clear the input buffer.
   * This is correct behavior for reading a series of images from one source.
   */
  src->start_of_file = TRUE;
}


/*
 * Fill the input buffer --- called whenever buffer is emptied.
 *
 * In typical applications, this should read fresh data into the buffer
 * (ignoring the current state of next_input_byte & bytes_in_buffer),
 * reset the pointer & count to the start of the buffer, and return TRUE
 * indicating that the buffer has been reloaded.  It is not necessary to
 * fill the buffer entirely, only to obtain at least one more byte.
 *
 * There is no such thing as an EOF return.  If the end of the file has been
 * reached, the routine has a choice of ERREXIT() or inserting fake data into
 * the buffer.  In most cases, generating a warning message and inserting a
 * fake EOI marker is the best course of action --- this will allow the
 * decompressor to output however much of the image is there.  However,
 * the resulting error message is misleading if the real problem is an empty
 * input file, so we handle that case specially.
 *
 * In applications that need to be able to suspend compression due to input
 * not being available yet, a FALSE return indicates that no more data can be
 * obtained right now, but more may be forthcoming later.  In this situation,
 * the decompressor will return to its caller (with an indication of the
 * number of scanlines it has read, if any).  The application should resume
 * decompression after it has loaded more data into the input buffer.  Note
 * that there are substantial restrictions on the use of suspension --- see
 * the documentation.
 *
 * When suspending, the decompressor will back up to a convenient restart point
 * (typically the start of the current MCU). next_input_byte & bytes_in_buffer
 * indicate where the restart point will be if the current call returns FALSE.
 * Data beyond this point must be rescanned after resumption, so move it to
 * the front of the buffer rather than discarding it.
 */

METHODDEF(boolean)
fill_input_buffer (j_decompress_ptr cinfo)
{
  my_src_ptr src = (my_src_ptr) cinfo->src;
  size_t nbytes;

  nbytes = JFREAD(src->infile, src->buffer, INPUT_BUF_SIZE);

  if (nbytes <= 0) {
    if (src->start_of_file)	/* Treat empty input file as fatal error */
      ERREXIT(cinfo, JERR_INPUT_EMPTY);
    WARNMS(cinfo, JWRN_JPEG_EOF);
    /* Insert a fake EOI marker */
    src->buffer[0] = (JOCTET) 0xFF;
    src->buffer[1] = (JOCTET) JPEG_EOI;
    nbytes = 2;
  }

  src->pub.next_input_byte = src->buffer;
  src->pub.bytes_in_buffer = nbytes;
  src->start_of_file = FALSE;

  return TRUE;
}


/*
 * Skip data --- used to skip over a potentially large amount of
 * uninteresting data (such as an APPn marker).
 *
 * Writers of suspendable-input applications must note that skip_input_data
 * is not granted the right to give a suspension return.  If the skip extends
 * beyond the data currently in the buffer, the buffer can be marked empty so
 * that the next read will cause a fill_input_buffer call that can suspend.
 * Arranging for additional bytes to be discarded before reloading the input
 * buffer is the application writer's problem.
 */

METHODDEF(void)
skip_input_data (j_decompress_ptr cinfo, long num_bytes)
{
  my_src_ptr src = (my_src_ptr) cinfo->src;

  /* Just a dumb implementation for now.  Could use fseek() except
   * it doesn't work on pipes.  Not clear that being smart is worth
   * any trouble anyway --- large skips are infrequent.
   */
  if (num_bytes > 0) {
    while (num_bytes > (long) src->pub.bytes_in_buffer) {
      num_bytes -= (long) src->pub.bytes_in_buffer;
      (void) fill_input_buffer(cinfo);
      /* note we assume that fill_input_buffer will never return FALSE,
       * so suspension need not be handled.
       */
    }
    src->pub.next_input_byte += (size_t) num_bytes;
    src->pub.bytes_in_buffer -= (size_t) num_bytes;
  }
}


/*
 * An additional method that can be provided by data source modules is the
 * resync_to_restart method for error recovery in the presence of RST markers.
 * For the moment, this source module just uses the default resync method
 * provided by the JPEG library.  That method assumes that no backt