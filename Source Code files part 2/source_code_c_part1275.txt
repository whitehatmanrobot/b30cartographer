   ajrc[1].cbData = sizeof(achColName);
    ajrc[1].itagSequence = 1;

    jtid = jcl.tableid;

    je = JetMove(jsid, jtid, JET_MoveFirst, 0);

    colCount = 0;
    do {

        memset(achColName, 0, sizeof(achColName));
        je = JetRetrieveColumns(jsid, jtid, ajrc, 2);
        if (strncmp(achColName,"ATT",3)) {
            // not an att column
            continue;
        }

        // It is an ATT column
        colCount++;

        // Hash tables too small, reallocate them
        if (2*colCount > ATTCOUNT) {

            err = SCResizeAttHash(pTHS, colCount);
            if (err) {
                return (err);
            }

            // refresh locals thay may have been altered by SCResizeAttHash
            ATTCOUNT = pSch->ATTCOUNT;
            ahcId    = pSch->ahcId;
            ahcCol   = pSch->ahcCol;
        }

        // Fill in the skeleton attcache entry

        aid = atoi(&achColName[4]);
        if (SCCalloc(&pac, 1, sizeof(ATTCACHE))) {
            return ERROR_DS_CANT_CACHE_ATT;
        }
        pac->id = aid;

        pac->jColid = jci;
        pac->syntax = achColName[3] - 'a';

        // add to id cache
        for (i=SChash(aid,ATTCOUNT);
             ahcId[i].pVal && (ahcId[i].pVal != FREE_ENTRY) ; i=(i+1)%ATTCOUNT){
        }
        ahcId[i].hKey = aid;
        ahcId[i].pVal = pac;

        // add to col cache
        for (i=SChash(jci,ATTCOUNT);
             ahcCol[i].pVal && (ahcCol[i].pVal != FREE_ENTRY); i=(i+1)%ATTCOUNT){
        }
        ahcCol[i].hKey = jci;
        ahcCol[i].pVal = pac;


        if (eServiceShutdown) {
            JetCloseTable(jsid, jtid);
            return 0;
        }

    } while ((je = JetMove(jsid, jtid, JET_MoveNext, 0)) == 0);

    je = JetCloseTable(jsid, jtid);

    // In newer builds, we fixed a bug such that we no longer create
    // columns for linked and constructed atts. So the following
    // attributes will no longer be in the cache at this stage.
    // However, they are needed since RebuildCatalog needs them before
    // the cache is built from the schemaNC. So we add them here now
    // as if they had a column, the rest of the information will be
    // filled up later by SCCacheSchema2
    //
    // Note that the SCGetAttById check is needed for the case
    // when the new binary is put on the old dit (which still has the columns
    // and so will have the attcaches at this stage. The columns will be
    // deleted in SCCacheSChema3 in the second schema cache load after a boot
    //
    // The above comments apply to pre-w2k DITs
    //
    {
        struct _MissingLinkIds {
            ATTRTYP aid;
            int syntaxId;
            ULONG linkId;
        } *pMissingLinkIds, aMissingLinkIds[] = {
            { ATT_HAS_MASTER_NCS, SYNTAX_ID_HAS_MASTER_NCS, 76 },
            { ATT_HAS_PARTIAL_REPLICA_NCS, SYNTAX_ID_HAS_PARTIAL_REPLICA_NCS, 74 },
            { ATT_MS_DS_SD_REFERENCE_DOMAIN, SYNTAX_ID_MS_DS_SD_REFERENCE_DOMAIN, 2000 },
            { INVALID_ATT }
        };

        for (pMissingLinkIds = aMissingLinkIds;
             pMissingLinkIds->aid != INVALID_ATT; ++pMissingLinkIds) {

            // If no column exists (shouldn't except on very, very
            // old DITs) allocate a new pac and add to id hash
            if (NULL == (pac = SCGetAttById(pTHS, pMissingLinkIds->aid))) {
                if (SCCalloc(&pac, 1, sizeof(ATTCACHE))) {
                    return ERROR_DS_CANT_CACHE_ATT;
                }
                for (i=SChash(pMissingLinkIds->aid,ATTCOUNT);
                    ahcId[i].pVal && (ahcId[i].pVal != FREE_ENTRY) ; i=(i+1)%ATTCOUNT){
                }
                ahcId[i].hKey = pMissingLinkIds->aid;
                ahcId[i].pVal = pac;
            }
            // Hammer the pac entry to its correct values
            pac->id = pMissingLinkIds->aid;
            pac->syntax = pMissingLinkIds->syntaxId;
            pac->ulLinkID = pMissingLinkIds->linkId;
        }
    }

    Assert(SCGetAttById(pTHS, ATT_HAS_MASTER_NCS)
           && SCGetAttById(pTHS, ATT_HAS_PARTIAL_REPLICA_NCS)
           && SCGetAttById(pTHS, ATT_MS_DS_SD_REFERENCE_DOMAIN));

    ++iSCstage;
    return(0);
}


// We will keep two lists of attributes of an attribute-schema or
// class-schema object to search - one for the regular cache load case
// here we are interested in caching nearly all attributes, and one
// for the validation-cache building case during schema updates, where
// we need to read only a subset that we will use in validation

// The list of attributes of an ATTRIBUTE object that we need to cache

//Regular case

ATTR AttributeSelList[] = {
    { ATT_SYSTEM_ONLY, {0, NULL}},
    { ATT_IS_SINGLE_VALUED, {0, NULL}},
    { ATT_RANGE_LOWER, {0, NULL}},
    { ATT_RANGE_UPPER, {0, NULL}},
    { ATT_ATTRIBUTE_ID, {0, NULL}},
    { ATT_LDAP_DISPLAY_NAME, {0, NULL}},
    { ATT_ATTRIBUTE_SYNTAX, {0, NULL}},
    { ATT_OM_SYNTAX, {0, NULL}},
    { ATT_OM_OBJECT_CLASS, {0, NULL}},
    { ATT_MAPI_ID, {0, NULL}},
    { ATT_LINK_ID, {0, NULL}},
    { ATT_SEARCH_FLAGS, {0, NULL}},
    { ATT_ATTRIBUTE_SECURITY_GUID, {0, NULL}},
    { ATT_SCHEMA_ID_GUID, {0, NULL}},
    { ATT_EXTENDED_CHARS_ALLOWED, {0, NULL}},
    { ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET, {0, NULL}},
    { ATT_IS_DEFUNCT, {0, NULL}},
    { ATT_SYSTEM_FLAGS, {0, NULL}},
    { ATT_MS_DS_INTID, {0, NULL}},
    { ATT_OBJECT_GUID, {0, NULL}}
};
#define NUMATTATT  sizeof(AttributeSelList)/sizeof(ATTR)

// Validation cache building case

ATTR RecalcSchAttributeSelList[] = {
    { ATT_RANGE_LOWER, {0, NULL}},
    { ATT_RANGE_UPPER, {0, NULL}},
    { ATT_ATTRIBUTE_ID, {0, NULL}},
    { ATT_LDAP_DISPLAY_NAME, {0, NULL}},
    { ATT_ATTRIBUTE_SYNTAX, {0, NULL}},
    { ATT_OM_SYNTAX, {0, NULL}},
    { ATT_OM_OBJECT_CLASS, {0, NULL}},
    { ATT_MAPI_ID, {0, NULL}},
    { ATT_LINK_ID, {0, NULL}},
    { ATT_SEARCH_FLAGS, {0, NULL}},
    { ATT_SCHEMA_ID_GUID, {0, NULL}},
    { ATT_IS_DEFUNCT, {0, NULL}},
    { ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET, {0, NULL}},
    { ATT_SYSTEM_FLAGS, {0, NULL}},
    { ATT_MS_DS_INTID, {0, NULL}},
    { ATT_OBJECT_GUID, {0, NULL}}
};
#define RECALCSCHNUMATTATT  sizeof(RecalcSchAttributeSelList)/sizeof(ATTR)


// The list of attributes of an CLASS object that we need to cache

// Regular Case

ATTR ClassSelList[] = {
    { ATT_SYSTEM_ONLY, {0, NULL}},
    { ATT_DEFAULT_SECURITY_DESCRIPTOR, {0, NULL}},
    { ATT_GOVERNS_ID, {0, NULL}},
    { ATT_MAY_CONTAIN, {0, NULL}},
    { ATT_MUST_CONTAIN, {0, NULL}},
    { ATT_SUB_CLASS_OF, {0, NULL}},
    { ATT_LDAP_DISPLAY_NAME, {0, NULL}},
    { ATT_RDN_ATT_ID, {0, NULL}},
    { ATT_POSS_SUPERIORS, {0, NULL}},
    { ATT_AUXILIARY_CLASS, {0, NULL}},
    { ATT_OBJECT_CLASS_CATEGORY, {0, NULL}},
    { ATT_SYSTEM_AUXILIARY_CLASS, {0, NULL}},
    { ATT_SYSTEM_MUST_CONTAIN, {0, NULL}},
    { ATT_SYSTEM_MAY_CONTAIN, {0, NULL}},
    { ATT_SCHEMA_ID_GUID, {0, NULL}},
    { ATT_SYSTEM_POSS_SUPERIORS, {0, NULL}},
    { ATT_DEFAULT_HIDING_VALUE, {0, NULL}},
    { ATT_IS_DEFUNCT, {0, NULL}},
    { ATT_DEFAULT_OBJECT_CATEGORY, {0, NULL}},
    { ATT_SYSTEM_FLAGS, {0, NULL}},
    { ATT_OBJECT_GUID, {0, NULL}}
};
#define NUMCLASSATT  sizeof(ClassSelList)/sizeof(ATTR)

// Validation cache building case

ATTR RecalcSchClassSelList[] = {
    { ATT_GOVERNS_ID, {0, NULL}},
    { ATT_MAY_CONTAIN, {0, NULL}},
    { ATT_MUST_CONTAIN, {0, NULL}},
    { ATT_SUB_CLASS_OF, {0, NULL}},
    { ATT_LDAP_DISPLAY_NAME, {0, NULL}},
    { ATT_RDN_ATT_ID, {0, NULL}},
    { ATT_POSS_SUPERIORS, {0, NULL}},
    { ATT_AUXILIARY_CLASS, {0, NULL}},
    { ATT_OBJECT_CLASS_CATEGORY, {0, NULL}},
    { ATT_SYSTEM_AUXILIARY_CLASS, {0, NULL}},
    { ATT_SYSTEM_MUST_CONTAIN, {0, NULL}},
    { ATT_SYSTEM_MAY_CONTAIN, {0, NULL}},
    { ATT_SCHEMA_ID_GUID, {0, NULL}},
    { ATT_SYSTEM_POSS_SUPERIORS, {0, NULL}},
    { ATT_IS_DEFUNCT, {0, NULL}},
    { ATT_SYSTEM_FLAGS, {0, NULL}},
    { ATT_OBJECT_GUID, {0, NULL}}
};
#define RECALCSCHNUMCLASSATT  sizeof(RecalcSchClassSelList)/sizeof(ATTR)


VOID
scAcquireSearchParameters(
    IN THSTATE *pTHS,
    IN DSNAME *pDnObjCat,
    IN ENTINFSEL *pSel,
    IN OUT SEARCHARG *pSearchArg,
    IN OUT FILTER *pFilter,
    OUT SEARCHRES **ppSearchRes
)

/*++
   Initialize search arguments, filters etc. for schema cache search

   Arguments:
      pTHS -- thread state
      pDnObjCat -- pointer to Dsname with object-category to put in filter
      pSel -- pointer to attribute selection list
      pSearchArg -- SearchArg to fill up
      pFilter -- filter to fill up
      ppSearchRes -- to allocate and initialize searchres. Free with
                     ReleaseSearchParamters.
--*/
{

    SEARCHRES *pSearchRes = NULL;

    // build search argument
    memset(pSearchArg, 0, sizeof(SEARCHARG));
    pSearchArg->pObject = gAnchor.pDMD;
    pSearchArg->choice = SE_CHOICE_IMMED_CHLDRN;
    pSearchArg->pFilter = pFilter;
    pSearchArg->searchAliases = FALSE;
    pSearchArg->pSelection = pSel;

    // Build Commarg
    InitCommarg(&(pSearchArg->CommArg));

    // build filter
    memset(pFilter, 0, sizeof(FILTER));
    pFilter->pNextFilter = (FILTER FAR *)NULL;
    pFilter->choice = FILTER_CHOICE_ITEM;
    pFilter->FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    pFilter->FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
    pFilter->FilterTypes.Item.FilTypes.ava.Value.valLen = pDnObjCat->structLen;
    pFilter->FilterTypes.Item.FilTypes.ava.Value.pVal = (PCHAR) pDnObjCat;

    // allocate space for search res
    pSearchRes = (SEARCHRES *)THAllocEx(pTHS, sizeof(SEARCHRES));
    pSearchRes->CommRes.aliasDeref = FALSE;   //Initialize to Default
    *ppSearchRes = pSearchRes;
}

VOID
scReleaseSearchParameters(
    IN THSTATE *pTHS,
    IN OUT SEARCHRES **ppSearchRes
)

/*++
   Free resources allocated by scAcquireSearchParameters
--*/
{
    if (*ppSearchRes) {
        THFreeEx(pTHS, *ppSearchRes);
        *ppSearchRes = NULL;
    }
}

VOID 
scFixCollisions(
    IN THSTATE *pTHS
    )
/*++

Routine Description:

    Treat dups as defunct in the schema-reuse sense of defunct. Schema-
    reuse handles collisions more gracefully than pre-schema-reuse forests.
    The better handling is needed because the behavior version replicates
    out-of-order wrt the schemaNC. In other words, a collision probably
    happend because someone raised the forest version and reused
    a defunct schema object but the schema objects are replicating
    BEFORE the forest version. Replication will no doubt clear up
    this case but handle it in the interim.

Arguments:

Return Value:

    None.

--*/
{
    DECLARESCHEMAPTR
    DWORD i, iAtt, iCls;
    ATTCACHE *pAC, *pACDup, *pACWinner;
    CLASSCACHE *pCC;
    // not really necessary because this function returns
    // immediately when called during a validation cache
    // load. But that may change someday.
    USHORT DebugLevel = (pTHS->UpdateDITStructure) ? DS_EVENT_SEV_ALWAYS
                                                   : DS_EVENT_SEV_MINIMAL;

    // the validation cache needs to see all of the active
    // attributes and classes, especially those that collide.
    if (!pTHS->UpdateDITStructure) {
        return;
    }

    // Treat dup attrs as if they were defunct
    for (iAtt = 0; iAtt < ATTCOUNT; ++iAtt) {
        pAC = ahcId[iAtt].pVal;
        if (!pAC
            || pAC == FREE_ENTRY
            || (    !pAC->bDupLDN
                 && !pAC->bDupOID
                 && !pAC->bDupMapiID
                // Okay to dup PropGuid during normal cache load;
                // && !pAC->bDupPropGuid
                )) {
            continue;
        }
        pAC->bDefunct = TRUE;

        // NOT AN RDN
        //
        // if the attr is not used as an rdn then remove from active hashes
        if (!pAC->bIsRdn) {
            scUnhashAtt(pTHS, pAC, SC_UNHASH_DEFUNCT);
            continue;
        }

        // USED AS RDN
        //
        // Treat all atts used as RdnAttId as live. A defunct rdnAttId
        // could only occur on pre-schema-reuse DCs and so could not
        // have been reused. schema-reuse DCs disallow reusing
        // rdnAttids.
        //
        // A problem might arise with divergent schemas if rdnAttids
        // collide with other attributes or with other rdnattid
        // attributes. In each case, decide who wins the OID, LDN,
        // and MapiID using the precedence
        //     1) attribute is used as RDN
        //     2) attribute has FLAG_ATTR_IS_RDN set in systemFlags
        //     3) attribute has the largest objectGuid
        // The loser is unhashed from the appropriate table.

        // Colliding OID; choose a winner
        if (pAC->bDupOID) {
            pACWinner = pAC;
            while (pACDup = SCGetAttByExtId(pTHS, pACWinner->Extid)) {
                scUnhashAtt(pTHS, pACDup, SC_UNHASH_LOST_OID);
                if (pACWinner->bIsRdn != pACDup->bIsRdn) {
                    pACWinner = (pACWinner->bIsRdn) ? pACWinner : pACDup;
                } else if (pACWinner->bFlagIsRdn != pACDup->bFlagIsRdn) {
                    pACWinner = (pACWinner->bFlagIsRdn) ? pACWinner : pACDup;
                } else {
                    pACWinner = (0 < memcmp(&pACWinner->objectGuid, 
                                            &pACDup->objectGuid, 
                                            sizeof(pAC->objectGuid)))
                                                ? pACWinner : pACDup;
                }
            }
            for (i=SChash(pACWinner->Extid,ATTCOUNT);
                ahcExtId[i].pVal && (ahcExtId[i].pVal != FREE_ENTRY); i=(i+1)%ATTCOUNT){
            }
            ahcExtId[i].hKey = pACWinner->Extid;
            ahcExtId[i].pVal = pACWinner;
            DPRINT3(DebugLevel, "Attr %s (%x %x) won the attributeId\n",
                    pACWinner->name, pACWinner->id, pACWinner->Extid);
            LogEvent8(DS_EVENT_CAT_SCHEMA,
                      DebugLevel,
                      DIRLOG_SCHEMA_ATTRIBUTE_WON_OID,
                      szInsertSz(pACWinner->name),
                      szInsertHex(pACWinner->id),
                      szInsertHex(pACWinner->Extid),
                      NULL, NULL, NULL, NULL, NULL);
        }

        // Colliding LDN; choose a winner
        if (pAC->bDupLDN) {
            pACWinner = pAC;
            while (pACDup = SCGetAttByName(pTHS, pACWinner->nameLen, pACWinner->name)) {
                scUnhashAtt(pTHS, pACDup, SC_UNHASH_LOST_LDN);
                if (pACWinner->bIsRdn != pACDup->bIsRdn) {
                    pACWinner = (pACWinner->bIsRdn) ? pACWinner : pACDup;
                } else if (pACWinner->bFlagIsRdn != pACDup->bFlagIsRdn) {
                    pACWinner = (pACWinner->bFlagIsRdn) ? pACWinner : pACDup;
                } else {
                    pACWinner = (0 < memcmp(&pACWinner->objectGuid, 
                                            &pACDup->objectGuid, 
                                            sizeof(pAC->objectGuid)))
                                                ? pACWinner : pACDup;
                }
            }
            for (i=SCNameHash(pACWinner->nameLen, pACWinner->name, ATTCOUNT);
                ahcName[i].pVal && (ahcName[i].pVal!= FREE_ENTRY); i=(i+1)%ATTCOUNT) {
            }
            ahcName[i].length = pACWinner->nameLen;
            ahcName[i].value = pACWinner->name;
            ahcName[i].pVal = pACWinner;
            DPRINT3(DebugLevel, "Attr %s (%x %x) won the ldapDisplayName\n",
                    pACWinner->name, pACWinner->id, pACWinner->Extid);
            LogEvent8(DS_EVENT_CAT_SCHEMA,
                      DebugLevel,
                      DIRLOG_SCHEMA_ATTRIBUTE_WON_LDN,
                      szInsertSz(pACWinner->name),
                      szInsertHex(pACWinner->id),
                      szInsertHex(pACWinner->Extid),
                      NULL, NULL, NULL, NULL, NULL);
        }
        // Colliding MapiID; choose a winner
        if (pAC->bDupMapiID) {
            pACWinner = pAC;
            while (pACDup = SCGetAttByMapiId(pTHS, pACWinner->ulMapiID)) {
                scUnhashAtt(pTHS, pACDup, SC_UNHASH_LOST_MAPIID);
                if (pACWinner->bIsRdn != pACDup->bIsRdn) {
                    pACWinner = (pACWinner->bIsRdn) ? pACWinner : pACDup;
                } else if (pACWinner->bFlagIsRdn != pACDup->bFlagIsRdn) {
                    pACWinner = (pACWinner->bFlagIsRdn) ? pACWinner : pACDup;
                } else {
                    pACWinner = (0 < memcmp(&pACWinner->objectGuid, 
                                            &pACDup->objectGuid, 
                                            sizeof(pAC->objectGuid)))
                                                ? pACWinner : pACDup;
                }
            }
            for (i=SChash(pACWinner->ulMapiID, ATTCOUNT);
                 ahcMapi[i].pVal && (ahcMapi[i].pVal!= FREE_ENTRY);
                 i=(i+1)%ATTCOUNT) {
            }
            ahcMapi[i].hKey = pACWinner->ulMapiID;
            ahcMapi[i].pVal = pACWinner;
            DPRINT4(DebugLevel, "Attr %s (%x %x) won the mapiID %x\n",
                    pACWinner->name, pACWinner->id, pACWinner->Extid, pACWinner->ulMapiID);
            LogEvent8(DS_EVENT_CAT_SCHEMA,
                      DebugLevel,
                      DIRLOG_SCHEMA_ATTRIBUTE_WON_MAPIID,
                      szInsertSz(pACWinner->name),
                      szInsertHex(pACWinner->id),
                      szInsertHex(pACWinner->Extid),
                      szInsertHex(pACWinner->ulMapiID),
                      NULL, NULL, NULL, NULL);
        }
    }

    // Treat dup classes as if they were defunct (except oid is not lost.)
    // The oid is not lost because a class must win the oid for
    // replication to work. Keep the winner. 
    //
    // Fixup the rdnIntId with the winner of the RdnExtId.
    for (iCls = 0; iCls < CLSCOUNT; ++iCls) {
        pCC = ahcClassAll[iCls].pVal;

        // free entry
        if (!pCC || pCC == FREE_ENTRY) {
            continue;
        }

        // The active attribute corresponding to RdnExtId may have
        // changed when attribute collisions were resolved.
        pCC->RdnIntId = SCAttExtIdToIntId(pTHS, pCC->RdnExtId);

        // Colliding classes are treated as if they were defunct
        if (pCC->bDupLDN || pCC->bDupOID) {
            // Okay to dup PropGuid during normal cache load; don't defunct 
            // || pCC->bDupPropGuid
            pCC->bDefunct = TRUE;
            scUnhashCls(pTHS, pCC, SC_UNHASH_DEFUNCT);
        }
    }
}

VOID 
scFixRdnAttId (
    IN THSTATE *pTHS
    )
/*++

Routine Description:

    Resurrect attributes used as rdnAttId for any class, live
    or defunct. The resurrected attributes will continue to own
    their attributeId, LDN, MapiId, and schemaIdGuid.

    Divergent schemas may have resulted in duplicate attributeIds.
    scFixCollisions will later decide on a "winner" for the
    OID, LDN, and MapiID.

    Attributes used as rdnattids continue to hold their identity
    because the DS depends on the relationship between ATT_RDN,
    FIXED_ATT_RDN_TYPE, the rdnattid column, the ldapDisplayName
    of the rdnattid, and the rdnattid in the object's class
    when replicating renames, adds, mods, and, perhaps,
    deletes.

Arguments:
    pTHS - thread state

Return Value:

    None.

--*/
{
    DECLARESCHEMAPTR
    DWORD i, j;
    ATTCACHE *pAC;
    CLASSCACHE *pCC;
    USHORT DebugLevel;

    // Resurrect attributes used as rdnAttId for any class, live
    // or defunct. Resurrecting the attributes means these attributes
    // cannot be reused. They are effectively live even when marked
    // defunct.
    for (i = 0; i < CLSCOUNT; ++i) {
        pCC = ahcClassAll[i].pVal;
        if (!pCC || pCC == FREE_ENTRY) {
            continue;
        }
        // If the attribute is not in the attributeId hash table,
        // then it must be defunct. Resurrect all attributes
        // with matching attributeIds.
        //
        // All of the attributes with matching OIDs are resurrected
        // so that they can again compete for the OID given the
        // new knowledge that this attribute and its peers are
        // used as rdnattids. scFixCollisions will choose a winner,
        // later.
        if (NULL == (pAC = SCGetAttByExtId(pTHS, pCC->RdnExtId))) {
            // avoid spew during a validation cache load and
            // when the class is defunct
            if (pCC->bDefunct || !pTHS->UpdateDITStructure) {
                DebugLevel = DS_EVENT_SEV_MINIMAL;
            } else {
                DebugLevel = DS_EVENT_SEV_ALWAYS;
            }
            // Reanimate potential rdnTypes.
            for (j = 0; j < ATTCOUNT; ++j) {
                if ((pAC = ahcId[j].pVal)
                    && pAC != FREE_ENTRY
                    && pAC->Extid == pCC->RdnExtId) {
                    // Just to be safe, remove from relevent hashes
                    scUnhashAtt(pTHS, pAC, SC_UNHASH_DEFUNCT);
                    DPRINT5(DebugLevel, "Resurrect Att %s (%x %x) for class %s (%x)\n",
                            pAC->name, pAC->id, pAC->Extid,
                            pCC->name, pCC->ClassId);
                    LogEvent8(DS_EVENT_CAT_SCHEMA,
                              DebugLevel,
                              DIRLOG_SCHEMA_RESURRECT_RDNATTID,
                              szInsertSz(pAC->name), szInsertHex(pAC->id), szInsertHex(pAC->Extid),
                              szInsertSz(pCC->name), szInsertHex(pCC->ClassId),
                              NULL, NULL, NULL);

                    // Place into active hashes. Set bIsRdn to TRUE
                    // so that scAddAttSchema ignores bDefunct
                    pAC->bIsRdn = TRUE;
                    SCAddAttSchema(pTHS, pAC, FALSE, TRUE);
                }
            }
            // For now, pick any one of the resurrected attrs
            // scFixCollisions will finalize the choice, later
            pAC = SCGetAttByExtId(pTHS, pCC->RdnExtId);
        }
        if (pAC) {
            pAC->bIsRdn = TRUE; // let folks know this att is an rdnattid
            pCC->RdnIntId = pAC->id; // first guess. May change in scFixCollisions.
        }   // else if (!pAC)
            // Not found. pCC->RdnIntId was initialized to
            // RdnExtId. Leave it that way because the attr
            // will probably replicate in later. No problem
            // because no rows can exist unless the LDN exists
            // (shouldn't except for divergent schemas). In that case,
            // the replicating row may have a different name on different
            // DCs. Not catastrophic and better than killing the DC.
    }
}

VOID
ValListToIntIdList(
    IN     THSTATE  *pTHS,
    IN     ULONG    *pCount,
    IN OUT ULONG    **ppVal
    )
/*++

Routine Description:

    Walk an array of attids and convert into intids compressing
    out the untranslatable and defunct on schema-reuse forests.

    Old forests still return defunct attributes.

Arguments:
    pTHS - Its schema ptr is NOT the global schema pointer

Return Value:

    None.

--*/
{
    DWORD       i;
    ATTCACHE    *pAC;
    ULONG       *pVal = *ppVal, *pNewVal;
    ULONG       NewCount;

    // The validation cache retains defunct or missing attids so
    // that scchk.c can correctly disallow the operation.
    if (!pTHS->UpdateDITStructure) {
        // Translate oids into intids; leaving non-translatable oids in place
        for (i = 0; i < *pCount; ++i) {
            pVal[i] = SCAttExtIdToIntId(pTHS, pVal[i]);
        }
    } else {
        // Collapse out defunct or missing attids on a schema-reuse forest.
        // This means defunct attrs are not returned on queries on
        // schema-reuse forests but are returned on pre-schema-reuse
        // forests.
        pNewVal = pVal;
        NewCount = 0;
        for (i = 0; i < *pCount; ++i) {
            if ((pAC = SCGetAttByExtId(pTHS, pVal[i]))
                && (!pAC->bDefunct || !ALLOW_SCHEMA_REUSE_VIEW(pTHS->CurrSchemaPtr))) {
                pNewVal[NewCount++] = pAC->id;
            }
        }
        // Just in case there is code that expects a NULL array if count is 0
        if (0 == (*pCount = NewCount)) {
            SCFree(ppVal);
        } // else don't bother reallocating -- not enough savings 
    }
}
VOID 
scFixMayMust (
    IN THSTATE *pTHS
    )
/*++

Routine Description:

    Fix the mays/musts for a class. 
    Exclude defunct attrs if schema-reuse forest and convert
    tokenized OIDs into internal IDs. The defunct attrs are
    left in place if this is a validation cache load (scchk.c).

Arguments:
    pTHS - Its schema ptr is NOT the global schema pointer

Return Value:

    None.

--*/
{
    DECLARESCHEMAPTR
    DWORD i;
    CLASSCACHE *pCC;

    // Collapse the defunct atts out of the may/must of all classes
    // and change the ExtIds into IntIds. If this is a validation
    // cache load (scchk.c), the defunct ExtIds are left in place.
    for (i = 0; i < CLSCOUNT; ++i) {
        pCC = ahcClassAll[i].pVal;
        if (!pCC || pCC == FREE_ENTRY) {
            continue;
        }
        ValListToIntIdList(pTHS, &pCC->MayCount, &pCC->pMayAtts);
        ValListToIntIdList(pTHS, &pCC->MyMayCount, &pCC->pMyMayAtts);
        ValListToIntIdList(pTHS, &pCC->MustCount, &pCC->pMustAtts);
        ValListToIntIdList(pTHS, &pCC->MyMustCount, &pCC->pMyMustAtts);
    }
}

int
scPagedSearchAtt(
    IN THSTATE      *pTHS,
    IN ENTINF       *pEI
    )
{
    int         err = 0;
    ATTCACHE    *pAC;
    SCHEMAPTR   *pSch = pTHS->CurrSchemaPtr;

    if (NULL == (pAC = scAddAtt(pTHS, pEI))) {
        if (0 == pTHS->errCode) {
            SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_SCHEMA_ALLOC_FAILED);
        }
        err = pTHS->errCode;
        goto cleanup;
    }
    pSch->nAttInDB++;

    if (pAC->bMemberOfPartialSet) {
        // this attribute is a member of partial set
        if (pSch->cPartialAttrVec <= pSch->pPartialAttrVec->V1.cAttrs) {
            // not enough room to add one more attribute - reallocate the partial attribute vector
            pSch->cPartialAttrVec += PARTIAL_ATTR_COUNT_INC;
            if (SCRealloc(&pSch->pPartialAttrVec, PartialAttrVecV1SizeFromLen(pSch->cPartialAttrVec))) {
                err = pTHS->errCode;
                goto cleanup;
            }
        }

        // there is enough space to add the attribute into the partial set - add it
        GC_AddAttributeToPartialSet(pSch->pPartialAttrVec, pAC->id);
    }

cleanup:
    return(err);
}

int
scPagedSearchCls(
    IN THSTATE      *pTHS,
    IN ENTINF       *pEI
    )
{
    int         err = 0;
    CLASSCACHE  *pCC;
    SCHEMAPTR   *pSch = pTHS->CurrSchemaPtr;

    if (NULL == (pCC = scAddClass(pTHS, pEI))) {
        if (pTHS->errCode == 0) {
            // scAddClass can fail in only two cases: the default SD
            // conversion fails, in which case the thread state error
            // code is already set; or if mallocs fail
            SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_SCHEMA_ALLOC_FAILED);
        }
        err = pTHS->errCode;
        goto cleanup;
    }
    pSch->nClsInDB++;

cleanup:
    return(err);
}

int
scPagedSearch(
        IN THSTATE  *pTHS,
        IN PWCHAR   pBaseObjCat,
        IN ULONG    attrCount,
        IN ATTR     *pAttr,
        IN int      (*SearchResize)(IN THSTATE *pTHS, 
                                    IN ULONG nNewEntries),
        IN int      (*SearchEntry)(IN THSTATE *pTHS,
                                   IN ENTINF *pEI)
        )
{
    int         err = 0;
    DWORD       i;
    ENTINFSEL   eiSel;
    PRESTART    pRestart;
    BOOL        fMoreData;
    DWORD       nDnObjCat;
    DSNAME      *pDnObjCat;
    SEARCHARG   SearchArg;
    FILTER      Filter;
    COMMARG     *pCommArg;
    ENTINFLIST  *pEIL, *pEILtmp;
    SEARCHRES   *pSearchRes = NULL;

    //build the object-category value to put in the filter
    nDnObjCat = DSNameSizeFromLen(gAnchor.pDMD->NameLen + wcslen(pBaseObjCat) + 1);
    pDnObjCat = THAllocEx(pTHS, nDnObjCat);
    wcscpy(pDnObjCat->StringName, pBaseObjCat);
    wcscat(pDnObjCat->StringName, gAnchor.pDMD->StringName);
    pDnObjCat->NameLen = wcslen(pDnObjCat->StringName);
    pDnObjCat->structLen = nDnObjCat;

    // build selection
    eiSel.attSel = EN_ATTSET_LIST;
    eiSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    eiSel.AttrTypBlock.attrCount = attrCount;
    eiSel.AttrTypBlock.pAttr = pAttr;

    fMoreData = TRUE;
    pRestart = NULL;

    while (fMoreData && !eServiceShutdown) {

        scAcquireSearchParameters(pTHS, pDnObjCat, &eiSel, &SearchArg, &Filter, &pSearchRes);

        // Set for paged search;
        pCommArg = &(SearchArg.CommArg);
        pCommArg->PagedResult.fPresent = TRUE;
        pCommArg->PagedResult.pRestart = pRestart;
        pCommArg->ulSizeLimit = 200;

        SearchBody(pTHS, &SearchArg, pSearchRes, 0);
        if (err = pTHS->errCode) {
            LogAndAlertEvent(DS_EVENT_CAT_SCHEMA, DS_EVENT_SEV_ALWAYS,
                             DIRLOG_SCHEMA_SEARCH_FAILED, szInsertUL(1),
                             szInsertUL(err), 0);
            goto cleanup;
        }

        if (eServiceShutdown) {
           break;
        }

        // Is there more data?
        if (pSearchRes->PagedResult.pRestart == NULL
            || !pSearchRes->PagedResult.fPresent) {
            // Nope
            fMoreData = FALSE;
        } else {
            // more data. save off the restart to use in the next iteration.
            // Note that freeing searchres does not free pRestart
            pRestart = pSearchRes->PagedResult.pRestart;
        }

        // Resize the hash tables, if needed
        err = (*SearchResize)(pTHS, pSearchRes->count);
        if (err) {
            goto cleanup;
        }

        //  for each attrSchema, add to caches
        pEIL = &(pSearchRes->FirstEntInf);
        for (i = 0; i < pSearchRes->count; i++) {

            // Check for service shutdown once every iteration
            if (eServiceShutdown) {
               return 0;
            }

            if (!pEIL) {
                LogEvent(DS_EVENT_CAT_SCHEMA,
                    DS_EVENT_SEV_MINIMAL,
                    DIRLOG_SCHEMA_BOGUS_SEARCH, szInsertUL(1), szInsertUL(i),
                    szInsertUL(pSearchRes->count));
                break;
            }

            // Process the returned search entry
            if (err = (*SearchEntry)(pTHS, &pEIL->Entinf)) {
                goto cleanup;
            }

            pEILtmp = pEIL;
            pEIL = pEIL->pNextEntInf;
            if (i > 0) {
                THFreeEx(pTHS, pEILtmp);
            }
        }

        // free the searchres
        scReleaseSearchParameters(pTHS, &pSearchRes);

    }  // while (fMoreData)

cleanup:
    scReleaseSearchParameters(pTHS, &pSearchRes);
    THFreeEx(pTHS, pDnObjCat);
    return err;
}

LONG
scGetForestBehaviorVersion(
        VOID
        )
/*++

Routine Description:

    Return the effective ForestBehaviorVersion for the schema cache.

    The schema cache is loaded differently and presents a different
    view of the schema objects after the forest behavior version is
    raised to DS_BEHAVIOR_SCHEMA_REUSE to support the new defunct,
    delete, and reuse behavior. The gAnchor.ForestBehaviorVersion 
    is not used because it may change during or after the schema
    cache has been loaded. This effective schema version is stored
    in the schemaptr.
    
    During install and mkdit, the effective forest version is
    set to DS_BEHAVIOR_SCHEMA_REUSE because the true forest
    version is not known and this more flexible schema cache
    can effectively handle both old and new schemas without
    generating bothersome events and without affecting the
    result of the install or mkdit.

    During boot, the version is read from the DIT. If this read
    fails, the effective version is returned as
    DS_BEHAVIOR_SCHEMA_REUSE for the reasons mentioned above. Later,
    the schema cache may be reloaded immediately if RebuildAnchor
    notices the forest behavior version and the schema's effective
    behavior version are not in sync.

    After boot, the gAnchor.ForestBehaviorVersion is used.
     
Arguments:

    None.

Return Value:

    Effective forest behavior version

--*/
{
    DWORD dwErr;
    DBPOS *pDB;
    LONG ForestBehaviorVersion;
    extern BOOL gfRunningAsMkdit;

    // Always use the most flexible cache version because the
    // more flexible, new cache can handle old and new cache behavior
    // while the old cache cannot. Using the new cache behavior doesn't
    // affect the outcome of dcpromo or mkdit.exe.
    if (DsaIsInstalling() || gfRunningAsMkdit || !gAnchor.pPartitionsDN) {
        return DS_BEHAVIOR_SCHEMA_REUSE;
    }

    // Not the boot load, use whatever is in the gAnchor. gAnchor
    // should have been initialized from the DIT by now so there
    // is no reason to reread the info.
    if (iSCstage > 2) {
        return gAnchor.ForestBehaviorVersion;
    }


    // read the forest's behavior version
    dwErr = 0;
    __try {
        DBOpen(&pDB);
        __try {
            dwErr = DBFindDSName(pDB, gAnchor.pPartitionsDN);
            if (dwErr) {
                __leave;
            }
            dwErr = DBGetSingleValue(pDB,
                                     ATT_MS_DS_BEHAVIOR_VERSION,
                                     &ForestBehaviorVersion,
                                     sizeof(ForestBehaviorVersion),
                                     NULL);
        } __finally {
            DBClose(pDB, TRUE);
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        DPRINT(0, "scGetForestBehaviorVersion: Exception reading version\n");
        dwErr = ERROR_DS_INCOMPATIBLE_VERSION;
    }

    // Can't be read, use the most flexible cache load
    if (dwErr) {
        DPRINT2(0, "scGetForestBehaviorVersion: error %d (%x)\n", dwErr, dwErr);
        ForestBehaviorVersion = DS_BEHAVIOR_SCHEMA_REUSE;
    }

    return ForestBehaviorVersion;
}

int
SCCacheSchema2(
        VOID
        )
/*++

Routine Description:

    Load the schema cache with information from the schemaNC.

    First, search the schemaNC for attributeSchema objects and then
    search for classSchema objects. The cache entries are constructed
    and added to the schema hash tables.
    
    The new (or updated) entries are added to the various hash tables
    according to the rules determined by the forest version in the
    gAnchor. During install or mkdit, the schema cache is loaded at
    version DS_BEHAVIOR_SCHEMA_REUSE because the actual forest version
    is not known and loading at this level doesn't hurt anythinhg and
    prevents unnecessary and bothersome events. During boot, the
    forest version is read from the DIT.

    SCCacheSchemaInit paritially initialized the ATTCACHE entries in
    the attribute hash tables (id, syntax, and colid) and they are in
    just the id and col hash tables. But this is enough info to allow
    searching the schemaNC. SCCacheSchema2 is responsible for
    searching the schemaNC and filling in the rest of the info
    in the ATTCACHE entries. And allocating CLASSCACHE entries.
    
    If this isn't the first schema cache load at boot, then
    SCCacheSchema3 will delete the indexes and columns for attributes
    that don't have corresponding entries in the schemaNC and will
    add missing indexes and columns for attributes in the schemaNC.
    The expensive index creation is delayed until the second
    cache load after boot (approximately 5 minutes after boot)
    so that the AD comes online more quickly and isn't delayed
    for what could be hours.

    Suggested Enhancements
    1) Reduce the number of full hash scans if possible.

Arguments:

    None.

Return Value:

    !0 - failed; caller is responsible for freeing pTHS->CurrSchemaPtr
    with SCFreeSchemaPtr(&pTHS->CurrSchemaPtr);

    0 - Okay

--*/
{
    THSTATE *pTHS = pTHStls;
    int err = 0;

    // Most errors are reported via pTHS->errCode (or will be soon, I hope)
    THClearErrors();

    // There seems to be a path during installation that might call
    // this function w/o having called SCCacheSchemaInit; or is at
    // least pretending not to have called SCCacheSchemaInit by
    // setting iSCstage to 0. Need to resolve this confused
    // code path and document when and how the schema should be
    // reloaded.
    if ((iSCstage == 0) && (err = SCCacheSchemaInit())) {
        return err;
    }

    // Version remains in effect for the life of the cache even if
    // forest's version changes mid-load. Changing the forest version
    // triggers an immediate cache load so the two versions will not
    // be out of sync for long. Also, new incompatible features will
    // not be enabled until both the schema cache and the gAnchor
    // have versions >= DS_BEHAVIOR_SCHEMA_REUSE.
    pTHS->CurrSchemaPtr->ForestBehaviorVersion = scGetForestBehaviorVersion();

    err = scPagedSearch(pTHS, 
                        L"CN=Attribute-Schema,",
                        (pTHS->UpdateDITStructure) ? NUMATTATT : RECALCSCHNUMATTATT,
                        (pTHS->UpdateDITStructure) ? AttributeSelList : RecalcSchAttributeSelList,
                        SCResizeAttHash,
                        scPagedSearchAtt);
    if (err) {
        return err;
    }

    err = scPagedSearch(pTHS, 
                        L"CN=Class-Schema,",
                        (pTHS->UpdateDITStructure) ? NUMCLASSATT: RECALCSCHNUMCLASSATT,
                        (pTHS->UpdateDITStructure) ? ClassSelList : RecalcSchClassSelList,
                        SCResizeClsHash,
                        scPagedSearchCls);
    if (err) {
        return err;
    }


    // Fill in the copy of schemaInfo attribute on schema container.
    // DRA will use it now, and who knows who else will later

    if (err = scFillInSchemaInfo(pTHS)) {
        // Failed to read the schema info
        DPRINT1(0, "Failed to read in schemaInfo during schema cache load: %d\n", err);
        return err;
    }

    // Load the prefix map from the schema object, if any
    // The prefix table will be realloced in InitPrefixTable2
    // if necessary

    if (err = InitPrefixTable2(pTHS->CurrSchemaPtr->PrefixTable.pPrefixEntry,
                               pTHS->CurrSchemaPtr->PREFIXCOUNT)) {
        LogEvent(DS_EVENT_CAT_SCHEMA, DS_EVENT_SEV_ALWAYS, DIRLOG_PREFIX_LOAD_FAILED, 0, 0, 0);
        return err;
    }

    scInitWellKnownAttids();

    // ORDER IS IMPORTANT
    //
    // 1) Resurrect defunct rdnattids.
    // 2) Defunct colliding attributes and classes
    // 3) Collapse defunct attributes out of the mays/musts
    scFixRdnAttId(pTHS);    // must preceed scFixCollisions
    scFixCollisions(pTHS);  // must preceed scFixMayMust
    scFixMayMust(pTHS);

    // WARNING - the schema's behavior version may have been
    // artificially raised for the initial boot schema load.
    // This means the schema runs in BETA3 mode for a few minutes
    // after boot. This is okay because LocalAdd will not create
    // intids until after the second cache load when the forest's
    // behavior version is known.

    ++iSCstage;
    return(0);
}

ATTCACHE*
scAddAtt(
        THSTATE *pTHS,
        ENTINF *pEI
        )
/*++
  Add a single attribute definition to the schema cache, given the data
  from the DMD object.

  N.B. The routines SCBuildACEntry and scAddAtt work in parallel, with
       SCBuildACEntry taking a positioned database record as input and
       SCAddAtt taking an ENTINF.  They both produce an ATTCACHE as output,
       and any changes made to one routine's processing must be made to
       the other's as well.

--*/
{
    ATTRTYP aid = INVALID_ATT, Extaid = INVALID_ATT;           // This is an invalid attribute id.
    ATTCACHE *pAC;
    ULONG i;
    int fNoJetCol = FALSE;
    unsigned syntax;
    char szIndexName [MAX_INDEX_NAME];      //used to create cached index names
    int  lenIndexName;

    // Look for both attids, the attributeId and the msDS-IntId
    for(i=0;i<pEI->AttrBlock.attrCount;i++) {
        if(pEI->AttrBlock.pAttr[i].attrTyp == ATT_ATTRIBUTE_ID) {
            // found the attribute id, save the value.
            Extaid = *(ATTRTYP*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal;
            if (aid != INVALID_ATT) {
                break;
            }
        } else if(pEI->AttrBlock.pAttr[i].attrTyp == ATT_MS_DS_INTID) {
            // found the internal id, save the value.
            aid = *(ATTRTYP*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal;
            if (Extaid != INVALID_ATT) {
                break;
            }
        }
    }

    // No msDS-IntId, use attributeId
    if(aid == INVALID_ATT) {
        aid = Extaid;
    }

    if(Extaid == INVALID_ATT) {
        // Did not find the attribute id.
        LogEvent(DS_EVENT_CAT_SCHEMA,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_SCHEMA_MISSING_ATT_ID, 0, 0, 0);
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_MISSING_REQUIRED_ATT);
        return NULL;
    }

    pAC = SCGetAttById(pTHS, aid);
    if (!pAC) {
        fNoJetCol = TRUE;
        if (SCCalloc(&pAC, 1, sizeof(ATTCACHE))) {
            return NULL;
        }
    } else if (pAC->name) {
        DPRINT4(0, "Dup intid %08x, Extid %08x. Dup with %s, Extid %08x)\n",
                aid, Extaid, pAC->name, pAC->Extid);
        if (!(pTHS->UpdateDITStructure)) {
            if (pAC->id <= LAST_MAPPED_ATT) {
                // dup attributeId
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_DUP_OID);
            } else {
                // dup msDS-IntId
                SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_DUP_MSDS_INTID);
            }
            return NULL;
        }   // else
            // Oddly enough, the existing code will simply reuse an
            // existing cache entry during a non-validation schema reload
            // if the attributeId (now msDS-IntId) matches. This means
            // the fields are overwritten and the entry rehashed. Surely
            // this is a bug! Or is it compensating for some odd interim
            // case during install or pre-w2k DCs? At any rate, the new
            // code will decide the attribute collides and will mark
            // "them" as defunct.
    }
    pAC->id = aid;
    pAC->Extid = Extaid;

    // Now walk the attrblock and add the appropriate fields to the AC
    for(i=0;i< pEI->AttrBlock.attrCount;i++) {
        ATTRVAL * pAVal = pEI->AttrBlock.pAttr[i].AttrVal.pAVal;

        switch (pEI->AttrBlock.pAttr[i].attrTyp) {
        case ATT_SYSTEM_ONLY:
            pAC->bSystemOnly = *(ULONG*)pAVal->pVal;
            break;
        case ATT_IS_SINGLE_VALUED:
            pAC->isSingleValued = *(BOOL*)pAVal->pVal;
            break;
        case ATT_RANGE_LOWER:
            pAC->rangeLower = *(ULONG*)pAVal->pVal;
            pAC->rangeLowerPresent = TRUE;
            break;
        case ATT_RANGE_UPPER:
            pAC->rangeUpper = *(ULONG*)pAVal->pVal;
            pAC->rangeUpperPresent = TRUE;
            break;
        case ATT_LDAP_DISPLAY_NAME:
            if (SCCalloc(&pAC->name, 1, pAVal->valLen+1)) {
                return NULL;
            }

            pAC->nameLen = WideCharToMultiByte(
                    CP_UTF8,
                    0,
                    (LPCWSTR)pAVal->pVal,
                    (pAVal->valLen /
                     sizeof(wchar_t)),
                    pAC->name,
                    pAVal->valLen,
                    NULL,
                    NULL);

            pAC->name[pAC->nameLen] = '\0';

            break;
        case ATT_ATTRIBUTE_SYNTAX:
            syntax = 0xFF & *(unsigned*)pAVal->pVal;
            if (fNoJetCol) {
                pAC->syntax = (0xFF) & syntax;
            }
            else if ((0xFF & syntax) != pAC->syntax) {
                DPRINT1(0, "mismatched syntax on attribute %u\n", aid);
            }
            break;
        case ATT_OM_SYNTAX:
            pAC->OMsyntax = *(int*)pAVal->pVal;
            break;
        case ATT_OM_OBJECT_CLASS:
            if (SCCalloc(&pAC->OMObjClass.elements, 1, pAVal->valLen)) {
                return NULL;
            }
            pAC->OMObjClass.length = pAVal->valLen;
            memcpy(pAC->OMObjClass.elements,
                   pAVal->pVal,
                   pAVal->valLen);
            break;
        case ATT_MAPI_ID:
            pAC->ulMapiID= *(ULONG*)pAVal->pVal;
            break;
        case ATT_LINK_ID:
            pAC->ulLinkID= *(ULONG*)pAVal->pVal;
            break;
        case ATT_ATTRIBUTE_ID:
        case ATT_MS_DS_INTID:
            break;
        case ATT_SEARCH_FLAGS:
            pAC->fSearchFlags = *(DWORD*)pAVal->pVal;
            break;
        case ATT_SCHEMA_ID_GUID:
            // The GUID for the attribute used for security checks
            memcpy(&pAC->propGuid, pAVal->pVal, sizeof(pAC->propGuid));
            Assert(pAVal->valLen == sizeof(pAC->propGuid));
            break;
        case ATT_OBJECT_GUID:
            // Needed to choose a winner when rdnattids collide
            memcpy(&pAC->objectGuid, pAVal->pVal, sizeof(pAC->objectGuid));
            Assert(pAVal->valLen == sizeof(pAC->objectGuid));
            break;
        case ATT_ATTRIBUTE_SECURITY_GUID:
            // The GUID for the attributes property set used for security checks
            memcpy(&pAC->propSetGuid, pAVal->pVal, sizeof(pAC->propSetGuid));
            Assert(pAVal->valLen == sizeof(pAC->propSetGuid));
            break;
        case ATT_EXTENDED_CHARS_ALLOWED:
            pAC->bExtendedChars = (*(DWORD*)pAVal->pVal?1:0);
            break;
        case ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET:
            if (*(DWORD*)pAVal->pVal)
            {
                pAC->bMemberOfPartialSet = TRUE;
            }
            break;
        case ATT_IS_DEFUNCT:
            pAC->bDefunct = (*(DWORD*)pAVal->pVal?1:0);
            break;
        case ATT_SYSTEM_FLAGS:
            if (*(DWORD*)pAVal->pVal & FLAG_ATTR_NOT_REPLICATED) {
                pAC->bIsNotReplicated = TRUE;
            }
            if (*(DWORD*)pAVal->pVal & FLAG_ATTR_REQ_PARTIAL_SET_MEMBER) {
                pAC->bMemberOfPartialSet = TRUE;
            }
            if (*(DWORD*)pAVal->pVal & FLAG_ATTR_IS_CONSTRUCTED) {
                pAC->bIsConstructed = TRUE;
            }
            if (*(DWORD*)pAVal->pVal & FLAG_ATTR_IS_OPERATIONAL) {
                pAC->bIsOperational = TRUE;
            }
            if (*(DWORD*)pAVal->pVal & FLAG_SCHEMA_BASE_OBJECT) {
                pAC->bIsBaseSchObj = TRUE;
            }
            if (*(DWORD*)pAVal->pVal & FLAG_ATTR_IS_RDN) {
                pAC->bIsRdn = TRUE;
                pAC->bFlagIsRdn = TRUE;
            }
            break;
        default:
            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_SCHEMA_SURPLUS_INFO,
                     szInsertUL(pEI->AttrBlock.pAttr[i].attrTyp),
                     0, 0);
        }
        THFreeEx(pTHS, pAVal->pVal);
        THFreeEx(pTHS, pAVal);
    }

    THFreeEx(pTHS, pEI->pName);
    THFreeEx(pTHS, pEI->AttrBlock.pAttr);

    // Backlinks should have their system flags set to indicate they are not
    // replicated.
    Assert(!FIsBacklink(pAC->ulLinkID) || pAC->bIsNotReplicated);

    // Is this marked as ANR and indexed over the whole tree?
    if(((pAC->fSearchFlags & (fANR | fATTINDEX)) == (fANR | fATTINDEX)) &&
       (!pAC->bDefunct)) {
        SCAddANRid(aid);
    }

    // assign names of commonly used indexes when searching with
    // fSearchFlags fPDNTATTINDEX, fATTINDEX and fTUPLEINDEX
    if (pAC->fSearchFlags & (fATTINDEX | fPDNTATTINDEX | fTUPLEINDEX)) {
        // set ATTINDEX
        if (pAC->fSearchFlags & fATTINDEX) {

            // this should be NULL
            Assert (pAC->pszIndex == NULL);

            DBGetIndexName (pAC, fATTINDEX, DS_DEFAULT_LOCALE, szIndexName, MAX_INDEX_NAME);
            lenIndexName = strlen (szIndexName) + 1;
            if (SCCalloc(&pAC->pszIndex, 1, lenIndexName)) {
                return NULL;
            }
            memcpy (pAC->pszIndex, szIndexName, lenIndexName);
        }

        // set PDNTATTINDEX
        if (pAC->fSearchFlags & fPDNTATTINDEX) {

            // this should be NULL
            Assert (pAC->pszPdntIndex == NULL);

            DBGetIndexName (pAC, fPDNTATTINDEX, DS_DEFAULT_LOCALE, szIndexName, sizeof (szIndexName));

            lenIndexName = strlen (szIndexName) + 1;
            if (SCCalloc(&pAC->pszPdntIndex, 1, lenIndexName)) {
                return NULL;
            }
            memcpy (pAC->pszPdntIndex, szIndexName, lenIndexName);
        }

        // set TUPLEINDEX
        if (pAC->fSearchFlags & fTUPLEINDEX) {

            // this should be NULL
            Assert (pAC->pszTupleIndex == NULL);

            DBGetIndexName (pAC, fTUPLEINDEX, DS_DEFAULT_LOCALE, szIndexName, sizeof (szIndexName));

            lenIndexName = strlen (szIndexName) + 1;
            if (SCCalloc(&pAC->pszTupleIndex, 1, lenIndexName)) {
                return NULL;
            }
            memcpy (pAC->pszTupleIndex, szIndexName, lenIndexName);
        }
    }

    if ( SCAddAttSchema (pTHS, pAC, fNoJetCol, FALSE)) {
       // error adding  attcache to hash tables. Fatal
       // Who frees pAC?
       return NULL;
    }

    return pAC;
}

/*
 * Walk an ATTR structure and adds all the unsigned values into an array
 * puCount && pauVal are in/out parameters
 *
 * Return Value:
 *    0 on success
 *    non-0 on alloc failure
 */
int GetValList(ULONG * puCount, ULONG **pauVal, ATTR *pA)
{
    ULONG u;
    ATTRVAL *pAV;
    ULONG *pau;
    ULONG   StartCount= *puCount;
    ULONG*  const StartList = *pauVal;
    ULONG*  StartListTmp = StartList;
    ULONG   NewCount = (ULONG) pA->AttrVal.valCount;


    *puCount += NewCount;
    if (SCCalloc(&pau, 1, (*puCount)*sizeof(ULONG))) {
        *puCount = 0;
        *pauVal = NULL;
        return 1;
    }
    *pauVal = pau;

    for (u=0;u<StartCount;u++)
    {
        *pau++ = *StartListTmp++;
    }

    pAV = pA->AttrVal.pAVal;
    for (u=0; u<NewCount; u++) {
        *pau = *(ULONG*)pAV->pVal;
        ++pAV;
        ++pau;
    }

    SCFree((VOID **)&StartList);

    return 0;
}



/*
 * Helper routine to cache last default SD converted during classcache load,
 * so that we do not call the advapi functions all the time. Major perf
 * gain since most of the default SDs in the schema are same anyway
 *
 * Arguments:
 *    pTHS - pointer th thread state
 *    pStrSD - string SD to convert
 *    ppSDBuf - pointer to pointer to return converted SD
 *    pSDLen - pointer to return size of converted SD
 *
 * Return Value:
 *    TRUE if the conversion succeeds, FALSE otherwise
 *    Note: The function returns false only if the advapi call fails
 */

BOOL  CachedConvertStringSDToSDRootDomainW(
    THSTATE *pTHS,
    WCHAR   *pStrSD,
    PSECURITY_DESCRIPTOR *ppSDBuf,
    ULONG *pSDLen
)
{

    unsigned len;
    BOOL flag;
    CACHED_SD_INFO *pCachedSDInfo = (CACHED_SD_INFO *) pTHS->pCachedSDInfo;

    // If the first conversion, create the structure in the thread state
    if (pCachedSDInfo == NULL) {
       pTHS->pCachedSDInfo = pCachedSDInfo =
            (CACHED_SD_INFO *) THAllocEx( pTHS, sizeof(CACHED_SD_INFO));
    }

    len = wcslen(pStrSD);
    if ( (len == pCachedSDInfo->cCachedStringSDLen)
           && (0 == memcmp(pStrSD, pCachedSDInfo->pCachedStringSD, len*sizeof(WCHAR))) ) {
        // same as the cached SD
        flag = TRUE;
    }
    else {
        // not the same SD as last time
        if (pCachedSDInfo->pCachedSD) {
           // this is local alloc'ed by the advapi routine

           LocalFree(pCachedSDInfo->pCachedSD);
           pCachedSDInfo->pCachedSD = NULL;
           pCachedSDInfo->cCachedSDSize = 0;
        }
        if (pCachedSDInfo->pCachedStringSD) {
           THFreeEx(pTHS, pCachedSDInfo->pCachedStringSD);
           pCachedSDInfo->pCachedStringSD = NULL;
           pCachedSDInfo->cCachedStringSDLen = 0;
        }

        // make the advapi call to convert the string SD
        flag =  ConvertStringSDToSDRootDomainW( gpRootDomainSid,
                                                pStrSD,
                                                SDDL_REVISION_1,
                                                &(pCachedSDInfo->pCachedSD),
                                                &(pCachedSDInfo->cCachedSDSize) );
        if (flag) {
           // we succeeded, remember the arguments
           pCachedSDInfo->pCachedStringSD = (WCHAR *) THAllocEx(pTHS, len*sizeof(WCHAR));
           memcpy(pCachedSDInfo->pCachedStringSD, pStrSD, len*sizeof(WCHAR));
           pCachedSDInfo->cCachedStringSDLen = len;
        }
        else {
           // the conversion failed. Forget everything
           if (pCachedSDInfo->pCachedStringSD) {
              THFreeEx(pTHS, pCachedSDInfo->pCachedStringSD);
           }
           if (pCachedSDInfo->pCachedSD) {
              LocalFree(pCachedSDInfo->pCachedSD);
           }
           pCachedSDInfo->pCachedStringSD = NULL;
           pCachedSDInfo->cCachedStringSDLen = 0;
           pCachedSDInfo->pCachedSD = NULL;
           pCachedSDInfo->cCachedSDSize = 0;

           DPRINT(0,"Failed to convert default SD in CachedConvertStringSDToSDRootDomainW\n");

       }
    }

    if (flag) {
       // No matter how we got here, if flag is set then we want to copy
       // the cached SD.
       *ppSDBuf = THAllocEx(pTHS, pCachedSDInfo->cCachedSDSize);
       memcpy (*ppSDBuf, pCachedSDInfo->pCachedSD, pCachedSDInfo->cCachedSDSize);
       *pSDLen = pCachedSDInfo->cCachedSDSize;
    }

    return flag;
}

DWORD
SCGetDefaultSD(
    IN  THSTATE *          pTHS,
    IN  CLASSCACHE *       pCC,
    IN  PSID               pDomainSid,
    OUT PSECURITY_DESCRIPTOR *  ppSD,  // THAlloc'd
    OUT ULONG *            pcbSD
    )
{
    PSECURITY_DESCRIPTOR     pSDTemp = NULL;
    ULONG                    cbSDTemp = 0;
    ULONG                    ulErr;

    // Sid should be provided or not, not partially provided ;)
    Assert(pDomainSid == NULL ||
           IsValidSid(pDomainSid));
    // Check and NULL out parameters.
    Assert(ppSD && *ppSD == NULL);
    Assert(pcbSD && *pcbSD == 0);
    *ppSD = NULL;
    *pcbSD = 0;

    // Either were using the provided domain SID, OR  we're using our 
    // default domain SID.
    Assert(!pDomainSid || gAnchor.pDomainDN);
    
    // This is invalid only once during install.
    Assert(DsaIsInstalling() || gAnchor.pDomainDN->SidLen > 0);

    if(pDomainSid == NULL ||
       (IsValidSid(&gAnchor.pDomainDN->Sid) && 
        IsValidSid(pDomainSid) &&
        RtlEqualSid(&gAnchor.pDomainDN->Sid, pDomainSid))){
                                      
        // The SID is that of the DCs domain SID or there is no SID
        // provided, implying that this is the Config/Schema NC, so
        // just returned the cached value.
        *ppSD = pCC->pSD;
        *pcbSD = pCC->SDLen;

    } else {

        // This is the interesting case, the SID of the domain here is 
        // not that of the default domain.
        
        // Get the String Default Security Descriptor and cache it if
        // we don't have it already.
        if(!pCC->pStrSD){
            Assert(!"This should never happen, all the String SDs are loaded at schema init.\n");
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_CODE_INCONSISTENCY, ERROR_INVALID_PARAMETER);
            return(pTHS->errCode);
        }
        Assert(pCC->pStrSD);
                 
        // This is a special version of ConvertStringSDToSD() that takes a domain
        // argument too.
        if(!ConvertStringSDToSDDomainW(pDomainSid, NULL, pCC->pStrSD, SDDL_REVISION_1,
                                       &pSDTemp, &cbSDTemp)){
            // NOTE: Out of memory doesn't return an error code.
            Assert(!"Default security descriptor conversion failed, are we out of memory.");
            ulErr = GetLastError();
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_STRING_SD_CONVERSION_FAILED, ulErr);
            DPRINT1(0,"Default SD conversion failed, error %x\n", ulErr);
            return(pTHS->errCode);
        }
        __try {
            Assert(IsValidSecurityDescriptor(pSDTemp));
            Assert(cbSDTemp);

            // allocate and copy into thread allocated memory, so it disappears
            // after the add operation.
            *ppSD = THAllocEx(pTHS, cbSDTemp);
            *pcbSD = cbSDTemp;
            memcpy(*ppSD, pSDTemp, cbSDTemp);
        } __finally {
            LocalFree(pSDTemp);
        }
    }

    Assert(!pTHS->errCode);
    return(pTHS->errCode);
}



/*
 * Add a single class definition to the schema cache, given the data
 * from the DMD object.
 *
 * N.B. This routine works in parallel with SCBuildCCEntry.  scAddClass
 *      takes the input description as an ENTINF, while SCBuildCCEntry
 *      takes the input as a positioned record in the DIT.  Any changes
 *      made to one routine must be made to the other.
 */
CLASSCACHE*
scAddClass(THSTATE *pTHS,
           ENTINF *pEI)
{
    CLASSCACHE *pCC;
    ULONG       i;
    ULONG       err;

    /* allocate a classcache object */
    if (SCCalloc(&pCC, 1, sizeof(CLASSCACHE))) {
        return NULL;
    }

    // Now walk the attrblock and add the appropriate fields to the CC
    for(i=0;i<pEI->AttrBlock.attrCount;i++) {
        switch (pEI->AttrBlock.pAttr[i].attrTyp) {
        case ATT_DEFAULT_SECURITY_DESCRIPTOR:
          {

            // A default security descriptor.  We need to copy this value to
            // long term memory and save the size.
            // But this is a string. We first need to convert. It
            // is a wide-char string now, but we need to null-terminate
            // it for the security conversion. Yikes! This means I
            // have to realloc for that one extra char!

            UCHAR *sdBuf = NULL;

            pCC->cbStrSD = pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen + sizeof(WCHAR);
            if (SCCalloc(&pCC->pStrSD, 1, pCC->cbStrSD)) {
                pCC->cbStrSD = 0;
                return(NULL);
            } else {
                memcpy(pCC->pStrSD,
                       pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal,
                       pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen);
                pCC->pStrSD[(pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen)/sizeof(WCHAR)] = L'\0';
            }

            // Hammer the default SD on cached classes when running as
            // dsamain.exe w/security disabled and unit tests enabled.
            DEFAULT_SD_FOR_EXE(pTHS, pCC)

            if (!CachedConvertStringSDToSDRootDomainW
                 (
                   pTHS,
                   pCC->pStrSD,
                  (PSECURITY_DESCRIPTOR*) &sdBuf,
                  &(pCC->SDLen)
                  )) {
                // Failed to convert.

                //
                // If we're running because of mkdit or any other exe type app,
                // like dsatest or the semantic checker then this is ok.
                //

                if ( gfRunningAsExe ) {
                    // We're running under mkdit or some such.  Of course that
                    // didn't work.  Just skip it.
                    pCC->pSD = NULL;
                    pCC->SDLen = 0;
                }
                else {
                    err = GetLastError();
                    pCC->pSD = NULL;
                    pCC->SDLen = 0;
                    LogEvent(DS_EVENT_CAT_SCHEMA,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_SCHEMA_SD_CONVERSION_FAILED,
                             szInsertWC(pCC->pStrSD),
                             szInsertWC(pEI->pName->StringName),
                             szInsertInt(err) );
                    // if heuristics reg key says to ignore bad default SDs
                    // and go on, do so
                    if (gulIgnoreBadDefaultSD) {
                       continue;
                    }

                    // otherwise, raise error and return
                    SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_STRING_SD_CONVERSION_FAILED, err);
                    DPRINT1(0,"Default SD conversion failed, error %x\n",err);
                    Assert(!"Default security descriptor conversion failed");
                    return NULL;
                }
            }
            else {
                // Converted successfully

                if (SCCalloc(&pCC->pSD, 1, pCC->SDLen)) {
                    if (NULL!=sdBuf) {
                        THFreeEx(pTHS, sdBuf);
                        sdBuf = NULL;
                    }
                    return NULL;
                }
                else {
                    memcpy(pCC->pSD, sdBuf, pCC->SDLen);
                }

                if (NULL!=sdBuf) {
                    THFreeEx(pTHS, sdBuf);
                    sdBuf = NULL;
                }

            }

        }

           break;
        case ATT_RDN_ATT_ID:
            // This is only true for attributes created before whistler
            // beta3 and base schema attributes. The real RdnIntId is
            // finalized in scFixRdnAttId and scFixCollisions after
            // the rdn attrs are resurrected and collisions resolved
            pCC->RdnExtId = *(ULONG*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal;
            pCC->RdnIntId = pCC->RdnExtId;
            pCC->RDNAttIdPresent = TRUE;
            break;
        case ATT_LDAP_DISPLAY_NAME:
            if (SCCalloc(&pCC->name, 1, pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen+1)) {
                return NULL;
            }
            pCC->nameLen = WideCharToMultiByte(
                    CP_UTF8,
                    0,
                    (LPCWSTR)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal,
                    (pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen  /
                     sizeof(wchar_t)),
                    pCC->name,
                    pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen,
                    NULL,
                    NULL);

            pCC->name[pCC->nameLen] =  '\0';
            break;
        case ATT_SYSTEM_ONLY:
            pCC->bSystemOnly =
                *(ULONG*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal;
            break;
        case ATT_DEFAULT_HIDING_VALUE:
            pCC->bHideFromAB =
                *(BOOL*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal;
            break;
        case ATT_GOVERNS_ID:
            pCC->ClassId = *(ULONG*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal;
            break;

        case ATT_SYSTEM_MAY_CONTAIN:
        case ATT_MAY_CONTAIN:
            if ( GetValList(&pCC->MayCount, &(pCC->pMayAtts),
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }

            if ( GetValList(&pCC->MyMayCount, &(pCC->pMyMayAtts),
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }
            break;

        case ATT_SYSTEM_MUST_CONTAIN:
        case ATT_MUST_CONTAIN:
            if ( GetValList(&pCC->MustCount, &pCC->pMustAtts,
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }

            if ( GetValList(&pCC->MyMustCount, &pCC->pMyMustAtts,
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }

            break;
        case ATT_SUB_CLASS_OF:
            if ( GetValList(&pCC->SubClassCount, &pCC->pSubClassOf,
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }
            if(pCC->SubClassCount > 1)
                    pCC->bUsesMultInherit = 1;

            // ATT_SUB_CLASS_OF is single-valued, so there will be only
            // one value stored in the dit
            pCC->MySubClass = *(ULONG*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal;
            break;
        case ATT_OBJECT_CLASS_CATEGORY:
            pCC->ClassCategory=
                *(ULONG*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal;
            break;
        case ATT_DEFAULT_OBJECT_CATEGORY:

            if (SCCalloc(&pCC->pDefaultObjCategory, 1, pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen)) {
                return NULL;
            }
            memcpy(pCC->pDefaultObjCategory,
                   pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal,
                   pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen);
            break;

        case ATT_SYSTEM_AUXILIARY_CLASS:
        case ATT_AUXILIARY_CLASS:
            if ( GetValList(&pCC->AuxClassCount, &pCC->pAuxClass,
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }
            break;
        case ATT_SCHEMA_ID_GUID:
            // The GUID for the attribute used for security checks
            memcpy(&pCC->propGuid,
                   pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal,
                   sizeof(pCC->propGuid));
            Assert(pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen ==
                   sizeof(pCC->propGuid));
            break;

        case ATT_OBJECT_GUID:
            // Used to choose a winner when OIDs collide
            memcpy(&pCC->objectGuid,
                   pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal,
                   sizeof(pCC->objectGuid));
            Assert(pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen ==
                   sizeof(pCC->objectGuid));
            break;

        case ATT_SYSTEM_POSS_SUPERIORS:
        case ATT_POSS_SUPERIORS:
            if ( GetValList(&pCC->PossSupCount, &pCC->pPossSup,
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }

            if ( GetValList(&(pCC->MyPossSupCount), &(pCC->pMyPossSup),
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }
            break;
        case ATT_IS_DEFUNCT:
            pCC->bDefunct =
                (*(DWORD*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal?1:0);
            break;
        case ATT_SYSTEM_FLAGS:
            if (*(DWORD*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal & FLAG_SCHEMA_BASE_OBJECT) {
                pCC->bIsBaseSchObj = TRUE;
            }
            break;

        default:
            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_SCHEMA_SURPLUS_INFO,
                     szInsertUL(pEI->AttrBlock.pAttr[i].attrTyp), 0, 0);
        }
        THFreeEx(pTHS, pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal);
        THFreeEx(pTHS, pEI->AttrBlock.pAttr[i].AttrVal.pAVal);
    }

    THFreeEx(pTHS, pEI->pName);
    THFreeEx(pTHS, pEI->AttrBlock.pAttr);

    if (SCAddClassSchema (pTHS, pCC)) {
      // error adding classcache to hash tables. Fatal
      return NULL;
    }

    return pCC;
}


DWORD scFillInSchemaInfo(THSTATE *pTHS)
{
    DBPOS *pDB=NULL;
    DWORD err=0;
    ATTCACHE* ac;
    BOOL fCommit = FALSE;
    ULONG cLen;
    UCHAR *pBuf;
    SCHEMAPTR *pSchemaPtr = (SCHEMAPTR *) pTHS->CurrSchemaPtr;

    DBOpen2(TRUE, &pDB);
    __try {
       // Schema cache is loaded and hence gAnchor.pDMD is defined at
       // this point

       if (gAnchor.pDMD == NULL) {
              DPRINT(0, "Couldn't find DMD name/address to load\n");
              err = 1;
              __leave;
          }

        // PREFIX: dereferencing NULL pointer 'pDB' 
        //         DBOpen2 returns non-NULL pDB or throws an exception
      if( err = DBFindDSName(pDB, gAnchor.pDMD) ) {
        DPRINT(0, "Cannot find DMD in dit\n");
        __leave;
      }

      ac = SCGetAttById(pTHS, ATT_SCHEMA_INFO);
      if (ac==NULL) {
          // messed up schema
          DPRINT(0, "scFillInSchemaInfo: Cannot retrive attcache for schema info\n");
          err = ERROR_DS_MISSING_EXPECTED_ATT;
           __leave;
       }
       // Read the Schema Info
       err = DBGetAttVal_AC(pDB, 1, ac, DBGETATTVAL_fREALLOC,
                            0, &cLen, (UCHAR **) &pBuf);
       switch (err) {
            case DB_ERR_NO_VALUE:
               // copy the default info
               memcpy(pSchemaPtr->SchemaInfo, INVALID_SCHEMA_INFO, SCHEMA_INFO_LENGTH); 
               err = 0;
               break;
            case 0:
               // success! we got the value in pBuf
               Assert(cLen == SCHEMA_INFO_LENGTH);
               memcpy(pSchemaPtr->SchemaInfo, pBuf, SCHEMA_INFO_LENGTH); 
               break;
            default:
               // Some other error!
               __leave;
        } /* switch */
    }
    __finally {
        if (0 == err) {
            fCommit = TRUE;
        }
        DBClose(pDB,fCommit);
    }

    return err;
}


/*
 * Takes an array of DWORDS.  Ignores the 0th DWORD, reads the
 * second as an upper limmit N and then creates indices using
 * the 2nd - (N-1)th DWORDS as attribute IDs-search flag pairs.
 * Frees the memory after its done.
 *
 * Currently only called from sccacheschema3 below.  Later, could
 * be used to asynchronously add indices on the fly.
 */
void
AsyncCreateIndices (DWORD * pNewIndices)
{
    DWORD i;
    int err;
    ATTCACHE * pAC;
    THSTATE * pTHS = pTHStls;           // Just for speed.

    if(pNewIndices) {
        /* Need to create some new indices */
        for(i=2;i<pNewIndices[1];i += 2) {

            if (eServiceShutdown)
            {
                //
                // The system is shutting down.
                //
                return;
            }

            if(pAC = SCGetAttById(pTHS, pNewIndices[i])) {
                LogEvent(DS_EVENT_CAT_SCHEMA,
                         DS_EVENT_SEV_EXTENSIVE,
                         DIRLOG_SCHEMA_CREATING_INDEX,
                         szInsertUL(pAC->id), pAC->name, 0);
                err = DBAddColIndex(pAC,
                                    pNewIndices[i+1],
                                    JET_bitIndexIgnoreAnyNull);
                if(err) {
                    LogEvent(DS_EVENT_CAT_SCHEMA,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_SCHEMA_CREATE_INDEX_FAILED,
                             szInsertUL(pAC->id), szInsertSz(pAC->name), szInsertInt(err));

                    // schedule a retry
                    if (DsaIsRunning()) {
                       SCSignalSchemaUpdateLazy();
                    }
                }
                else {
                    LogEvent(DS_EVENT_CAT_SCHEMA,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_SCHEMA_INDEX_CREATED,
                             szInsertUL(pAC->id), szInsertSz(pAC->name), 0);
                }
            }
        }
        SCFree(&pNewIndices);
    }

}

/*
 * Helper macros to indicate if we want cleanup or not, and if we
 * want to create all indices or just selected ones.
*/

#define NO_CLEANUP  (gFirstCacheLoadAfterBoot || !DsaIsRunning())
#define DO_CLEANUP (!gFirstCacheLoadAfterBoot && DsaIsRunning())
#define CREATE_SELECTED_INDICES  (gFirstCacheLoadAfterBoot || !DsaIsRunning())
#define CREATE_ALL_INDICES (!gFirstCacheLoadAfterBoot && DsaIsRunning())


/*
 * Compute transitive closure of inherited schema charactistics, and
 * delete unused JET indices and columns
 *
 * If this is called as part of the first cache load after boot, we
 * will skip most of these. Specifically, we will only verify if
 * certain indices we rely on are there, and if not, create them.
 * All else will be done by an async cache update later
 */
int SCCacheSchema3()
{
    THSTATE *pTHS=pTHStls;
    DECLARESCHEMAPTR
    ULONG i;
    ATTCACHE * pAC;
    CHAR szIndexName [MAX_INDEX_NAME];      //used to create cached index names
    int  lenIndexName;
    DWORD *pNewIndices=NULL;
    JET_ERR err;
    ULONG exceptErr=0;
    JET_SESID jsid;
    JET_DBID jdbid;
    JET_INDEXLIST jil;
    DBPOS *pDB=NULL;
    BOOL fColDeleted = FALSE;

    /* This function is called from two places: LoadSchemaInfo during
     * boot/install/mkdit cache load, and from SCUpdateSchemaHelper
     * during async or blocking cache update. In the latter case,
     * we come in with no transaction open, but we need a dbpos
     * in searching for indices etc. So open a dbpos and close before
     * calling AsyncCreateIndices so that a transaction is not held in the
     * normal case when indices are built, which can potentially take
     * long (the main reason we come in without an open transaction,
     * so that we can close it inside SCCacheSchema3 wherever we want).
     * In the former case, we have a transaction open already (since
     * schema cache load is just one of many things inside the transaction,
     * but the extra DBOpen doesn't hurt much (compared to the cache load
     * time). The max transaction time here is not very important, since
     * no other client is doing anything (so no version store problem)
     * unless this is over.
     * Note that all we use is pDB->JetSessId and pDB->JetObjTbl. While
     * JetSessId is easy te get also from the thstate (thats what DBOpen
     * does too), getting JetObjTbl is slightly more complex (see DBOpen2
     * code). We could have duplicated it here, but this seems cleaner
     */
    DBOpen2(FALSE, &pDB);

    __try {  /* except */
     __try { /* finally */

        /* Quiz JET to find a table that describes the indices */
        jsid = pTHS->JetCache.sesid;
        jdbid = pTHS->JetCache.dbid;

        /* Check if we need to do cleanup this time around */
	
        if ( DO_CLEANUP ) {
		
            if (!JetGetIndexInfo(jsid,jdbid,SZDATATABLE,0,&jil,sizeof(jil),
                JET_IdxInfoList)) {
                /* We have the table we need.  We just blow off reclamation of
                 * indices if the previous call failed.
                 *
                 * Ok, now walk the table and extract info for each index.  Whenever
                 * we find an index that looks like it is created from an attribute
                 * (name starts with INDEX) put it in the list of index names to
                 * check on later.
                 */

                /* NOTE: the use of oldaid is to avoid dups in the index names.
                 * someday, if we can figure out how to get jet to skip the
                 * dups, we will get rid of the check.
                 */

                 JET_TABLEID jtid;
                 JET_RETRIEVECOLUMN ajrc[1];
                 char achIndexName[JET_cbNameMost];
                 char oldIndexName[JET_cbNameMost];
                 ULONG aid, oldaid=-1;
                 ULONG indexMask;
                 DWORD numValidIndexes = 0;

                 oldIndexName[0]=0;

                 memset(ajrc, 0, sizeof(ajrc));
                 ajrc[0].columnid = jil.columnidindexname;
                 ajrc[0].pvData = achIndexName;
                 ajrc[0].cbData = sizeof(achIndexName);
                 ajrc[0].itagSequence = 1;

                 jtid = jil.tableid;

                 JetMove(jsid, jtid, JET_MoveFirst, 0);

                 do {
                     // Check for service shutdown once every iteration
                     if (eServiceShutdown) {
                         return 0;
                     }

                     memset(achIndexName, 0, sizeof(achIndexName));
                     JetRetrieveColumns(jsid, jtid, ajrc, 1);
                     if(strcmp(achIndexName,oldIndexName)==0) {
                       /* this is the same index as last time */
                       continue;
                     }
                     else {
                       strcpy(oldIndexName,achIndexName);
                     }

                     if (!strncmp(achIndexName,
                                  SZLCLINDEXPREFIX,
                                  sizeof(SZLCLINDEXPREFIX)-1)) {
                         DWORD dwLanguage, j, fFound=FALSE;
                         /* This is a localized index. Pluck the language id off
                          * the end and see if we should keep the index.
                          */

                         sscanf(&achIndexName[strlen(achIndexName)-7],
                                "%lx",&dwLanguage);

                         for(j=1; !fFound && j<=gAnchor.ulNumLangs; j++) {
                             if(gAnchor.pulLangs[j] == dwLanguage)
                                 fFound = TRUE;
                         }

                         if(!fFound) {
                            /* This lang wasn't in the list, so kill it */
                            err = JetDeleteIndex(pDB->JetSessID,
                                                 pDB->JetObjTbl,
                                                 achIndexName);
                            switch(err) {
                            case JET_errSuccess:
                                LogEvent(DS_EVENT_CAT_SCHEMA,
                                         DS_EVENT_SEV_ALWAYS,
                                         DIRLOG_SCHEMA_DELETED_LOCALIZED_INDEX,
                                         szInsertSz(achIndexName), 0, 0);
                                break;

                            default:
                                LogEvent(DS_EVENT_CAT_SCHEMA,
                                         DS_EVENT_SEV_ALWAYS,
                                         DIRLOG_SCHEMA_DELETE_LOCALIZED_INDEX_FAIL,
                                         szInsertSz(achIndexName), szInsertUL(err), 0);
                                break;
                            }
                         }
                        continue;
                    }

                    if (strncmp(achIndexName,
                                SZATTINDEXPREFIX,
                                sizeof(SZATTINDEXPREFIX)-1)) {
                        /* not an att column */
                        continue;
                    }

                    /* ok, this index is based on an attribute.  Look up the attribute
                     * and make sure it needs this index.  If it doesn't, kill the
                     * index.
                    */
                    if(achIndexName[sizeof(SZATTINDEXPREFIX)-1] == 'P') {
                        indexMask = fPDNTATTINDEX;
                        aid = strtoul(&achIndexName[sizeof(SZATTINDEXPREFIX)+sizeof("P_") - 2], NULL, 16);
                    }
                    else if (achIndexName[sizeof(SZATTINDEXPREFIX)-1] == 'L') {
                        DWORD dwLanguage, j, fFound=FALSE, tmpid;
                        char tmpStr[10];

                        DPRINT1 (1, "Testing index %s\n", achIndexName);

                        memcpy (tmpStr, &achIndexName[sizeof(SZATTINDEXPREFIX)+sizeof("LP_")-2], 8);
                        tmpStr[8]=0;

                        tmpid = strtoul(tmpStr, NULL, 16);

                        DPRINT1 (1, "Found localized index for att 0x%x\n", tmpid);

                        if ( !(pAC = SCGetAttById(pTHS, tmpid)) ||
                             !(pAC->fSearchFlags & fPDNTATTINDEX) ) {
                            fFound = FALSE;
                        }
                        else {
                             /* This is a localized index. Pluck the language id off
                             * the end and see if we should keep the index.
                             */

                            sscanf(&achIndexName[strlen(achIndexName)-3],
                                   "%lx",&dwLanguage);

                            DPRINT1 (1, "Found localized index for lang %d\n", dwLanguage);

                            for(j=1; !fFound && j<=gAnchor.ulNumLangs; j++) {
                                if(gAnchor.pulLangs[j] == dwLanguage)
                                    fFound = TRUE;
                            }
                        }

                        if(!fFound) {

                            DPRINT1 (1, "Removing index %s\n", achIndexName);
                           /* This lang wasn't in the list, so kill it */
                           err = JetDeleteIndex(pDB->JetSessID,
                                                pDB->JetObjTbl,
                                                achIndexName);
                           switch(err) {
                           case JET_errSuccess:
                               LogEvent(DS_EVENT_CAT_SCHEMA,
                                        DS_EVENT_SEV_ALWAYS,
                                        DIRLOG_SCHEMA_DELETED_LOCALIZED_INDEX,
                                        szInsertSz(achIndexName), 0, 0);
                               break;

                           default:
                               LogEvent(DS_EVENT_CAT_SCHEMA,
                                        DS_EVENT_SEV_ALWAYS,
                                        DIRLOG_SCHEMA_DELETE_LOCALIZED_INDEX_FAIL,
                                        szInsertSz(achIndexName), szInsertUL(err), 0);
                               break;
                           }
                       }
                       continue;
                    }
                    else if(achIndexName[sizeof(SZATTINDEXPREFIX)-1] == 'T') {
                        indexMask = fTUPLEINDEX;
                        aid = strtoul(&achIndexName[sizeof(SZATTINDEXPREFIX)+sizeof("T_") - 2], NULL, 16);
                    }
                    else {
                        indexMask = fATTINDEX;
                        aid = strtoul(&achIndexName[sizeof(SZATTINDEXPREFIX)-1], NULL, 16);
                    }

                    if((aid !=oldaid) &&           // Not the one we just did   and
                        (!(pAC = SCGetAttById(pTHS, aid)) || // doesn't have an attribute or
                        !(pAC->fSearchFlags & indexMask))) {  // attribute is not
                                                              // indexed anymore

                        // ok, we think this needs to die, but let's make sure
                        // by looking through the list of INDICES THAT MUST NOT DIE

                        char *attname = "?";

                        if(pAC && pAC->name)
                            attname = pAC->name;

                        oldaid = aid;

                        // We never need to keep substring indexes.
                        if( (fTUPLEINDEX == indexMask) || !AttInIndicesToKeep(aid)) {

                            // Yeah, kill it.
                            err = DBDeleteColIndex(aid,indexMask);

                            switch(err) {
                            case JET_errSuccess:
                                LogEvent(DS_EVENT_CAT_SCHEMA,
                                         DS_EVENT_SEV_ALWAYS,
                                         ((fTUPLEINDEX == indexMask) ?
                                            DIRLOG_SCHEMA_DELETED_TUPLE_INDEX :
                                            DIRLOG_SCHEMA_DELETED_INDEX),
                                         szInsertSz(attname), szInsertUL(aid), 0);
                                DPRINT3(0, "Deleted index '%s' for attname = %s attid = %d\n",
                                        achIndexName, attname, aid);
                                break;

                            default:
                                LogEvent(DS_EVENT_CAT_SCHEMA,
                                         DS_EVENT_SEV_ALWAYS,
                                         ((fTUPLEINDEX == indexMask) ?
                                            DIRLOG_SCHEMA_DELETE_TUPLE_INDEX_FAIL :
                                            DIRLOG_SCHEMA_DELETE_INDEX_FAIL),
                                         szInsertSz(attname), szInsertUL(aid), szInsertUL(err));
                                DPRINT4(0, "Failed to delete index '%s' attname = %s attid = %d err = %d\n",
                                        achIndexName, attname, aid, err);
                                break;
                            }
                            continue;
                        }
                    }

                    numValidIndexes++;

               } while (JetMove(jsid, jtid, JET_MoveNext, JET_bitMoveKeyNE) == 0);

               JetCloseTable(jsid, jtid);


               // we read the number of MaxTables only once
               if (gulMaxTables == 0) {
                   if (GetConfigParam(
                               DB_MAX_OPEN_TABLES,
                               &gulMaxTables,
                               sizeof(gulMaxTables))) {
                       gulMaxTables = 500;
                   }
               }

               // the number of total tables is the number of indexes in
               // the data table plus 100 to account for all the tables 
               // + the indexes in the various tables + other 
               numValidIndexes += 100;

               // we are only interested in increasing the number of MaxTables
               // we don't handle decreasing this number
               if (gulMaxTables < numValidIndexes) {
                   
                   DPRINT1 (0, "Writing max open tables to registry: %d\n", numValidIndexes);

                   if (SetConfigParam (DB_MAX_OPEN_TABLES, 
                                       REG_DWORD, 
                                       &numValidIndexes,
                                       sizeof(numValidIndexes))) {

                       DPRINT1 (0, "Error writing max open tables to registry: %d\n", numValidIndexes);
                   }
                   else {
                       gulMaxTables = numValidIndexes;
                   }
               }
            }
        } /* DoCleanupAndCreateAllIndices */


        // Before removing unused columns and creating indices for attributes
        // that needs one but doesn't have any, make sure the searchFlag entry
        // in the attcache for each attribute in the IndicesToKeep table has
        // the correct value for the type of indices they must have. Otherwise
        // set it to the correct value so that (1) if by chance they do not have
        // the indices, it will be created in the next part and (2) searches using
        // this schema cache later will see the correct searchFlag value for
        // the indices irrespective of whether the user changes it or not

        // Do not check the last entry in the table, which is just a sentinel
        // for searches

        for (i=0; i<cIndicesToKeep-1; i++) {

            DWORD bitsToOR = 0;

            // get the attcache
            pAC = SCGetAttById(pTHS, IndicesToKeep[i].attrType);

            // these attributes must always be there in the schema
            if (!pAC) {
                // something wrong, but not fatal
                DPRINT1(0,"Cannot find attcache entry for %d\n", IndicesToKeep[i].attrType);
                continue;
            }

            // ok, got the attcache. Check the search flag value
            // In particular, check if all index bits that are supposed
            // to be there are there or not; if not, add them to searchFlags

            bitsToOR = IndicesToKeep[i].indexType & INDEX_BITS_MASK;


            if ( bitsToOR  != (pAC->fSearchFlags & INDEX_BITS_MASK) ) {

                // they are different, just bit-OR all the bits in
                // the table just in case some are missing

                pAC->fSearchFlags |= bitsToOR;


                // since we deliberately change the
                // searchFlags, we have to set the index names too

                // set ATTINDEX
                if ((pAC->fSearchFlags & fATTINDEX) && (!pAC->pszIndex)) {

                    DBGetIndexName (pAC, 
                                    fATTINDEX, 
                                    DS_DEFAULT_LOCALE, 
                                    szIndexName, sizeof (szIndexName));
                    lenIndexName = strlen (szIndexName) + 1;
                    if (SCCalloc(&pAC->pszIndex, 1, lenIndexName)) {
                        return 1;
                    }
                    memcpy (pAC->pszIndex, szIndexName, lenIndexName);
                }

                // set PDNTATTINDEX
                if ((pAC->fSearchFlags & fPDNTATTINDEX) &&
                                              (!pAC->pszPdntIndex)) {

                    DBGetIndexName (pAC, 
                                    fPDNTATTINDEX, 
                                    DS_DEFAULT_LOCALE, 
                                    szIndexName, sizeof (szIndexName));
                    lenIndexName = strlen (szIndexName) + 1;
                    if (SCCalloc(&pAC->pszPdntIndex, 1, lenIndexName)) {
                        return 1;
                    }
                    memcpy (pAC->pszPdntIndex, szIndexName, lenIndexName);
                }
            }

        }


        /* remove unused columns and make list of indices to create */
        for (i=0; i<ATTCOUNT; i++) {
            pAC = (ATTCACHE*)(ahcId[i].pVal);
            if (pAC == FREE_ENTRY) {
                continue;
            }

            if (eServiceShutdown)
            {
                return 0;
            }

            if ( (ahcId[i].pVal && !(pAC->name))
                     // temporary cleanup code since we allowed creation of
                     // columns for these also in mkdit code. Fixed with this.
                     // Take this condition off after B3 RC1
                     || (pAC && pAC->jColid && (pAC->bIsConstructed || pAC->ulLinkID)) ) {
                /* looks like dead att */
                /* cleanup if asked for */
                if (NO_CLEANUP) {
                    // we want to defer cleanup
                    continue;
                }

                if (ahcId[i].pVal && !(pAC->name)) {
                    err = JET_errColumnInUse;
                }
                else {
                    err = DBDeleteCol(pAC->id, pAC->syntax);
                }
                
                switch(err) {
                case JET_errSuccess:
                    LogEvent(DS_EVENT_CAT_SCHEMA,
                        DS_EVENT_SEV_ALWAYS,
                        DIRLOG_SCHEMA_DELETED_COLUMN,
                        szInsertUL(pAC->jColid), szInsertUL(pAC->id), 0);

                    // remember that we deleted at least one column this time
                    fColDeleted = TRUE;

                    break;
                case JET_errColumnInUse:
                    LogEvent(DS_EVENT_CAT_SCHEMA,
                        DS_EVENT_SEV_ALWAYS,
                        DIRLOG_SCHEMA_DELETED_COLUMN_IN_USE,
                        szInsertUL(pAC->jColid), szInsertUL(pAC->id), 0);
                    break;

                default:
                    LogEvent(DS_EVENT_CAT_SCHEMA,
                        DS_EVENT_SEV_ALWAYS,
                        DIRLOG_SCHEMA_DELETE_COLUMN_FAIL,
                        szInsertUL(pAC->jColid), szInsertUL(pAC->id), szInsertUL(err));
                    break;
                }

            }
            else if(pAC && pAC->fSearchFlags &&
                        !(pAC->bIsConstructed) && !(pAC->ulLinkID) ) {

                DWORD fMissing = FALSE;
                DWORD MissingIndexes = 0;

                // This needs an index, does it have one?  This is done here
                // rather than at the time we add the column (scaddatt) so
                // that we can batch a list of new indices needed.

                // If we want to create just selected indices this
                // time around, check if this is one of those, else
                // just continue with the next one

                if ( CREATE_SELECTED_INDICES  &&
                    !AttInIndicesToKeep(pAC->id) ) {
                    // we don't need to create this one now even
                    // if it is missing
                    continue;
                }

                if(pAC->fSearchFlags & fATTINDEX) {
                    // needs a normal index
                    Assert (pAC->pszIndex != NULL);
                    if(err=JetSetCurrentIndex(pDB->JetSessID,
                                              pDB->JetObjTbl,
                                              pAC->pszIndex     )) {
                        DPRINT2(0,"Need to create index %s (%d)\n", pAC->pszIndex, err);
                        LogEvent(DS_EVENT_CAT_SCHEMA,
                            DS_EVENT_SEV_ALWAYS,
                            DIRLOG_SCHEMA_INDEX_NEEDED,
                            szInsertSz(pAC->name), szInsertSz(pAC->pszIndex), szInsertInt(err));

                        fMissing = TRUE;
                        MissingIndexes |= fATTINDEX;
                    }
                }
                if(pAC->fSearchFlags & fTUPLEINDEX) {
                    // needs a tuple index
                    Assert (pAC->pszTupleIndex != NULL);
                    if(err=JetSetCurrentIndex(pDB->JetSessID,
                                              pDB->JetObjTbl,
                                              pAC->pszTupleIndex     )) {
                        DPRINT2(0,"Need to create index %s (%d)\n", pAC->pszTupleIndex, err);
                        LogEvent(DS_EVENT_CAT_SCHEMA,
                            DS_EVENT_SEV_ALWAYS,
                            DIRLOG_SCHEMA_INDEX_NEEDED,
                            szInsertSz(pAC->name), szInsertSz(pAC->pszTupleIndex), szInsertInt(err));

                        fMissing = TRUE;
                        MissingIndexes |= fTUPLEINDEX;
                    }
                }
                if(pAC->fSearchFlags & fPDNTATTINDEX) {
                    
                    ULONG j;

                    // needs a PDNT index
                    Assert (pAC->pszPdntIndex != NULL);

                    if(err=JetSetCurrentIndex(pDB->JetSessID,
                                              pDB->JetObjTbl,
                                              pAC->pszPdntIndex      )) {
                        DPRINT2(0,"Need to create index %s (%d)\n", pAC->pszPdntIndex, err);
                        LogEvent(DS_EVENT_CAT_SCHEMA,
                            DS_EVENT_SEV_ALWAYS,
                            DIRLOG_SCHEMA_INDEX_NEEDED,
                            szInsertSz(pAC->name), szInsertSz(pAC->pszPdntIndex), szInsertInt(err));
                        fMissing = TRUE;
                        MissingIndexes |= fPDNTATTINDEX;
                    }

                    for(j=1; j<=gAnchor.ulNumLangs; j++) {
                        DBGetIndexName (pAC, 
                                        fPDNTATTINDEX, 
                                        gAnchor.pulLangs[j], 
                                        szIndexName, sizeof (szIndexName));

                        if(err=JetSetCurrentIndex(pDB->JetSessID,
                                                  pDB->JetObjTbl,
                                                  szIndexName      )) {
                            DPRINT2(0,"Need to create index %s (%d)\n", szIndexName, err);
                            LogEvent(DS_EVENT_CAT_SCHEMA,
                                DS_EVENT_SEV_ALWAYS,
                                DIRLOG_SCHEMA_INDEX_NEEDED,
                                szInsertSz(pAC->name), szInsertSz(szIndexName), szInsertInt(err));
                            fMissing = TRUE;
                            MissingIndexes |= fPDNTATTINDEX;
                        }
                    }
                }

                if(fMissing) {
                    if(!pNewIndices) {
                        if (SCCalloc(&pNewIndices, 1, 20*sizeof(DWORD))) {
                            return 1;
                        }
                        pNewIndices[0] = 20;
                        pNewIndices[1] = 2;
                    }
                    else if(pNewIndices[0] == pNewIndices[1] ) {
                        /* Need more room */
                        if (SCRealloc(&pNewIndices, 2*pNewIndices[0]*sizeof(DWORD))) {
                            return 1;
                        }
                        pNewIndices[0] *= 2;
                    }

                    if (pNewIndices && (pNewIndices[0] > pNewIndices[1])) {
                        pNewIndices[pNewIndices[1]] = pAC->id;
                        pNewIndices[pNewIndices[1]+1] = MissingIndexes;
                        pNewIndices[1] += 2;
                    }

                }
            }
        }

     } /* try-finally */
     __finally {
          DBClose(pDB, FALSE);
     }
    } /* try-except */
    __except (HandleMostExceptions(exceptErr=GetExceptionCode())) {
        DPRINT1(0,"NTDS SCCacheSchema3: Exception %d\n",exceptErr);
    }

    if (exceptErr) {
       // don't proceed on an exception
       return exceptErr;
    }

    /* Compute transitive closure on all classes */
    if ( ComputeCacheClassTransitiveClosure(FALSE) ) {
        // Error
        DPRINT(0,"SCCacheSchema3: Error closing classes\n");
        return 1;
    }

    AsyncCreateIndices(pNewIndices);

    // if we deleted a column, schedule a lazy cache update so that
    // any stale entries read from the deleted columns are flushed
    if (fColDeleted && DsaIsRunning()) {
       SCSignalSchemaUpdateLazy();
    }

    return (0);
}

int
ComputeCacheClassTransitiveClosure(BOOL fForce)

/*++
    Compute inherited mays/musts/poss-sups for all classes

    Return Value:
       0 on success
       non-0 on error
--*/

{
    THSTATE *pTHS=pTHStls;
    DECLARESCHEMAPTR
    ULONG i, j;
    ULONG *pul;
    int err = 0;
    CLASSCACHE *pCC;

    // if fForce is TRUE, mark all classes as not-closed first to force
    // the closure to be rebuilt
    if (fForce) {
       for (i=0; i<CLSCOUNT; i++) {
           if (ahcClass[i].pVal && ahcClass[i].pVal != FREE_ENTRY) {
               pCC = (CLASSCACHE*)(ahcClass[i].pVal);
               pCC->bClosed = 0;
               pCC->bClosureInProgress = 0;
           }
       }
    }


    /* Compute transitive closure on all classes */
    for (i=0; i<CLSCOUNT; i++) {
        if (ahcClass[i].pVal && ahcClass[i].pVal != FREE_ENTRY) {

            // Closing the class may take some time.
            // Check for service shutdown
            if (eServiceShutdown) {
                return 0;
            }

            pCC = (CLASSCACHE*)(ahcClass[i].pVal);
            err = scCloseClass(pTHS, pCC);
            if (err) {
               // Error closing class. Treat as fatal, since lots of things may
               // not work in an unpredictable manner
               DPRINT1(0, "Error closing class %s\n", pCC->name);
               LogEvent(DS_EVENT_CAT_SCHEMA,
                    DS_EVENT_SEV_MINIMAL,
                    DIRLOG_SCHEMA_CLOSURE_FAILURE,
                    szInsertUL(pCC->ClassId), szInsertSz(pCC->name), 0);
               return err;
            }
        }
    }

    if (fForce) {

       CLASSCACHE *pCCSup, *pCCSupTemp;

       // forcing everything to be rebuilt may have caused duplicates in
       // the subclassoflist, which are not removed by scCloseClass. 
       // Instead of removing duplicates by sorting and such, which will
       // change the order of the values, rebuild these values from the
       // chain of direct superclasses. We seem to maintain the order in
       // many places in code (note the order here affects the order in which
       // objectClass values are wriiten in SetClassInheritance)


       for (i=0; i<CLSCOUNT; i++) {
           if (ahcClass[i].pVal && ahcClass[i].pVal != FREE_ENTRY) {
               pCC = (CLASSCACHE*)(ahcClass[i].pVal);
               // don't do for top, which is special and needs nothing 
               if (pCC->ClassId == CLASS_TOP) {
                  continue;
               }
               j = 0;
               pCCSup = pCC;
               do {
                  pCC->pSubClassOf[j++] = pCCSup->MySubClass;
                  pCCSupTemp = pCCSup;
                  pCCSup = SCGetClassById(pTHS, pCCSup->MySubClass);
                  if (pCCSup == NULL) {
                     DPRINT1(0, "Cannot find classcache for %d\n", pCCSupTemp->MySubClass); 
                     Assert(FALSE);
                     return ERROR_DS_OBJ_CLASS_NOT_DEFINED;
                  }
               }
               while ( (pCCSup->ClassId != CLASS_TOP) && (j <= pCC->SubClassCount));
                  
               //j cannot be greater than exisiting subClassCount
               if (j > pCC->SubClassCount) {
                   Assert(FALSE);
                   return ERROR_DS_OPERATIONS_ERROR; 
               }
               pCC->SubClassCount = j;
           } /* if (ahcClass[i].pVal) */
      } /* for */

    }  /* if fForce */

    return 0;

}

int
scCloseSuperClassHelper (
        CLASSCACHE *pCC,
        CLASSCACHE *pCCSup
        )
/*++
    Helper routine that does bulk of the work of inheriting from a
    superclass (class in subclassof list) pointed to by pCCSup

    Returns 0 on success, non-0 on error
--*/
{
    // If we don't have a default SD, grab the parents.
    if(!pCC->pSD) {
        pCC->SDLen = pCCSup->SDLen;

        if(pCCSup->SDLen) {
           // The parent has a default SD.
           if (SCCalloc(&pCC->pSD, 1, pCCSup->SDLen)) {
               return 1;
           }
           pCC->SDLen = pCCSup->SDLen;
           memcpy(pCC->pSD, pCCSup->pSD, pCC->SDLen);
        }
    }
    if(!pCC->pStrSD) {

        if(pCCSup->pStrSD) {

            // The parent has a default SD.
            if (SCCalloc(&pCC->pStrSD, 1, pCCSup->cbStrSD)) {
                return 1;
            }
            pCC->cbStrSD = pCCSup->cbStrSD;
            memcpy(pCC->pStrSD, pCCSup->pStrSD, pCCSup->cbStrSD);
        }
    }

    pCC->bUsesMultInherit |= pCCSup->bUsesMultInherit;
    /* Do verification of rules for inheritance */
    switch(pCC->ClassCategory) {
         case DS_88_CLASS:
         case DS_STRUCTURAL_CLASS:
            if(pCC->bUsesMultInherit)  {
                /* Structural class with multiple inheritance, a no-no */
                LogEvent8(DS_EVENT_CAT_SCHEMA,
                          DS_EVENT_SEV_MINIMAL,
                          DIRLOG_SCHEMA_STRUCTURAL_WITH_MULT_INHERIT,
                          szInsertUL(pCC->ClassId), pCC->name,
                          szInsertUL(pCCSup->ClassId),
                          pCCSup->name, 0, 0, NULL, NULL);
            }
            break;

          case DS_ABSTRACT_CLASS:
            if(pCCSup->ClassCategory != DS_ABSTRACT_CLASS) {
                /* Abstract can only inherit from abstract */
                LogEvent8(DS_EVENT_CAT_SCHEMA,
                         DS_EVENT_SEV_MINIMAL,
                         DIRLOG_SCHEMA_ABSTRACT_INHERIT_NON_ABSTRACT,
                         szInsertUL(pCC->ClassId), pCC->name,
                         szInsertUL(pCCSup->ClassId),
                         pCCSup->name, 0, 0, NULL, NULL);

            }
            break;

          case DS_AUXILIARY_CLASS:
            if(pCCSup->ClassCategory == DS_STRUCTURAL_CLASS) {
                /* Auxiliary can not inherit from structural */
                LogEvent8(DS_EVENT_CAT_SCHEMA,
                         DS_EVENT_SEV_MINIMAL,
                         DIRLOG_SCHEMA_AUXILIARY_INHERIT_STRUCTURAL,
                         szInsertUL(pCC->ClassId), pCC->name,
                         szInsertUL(pCCSup->ClassId),
                         pCCSup->name, 0, 0, NULL, NULL);
            }
            break;
    }

    /* set class hierarchy, but not for top */
    if (pCC->ClassId != CLASS_TOP) {
         if (pCCSup->SubClassCount) {
              int cNew = pCC->SubClassCount + pCCSup->SubClassCount;
              if (pCCSup->SubClassCount) {
                    if (SCRealloc(&pCC->pSubClassOf, cNew*sizeof(ULONG))) {
                        return 1;
                    }
                    memcpy(&pCC->pSubClassOf[pCC->SubClassCount],
                        pCCSup->pSubClassOf,
                        pCCSup->SubClassCount*sizeof(ULONG));
                    pCC->SubClassCount = cNew;
               }
         }
    }
    else {
         /* this is top, mark it as subclass of none */
         /* as a hack, keep the one element array around for those who */
         /* believe in one trip for loops */
         pCC->SubClassCount = 0;
    }

    if (pCC != pCCSup) {        /* don't do this for top! */
         /* Inherit RDN Att id, if not specified */
         if (!pCC->RDNAttIdPresent) {
              pCC->RDNAttIdPresent = pCCSup->RDNAttIdPresent;
              pCC->RdnExtId = pCCSup->RdnExtId;
              pCC->RdnIntId = pCCSup->RdnIntId;
         }

         /* inherit must atts */
         if (pCC->MustCount == 0) {
              pCC->MustCount = pCCSup->MustCount;
              if (SCCalloc(&pCC->pMustAtts, 1, pCC->MustCount * sizeof(ULONG))) {
                  return 1;
              }
               memcpy(pCC->pMustAtts, pCCSup->pMustAtts,
                      pCC->MustCount * sizeof(ULONG));
          }
          else if (pCCSup->MustCount != 0) {
               if (SCRealloc(&pCC->pMustAtts,
                       (pCC->MustCount + pCCSup->MustCount) * sizeof(ULONG))) {
                   return 1;
                }
                memcpy(pCC->pMustAtts + pCC->MustCount, pCCSup->pMustAtts,
                       pCCSup->MustCount * sizeof(ULONG));
                pCC->MustCount += pCCSup->MustCount;
          }

          /* inherit may atts */
          if (pCC->MayCount == 0) {
               pCC->MayCount = pCCSup->MayCount;
               if (SCCalloc(&pCC->pMayAtts, 1, pCC->MayCount * sizeof(ULONG))) {
                   return 1;
               }
                memcpy(pCC->pMayAtts, pCCSup->pMayAtts,
                       pCC->MayCount * sizeof(ULONG));
          }
          else if (pCCSup->MayCount != 0) {
                if (SCRealloc(&pCC->pMayAtts,
                        (pCC->MayCount + pCCSup->MayCount) * sizeof(ULONG))) {
                    return 1;
                }
                memcpy(pCC->pMayAtts + pCC->MayCount, pCCSup->pMayAtts,
                       pCCSup->MayCount * sizeof(ULONG));
                pCC->MayCount += pCCSup->MayCount;
          }

          /* inherit poss-superiors */
          if (pCC->PossSupCount == 0) {
                pCC->PossSupCount = pCCSup->PossSupCount;
                if (SCCalloc(&pCC->pPossSup, 1, pCC->PossSupCount * sizeof(ULONG))) {
                    return 1;
                }
                memcpy(pCC->pPossSup, pCCSup->pPossSup,
                       pCC->PossSupCount * sizeof(ULONG));
           }
           else if (pCCSup->PossSupCount != 0) {
                if (SCRealloc(&pCC->pPossSup,
                        (pCC->PossSupCount + pCCSup->PossSupCount) * sizeof(ULONG))) {
                    return 1;
                }
                memcpy(pCC->pPossSup + pCC->PossSupCount, pCCSup->pPossSup,
                       pCCSup->PossSupCount * sizeof(ULONG));
                pCC->PossSupCount += pCCSup->PossSupCount;
           }
    }

    return 0;
}

int
scCloseAuxClassHelper (
        CLASSCACHE *pCC,
        CLASSCACHE *pCCAux
        )
/*++
    Helper routine that does bulk of the work of inheriting from a
    aux class (class in auxclassof list) pointed to by pCCAux

    Returns 0 on success, non-0 on error
--*/
{
    DWORD sMayCount   ;
    DWORD sMustCount  ;
    ATTRTYP* sMayList ;
    ATTRTYP* sMustList;

    if((pCCAux->ClassCategory != DS_AUXILIARY_CLASS) &&
          (pCCAux->ClassCategory != DS_88_CLASS)  ) {
           /* Illegal aux class */
           LogEvent8(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_SCHEMA_NOT_AUX,
                     szInsertUL(pCC->ClassId), szInsertSz(pCC->name),
                     szInsertUL(pCCAux->ClassId), szInsertSz(pCCAux->name),
                     0,0, NULL, NULL);
           // don't inherit from this one, but let inheritance continue
           // from other classes
           return 0;
     }

     sMayCount = pCC->MayCount;
     sMustCount= pCC->MustCount;
     sMayList  = pCC->pMayAtts;
     sMustList = pCC->pMustAtts;

     pCC->MayCount +=pCCAux->MayCount;
     pCC->MustCount+=pCCAux->MustCount;

     if (SCCalloc(&pCC->pMayAtts, pCC->MayCount ,sizeof(ATTRTYP))
         || SCCalloc(&pCC->pMustAtts, pCC->MustCount,sizeof(ATTRTYP))) {
          return 1;
     }

     CopyMemory(pCC->pMayAtts ,sMayList ,sMayCount *sizeof(ATTRTYP));
     CopyMemory(pCC->pMustAtts,sMustList,sMustCount*sizeof(ATTRTYP));

     CopyMemory(&(pCC->pMayAtts[sMayCount])  ,pCCAux->pMayAtts ,pCCAux->MayCount *sizeof(ATTRTYP));
     CopyMemory(&(pCC->pMustAtts[sMustCount]),pCCAux->pMustAtts,pCCAux->MustCount*sizeof(ATTRTYP));

     SCFree(&sMayList);
     SCFree(&sMustList);

     return 0;
}


void scLogEvent(
     ULONG cat,
     ULONG sev,
     MessageId msg,
     ULONG arg1,
     char *arg2,
     ULONG arg3
     )
/*++
     Wrapper around LogEvent() so as to not bloat the stack size of
     scCloseClass, which is recursive
--*/
{
     LogEvent( cat, sev, msg,
               szInsertUL(arg1),
               szInsertSz(arg2),
               szInsertUL(arg3)
             );
}

int
scCloseClass (
        THSTATE *pTHS,
        CLASSCACHE *pCC
        )
/*++
   Compute the transitive closure of the properties of a class, including
   its list of must have and may have attributes, and the class hierarchy.

   Return Value:
      0 on success
      non-0 on error (right now, errors only on allo failures)
--*/
{
    int i,j,k, err = 0;
    int iSubClass,cSubClass;
    int iAuxClass,cAuxClass;
    ATTCACHE *pAC;
    ULONG * pul;
    ULONG * pul2;

    if (pCC->bClosed) {
        return 0;
    }
    if (pCC->bClosureInProgress) {
        if (pCC->ClassId != CLASS_TOP) {
            /* don't whine if TOP */
            scLogEvent(DS_EVENT_CAT_SCHEMA,
                  DS_EVENT_SEV_MINIMAL,
                  DIRLOG_SCHEMA_CIRCULAR_INHERIT,
                  pCC->ClassId, pCC->name, 0);
        }
        return 0;
    }

    pCC->bClosureInProgress = 1;

    cSubClass = pCC->SubClassCount;
    for (iSubClass=0; iSubClass<cSubClass; iSubClass++) {
        CLASSCACHE *pCCSup;

        /* find the super class and make sure it's closed */
        pCCSup = SCGetClassById(pTHS, pCC->pSubClassOf[iSubClass]);
        if (NULL == pCCSup) {
            /* Couldn't find superclass in cache */
            scLogEvent(DS_EVENT_CAT_SCHEMA,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_SCHEMA_INVALID_SUPER,
                  pCC->ClassId, pCC->name,
                  pCC->pSubClassOf[iSubClass]);
            continue;
        }
        if ( err = scCloseClass(pTHS, pCCSup)) {
           DPRINT1(0,"SCCloseClass: Error closing sup class %s\n", pCCSup->name);
           scLogEvent(DS_EVENT_CAT_SCHEMA,
                  DS_EVENT_SEV_MINIMAL,
                  DIRLOG_SCHEMA_CLOSURE_FAILURE,
                  pCCSup->ClassId, pCCSup->name, 0);
           return err;
        }

        if (err = scCloseSuperClassHelper(pCC, pCCSup)) {
           return err;
        }

    }


    cAuxClass = pCC->AuxClassCount;
    for (iAuxClass=0; iAuxClass<cAuxClass; iAuxClass++) {
        CLASSCACHE *pCCAux;

        /* find the auxiliary class and make sure it's closed */
        pCCAux = SCGetClassById(pTHS, pCC->pAuxClass[iAuxClass]);
        if (NULL == pCCAux) {
            /* Couldn't find aux class in cache */
            scLogEvent(DS_EVENT_CAT_SCHEMA,
                       DS_EVENT_SEV_MINIMAL,
                       DIRLOG_SCHEMA_INVALID_AUX,
                       pCC->ClassId, pCC->name,
                       pCC->pAuxClass[iAuxClass]);
            continue;
        }
        // if class-ids are same, same class, so no point closing it.
        // Actually, closing the class w.r.to itself makes the alloc/realloc/copy
        // code in scCloseAuxClassHelper quite complex to ensure that we do
        // not write past allocated buffers. Other than that, there is no harm
        // really as this operation only adds the same may/musts to the list
        // again which gets removed during duplicate removal.
        // On another note, the reason we have to do this in spite of the
        // bClosureInProgress bit setting (that is there mainly for this purpose)
        // is that that mechanism can detect circular inherit when all the
        // classcaches are obtained from the same cache. However, we often
        // build a cache from the dit, and then close it against the schema cache,
        // so on the first scCloseClass call, the classcache on which the bit is
        // set is not the same as the classcache for the same class in the cache.


        if (pCC->ClassId == pCCAux->ClassId) {
           DPRINT1(0,"Direct circular inherit in class %s\n", pCC->name);
           scLogEvent(DS_EVENT_CAT_SCHEMA,
                  DS_EVENT_SEV_MINIMAL,
                  DIRLOG_SCHEMA_CIRCULAR_INHERIT,
                  pCC->ClassId, pCC->name, 0);
           continue;
        }

        if ( err = scCloseClass(pTHS, pCCAux)) {
           DPRINT1(0, "scCloseClass: Error closing aux class %s\n", pCCAux->name);
           scLogEvent(DS_EVENT_CAT_SCHEMA,
                  DS_EVENT_SEV_MINIMAL,
                  DIRLOG_SCHEMA_CLOSURE_FAILURE,
                  pCCAux->ClassId, pCCAux->name, 0);
           return err;
        }

        if (err = scCloseAuxClassHelper(pCC,pCCAux)) {
            return err;
        }

    } //for (iAuxClass=0; iAuxClass<cAuxClass; iAuxClass++)



    /* sort, verify, and trim the attributes, if any */
    if (!(pAC = SCGetAttById(pTHS, pCC->RdnIntId))) {
        scLogEvent(DS_EVENT_CAT_SCHEMA,
              DS_EVENT_SEV_EXTENSIVE,
              DIRLOG_SCHEMA_INVALID_RDN,
              pCC->ClassId, pCC->name, pCC->RdnIntId);
    }

    // Remove Duplicates
    if (pCC->MustCount) {
        if(pCC->MyMustCount) {
            // I had some native musts (not inherited)
            qsort(pCC->pMyMustAtts,
                  pCC->MyMustCount,
                  sizeof(ULONG),
                  CompareAttrtyp);
        }

        qsort(pCC->pMustAtts, pCC->MustCount, sizeof(ULONG), CompareAttrtyp);

        for (i=0, j=0, pul=pCC->pMustAtts;
             i<(int)pCC->MustCount;
             j++) {

            pul[j] = pul[i];

            while( i<(int)pCC->MustCount && (pul[i] == pul[j]))
                i++;

        }

        pCC->MustCount = j;

    }

    // Remove Duplicates
    if (pCC->MayCount) {
        if(pCC->MyMayCount) {
            // I had some native mays (not inherited)
            qsort(pCC->pMyMayAtts,
                  pCC->MyMayCount,
                  sizeof(ULONG),
                  CompareAttrtyp);
        }

        qsort(pCC->pMayAtts, pCC->MayCount, sizeof(ULONG), CompareAttrtyp);

        for (i=0, j=0, pul=pCC->pMayAtts;
             i<(int)pCC->MayCount;
             j++) {

            pul[j] = pul[i];


            while( i<(int)pCC->MayCount && (pul[i] == pul[j]))
                i++;
        }

        pCC->MayCount = j;

    }

    // Remove Duplicates
    if (pCC->PossSupCount) {
        if(pCC->MyPossSupCount) {
            // I had some native mays (not inherited)
            qsort(pCC->pMyPossSup,
                  pCC->MyPossSupCount,
                  sizeof(ULONG),
                  CompareAttrtyp);
        }

        qsort(pCC->pPossSup, pCC->PossSupCount, sizeof(ULONG), CompareAttrtyp);

        for (i=0, j=0, pul=pCC->pPossSup;
             i<(int)pCC->PossSupCount;
             j++) {

            pul[j] = pul[i];


            while( i<(int)pCC->PossSupCount && (pul[i] == pul[j]))
                i++;
        }

        pCC->PossSupCount = j;

    }

    // Finally, trim out any may haves that are also must haves.
    if (pCC->MustCount && pCC->MayCount) {
        BOOL fChanged = FALSE;

        pul=pCC->pMustAtts;
        pul2 = pCC->pMayAtts;
        for(i=0,j=0;i < (int)pCC->MustCount;i++) {
            while ((j < (int)pCC->MayCount) && (pul[i] > pul2[j])) {
                j++;
            }
            if(j >= (int)pCC->MayCount)
                break;

            if(pul[i] == pul2[j]) {
                // This attribute is both a may and must.  Trim it
                memcpy(&pul2[j],
                       &pul2[j+1],
                       (pCC->MayCount -1 - j)*sizeof(ULONG));
                pCC->MayCount--;
                fChanged = TRUE;
            }
        }
        if(fChanged) {
            if (SCRealloc(&pCC->pMayAtts, pCC->MayCount * sizeof(ULONG))) {
                return 1;
            }
        }
    }
    
    pCC->bClosed = 1;
    pCC->bClosureInProgress = 0;

    return 0;
}



/////////////////////////////////////////////////////////////////////////
// Function to either free global schema cache memory immediately, or
// reschedule it for delayed freeing depending certain conditions.
//
// Conditions for immediate freeing: Either fImmediate is TRUE in
//                                   the SCHEMARELEASE structure passed
//                                   in  or if the RefCount of
//                                   the schema cache is 0
//
// Arguments: buffer -- ptr to a SCHEMARELEASE structure
//            ppvNext - parameter for next schedule
//            pTimeNext - time of next reschedule
////////////////////////////////////////////////////////////////////////

void
DelayedFreeSchema(
    IN  void *  buffer,
    OUT void ** ppvNext,
    OUT DWORD * pcSecsUntilNextIteration
    )
{
    SCHEMARELEASE *ptr = (SCHEMARELEASE *) buffer;
    SCHEMAPTR *pSchemaPtr = ptr->pSchema;
    BOOL fImmediate = ptr->fImmediate;

    if ( (!fImmediate) && (pSchemaPtr->RefCount != 0)) {
      // Some thread still referring to this, so reschedule for
      // checking after another hour
      // Increment cTimesRescheduled to note how many times the task
      // has been rescheduled. Can be used to free after some
      // large no. of reschedules if necessary

      (ptr->cTimesRescheduled)++;
      (*ppvNext) = buffer;
      (*pcSecsUntilNextIteration) = gdwDelayedMemFreeSec;
    } else {
      // either immediate freeing is requested during install or
      // no thread referring to this cache so free immediately

        SCFreeSchemaPtr(&pSchemaPtr);
        SCFree(&ptr);
    }
}


/*
 * Unload the entire schema, all attributes and classes.
 */
void SCUnloadSchema(BOOL fUpdate)
{

    ULONG i;
    DWORD j=1;
    SCHEMARELEASE *ptr;


    if (iSCstage == 0) {
        // This means the schema cache is trying to be unloaded when it
        // hasn't even been created.  This is ok since during initialization
        // is it possible to be in the shutdown path without having created
        // a schema cache.
        CurrSchemaPtr = 0;
        return;
    }

    {

        // enqueue the schema cache pointer for
        // delayed freeing if necessary.


        if (SCCalloc(&ptr, 1, sizeof(SCHEMARELEASE))) {
            return;
        }
        ptr->pSchema = CurrSchemaPtr;
        ptr->cTimesRescheduled = 1;

        if (DsaIsInstalling()) {

            ptr->fImmediate = TRUE;

            // free memory immediately
            DelayedFreeSchema(ptr, NULL, NULL);
        }
        else {
            ptr->fImmediate = FALSE;
            // insert in task q for delayed freeing
            // Ref count first checked after one minute
            InsertInTaskQueue(TQ_DelayedFreeSchema, ptr, 60);
        }

        if (!fUpdate) {
           // This is not an unload due to schema update

            CurrSchemaPtr=0;

            iSCstage = 0;
        }

    }
}


/*
 * Update a classcache in the cache.  Used when the DMD object representing
 * the class is modified while the DS is running.
 * NOTE - To avoid leaving the classcache structure in an inconsistent state
 * or freeing pointers in an unsafe manner, we construct an entire new
 * classcache and then replace the hash table entries.
 */
int SCModClassSchema (THSTATE *pTHS, ATTRTYP ClassId)
{
    DECLARESCHEMAPTR

    CLASSCACHE * pCCold, *pCCnew;
    int err;
    ULONG i;

    pCCold = SCGetClassById(pTHS, ClassId);
    if (NULL == pCCold) {
        return TRUE;    // Caller reports error
    }

    // Update values from database. Cache entry is already indexed by
    // the hash tables since it's an existing entry.

    // The schema is being modified on the parent during dcpromo. This
    // may cause a defunct class to supercede an active class. This
    // should be okay because replication will still update instances
    // correctly. If this appears to be a problem, then compare the
    // active entry in ahcClass (pCCOld) with the dup entries in
    // ahcClassAll and, if needed, supercede the active entry
    err = SCBuildCCEntry (pCCold, &pCCnew);
    if (err) {
        return(err);
    }

	/* touch up the hash tables */
	for (i=0; i<CLSCOUNT; i++) {
	    if (ahcClass[i].pVal == pCCold) {
		ahcClass[i].pVal = pCCnew;
		break;
	    }
	}
	for (i=0; i<CLSCOUNT; i++) {
	    if (ahcClassName[i].pVal == pCCold) {
		ahcClassName[i].pVal = pCCnew;
		break;
	    }
	}
	for (i=0; i<CLSCOUNT; i++) {
	    if (ahcClassAll[i].pVal == pCCold) {
		ahcClassAll[i].pVal = pCCnew;
		break;
	    }
	}

    SCFreeClasscache(&pCCold);

    return(err);
}

int
SCModAttSchema (
        THSTATE *pTHS,
        ATTRTYP attrid
        )
/*
 * Update an attcache in the cache.  Used when the DMD object representing
 * the class is modified while the DS is running.
 * NOTE - To avoid leaving the attcache structure in an inconsistent state
 * or freeing pointers in an unsafe manner, we construct an entire new
 * attcache and then replace the hash table entries.
 */
{
    DECLARESCHEMAPTR

    ATTCACHE *pACold, *pACnew;
    int err;
    ULONG i;

    /* Look up existing entry by id */

    if (NULL == (pACold = SCGetAttById(pTHS, attrid))) {
        return TRUE;    /* Caller reports error */
    }

    /* Update values from database. Cache entry is already indexed by */
    /* the hash tables since it's an existing entry. */

    err = SCBuildACEntry (pACold, &pACnew);
    if (err) {
        return(err);
    }

	/* touch up the hash tables */
	for (i=0; i<ATTCOUNT; i++) {
	    if (ahcId[i].pVal == pACold) {
		ahcId[i].pVal = pACnew;
		break;
	    }
	}
	for (i=0; i<ATTCOUNT; i++) {
	    if (ahcExtId[i].pVal == pACold) {
		ahcExtId[i].pVal = pACnew;
		break;
	    }
	}
	for (i=0; i<ATTCOUNT; i++) {
	    if (ahcCol[i].pVal == pACold) {
		ahcCol[i].pVal = pACnew;
		break;
	    }
	}
	for (i=0; i<ATTCOUNT; i++) {
	    if (ahcMapi[i].pVal == pACold) {
		ahcMapi[i].pVal = pACnew;
		break;
	    }
	}
	for (i=0; i<ATTCOUNT; i++) {
	    if (ahcLink[i].pVal == pACold) {
		ahcLink[i].pVal = pACnew;
		break;
	    }
	}
	for (i=0; i<ATTCOUNT; i++) {
	    if (ahcName[i].pVal == pACold) {
		ahcName[i].pVal = pACnew;
		break;
	    }
	}

    SCFreeAttcache(&pACold);

    return err;
}

int
SCBuildACEntry (
        ATTCACHE *pACold,
        ATTCACHE **ppACnew
        )
// This routine allocates and fills in the fields in the ATTCACHE structure by
// reading the attributes from the database. If an already existing ATTCACHE
// structure is also given, the database columnid from the existing ATTCACHE is
// copied to the new attcache.
//
// N.B. The routines SCBuildACEntry and scAddAtt work in parallel, with
//      SCBuildACEntry taking a positioned database record as input and
//      SCAddAtt taking an ENTINF.  They both produce an ATTCACHE as output,
//      and any changes made to one routine's processing must be made to
//      the other's as well.
//
// Return Value:
//    0 on success
//    non-0 on error
//
{
    THSTATE *pTHS=pTHStls;
    ATTCACHE     *pAC, *ppACs[NUMATTATT];
    DWORD        i, cOutAtts;
    ATTR         *pAttr;
    BOOL         fFoundID, fFoundExtID, fFoundAttSyntax, fFoundName, fMallocFailed;
    BOOL         fFoundBadAttSyntax = FALSE;

    char         szIndexName [MAX_INDEX_NAME];      //used to create cached index names
    int          lenIndexName;


    if (SCCalloc(ppACnew, 1, sizeof(ATTCACHE))) {
       return(SetSysError(ENOMEM, ERROR_DS_SCHEMA_ALLOC_FAILED));
    }

    pAC = (*ppACnew);                      // Speed hack

    fMallocFailed = fFoundID = fFoundExtID = fFoundAttSyntax = fFoundName = FALSE;

    // Get the attcache pointer for all the attributes we are interested
    for(i=0;i<NUMATTATT;i++) {
        ppACs[i] = SCGetAttById(pTHS, AttributeSelList[i].attrTyp);
    }

    // Get the attributes
    DBGetMultipleAtts(pTHS->pDB, NUMATTATT, &ppACs[0], NULL, NULL,
                      &cOutAtts, &pAttr, DBGETMULTIPLEATTS_fGETVALS, 0);

    // Reset the jet column id.
    if(pACold)
        pAC->jColid = pACold->jColid;

    for(i=0;i<cOutAtts && !fMallocFailed;i++) {
        PUCHAR pVal=pAttr[i].AttrVal.pAVal->pVal;
        DWORD  valLen =pAttr[i].AttrVal.pAVal->valLen;
        switch(pAttr[i].attrTyp) {
        case ATT_ATTRIBUTE_ID:
            pAC->Extid = *(SYNTAX_OBJECT_ID *)pVal;
            fFoundExtID = TRUE;
            break;
        case ATT_MS_DS_INTID:
            pAC->id = *(SYNTAX_OBJECT_ID *)pVal;
            fFoundID = TRUE;
            break;
        case ATT_ATTRIBUTE_SYNTAX:
            pAC->syntax = (UCHAR) (0xFF & *(SYNTAX_INTEGER *)pVal);
            fFoundAttSyntax = TRUE;
            // if this is done as part of a originating attribute add operation,
            // verify that the prefix is correct. The suffix will be
            // verified in the syntax mismatch test

            if ( (pTHS->SchemaUpdate == eSchemaAttAdd) 
                    && !pTHS->fDRA && !DsaIsInstalling() ) {
               if ( ((0xFFFF0000 & *(SYNTAX_INTEGER *)pVal) >> 16) != _dsP_attrSyntaxPrefIndex) {
                   // top 16 bits don't match the index. mismatch
                   fFoundBadAttSyntax = TRUE;
               }
            }
            break;
        case  ATT_LDAP_DISPLAY_NAME:
            // The admin display name read from the DB is currently in raw
            // (Unicode) format.  Single-byte it.
            pAC->nameLen = valLen;
            if (SCCalloc(&pAC->name, 1, valLen + 1)) {
                fMallocFailed = TRUE;
            }
            else {
                pAC->nameLen = WideCharToMultiByte(
                        CP_UTF8,
                        0,
                        (LPCWSTR)pVal,
                        (valLen/sizeof(wchar_t)),
                        pAC->name,
                        valLen,
                        NULL,
                        NULL);

                pAC->name[pAC->nameLen]= '\0';
                fFoundName=TRUE;
            }
            break;
        case ATT_IS_SINGLE_VALUED:
            pAC->isSingleValued = *(SYNTAX_BOOLEAN *)pVal;
            break;
        case  ATT_SEARCH_FLAGS:
            pAC->fSearchFlags = *(SYNTAX_INTEGER *)pVal;
            break;
        case  ATT_SYSTEM_ONLY:
            pAC->bSystemOnly = *(SYNTAX_INTEGER *)pVal;
            break;
        case ATT_RANGE_LOWER:
            pAC->rangeLowerPresent = TRUE;
            pAC->rangeLower = *(SYNTAX_INTEGER *)pVal;
            break;
        case  ATT_RANGE_UPPER:
            pAC->rangeUpperPresent = TRUE;
            pAC->rangeUpper = *(SYNTAX_INTEGER *)pVal;
            break;
        case  ATT_MAPI_ID:
            pAC->ulMapiID = *(SYNTAX_INTEGER *)pVal;
            break;
        case ATT_LINK_ID:
            pAC->ulLinkID = *(SYNTAX_INTEGER *)pVal;
            break;
        case ATT_OM_SYNTAX:
            pAC->OMsyntax = *(SYNTAX_INTEGER *)pVal;
            break;
        case ATT_OM_OBJECT_CLASS:
            pAC->OMObjClass.length = valLen;
            if (SCCalloc(&pAC->OMObjClass.elements, 1, valLen)) {
                fMallocFailed = TRUE;
            }
            else
                memcpy(pAC->OMObjClass.elements, (UCHAR *)pVal, valLen);
            break;
        case ATT_EXTENDED_CHARS_ALLOWED:
            pAC->bExtendedChars =(*(SYNTAX_BOOLEAN*)pVal?1:0);
            break;
        case ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET:
            if (*(SYNTAX_BOOLEAN*)pVal)
            {
                pAC->bMemberOfPartialSet = TRUE;
            }
            break;
        case ATT_IS_DEFUNCT:
            pAC->bDefunct =(*(SYNTAX_BOOLEAN*)pVal?1:0);
            break;
        case ATT_SYSTEM_FLAGS:
            if (*(DWORD*)pVal & FLAG_ATTR_NOT_REPLICATED) {
                pAC->bIsNotReplicated = TRUE;
            }
            if (*(DWORD*)pVal & FLAG_ATTR_REQ_PARTIAL_SET_MEMBER) {
                pAC->bMemberOfPartialSet = TRUE;
            }
            if (*(DWORD*)pVal & FLAG_ATTR_IS_CONSTRUCTED) {
                pAC->bIsConstructed = TRUE;
            }
            if (*(DWORD*)pVal & FLAG_ATTR_IS_OPERATIONAL) {
                pAC->bIsOperational = TRUE;
            }
            if (*(DWORD*)pVal & FLAG_SCHEMA_BASE_OBJECT) {
                pAC->bIsBaseSchObj = TRUE;
            }
            if (*(DWORD*)pVal & FLAG_ATTR_IS_RDN) {
                pAC->bIsRdn = TRUE;
                pAC->bFlagIsRdn = TRUE;
            }
            break;

        case ATT_OBJECT_GUID:
            // Needed to choose a winner when OIDs collide
            memcpy(&pAC->objectGuid, pVal, sizeof(pAC->objectGuid));
            Assert(valLen == sizeof(pAC->objectGuid));
            break;

        default:
            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_SCHEMA_SURPLUS_INFO,
                     szInsertUL(pAttr[i].attrTyp), 0, 0);
            break;
        }
    }
    if (!fFoundID) {
        fFoundID = fFoundExtID;
        pAC->id = pAC->Extid;
    }

    if(fMallocFailed || !fFoundID || !fFoundAttSyntax || !fFoundName) {
        SCFreeAttcache(&pAC);

        if(fMallocFailed) {
            return(SetSysError(ENOMEM, ERROR_DS_SCHEMA_ALLOC_FAILED));
        }
        else if(!fFoundID) {
            DPRINT(2,"Couldn't retrieve the schema's attribute id\n");
            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_ATT_SCHEMA_REQ_ID,
                     szInsertSz(GetExtDN(pTHS,pTHS->pDB)),
                     NULL,
                     NULL);

            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_ATT_SCHEMA_REQ_ID);
        }
        else if(!fFoundAttSyntax) {
            DPRINT(2,"Couldn't retrieve the schema's attribute syntax\n");
            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_ATT_SCHEMA_REQ_SYNTAX,
                     szInsertSz(GetExtDN(pTHS,pTHS->pDB)),
                     NULL,
                     NULL);
            return SetSvcError(SV_PROBLEM_DIR_ERROR,
                               ERROR_DS_ATT_SCHEMA_REQ_SYNTAX);
        }
        else {
            DPRINT(2,"Couldn't retrieve the schema's attribute name\n");
            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_MISSING_EXPECTED_ATT,
                     szInsertUL(ATT_LDAP_DISPLAY_NAME),
                     szInsertSz(GetExtDN(pTHS,pTHS->pDB)),
                     NULL);
            return SetSvcError(SV_PROBLEM_DIR_ERROR,
                               ERROR_DS_MISSING_EXPECTED_ATT);
        }
    }

    if (fFoundBadAttSyntax) {
        // found bad attribute syntax in the course of a new attribute add
        // this is a schema validation error, user has input a bad syntax.
        // Note that at this point, we have pAC->name to log, or else we would
        // have returned above when fFoundName was found to be False. 
        LogEvent(DS_EVENT_CAT_SCHEMA,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_SCHEMA_VALIDATION_FAILED,
                 szInsertSz(pAC->name),
                 szInsertInt(ERROR_DS_BAD_ATT_SCHEMA_SYNTAX), 0);
        return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                           ERROR_DS_BAD_ATT_SCHEMA_SYNTAX);
    }

    // assign names of commonly used indexes when searching with
    // fSearchFlags fPDNTATTINDEX, fATTINDEX and fTUPLEINDEX
    if ( pAC->fSearchFlags & (fATTINDEX | fPDNTATTINDEX | fTUPLEINDEX) ) {
        // set ATTINDEX
        if (pAC->fSearchFlags & fATTINDEX) {

            // this should be NULL
            Assert (pAC->pszIndex == NULL);

            DBGetIndexName (pAC, fATTINDEX, DS_DEFAULT_LOCALE, szIndexName, sizeof (szIndexName));
            lenIndexName = strlen (szIndexName) + 1;
            if (SCCalloc(&pAC->pszIndex, 1, lenIndexName)) {
                fMallocFailed = TRUE;
            }
            else
                memcpy (pAC->pszIndex, szIndexName, lenIndexName);
        }

        // set TUPLEINDEX
        if (pAC->fSearchFlags & fTUPLEINDEX) {

            // this should be NULL
            Assert (pAC->pszTupleIndex == NULL);

            DBGetIndexName (pAC, fTUPLEINDEX, DS_DEFAULT_LOCALE, szIndexName, sizeof (szIndexName));
            lenIndexName = strlen (szIndexName) + 1;
            if (SCCalloc(&pAC->pszTupleIndex, 1, lenIndexName)) {
                fMallocFailed = TRUE;
            }
            else
                memcpy (pAC->pszTupleIndex, szIndexName, lenIndexName);
        }
        
        // set PDNTATTINDEX
        if (!fMallocFailed  && (pAC->fSearchFlags & fPDNTATTINDEX)) {

            // this should be NULL
            Assert (pAC->pszPdntIndex == NULL);

            DBGetIndexName (pAC, fPDNTATTINDEX, DS_DEFAULT_LOCALE, szIndexName, sizeof (szIndexName));
            lenIndexName = strlen (szIndexName) + 1;
            if (SCCalloc(&pAC->pszPdntIndex, 1, lenIndexName)) {
                fMallocFailed = TRUE;
            }
            else
                memcpy (pAC->pszPdntIndex, szIndexName, lenIndexName);
        }
    }
    if(fMallocFailed) {
        SCFreeAttcache(&pAC);
        return(SetSysError(ENOMEM, ERROR_DS_SCHEMA_ALLOC_FAILED));
    }


    // Backlinks should have their system flags set to indicate they are not
    // replicated.
    Assert(!FIsBacklink(pAC->ulLinkID) || pAC->bIsNotReplicated);

    return 0;

}/*SCBuildACEntry*/


/*
 * Add a single class definition to the schema cache, given the data
 * from the DMD object.
 *
 * N.B. This routine works in parallel with SCAddClass.  scAddClass
 *      takes the input description as an ENTINF, while SCBuildCCEntry
 *      takes the input as a positioned record in the DIT.  Any changes
 *      made to one routine must be made to the other.
 */
int
SCBuildCCEntry (
        CLASSCACHE *pCCold,
        CLASSCACHE **ppCCnew
        )

// This routine allocates and fills in the fields in a CLASSCACHE structure by
// reading the attributes from the database. If the fields are not in the
// database, they are defaulted to 0s and NULLs.  An already existing CLASSCACHE
// structure may also be specified, and in the future some attributes may be
// copied from the old structure to the new, but that is not currently
// necessary.
//
// Return Value:
//    0 on success
//    non-0 on error
//
{
    THSTATE      *pTHS=pTHStls;
    ATTCACHE     *ppACs[NUMCLASSATT];
    CLASSCACHE   *pCC;
    DWORD        i, j, cOutAtts, numValues;
    ATTR         *pAttr;
    BOOL         fFoundGovernsID, fFoundSubclass, fFoundName, fMallocFailed;

    if (SCCalloc(ppCCnew, 1, sizeof(CLASSCACHE))) {
       return(SetSysError(ENOMEM, ERROR_DS_SCHEMA_ALLOC_FAILED));
    }
    pCC = (*ppCCnew);

    fMallocFailed = fFoundGovernsID = fFoundSubclass = fFoundName = FALSE;

    // Get the attcache pointer for all the attributes we are interested
    for(i=0;i<NUMCLASSATT;i++) {
        ppACs[i] = SCGetAttById(pTHS, ClassSelList[i].attrTyp);
    }

    // Get the attributes
    DBGetMultipleAtts(pTHS->pDB, NUMCLASSATT, &ppACs[0], NULL, NULL,
                      &cOutAtts, &pAttr, DBGETMULTIPLEATTS_fGETVALS, 0);


    for(i=0;i<cOutAtts && !fMallocFailed ;i++) {
        ATTRVAL *pAVal = pAttr[i].AttrVal.pAVal;

        switch(pAttr[i].attrTyp) {
        case ATT_DEFAULT_SECURITY_DESCRIPTOR:
            // A default security descriptor.  We need to copy this value to
            // long term memory and save the size.
            // But this is a string. We first need to convert. It
            // is a wide-char string now, but we need to null-terminate
            // it for the security conversion. Yikes! This means I
            // have to realloc for that one extra char!

           {

            UCHAR *sdBuf = NULL;
            ULONG  err = 0;

            pCC->cbStrSD = pAttr[i].AttrVal.pAVal->valLen + sizeof(WCHAR);
            if (SCCalloc(&pCC->pStrSD, 1, pCC->cbStrSD)) {
                pCC->cbStrSD = 0;
                fMallocFailed = TRUE;
                break;
            } else {
                memcpy(pCC->pStrSD,
                       pAttr[i].AttrVal.pAVal->pVal,
                       pAttr[i].AttrVal.pAVal->valLen);
                pCC->pStrSD[(pAttr[i].AttrVal.pAVal->valLen)/sizeof(WCHAR)] = L'\0';
            }

            // Hammer the default SD on cached classes when running as
            // dsamain.exe w/security disabled and unit tests enabled.
            DEFAULT_SD_FOR_EXE(pTHS, pCC)

            if (!ConvertStringSDToSDRootDomainW
                 (
                   gpRootDomainSid,
                   pCC->pStrSD,
                   SDDL_REVISION_1,
                   (PSECURITY_DESCRIPTOR*) &sdBuf,
                   &(pCC->SDLen)
                 )) {
                err = GetLastError();
                DPRINT1(0,"SCBuildCCEntry: Default security descriptor conversion failed, error %x\n",err);
                return SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                     ERROR_DS_SEC_DESC_INVALID, err);
            }

            // Converted successfully

            if (SCCalloc(&pCC->pSD, 1, pCC->SDLen)) {
                fMallocFailed = TRUE;
            }
            else {
                memcpy(pCC->pSD, sdBuf, pCC->SDLen);
            }

            if (NULL!=sdBuf)
            {
                LocalFree(sdBuf);
                sdBuf = NULL;

            }

           }

            break;

        case ATT_OBJECT_CLASS_CATEGORY:
            pCC->ClassCategory=*(ULONG*)pAVal->pVal;
            break;
        case ATT_DEFAULT_OBJECT_CATEGORY:
            if (SCCalloc(&pCC->pDefaultObjCategory, 1, pAVal->valLen)) {
               fMallocFailed = TRUE;
            }
            else {
              memcpy(pCC->pDefaultObjCategory,
                     pAVal->pVal, pAVal->valLen);
            }
            break;
        case ATT_SYSTEM_AUXILIARY_CLASS:
        case ATT_AUXILIARY_CLASS:
            if (GetValList(&(pCC->AuxClassCount), &(pCC->pAuxClass), &pAttr[i])) {
                fMallocFailed = TRUE;
            }
            break;
        case ATT_SYSTEM_ONLY:
            pCC->bSystemOnly = *(SYNTAX_INTEGER *)pAVal->pVal;
            break;

        case ATT_DEFAULT_HIDING_VALUE:
            pCC->bHideFromAB = *(SYNTAX_BOOLEAN *)pAVal->pVal;
            break;

        case ATT_GOVERNS_ID:
            pCC->ClassId = *(SYNTAX_OBJECT_ID *)pAVal->pVal;
            fFoundGovernsID = TRUE;
            break;

        case ATT_LDAP_DISPLAY_NAME:
            // The admin display name read from the DB is currently in raw
            // (Unicode) format.  Single-byte it.
            pCC->nameLen = pAVal->valLen;
            if (SCCalloc(&pCC->name, 1, pAVal->valLen+1)) {
                fMallocFailed = TRUE;
            }
            else {
                pCC->nameLen = WideCharToMultiByte(
                        CP_UTF8,
                        0,
                        (LPCWSTR)pAVal->pVal,
                        (pAVal->valLen/
                         sizeof(wchar_t)),
                        pCC->name,
                        pAVal->valLen,
                        NULL,
                        NULL);

                pCC->name[pCC->nameLen] = '\0';

                fFoundName=TRUE;
            }
            break;

        case ATT_RDN_ATT_ID:
            // Cannot be a normal cache load -- it uses scAddClass.
            //
            // During install, this entry is added directly into the
            // schema cache. This means RdnIntId is incorrect. That
            // should be okay because the schema cache is reloaded
            // again after the schemaNC replicates in and before
            // the other NCs are replicated. This means a replicating
            // schema object cannot depend on a replicated class; which
            // is true today for other reasons.
            //
            // During validation cache loads, this entry is built
            // as a temporary data structure and the real entry in
            // the validation cache is used for checks. So its
            // okay RdnIntId is incorrect.
            pCC->RDNAttIdPresent = TRUE;
            pCC->RdnExtId = *(SYNTAX_OBJECT_ID *)pAVal->pVal;
            pCC->RdnIntId = pCC->RdnExtId;
            break;

        case ATT_SUB_CLASS_OF:
            // Find what classes this class is a subclass of.
            if(!pAttr[i].AttrVal.valCount)
                break;
            fFoundSubclass = TRUE;
            pCC->SubClassCount = pAttr[i].AttrVal.valCount;
            if (SCCalloc(&pCC->pSubClassOf, 1, pAttr[i].AttrVal.valCount*sizeof(ULONG))) {
                fMallocFailed = TRUE;
            }
            else {
                for(j=0;j<pAttr[i].AttrVal.valCount;j++) {
                    pCC->pSubClassOf[j] =
                        *(SYNTAX_OBJECT_ID *)pAVal[j].pVal;

                }
            }
            // ATT_SUB_CLASS_OF is single-valued, so there will be only
            // one value stored in the dit
            pCC->MySubClass = *(SYNTAX_OBJECT_ID *)pAVal->pVal;
            break;

        case ATT_SYSTEM_MUST_CONTAIN:
        case ATT_MUST_CONTAIN:
            // Get the list of mandatory attributes for this class.
            if (GetValList(&(pCC->MustCount), &(pCC->pMustAtts), &pAttr[i])) {
                fMallocFailed = TRUE;
            } else {
                // WARN: built using partial cache during install
                // Cache is reloaded prior to replicating other NCs
                // Replicating schemaNC cannot depend on parent's schema.
                ValListToIntIdList(pTHS, &pCC->MustCount, &pCC->pMustAtts);
            }

            if (GetValList(&(pCC->MyMustCount), &(pCC->pMyMustAtts), &pAttr[i])) {
                fMallocFailed = TRUE;
            } else {
                // WARN: built using partial cache during install
                // Cache is reloaded prior to replicating other NCs
                // Replicating schemaNC cannot depend on parent's schema.
                ValListToIntIdList(pTHS, &pCC->MyMustCount, &pCC->pMyMustAtts);
            }

            break;

        case ATT_SYSTEM_MAY_CONTAIN:
        case ATT_MAY_CONTAIN:
            if (GetValList(&(pCC->MayCount), &(pCC->pMayAtts), &pAttr[i])) {
                fMallocFailed = TRUE;
            } else {
                // WARN: built using partial cache during install
                // Cache is reloaded prior to replicating other NCs
                // Replicating schemaNC cannot depend on parent's schema.
                ValListToIntIdList(pTHS, &pCC->MayCount, &pCC->pMayAtts);
            }

            if (GetValList(&(pCC->MyMayCount), &(pCC->pMyMayAtts), &pAttr[i])) {
                fMallocFailed = TRUE;
            } else {
                // WARN: built using partial cache during install
                // Cache is reloaded prior to replicating other NCs
                ValListToIntIdList(pTHS, &pCC->MyMayCount, &pCC->pMyMayAtts);
            }
            break;

        case ATT_OBJECT_GUID:
            // Needed to choose winner if OIDs collide
            memcpy(&pCC->objectGuid,
                   pAttr[i].AttrVal.pAVal->pVal,
                   sizeof(pCC->objectGuid));
            Assert(pAttr[i].AttrVal.pAVal->valLen ==
                   sizeof(pCC->objectGuid));
            break;


        case ATT_SYSTEM_POSS_SUPERIORS:
        case ATT_POSS_SUPERIORS:
            // Get the list of possible superiors for this class.
            if (GetValList(&(pCC->PossSupCount), &(pCC->pPossSup), &pAttr[i])) {
               fMallocFailed = TRUE;
           }
           if (GetValList(&(pCC->MyPossSupCount), &(pCC->pMyPossSup), &pAttr[i])) {
               fMallocFailed = TRUE;
            }
            break;
        case ATT_IS_DEFUNCT:
            pCC->bDefunct =(*(SYNTAX_BOOLEAN*)pAVal->pVal?1:0);
            break;
        case ATT_SYSTEM_FLAGS:
            if (*(DWORD*)pAVal->pVal & FLAG_SCHEMA_BASE_OBJECT) {
                pCC->bIsBaseSchObj = TRUE;
            }
            break;

        default:
            break;
        }
    }

    if(fMallocFailed || !fFoundSubclass || !fFoundGovernsID  || !fFoundName) {
        SCFreeClasscache(&pCC);
        if (fMallocFailed) {
            return(SetSysError(ENOMEM, ERROR_DS_SCHEMA_ALLOC_FAILED));
        }

        if(!fFoundSubclass) {
            LogUnhandledError(0);
            Assert (FALSE);
        }

        if(!fFoundGovernsID) {
            DPRINT(2,"Couldn't retrieve the objects class\n");
            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_GOVERNSID_MISSING,
                     szInsertSz(GetExtDN(pTHS,pTHS->pDB)),
                     NULL,
                     NULL);

            return SetSvcError(SV_PROBLEM_DIR_ERROR,ERROR_DS_GOVERNSID_MISSING);
        }

        if(!fFoundName) {
            DPRINT(2,"Couldn't retrieve the schema's class name\n");
            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_MISSING_EXPECTED_ATT,
                     szInsertUL(ATT_LDAP_DISPLAY_NAME),
                     szInsertSz(GetExtDN(pTHS,pTHS->pDB)),
                     NULL);

            return SetSvcError(SV_PROBLEM_DIR_ERROR,
                               ERROR_DS_MISSING_EXPECTED_ATT);
        }
    }

    pCC->bClosed = FALSE;

    if (pTHS->SchemaUpdate==eSchemaClsMod)
    {
        //
        // We want to insure that there is no Circular Dependency
        // with the class inheritence
        //
        CLASSCACHE* pCC1;
        ULONG i;

        pCC1 = SCGetClassById(pTHS, pCC->pSubClassOf[0]);
        if (pCC1) {
            for (i=0;i<pCC1->SubClassCount;i++)
            {
                if (pCC1->pSubClassOf[i]==pCC->ClassId)
                {
                    return SetSvcError(SV_PROBLEM_DIR_ERROR,ERROR_DS_MISSING_EXPECTED_ATT);
                }
            }
        }
        // The check for circular dependency is impossible if the parent
        // class has not yet replicated in. An event log warning will be
        // issued by scCloseClass().
        else if (!pTHS->fDRA) {
            return SetSvcError(SV_PROBLEM_DIR_ERROR,ERROR_DS_MISSING_EXPECTED_ATT);
        }
    }

    // Visit all superior classes to get all the may and must contain
    // attributes for this class.
    if (scCloseClass(pTHS, pCC)) {
       DPRINT1(0, "SCBuildCCEntry: Error closing class %s\n", pCC->name);
       return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_CANT_CACHE_CLASS);
    }

    return 0;
}


int
SCAddClassSchema (
        IN THSTATE *pTHS,
        IN CLASSCACHE *pCC
        )
/*
 * Insert a classcache into the hash tables.
 */
{
    DECLARESCHEMAPTR
    ULONG i,start;
    CLASSCACHE *pCCDup;
    ATTCACHE *pACDup;
    BOOL bWonOid;
    USHORT DebugLevel = (pTHS->UpdateDITStructure) ? DS_EVENT_SEV_ALWAYS
                                                   : DS_EVENT_SEV_MINIMAL;

    // Hash table for all classes
    start=i=SChash(pCC->ClassId,CLSCOUNT);
    do {
        if (ahcClassAll[i].pVal==NULL || (ahcClassAll[i].pVal== FREE_ENTRY))
        {
            break;
        }
        i=(i+1)%CLSCOUNT;

        if (i==start)
        {
            // can't happen -- The cache is over-allocated to prevent this case
            Assert(!"Schema Cache is Full");
        }

    } while(start!=i);
    ahcClassAll[i].hKey = pCC->ClassId;
    ahcClassAll[i].pVal = pCC;

    // Replication and divergent schemas can result in multiple
    // active classes claiming the same OID. Choose a winner
    // amoung the active classes. Colliding classes are all
    // treated as if they were defunct. The user must choose
    // a winner by officially defuncting the loser.
    //
    // Replication, delete, and rename depend on having an
    // owner for every governsId. Choose a winner amoung the
    // defunct classes.
    if (pCCDup = SCGetClassById(pTHS, pCC->ClassId)) {
        if (pCC->bDefunct && !pCCDup->bDefunct) {
            bWonOid = FALSE;
        } else if (!pCC->bDefunct && pCCDup->bDefunct) {
            scUnhashCls(pTHS, pCCDup, SC_UNHASH_LOST_OID);
            bWonOid = TRUE;
        } else {
            if (0 < memcmp(&pCC->objectGuid, 
                           &pCCDup->objectGuid, 
                           sizeof(pCC->objectGuid))) {
                scUnhashCls(pTHS, pCCDup, SC_UNHASH_LOST_OID);
                bWonOid = TRUE;
            } else {
                bWonOid = FALSE;
            }
            if (!pCC->bDefunct && !pCCDup->bDefunct) {
                DPRINT5(DebugLevel, "Class %s (%x) %s GovernsId to Class %s (%x)\n",
                        pCC->name, pCC->ClassId, 
                        (bWonOid) ? "WON" : "LOST", 
                        pCCDup->name, pCCDup->ClassId);
                LogEvent8(DS_EVENT_CAT_SCHEMA,
                          DebugLevel,
                          DIRLOG_SCHEMA_DUP_GOVERNSID,
                          szInsertSz(pCC->name), szInsertHex(pCC->ClassId),
                          szInsertSz(pCCDup->name), NULL,
                          NULL, NULL, NULL, NULL);
                pCCDup->bDupOID = TRUE;
                pCC->bDupOID = TRUE;
            }
        }
    } else {
        bWonOid = TRUE;
    }

    // Defunct or not, this class won the OID
    if (bWonOid) {
        start=i=SChash(pCC->ClassId,CLSCOUNT);
        do {
            if (ahcClass[i].pVal==NULL || (ahcClass[i].pVal== FREE_ENTRY))
            {
                break;
            }
            i=(i+1)%CLSCOUNT;

            if (i==start)
            {
                // can't happen -- The cache is over-allocated to prevent this case
                Assert(!"Schema Cache is Full");
            }

        }while(start!=i);

        ahcClass[i].hKey = pCC->ClassId;
        ahcClass[i].pVal = pCC;
    }

    // Once the forest version is raised to DS_BEHAVIOR_SCHEMA_REUSE,
    // defunct classes won't own their schemaIdGuid or their LDN.
    if (pCC->bDefunct && ALLOW_SCHEMA_REUSE_VIEW(pTHS->CurrSchemaPtr)) {
        DPRINT2(DS_EVENT_SEV_MINIMAL, "Ignoring defunct class %s (%x)\n",
                pCC->name, pCC->ClassId);
        LogEvent8(DS_EVENT_CAT_SCHEMA,
                  DS_EVENT_SEV_MINIMAL,
                  DIRLOG_SCHEMA_IGNORE_DEFUNCT,
                  szInsertSz(pCC->name), szInsertHex(pCC->ClassId),
                  szInsertHex(0), NULL, NULL, NULL, NULL, NULL);
        return 0;
    }

    // Does ClassId collide with an attribute's attributeId?
    // Condition arises because of divergent schemas and when
    // replicating reused schema objects.
    if ((pACDup = SCGetAttByExtId(pTHS, pCC->ClassId)) 
        && !pACDup->bDefunct) {
        DPRINT5(DebugLevel, "Class %s (%x) duplicates ExtId for Attr %s (%x, %x)\n",
                pCC->name, pCC->ClassId, pACDup->name, pACDup->id, pACDup->Extid);
        LogEvent8(DS_EVENT_CAT_SCHEMA,
                  DebugLevel,
                  DIRLOG_SCHEMA_DUP_GOVERNSID_ATTRIBUTEID,
                  szInsertSz(pCC->name), szInsertHex(pCC->ClassId),
                  szInsertSz(pACDup->name), szInsertHex(pACDup->id), szInsertHex(pACDup->Extid),
                  NULL, NULL, NULL);
        pACDup->bDupOID = TRUE;
        pCC->bDupOID = TRUE;
    }

    if (!pTHS->UpdateDITStructure && !fNullUuid(&pCC->propGuid)) {
        // This is the validation cache. Need to add this
        // to the schemaIdGuid hash table
        if (pCCDup = SCGetClassByPropGuid(pTHS, pCC)) {
            DPRINT4(DebugLevel, "Class %s (%x) duplicates PropGuid for Class %s (%x)\n",
                    pCC->name, pCC->ClassId, pCCDup->name, pCCDup->ClassId);
            LogEvent8(DS_EVENT_CAT_SCHEMA,
                      DebugLevel,
                      DIRLOG_SCHEMA_DUP_SCHEMAIDGUID_CLASS,
                      szInsertSz(pCC->name), szInsertHex(pCC->ClassId),
                      szInsertSz(pCCDup->name), szInsertHex(pCCDup->ClassId),
                      NULL, NULL, NULL, NULL);
            pCCDup->bDupPropGuid = TRUE;
            pCC->bDupPropGuid = TRUE;
        }

       for (i=SCGuidHash(pCC->propGuid, CLSCOUNT);
            ahcClsSchemaGuid[i] && (ahcClsSchemaGuid[i] != FREE_ENTRY);
            i=(i+1)%CLSCOUNT) {
       }
       ahcClsSchemaGuid[i] = pCC;
    }

    if (pCC->name) {
        /* if this class has a name, add it to the name cache */

        if (pCCDup = SCGetClassByName(pTHS, pCC->nameLen, pCC->name)) {
            DPRINT4(DebugLevel, "Class %s (%x) duplicates LDN for Class %s (%x)\n",
                    pCC->name, pCC->ClassId, pCCDup->name, pCCDup->ClassId);
            LogEvent8(DS_EVENT_CAT_SCHEMA,
                      DebugLevel,
                      DIRLOG_SCHEMA_DUP_LDAPDISPLAYNAME_CLASS_CLASS,
                      szInsertSz(pCC->name), szInsertHex(pCC->ClassId),
                      szInsertSz(pCCDup->name), szInsertHex(pCCDup->ClassId),
                      NULL, NULL, NULL, NULL);
            pCCDup->bDupLDN = TRUE;
            pCC->bDupLDN = TRUE;
        }
        if (pACDup = SCGetAttByName(pTHS, pCC->nameLen, pCC->name)) {
            DPRINT5(DebugLevel, "Class %s (%x) duplicates LDN for Attr %s (%x, %x)\n",
                    pCC->name, pCC->ClassId, pACDup->name, pACDup->id, pACDup->Extid);
            LogEvent8(DS_EVENT_CAT_SCHEMA,
                      DebugLevel,
                      DIRLOG_SCHEMA_DUP_LDAPDISPLAYNAME_CLASS_ATTRIBUTE,
                      szInsertSz(pCC->name), szInsertHex(pCC->ClassId),
                      szInsertSz(pACDup->name), szInsertHex(pACDup->id), szInsertHex(pACDup->Extid),
                      NULL, NULL, NULL);
            pACDup->bDupLDN = TRUE;
            pCC->bDupLDN = TRUE;
        }
        start=i=SCNameHash(pCC->nameLen, pCC->name, CLSCOUNT);
        do
        {
            if (ahcClassName[i].pVal==NULL || (ahcClassName[i].pVal== FREE_ENTRY))
            {
                break;
            }
            i=(i+1)%CLSCOUNT;


            if (i==start)
            {
                // can't happen -- The cache is over-allocated to prevent this case
                Assert(!"Schema Cache is Full");
            }
        }while(start!=i);

        ahcClassName[i].length = pCC->nameLen;
        ahcClassName[i].value = pCC->name;
        ahcClassName[i].pVal = pCC;
    }

    return 0;
}


/*
 * Insert an attcache into the hash tables, and create a JET column if
 * needed.
 */
int 
SCAddAttSchema(
    IN THSTATE *pTHS,
    IN ATTCACHE *pAC,
    IN BOOL fNoJetCol,
    IN BOOL fFixingRdn
    )
{
    DECLARESCHEMAPTR

    ULONG i;
    int err;
    ATTRTYP aid;
    ATTRTYP Extid;
    ATTCACHE *pACDup;
    USHORT DebugLevel = (pTHS->UpdateDITStructure) ? DS_EVENT_SEV_ALWAYS
                                                   : DS_EVENT_SEV_MINIMAL;

    aid = pAC->id;
    Extid = pAC->Extid;

    // fFixingRdns will only be set when this attribute is being added
    // a second time by scFixRdnAttIds. The second call "resurrects"
    // defuncted or colliding attributes used as rdns.
    if (!fFixingRdn) {
        //
        // Hash in the id, column id, and linkId tables
        //

        // Fill in hash entry normally filled in when scanning jet columns
        if (fNoJetCol) {
            // IntId
            for (i=SChash(aid,ATTCOUNT);
                 ahcId[i].pVal && (ahcId[i].pVal != FREE_ENTRY); i=(i+1)%ATTCOUNT){
            }
            ahcId[i].hKey = aid;
            ahcId[i].pVal = pAC;
        }

        // Create column if needed and add to column hash
        if (fNoJetCol
            && !pAC->ulLinkID 
            && !pAC->bIsConstructed 
            && pTHS->UpdateDITStructure) {
            /* it's not a link, not constructed att, so must be new and needs a jet column */
            /* create JET col */
            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_EXTENSIVE,
                     DIRLOG_SCHEMA_CREATING_COLUMN, 
                     szInsertUL(Extid), szInsertSz(pAC->name), 0);

            // DBAddCol creates a column for pAC. If needed, DBAddCol will
            // also create an empty index for pAC. An empty index is created
            // because there is no need to scan the rows in the database
            // looking for keys that aren't there.
            err = DBAddCol(pAC);
            if (err) {
                /* Couldn't add column */
                LogEvent(DS_EVENT_CAT_SCHEMA,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_SCHEMA_COLUMN_ADD_FAILED,
                    szInsertUL(Extid), szInsertSz(pAC->name), szInsertUL(err));

                // Remove the attcache from all hash tables (since it may
                // have already been added to the name table etc. by code
                // above. Reset pAC->jColid, since the table freeing
                // routine checks that to see if it needs to free the
                // atcache from the colId table (this is done for safety,
                // since the call to DBAddCol may have changed this)
                pAC->jColid = 0;
                scUnhashAtt(pTHS, pAC, SC_UNHASH_ALL);
                SCFreeAttcache(&pAC);
                return (err);
            }

            /* new column added */
            LogEvent(DS_EVENT_CAT_SCHEMA,
                DS_EVENT_SEV_MINIMAL,
                DIRLOG_SCHEMA_COLUMN_ADDED,
                szInsertUL(pAC->jColid), szInsertSz(pAC->name), szInsertUL(Extid));

            // jColid
            for (i=SChash(pAC->jColid,ATTCOUNT);
                    ahcCol[i].pVal && (ahcCol[i].pVal != FREE_ENTRY); i=(i+1)%ATTCOUNT){
            }
            ahcCol[i].hKey = pAC->jColid;
            ahcCol[i].pVal = pAC;
        }

        // Need to fill in the hints
        if (pAC->pszIndex) {
            DBGetIndexHint(pAC->pszIndex, &pAC->pidxIndex);
        }
        if (pAC->pszPdntIndex) {
            DBGetIndexHint(pAC->pszPdntIndex, &pAC->pidxPdntIndex);
        }
        if (pAC->pszTupleIndex) {
            DBGetIndexHint(pAC->pszTupleIndex, &pAC->pidxTupleIndex);
        }

        // Link Id table
        if (pAC->ulLinkID) {
            /* if this att is a link or backlink, add it to link cache */
            for (i=SChash(pAC->ulLinkID, ATTCOUNT);
                    ahcLink[i].pVal && (ahcLink[i].pVal != FREE_ENTRY); i=(i+1)%ATTCOUNT) {
            }
            ahcLink[i].hKey = pAC->ulLinkID;
            ahcLink[i].pVal = pAC;
        }
    }

    // Defunct attributes do not own their OID, LDN, SchemaIdGuid, or MapiId
    //     Unless the attribute is used as an rdn
    //     Unless the forest version is pre-schema-reuse
    if (pAC->bDefunct
        && !pAC->bIsRdn
        && ALLOW_SCHEMA_REUSE_VIEW(pTHS->CurrSchemaPtr)) {
        DPRINT3(DS_EVENT_SEV_MINIMAL, "Ignoring defunct attribute %s (%x, %x)\n",
                pAC->name, pAC->id, pAC->Extid);
        LogEvent8(DS_EVENT_CAT_SCHEMA,
                  DS_EVENT_SEV_MINIMAL,
                  DIRLOG_SCHEMA_IGNORE_DEFUNCT,
                  szInsertSz(pAC->name), szInsertHex(pAC->id), szInsertHex(pAC->Extid),
                  NULL, NULL, NULL, NULL, NULL);
        return 0;
    }

    //
    // ahcExtid
    //

    // Collisions can occur during an originating write, during out-of-order
    // replication, and because of divergent schemas. The colliding
    // attributes are treated as if defunct except when used as an
    // rdnattid of any class, live or defunct or when FLAG_ATTR_IS_RDN
    // is set in ATT_SYSTEM_FLAGS.
    if (pACDup = SCGetAttByExtId(pTHS, pAC->Extid)) {
        DPRINT6(DebugLevel, "Attr %s (%x, %x) duplicates Extid for Attr %s (%x, %x)\n",
                pAC->name, pAC->id, pAC->Extid, pACDup->name, pACDup->id, pACDup->Extid);
        LogEvent8(DS_EVENT_CAT_SCHEMA,
                  DebugLevel,
                  DIRLOG_SCHEMA_DUP_ATTRIBUTEID,
                  szInsertSz(pAC->name), szInsertHex(pAC->id), szInsertHex(pAC->Extid),
                  szInsertSz(pACDup->name), szInsertHex(pACDup->id), szInsertHex(pACDup->Extid),
                  NULL, NULL);
        pACDup->bDupOID = TRUE;
        pAC->bDupOID = TRUE;
    }
    for (i=SChash(Extid,ATTCOUNT);
        ahcExtId[i].pVal && (ahcExtId[i].pVal != FREE_ENTRY); i=(i+1)%ATTCOUNT){
    }
    ahcExtId[i].hKey = Extid;
    ahcExtId[i].pVal = pAC;

    //
    // ahcAttSchemaGuid
    //

    if (!pTHS->UpdateDITStructure && !fNullUuid(&pAC->propGuid)) {
       // This is the validation cache. Need to add this
       // to the schemaIdGuid hash table.
       //
       // Don't bother checking the class hash, no classes are loaded.
       // SCAddClassSchema will check for dups against the attributes, later.
        if (pACDup = SCGetAttByPropGuid(pTHS, pAC)) {
            DPRINT6(DebugLevel, "Attr %s (%x, %x) duplicates PropGuid for Attr %s (%x, %x)\n",
                    pAC->name, pAC->id, pAC->Extid, pACDup->name, pACDup->id, pACDup->Extid);
            LogEvent8(DS_EVENT_CAT_SCHEMA,
                      DebugLevel,
                      DIRLOG_SCHEMA_DUP_SCHEMAIDGUID_ATTRIBUTE,
                      szInsertSz(pAC->name), szInsertHex(pAC->id), szInsertHex(pAC->Extid),
                      szInsertSz(pACDup->name), szInsertHex(pACDup->id), szInsertHex(pACDup->Extid),
                      NULL, NULL);
            pACDup->bDupPropGuid = TRUE;
            pAC->bDupPropGuid = TRUE;
        }
        for (i=SCGuidHash(pAC->propGuid, ATTCOUNT);
             ahcAttSchemaGuid[i] && (ahcAttSchemaGuid[i] != FREE_ENTRY);
             i=(i+1)%ATTCOUNT) {
        }
        ahcAttSchemaGuid[i] = pAC;
    }

    //
    // ahcMapi
    //
    if (pAC->ulMapiID) {
        /* if this att is MAPI visible, add it to MAPI cache */
        if (pACDup = SCGetAttByMapiId(pTHS, pAC->ulMapiID)) {
            DPRINT6(DebugLevel, "Attr %s (%x, %x) duplicates MapiID for Attr %s (%x, %x)\n",
                    pAC->name, pAC->id, pAC->Extid, pACDup->name, pACDup->id, pACDup->Extid);
            LogEvent8(DS_EVENT_CAT_SCHEMA,
                      DebugLevel,
                      DIRLOG_SCHEMA_DUP_MAPIID,
                      szInsertSz(pAC->name), szInsertHex(pAC->id), szInsertHex(pAC->Extid),
                      szInsertSz(pACDup->name), szInsertHex(pACDup->id), szInsertHex(pACDup->Extid),
                      NULL, NULL);
            pACDup->bDupMapiID = TRUE;
            pAC->bDupMapiID = TRUE;
        }
        for (i=SChash(pAC->ulMapiID, ATTCOUNT);
             ahcMapi[i].pVal && (ahcMapi[i].pVal!= FREE_ENTRY);
             i=(i+1)%ATTCOUNT) {
        }
        ahcMapi[i].hKey = pAC->ulMapiID;
        ahcMapi[i].pVal = pAC;
    }

    //
    // ahcName
    //
    if (pAC->name) {
       // if this att has a name, add it to the name cache
       //
       // Don't bother checking the class hash, no classes are loaded.
       // SCAddClassSchema will check for dups against the attributes, later.
        if (pACDup = SCGetAttByName(pTHS, pAC->nameLen, pAC->name)) {
            DPRINT6(DebugLevel, "Attr %s (%x, %x) duplicates LDN for Attr %s (%x, %x)\n",
                    pAC->name, pAC->id, pAC->Extid, pACDup->name, pACDup->id, pACDup->Extid);
            LogEvent8(DS_EVENT_CAT_SCHEMA,
                      DebugLevel,
                      DIRLOG_SCHEMA_DUP_LDAPDISPLAYNAME_ATTRIBUTE,
                      szInsertSz(pAC->name), szInsertHex(pAC->id), szInsertHex(pAC->Extid),
                      szInsertSz(pACDup->name), szInsertHex(pACDup->id), szInsertHex(pACDup->Extid),
                      NULL, NULL);
            pACDup->bDupLDN = TRUE;
            pAC->bDupLDN = TRUE;
        }
#if DBG
{
        ULONG CheckForFreeEntry;
        for (i=SCNameHash(pAC->nameLen, pAC->name, ATTCOUNT), CheckForFreeEntry = i;
                    ahcName[i].pVal && (ahcName[i].pVal!= FREE_ENTRY); i=(i+1)%ATTCOUNT) {
            if ( i+1 == CheckForFreeEntry ) {
                Assert(!"No free entries!");
            }

        }
}
#else
        for (i=SCNameHash(pAC->nameLen, pAC->name, ATTCOUNT);
                    ahcName[i].pVal && (ahcName[i].pVal!= FREE_ENTRY); i=(i+1)%ATTCOUNT) {
        }
#endif

        ahcName[i].length = pAC->nameLen;
        ahcName[i].value = pAC->name;
        ahcName[i].pVal = pAC;
    }

    return 0;
}

/*
 * Remove an attribute from the schema cache
 */
int SCDelAttSchema(THSTATE *pTHS,
                   ATTRTYP attrid)
{
    ATTCACHE *pAC;

    // Find cache entry

    if (!(pAC = SCGetAttById(pTHS, attrid))) {
        Assert (FALSE);
        return !0;
    }

    scUnhashAtt (pTHS, pAC, SC_UNHASH_ALL);
    SCFreeAttcache(&pAC);

    return 0;
}


/*
 * Remove a class from the schema cache
 */
int SCDelClassSchema(ATTRTYP ClassId)
{
    THSTATE *pTHS=pTHStls;
    CLASSCACHE *pCC;

    // Find cache entry

    if (!(pCC = SCGetClassById(pTHS, ClassId))) {
        Assert (FALSE);
        return !0;
    }

    scUnhashCls (pTHS, pCC, SC_UNHASH_ALL);
    SCFreeClasscache(&pCC);

    return 0;
}

int
SCEnumMapiProps(
        unsigned * pcProps,
        ATTCACHE ***ppACBuf
        )
/*
 * Enumerate all MAPI accessible properties (attributes).
 */
{
    THSTATE *pTHS=pTHStls;
    DECLARESCHEMAPTR

    ULONG cProps = 0;
    ATTCACHE ** pACBuf;
    ULONG i;

    pACBuf = THAllocEx(pTHS, ATTCOUNT*sizeof(void*));

    for (i=0; i<ATTCOUNT; i++) {
        if (ahcMapi[i].pVal && (ahcMapi[i].pVal != FREE_ENTRY)) {
            pACBuf[cProps] = (ATTCACHE*)(ahcMapi[i].pVal);
            ++cProps;
        }
    }

    *ppACBuf = THReAllocEx(pTHS, pACBuf, cProps * sizeof(void *));
    *pcProps = cProps;

    return(0);
}

int
SCEnumNamedAtts(
        unsigned * pcAtts,
        ATTCACHE ***ppACBuf
        )
/*
 * Enumerate all attributes that have names.
 */
{
    THSTATE *pTHS=pTHStls;
    DECLARESCHEMAPTR

    ULONG cAtts = 0;
    ATTCACHE ** pACBuf, * pAC;
    ULONG i;

    pACBuf = THAllocEx(pTHS, ATTCOUNT*sizeof(void*));

    for (i=0; i<ATTCOUNT; i++) {
        if ((pAC = ahcName[i].pVal)
            && (pAC != FREE_ENTRY)
            // Hide defunct attrs in schema-reuse forests
            && (!pAC->bDefunct || !ALLOW_SCHEMA_REUSE_VIEW(pTHS->CurrSchemaPtr))) {
            pACBuf[cAtts] = (ATTCACHE*)(ahcName[i].pVal);
            ++cAtts;
        }
    }

    *pcAtts = cAtts;
    *ppACBuf = THReAllocEx(pTHS, pACBuf,cAtts*sizeof(void *));

    return(0);
}

int
SCEnumNamedClasses(
        unsigned * pcClasses,
        CLASSCACHE ***ppCCBuf
        )
/*
 * Enumerate all classes that have names.
 */
{
    THSTATE *pTHS=pTHStls;
    DECLARESCHEMAPTR

    ULONG cClasses = 0;
    CLASSCACHE ** pCCBuf;
    ULONG i;

    pCCBuf = THAllocEx(pTHS, CLSCOUNT*sizeof(void*));

    for (i=0; i<CLSCOUNT; i++) {
        if (ahcClassName[i].pVal && (ahcClassName[i].pVal != FREE_ENTRY)) {
            pCCBuf[cClasses] = (CLASSCACHE*)(ahcClassName[i].pVal);
            ++cClasses;
        }
    }

    // pCCBuf may have been over-allocated. Shrink to fit.
    //
    // PERFHINT - pCCBuf may be invariant for a given schema cache.
    // If this proves to be true, consider saving pCCBuf in CurrSchemaPtr
    // for future calls to this function.
    *pcClasses = cClasses;
    *ppCCBuf = THReAllocEx(pTHS, pCCBuf,cClasses * sizeof(void *));

    return(0);
}

int
SCEnumNamedAuxClasses(
        unsigned * pcClasses,
        CLASSCACHE ***ppCCBuf
        )
/*
 * Enumerate all the aux classes that have names.
 */
{
    THSTATE *pTHS=pTHStls;
    DECLARESCHEMAPTR

    ULONG cClasses = 0;
    CLASSCACHE ** pCCBuf;
    ULONG i;
    ULONG ClassCategory;


    pCCBuf = THAllocEx(pTHS, CLSCOUNT*sizeof(void*));

    for (i=0; i<CLSCOUNT; i++) {
        if (ahcClassName[i].pVal && 
            (ahcClassName[i].pVal != FREE_ENTRY) &&
            ( ((ClassCategory = 
                ((CLASSCACHE*)(ahcClassName[i].pVal))->ClassCategory) == DS_AUXILIARY_CLASS) || 
               (ClassCategory == DS_88_CLASS) ) ) {

                    pCCBuf[cClasses] = (CLASSCACHE*)(ahcClassName[i].pVal);
                    ++cClasses;
        }
    }

    // pCCBuf may have been over-allocated. Shrink to fit.
    //
    // PERFHINT - pCCBuf may be invariant for a given schema cache.
    // If this proves to be true, consider saving pCCBuf in CurrSchemaPtr
    // for future calls to this function.
    *pcClasses = cClasses;
    *ppCCBuf = THReAllocEx(pTHS, pCCBuf,cClasses * sizeof(void *));

    return(0);
}


void
SCAddANRid (
        DWORD aid
        )
/*
 * Add the given ID to the list of IDs to ANR on.  Trim dups, allocate
 * more space as necessary.
 *
 */
{
    SCHEMAPTR *pSchema = (SCHEMAPTR *)pTHStls->CurrSchemaPtr;
    DWORD i;

    if(!pSchema->caANRids) {
        /* First time in.  Alloc some space */
        if (SCCalloc(&pSchema->pANRids, 1, 50*sizeof(DWORD))) {
            /* no memory? */
            return;
        }
        pSchema->caANRids=50;
        pSchema->cANRids=0;
    }

    for(i=0;i<pSchema->cANRids;i++)
        if(pSchema->pANRids[i] == aid)
            /* Already here. */
            return;

    if(pSchema->caANRids == pSchema->cANRids) {
        /* Need more space */
        if (SCRealloc(&pSchema->pANRids, 2*pSchema->caANRids*sizeof(DWORD))) {
            /* no memory? */
            return;
        }
        pSchema->caANRids *= 2;
    }

    pSchema->pANRids[pSchema->cANRids] = aid;
    pSchema->cANRids++;
}

/*
 * Return the number of IDs to ANR on, and fill in the variable
 * given to us with a pointer to the first id to ANR on.
 */
DWORD SCGetANRids(LPDWORD * IDs)
{
    SCHEMAPTR *pSchema = (SCHEMAPTR *)pTHStls->CurrSchemaPtr;

    *IDs = pSchema->pANRids;

    return pSchema->cANRids;
}

//-----------------------------------------------------------------------
//
// Function Name:            SCCanUpdateSchema
//
// Routine Description:
//
//    Checks to see if Schema Update should be allowed
//    Allow Schema Change if this DSA is the FSMO Role
//    Owner and the system is running.
//
// Arguments:
//    pTHS - THSTATE pointer
//
// Return Value:
//
//    BOOL             TRUE if Schema Update is allowed
//
//-----------------------------------------------------------------------
BOOL
SCCanUpdateSchema(THSTATE *pTHS)
{
    ULONG schemaupdateallowed=0;
    int err=0;
    DSNAME *pOwner;
    ULONG len, dntSave;
    DBPOS *pDB;
    BOOL roleOwner=FALSE, regKeyPresent=FALSE;

    if (pTHS->fDRA) {
	return TRUE;
    }

    if ( DsaIsRunning() )
    {
           Assert(pTHS->pDB);
           // save currency
           dntSave = pTHS->pDB->DNT;
           __try {
               err = DBFindDSName(pTHS->pDB, gAnchor.pDMD);
               if (err) {
                   __leave;
               }

               err = DBGetAttVal(pTHS->pDB,
                                 1,
                                 ATT_FSMO_ROLE_OWNER,
                                 0,
                                 0,
                                 &len,
                                 (UCHAR **)&pOwner);
               if (err) {
                   __leave;
               }

               // check if this DSA is the FSMO Role Owner

               if (!NameMatched(pOwner,gAnchor.pDSADN) ||
                   !IsFSMOSelfOwnershipValid( gAnchor.pDMD )) {
                    __leave;
               }

               // Schema update is allowed
               schemaupdateallowed = 1;

          } /* try */
          __finally {

            // restore currency
            DBFindDNT(pTHS->pDB, dntSave);
          }
    }
    else
    {
        //
        // We are installing
        //
        schemaupdateallowed=1;
    }

    return schemaupdateallowed!=0;
} // End CanUpdateSchema

int
SCLegalChildrenOfClass(
    ULONG       parentClass,            // IN
    ULONG       *pcLegalChildren,       // OUT
    CLASSCACHE  ***ppLegalChildren)     // OUT

/*++

Routine Description:

    Determines the set of classes which can be instantiated as children
    of the class identified by parentClass.  Assumes the caller has
    a valid thread state.

Arguments:

    parentClass - Class id of the parent under which a child is desired.

    pcLegalChildren - pointer to count of legal children.

    ppLegalChildren - pointer to array of CLASSCACHE pointers representing
        legal children.

Return Value:

    0 on success, !0 otherwise.
    May throw an exception - eg: THAllocEx is used.

--*/

{
    THSTATE *pTHS=pTHStls;
    int         err;
    unsigned    i, j, k, l;
    CLASSCACHE  *pParentClassCC;
    ULONG       *ParentSet;
    ULONG       cParentSet;
    ULONG       *ChildSet;
    unsigned    cAllCC;
    CLASSCACHE  **ppAllCC;
    BOOL        found;

    Assert(NULL != pTHS);

    pParentClassCC = SCGetClassById(pTHS, parentClass);

    if ( 0 == pParentClassCC )
        return(1);

    err = SCEnumNamedClasses(&cAllCC, &ppAllCC);

    if ( 0 != err )
        return(err);

    // The legal children classes are those which have parentClass or a class
    // which parentClass derives from, in their pPossSup array.  Consider the
    // class hierarchy Top-A-B-C-D and the parentClass of interest is B.
    // Clearly any class which claims B as a possible superior should be
    // returned.  An instance of class B is as good as or better than an
    // instance of class A.  Thus any class which required A as a possible
    // superior implicitly should be satisfied with B as a possible superior.
    // So we need to return the classes which list the classes B is derived from
    // as possible superiors.
    // Note that we close the possible superiors list of each classcache.  For
    // example, assume E is the superclass of F.  Further, in the directory, E
    // lists A as a possilbe superior and F lists C.  In the classcache
    // structure, the cache element for E lists A as a possible superior and the
    // element for F lists A and C.  Thus, if B were the class of interest, we
    // will (with no extra work) return E (because it lists A as a possible
    // superor, and A is a superclass of B) and F (because it also lists A
    // because it inherited this from E).

    cParentSet = 0;
    ParentSet = (ULONG *) THAllocEx(pTHS, sizeof(ULONG) * cAllCC);

    // Seed ParentSet with parentClass.

    ParentSet[cParentSet++] = parentClass;

    // Extend ParentSet with all the classes parentClass derives from.
    for ( i = 0; i < pParentClassCC->SubClassCount; i++ )
        ParentSet[cParentSet++] = pParentClassCC->pSubClassOf[i];

    // ParentSet now holds parentClass and all classes parentClass is derived
    // from.  Now find all classes which have one of ParentSet as a possible
    // superior.

    *pcLegalChildren = 0;
    ChildSet = (ULONG *) THAllocEx(pTHS, sizeof(ULONG) * cAllCC);

    for ( i = 0; i < cParentSet; i++ )
    {
        for ( j = 0; j < cAllCC; j++ )
        {
            // PossSup ...
            for ( k = 0; k < ppAllCC[j]->PossSupCount; k++ )
            {
                if ( ParentSet[i] == ppAllCC[j]->pPossSup[k] )
                {
                    // Skip duplicates.

                    found = FALSE;

                    for ( l = 0; l < *pcLegalChildren; l++ )
                    {
                        if ( ChildSet[l] == ppAllCC[j]->ClassId )
                        {
                            found = TRUE;
                            break;
                        }
                    }

                    if ( !found )
                    {
                        ChildSet[(*pcLegalChildren)++] = ppAllCC[j]->ClassId;
                    }

                    break;
                }
            }
        }
    }

    // Convert to CLASSCACHE pointers.

    *ppLegalChildren = (CLASSCACHE **) THAllocEx(pTHS,
                                *pcLegalChildren * sizeof(CLASSCACHE *));

    for ( i = 0; i < *pcLegalChildren; i++ )
    {
        (*ppLegalChildren)[i] = SCGetClassById(pTHS, ChildSet[i]);

        if ( 0 == (*ppLegalChildren)[i])
            return(1);
    }

    return(0);
}

int
SCLegalChildrenOfName(
    DSNAME      *pDSName,               // IN
    DWORD       flags,                  // IN
    ULONG       *pcLegalChildren,       // OUT
    CLASSCACHE  ***ppLegalChildren)     // OUT

/*++

Routine Description:

    Determines the set of classes which can be instantiated as children
    of the object identified by pDSName.  Assumes the caller has
    a valid thread state, but not necessarily an open database.  This
    version of the procedure is intended for callers outside the core
    who are constructing a virtual attribute.

Arguments:

    pDSName - DSNAME of object under which a child is desired.

    SecurityFilter - Boolean which indicates whether to filter results by
        actual rights caller has in the parent container.

    pcLegalChildren - pointer to count of legal children.

    ppLegalChildren - pointer to array of CLASSCACHE pointers representing
        legal children.

Return Value:

    0 on success, !0 otherwise.
    Will not throw an exception.
    Will not set pTHStls->errCode.

--*/

{
    THSTATE *pTHS=pTHStls;
    int                  retVal = 1;
    DBPOS                *pDB;
    ULONG                *pClassId;
    ULONG                cCandidates;
    CLASSCACHE           **rCandidates;
    CLASSCACHE           *pCC;
    ULONG                len;
    PSECURITY_DESCRIPTOR pNTSD=NULL;
    PSID                 pSid=NULL;
    GUID                 *pGuid = NULL;
    ULONG                i;

    Assert(NULL != pTHS);

    *pcLegalChildren = 0;
    *ppLegalChildren = NULL;

    DBOpen(&pDB);

    __try
    {
        // PREFIX: dereferencing uninitialized pointer 'pDB' 
        //         DBOpen returns non-NULL pDB or throws an exception
        retVal = DBFindDSName(pDB, pDSName);

        if ( 0 != retVal )
            leave;

        if(flags == SC_CHILDREN_USE_GOVERNS_ID) {
            retVal = DBGetAttVal(
                    pDB,                     // DBPos
                    1,                       // which value to get
                    ATT_GOVERNS_ID,          // which attribute
                    DBGETATTVAL_fREALLOC,    // DB layer should alloc
                    0,                       // initial buffer size
                    &len,                    // output buffer size
                    (UCHAR **) &pClassId);   // output buffer
        }
        else {
            retVal = DBGetAttVal(
                    pDB,                     // DBPos
                    1,                       // which value to get
                    ATT_OBJECT_CLASS,        // which attribute
                    DBGETATTVAL_fREALLOC,    // DB layer should alloc
                    0,                       // initial buffer size
                    &len,                    // output buffer size
                    (UCHAR **) &pClassId);   // output buffer
        }

        if ( 0 != retVal )
            leave;

        retVal = SCLegalChildrenOfClass(*pClassId,
                                        &cCandidates,
                                        &rCandidates);
        if ( 0 != retVal )
            leave;

        if(flags == SC_CHILDREN_USE_SECURITY) {
            // Get the Security Descriptor and the SID
            retVal = DBGetAttVal(
                    pDB,
                    1,
                    ATT_NT_SECURITY_DESCRIPTOR,
                    DBGETATTVAL_fREALLOC,
                    0,
                    &len,
                    (UCHAR **) &pNTSD);

            if(retVal==DB_ERR_UNKNOWN_ERROR)
                leave;
            if(retVal) {
                len = 0;
                pNTSD = NULL;
            }

            // Since we're only checking for a specific error code, we might
            // have left some value in retval.
            retVal = 0;

            DBFillGuidAndSid(pDB, pDSName);

            // Filter result by determining what the caller really has a right
            // to create under the parent.
            if(flags & SC_CHILDREN_USE_SECURITY) {
                // Apply the security
                CheckSecurityClassCacheArray(pTHS,
                                             RIGHT_DS_CREATE_CHILD,
                                             pNTSD,
                                             pDSName,
                                             cCandidates,
                                             rCandidates
                                             );

                // OK, we've Nulled out any elements in the rCandidates array
                // which we don't have add children rights to.
            }
        }

        // allocate the return list
        *ppLegalChildren = THAllocEx(pTHS, cCandidates * sizeof(CLASSCACHE *));


        // Filter out system-only classes as an external client can't create
        // one of them, and any classes we decided were illegal due to
        // security problems. Also filter out any abstract or auxiliary
        // class since these cannot be instantiated anyway

        for ( i = 0; i < cCandidates; i++ ) {
            if(!rCandidates[i] ||
               rCandidates[i]->bSystemOnly ||
                  (rCandidates[i]->ClassCategory == DS_ABSTRACT_CLASS) ||
                  (rCandidates[i]->ClassCategory == DS_AUXILIARY_CLASS) ) {
                continue;
            }

            // Finally a class the caller can add!

            (*ppLegalChildren)[(*pcLegalChildren)++] = rCandidates[i];
        }
    }
    __finally
    {
        if ( AbnormalTermination() )
            retVal = 1;

        // Committing read-only transaction is faster than aborting it.
        DBClose(pDB, TRUE);
    }

    return(retVal);
}

int
SCLegalAttrsOfName(
    DSNAME      *pDSName,           // IN
    BOOL        SecurityFilter,     // IN
    ULONG       *pcLegalAttrs,      // OUT
    ATTCACHE    ***ppLegalAttrs)    // OUT

/*++

Routine Description:

    Determines the set of attributes which can be modified
    on the object identified by pDSName.  Assumes the caller has
    a valid thread state, but not necessarily an open database.  This
    version of the procedure is intended for callers outside the core
    who are constructing a virtual attribute.

Arguments:

    pDSName - DSNAME of object under which a child is desired.

    SecurityFilter - Boolean which indicates whether to filter results by
        actual rights caller has on the pDSName object.

    pcLegalAttrs - pointer to count of legal attributes.

    ppLegalAttrs - pointer to array of ATTCACHE pointers representing
        writeable attrs.

Return Value:

    0 on success, !0 otherwise.
    Will not throw an exception.
    Will not set pTHStls->errCode.

--*/

{
    THSTATE *pTHS=pTHStls;
    int                  retVal = 1;
    DBPOS                *pDB;
    ULONG                *pClassId;
    ULONG                cCandidates;
    ULONG                *rCandidates;
    ATTCACHE             **rpCandidatesAC;
    CLASSCACHE           *pCC;
    ATTCACHE             *pAC;
    ULONG                len;
    ULONG                i, j, tmp;
    BOOL                 found;
    PSECURITY_DESCRIPTOR pNTSD=NULL;
    Assert(NULL != pTHS);

    *pcLegalAttrs = 0;
    *ppLegalAttrs = NULL;

    DBOpen(&pDB);

    __try
    {
        // PREFIX: dereferencing uninitialized pointer 'pDB' 
        //         DBOpen returns non-NULL pDB or throws an exception
        retVal = DBFindDSName(pDB, pDSName);

        if ( 0 != retVal )
            leave;

        retVal = DBGetAttVal(
                   pDB,                     // DBPos
                   1,                       // which value to get
                   ATT_OBJECT_CLASS,        // which attribute
                   DBGETATTVAL_fREALLOC,    // DB layer should alloc
                   0,                       // initial buffer size
                   &len,                    // output buffer size
                   (UCHAR **) &pClassId);   // output buffer

        if ( 0 != retVal )
            leave;

        pCC = SCGetClassById(pTHS, *pClassId);

        if ( 0 == pCC ) {
            retVal = 1;
            leave;
        }

        DBFillGuidAndSid(pDB, pDSName);

        // Get the Security Descriptor and the SID
        retVal = DBGetAttVal(
                pDB,
                1,
                ATT_NT_SECURITY_DESCRIPTOR,
                DBGETATTVAL_fREALLOC,
                0,
                &len,
                (UCHAR **) &pNTSD);

        if(retVal==DB_ERR_UNKNOWN_ERROR)
            leave;
        if(retVal) {
            len = 0;
            pNTSD = NULL;
        }

        // Construct array of candidate ATTCACHE pointers sans duplicates.

        cCandidates = pCC->MustCount +
                      pCC->MayCount;

        rCandidates = (ULONG *) THAllocEx(pTHS, cCandidates * sizeof(ULONG));
        rpCandidatesAC = (ATTCACHE **)
            THAllocEx(pTHS, cCandidates * sizeof(ATTCACHE *));

        tmp = 0;
        for ( i = 0; i < pCC->MustCount; i++ )
            rCandidates[tmp++] = pCC->pMustAtts[i];
        for ( i = 0; i < pCC->MayCount; i++ )
            rCandidates[tmp++] = pCC->pMayAtts[i];

        // Eliminate duplicates and map to ATTCACHE pointer.

        Assert(tmp == cCandidates);
        cCandidates = 0;

        for ( i = 0; i < tmp; i++ )
        {
            found = FALSE;

            for ( j = 0; j < i; j++ )
            {
                if ( rCandidates[i] == rCandidates[j] )
                {
                    found = TRUE;
                    break;
                }
            }

            if ( !found )
            {
                if (!(rpCandidatesAC[cCandidates++] =
                      SCGetAttById(pTHS, rCandidates[i]))) {
                    retVal = 1;
                    leave;
                }
            }
        }

        // cCandidates and rpCandidatesAC are now valid.

        if ( !SecurityFilter )
        {
            *pcLegalAttrs = cCandidates;
            *ppLegalAttrs = rpCandidatesAC;
            retVal = 0;
            leave;
        }
        else {
            // Apply the security
            CheckSecurityAttCacheArray(pTHS,
                                       RIGHT_DS_WRITE_PROPERTY,
                                       pNTSD,
                                       pDSName,
                                       cCandidates,
                                       pCC,
                                       rpCandidatesAC,
                                       CHECK_PERMISSIONS_WITHOUT_AUDITING
                                       );

            // Any properties we don't have rights to have been replaced
            // with a NULL in rgpAC.  See if any are NULL.
            // Start by trimming off NULLS from the end of the list.
            while (cCandidates && !rpCandidatesAC[cCandidates-1]) {
                cCandidates--;
            }

            // OK, if the list still has anything in it, then it ends with a
            // non-NULL element.

            for(i=0;i<cCandidates;i++) {

                if(!rpCandidatesAC[i]) {
                    // Found one we don't have rights to.  Trim it out of the
                    // list by grabbing the one from the end.
                    cCandidates--;
                    rpCandidatesAC[i] = rpCandidatesAC[cCandidates];

                    while (i < cCandidates && !rpCandidatesAC[cCandidates-1]) {
                        cCandidates--;
                    }
                    // OK, if the list still has anything in it, then it ends
                    // with a non-NULL element.
                }
            }

            // We've checked security and trimmed non-writable elements.
            *pcLegalAttrs = cCandidates;
            *ppLegalAttrs = rpCandidatesAC;
            retVal = 0;
            leave;
        }

        Assert("SecurityFilter for SCLegalAttrs not yet implemented!");

        retVal = 1;
    }
    __finally
    {
        if ( AbnormalTermination() )
            retVal = 1;

        // Committing read-only transaction is faster than aborting it.
        DBClose(pDB, TRUE);
    }

    return(retVal);
}

DSTIME SchemaFsmoLease;
VOID
SCExtendSchemaFsmoLease()
/*++
Routine Description:
    Extend the schema fsmo lease.

    The schema fsmo cannot be transferred for a few seconds after
    it has been transfered or after a schema change (excluding
    replicated or system changes). This gives the schema admin a
    chance to change the schema before having the fsmo pulled away
    by a competing schema admin who also wants to make schema
    changes.

    The length of the lease can only be altered by setting the registry
    and rebooting. See dsamain.c, GetDSARegistryParameters().
    
Arguments:
    None.

Return Values:
    None.
--*/
{
    SchemaFsmoLease = DBTime();
} // End SCExtendSchemaFsmoLease

BOOL
SCExpiredSchemaFsmoLease()
/*++
Routine Description:
    Has the schema fsmo lease expired?

    The schema fsmo cannot be transferred for a few seconds after
    it has been transfered or after a schema change (excluding
    replicated or system changes). This gives the schema admin a
    chance to change the schema before having the fsmo pulled away
    by a competing schema admin who also wants to make schema
    changes.

    The length of the lease can only be altered by setting the registry
    and rebooting. See dsamain.c, GetDSARegistryParameters().
    
Arguments:
    None.

Return Values:
    TRUE - has expired
    FALSE - has not expired
--*/
{
    DSTIME  Now = DBTime();
    extern ULONG gulSchemaFsmoLeaseSecs;

    // the lease is ridiculous or has expired
    if (   SchemaFsmoLease > Now
        || (SchemaFsmoLease + gulSchemaFsmoLeaseSecs) <= Now) {
        return TRUE;
    }

    // the lease is still held
    return FALSE;
} // End SCExpiredSchemaFsmoLease

BOOL
SCSignalSchemaUpdateLazy()
/*++
Routine Description:
    Wakeup the async thread, SCSchemaUpdateThread, to refresh the
    schema cache in 5 minutes.
    
Arguments:
    None.

Return Values:
    TRUE on success
--*/
{
    SCHEMASTATS_INC(SigLazy);
    return SetEvent(evSchema);
} // End SignalSchemaUpdateLazy

BOOL
SCSignalSchemaUpdateImmediate()
/*++
Routine Description:
    Wakeup the async thread, SCSchemaUpdateThread, to refresh the
    schema cache, now, after boosting its priority to a normal
    priority.
    
Arguments:
    None.

Return Values:
    TRUE on success
--*/
{
    SCHEMASTATS_INC(SigNow);
    // First, increase the thread's priority
    if (hAsyncSchemaUpdateThread) {
        SetThreadPriority(hAsyncSchemaUpdateThread, THREAD_PRIORITY_NORMAL);
    }
    return SetEvent(evUpdNow);
} // End SignalSchemaUpdateLazy

BOOL
SCCacheIsStale(
    VOID
    )
/*++
Routine Description:
    The cache is deemed "stale" if the global count of schema changes
    does not match the saved value in the schema cache.
    
    WARNING: the count is not incremented for every change to the database
    that would alter the incore schema cache. Rather it seems to be a count
    of changes that might affect the replication subsystem. Hence the cache
    reload thread can't use the count to discover if the schema cache is
    already up-to-date. We need a schema-dirty bit to prevent 
    reloading an already up-to-date cache.

Arguments:
    None.

Return Values:
    TRUE if the schema cache appears to be stale
    FALSE if the schema cache appears to be up-to-date
--*/
{
    BOOL Ret = FALSE;

    EnterCriticalSection( &csSchemaPtrUpdate );
    __try {
        if (!CurrSchemaPtr ||
            CurrSchemaPtr->lastChangeCached < gNoOfSchChangeSinceBoot) {
            Ret = TRUE;
        }
    } __finally {
        LeaveCriticalSection( &csSchemaPtrUpdate );
    }
    return Ret;
} // End SCCacheIsStale

VOID
SCRefreshSchemaPtr(
    IN THSTATE *pTHS
    )
/*++
Routine Description:
    Replace the thread's schema pointer with the address of the current
    schema cache if:
        There is a current schema cache.
        The thread has a schema cache pointer.
        The thread's schema cache pointer is not current.
    
    Decrement the ref count on the old schema cache and increment
    the ref count on the new schema cache. The old schema cache
    will be freed after its ref count hits 0.

Arguments:
    pTHS - thread state

Return Values:
    None.
--*/
{
    // Update the schema ptr in pTHS
    EnterCriticalSection( &csSchemaPtrUpdate );
    __try {
        // update iff one already exists
        if (   pTHS->CurrSchemaPtr
            && CurrSchemaPtr
            && pTHS->CurrSchemaPtr != CurrSchemaPtr ) {

            // release old schema ptr
            InterlockedDecrement(&(((SCHEMAPTR *) (pTHS->CurrSchemaPtr))->RefCount));

            // acquire new schema ptr
            pTHS->CurrSchemaPtr = CurrSchemaPtr;
            InterlockedIncrement(&(((SCHEMAPTR *) (pTHS->CurrSchemaPtr))->RefCount));
        }
    } __finally {
        LeaveCriticalSection(&csSchemaPtrUpdate);
    }
} // End SCRefreshSchemaPtr

BOOL
SCReplReloadCache(
    IN THSTATE  *pTHS,
    IN DWORD    TimeoutInMs
    )
/*++
Routine Description:
    Reload the schema cache for the replication subsystem.
        If the cache is stale, reload it.
        If the thread's schema cache pointer is stale, refresh it.
    
    The cache is deemed "stale" if the global count of schema changes
    does not match the saved value in the schema cache. WARNING: the
    count is not incremented for every change to the database that would
    alter the incore schema cache. Rather it seems to be a count of
    changes that might affect the replication subsystem. Hence the cache
    reload thread can't use the count to discover if the schema cache is
    already up-to-date. We need a schema-dirty bit to prevent 
    reloading an already up-to-date cache.

Arguments:
    pTHS - thread state
    TimeoutInMs - Wait at most this many milliseconds for the 
        reload thread to finish if it is currently busy and then
        wait at most this many milliseconds for the reload thread
        to complete after being signaled

Return Values:
    FALSE if the reload thread could not be signaled.
    TRUE for all other cases.
--*/
{
    BOOL    IsStale;
    DWORD   waitret;
    HANDLE  wmo[] = { evUpdRepl, hServDoneEvent };

    // If the cache is stale (see above), wait for the cache-reload thread
    IsStale = SCCacheIsStale();
    if (IsStale) {
        waitret = WaitForMultipleObjects(2, wmo, FALSE, TimeoutInMs);
        IsStale = SCCacheIsStale();
    }

    // If the cache is stale (see above), signal the cache-reload thread and wait
    if (IsStale) {
        // kick the reload thread
        ResetEvent(evUpdRepl);
        if (!SCSignalSchemaUpdateImmediate()) {
            // could not signal the reload thread
            return FALSE;
        }
        // Wait for the reload thread to finish
        waitret = WaitForMultipleObjects(2, wmo, FALSE, TimeoutInMs);

        // Now throttle schema reloads by waiting half the timeout
        // period to avoid saturating the src and dst DCs while the
        // schema is being modified concurrently with replication.
        Sleep(TimeoutInMs >> 1);

        // Check again to see if the schema is stale
        IsStale = SCCacheIsStale();

        // Lots of schema changes going on; wait a bit more
        if (IsStale) {
            Sleep(TimeoutInMs >> 1);
        }
    }

    // If the cache is not stale (see above), refresh thread's schema ptr
    if (!IsStale && pTHS->CurrSchemaPtr != CurrSchemaPtr) {
        SCRefreshSchemaPtr(pTHS);
    }
    return TRUE;
} // End SCReplReloadCache

//-----------------------------------------------------------------------
//
// Function Name:            RecalcPrefixTable
//
// Routine Description:
//
//    Creates a new schemaptr, copies the thread's old schema pointer
//    to it, and then reloads the prefix table from the dit. So on
//    exit, the thread state's schema pointer points to basically the
//    schema cache pointed to by the calling thread's schema pointer,
//    only the prefix table part may be different (will contain prefixes
//    that are in the dit but not reflected in the calling thread's
//    schema cache)
//
// Arguments:
//
// Return Value:
//
//    int              Zero On Succeess
//
//-----------------------------------------------------------------------
int
RecalcPrefixTable()
{
    THSTATE *pTHS = pTHStls;
    int err = 0;
    ULONG PREFIXCOUNT = 0;
    SCHEMAPTR *tSchemaPtr, *oldSchemaPtr;
    PrefixTableEntry *ptr;

    // Find the calling thread's schema pointer. We will borrow most
    // of the schema cache pointers from it.

    oldSchemaPtr = pTHS->CurrSchemaPtr;

    // Must not be null. This is only called from AssignIndex, which
    // should have a proper schema pointer
    Assert(oldSchemaPtr);

    // Create a new schema pointer to put in the thread state. Cannot
    // work with the same pointer (oldSChemaPtr) as we will reload
    // the prefix table part, which may be different

    if (SCCalloc(&pTHS->CurrSchemaPtr, 1, sizeof(SCHEMAPTR))) {
        return ERROR_DS_CANT_CACHE_ATT;
    }
    tSchemaPtr = pTHS->CurrSchemaPtr;

    // Copy all cache pointers from oldSchemaPtr. Note that since
    // the calling thread has ref-counted this cache, and since
    // this new cache being built/copied will be used only during the
    // lifetime of the calling thread, there is no fear of the cache
    // being freed during validation, and so no need to increment the
    // ref-count to indicate that the same thread is using this cache
    // twice (sort of)

    memcpy(tSchemaPtr, oldSchemaPtr, sizeof(SCHEMAPTR));

    // Now just reload the prefix part. The calling function (right now
    // only AssignIndex) is responsible for freeing this (Size allocated
    // is decided in same way as in SCCacheSchemaInit during normal cache
    // building).

    // if the DS is installing, there is the possibility that the old
    // PREFIXCOUNT is quite different from the default one, and as a
    // result we are going to do a lot of reallocations on the prefixtable.
    // this way we at least start with a larger number for prefixcount.
    if (DsaIsInstalling()) {
        PREFIXCOUNT = oldSchemaPtr->PREFIXCOUNT;
    }

    if (PREFIXCOUNT < START_PREFIXCOUNT) {
        PREFIXCOUNT = START_PREFIXCOUNT;
    }

    while ( (2*(CurrSchemaPtr->PrefixTable.PrefixCount + 25)) > PREFIXCOUNT) {
          PREFIXCOUNT += START_PREFIXCOUNT;
    }

    tSchemaPtr->PREFIXCOUNT = PREFIXCOUNT;

    if (SCCalloc(&tSchemaPtr->PrefixTable.pPrefixEntry, tSchemaPtr->PREFIXCOUNT, sizeof(PrefixTableEntry))) {
         return ERROR_DS_CANT_CACHE_ATT;
    }
    ptr = tSchemaPtr->PrefixTable.pPrefixEntry;

    if (err = InitPrefixTable(ptr, tSchemaPtr->PREFIXCOUNT)) {
          DPRINT1(0, "InitPrefixTable Failed in RecalcPrefixTable %d\n", err);
          // Free allocated memory
          SCFreePrefixTable(&ptr, tSchemaPtr->PREFIXCOUNT);
          return err;
    }

    if (err = InitPrefixTable2(ptr, tSchemaPtr->PREFIXCOUNT)) {
          DPRINT1(0, "InitPrefixTable2 Failed in RecalcPrefixTable %d\n", err);
          // Free allocated memory
          SCFreePrefixTable(&ptr, tSchemaPtr->PREFIXCOUNT);
          return err;
    }

    return 0;

}


//-----------------------------------------------------------------------
//
// Function Name:            RecalcSchema
//
// Routine Description:
//
//    Calculates the Schema Cache for the current thread from the DIT
//
// Arguments:
//    pTHS - THSTATE pointer
//
// Return Value:
//
//    int              Zero On Succeess
//
//-----------------------------------------------------------------------
int
RecalcSchema(
             THSTATE *pTHS
)
{
    int err=0;
    BOOL    fDSA=pTHS->fDSA;


    __try {
        // Boost Async update thread's priority just in case
        // an async update is going on now, since there is a
        // critical section that is shared

        SetThreadPriority(hAsyncSchemaUpdateThread, THREAD_PRIORITY_NORMAL);

    _try
    {

        pTHS->fDSA=TRUE;
        pTHS->UpdateDITStructure=FALSE;

        //
        // Now do the most expensive set of operation in the DS.....
        //
        err = SCCacheSchemaInit ();
        if (err)
        {
            DPRINT1(0, "SCCacheSchemaInit: Error %d\n",err);

            // Free up the cache built so far
            SCFreeSchemaPtr(&pTHS->CurrSchemaPtr);

            pTHS->fDSA=fDSA;
            return err;
        }


        err = SCCacheSchema2();
        if (err)
        {
            DPRINT1(0, "SCCacheSchema2: Error %d\n",err);

            // Free up the cache built so far
            SCFreeSchemaPtr(&pTHS->CurrSchemaPtr);

            pTHS->fDSA=fDSA;
            return err;
        }

    }
    __except(HandleMostExceptions(err = GetExceptionCode()))
    {
        DPRINT1(0, "NTDS RecalcSchema: Exception %d\n",err);
    }

    }
    __finally {
       // Restore priority of async schema update thread to low
       SetThreadPriority(hAsyncSchemaUpdateThread, THREAD_PRIORITY_BELOW_NORMAL);
    }

    pTHS->fDSA=fDSA;

    return err;

} // End RecalcSchema


//-----------------------------------------------------------------------
//
// Function Name:            SCUpdateSchemaHelper
//
// Routine Description:
//
//    Helper function to update the Schema By calling the
//    Schema Init Code, and unloads the old cache. Called by
//    blocking and async schema cache update routines.
//
//
// Return Value:
//
//    int              Zero On Succeess, non-zero on error
//
//-----------------------------------------------------------------------
int SCUpdateSchemaHelper()
{

    int err = 0;
    THSTATE *pTHS = pTHStls;

    __try {
        __try {
            err = SCCacheSchemaInit ();
            if (err) {
                DPRINT1(0,"NTDS SCCacheSchemaInit: Schema Update Failed. Error %d\n",err);
                // Free up the cache built so far
                SCFreeSchemaPtr(&pTHS->CurrSchemaPtr);
                return err;
            }

            if (eServiceShutdown) {
                return 0;
            }

            // The cache load sees all changes until now (to be precise, there is
            //  a possibility of some schema change committing between this
            // and the opening of the transaction. But it is better to say we are
            // backdated (which will necessitate another cache update
            // wherever we check if the cache is uptodate with current changes) than
            // falsely say we are uptodate (which can cause inconsistencies)
            EnterCriticalSection(&csNoOfSchChangeUpdate);
            __try {
                ((SCHEMAPTR *) pTHS->CurrSchemaPtr)->lastChangeCached = gNoOfSchChangeSinceBoot;
            }
            __finally {
                LeaveCriticalSection(&csNoOfSchChangeUpdate);
            }

            // This may add Jet columns
            SYNC_TRANS_WRITE();
            EnterCriticalSection(&csJetColumnUpdate);
            __try {
                 err = SCCacheSchema2();
             }
            __finally {
                 LeaveCriticalSection(&csJetColumnUpdate);
                 if (err && pTHS->errCode==0) {
                    SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,ERROR_DS_SCHEMA_NOT_LOADED,err);
				 }
                 CLEAN_BEFORE_RETURN(pTHS->errCode);

            }

             if (err)
               {
                  DPRINT1(0,"NTDS SCCacheSchema2: Schema Update Failed. Error %d\n",err);

                  // Free up the cache built so far
                  SCFreeSchemaPtr(&pTHS->CurrSchemaPtr);

                  return err;
               }

             if (eServiceShutdown) {
                 return 0;
             }

             // Should not have a dbpos here, since the one opened above
             // have been closed

             Assert(!pTHS->pDB);

             // This may delete unused Jet columns
             EnterCriticalSection(&csJetColumnUpdate);
             __try {
                 err = SCCacheSchema3() ;
              }
             __finally {
                 LeaveCriticalSection(&csJetColumnUpdate);
              }

             if (err)
               {
                 DPRINT1(0,"NTDS SCCacheSchema3: Schema Update Failed. Error%d\n",err);

                 // Free up the cache built so far
                 SCFreeSchemaPtr(&pTHS->CurrSchemaPtr);

                 return err;
               }


            if (eServiceShutdown) {
                return 0;
            }

             //
             // Assign the Schema Ptr
             // But first enqueue the old schema cache for delayed freeing
             // Unload only if not installing, no need to unload during install

             // if this is called from the async thread, the thread's priority
             // may be low. Set it to normal to speed this part up, as this critical
             // section is also used to assign Schema Ptr during user thread
             // initialization. If this is called from the blockign thread,
             // which already has a normal priority, this has no effect. For
             // the async case, the thread priority will be set back
             // to below normal when the schema update is over

             SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
             EnterCriticalSection(&csSchemaPtrUpdate);
             __try {
                 // Its odd that SCUnloadSchema handles the case of
                 // DsaIsInstalling() but this code never calls it
                 // unless DsaIsRunning()?
                 if (DsaIsRunning()) {
                   SCUnloadSchema(TRUE);
                 }
                 CurrSchemaPtr = pTHS->CurrSchemaPtr;
               }
             __finally {
                 LeaveCriticalSection(&csSchemaPtrUpdate);
               }
             lastSchemaUpdateTime = DBTime();

         }
         __finally {
             if (err && pTHS->errCode==0) {
                 SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,ERROR_DS_SCHEMA_NOT_LOADED,err);
             }
         }
    }
    __except(HandleMostExceptions(err = GetExceptionCode()))
      {
         DPRINT1(0,"NTDS SCUpdateSchemaHelper: Exception %d\n",err);
      }

    return err;

}





//-----------------------------------------------------------------------
//
// Function Name:            SCUpdateSchema
//
// Routine Description:
//
//    Updates the Schema By calling the Schema Init Code
//    Assumes being called by the async thread, so creates
//    and frees thread state
//
// Author: RajNath
// Date  : [3/7/1997]
//
// Arguments:
//
//
// Return Value:
//
//    int              Zero On Succeess
//
//-----------------------------------------------------------------------
int
SCUpdateSchema(
    )
{
    int err = 0;
    SCHEMAPTR *oldSchemaPtr;
    THSTATE* pTHS;

    SCHEMASTATS_INC(Reload);

    // The replication thread should wait (See SCReplReloadCache()) for
    // the schema reload to finish
    ResetEvent(evUpdRepl);

    // prevent spurious reloads
    ResetEvent(evUpdNow);
    ResetEvent(evSchema);

    //
    // Create The global pTHStls for this thread
    //


    pTHS=InitTHSTATE(CALLERTYPE_INTERNAL);
    if(!pTHS) {
        return STATUS_NO_MEMORY;
    }

    __try {

        // Serialize schema cache updates

        EnterCriticalSection(&csSchemaCacheUpdate);

        __try
        {

            // Since InitTHSTATE will assign the current schemaptr
            // to pTHS->CurrSchemaPtr and increase its RefCount,
            // save the schema ptr to readjust RefCount at the end.
            // This is necessary since pTHS->CurrSchemaPtr will change
            // after this next cache load below

            oldSchemaPtr = (SCHEMAPTR *) (pTHS->CurrSchemaPtr);


            pTHS->fDSA=TRUE;
            pTHS->UpdateDITStructure=TRUE;


            // Call the helper routine to do the actual update
            err = SCUpdateSchemaHelper();
            if (err) {
              DPRINT1(0,"Async Schema Update Failed %d\n", err);
            }

        }
        __finally
        {

            LeaveCriticalSection(&csSchemaCacheUpdate);

            // Before freeing the thread state, check the schema ptr
            // If it is the same as the old schema ptr, then some error
            // occured in this routine and the new cache didn't get created
            // In this case, we need not do anything, since the call below
            // will decrement the RefCount of the old cache pointer (since
            // it was incremented in the InitTHSTATE cal). If however, the
            // thread's schema ptr is now different, then we need to
            // decrement the old schema ptr's RefCount, and also, increment
            // the new schema ptr's RefCount, since it will be decremented
            // by one in the free_thread_state call (since this was not
            // the schema cache that got incremented in the InitTHSTATE call)


            if ( pTHS->CurrSchemaPtr != oldSchemaPtr ) {
              if (oldSchemaPtr) {
                  InterlockedDecrement(&(oldSchemaPtr->RefCount));
              }
              if (pTHS->CurrSchemaPtr) {
               InterlockedIncrement(&(((SCHEMAPTR *) (pTHS->CurrSchemaPtr))->RefCount));
              }
            }

            free_thread_state();
        }
    }
    __except(HandleMostExceptions(err = GetExceptionCode()))
    {

        DPRINT1(0,"NTDS SCUpdateSchema: Exception %d\n",err);
    }


    if (err)
    {
        DPRINT1(0,"NTDS: SCSchemaUpdateThread Failure %d\n",err);
    }

    return err;

} // End SCUpdateSchema


//-----------------------------------------------------------------------
//
// Function Name:            SCUpdateSchemaBlocking
//
// Routine Description:
//
//    Updates the Schema By calling the Schema Init Code
//    Assumes it is called by a thread with already initialized
//    thread state, so does not create/free thread state and saves
//    and restores currency etc. properly
//
//
//    Assumes no open transactions. Because of the possibility of
//    simultaneous blocking and async cache updates, it is important
//    that their transactions are effectively serialized to allow
//    database changes made by one such as column creation/deletion
//    etc. to be seen by th other immediately
//
// Arguments: None
//
//
// Return Value:
//
//    int              Zero On Succeess, non-zero on failure
//
//-----------------------------------------------------------------------
int
SCUpdateSchemaBlocking
(
)
{
    int err = 0;
    PVOID   pOutBuf;
    SCHEMAPTR *oldSchemaPtr;
    ULONG dntSave=0;
    BOOL fDSASave, updateDitStructureSave;
    THSTATE* pTHS = pTHStls;


    // Check that proper thread state is non-null

    Assert(pTHS);

    // Should not have open transaction
    Assert (!pTHS->pDB);

    __try {
        // Boost Async update thread's priority just in case
        // an async update is going on now, since we will be blocked
        // on that

        if (hAsyncSchemaUpdateThread) {
            SetThreadPriority(hAsyncSchemaUpdateThread, THREAD_PRIORITY_NORMAL);
        }

        // Serialize simultaneous cache updates

        EnterCriticalSection(&csSchemaCacheUpdate);

        __try
        {
            // Save schema pointer etc.

            oldSchemaPtr = (SCHEMAPTR *) (pTHS->CurrSchemaPtr);
            fDSASave = pTHS->fDSA;
            updateDitStructureSave = pTHS->UpdateDITStructure;


            // Prepare for cache update

            pTHS->fDSA=TRUE;
            pTHS->UpdateDITStructure=TRUE;


            // Call the helper routine to do the actual update
            err = SCUpdateSchemaHelper();

            if (err) {
              DPRINT1(0,"Blocking Schema Update Failed %d\n", err);
            }

        }
        __finally
        {
            LeaveCriticalSection(&csSchemaCacheUpdate);

            // Restore priority of async schema update thread to low
            if (hAsyncSchemaUpdateThread) {
                SetThreadPriority(hAsyncSchemaUpdateThread, THREAD_PRIORITY_BELOW_NORMAL);
            }

            // Restore schema pointer etc. (Restore schema ptr to the one this
            // thread started with to allow proper ref count update when
            // the thread exits)

            pTHS->CurrSchemaPtr = oldSchemaPtr;
            pTHS->fDSA = fDSASave;
            pTHS->UpdateDITStructure = updateDitStructureSave;

        }
    }
    __except(HandleMostExceptions(err = GetExceptionCode()))
    {

        DPRINT1(0,"NTDS SCUpdateSchemaBlocking: Exception %d\n",err);
    }

    if (err) {
        DPRINT1(0,"NTDS: SCSchemaUpdateThread Failure %d\n",err);
    }
    else {
        // Updated successfully, log a message
        LogEvent(DS_EVENT_CAT_SCHEMA,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_SCHEMA_CACHE_UPDATED,
                 0, 0, 0);
     }

    return err;

} // End SCUpdateSchemaBlocking





//-----------------------------------------------------------------------
//
// Function Name:            SCSchemaUpdateThread
//
// Routine Description:
//
//    Asynchronous Thread used for updating the Schema
//
// Author: RajNath
// Date  : [3/7/1997]
//
// Arguments:
//
//
// Return Value:
//
//    Does not return
//
//-----------------------------------------------------------------------
ULONG
SCSchemaUpdateThread(PVOID pv)
{

    HANDLE wmo[]={evSchema,evUpdNow,hServDoneEvent};
    HANDLE wmo1[]={evUpdNow,hServDoneEvent};
    DWORD  waitret, waitret1;
    ULONG  err = 0;
    ULONG  cRetry = 0;

    //
    // This Function is executed in a Thread. For performance reasons
    // we do not want to call SCUpdate Schema every time the Schema container
    // is touched but instead five minutes or when signaled.
    //

    // Users should not have to wait for this.
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL);

    if (evSchema == NULL || evUpdNow == NULL || evUpdRepl == NULL)
    {
        DPRINT1(0, "NTDS: SchemaUpdateThread Startup Failed. Error %d\n",GetLastError());
        return GetLastError();
    }

    while (!eServiceShutdown) {
        // The replication thread can continue (SCReplReloadCache())
        SetEvent(evUpdRepl);
        waitret = WaitForMultipleObjects(3,wmo,FALSE,INFINITE);

        switch ((waitret))
        {
            case WAIT_OBJECT_0:
            {
                //
                // Someone just updated the Schema Container and wants us to
                // Update the SchemaCache. Lets wait 5 minutes or Someone says
                // update now.
                //
                waitret1 = WaitForMultipleObjects(2,
                                                  wmo1,
                                                  FALSE,
                                                  gdwRecalcDelayMs);

                // No ned to check waitret1, since eServiceShutdown is
                // set before hServDoneEvent is signalled

                if (!eServiceShutdown) {
                   err = SCUpdateSchema();
                   if (err) {
                     // The update failed for some reason. Retry the
                     // cache update after some time. Log in the eventlog

                      cRetry++;
                      if (cRetry <= maxRetry) {
                          LogEvent(DS_EVENT_CAT_SCHEMA,
                                   DS_EVENT_SEV_VERBOSE,
                                   DIRLOG_SCHEMA_CACHE_UPDATE_RETRY,
                                   szInsertUL(err),
                                   szInsertUL(maxRetry),
                                   szInsertUL(cRetry));
                      }

                      if ( (cRetry > maxRetry)
                              || !SCSignalSchemaUpdateLazy() ) {

                        // Either already retried too many times, or cannot
                        // even signal a  schema update. Log an error,
                        // reset retry counter, and abort

                        cRetry = 0;

                        LogEvent(DS_EVENT_CAT_SCHEMA,
                           DS_EVENT_SEV_ALWAYS,
                           DIRLOG_SCHEMA_CACHE_UPDATE_FAILED, szInsertUL(err), 0, 0);
                     }
                   }
                   else {
                      // Cache update is successful. Reset retry counter
                      cRetry = 0;

                      // log a message
                      LogEvent(DS_EVENT_CAT_SCHEMA,
                               DS_EVENT_SEV_MINIMAL,
                               DIRLOG_SCHEMA_CACHE_UPDATED,
                               0, 0, 0);

                   }

                   // Set thread priority back to below normal. We set it
                   // to normal for a small part in SCUpdateSchemaHelper so
                   // as to not get starved out while inside a critical
                   // section that is also used by user threads
                   SetThreadPriority(GetCurrentThread(),
                                     THREAD_PRIORITY_BELOW_NORMAL);
                }
            }
            break;

            case WAIT_OBJECT_0+1:
            {
                //
                // Someone wants to update schema immediately
                //
                if (!eServiceShutdown) {
                   err = SCUpdateSchema();
                   if (err) {
                     // The update failed for some reason. Retry the
                     // cache update after some time. Log in eventlog

                      cRetry++;
                      if (cRetry <= maxRetry) {
                         LogEvent(DS_EVENT_CAT_SCHEMA,
                                  DS_EVENT_SEV_VERBOSE,
                                  DIRLOG_SCHEMA_CACHE_UPDATE_RETRY,
                                  szInsertUL(err),
                                  szInsertUL(maxRetry),
                                  szInsertUL(cRetry));
                      }

                      if ( (cRetry > maxRetry)
                              || !SCSignalSchemaUpdateLazy() ) {

                        // Either already retried too many times, or cannot
                        // even signal a  schema update. Log an error,
                        // reset retry counter, and abort

                        cRetry = 0;

                        LogEvent(DS_EVENT_CAT_SCHEMA,
                                 DS_EVENT_SEV_ALWAYS,
                                 DIRLOG_SCHEMA_CACHE_UPDATE_FAILED,
                                 szInsertUL(err),
                                 0,
                                 0);
                     }
                   }
                   else {
                      // Cache update is successful. Reset retry counter
                      cRetry = 0;

                      // log a message
                      LogEvent(DS_EVENT_CAT_SCHEMA,
                               DS_EVENT_SEV_MINIMAL,
                               DIRLOG_SCHEMA_CACHE_UPDATED,
                               0, 0, 0);
                   }

                   // Set thread priority back to below normal. We set it
                   // to normal for a small part in SCUpdateSchemaHelper so
                   // as to not get starved out while inside a critical
                   // section that is also used by user threads
                   SetThreadPriority(GetCurrentThread(),
                                     THREAD_PRIORITY_BELOW_NORMAL);
                }
            }
            break;


            case WAIT_OBJECT_0+2:
            {
                //Service Shutdown:

                DPRINT(0,"Shutting down schema update thread\n");

                // Don't close the thread handle, because the main thread
                // is using it to track this thread's shutdown.
                return 0;
            }
            break;

            default:
            {
                //
                // Some Error Happened
                //
                DPRINT1(0,"NTDS: SCSchemaUpdateThread Failure %d\n",waitret);

            }
            break;


        }
    }

    //
    // Never Gets Here except on service shutdown
    //
    DPRINT(0,"Shutting down schema update thread \n");

    return 0;

} // End SCSchemaUpdateThread

DSTIME
SCGetSchemaTimeStamp (
        )
{
    return CurrSchemaPtr->sysTime;
}

DSNAME *
DsGetDefaultObjCategory(
    IN  ATTRTYP objClass
    )
/*++

Routine Description:

    Return the DSNAME of the default object category for the given object class.

    EXPORTED TO IN-PROCESS, EX-MODULE CLIENTS.

    This allows e.g. the KCC to construct DirSearch()s using ATT_OBJECT_CATEGORY
    filters.

Arguments:

    objClass (IN) - Object class of category of interest.

Return Values:

    (DSNAME *) The associated object category, or NULL if not found.

--*/
{
    THSTATE *    pTHS = pTHStls;
    CLASSCACHE * pCC;

    pCC = SCGetClassById(pTHS, objClass);
    if (NULL == pCC) {
        return NULL;
    }
    else {
        return pCC->pDefaultObjCategory;
    }
}


ATTCACHE **
SCGetTypeOrderedList(
    THSTATE *pTHS,
    IN CLASSCACHE *pCC
    )
/*++
    Routine Description:
        Given a classcache, return a list of ALL mays and musts sorted by attrtype.
        First time this is called for a class, the list is computed and
        hanged off the classcache structure; next time the earlier computed
        structure is returned. Of course if a schema cache load occurs for
        reason, the list is freed and recomputed again when it is asked for.
        The count of different types of atts (link, backlink, constructed,
        and column) is also cached for better searching in the calle if needed

    Arguments:
        pTHS - pointer to thread state to access schema cache
        pCC  - pointer to classcache

    Return value:
        pointer to list of attcaches on success (no. of elements on list
        = pCC->MayCount + pCC->MustCount, so not explicitly returned), NULL
        on failure (only failures possible now is failure to find an attribute
        in schema cache, which is catastrophic anyway, and allocation failure)
--*/
{
    ATTCACHE **rgpAC = NULL, **rgpACSaved;
    ULONG i, nAtts, cLink = 0, cBackLink = 0, cConstructed = 0, cCol = 0;

    // CLASSCACHEes are always intialized to 0, so if the pointer
    // is non-0, it must point to an already computed list
    if (pCC->ppAllAtts) {
       return pCC->ppAllAtts;
    }

    // not there, so compute it

    EnterCriticalSection(&csOrderClassCacheAtts);
    __try {
        if (pCC->ppAllAtts) {
           // someone else has computed it from the time we checked in
           // the read above. So just return it
           __leave;
        }

        // else, we need to compute and add it to the classcache

        if (SCCalloc((VOID **)&rgpAC, (pCC->MayCount + pCC->MustCount), sizeof(ATTCACHE *))) {
           __leave;
        }

        // first, just find and copy the attcaches
        nAtts = 0;
        for (i=0; i<pCC->MayCount; i++) {
           rgpAC[nAtts] = SCGetAttById(pTHS, (pCC->pMayAtts)[i]);
           if (!rgpAC[nAtts]) {
               DPRINT1(1,"SCGetColOrderedList: Couldn't find attcache for attribute 0x%x\n", (pCC->pMayAtts)[i]);
           } else {
               ++nAtts;
           }
        }

        for (i=0; i<pCC->MustCount; i++) {
           rgpAC[nAtts] = SCGetAttById(pTHS, (pCC->pMustAtts)[i]);
           if (!rgpAC[nAtts]) {
               DPRINT1(1,"SCGetColOrderedList: Couldn't find attcache for attribute 0x%x\n", (pCC->pMustAtts)[i]);
            } else {
                ++nAtts;
            }
        }

        // Count the different type of atts and store
        if (SCCalloc(&pCC->pAttTypeCounts, 1, sizeof(ATTTYPECOUNTS))) {
            SCFree((VOID **)&rgpAC);
            __leave;
        }

        for (i = 0; i < nAtts; i++) {
            if (FIsLink((rgpAC[i])->ulLinkID)) {
                (pCC->pAttTypeCounts)->cLinkAtts++;
            } else if (FIsBacklink((rgpAC[i])->ulLinkID)) {
                (pCC->pAttTypeCounts)->cBackLinkAtts++;
            } else if ((rgpAC[i])->bIsConstructed) {
                (pCC->pAttTypeCounts)->cConstructedAtts++;
            } else {
                (pCC->pAttTypeCounts)->cColumnAtts++;
            }
        }

        qsort(rgpAC,
              nAtts,
              sizeof(rgpAC[0]),
              CmpACByAttType);

        rgpACSaved = rgpAC;

        // add the pointer
        InterlockedExchangePointer((PVOID *)&(pCC->ppAllAtts), (PVOID)rgpAC);

        // Just a  doublecheck that the pointer assignment was fine, since this
        // is a new api  to ensure compatibility with 64 bit NT
        Assert(pCC->ppAllAtts == rgpACSaved);

     }
     __finally {
        LeaveCriticalSection(&csOrderClassCacheAtts);
     }

     return pCC->ppAllAtts;
}

typedef struct _AttMapping {
    ATTRTYP schemaAttrTyp; 
    ATTRTYP tempAttrTyp;
    int     tempOMsyntax;

} AttMapping;


// Two flavor of attributes. 
// default in BINARY so we explicitly specify XML
//
AttMapping xmlAttrs[] = {
// this table can be used to address translation to XML for attributes like ldapAdminLimits
//        ATT_LDAP_ADMIN_LIMITS,  ATT_LDAP_ADMIN_LIMITS_XML, OM_S_UNICODE_STRING,
        0,                      0};

// default in XML so we explicitly specify BINARY
//
AttMapping otherAttrs[] = {
    ATT_MS_DS_NC_REPL_INBOUND_NEIGHBORS,    ATT_MS_DS_NC_REPL_INBOUND_NEIGHBORS_BINARY,    OM_S_OCTET_STRING,
    ATT_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS,   ATT_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS_BINARY,   OM_S_OCTET_STRING,
    ATT_MS_DS_NC_REPL_CURSORS,              ATT_MS_DS_NC_REPL_CURSORS_BINARY,              OM_S_OCTET_STRING,
    ATT_MS_DS_REPL_ATTRIBUTE_META_DATA,     ATT_MS_DS_REPL_ATTRIBUTE_META_DATA_BINARY,     OM_S_OCTET_STRING,
    ATT_MS_DS_REPL_VALUE_META_DATA,         ATT_MS_DS_REPL_VALUE_META_DATA_BINARY,         OM_S_OCTET_STRING,
    0,                                      0, 0};

ATTCACHE* SCGetAttSpecialFlavor (THSTATE *pTHS, ATTCACHE *pAC, BOOL fXML)
{
    ATTCACHE *pNewAC;
    ATTRTYP   newID = 0;
    int       newOMsyntax = 0;
    SCHEMAEXT *pSchExt = (SCHEMAEXT *)pTHS->pExtSchemaPtr;
    DWORD i;

    // are we looking for the XML flavor (binary was the default).
    if (fXML) {
        for (i=0; xmlAttrs[i].schemaAttrTyp; i++) {
            if (pAC->id == xmlAttrs[i].schemaAttrTyp) {
                newID = xmlAttrs[i].tempAttrTyp;
                newOMsyntax = xmlAttrs[i].tempOMsyntax;
                break;
            }
        }
    }
    // so we are looking for the binary flavor (xml is the default).
    else {
        for (i=0; otherAttrs[i].schemaAttrTyp; i++) {
            if (pAC->id == otherAttrs[i].schemaAttrTyp) {
                newID = otherAttrs[i].tempAttrTyp;
                newOMsyntax = otherAttrs[i].tempOMsyntax;
                break;
            }
        }
    }

    if (!newID) {
        return NULL;
    }

    if (pSchExt != NULL) {
        for (i=0; i<pSchExt->cUsed; i++) {
            if (pSchExt->ppACs[i]->id == newID) {
                return pSchExt->ppACs[i];
            }
        }
    }
    else {
        pSchExt = THAllocEx (pTHS, sizeof (SCHEMAEXT));
        pSchExt->ppACs = THAllocEx(pTHS, sizeof (ATTCACHE *) * 16);
        pSchExt->cAlloced = 16;

        pTHS->pExtSchemaPtr = (PVOID)pSchExt;
    }

    if (pSchExt->cUsed == pSchExt->cAlloced) {
        pSchExt->cAlloced *= 2;
        pSchExt->ppACs = THReAllocEx(pTHS, pSchExt->ppACs, sizeof (ATTCACHE *) * pSchExt->cAlloced);
    }

    pNewAC = THAllocEx (pTHS, sizeof (ATTCACHE));
    memcpy (pNewAC, pAC, sizeof (ATTCACHE));
    pNewAC->id = newID;
    pNewAC->OMsyntax = newOMsyntax;
    pNewAC->aliasID = pAC->id;

    pSchExt->ppACs[pSchExt->cUsed++] = pNewAC;

    return pNewAC;
}

ATTRTYP
SCAutoIntId(
    THSTATE     *pTHS
    )
/*++
Routine Description:

    Automatically generate an intid.
    
Arguments:
    pTHS - thread state that addresses a schema cache. The schema
           cache may be built by RecalcSchema. The private schema
           cache includes the uncommitted changes (add/mod/del) for ac.

Return Values:
    next IntId or INVALID_ATT if none available
--*/
{
    DWORD   i;
    ULONG   ulRange, ulBase;

    // calculate using this thread's schema cache
    srand(GetTickCount());
    ulRange = MakeLinkBase(LAST_INTID_ATT - FIRST_INTID_ATT) + 1;
    ulBase = ((rand() << 15) ^ rand()) % ulRange;
    for (i = 0; i < ulRange; ++i, ulBase = ++ulBase % ulRange) {
        if (!SCGetAttById(pTHS, FIRST_INTID_ATT + ulBase)) {
            return FIRST_INTID_ATT + ulBase;
        }
    }

    return INVALID_ATT;
} // SCAutoIntId

#if DBG && INCLUDE_UNIT_TESTS

// Below are some a unit test to check if the in memory schema cache is
// consistent with the one on disk. This code is duplicated from the SchemaInit* functions
//


CLASSCACHE* scAddClass_test(THSTATE *pTHS,
                       ENTINF *pEI,
                       int *mismatch,
                       SCHEMAPTR *CurrSchemaPtr 
                       )
{
    CLASSCACHE *pCC, *pCCNew;
    ULONG       i;
    ULONG       err;
    ULONG aid;
    int SDLen;

    ULONG *pMayAtts, *pMyMayAtts,*pMustAtts, *pMyMustAtts; 
    ULONG *pSubClassOf,*pAuxClass, *pPossSup, *pMyPossSup;
    
    ULONG *tpMayAtts, *tpMyMayAtts,*tpMustAtts, *tpMyMustAtts; 
    ULONG *tpSubClassOf,*tpAuxClass, *tpPossSup, *tpMyPossSup;
    
    
    ULONG  MayCount, MyMayCount, MustCount, MyMustCount;
    ULONG  SubClassCount, AuxClassCount, PossSupCount, MyPossSupCount;

    ULONG CLSCOUNT     = ((SCHEMAPTR*)(CurrSchemaPtr))->CLSCOUNT;
    HASHCACHE*       ahcClass     = ((SCHEMAPTR*)(CurrSchemaPtr))->ahcClass;
    
    pMayAtts = pMyMayAtts = pMustAtts = pMyMustAtts =
        pSubClassOf = pAuxClass = pPossSup = pMyPossSup = 0;
    
    MayCount = MyMayCount = MustCount = MyMustCount = SubClassCount =
        AuxClassCount = PossSupCount = MyPossSupCount = 0;

    *mismatch = 0;


    // Look for the clsid
    for(i=0;i<pEI->AttrBlock.attrCount;i++) {
        if(pEI->AttrBlock.pAttr[i].attrTyp == ATT_GOVERNS_ID) {
            // found the attribute id, save the value.
            aid = *(ULONG*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal;
            break;  // go home.
        }
    }

    pCCNew = SCGetClassById(pTHS, aid);

    for (i=SChash(aid,CLSCOUNT);
         (ahcClass[i].pVal && (ahcClass[i].hKey != aid)); i=(i+1)%CLSCOUNT) {
        ;
    }

    pCC = ahcClass[i].pVal;


    if (!pCC || pCC->ClassId != aid)
    {
        DPRINT1 (0, "scAddClass_test: ERROR, class %d not found\n", aid);
        return NULL;
    }
    else {
        if (pCC->name) {
            DPRINT1 (0, "scAddClass_test: checking %s\n", pCC->name);
        }
    }


    // Now walk the attrblock and add the appropriate fields to the CC
    for(i=0;i<pEI->AttrBlock.attrCount;i++) {
        switch (pEI->AttrBlock.pAttr[i].attrTyp) {
        case ATT_DEFAULT_SECURITY_DESCRIPTOR:
          {

            // A default security descriptor.  We need to copy this value to
            // long term memory and save the size.
            // But this is a string. We first need to convert. It
            // is a wide-char string now, but we need to null-terminate
            // it for the security conversion. Yikes! This means I
            // have to realloc for that one extra char!

            UCHAR *sdBuf = NULL;
            WCHAR *strSD =
                THAllocEx(pTHS,pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen + 2);

            memcpy(strSD, pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal,
                   pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen);
            strSD[(pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen)/sizeof(WCHAR)] = L'\0';

            if (!CachedConvertStringSDToSDRootDomainW
                 (
                   pTHS,
                   strSD,
                  (PSECURITY_DESCRIPTOR*) &sdBuf,
                   &SDLen
                  )) {
                // Failed to convert.

                    err = GetLastError();
                    LogEvent(DS_EVENT_CAT_SCHEMA,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_SCHEMA_SD_CONVERSION_FAILED,
                             szInsertWC(strSD),
                             szInsertWC(pEI->pName->StringName),
                             szInsertInt(err) );
                    // if heuristics reg key says to ignore bad default SDs
                    // and go on, do so
                    if (gulIgnoreBadDefaultSD) {
                        THFreeEx(pTHS,strSD);
                        continue;
                    }

                    // otherwise, raise error and return
                    SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_STRING_SD_CONVERSION_FAILED, err);
                    DPRINT1(0,"Default SD conversion failed, error %x\n",err);
                    Assert(!"Default security descriptor conversion failed");
                    THFreeEx(pTHS,strSD);
                    return NULL;
            }
            else {
                // Converted successfully
                
                if (memcmp(pCC->pSD, sdBuf, pCC->SDLen) != 0) {

                    DPRINT1 (0, "scAddClass_test: ERROR, SD different for class %d\n", aid);
                    THFreeEx(pTHS, sdBuf);
                    *mismatch = 1;
                }

                if (NULL!=sdBuf) {
                    THFreeEx(pTHS, sdBuf);
                    sdBuf = NULL;
                }
            }
            THFreeEx(pTHS,strSD);
        }

           break;


        case ATT_RDN_ATT_ID:

            if ( (pCC->RdnExtId != *(ULONG*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal) ||
                 (pCC->RDNAttIdPresent != TRUE ) ) {
                
                    DPRINT1 (0, "scAddClass_test: ERROR, ATT_RDN_ATT_ID different for class %d\n", aid);
                    *mismatch = 1;
            }
            break;


        case ATT_LDAP_DISPLAY_NAME:
            {
            DWORD name_size = pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen;
            char *name = THAllocEx(pTHS,name_size+1);
            int namelen;

            namelen = WideCharToMultiByte(
                    CP_UTF8,
                    0,
                    (LPCWSTR)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal,
                    (pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen  /
                     sizeof(wchar_t)),
                    name,
                    name_size,
                    NULL,
                    NULL);

            if (_mbsncmp (name, pCC->name, namelen) != 0) {
                DPRINT1 (0, "scAddClass_test: ERROR, ldapDisplayName different for class %d\n", aid);
                *mismatch = 1;
            }

            THFreeEx(pTHS,name);
            }
            break;
        
        case ATT_SYSTEM_ONLY:
            if (pCC->bSystemOnly !=
                *(ULONG*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal ) {
                DPRINT1 (0, "scAddClass_test: ERROR, ATT_SYSTEM_ONLY different for class %d\n", aid);
                *mismatch = 1;
            }
            break;


        case ATT_DEFAULT_HIDING_VALUE:
            if (pCC->bHideFromAB != (unsigned)
                *(BOOL*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal) {
                DPRINT1 (0, "scAddClass_test: ERROR, ATT_DEFAULT_HIDING_VALUE different for class %d\n", aid);
                *mismatch = 1;
            }
            break;


        case ATT_GOVERNS_ID:
            if (pCC->ClassId != *(ULONG*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal) {
                DPRINT1 (0, "scAddClass_test: ERROR, ATT_GOVERNS_ID different for class %d\n", aid);
                *mismatch = 1;
            }
            break;

        case ATT_SYSTEM_MAY_CONTAIN:
        case ATT_MAY_CONTAIN:

            if ( GetValList(&MayCount, &pMayAtts, 
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }
            if ( GetValList( &MyMayCount, &pMyMayAtts,
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }

            if(MyMayCount) {
                qsort(pMyMayAtts,
                    MyMayCount,
                    sizeof(ULONG),
                    CompareAttrtyp);
            }

            if (memcmp (pCC->pMyMayAtts, pMyMayAtts, pCC->MyMayCount * sizeof (ULONG)) != 0)  {

                DPRINT1 (0, "scAddClass_test: ERROR, myMAYAttrs different for class %d\n", aid);
                *mismatch = 1;
            }
            break;

        case ATT_SYSTEM_MUST_CONTAIN:
        case ATT_MUST_CONTAIN:


            if ( GetValList( &MustCount, &pMustAtts,
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }
            if ( GetValList( &MyMustCount, &pMyMustAtts,
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }

            if(MyMustCount) {
                qsort(pMyMustAtts,
                      MyMustCount,
                      sizeof(ULONG),
                      CompareAttrtyp);
            }

            if (memcmp (pCC->pMyMustAtts, pMyMustAtts, pCC->MyMustCount * sizeof (ULONG)) != 0 ) {

                DPRINT1 (0, "scAddClass_test: ERROR, myMUST*Attrs different for class %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_SUB_CLASS_OF:

            if ( GetValList( &SubClassCount, &pSubClassOf,
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }
            
            // first one in cache must be the direct superclass stored in dit
            // Also, the MySubClass field stores the direct superclass
            if ( (pCC->pSubClassOf[0] != pSubClassOf[0]) ||
                 (pCC->MySubClass != pSubClassOf[0]) ) {

                DPRINT1 (0, "scAddClass_test: ERROR, SUB_CLASS_OF different for class %d\n", aid);
                *mismatch = 1;
            }
            break;

        case ATT_OBJECT_CLASS_CATEGORY:
            if (pCC->ClassCategory !=
                *(ULONG*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal) {

                DPRINT1 (0, "scAddClass_test: ERROR, ATT_OBJECT_CLASS_CATEGORY different for class %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_DEFAULT_OBJECT_CATEGORY:
            {
                DWORD objCsize = pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen;

                if ( (memcmp(pCC->pDefaultObjCategory,
                       pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal,
                       pEI->AttrBlock.pAttr[i].AttrVal.pAVal->valLen) != 0 ) ||

                     (objCsize != DSNameSizeFromLen (pCC->pDefaultObjCategory->NameLen )) ) {

                    DPRINT1 (0, "scAddClass_test: ERROR, ATT_DEFAULT_OBJECT_CATEGORY different for class %d\n", aid);
                    *mismatch = 1;
                }

            }

            break;

        case ATT_SYSTEM_AUXILIARY_CLASS:
        case ATT_AUXILIARY_CLASS:
            if ( GetValList(&AuxClassCount, &pAuxClass,
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }
            
            if ( memcmp (pCC->pAuxClass, pAuxClass, pCC->AuxClassCount * sizeof (ULONG)) != 0)  {

                DPRINT1 (0, "scAddClass_test: ERROR, AUXILIARY_CLASS different for class %d\n", aid);
                *mismatch = 1;
            }
            break;

        case ATT_SCHEMA_ID_GUID:
            // The GUID for the attribute used for security checks
            if (memcmp(&pCC->propGuid,
                   pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal,
                   sizeof(pCC->propGuid)) != 0) {
                
                DPRINT1 (0, "scAddClass_test: ERROR, SCHEMA_ID_GUID different for class %d\n", aid);
                *mismatch = 1;
            }
            break;


        case ATT_SYSTEM_POSS_SUPERIORS:
        case ATT_POSS_SUPERIORS:
            if ( GetValList(&PossSupCount, &pPossSup,
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }
            if ( GetValList(&MyPossSupCount, &pMyPossSup,
                       &pEI->AttrBlock.pAttr[i]) ) {
                return NULL;
            }

            if(MyPossSupCount) {
                qsort(pMyPossSup,
                      MyPossSupCount,
                      sizeof(ULONG),
                      CompareAttrtyp);
            }

            if (memcmp (pCC->pMyPossSup, pMyPossSup, pCC->MyPossSupCount * sizeof (ULONG)) != 0)  {

                DPRINT1 (0, "scAddClass_test: ERROR, myPOSSSUP*Attrs different for class %d\n", aid);
                *mismatch = 1;
            }
            break;

        case ATT_IS_DEFUNCT:
            if (pCC->bDefunct != (unsigned)
                (*(DWORD*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal?1:0)) {

                DPRINT1 (0, "scAddClass_test: ERROR, ATT_IS_DEFUNCT different for class %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_SYSTEM_FLAGS:
            if ( (*(DWORD*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal & FLAG_SCHEMA_BASE_OBJECT) && 
                pCC->bIsBaseSchObj != TRUE ) {

                DPRINT1 (0, "scAddClass_test: ERROR, ATT_SYSTEM_FLAGS different for class %d\n", aid);
                *mismatch = 1;

            }
            break;
        default:
            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_SCHEMA_SURPLUS_INFO,
                     szInsertUL(pEI->AttrBlock.pAttr[i].attrTyp), 0, 0);
        }
        THFreeEx(pTHS, pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal);
        THFreeEx(pTHS, pEI->AttrBlock.pAttr[i].AttrVal.pAVal);
    }

    THFreeEx(pTHS, pEI->pName);
    THFreeEx(pTHS, pEI->AttrBlock.pAttr);


    SCFree(&pMayAtts);
    SCFree(&pMyMayAtts);
    SCFree(&pMustAtts);
    SCFree(&pMyMustAtts);
    SCFree(&pSubClassOf);
    SCFree(&pAuxClass);
    SCFree(&pPossSup);
    SCFree(&pMyPossSup);


    if (pCCNew) {
        if (pCC->pMayAtts && memcmp (pCC->pMayAtts, pCCNew->pMayAtts, pCC->MayCount * sizeof (ULONG)) != 0)  {

            DPRINT1 (0, "scAddClass_test: ERROR, MAYAttrs different for class %d\n", aid);
            *mismatch = 1;
        }
        
        if (pCC->pMustAtts && memcmp (pCC->pMustAtts, pCCNew->pMustAtts, pCC->MustCount * sizeof (ULONG)) != 0 ) {

            DPRINT1 (0, "scAddClass_test: ERROR, MUST*Attrs different for class %d\n", aid);
            *mismatch = 1;
        }

        if (pCC->pSubClassOf && memcmp (pCC->pSubClassOf, pCCNew->pSubClassOf, pCC->SubClassCount * sizeof (ULONG)) != 0) {

            DPRINT1 (0, "scAddClass_test: ERROR, SUB_CLASS_OF different for class %d\n", aid);
            *mismatch = 1;
        }

        if ( pCC->pAuxClass && memcmp (pCC->pAuxClass, pCCNew->pAuxClass, pCC->AuxClassCount * sizeof (ULONG)) != 0)  {

            DPRINT1 (0, "scAddClass_test: ERROR, AUXILIARY_CLASS different for class %d\n", aid);
            *mismatch = 1;
        }
        
        if (pCC->pPossSup && memcmp (pCC->pPossSup, pCCNew->pPossSup, pCC->PossSupCount * sizeof (ULONG)) != 0)  {

            DPRINT1 (0, "scAddClass_test: ERROR, POSSSUP*Attrs different for class %d\n", aid);
            *mismatch = 1;
        }
    }


    // ================================

    {
        HASHCACHESTRING* ahcClassName = ((SCHEMAPTR*)(CurrSchemaPtr))->ahcClassName;

        if (pCC->name) {
            for (i=SCNameHash(pCC->nameLen,pCC->name,CLSCOUNT);
                   (ahcClassName[i].pVal &&
                   (ahcClassName[i].length != pCC->nameLen ||
                     _memicmp(ahcClassName[i].value,pCC->name,pCC->nameLen)));
                   i=(i+1)%CLSCOUNT) {
            }
            if (ahcClassName[i].pVal != pCC) {
                DPRINT1 (0, "scAddClass_test: ERROR, ahcClassName different for class %d\n", aid);
                *mismatch = 1;
            }

        }

    }

    return pCC;
}

ATTCACHE*
scAddAtt_test(
        THSTATE *pTHS,
        ENTINF *pEI,
        int *mismatch,
        SCHEMAPTR *CurrSchemaPtr 
        )
{
    ATTRTYP aid=(ATTRTYP) -1;           // This is an invalid attribute id.
    ATTCACHE *pAC, *pACnew;
    ULONG i;
    int fNoJetCol = FALSE;
    unsigned syntax;
    char szIndexName [MAX_INDEX_NAME];      //used to create cached index names
    int  lenIndexName;
    ULONG ATTCOUNT     = ((SCHEMAPTR*)(CurrSchemaPtr))->ATTCOUNT;
    HASHCACHE*       ahcId  = ((SCHEMAPTR*)(CurrSchemaPtr))->ahcId;   \


    *mismatch = 0;


    // Look for the attid
    for(i=0;i<pEI->AttrBlock.attrCount;i++) {
        if(pEI->AttrBlock.pAttr[i].attrTyp == ATT_ATTRIBUTE_ID) {
            // found the attribute id, save the value.
            aid = *(ATTRTYP*)pEI->AttrBlock.pAttr[i].AttrVal.pAVal->pVal;
            break;  // go home.
        }
    }

    pACnew = SCGetAttById(pTHS, aid);

    for (i=SChash(aid,ATTCOUNT);
         (ahcId[i].pVal && (ahcId[i].hKey != aid)); i=(i+1)%ATTCOUNT) {
        ;
    }

    pAC = ahcId[i].pVal;


    if (!pAC || pAC->id != aid) {
        
        DPRINT1 (0, "scAddAtt_test: ERROR, attr %d not found\n", aid);
        return NULL;
    }
    else {
        if (pAC->name) {
            DPRINT1 (0, "scAddAtt_test: checking %s\n", pAC->name);
        }
    }


    // Now walk the attrblock and add the appropriate fields to the AC
    for(i=0;i< pEI->AttrBlock.attrCount;i++) {
        ATTRVAL * pAVal = pEI->AttrBlock.pAttr[i].AttrVal.pAVal;

        switch (pEI->AttrBlock.pAttr[i].attrTyp) {
        case ATT_SYSTEM_ONLY:
            if (pAC->bSystemOnly != *(ULONG*)pAVal->pVal) {
                DPRINT1 (0, "scAddAtt_test: ERROR, ATT_SYSTEM_ONLY different. Attr: %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_IS_SINGLE_VALUED:
            if (pAC->isSingleValued != *(BOOL*)pAVal->pVal) {
                DPRINT1 (0, "scAddAtt_test: ERROR, ATT_IS_SINGLE_VALUED different. Attr: %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_RANGE_LOWER:
            if (pAC->rangeLower != *(ULONG*)pAVal->pVal ||
                pAC->rangeLowerPresent != TRUE ) {
                DPRINT1 (0, "scAddAtt_test: ERROR, ATT_RANGE_LOWER different. Attr: %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_RANGE_UPPER:
            if (pAC->rangeUpper != *(ULONG*)pAVal->pVal ||
                pAC->rangeUpperPresent != TRUE ) {
                DPRINT1 (0, "scAddAtt_test: ERROR, ATT_RANGE_UPPER different. Attr: %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_LDAP_DISPLAY_NAME:
            {
            char *name = THAllocEx(pTHS,pAVal->valLen+1);
            int nameLen;

            nameLen = WideCharToMultiByte(
                    CP_UTF8,
                    0,
                    (LPCWSTR)pAVal->pVal,
                    (pAVal->valLen /
                     sizeof(wchar_t)),
                    name,
                    pAVal->valLen,
                    NULL,
                    NULL);
            
                if (_mbsncmp (name, pAC->name, nameLen) != 0) {
                    DPRINT1 (0, "scAddAtt_test: ERROR, ldapDisplayName different for class %d\n", aid);
                    *mismatch = 1;
                }
            THFreeEx(pTHS,name);
            }
            break;
        case ATT_ATTRIBUTE_SYNTAX:
            syntax = 0xFF & *(unsigned*)pAVal->pVal;
            
            if ( ((0xFF) & pAC->syntax) != ((0xFF) & syntax)) {
                DPRINT1 (0, "scAddAtt_test: ERROR, ATTRIBUTE_SYNTAX different. Attr: %d\n", aid);
                return NULL;
            }

            break;
        
        case ATT_OM_SYNTAX:
            if (pAC->OMsyntax != *(int*)pAVal->pVal) {
                DPRINT1 (0, "scAddAtt_test: ERROR, OM_SYNTAX different. Attr: %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_OM_OBJECT_CLASS:
            if (pAC->OMObjClass.length != pAVal->valLen || 
                memcmp(pAC->OMObjClass.elements,
                        pAVal->pVal,
                        pAVal->valLen) != 0) {

                DPRINT1 (0, "scAddAtt_test: ERROR, OM_OBJECT_CLASS different. Attr: %d\n", aid);
                *mismatch = 1;
            }

            break;
        case ATT_MAPI_ID:
            if (pAC->ulMapiID != *(ULONG*)pAVal->pVal) {
                DPRINT1 (0, "scAddAtt_test: ERROR, MAPI_ID different. Attr: %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_LINK_ID:
            if (pAC->ulLinkID != *(ULONG*)pAVal->pVal) {
                DPRINT1 (0, "scAddAtt_test: ERROR, LINK_ID different. Attr: %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_ATTRIBUTE_ID:
            break;
        case ATT_SEARCH_FLAGS:
            if (pAC->fSearchFlags != *(DWORD*)pAVal->pVal) {
                DPRINT1 (0, "scAddAtt_test: ERROR, SEARCH_FLAGS different. Attr: %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_SCHEMA_ID_GUID:
            // The GUID for the attribute used for security checks
            if (memcmp(&pAC->propGuid, pAVal->pVal, sizeof(pAC->propGuid)) != 0) {
                DPRINT1 (0, "scAddAtt_test: ERROR, SCHEMA_ID_GUID different. Attr: %d\n", aid);
                *mismatch = 1;
            }
            Assert(pAVal->valLen == sizeof(pAC->propGuid));
            break;
        case ATT_ATTRIBUTE_SECURITY_GUID:
            // The GUID for the attributes property set used for security checks
            if (memcmp(&pAC->propSetGuid, pAVal->pVal, sizeof(pAC->propSetGuid)) !=0 ) {
                DPRINT1 (0, "scAddAtt_test: ERROR, ATTRIBUTE_SECURITY_GUID different. Attr: %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_EXTENDED_CHARS_ALLOWED:
            if (pAC->bExtendedChars != (unsigned) (*(DWORD*)pAVal->pVal?1:0)) {
                DPRINT1 (0, "scAddAtt_test: ERROR, EXTENDED_CHAR_ALLOWED different. Attr: %d\n", aid);
                *mismatch = 1;
            }
                
            break;
        case ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET:
            if (*(DWORD*)pAVal->pVal)
            {
                pAC->bMemberOfPartialSet = TRUE;
            }
            break;
        case ATT_IS_DEFUNCT:
            if (pAC->bDefunct != (unsigned)(*(DWORD*)pAVal->pVal?1:0) ) {
                DPRINT1 (0, "scAddAtt_test: ERROR, IS_DEFUNCT different. Attr: %d\n", aid);
                *mismatch = 1;
            }
            break;
        case ATT_SYSTEM_FLAGS:
            if ( ((*(DWORD*)pAVal->pVal & FLAG_ATTR_NOT_REPLICATED) &&
                  pAC->bIsNotReplicated != TRUE )  ||
                 ((*(DWORD*)pAVal->pVal & FLAG_ATTR_REQ_PARTIAL_SET_MEMBER) &&
                  pAC->bMemberOfPartialSet != TRUE ) ||
                 ((*(DWORD*)pAVal->pVal & FLAG_ATTR_IS_CONSTRUCTED) &&
                  pAC->bIsConstructed != TRUE ) ||
                 ((*(DWORD*)pAVal->pVal & FLAG_ATTR_IS_OPERATIONAL) &&
                  pAC->bIsOperational != TRUE ) ||
                 ((*(DWORD*)pAVal->pVal & FLAG_ATTR_IS_RDN) &&
                  pAC->bFlagIsRdn != TRUE ) ||
                 ((*(DWORD*)pAVal->pVal & FLAG_SCHEMA_BASE_OBJECT) &&
                  pAC->bIsBaseSchObj != TRUE) ) {
                
                DPRINT1 (0, "scAddAtt_test: ERROR, SYSTEM_FLAGS different. Attr: %d\n", aid);
                *mismatch = 1;
            }
            break;
        default:
            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_SCHEMA_SURPLUS_INFO,
                     szInsertUL(pEI->AttrBlock.pAttr[i].attrTyp),
                     0, 0);
        }
        THFreeEx(pTHS, pAVal->pVal);
        THFreeEx(pTHS, pAVal);
    }

    THFreeEx(pTHS, pEI->pName);
    THFreeEx(pTHS, pEI->AttrBlock.pAttr);

    // Backlinks should have their system flags set to indicate they are not
    // replicated.
    Assert(!FIsBacklink(pAC->ulLinkID) || pAC->bIsNotReplicated);

    // Is this marked as ANR and indexed over the whole tree?
    //if(((pAC->fSearchFlags & (fANR | fATTINDEX)) == (fANR | fATTINDEX)) &&
    //   (!pAC->bDefunct)) {
    //    SCAddANRid(aid);
    //}

    // assign names of commonly used indexes when searching with
    // fSearchFlags fPDNTATTINDEX, fATTINDEX and fTUPLEINDEX
    if (pAC->fSearchFlags & (fATTINDEX | fPDNTATTINDEX | fTUPLEINDEX)) {
        // set ATTINDEX
        if (pAC->fSearchFlags & fATTINDEX) {
            DBGetIndexName (pAC, fATTINDEX, DS_DEFAULT_LOCALE, szIndexName, sizeof (szIndexName));
            lenIndexName = strlen (szIndexName) + 1;
            if (memcmp (pAC->pszIndex, szIndexName, lenIndexName) != 0) {
                DPRINT1 (0, "scAddAtt_test: ERROR, pszIndex different. Attr: %d\n", aid);
                *mismatch = 1;
            }
        }

        // set TUPLEINDEX
        if (pAC->fSearchFlags & fTUPLEINDEX) {
            DBGetIndexName (pAC, fTUPLEINDEX, DS_DEFAULT_LOCALE, szIndexName, sizeof (szIndexName));
            lenIndexName = strlen (szIndexName) + 1;
            if (memcmp (pAC->pszTupleIndex, szIndexName, lenIndexName) != 0) {
                DPRINT1 (0, "scAddAtt_test: ERROR, pszTupleIndex different. Attr: %d\n", aid);
                *mismatch = 1;
            }
        }
        
        // set PDNTATTINDEX
        if (pAC->fSearchFlags & fPDNTATTINDEX) {
            DBGetIndexName (pAC, fPDNTATTINDEX, DS_DEFAULT_LOCALE, szIndexName, sizeof (szIndexName));
            lenIndexName = strlen (szIndexName) + 1;
            if (memcmp (pAC->pszPdntIndex, szIndexName, lenIndexName) != 0 ){
                DPRINT1 (0, "scAddAtt_test: ERROR, pszIndex different. Attr: %d\n", aid);
                *mismatch = 1;
            }
        }
    }


    // =====================================================
    {
        HASHCACHE*       ahcId        = ((SCHEMAPTR*)(CurrSchemaPtr))->ahcId;   
        HASHCACHE*       ahcCol       = ((SCHEMAPTR*)(CurrSchemaPtr))->ahcCol;  
        HASHCACHE*       ahcMapi      = ((SCHEMAPTR*)(CurrSchemaPtr))->ahcMapi; 
        HASHCACHE*       ahcLink      = ((SCHEMAPTR*)(CurrSchemaPtr))->ahcLink; 
        HASHCACHESTRING* ahcName      = ((SCHEMAPTR*)(CurrSchemaPtr))->ahcName; 




        if (pAC->jColid) {
            for (i=SChash(pAC->jColid, ATTCOUNT);
                  (ahcCol[i].pVal && (ahcCol[i].hKey != pAC->jColid)); 
                  i=(i+1)%ATTCOUNT){
            }
            if (ahcCol[i].pVal != pAC) {
                DPRINT1 (0, "scAddAtt_test: ERROR, ahcCol different. Attr: %d\n", aid);
                *mismatch = 1;
            }
        }

        // update ahcMapi
        //
        if (pAC->ulMapiID) {
            for (i=SChash(pAC->ulMapiID,ATTCOUNT);
                   (ahcMapi[i].pVal && (ahcMapi[i].hKey != pAC->ulMapiID)); 
                   i=(i+1)%ATTCOUNT){
            }
            if (ahcMapi[i].pVal != pAC) {
                DPRINT1 (0, "scAddAtt_test: ERROR, ahcMapi different. Attr: %d\n", aid);
                *mismatch = 1;
            }
        }

        if (pAC->name) {
            /* if this att has a name, add it to the name cache */

            for (i=SCNameHash(pAC->nameLen,pAC->name,ATTCOUNT);
                   (ahcName[i].pVal &&
                   (ahcName[i].length != pAC->nameLen ||
                   _memicmp(ahcName[i].value,pAC->name,pAC->nameLen)));
                   i=(i+1)%ATTCOUNT) {
            }
            if (ahcName[i].pVal != pAC) {
                DPRINT1 (0, "scAddAtt_test: ERROR, ahcName different. Attr: %d\n", aid);
                *mismatch = 1;
            }
        }

        if (pAC->ulLinkID) {
            for (i=SChash(pAC->ulLinkID,ATTCOUNT);
                   (ahcLink[i].pVal && (ahcLink[i].hKey != pAC->ulLinkID)); 
                   i=(i+1)%ATTCOUNT){
            }
            if (ahcLink[i].pVal != pAC) {
                DPRINT1 (0, "scAddAtt_test: ERROR, ahcLink different. Attr: %d\n", aid);
                *mismatch = 1;
            }
        }
    }

    return pAC;
}

void
SCCheckCacheConsistency (void)
{
    THSTATE *pTHS=pTHStls;
    DECLARESCHEMAPTR
    DECLAREPREFIXPTR

    SEARCHARG SearchArg;
    SEARCHRES *pSearchRes;
    COMMARG  *pCommArg;
    PRESTART pRestart;
    BOOL fMoreData;
    FILTER Filter;
    ULONG objClass;
    ENTINFSEL eiSel;
    ATTRBLOCK AttrTypBlock;
    ENTINFLIST * pEIL, *pEILtmp;
    ULONG i, cCurrAttCnt, cCurrClsCount;
    ATTCACHE*   ac;
    CLASSCACHE* cc;
    SCHEMAPTR *tSchemaPtr;
    PVOID ptr;
    PVOID pNew;
    DWORD cAllocatedAttrs = 0;
    PARTIAL_ATTR_VECTOR *pPartialAttrVec = NULL;
    int mismatch, mismatchcnt;
    int err=0;
    
    
    ULONG Len = gAnchor.pDMD->structLen + 32*sizeof(WCHAR);
    DSNAME *pDsName = THAllocEx(pTHS,Len);
    WCHAR *SchemaObjDN = THAllocEx(pTHS,(gAnchor.pDMD->NameLen + 32)*sizeof(WCHAR));

    Assert(VALID_THSTATE(pTHS));

    DBOpen2(TRUE, &pTHS->pDB);

    __try { /* finally */

        if ( RecalcSchema( pTHS ) ){
            DPRINT(0,"SCCheckCacheConsistency: Recalc Schema FAILED\n");
            return;
        }

        if ( ComputeCacheClassTransitiveClosure(FALSE) ) {
            // Error
            DPRINT(0,"SCCheckCacheConsistency: Error closing classes\n");
            return;
        }


        //build the object-category value to put in the filter
        i = 0;
        wcscpy(SchemaObjDN, L"CN=Attribute-Schema,");
        i += 20;  // size of cn=attribute-schema,"
        wcscpy(&SchemaObjDN[i], gAnchor.pDMD->StringName);
        // SchemaObjDN now contains DN of attribute-schema class
        memset(pDsName, 0, Len);
        pDsName->NameLen = wcslen(SchemaObjDN);
        pDsName->structLen = DSNameSizeFromLen(pDsName->NameLen);
        wcscpy(pDsName->StringName, SchemaObjDN);

        // build selection
        eiSel.attSel = EN_ATTSET_LIST;
        eiSel.infoTypes = EN_INFOTYPES_TYPES_VALS;

        // regular cache load
        eiSel.AttrTypBlock.attrCount = NUMATTATT;
        eiSel.AttrTypBlock.pAttr = AttributeSelList;

        // do the initial allocation for the partial set
        if (SCCalloc(&pPartialAttrVec, 1, PartialAttrVecV1SizeFromLen(DEFAULT_PARTIAL_ATTR_COUNT))) {
            return;
        }

        pPartialAttrVec->dwVersion = VERSION_V1;
        pPartialAttrVec->V1.cAttrs = 0;
        cAllocatedAttrs = DEFAULT_PARTIAL_ATTR_COUNT;


        fMoreData = TRUE;
        pRestart = NULL;
        cCurrAttCnt = 0;
        mismatchcnt = 0;

        while (fMoreData) {

            // Check for service shutdown, since the next call to SearchBody can
            // take some time

            scAcquireSearchParameters(pTHS, pDsName, &eiSel, &SearchArg, &Filter, &pSearchRes);

            // Set for paged search;
            pCommArg = &(SearchArg.CommArg);
            pCommArg->PagedResult.fPresent = TRUE;
            pCommArg->PagedResult.pRestart = pRestart;
            pCommArg->ulSizeLimit = 200;


            // Search for all attSchema objects
            SearchBody(pTHS, &SearchArg, pSearchRes,0);
            if (pTHS->errCode) {
                LogAndAlertEvent(DS_EVENT_CAT_SCHEMA,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_SCHEMA_SEARCH_FAILED, szInsertUL(1),
                    szInsertUL(pTHS->errCode), 0);
                SCFree(&pPartialAttrVec);
                return;
            }


            // Set fMoreData for next iteration
            if ( !( (pSearchRes->PagedResult.pRestart != NULL)
                        && (pSearchRes->PagedResult.fPresent)
                  ) ) {
                // No more data needs to be read. So no iterarions needed after this
                fMoreData = FALSE;
            }
            else {
                // more data. save off the restart to use in the next iteration.
                // Note that we will free this searchres, but the pRestart is not freed by that

                pRestart = pSearchRes->PagedResult.pRestart;
            }

            // Check if table sizes are still large enough.

            if ((pSearchRes->count + cCurrAttCnt) > ATTCOUNT) {

               // Attribute tables are too small. there is no way this 
               // can happen at this time.

               DPRINT3(0,"SCCheckCacheConsistency: Error: Reallocing tables: %d, %d, %d\n", pSearchRes->count, ATTCOUNT, pTHS->UpdateDITStructure);
               return;
            }

            //  for each attrSchema, add to caches
            pEIL = &(pSearchRes->FirstEntInf);
            for (i=0; i<pSearchRes->count; i++) {

                if (!pEIL) {
                    LogEvent(DS_EVENT_CAT_SCHEMA,
                        DS_EVENT_SEV_MINIMAL,
                        DIRLOG_SCHEMA_BOGUS_SEARCH, szInsertUL(1), szInsertUL(i),
                        szInsertUL(pSearchRes->count));
                    break;
                }
                ac = scAddAtt_test(pTHS, &pEIL->Entinf, &mismatch, CurrSchemaPtr);

                mismatchcnt += mismatch;
                cCurrAttCnt++;

                
                /*
                if (ac!=NULL) {

                    if (ac->bMemberOfPartialSet)
                    {
                        // this attribute is a member of partial set
                        if (cAllocatedAttrs <= pPartialAttrVec->V1.cAttrs)
                        {
                            // not enough room to add one more attribute - reallocate the partial attribute vector
                            cAllocatedAttrs += PARTIAL_ATTR_COUNT_INC;

                            pNew = realloc(pPartialAttrVec, PartialAttrVecV1SizeFromLen(cAllocatedAttrs));
                            if (!pNew)
                            {
                                free(pPartialAttrVec);
                                return;
                            }
                            pPartialAttrVec = (PARTIAL_ATTR_VECTOR *) pNew;
                        }

                        // there is enough space to add the attribute into the partial set - add it
                        GC_AddAttributeToPartialSet(pPartialAttrVec, ac->id);
                    }
                    
                }
                */

                pEILtmp = pEIL;
                pEIL = pEIL->pNextEntInf;
                if (i > 0) {
                    THFreeEx(pTHS, pEILtmp);
                }
            }

           // free the searchres
           scReleaseSearchParameters(pTHS, &pSearchRes);

        }  /* while (fMoreData) */

        

        // ==========================================================================



        // regular cache load
        eiSel.AttrTypBlock.attrCount = NUMCLASSATT;
        eiSel.AttrTypBlock.pAttr = ClassSelList;

        //build the object-category value to put in the filter
        i = 0;
        wcscpy(SchemaObjDN, L"CN=Class-Schema,");
        i += 16; // length of "cn=class-schema,"
        wcscpy(&SchemaObjDN[i], gAnchor.pDMD->StringName);
        // SchemaObjDN now has the dn of class-schema class
        memset(pDsName, 0, Len);
        pDsName->NameLen = wcslen(SchemaObjDN);
        pDsName->structLen = DSNameSizeFromLen(pDsName->NameLen);
        wcscpy(pDsName->StringName, SchemaObjDN);

        // Initialize search parameters
        scAcquireSearchParameters(pTHS, pDsName, &eiSel, &SearchArg, &Filter, &pSearchRes);

        pTHS->errCode = 0;
        cCurrClsCount = 0;

        // Search for all classSchema objects
        // This time do a non-paged search since (1) it is very complex and time-consuming
        // to handle necessary reallocations in the middle, and (2) no. of classes are quite
        // small anyway (and not expected to be very large either)

        SearchBody(pTHS, &SearchArg, pSearchRes,0);

        if (pTHS->errCode) {
            LogAndAlertEvent(DS_EVENT_CAT_SCHEMA,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_SCHEMA_SEARCH_FAILED, szInsertUL(2),
                szInsertUL(pTHS->errCode), 0);

            return;
        }

        //????????????

        if (pSearchRes->count > CLSCOUNT) {

          // Class hash tables too small. Realloc the old tables.
          // Can possibly come here only during install/boot
          // Since class hash tables are not used prior to this,
          // just free the old table and calloc again (which automatically
          // zero them out too

           DPRINT3(0,"SCCheckCacheConsistency: Error: Reallocing Class tables: %d, %d, %d\n", pSearchRes->count, CLSCOUNT, pTHS->UpdateDITStructure);

           return;
        }

        //  for each classSchema, read and add to cache
        pEIL = &(pSearchRes->FirstEntInf);
        if (!pEIL) {
            DPRINT(0,"Null pEIL from SearchBody\n");
        }


        for (i=0; i<pSearchRes->count; i++) {

            if (!pEIL) {
                LogEvent(DS_EVENT_CAT_SCHEMA,
                    DS_EVENT_SEV_MINIMAL,
                    DIRLOG_SCHEMA_BOGUS_SEARCH, szInsertUL(2), szInsertUL(i),
                    szInsertUL(pSearchRes->count));
                break;
            }
            
            cc = scAddClass_test(pTHS, &pEIL->Entinf, &mismatch, CurrSchemaPtr);


            mismatchcnt += mismatch;
            cCurrClsCount++;

            pEILtmp = pEIL;
            pEIL = pEIL->pNextEntInf;
            if (i > 0) {
                THFreeEx(pTHS, pEILtmp);
            }
        }

    } /* try-finally */
    __finally {
          DBClose(pTHS->pDB, FALSE);
          THFreeEx(pTHS,pDsName);
          THFreeEx(pTHS,SchemaObjDN);
    }

    DPRINT1(0,"Schema Cache Consistency Check FINISHED. Mismatches %d\n", mismatchcnt);
}

// Not for general use. Set to 0 in all builds.
//
// Set to _DEBUG_SCHEMA_ALLOC_ to 1 for quick and dirty check
// to make sure schema loads aren't leaking memory. Doesn't take
// into account memory freed/alloced outside of scchk.c, scache.c,
// and oidconv.c. Don't enable except in privates. Not stable.

LONG SchemaAlloced;
LONG SchemaEntries;

#if _DEBUG_SCHEMA_ALLOC_

#include <dbghelp.h>

// Not for general use.
//
// Quick and dirty check to make sure schema loads aren't leaking memory.
// Doesn't take into account memory freed/alloced outside of scchk.c,
// scache.c, and oidconv.c. Don't enable except in privates. Not stable.
CRITICAL_SECTION csSchemaAlloc;
LONG SchemaDump;
BOOL SchemaFirst = TRUE;
HANDLE  hSchemaProcessHandle = NULL;

// header prepended to each memory allocation. Actual memory address
// returned to caller skips this header and rounds up to 16 byte boundary.
#define SCHEMA_STACK 4
#define SCHEMA_SKIP  2
struct SchemaAlloc {
    struct SchemaAlloc *This;
    struct SchemaAlloc *Next;
    struct SchemaAlloc *Prev;
    DWORD nBytes;
    ULONG_PTR  Stack[SCHEMA_STACK];
} SchemaAnchor = {
    &SchemaAnchor,
    &SchemaAnchor,
    &SchemaAnchor,
    0
};

#define SCHEMA_EXTRA    ((sizeof(struct SchemaAlloc) + 15) & ~15)

VOID
SchemaStackTrace(
    IN PULONG_PTR   Stack,
    IN ULONG        Depth,
    IN ULONG        Skip
    )
/*++

Routine Description:

    Trace the stack back up to Depth frames. The current frame is included.

Arguments:

    Stack   - Saves the "return PC" from each frame
    Depth   - Only this many frames

Return Value:

    None.

--*/
{
    HANDLE      ThreadToken;
    ULONG       WStatus;
    STACKFRAME  Frame;
    ULONG       i;
    CONTEXT     Context;
    ULONG       FrameAddr;

    if (Stack) {
        *Stack = 0;
    }

    if (!hSchemaProcessHandle) {
        return;
    }

    //
    // I don't know how to generate a stack for an alpha, yet. So, just
    // to get into the build, disable the stack trace on alphas.
    //
#if ALPHA
    return;
#elif IA64

    //
    // Need stack dump init for IA64.
    //

    return;

#else

    //
    // init
    //

    ZeroMemory(&Context, sizeof(Context));

    // no need to close this handle
    ThreadToken = GetCurrentThread();


    try { try {
        Context.ContextFlags = CONTEXT_FULL;
        if (!GetThreadContext(ThreadToken, &Context)) {
            DPRINT1(0, "Can't get context (error 0x%x)\n", GetLastError());
        }

        //
        // let's start clean
        //
        ZeroMemory(&Frame, sizeof(STACKFRAME));

        //
        // from  nt\private\windows\screg\winreg\server\stkwalk.c
        //
        Frame.AddrPC.Segment = 0;
        Frame.AddrPC.Mode = AddrModeFlat;

#ifdef _M_IX86
        Frame.AddrFrame.Offset = Context.Ebp;
        Frame.AddrFrame.Mode = AddrModeFlat;

        Frame.AddrStack.Offset = Context.Esp;
        Frame.AddrStack.Mode = AddrModeFlat;

        Frame.AddrPC.Offset = (DWORD)Context.Eip;
#elif defined(_M_MRX000)
        Frame.AddrPC.Offset = (DWORD)Context.Fir;
#elif defined(_M_ALPHA)
        Frame.AddrPC.Offset = (DWORD)Context.Fir;
#endif

        for (i = 0; i < (Depth - 1 + Skip); ++i) {
            *Stack=0;
            if (!StackWalk(
                IMAGE_FILE_MACHINE_I386,  // DWORD                          MachineType
                hSchemaProcessHandle,        // HANDLE                         hProcess
                ThreadToken,              // HANDLE                         hThread
                &Frame,                   // LPSTACKFRAME                   StackFrame
                NULL, //(PVOID)&Context,          // PVOID                          ContextRecord
                NULL,                     // PREAD_PROCESS_MEMORY_ROUTINE   ReadMemoryRoutine
                SymFunctionTableAccess,   // PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine
                SymGetModuleBase,         // PGET_MODULE_BASE_ROUTINE       GetModuleBaseRoutine
                NULL)) {                  // PTRANSLATE_ADDRESS_ROUTINE     TranslateAddress

                WStatus = GetLastError();

                //DPRINT1_WS(0, "++ Can't get stack address for level %d;", i, WStatus);
                break;
            }
            if (!(*Stack = Frame.AddrReturn.Offset)) {
                break;
            }
            if (i < Skip) {
                continue;
            }
            ++Stack;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        /* FALL THROUGH */
    } } finally {
      ;
    }
    return;
#endif 
}


VOID
SCFree(
    IN OUT VOID **ppMem
    )
/*++

Routine Description:

    Free memory allocated with SCCalloc or SCRealloc.

Arguments:

Return Value:

    None.

--*/
{
    // Quick and dirty check to make sure schema loads aren't leaking memory.
    // Doesn't take into account memory freed/alloced outside of scchk.c,
    // scache.c, and oidconv.c. Don't enable except in privates. Not stable.
    struct SchemaAlloc *pSA;

    if (*ppMem) {
        // adjust to header
        pSA = (PVOID)((PCHAR)(*ppMem) - SCHEMA_EXTRA);
        Assert(pSA->This == pSA);
        EnterCriticalSection(&csSchemaAlloc);
        __try {
            // Remove from list
            pSA->Next->Prev = pSA->Prev;
            pSA->Prev->Next = pSA->Next;

            // Maintain bytes alloced
            SchemaAlloced -= pSA->nBytes;
            --SchemaEntries;
        } __finally {
            LeaveCriticalSection(&csSchemaAlloc);
        }
        free(pSA);
        *ppMem = NULL;
    }
}

int
SCReallocWrn(
    IN OUT VOID **ppMem,
    IN DWORD    nBytes
    )
/*++

Routine Description:

    realloc memory. Free with free(). On error, log an error but
    leave *ppMem unchanged.

Arguments:

    nBytes - bytes to allocate

Return Value:

    0 - *ppMem set to address of realloced memory. Free with SCFree().
    !0 - do not alter *ppMem and log an event

--*/
{
    // Quick and dirty check to make sure schema loads aren't leaking memory.
    // Doesn't take into account memory freed/alloced outside of scchk.c,
    // scache.c, and oidconv.c. Don't enable except in privates. Not stable.
    struct SchemaAlloc *pSA;
    PVOID p;

    // adjust to header
    pSA = (PVOID)((PCHAR)(*ppMem) - SCHEMA_EXTRA);
    Assert(pSA->This == pSA);

    // Remove from list
    EnterCriticalSection(&csSchemaAlloc);
    __try {
        pSA->Next->Prev = pSA->Prev;
        pSA->Prev->Next = pSA->Next;
        SchemaAlloced -= pSA->nBytes;
        --SchemaEntries;
    } __finally {
        LeaveCriticalSection(&csSchemaAlloc);
    }

    // realloc (including extra bytes)
    nBytes += SCHEMA_EXTRA;
    if (NULL != (p = realloc(pSA, nBytes))) {
        pSA = p;
    }
    // add back at head of list
    pSA->This = pSA;
    pSA->nBytes = nBytes;
    EnterCriticalSection(&csSchemaAlloc);
    __try {
        pSA->Next = SchemaAnchor.Next;
        pSA->Prev = &SchemaAnchor;
        pSA->Next->Prev = pSA;
        pSA->Prev->Next = pSA;
        SchemaAlloced += pSA->nBytes;
        ++SchemaEntries;
    } __finally {
        LeaveCriticalSection(&csSchemaAlloc);
    }

    if (!p) {
        // log an event and set error in thread state
        scMemoryPanic(nBytes);
        return 1;
    }

    // Return block past header
    *ppMem = (PCHAR)pSA + SCHEMA_EXTRA;
    return 0;
}


int
SCCallocWrn(
    IN OUT VOID **ppMem,
    IN DWORD    nItems,
    IN DWORD    nBytes
    )
/*++

Routine Description:

    malloc and clear memory. Free with free(). On error, log an event

Arguments:

    ppMem - address of address to return memory pointer
    nBytes - bytes to allocate

Return Value:

    0 - *ppMem set to address of malloced, cleared memory. Free with SCFree().
    !0 - clear *ppMem and log an event

--*/
{
    // Quick and dirty check to make sure schema loads aren't leaking memory.
    // Doesn't take into account memory freed/alloced outside of scchk.c,
    // scache.c, and oidconv.c. Don't enable except in privates. Not stable.
    struct SchemaAlloc *pSA;

    // First time thru the DS is running single threaded (CYF).
    if (SchemaFirst) {
        InitializeCriticalSectionAndSpinCount(&csSchemaAlloc, 4000);
        hSchemaProcessHandle = GetCurrentProcess();
        if (!SymInitialize(hSchemaProcessHandle, NULL, FALSE)) {
            DPRINT1(0, "Could not initialize symbol subsystem (imagehlp) (error 0x%x)\n" ,GetLastError());
            hSchemaProcessHandle = 0;
        }
        SchemaFirst = FALSE;
    }
    nBytes = (nBytes * nItems) + SCHEMA_EXTRA;
    pSA = malloc(nBytes);
    if (!pSA) {
        *ppMem = NULL;
        scMemoryPanic(nBytes);
        return 1;
    }
    memset(pSA, 0, nBytes);
    pSA->This = pSA;
    pSA->nBytes = nBytes;
    EnterCriticalSection(&csSchemaAlloc);
    __try {
        pSA->Next = SchemaAnchor.Next;
        pSA->Prev = &SchemaAnchor;
        pSA->Next->Prev = pSA;
        pSA->Prev->Next = pSA;
        SchemaAlloced += pSA->nBytes;
        ++SchemaEntries;
        SchemaStackTrace(pSA->Stack, SCHEMA_STACK, SCHEMA_SKIP);
        if (SchemaDump) {
            struct SchemaAlloc *p;
            DPRINT1(0, "SCCallocWrn: %d alloced\n", SchemaAlloced);
            for (p = SchemaAnchor.Prev; 
                 p != &SchemaAnchor && SchemaDump; 
                 p = p->Prev, --SchemaDump) {
                DPRINT2(0, "SCCallocWrn: %08x %6d\n", p->This, p->nBytes - SCHEMA_EXTRA);
                DPRINT4(0, "SCCallocWrn:     %08x %08x %08x %08x\n",
                        p->Stack[0], p->Stack[1], p->Stack[2], p->Stack[3]);

            }
            SchemaDump = 0;
        }
    } __finally {
        LeaveCriticalSection(&csSchemaAlloc);
    }

    *ppMem = (PCHAR)pSA + SCHEMA_EXTRA;
    return 0;
}
#endif _DEBUG_SCHEMA_ALLOC_

int
SCCheckSchemaCache(
    IN THSTATE *pTHS,
    IN PCHAR pBuf
    )
/*++

Routine Description:
    Verify that the global schema cache is self-consistent.

Arguments:
    pTHS - thread state
    pBuf - from GenericControl

Return Value:

    pTHS->errCode

--*/
{
    DECLARESCHEMAPTR
    DWORD nAttInId, i, nClsInAll;
    ATTCACHE *pAC, *pACtmp;
    CLASSCACHE *pCC, *pCCtmp;
    SCHEMAPTR *pSch = (SCHEMAPTR *)pTHS->CurrSchemaPtr;

    DPRINT2(0, "Schema/anchor version: %d/%d\n",
            pSch->ForestBehaviorVersion, gAnchor.ForestBehaviorVersion);

    // Id
    for (i = nAttInId = 0; i < ATTCOUNT; ++i) {
        pAC = ahcId[i].pVal;
        if (pAC == NULL || pAC == FREE_ENTRY) {
            continue;
        }
        ++nAttInId;

        if (!pAC->name || (pAC->nameLen == 0)) {
            DPRINT2(0, "ERROR: Bad att name: (%x, %x)\n", pAC->id, pAC->Extid);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }
        if (pAC != SCGetAttById(pTHS, pAC->id)) {
            DPRINT3(0, "ERROR: Bad ahcid: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }
        if (pAC->bFlagIsRdn && !pAC->bIsRdn) {
            DPRINT3(0, "ERROR: Bad FlagIsRdn: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }

        if (!pAC->bDefunct
            || !ALLOW_SCHEMA_REUSE_VIEW(pSch)) {
            if (pAC != SCGetAttByExtId(pTHS, pAC->Extid)) {
                DPRINT3(0, "ERROR: Not in ahcExtid: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
            if (pAC != SCGetAttByName(pTHS, pAC->nameLen, pAC->name)) {
                DPRINT3(0, "ERROR: Not in ahcName: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
            if (pAC->ulMapiID && pAC != SCGetAttByMapiId(pTHS, pAC->ulMapiID)) {
                DPRINT3(0, "ERROR: Not in ahcMapi: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
        } else if (!pAC->bIsRdn) {
            if (pAC == SCGetAttByExtId(pTHS, pAC->Extid)) {
                DPRINT3(0, "ERROR: Should not be in ahcExtid: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
            if (pAC == SCGetAttByName(pTHS, pAC->nameLen, pAC->name)) {
                DPRINT3(0, "ERROR: Should not be in ahcName: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
            if (pAC->ulMapiID && pAC == SCGetAttByMapiId(pTHS, pAC->ulMapiID)) {
                DPRINT3(0, "ERROR: Should not be in ahcMapi: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
        } else {
            if (NULL == (pACtmp = SCGetAttByExtId(pTHS, pAC->Extid))
                || !pACtmp->bIsRdn
                || (pAC->bFlagIsRdn && !pACtmp->bFlagIsRdn)
                || (pAC->bFlagIsRdn == pACtmp->bFlagIsRdn
                    && (0 < memcmp(&pAC->objectGuid, 
                                   &pACtmp->objectGuid, 
                                   sizeof(pAC->objectGuid)))) ) {
                DPRINT5(0, "ERROR: Wrong rdn in ahcExtid: %s (%x, %x) (%p %p)\n", pAC->name, pAC->id, pAC->Extid, pAC, pACtmp);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
            if (NULL == (pACtmp = SCGetAttByName(pTHS, pAC->nameLen, pAC->name))
                || !pACtmp->bIsRdn
                || (pAC->bFlagIsRdn && !pACtmp->bFlagIsRdn)
                || (pAC->bFlagIsRdn == pACtmp->bFlagIsRdn
                    && (0 < memcmp(&pAC->objectGuid, 
                                   &pACtmp->objectGuid, 
                                   sizeof(pAC->objectGuid)))) ) {
                DPRINT5(0, "ERROR: Wrong rdn in ahcName: %s (%x, %x) (%p %p)\n", pAC->name, pAC->id, pAC->Extid, pAC, pACtmp);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
            if (pAC->ulMapiID
                && (NULL == (pACtmp = SCGetAttByMapiId(pTHS, pAC->ulMapiID))
                    || !pACtmp->bIsRdn
                    || (pAC->bFlagIsRdn && !pACtmp->bFlagIsRdn)
                    || (pAC->bFlagIsRdn == pACtmp->bFlagIsRdn
                        && (0 < memcmp(&pAC->objectGuid, 
                                       &pACtmp->objectGuid, 
                                       sizeof(pAC->objectGuid))))) ) {
                DPRINT5(0, "ERROR: Wrong rdn in ahcMapi: %s (%x, %x) (%p %p)\n", pAC->name, pAC->id, pAC->Extid, pAC, pACtmp);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
        }
        // pre-beta3 forests should not have intid
        if (pAC->id != pAC->Extid
            && !ALLOW_SCHEMA_REUSE_VIEW(pSch)) {
            DPRINT3(0, "ERROR: Bad intid: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }
    }
    if (pSch->nAttInDB != nAttInId) {
        DPRINT2(0, "ERROR: nAttInDB (%d) != nAttInId (%d)\n", CurrSchemaPtr->nAttInDB, nAttInId);
        return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
    }

    // ExtId
    for (i = 0; i < ATTCOUNT; ++i) {
        pAC = ahcExtId[i].pVal;
        if (pAC == NULL || pAC == FREE_ENTRY) {
            continue;
        }
        if (pAC != SCGetAttByExtId(pTHS, pAC->Extid)) {
            DPRINT3(0, "ERROR: Bad ahcExtid: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }
        if (pAC->bDefunct 
            && !pAC->bIsRdn
            && ALLOW_SCHEMA_REUSE_VIEW(pSch)) {
            DPRINT3(0, "ERROR: Bad defunct: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }
    }

    // Name
    for (i = 0; i < ATTCOUNT; ++i) {
        pAC = ahcName[i].pVal;
        if (pAC == NULL || pAC == FREE_ENTRY) {
            continue;
        }
        if (pAC != SCGetAttByName(pTHS, pAC->nameLen, pAC->name)) {
            DPRINT3(0, "ERROR: Bad ahcName: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }
    }

    // MapiID Hash
    for (i = 0; i < ATTCOUNT; ++i) {
        pAC = ahcMapi[i].pVal;
        if (pAC == NULL || pAC == FREE_ENTRY) {
            continue;
        }
        if (pAC != SCGetAttByMapiId(pTHS, pAC->ulMapiID)) {
            DPRINT3(0, "ERROR: Bad ahcMapi: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }
    }

    // ATT SchembIdGuid Hash
    if (ahcAttSchemaGuid) for (i = 0; i < ATTCOUNT; ++i) {
        pAC = ahcAttSchemaGuid[i];
        if (pAC == NULL || pAC == FREE_ENTRY) {
            continue;
        }
        if (pAC != SCGetAttByPropGuid(pTHS, pAC)) {
            DPRINT3(0, "ERROR: Bad ahcAttSchemaIdGuid: %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }
    }

    // ClassAll
    for (i = nClsInAll = 0; i < CLSCOUNT; ++i) {
        pCC = ahcClassAll[i].pVal;
        if (pCC == NULL || pCC == FREE_ENTRY) {
            continue;
        }
        ++nClsInAll;

        // bad LDN
        if (!pCC->name || (pCC->nameLen == 0)) {
            DPRINT1(0, "ERROR: Bad cls name: (%x)\n", pCC->ClassId);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }

        if (!pCC->bDefunct
            || !ALLOW_SCHEMA_REUSE_VIEW(pSch)) {
            if (pCC != SCGetClassById(pTHS, pCC->ClassId)) {
                DPRINT2(0, "ERROR: Not in ahcClass: %s (%x)\n", pCC->name, pCC->ClassId);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
            if (pCC != SCGetClassByName(pTHS, pCC->nameLen, pCC->name)) {
                DPRINT2(0, "ERROR: Not in ahcClassName: %s (%x)\n", pCC->name, pCC->ClassId);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
        } else {
            if (NULL == (pCCtmp = SCGetClassById(pTHS, pCC->ClassId))
                || (pCC->bDefunct == pCCtmp->bDefunct
                    && (0 < memcmp(&pCC->objectGuid, 
                                   &pCCtmp->objectGuid, 
                                   sizeof(pCC->objectGuid)))) ) {
                DPRINT2(0, "ERROR: Should not be in ahcClass: %s (%x)\n", pCC->name, pCC->ClassId);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
            if (pCC == SCGetClassByName(pTHS, pCC->nameLen, pCC->name)) {
                DPRINT2(0, "ERROR: Should not be in ahcClassName: %s (%x)\n", pCC->name, pCC->ClassId);
                return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
            }
        }
    }
    if (pSch->nClsInDB != nClsInAll) {
        DPRINT2(0, "ERROR: nClsInDB (%d) != nClsInAll (%d)\n", CurrSchemaPtr->nClsInDB, nClsInAll);
        return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
    }

    // Class
    for (i = 0; i < CLSCOUNT; ++i) {
        pCC = ahcClass[i].pVal;
        if (pCC == NULL || pCC == FREE_ENTRY) {
            continue;
        }
        if (pCC != SCGetClassById(pTHS, pCC->ClassId)) {
            DPRINT2(0, "ERROR: Bad ahcClass: %s (%x)\n", pCC->name, pCC->ClassId);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }
    }

    // ClassName
    for (i = 0; i < CLSCOUNT; ++i) {
        pCC = ahcClassName[i].pVal;
        if (pCC == NULL || pCC == FREE_ENTRY) {
            continue;
        }
        if (pCC != SCGetClassByName(pTHS, pCC->nameLen, pCC->name)) {
            DPRINT2(0, "ERROR: Bad ahcClassName: %s (%x)\n", pCC->name, pCC->ClassId);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }
    }

    // CLS SchembIdGuid Hash
    if (ahcClsSchemaGuid) for (i = 0; i < CLSCOUNT; ++i) {
        pCC = ahcClsSchemaGuid[i];
        if (pCC == NULL || pCC == FREE_ENTRY) {
            continue;
        }
        if (pCC != SCGetClassByPropGuid(pTHS, pCC)) {
            DPRINT2(0, "ERROR: Bad ahcClsSchemaIdGuid: %s (%x)\n", pCC->name, pCC->ClassId);
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }
    }

    if (pSch->ForestBehaviorVersion != gAnchor.ForestBehaviorVersion) {
        DPRINT2(0, "ERROR: Version mismatch: Schema %d != gAnchor %d\n",
                pSch->ForestBehaviorVersion, gAnchor.ForestBehaviorVersion);
        return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
    }

    return 0;
}

int
SCCheckRdnOverrun(
    IN THSTATE *pTHS,
    IN PCHAR pBuf
    )
/*++

Routine Description:
    Check the new code rdn encoding code.

Arguments:
    pTHS - thread state
    pBuf - from GenericControl

Return Value:

    pTHS->errCode

--*/
{
    DWORD   ccOut, i;
    DWORD   Vals[4];
    OID     Oid;
    WCHAR   Out[MAX_RDN_KEY_SIZE + 1];
    ATTRTYP AttrTyp = 4294967295; // 0xFFFFFFFF
    CHAR    ExpBer[] = {0x4f, 0xA0, 0xFF, 0xFF, 0x7F, 0xA0, 0xFF, 0xFF, 0x7F };

    Oid.cVal = 1;
    Oid.Val = &AttrTyp;

    //
    // OidStructToString
    //

    // buffer too small
    ccOut = OidStructToString(&Oid, Out, 8);
    if (ccOut) {
        DPRINT(0, "ERROR: OidStructToString overrun not detected\n");
        return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
    }

    // expect OID.4294967295
    memset(Out, 0, sizeof(Out));
    ccOut = OidStructToString(&Oid, Out, MAX_RDN_KEY_SIZE);
    if (ccOut != 14) {
        DPRINT2(0, "ERROR: OidStructToString bad conversion: %d != %d expected\n", ccOut, 14);
        return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
    }
    if (0 != _wcsnicmp(L"OID.4294967295", Out, 14)) {
        DPRINT1(0, "ERROR: OidStructToString bad conversion: %ws != OID.4294967295 expected\n", Out);
        return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
    }

    //
    // AttrTypeToIntIdString
    //

    // buffer too small
    ccOut = AttrTypeToIntIdString(AttrTyp, Out, 8);
    if (ccOut) {
        DPRINT(0, "ERROR: AttrTypeToIntIdString overrun not detected\n");
        return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
    }

    // expect IID.4294967295
    memset(Out, 0, sizeof(Out));
    ccOut = AttrTypeToIntIdString(AttrTyp, Out, MAX_RDN_KEY_SIZE);
    if (ccOut != 14) {
        DPRINT2(0, "ERROR: AttrTypeToIntIdString bad conversion: %d != %d expected\n", ccOut, 14);
        return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
    }
    if (0 != _wcsnicmp(L"IID.4294967295", Out, 14)) {
        DPRINT1(0, "ERROR: AttrTypeToIntIdString bad conversion: %ws != IID.4294967295 expected\n", Out);
        return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
    }

    // \x4f A0FFFF7F A0FFFF7F
    Oid.cVal = 4;
    Oid.Val = Vals;
    Oid.Val[0] = 0x1;
    Oid.Val[1] = 0x27;
    Oid.Val[2] = 0x41FFFFF;
    Oid.Val[3] = 0x41FFFFF;
    for (i = 0; i < 9; ++i) {
        ccOut = EncodeOID(&Oid, (PCHAR)Out, i);
        if (ccOut) {
            DPRINT(0, "ERROR: EncodeOID overrun not detected\n");
            return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        }
    }
    ccOut = EncodeOID(&Oid, (PCHAR)Out, 9);
    if (ccOut != 9) {
        DPRINT2(0, "ERROR: EncodeOID bad conversion: %d != %d expected\n", ccOut, 9);
        return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
    }
    if (0 != memcmp(ExpBer, Out, 9)) {
        DPRINT(0, "ERROR: EncodeOID bad conversion\n");
        return SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
    }

    return 0;
}

VOID
scDefaultSdForExe(
    IN THSTATE      *pTHS,
    IN CLASSCACHE   *pCC
    )
/*++

Routine Description:

    Hammer the default SD on cached classes when running as
    dsamain.exe w/security disabled. But be careful to keep
    the correct defaultSD when running as mkdit.exe to catch
    errors.

Arguments:

    pCC - fix up pCC's pStrSD and cbStrSD

Return Value:

    pTHS->errCode

--*/
{
    extern BOOL gfRunningAsExe;
    extern BOOL gfRunningAsMkdit;
    extern DWORD dwSkipSecurity;

    // everyone all access
#define _DEFAULT_SDDL_FOR_EXE_  L"O:WDG:WDD:(A;;GA;;;WD)"

    // Hammer the default SD on cached classes when running as
    // dsamain.exe w/security disabled. But be careful to keep
    // the correct defaultSD when running as mkdit.exe to catch
    // errors.
    if (dwSkipSecurity && gfRunningAsExe && !gfRunningAsMkdit) {
        SCFree(&pCC->pStrSD);
        pCC->cbStrSD = (wcslen(_DEFAULT_SDDL_FOR_EXE_) + 1) * sizeof(WCHAR);
        if (SCCalloc(&pCC->pStrSD, 1, pCC->cbStrSD)) {
            Assert(!"Could not DefaultSD for Unit Test");
        }
        memcpy(pCC->pStrSD, _DEFAULT_SDDL_FOR_EXE_, pCC->cbStrSD);
    }
}

int
scDupStruct(
    IN THSTATE  *pTHS,
    IN VOID     *pOldMem,
    OUT VOID    **ppNewMem,
    IN  DWORD   nBytes
    )
/*++

Routine Description:

    Make a copy of a struct

Arguments:

    pTHS - thread state
    pOldMem - memory to be dup'ed
    ppNewMem - new memory is allocated
    nBytes - size of struct

Return Value:

    pTHS->errCode

--*/
{
    if (NULL == pOldMem) {
        *ppNewMem = NULL;
    } else if (!SCCalloc(ppNewMem, 1, nBytes)) {
        memcpy(ppNewMem, pOldMem, nBytes);
    }
    return pTHS->errCode;
}

int
scDupString(
    IN THSTATE  *pTHS,
    IN VOID     *pOldStr,
    OUT VOID    **ppNewStr
    )
/*++

Routine Description:

    Make a copy of a struct

Arguments:

    pTHS - thread state
    pOldStr - memory to be dup'ed
    ppNewStr - new memory is allocated

Return Value:

    pTHS->errCode

--*/
{
    if (NULL == pOldStr) {
        *ppNewStr = NULL;
    } else {
        scDupStruct(pTHS, pOldStr, ppNewStr, strlen(pOldStr) + 1);
    }
    return pTHS->errCode;
}

int
SCCopySchema(
    IN THSTATE *pTHS,
    IN PCHAR pBuf
    )
/*++

Routine Description:

    Make a copy of the schema and then free it

Arguments:

    pTHS - thread state
    pBuf - ignored

Return Value:

    pTHS->errCode

--*/
{
    DWORD       i;
    DWORD CopyAtt = 0;
    DWORD CopyCls = 0;
    ATTCACHE    *pAC, *pACDup = NULL;
    CLASSCACHE  *pCC, *pCCDup = NULL;
    static DWORD CopyAttTot = 0;
    static DWORD CopyClsTot = 0;
    static DWORD CopyAttFail = 0;
    static DWORD CopyClsFail = 0;
    ULONG ATTCOUNT = pTHS->CurrSchemaPtr->ATTCOUNT;
    ULONG CLSCOUNT = pTHS->CurrSchemaPtr->CLSCOUNT;
    HASHCACHE *ahcId = pTHS->CurrSchemaPtr->ahcId;
    HASHCACHE *ahcClassAll = pTHS->CurrSchemaPtr->ahcClassAll;

    for (i = 0; i < ATTCOUNT; ++i) {
        pAC = ahcId[i].pVal;
        if (!pAC || pAC == FREE_ENTRY) {
            continue;
        }
        ++CopyAtt;
        ++CopyAttTot;
        if (scDupStruct(pTHS, pAC, &pACDup, sizeof(ATTCACHE))
            || scDupString(pTHS, pAC->name, &pACDup->name)
            || scDupString(pTHS, pAC->pszPdntIndex, &pACDup->pszPdntIndex)
            || scDupStruct(pTHS, pAC->pidxPdntIndex, &pACDup->pidxPdntIndex, sizeof(*pAC->pidxPdntIndex))
            || scDupString(pTHS, pAC->pszIndex, &pACDup->pszIndex)
            || scDupStruct(pTHS, pAC->pidxIndex, &pACDup->pidxIndex, sizeof(*pAC->pidxIndex))
            || scDupString(pTHS, pAC->pszTupleIndex, &pACDup->pszTupleIndex)
            || scDupStruct(pTHS, pAC->pidxTupleIndex, &pACDup->pidxTupleIndex, sizeof(*pAC->pidxTupleIndex))) {
                ++CopyAttFail;
        }
        SCFreeAttcache(&pACDup);
    }

    for (i = 0; i < CLSCOUNT; ++i) {
        pCC = ahcClassAll[i].pVal;
        if (!pCC || pCC == FREE_ENTRY) {
            continue;
        }
        ++CopyCls;
        ++CopyClsTot;
        if (scDupStruct(pTHS, pCC, &pCCDup, sizeof(CLASSCACHE))
            || scDupString(pTHS, pCC->name, &pCCDup->name)
            || scDupStruct(pTHS, pCC->pSD, &pCCDup->pSD, pCC->SDLen)
            || (pCC->pDefaultObjCategory
                && scDupStruct(pTHS, pCC->pDefaultObjCategory, &pCCDup->pDefaultObjCategory, pCC->pDefaultObjCategory->structLen))
            || scDupStruct(pTHS, pCC->pSubClassOf, &pCCDup->pSubClassOf, pCC->SubClassCount * sizeof(ULONG))
            || scDupStruct(pTHS, pCC->pAuxClass, &pCCDup->pAuxClass, pCC->AuxClassCount * sizeof(ULONG))
            || scDupStruct(pTHS, pCC->pPossSup, &pCCDup->pPossSup, pCC->PossSupCount * sizeof(ULONG))
            || scDupStruct(pTHS, pCC->pMustAtts, &pCCDup->pMustAtts, pCC->MustCount * sizeof(ATTRTYP))
            || scDupStruct(pTHS, pCC->pMayAtts, &pCCDup->pMayAtts, pCC->MayCount * sizeof(ATTRTYP))
            // Clear these entries. They will be re-initialized at first request.
            || (pCCDup->ppAllAtts = NULL)
            || (pCCDup->pAttTypeCounts = 0)
            || scDupStruct(pTHS, pCC->pMyMustAtts, &pCCDup->pMyMustAtts, pCC->MyMustCount * sizeof(ATTRTYP))
            || scDupStruct(pTHS, pCC->pMyMayAtts, &pCCDup->pMyMayAtts, pCC->MyMayCount * sizeof(ATTRTYP))
            || scDupStruct(pTHS, pCC->pMyPossSup, &pCCDup->pMyPossSup, pCC->MyPossSupCount * sizeof(ULONG))) {
            ++CopyClsFail;
        }
        SCFreeClasscache(&pCCDup);
    }
    DPRINT3(0, "CopySchema: %d Att, %d AttTot, %d AttFail\n", CopyAtt, CopyAttTot, CopyAttFail);
    DPRINT3(0, "CopySchema: %d Cls, %d ClsTot, %d ClsFail\n", CopyCls, CopyClsTot, CopyClsFail);
    return pTHS->errCode;
}

int
SCSchemaPerf(
    IN THSTATE *pTHS,
    IN PCHAR pBuf
    )
/*++

Routine Description:

    Perf of schema hash tables

Arguments:

    pTHS - thread state
    pBuf - ignored

Return Value:

    pTHS->errCode

--*/
{
    DWORD       hi, i, nTries, nBad, nEnt, nTotTries;
    ATTCACHE    *pAC;
    CLASSCACHE  *pCC;
    ULONG ATTCOUNT = pTHS->CurrSchemaPtr->ATTCOUNT;
    HASHCACHE *ahcId = pTHS->CurrSchemaPtr->ahcId;

    for (hi = nEnt = nBad = nTotTries = 0; hi < ATTCOUNT; ++hi) {
        pAC = ahcId[hi].pVal;
        if (!pAC || pAC == FREE_ENTRY) {
            continue;
        }
        ++nEnt;

        for (i = SChash(pAC->id, ATTCOUNT), nTries = 0;
             ahcId[i].pVal && ahcId[i].pVal != pAC; i=(i+1)%ATTCOUNT) {
            ++nTries;
            if (nTries > 1) {
                if (ahcId[i].pVal != FREE_ENTRY) {
                    DPRINT2(0, "%x collides with %x\n", pAC->id, ((ATTCACHE *)ahcId[i].pVal)->id);
                } else {
                    DPRINT(0, "FREE_ENTRY\n");
                }
            }
        }
        nTotTries += nTries;
        if (ahcId[i].pVal != pAC) {
            DPRINT3(0, "Id Hash: Missing %s (%x, %x)\n", pAC->name, pAC->id, pAC->Extid);
        } else if (nTries) {
            if (nTries > 1) {
                DPRINT4(0, "Id Hash: %s (%x, %x), %d tries\n", pAC->name, pAC->id, pAC->Extid, nTries);
            }
            ++nBad;
        }
    }
    DPRINT4(0, "Id Hash: %d hash, %d ents, %d bad, %d Tries\n", ATTCOUNT, nEnt, nBad, nTotTries);
    return pTHS->errCode;
}

int
SCSchemaStats(
    IN THSTATE *pTHS,
    IN PCHAR pBuf
    )
/*++

Routine Description:

    Report schema alloc stats

Arguments:

    pTHS -
    pBuf - ignored

Return Value:

    pTHS->errCode

--*/
{
    DPRINT3(0, "%p: %d SchemaAlloced, %d SchemEntries\n",
            CurrSchemaPtr, SchemaAlloced, SchemaEntries);
    if (CurrSchemaPtr) {
        DPRINT2(0, "%d Schema Version, %d Forest Version\n",
                CurrSchemaPtr->ForestBehaviorVersion,
                gAnchor.ForestBehaviorVersion);
    } else {
        DPRINT(0, "No CurrSchemaPtr\n");
    }

    DPRINT3(0, "Name     : %6d %6d %4.2f\n", 
           hashstat.nameLookups, hashstat.nameTries,
           (float)hashstat.nameTries/hashstat.nameLookups);

    DPRINT3(0, "ClassName: %6d %6d %4.2f\n", 
           hashstat.classNameLookups, hashstat.classNameTries,
           (float)hashstat.classNameTries/hashstat.classNameLookups);

    DPRINT3(0, "id       : %6d %6d %4.2f\n", 
           hashstat.idLookups, hashstat.idTries,
           (float)hashstat.idTries/hashstat.idLookups);

    DPRINT3(0, "Class    : %6d %6d %4.2f\n", 
           hashstat.classLookups, hashstat.classTries,
           (float)hashstat.classTries/hashstat.classLookups);

    DPRINT3(0, "Col      : %6d %6d %4.2f\n", 
           hashstat.colLookups, hashstat.colTries,
           (float)hashstat.colTries/hashstat.colLookups);

    DPRINT3(0, "Mapi     : %6d %6d %4.2f\n", 
           hashstat.mapiLookups, hashstat.mapiTries,
           (float)hashstat.mapiTries/hashstat.mapiLookups);

    DPRINT3(0, "Link     : %6d %6d %4.2f\n", 
           hashstat.linkLookups, hashstat.linkTries,
           (float)hashstat.linkTries/hashstat.linkLookups);

    DPRINT3(0, "Prop     : %6d %6d %4.2f\n", 
           hashstat.PropLookups, hashstat.PropTries,
           (float)hashstat.PropTries/hashstat.PropLookups);

    DPRINT3(0, "ClassProp: %6d %6d %4.2f\n", 
           hashstat.classPropLookups, hashstat.classPropTries,
           (float)hashstat.classPropTries/hashstat.classPropLookups);

    return pTHS->errCode;
}
#endif DBG && INCLUDE_UNIT_TESTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\schash.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1993 - 1999
//
//  File:       schash.c
//
//--------------------------------------------------------------------------
//
// Abstract:
//
//   Contains hash functions used by schema cache code
//
// NOTE: This file is NOT to be compiled. This is created here
// so that we do not have to redefine the functions in both
// scache.c and scchk.c (and worry about keeping them the same 
// later), but just include this file. Since these are inline 
// static functions, extern declarations generate compiler errors. 
// These are not put in  the include directory since these are 
// code and not really just definitions 
//
//----------------------------------------------------------------------------

// The hash tables must be a power of 2 in length because the hash
// functions use (x & (n - 1)), not (x % n).
//
// A table of prime numbers and some code in scRecommendedHashSize
// has been left in place for later experimentation but has been
// ifdef'ed out to save CD space.
//
// Using a prime number of slots reduces the size of the tables
// and decreases the miss rate but increases the cycles needed to
// compute the hash index by a factor of 10x to 20x in SChash. SChash
// is called much more frequently than SCName/GuidHash.
//
// If you change schash.c, you must touch scchk.c and scache.c
// so that they get rebuilt because they include schash.c

static __inline ULONG SChash(ULONG hkey, ULONG count)
{
    // count must be a PowerOf2
    return((hkey << 3) & (count - 1));
}

static __inline ULONG SCGuidHash(GUID hkey, ULONG count)
{
   // We just cast each byte of the 16-byte guid to an ulong,
   // and add them all up (so max value is (255 X 16), then
   // hash this sum as usual

   PUCHAR pVal = (PUCHAR) &hkey;
   ULONG i, val=0;

   for (i=0; i<sizeof(GUID); i++) {
       val += (*pVal);
       pVal++;
   }
    // pseudo-random
   return (val % (count - 1));
}

static __inline ULONG SCNameHash(ULONG size, PUCHAR pVal, ULONG count)
{
    ULONG val=0;
    while(size--) {
        // Map A->a, B->b, etc.  Also maps @->', but who cares.
        // val += (*pVal | 0x20);
        val = ((val << 7) - val) + (*pVal | 0x20);
        pVal++;
    }
    // pseudo-random
    return (val % (count - 1));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsapi\drs_client.c ===
#include <NTDSpch.h>
#pragma  hdrstop
#include <drs_w.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\xdommove.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       xDomMove.c
//
//--------------------------------------------------------------------------

/*++

Module Name:

    xDomMove.c

Abstract:

    This module implements various items relevant to cross domain move.

Author:

    Dave Straube (davestr) 8/7/98

Revision History:

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <ntdsa.h>                      // Core data types
#include <scache.h>                     // Schema cache code
#include <dbglobal.h>                   // DBLayer header.
#include <mdglobal.h>                   // THSTATE definition
#include <mdlocal.h>                    // DSNAME manipulation routines
#include <dsatools.h>                   // Memory, etc.
#include <objids.h>                     // ATT_* definitions
#include <mdcodes.h>                    // Only needed for dsevent.h
#include <filtypes.h>                   // filter types
#include <dsevent.h>                    // Only needed for LogUnhandledError
#include <dsexcept.h>                   // exception handlers
#include <debug.h>                      // Assert()
#include <xdommove.h>                   // This file's prototypes
#include <winsock.h>                    // host <--> net long conversions

#include <fileno.h>
#define  FILENO FILENO_XDOMMOVE

DWORD
GetProxyType(
    SYNTAX_DISTNAME_BINARY          *pProxy)
{
    ULONG netLong;

    PROXY_SANITY_CHECK(pProxy);
    netLong = * PROXY_DWORD_ADDR(pProxy, PROXY_TYPE_OFFSET);
    return(ntohl(netLong));
}

DWORD
GetProxyTypeInternal(
    DWORD                           cBytes,
    INTERNAL_SYNTAX_DISTNAME_STRING *pProxy)
{
    ULONG netLong;

    INTERNAL_PROXY_SANITY_CHECK(cBytes, pProxy);
    netLong = ((DWORD *) pProxy->data.byteVal)[PROXY_TYPE_OFFSET];
    return(ntohl(netLong));
}

DWORD
GetProxyEpoch(
    SYNTAX_DISTNAME_BINARY          *pProxy)
{
    ULONG netLong;

    PROXY_SANITY_CHECK(pProxy);
    netLong = * PROXY_DWORD_ADDR(pProxy, PROXY_EPOCH_OFFSET);
    return(ntohl(netLong));
}

DWORD
GetProxyEpochInternal(
    DWORD                           cBytes,
    INTERNAL_SYNTAX_DISTNAME_STRING *pProxy)
{
    ULONG netLong;

    INTERNAL_PROXY_SANITY_CHECK(cBytes, pProxy);
    netLong = ((DWORD *) pProxy->data.byteVal)[PROXY_EPOCH_OFFSET];
    return(ntohl(netLong));
}

// Following throw exceptions and returns THAllocEx'd memory.

VOID
MakeProxy(
    THSTATE                         *pTHS,
    DSNAME                          *pName,
    DWORD                           type,
    DWORD                           epoch,
    ULONG                           *pcBytes,
    SYNTAX_DISTNAME_BINARY          **ppProxy)
{
    Assert(VALID_THSTATE(pTHS));
    Assert(type < PROXY_TYPE_UNKNOWN);

    *pcBytes = PADDEDNAMESIZE(pName) + PROXY_BLOB_SIZE;
    *ppProxy = (SYNTAX_DISTNAME_BINARY *) THAllocEx(pTHS, *pcBytes);
    memcpy(&(*ppProxy)->Name, pName, pName->structLen);
    (DATAPTR(*ppProxy))->structLen = PROXY_BLOB_SIZE;
    * PROXY_DWORD_ADDR(*ppProxy, PROXY_TYPE_OFFSET) = htonl(type);
    * PROXY_DWORD_ADDR(*ppProxy, PROXY_EPOCH_OFFSET) = htonl(epoch);
    PROXY_SANITY_CHECK(*ppProxy);
}

VOID
MakeProxyKeyInternal(
    DWORD                           DNT,
    DWORD                           type,
    DWORD                           *pcBytes,
    VOID                            *buff)
{
    DWORD *key = (DWORD *) buff;

    Assert(type < PROXY_TYPE_UNKNOWN);
    Assert(*pcBytes >= (3 * sizeof(DWORD)));

    // Construct an INTERNAL_SYNTAX_DISTNAME_STRING value with all
    // but the epoch number on the end.  See also ExtIntDistString().

    key[0] = DNT;
    key[1] = PROXY_BLOB_SIZE;
    key[2] = htonl(type);
    *pcBytes = 3 * sizeof(DWORD);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsapi\dcinfo.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dcinfo.c

Abstract:

    Implementation of DsGetDomainControllerInfo API and helper functions.

Author:

    DaveStr     02-Jun-98

Environment:

    User Mode - Win32

Revision History:


--*/

#define _NTDSAPI_           // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <malloc.h>         // alloca()
#include <crt\excpt.h>      // EXCEPTION_EXECUTE_HANDLER
#include <crt\stdlib.h>     // wcstol, wcstoul
#include <dsgetdc.h>        // DsGetDcName()
#include <rpc.h>            // RPC defines
#include <rpcndr.h>         // RPC defines
#include <rpcbind.h>        // GetBindingInfo(), etc.
#include <drs_w.h>          // wire function prototypes
#include <bind.h>           // BindState
#include <util.h>           // OFFSET macro
#include <dststlog.h>       // DSLOG

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsGetDomainControllerInfoW                                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsGetDomainControllerInfoW(
    HANDLE                          hDs,            // in
    LPCWSTR                         DomainName,     // in
    DWORD                           InfoLevel,      // in
    DWORD                           *pcOut,         // out
    VOID                            **ppInfo        // out
    )
{
    DRS_MSG_DCINFOREQ       infoReq;
    DRS_MSG_DCINFOREPLY     infoReply;
    DWORD                   dwOutVersion = 0;
    DWORD                   dwErr;
#if DBG
    DWORD                   startTime = GetTickCount();
#endif

    if (    !DomainName 
         || !pcOut 
         || !ppInfo )
    {
        return(ERROR_INVALID_PARAMETER);
    }

    switch ( InfoLevel )
    {
    case 1:

        if ( !IS_DRS_EXT_SUPPORTED(((BindState *) hDs)->pServerExtensions,
                                   DRS_EXT_DCINFO_V1) ) {
            return(ERROR_NOT_SUPPORTED);
        }
        break;

    case 2:

        if ( !IS_DRS_EXT_SUPPORTED(((BindState *) hDs)->pServerExtensions,
                                   DRS_EXT_DCINFO_V2) ) {
            return(ERROR_NOT_SUPPORTED);
        }
        break;

    case DS_DCINFO_LEVEL_FFFFFFFF:

        if ( !IS_DRS_EXT_SUPPORTED(((BindState *) hDs)->pServerExtensions,
                                   DRS_EXT_DCINFO_VFFFFFFFF) ) {
            return(ERROR_NOT_SUPPORTED);
        }
        break;

    default:

        return(ERROR_INVALID_PARAMETER);
        break;
    }

    *pcOut = 0;
    *ppInfo = NULL;

    __try
    {
        memset(&infoReq, 0, sizeof(infoReq));
        memset(&infoReply, 0, sizeof(infoReply));

        infoReq.V1.Domain = (WCHAR *) DomainName;
        infoReq.V1.InfoLevel = InfoLevel;

        dwErr = _IDL_DRSDomainControllerInfo(
                        ((BindState *) hDs)->hDrs,
                        1,                              // dwInVersion
                        &infoReq,
                        &dwOutVersion,
                        &infoReply);

        // See drs.idl for how infoReq.V1.InfoLevel and dwOutVersion
        // are correlated (near definition for DRS_MSG_DCINFOREPLY).

        if ( 0 == dwErr )
        {
            if ( dwOutVersion != InfoLevel )
            {
                dwErr = ERROR_DS_INTERNAL_FAILURE;
            }
            else
            {
                // Since all versions of DRS_MSG_DCINFOREPLY_V* have the
                // same two fields in the same two places, we can use
                // the V1 version in all InfoLevel cases. 

                *pcOut = infoReply.V1.cItems;
                *ppInfo = infoReply.V1.rItems;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        dwErr = RpcExceptionCode();
    }

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsGetDomainControllerInfo]"));
    DSLOG((0,"[DN=%ws][LV=%u][ST=%u][ET=%u][ER=%u][-]\n",
           DomainName, InfoLevel, startTime, GetTickCount(), dwErr))
        
    return(dwErr);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsGetDomainControllerInfoA                                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsGetDomainControllerInfoA(
    HANDLE                          hDs,            // in
    LPCSTR                          DomainName,     // in
    DWORD                           InfoLevel,      // in
    DWORD                           *pcOut,         // out
    VOID                            **ppInfo        // out
    )
{
    DWORD                           dwErr = ERROR_INVALID_PARAMETER;
    WCHAR                           *pwszDomainName = NULL;
    DWORD                           i;
    CHAR                            *pszTmp;
    DS_DOMAIN_CONTROLLER_INFO_1W    *pInfoV1;
    DS_DOMAIN_CONTROLLER_INFO_2W    *pInfoV2;
    DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW    *pInfoVFFFFFFFF;

    if (    !DomainName 
         || !pcOut 
         || !ppInfo )
    {
        return(ERROR_INVALID_PARAMETER);
    }

    switch ( InfoLevel )
    {
    case 1:

        if ( !IS_DRS_EXT_SUPPORTED(((BindState *) hDs)->pServerExtensions,
                                   DRS_EXT_DCINFO_V1) ) {
            return(ERROR_NOT_SUPPORTED);
        }
        break;

    case 2:

        if ( !IS_DRS_EXT_SUPPORTED(((BindState *) hDs)->pServerExtensions,
                                   DRS_EXT_DCINFO_V2) ) {
            return(ERROR_NOT_SUPPORTED);
        }
        break;

    case DS_DCINFO_LEVEL_FFFFFFFF:

        if ( !IS_DRS_EXT_SUPPORTED(((BindState *) hDs)->pServerExtensions,
                                   DRS_EXT_DCINFO_VFFFFFFFF) ) {

            return(ERROR_NOT_SUPPORTED);
        }
        break;

    default:

        return(ERROR_INVALID_PARAMETER);
        break;
    }

    *pcOut = 0;
    *ppInfo = NULL;

    if (    !DomainName
         || (dwErr = AllocConvertWide(DomainName, &pwszDomainName))
         || (dwErr = DsGetDomainControllerInfoW(hDs, 
                                                pwszDomainName, 
                                                InfoLevel, 
                                                pcOut, 
                                                ppInfo)) )
    {

        goto Cleanup;
    }

    // Convert all string values from WCHAR to ASCII.  We overwrite the WCHAR
    // buffer with the ASCII data knowing that (sizeof(WCHAR) < sizeof(CHAR)).

    for ( i = 0; i < *pcOut; i++ )
    {
        switch ( InfoLevel )
        {
        case 1:

            pInfoV1 = & ((DS_DOMAIN_CONTROLLER_INFO_1W *) (*ppInfo))[i];

            if ( pInfoV1->NetbiosName ) {
                if ( dwErr = AllocConvertNarrow(pInfoV1->NetbiosName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoV1->NetbiosName, pszTmp);
                LocalFree(pszTmp);
            }

            if ( pInfoV1->DnsHostName ) {
                if ( dwErr = AllocConvertNarrow(pInfoV1->DnsHostName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoV1->DnsHostName, pszTmp);
                LocalFree(pszTmp);
            }
            
            if ( pInfoV1->SiteName ) {
                if ( dwErr = AllocConvertNarrow(pInfoV1->SiteName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoV1->SiteName, pszTmp);
                LocalFree(pszTmp);
            }

            if ( pInfoV1->ComputerObjectName ) {
                if ( dwErr = AllocConvertNarrow(pInfoV1->ComputerObjectName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoV1->ComputerObjectName, pszTmp);
                LocalFree(pszTmp);
            }

            if ( pInfoV1->ServerObjectName ) {
                if ( dwErr = AllocConvertNarrow(pInfoV1->ServerObjectName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoV1->ServerObjectName, pszTmp);
                LocalFree(pszTmp);
            }

            break;

        case 2:

            pInfoV2 = & ((DS_DOMAIN_CONTROLLER_INFO_2W *) (*ppInfo))[i];

            if ( pInfoV2->NetbiosName ) {
                if ( dwErr = AllocConvertNarrow(pInfoV2->NetbiosName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoV2->NetbiosName, pszTmp);
                LocalFree(pszTmp);
            }

            if ( pInfoV2->DnsHostName ) {
                if ( dwErr = AllocConvertNarrow(pInfoV2->DnsHostName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoV2->DnsHostName, pszTmp);
                LocalFree(pszTmp);
            }
            
            if ( pInfoV2->SiteName ) {
                if ( dwErr = AllocConvertNarrow(pInfoV2->SiteName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoV2->SiteName, pszTmp);
                LocalFree(pszTmp);
            }

            if ( pInfoV2->SiteObjectName ) {
                if ( dwErr = AllocConvertNarrow(pInfoV2->SiteObjectName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoV2->SiteObjectName, pszTmp);
                LocalFree(pszTmp);
            }

            if ( pInfoV2->ComputerObjectName ) {
                if ( dwErr = AllocConvertNarrow(pInfoV2->ComputerObjectName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoV2->ComputerObjectName, pszTmp);
                LocalFree(pszTmp);
            }

            if ( pInfoV2->ServerObjectName ) {
                if ( dwErr = AllocConvertNarrow(pInfoV2->ServerObjectName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoV2->ServerObjectName, pszTmp);
                LocalFree(pszTmp);
            }

            if ( pInfoV2->NtdsDsaObjectName ) {
                if ( dwErr = AllocConvertNarrow(pInfoV2->NtdsDsaObjectName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoV2->NtdsDsaObjectName, pszTmp);
                LocalFree(pszTmp);
            }

            break;

        case 0xFFFFFFFF:

            pInfoVFFFFFFFF = & ((DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW *) (*ppInfo))[i];

            if ( pInfoVFFFFFFFF->UserName ) {
                if ( dwErr = AllocConvertNarrow(pInfoVFFFFFFFF->UserName, 
                                                &pszTmp) ) {
                    goto Cleanup;
                }
                strcpy((CHAR *) pInfoVFFFFFFFF->UserName, pszTmp);
                LocalFree(pszTmp);
            }

            break;

        }
    }

Cleanup:

    if ( pwszDomainName )
        LocalFree(pwszDomainName);

    if ( dwErr && *pcOut && *ppInfo )
        DsFreeDomainControllerInfoW(InfoLevel, *pcOut, *ppInfo);

    return(dwErr);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsFreeDomainControllerInfoW                                          //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
DsFreeDomainControllerInfoW(
    DWORD                           InfoLevel,      // in
    DWORD                           cInfo,          // in
    VOID                            *pInfo          // in
    )
{
    DWORD                           i;
    DS_DOMAIN_CONTROLLER_INFO_1W    *pInfoV1;
    DS_DOMAIN_CONTROLLER_INFO_2W    *pInfoV2;
    DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW    *pInfoVFFFFFFFF;

    if ( cInfo && pInfo )
    {
        switch ( InfoLevel )
        {
        case 1:

            pInfoV1 = & ((DS_DOMAIN_CONTROLLER_INFO_1W *) (pInfo))[0];

            for ( i = 0; i < cInfo; i++ )
            {
                MIDL_user_free(pInfoV1[i].NetbiosName);
                MIDL_user_free(pInfoV1[i].DnsHostName);
                MIDL_user_free(pInfoV1[i].SiteName);
                MIDL_user_free(pInfoV1[i].ComputerObjectName);
                MIDL_user_free(pInfoV1[i].ServerObjectName);
            }

            MIDL_user_free(pInfo);
            break;

        case 2:

            pInfoV2 = & ((DS_DOMAIN_CONTROLLER_INFO_2W *) (pInfo))[0];

            for ( i = 0; i < cInfo; i++ )
            {
                MIDL_user_free(pInfoV2[i].NetbiosName);
                MIDL_user_free(pInfoV2[i].DnsHostName);
                MIDL_user_free(pInfoV2[i].SiteName);
                MIDL_user_free(pInfoV2[i].SiteObjectName);
                MIDL_user_free(pInfoV2[i].ComputerObjectName);
                MIDL_user_free(pInfoV2[i].ServerObjectName);
                MIDL_user_free(pInfoV2[i].NtdsDsaObjectName);
            }

            MIDL_user_free(pInfo);
            break;

       case 0xFFFFFFFF:

            pInfoVFFFFFFFF = & ((DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW *) (pInfo))[0];

            for ( i = 0; i < cInfo; i++ )
            {
                MIDL_user_free(pInfoVFFFFFFFF[i].UserName);
            }

            MIDL_user_free(pInfo);
            break;
        }
    }
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsFreeDomainControllerInfoA                                          //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
DsFreeDomainControllerInfoA(
    DWORD                           InfoLevel,      // in
    DWORD                           cInfo,          // in
    VOID                            *pInfo          // in
    )
{
    DsFreeDomainControllerInfoW(InfoLevel, cInfo, pInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsapi\addsid.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    addsid.c

Abstract:

    Implementation of DsAddSidHistory.

Author:

    DaveStr     09-Mar-99

Environment:

    User Mode - Win32

Revision History:

--*/

#define _NTDSAPI_           // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <crt\excpt.h>      // EXCEPTION_EXECUTE_HANDLER
#include <rpc.h>            // RPC defines
#include <drs_w.h>          // wire function prototypes
#include <bind.h>           // BindState
#include <util.h>           // AllocConvertWide()
#include <dsutil.h>         // MAP_SECURITY_PACKAGE_ERROR()
#include <dststlog.h>       // DSLOG

#include "dsdebug.h"        // debug utility functions

//
// For DPRINT...
//
#define DEBSUB  "NTDSAPI_ADDSID"

NTDSAPI
DWORD
WINAPI
DsAddSidHistoryW(
    HANDLE                  hDs,                    // in
    DWORD                   Flags,                  // in
    LPCWSTR                 SrcDomain,              // in - DNS or NetBIOS
    LPCWSTR                 SrcPrincipal,           // in - SAM account name
    LPCWSTR                 SrcDomainController,    // in, optional - NetBIOS
    RPC_AUTH_IDENTITY_HANDLE SrcDomainCreds,        // in - creds for src domai
    LPCWSTR                 DstDomain,              // in - DNS or NetBIOS
    LPCWSTR                 DstPrincipal            // in - SAM account name
    )

/*++

Routine Description:

    Adds the SID and SID History from SrcPrincipal to the SID History
    of DstPrincipal.

    WARN: DsAddSidHistory may fail with ACCESS_DENIED if SrcDomainCreds
    are NULL and the binding, hDs, used IMPERSONATE instead of DELEGATE.
    To get this call to work, the user must enable Delegation at the
    destination DC or run this call on the DstDc while specifying
    the DstDc's NetBIOS name when binding (forces LRPC).
    
Arguments:
    hDs - From DsBindxxx
    Flags - must be 0
    SrcDomain - NT4 - NetBIOS name
                NT5 - DNS name
    SrcPrincipal - name of account principal with SIDs to copy
    SrcDomainController - OPTIONAL NT4 - NetBIOS name
                          OPTIONAL NT5 - DNS name
    SrcDomainCreds - OPTIONAL address of a SEC_WINNT_AUTH_IDENTITY_W
    DstDomain - NetBIOS or DNS name of the destination domain of DstPrincipal
    DstPrincipal - name of account principal to receive copied SIDs

Return Value:

    0 on success.  WIN32 error code.

--*/
{
    DWORD                       dwErr = ERROR_INVALID_PARAMETER;
    DRS_MSG_ADDSIDREQ           req;
    DRS_MSG_ADDSIDREPLY         reply;
    SEC_WINNT_AUTH_IDENTITY_W   *pSec;
    WCHAR                       *pwszUser = NULL;
    WCHAR                       *pwszDomain = NULL;
    WCHAR                       *pwszPassword = NULL;
    DWORD                       cbScratch;
    CHAR                        *pszScratch = NULL;
    DWORD                       dwOutVersion = 0;
#if DBG
    DWORD                       startTime = 0;
#endif

    pSec = (SEC_WINNT_AUTH_IDENTITY_W *) SrcDomainCreds;

    if (    !hDs
         || !SrcDomain
         || !SrcPrincipal
         || (   (pSec)
             && (    !pSec->User
                  || !pSec->UserLength
                  || !pSec->Domain
                  || !pSec->DomainLength
                  || !pSec->Password
                  || (    !(pSec->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI)
                       && !(pSec->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE))))
         || !DstDomain
         || !DstPrincipal ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( !IS_DRS_EXT_SUPPORTED(((BindState *) hDs)->pServerExtensions,
                               DRS_EXT_ADD_SID_HISTORY) ) {
        return(ERROR_NOT_SUPPORTED);
    }

    __try {

        // require strong encryption if creds are being passed
        if (SrcDomainCreds) {
            memset(&req, 0, sizeof(req));
            memset(&reply, 0, sizeof(reply));

            // Check if the connection is secure enough for addsid.
            // At this time, this means the connection is local or,
            // if remote, is using encryption keys that are at least
            // 128bits in length.
            req.V1.Flags = DS_ADDSID_FLAG_PRIVATE_CHK_SECURE;
            RpcTryExcept {
                dwErr = _IDL_DRSAddSidHistory(((BindState *) hDs)->hDrs,
                                             1, &req, &dwOutVersion, &reply);
            } RpcExcept(1) {
                dwErr = RpcExceptionCode();
                MAP_SECURITY_PACKAGE_ERROR(dwErr);
            } RpcEndExcept;
            DPRINT1(0, "IDL_DRSAddSidHistory check secure ==> %08x\n", dwErr);

            if ( !dwErr ) {
                if ( 1 != dwOutVersion ) {
                    dwErr = RPC_S_INTERNAL_ERROR;
                } else {
                    dwErr = reply.V1.dwWin32Error;
                }
            }
            DPRINT1(0, "IDL_DRSAddSidHistory check secure reply ==> %08x\n", dwErr);

            if (dwErr) {
                __leave;
            }
        }

        memset(&req, 0, sizeof(req));
        memset(&reply, 0, sizeof(reply));

        req.V1.Flags = Flags;
        req.V1.SrcDomain = (WCHAR *) SrcDomain;
        req.V1.SrcPrincipal = (WCHAR *) SrcPrincipal;
        req.V1.SrcDomainController = (WCHAR *) SrcDomainController;
        req.V1.DstDomain = (WCHAR *) DstDomain;
        req.V1.DstPrincipal = (WCHAR *) DstPrincipal;

        // UNICODE creds; accept as is
        if ( pSec && (pSec->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE) ) {
            req.V1.SrcCredsUserLength = pSec->UserLength;
            req.V1.SrcCredsUser = pSec->User;
            req.V1.SrcCredsDomainLength = pSec->DomainLength;
            req.V1.SrcCredsDomain = pSec->Domain;
            req.V1.SrcCredsPasswordLength = pSec->PasswordLength;
            req.V1.SrcCredsPassword = pSec->Password;
        }
        // ANSI creds; convert to UNICODE
        if ( pSec && (pSec->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI) ) {
            // Allocate scratch buffer guaranteed to be big enough.
            cbScratch = pSec->UserLength + 1;
            cbScratch += pSec->DomainLength;
            cbScratch += pSec->PasswordLength;

            if ( NULL == (pszScratch = LocalAlloc(LPTR, cbScratch)) ) {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                __leave;
            }

            req.V1.SrcCredsUserLength = pSec->UserLength;
            memset(pszScratch, 0, cbScratch);
            memcpy(pszScratch, pSec->User, pSec->UserLength);
            if ( dwErr = AllocConvertWide(pszScratch, &pwszUser) ) {
                __leave;
            }
            req.V1.SrcCredsUser = pwszUser;

            req.V1.SrcCredsDomainLength = pSec->DomainLength;
            memset(pszScratch, 0, cbScratch);
            memcpy(pszScratch, pSec->Domain, pSec->DomainLength);
            if ( dwErr = AllocConvertWide(pszScratch, &pwszDomain) ) {
                __leave;
            }
            req.V1.SrcCredsDomain = pwszDomain;

            req.V1.SrcCredsPasswordLength = pSec->PasswordLength;
            memset(pszScratch, 0, cbScratch);
            memcpy(pszScratch, pSec->Password, pSec->PasswordLength);
            if ( dwErr = AllocConvertWide(pszScratch, &pwszPassword) ) {
                __leave;
            }
            req.V1.SrcCredsPassword = pwszPassword;
        }
        DPRINT(0, "IDL_DRSAddSidHistory:\n");
        DPRINT1(0, "    Flags                 : %08x\n", req.V1.Flags);
        DPRINT1(0, "    SrcDomain             : %ws\n", req.V1.SrcDomain);
        DPRINT1(0, "    SrcPrincipal          : %ws\n", req.V1.SrcPrincipal);
        DPRINT1(0, "    SrcDomainController   : %ws\n", req.V1.SrcDomainController);
        DPRINT1(0, "    DstDomain             : %ws\n", req.V1.DstDomain);
        DPRINT1(0, "    DstPrincipal          : %ws\n", req.V1.DstPrincipal);
        DPRINT1(0, "    SrcCredsUserLength    : %d\n", req.V1.SrcCredsUserLength);
        DPRINT1(0, "    SrcCredsUser          : %ws\n", req.V1.SrcCredsUser);
        DPRINT1(0, "    SrcCredsDomainLength  : %d\n", req.V1.SrcCredsDomainLength);
        DPRINT1(0, "    SrcCredsDomain        : %ws\n", req.V1.SrcCredsDomain);
        // Never in clear text...
        // DPRINT1(0, "    SrcCredsPasswordLength: %d\n", req.V1.SrcCredsPasswordLength);
        // DPRINT1(0, "    SrcCredsPassword      : %ws\n", req.V1.SrcCredsPassword);

        RpcTryExcept {
            dwErr = _IDL_DRSAddSidHistory(((BindState *) hDs)->hDrs,
                                         1, &req, &dwOutVersion, &reply);
        } RpcExcept(1) {
            dwErr = RpcExceptionCode();
            MAP_SECURITY_PACKAGE_ERROR(dwErr);
        } RpcEndExcept;

        DPRINT2(0, "IDL_DRSAddSidHistory ==> %08x, %d\n", 
                dwErr, 
                dwOutVersion);

        if ( !dwErr ) {
            if ( 1 != dwOutVersion ) {
                dwErr = RPC_S_INTERNAL_ERROR;
            } else {
                dwErr = reply.V1.dwWin32Error;
            }
        }
        DPRINT1(0, "IDL_DRSAddSidHistory reply ==> %08x\n", dwErr);

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwErr = GetExceptionCode();
    }

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsAddSidHistory]"));
    DSLOG((0,"[PA=%ws][PA=%ws][PA=%ws][PA=%ws][PA=%ws][ST=%u][ET=%u][ER=%u][-]\n",
           SrcDomain, SrcPrincipal, 
           SrcDomainController ? SrcDomainController : L"NULL",
           DstDomain, DstPrincipal,
           startTime, GetTickCount(), dwErr))

    if ( pwszUser )     LocalFree(pwszUser);
    if ( pwszDomain )   LocalFree(pwszDomain);
    if ( pwszPassword ) LocalFree(pwszPassword);
    if ( pszScratch)    LocalFree(pszScratch);

    return(dwErr);
}

NTDSAPI
DWORD
WINAPI
DsAddSidHistoryA(
    HANDLE                  hDs,                    // in
    DWORD                   Flags,                  // in
    LPCSTR                  SrcDomain,              // in - DNS or NetBIOS
    LPCSTR                  SrcPrincipal,           // in - SAM account name
    LPCSTR                  SrcDomainController,    // in, optional - NetBIOS
    RPC_AUTH_IDENTITY_HANDLE SrcDomainCreds,        // in - creds for src domai
    LPCSTR                  DstDomain,              // in - DNS or NetBIOS
    LPCSTR                  DstPrincipal            // in - SAM account name
    )

/*++

Routine Description:

    See DsAddSidHistoryW

--*/

{
    DWORD                       dwErr = ERROR_INVALID_PARAMETER;
    WCHAR                       *SrcDomainW = NULL;
    WCHAR                       *SrcPrincipalW = NULL;
    WCHAR                       *SrcDomainControllerW = NULL;
    WCHAR                       *DstDomainW = NULL;
    WCHAR                       *DstPrincipalW = NULL;
    SEC_WINNT_AUTH_IDENTITY_W   *pSec;
    
    pSec = (SEC_WINNT_AUTH_IDENTITY_W *) SrcDomainCreds;

    if (    !hDs
         || !SrcDomain
         || !SrcPrincipal
         || (   (pSec)
             && (    !pSec->User
                  || !pSec->UserLength
                  || !pSec->Domain
                  || !pSec->DomainLength
                  || !pSec->Password
                  || (    !(pSec->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI)
                       && !(pSec->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE))))
         || !DstDomain
         || !DstPrincipal ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( !IS_DRS_EXT_SUPPORTED(((BindState *) hDs)->pServerExtensions,
                               DRS_EXT_ADD_SID_HISTORY) ) {
        return(ERROR_NOT_SUPPORTED);
    }

    if (    !(dwErr = AllocConvertWide(SrcDomain, 
                                      &SrcDomainW))
         && !(dwErr = AllocConvertWide(SrcPrincipal, 
                                      &SrcPrincipalW))
         && (    !SrcDomainController
              || !(dwErr = AllocConvertWide(SrcDomainController, 
                                            &SrcDomainControllerW)))
         && !(dwErr = AllocConvertWide(DstDomain, 
                                      &DstDomainW))
         && !(dwErr = AllocConvertWide(DstPrincipal, 
                                      &DstPrincipalW)) ) {
        dwErr = DsAddSidHistoryW(hDs, Flags, SrcDomainW, SrcPrincipalW,
                                 SrcDomainControllerW, SrcDomainCreds, 
                                 DstDomainW, DstPrincipalW);
    }

    if ( SrcDomainW )           LocalFree(SrcDomainW);
    if ( SrcPrincipalW )        LocalFree(SrcPrincipalW);
    if ( SrcDomainControllerW ) LocalFree(SrcDomainControllerW);
    if ( DstDomainW )           LocalFree(DstDomainW);
    if ( DstPrincipalW )        LocalFree(DstPrincipalW);

    return(dwErr);
}

NTDSAPI
DWORD
WINAPI
DsInheritSecurityIdentityW(
    HANDLE                  hDs,                    // in
    DWORD                   Flags,                  // in - sbz for now
    LPCWSTR                 SrcPrincipal,           // in - distinguished name
    LPCWSTR                 DstPrincipal            // in - distinguished name
    )
{
    DWORD                       dwErr = ERROR_INVALID_PARAMETER;
    DRS_MSG_ADDSIDREQ           req;
    DRS_MSG_ADDSIDREPLY         reply;
    DWORD                       dwOutVersion = 0;
#if DBG
    DWORD                       startTime = 0;
#endif

    if (    !hDs
         || !SrcPrincipal
         || !DstPrincipal ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( !IS_DRS_EXT_SUPPORTED(((BindState *) hDs)->pServerExtensions,
                               DRS_EXT_ADD_SID_HISTORY) ) {
        return(ERROR_NOT_SUPPORTED);
    }

    __try {

        memset(&req, 0, sizeof(req));
        memset(&reply, 0, sizeof(reply));

        req.V1.Flags = (Flags | DS_ADDSID_FLAG_PRIVATE_DEL_SRC_OBJ);
        req.V1.SrcDomain = NULL;
        req.V1.SrcPrincipal = (WCHAR *) SrcPrincipal;
        req.V1.SrcDomainController = NULL;
        req.V1.DstDomain = NULL;
        req.V1.DstPrincipal = (WCHAR *) DstPrincipal;
        req.V1.SrcCredsUserLength = 0;
        req.V1.SrcCredsUser = NULL;
        req.V1.SrcCredsDomainLength = 0;
        req.V1.SrcCredsDomain = NULL;
        req.V1.SrcCredsPasswordLength = 0;
        req.V1.SrcCredsPassword = NULL;

        RpcTryExcept {
            dwErr = _IDL_DRSAddSidHistory(((BindState *) hDs)->hDrs,
                                         1, &req, &dwOutVersion, &reply);
        } RpcExcept(1) {
            dwErr = RpcExceptionCode();
            MAP_SECURITY_PACKAGE_ERROR(dwErr);
        } RpcEndExcept;

        if ( !dwErr ) {
            if ( 1 != dwOutVersion ) {
                dwErr = RPC_S_INTERNAL_ERROR;
            } else {
                dwErr = reply.V1.dwWin32Error;
            }
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwErr = GetExceptionCode();
    }

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsInheritSecurityIdentity]"));
    DSLOG((0,"[PA=%ws][PA=%ws][ST=%u][ET=%u][ER=%u][-]\n",
           SrcPrincipal, DstPrincipal,
           startTime, GetTickCount(), dwErr))

    return(dwErr);
}

NTDSAPI
DWORD
WINAPI
DsInheritSecurityIdentityA(
    HANDLE                  hDs,                    // in
    DWORD                   Flags,                  // in - sbz for now
    LPCSTR                  SrcPrincipal,           // in - distinguished name
    LPCSTR                  DstPrincipal            // in - distinguished name
    )
{
    DWORD                       dwErr = ERROR_INVALID_PARAMETER;
    WCHAR                       *SrcPrincipalW = NULL;
    WCHAR                       *DstPrincipalW = NULL;
    
    if (    !hDs
         || !SrcPrincipal
         || !DstPrincipal ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( !IS_DRS_EXT_SUPPORTED(((BindState *) hDs)->pServerExtensions,
                               DRS_EXT_ADD_SID_HISTORY) ) {
        return(ERROR_NOT_SUPPORTED);
    }

    if (    !(dwErr = AllocConvertWide(SrcPrincipal, 
                                      &SrcPrincipalW))
         && !(dwErr = AllocConvertWide(DstPrincipal, 
                                      &DstPrincipalW)) ) {
        dwErr = DsInheritSecurityIdentityW(hDs, Flags, 
                                           SrcPrincipalW, DstPrincipalW);
    }

    if ( SrcPrincipalW )        LocalFree(SrcPrincipalW);
    if ( DstPrincipalW )        LocalFree(DstPrincipalW);

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsapi\bind.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    bind.h

Abstract:

    Definitions for client side state which is automatically managed
    by the client stubs so that API users don't have to manage any
    connection state.  Currently the only connection state is the context
    handle.  Clients are returned a handle (pointer) to a BindState struct 
    rather than an RPC handle for the server directly. 

Author:

    DaveStr     10-May-97

Environment:

    User Mode - Win32

Revision History:

    DaveStr     20-Oct-97
        Removed dependency on MAPI STAT struct.

--*/

#ifndef __BIND_H__
#define __BIND_H__

// Check if the RPC excption code implies that the server
// may not be reachable. A subsequent call to DsUnbind
// will not attempt the unbind at the server. An unreachable
// server may take many 10's of seconds to timeout
// and we wouldn't want to punish correctly behaving
// apps that are attempting an unbind after a failing
// server call; eg, DsCrackNames.
//
// The server-side RPC will eventually issue a
// callback to our server code that will effectivly
// unbind at the server.
#define CHECK_RPC_SERVER_NOT_REACHABLE(_hDS_, _dwErr_) \
    (((BindState *) (_hDS_))->bServerNotReachable = \
    ((_dwErr_) == RPC_S_SERVER_UNAVAILABLE \
     || (_dwErr_) == RPC_S_CALL_FAILED \
     || (_dwErr_) == RPC_S_CALL_FAILED_DNE \
     || (_dwErr_) == RPC_S_OUT_OF_MEMORY))

#define NTDSAPI_SIGNATURE "ntdsapi"

typedef struct _BindState 
{
    BYTE            signature[8];       // NTDSAPI_SIGNATURE
    DRS_HANDLE      hDrs;               // DRS interface RPC context handle
    PDRS_EXTENSIONS pServerExtensions;  // server side DRS extensions 
    DWORD           bServerNotReachable; // server may be not be reachable
    // Following field must be last one in struct and is used to track
    // who a person is bound to so we can divine the destination from 
    // later ntdsapi.dll calls which pass an active BindState.
    WCHAR           bindAddr[1];        // binding address
} BindState;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsapi\bind.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    bind.c

Abstract:

    Implementation of ntdsapi.dll bind routines.

Author:

    DaveStr     24-Aug-96

Environment:

    User Mode - Win32

Revision History:

    wlees 9-Feb-98  Add support for credentials
--*/

#define _NTDSAPI_           // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <malloc.h>         // alloca()
#include <lmcons.h>         // MAPI constants req'd for lmapibuf.h
#include <lmapibuf.h>       // NetApiBufferFree()
#include <crt\excpt.h>      // EXCEPTION_EXECUTE_HANDLER
#include <dsgetdc.h>        // DsGetDcName()
#include <rpc.h>            // RPC defines
#include <rpcndr.h>         // RPC defines
#include <drs_w.h>            // wire function prototypes
#include <bind.h>           // BindState
#include <msrpc.h>          // DS RPC definitions
#include <stdio.h>          // for printf during debugging!
#include <dststlog.h>       // DSLOG
#include <dsutil.h>         // MAP_SECURITY_PACKAGE_ERROR
#define SECURITY_WIN32 1
#include <sspi.h>
#include <winsock.h>
#include <process.h>

#include "util.h"           // ntdsapi internal utility functions
#include "dsdebug.h"        // debug utility functions

//
// For DPRINT...
//
#define DEBSUB  "NTDSAPI_BIND:"

DEFINE_DSLOG;


DWORD
NtdsapiGetBinding(
    LPCWSTR             pwszAddress,
    BOOL                fUseLPC,
    RPC_BINDING_HANDLE  *phRpc,
    RPC_IF_HANDLE       clientIfHandle
    )
/*++

  Description:

    We used to call the ASCII-only routines in _clw to get an RPC binding
    to the server - but this is insufficient for internationalized server
    names.  Noting that a DS client needs tcp/ip connectivity if it is ever
    to do something more than what's in ntdsapi.dll (a likely requirement)
    then it is sufficient that DsBind* restrict itself to tcp/ip as well -
    with one exception.  We always try LPC first as it is cheap to test
    and performs better when available.

  Arguments:

    pwszAddress - Address to bind to.

    fUseLPC - Flag indicating whether to use LPC protocol.

    phRpc - Pointer to binding handle updated on return.

  Return Value:

    RPC error code, 0 on success

--*/
{
    DWORD   dwErr = 0;
    WCHAR   *pwszProtSeq = ( fUseLPC ? LPC_PROTSEQW : TCP_PROTSEQW );
    WCHAR   *pwszEndPoint = ( fUseLPC ? DS_LPC_ENDPOINTW : NULL );
    WCHAR   *pwszStringBinding = NULL;

    *phRpc = NULL;

    if ( 0 == wcsncmp(pwszAddress, L"\\\\", 2) )
    {
        pwszAddress += 2;
    }

    RpcTryExcept
    {
        dwErr = RpcStringBindingComposeW(
                                        NULL,
                                        pwszProtSeq,
                                        (WCHAR *) pwszAddress,
                                        pwszEndPoint,
                                        NULL,
                                        &pwszStringBinding);

        if ( RPC_S_OK == dwErr )
        {
            dwErr = RpcBindingFromStringBindingW(pwszStringBinding, phRpc);

            if ( RPC_S_OK == dwErr )
            {
                DPRINT(0, "RpcEpResolveBinding:\n");
                DPRINT1(0, "    pwszProtSeq : %ws\n", pwszProtSeq);
                DPRINT1(0, "    pwszAddress : %ws\n", pwszAddress);
                DPRINT1(0, "    pwszEndPoint: %ws\n", pwszEndPoint);
                dwErr = RpcEpResolveBinding(
                                        *phRpc,
                                        clientIfHandle);
                DPRINT1(0, "RpcEpResolveBinding ==> 0x%x\n", dwErr);
            }
        }
    }
    RpcExcept(1)
    {
        dwErr = RpcExceptionCode();
        DPRINT1(0, "RpcEpResolveBinding Exception ==> 0x%x\n", dwErr);
    }
    RpcEndExcept;

    if ( pwszStringBinding )
    {
        RpcStringFreeW(&pwszStringBinding);
    }

    if ( dwErr && *phRpc )
    {
        RpcBindingFree(phRpc);
    }

    return(dwErr);
}

DWORD
NtdsapiBindingSetAuthInfoExW(
    RPC_BINDING_HANDLE          hRpc,
    WCHAR                       *pwszSpn,
    ULONG                       AuthnLevel,
    ULONG                       AuthnSvc,
    RPC_AUTH_IDENTITY_HANDLE    AuthIdentity,
    ULONG                       AuthSvc,
    RPC_SECURITY_QOS            *pQos
    )
/*++

  Description:

    Private version of RpcBindingSetAuthInfoExW which calls the A version
    on win9x since 'W' version is not supported there.

  Arguments:

    Same as for RpcBindingSetAuthInfoExW.

  Return Values:

    WIN32 error code

--*/
{
    DWORD   dwErr = RPC_S_OK;
    CHAR    *pszSpn = NULL;

    RpcTryExcept
    {
#ifdef WIN95

        dwErr = AllocConvertNarrow(pwszSpn, &pszSpn);

        if ( ERROR_SUCCESS == dwErr )
        {
            // Sorry, but the 'Ex' version is not supported on WIN95,
            // so we just punt on the entire QOS stuff.

            dwErr = RpcBindingSetAuthInfoA(hRpc, pszSpn, AuthnLevel,
                                           AuthnSvc, AuthIdentity, AuthSvc);
        }
#else
        dwErr = RpcBindingSetAuthInfoExW(hRpc, pwszSpn, AuthnLevel,
                                         AuthnSvc, AuthIdentity,
                                         AuthSvc, pQos);
#endif
    }
    RpcExcept(1)
    {
        dwErr = RpcExceptionCode();
    }
    RpcEndExcept;

    if ( pszSpn) LocalFree(&pszSpn);

    return(dwErr);
}

BOOL
IsIpAddr(
    LPCWSTR pwsz
    )
/*++
    Simple test for whether a string is an IP address or not. We'd like
    to test for (INADDR_NONE != inet_addr(ipAddr)) but this seems to
    take long to execute - maybe it goes off machine.  So we simply
    check for length, occurrences of '.' and test all characters.
--*/
{
    DWORD   cChar = wcslen(pwsz);
    DWORD   cDot = 0;
    WCHAR   c;

    if ( cChar <= 15 )
    {
        while ( c = *(pwsz++) )
        {
            if ( iswdigit(c) )
            {
                continue;
            }
            else if ( L'.' == c )
            {
                cDot++;
            }
            else
            {
                return(FALSE);
            }
        }

        if ( 3 == cDot )
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

DWORD
SetUpMutualAuthAndEncryption(
    RPC_BINDING_HANDLE          hRpc,
    LPCWSTR                     DomainControllerName,
    LPCWSTR                     DnsDomainName,
    DOMAIN_CONTROLLER_INFOW     *pDcInfo,
    ULONG                       AuthnSvc,
    ULONG                       AuthnLevel,
    RPC_AUTH_IDENTITY_HANDLE    AuthIdentity,
    LPCWSTR                     ServicePrincipalName,
    ULONG                       ImpersonationType
    )
/*++

  Description:

    Sets up mutual authentication between client and service.

  Arguments:

    hRpc - Valid RPC binding handle to server.

    DomainControllerName - Same as for DsBind* - may be NULL.

    DnsDomainName - Same as for DsBind* - may be NULL.

    pDcInfo - DOMAIN_CONTROLLER_INFOW pointer in case original DsBind*
        arguments required us to find a DC for them.

    AuthnSvc - Specification of which authentication service is desired.

    AuthIdentity - Client credentials - may be NULL.

    ServicePrincipalName - SPN to use or NULL.

    ImpersonationType - IMPERSONATE or DELEGATE
    
    AuthnLevel - the authentication protection level needed (e.g. RPC_C_PROTECT_LEVEL_PKT_PRIVACY)
                 if not specified (0), the default (RPC_C_PROTECT_LEVEL_PKT_PRIVACY) is used.

  Return Values:

    Either RPC or WIN32 error code, 0 on success.

--*/
{
    DWORD               dwErr, dwErr1, cChar;
    LPCWSTR             pwszService = NULL;
    LPCWSTR             pwszInstance = NULL;
    WCHAR               *pwszTmpService = NULL;
    WCHAR               *pwszTmpInstance = NULL;
    WCHAR               *svcClass = L"LDAP";
    WCHAR               *pwszSpn = NULL;
    ULONG               AuthnLevel1;
    ULONG               AuthnSvc1;
    RPC_SECURITY_QOS    qos, qos1;

    // Mutual authentication via SPNs only makes sense if you can construct
    // the server's SPN a-priori.  For true security, you need to take this
    // literally.  For example, you can't generate SPN components by doing
    // lookups in DNS, or calling DsGetDcName which in turn calls DNS or other
    // components.  The reason is that any of those other components may be
    // compromised and work in concert with a destination server to spoof you.
    // Thus we construct SPNs strictly from the client's original DsBind args.

#if WIN95 || WINNT4
    // Mutual auth not supported on WIN95 or WINNT4 yet, and there are
    // negotiate problems as well.
    AuthnSvc = RPC_C_AUTHN_WINNT;
#endif

    if (AuthnLevel == 0) {
        AuthnLevel = RPC_C_PROTECT_LEVEL_PKT_PRIVACY;
    }

    if ( (RPC_C_AUTHN_WINNT != AuthnSvc) && !ServicePrincipalName )
    {
        // Test for each combination of original DsBind* arguments.

        if ( DomainControllerName && DnsDomainName )
        {
            // Caller gave all components needed to construct full 3-part SPN.
            pwszInstance = DomainControllerName;
            pwszService = DnsDomainName;
        }
        else if ( DomainControllerName && !DnsDomainName )
        {
            // Construct SPN of form: LDAP/ntdsdc4.ntdev.microsoft.com
            pwszInstance = DomainControllerName;
            pwszService = DomainControllerName;
        }
        else if ( !DomainControllerName && DnsDomainName )
        {
            // In this case DsBind* called DsGetDcName and pDcInfo is valid
            // and PaulLe says it is OK to use its DomainControllerName
            // to construct a full 3-part SPN.
            pwszInstance = pDcInfo->DomainControllerName;
            pwszService = DnsDomainName;
        }
        else
        {
            // Caller gave all NULL arguments which meant we were to find
            // a GC and also means they have no mutual auth requirements.
            // Construct SPN of form GC/host/forest.
            pwszInstance = pDcInfo->DomainControllerName;
            pwszService = pDcInfo->DnsForestName;
            svcClass = L"GC";
        }

        // Skip past leading "\\" if present.  This is not circumventing
        // a client who has passed NetBIOS names mistakenly but rather
        // helping the client which has passed args as returned by
        // DsGetDcName which prepends "\\" even when DS_RETURN_DNS_NAME
        // was requested.

        if (0 == wcsncmp(pwszInstance, L"\\\\", 2)) pwszInstance += 2;
        if (0 == wcsncmp(pwszService, L"\\\\", 2)) pwszService += 2;

        // Strip trailing '.' if it exists.  We do this as we know
        // the server side registers dot-less names only.  We can't whack
        // in place as the input args are const.

        cChar = wcslen(pwszInstance);
        if ( L'.' == pwszInstance[cChar - 1] )
        {
            pwszTmpInstance = (WCHAR *) alloca(cChar * sizeof(WCHAR));
            memcpy(pwszTmpInstance, pwszInstance, cChar * sizeof(WCHAR));
            pwszTmpInstance[cChar - 1] = L'\0';
            pwszInstance = (LPCWSTR) pwszTmpInstance;
        }

        cChar = wcslen(pwszService);
        if ( L'.' == pwszService[cChar - 1] )
        {
            pwszTmpService = (WCHAR *) alloca(cChar * sizeof(WCHAR));
            memcpy(pwszTmpService, pwszService, cChar * sizeof(WCHAR));
            pwszTmpService[cChar - 1] = L'\0';
            pwszService = (LPCWSTR) pwszTmpService;
        }

        // Check for IP addresses which can not be used for mutual auth.

        if ( IsIpAddr(pwszInstance) )
        {
#ifndef WIN95
//          STARTUPINFOW startupInfo;
//          GetStartupInfoW(&startupInfo);
//          DbgPrint("Warning - %ws trying mutual auth to IP addr: %ws\n",
//                   startupInfo.lpTitle, pwszInstance);
#endif
            DPRINT(0, "Attempt mutual auth with IP address.\n");
            goto MakeSPN;
        }

        // Check for NetBIOS names which can not be used for mutual auth.
        // 2/20/99 - Security run times check some global setting and either
        // fail mutual auth or quietly ignore the request.  So we can just
        // pass the args through unchanged, however we check so as to
        // generate warnings.

        if (    (    pwszInstance
                  && !wcschr(pwszInstance, L'.'))
             || (    pwszService
                  && !wcschr(pwszService, L'.')) )
        {
#ifndef WIN95
//          STARTUPINFOW startupInfo;
//          GetStartupInfoW(&startupInfo);
//          DbgPrint("Warning - %ws trying mutual auth to NB addr: %ws:%ws\n",
//                   startupInfo.lpTitle, pwszInstance, pwszService);
#endif
            DPRINT(0, "Attempt mutual auth with NetBIOS name.\n");
        }
    }

    // Now make the SPN.

MakeSPN:

    if ( RPC_C_AUTHN_WINNT == AuthnSvc )
    {
        pwszSpn = SERVER_PRINCIPAL_NAMEW;
    }
    else if ( ServicePrincipalName )
    {
        pwszSpn = (WCHAR *) ServicePrincipalName;
    }
    else
    {
        cChar = 0;
        dwErr = DsMakeSpnW(svcClass, pwszService, pwszInstance, 0,
                           NULL, &cChar, NULL);

        if ( dwErr && (ERROR_BUFFER_OVERFLOW != dwErr) )
        {
            DPRINT1(0, "DsMakeSpnW ==> 0x%x\n", dwErr);
            return(dwErr);
        }

        if ( !(pwszSpn = (WCHAR *) LocalAlloc(LPTR, sizeof(WCHAR) * cChar)) )
        {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        dwErr = DsMakeSpnW(svcClass, pwszService, pwszInstance, 0,
                           NULL, &cChar, pwszSpn);

        if ( dwErr )
        {
            DPRINT1(0, "DsMakeSpnW ==> 0x%x\n", dwErr);
            LocalFree(pwszSpn);
            return(dwErr);
        }
    }

    RpcTryExcept
    {
        qos.Version = RPC_C_SECURITY_QOS_VERSION;
        qos.Capabilities = ((RPC_C_AUTHN_WINNT == AuthnSvc) || (AuthnSvc == RPC_C_AUTHN_NONE))
                                ? RPC_C_QOS_CAPABILITIES_DEFAULT
                                : RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
        qos.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;
        qos.ImpersonationType = (RPC_C_AUTHN_WINNT == AuthnSvc)
                                ? RPC_C_IMP_LEVEL_DEFAULT
                                : ImpersonationType;

        DPRINT(0, "Authentication Info:\n");
        DPRINT1(0, "    SPN                ==> %ws\n", pwszSpn);
        DPRINT1(0, "    AuthnLevel         ==> %s\n",
            RPC_C_PROTECT_LEVEL_DEFAULT == AuthnLevel
                ? "RPC_C_PROTECT_LEVEL_DEFAULT"
                : (RPC_C_PROTECT_LEVEL_PKT_PRIVACY ==  AuthnLevel)
                    ? "RPC_C_PROTECT_LEVEL_PKT_PRIVACY"
                    : (RPC_C_AUTHN_LEVEL_NONE == AuthnLevel) 
                        ? "RPC_C_AUTHN_LEVEL_NONE"
                        : "???");
        DPRINT1(0, "    AuthnSvc           ==> %s\n",
            RPC_C_AUTHN_WINNT == AuthnSvc
                ? "RPC_C_AUTHN_WINNT"
                : RPC_C_AUTHN_GSS_NEGOTIATE == AuthnSvc
                    ? "RPC_C_AUTHN_GSS_NEGOTIATE"
                    : (RPC_C_AUTHN_GSS_KERBEROS == AuthnSvc)
                    ? "RPC_C_AUTHN_GSS_KERBEROS"
                    : (RPC_C_AUTHN_NONE == AuthnSvc)
                        ? "RPC_C_AUTHN_NONE"
                        : "???");
        DPRINT1(0, "    qos.Capabilities   ==> %s\n",
            RPC_C_QOS_CAPABILITIES_DEFAULT == qos.Capabilities
                ? "RPC_C_QOS_CAPABILITIES_DEFAULT"
                : "RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH");
        DPRINT1(0, "    qos.ImpersonationType   ==> %s\n",
            (RPC_C_IMP_LEVEL_DEFAULT == qos.ImpersonationType)
                ? "RPC_C_IMP_LEVEL_DEFAULT"
                : (RPC_C_IMP_LEVEL_IMPERSONATE == qos.ImpersonationType)
                      ? "RPC_C_IMP_LEVEL_IMPERSONATE"
                      : (RPC_C_IMP_LEVEL_DELEGATE == qos.ImpersonationType)
                            ? "RPC_C_IMP_LEVEL_DELEGATE"
                            : (RPC_C_IMP_LEVEL_ANONYMOUS == qos.ImpersonationType)
                                ? "RPC_C_IMP_LEVEL_ANONYMOUS"
                                : "???");

        dwErr = NtdsapiBindingSetAuthInfoExW(
                                hRpc,
                                pwszSpn,
                                AuthnLevel,
                                AuthnSvc,
                                AuthIdentity,
                                0,
                                &qos);
        DPRINT1(0, "NtdsapiBindingSetAuthInfoExW ==> 0x%x\n", dwErr);

#if DBG
#ifndef WIN95
        if ( !dwErr )
        {
            dwErr1 = RpcBindingInqAuthInfoExW(
                                hRpc,
                                NULL,
                                &AuthnLevel1,
                                &AuthnSvc1,
                                NULL,
                                NULL,
                                RPC_C_SECURITY_QOS_VERSION,
                                &qos1);
            DPRINT1(0, "RpcBindingInqAuthInfoExW ==> 0x%x\n", dwErr1);

            if ( !dwErr1 )
            {
                DPRINT2(0, "\tCapabilities:        %d ==> %d\n",
                    qos.Capabilities, qos1.Capabilities);
                DPRINT2(0, "\tIdentityTracking:    %d ==> %d\n",
                    qos.IdentityTracking, qos1.IdentityTracking);
                DPRINT2(0, "\tImpersonationType:   %d ==> %d\n",
                    qos.ImpersonationType, qos1.ImpersonationType);
                DPRINT2(0, "\tAuthnSvc:            %d ==> %d\n",
                    AuthnSvc, AuthnSvc1);
                DPRINT2(0, "\tAuthnLevel:          %d ==> %d\n",
                    AuthnLevel, AuthnLevel1);
            }
        }
#endif
#endif
    }
    RpcExcept(1)
    {
        dwErr = RpcExceptionCode();
        DPRINT1(0, "NtdsapiBindingSetAuthInfoExW Exception ==> 0x%x\n", dwErr);
    }
    RpcEndExcept;

    if (    pwszSpn
         && (RPC_C_AUTHN_WINNT != AuthnSvc)
         && (pwszSpn != ServicePrincipalName) )
    {
        LocalFree(pwszSpn);
    }

    return(dwErr);
}

DWORD
DsBindA(
    IN  LPCSTR  DomainControllerName,
    IN  LPCSTR  DnsDomainName,
    OUT HANDLE  *phDS
    )

/*++

Routine Description:

    Public wrapper for cred-less version of DsBindWithCredA.
    Default process credentials are used.
    See below.

Arguments:

    DomainControllerName -
    DnsDomainName -
    phDS -

Return Value:

    DWORD -

--*/

{
    return DsBindWithCredA( DomainControllerName,
                            DnsDomainName,
                            NULL, // credentials
                            phDS );
} /* DsBindA */


DWORD
DsBindW(
    LPCWSTR DomainControllerName,
    LPCWSTR DnsDomainName,
    HANDLE  *phDS
    )

/*++

Routine Description:

    Public wrapper for cred-less version of DsBindWithCredW
    Default process credentials are used.
    See below.

Arguments:

    DomainControllerName -
    DnsDomainName -
    phDS -

Return Value:

    DWORD -

--*/

{
    return DsBindWithCredW( DomainControllerName,
                            DnsDomainName,
                            NULL, // credentials
                            phDS );
} /* DsBindW */

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsBindWithSpnW                                                       //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

// Dup this definition from sdk\inc\crt\wchar.h since there it is
// within a #ifdef __cplusplus sentinel which we don't trigger..

const wchar_t *wmemchr(const wchar_t *_S, wchar_t _C, size_t _N)
{
    for ( ; 0 < _N; ++_S, --_N )
        if ( *_S == _C )
            return(_S);
    return (0);
}

BOOL
IsServerUnavailableError(
    DWORD   dwErr
    )
{
    // This list of error codes blessed by MazharM on 4/20/99.

    switch ( dwErr )
    {
    case RPC_S_SERVER_UNAVAILABLE:      // can't get there from here
    case EPT_S_NOT_REGISTERED:          // demoted or in DS repair mode
    case RPC_S_UNKNOWN_IF:              // demoted or in DS repair mode
    case RPC_S_INTERFACE_NOT_FOUND:     // demoted or in DS repair mode
    case RPC_S_COMM_FAILURE:            // can't get there from here
        return(TRUE);
    }

    return(FALSE);
}

DWORD
DsBindWithSpnW(
    IN  LPCWSTR DomainControllerName,
    IN  LPCWSTR DnsDomainName,
    IN  RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN  LPCWSTR ServicePrincipalName,
    OUT HANDLE  *phDS
    )

/*++

Routine Description:

    Starts an RPC session with a particluar DC.  See ntdsapi.h for
    description of DomainControllerName and DnsDomainName arguments.

    Bind is performed using supplied credentials.

Arguments:

    DomainControllerName - Same field as in DOMAIN_CONTROLLER_INFO.

    DnsDomainName - Dotted DNS name for a domain.

    AuthIdentity - Credentials to use, or NULL.

    ServicePrincipalName - SPN to use during mutual auth or NULL.

    phDS - Pointer to HANDLE which is filled in with BindState address
        on success.

Return Value:

    0 on success.  Miscellaneous RPC and DsGetDcName errors otherwise.

--*/

{
    DWORD                   dwErr;
    DOMAIN_CONTROLLER_INFOW *pDcInfo = NULL;
    RPC_BINDING_HANDLE      hRpc;
    GUID                    guid = NtdsapiClientGuid;
    LPCWSTR                 pBindingAddress;
    ULONG                   flags;
    DRS_HANDLE              hDrs;
    PDRS_EXTENSIONS         pServerExtensions;
    BOOL                    fUseLPC = TRUE;
    ULONG                   AuthnSvc;
#if DBG
    DWORD                   startTime = GetTickCount();
#endif
    DRS_EXTENSIONS_INT      ClientExtensions = {0};

    // We perform special semantics for explicit credentials whose
    // username has an "@" in it.  The assumption is that "@" is rare in
    // legacy user names, thus existence of an "@" probably means a UPN
    // has been presented.  The security subsystem makes the distinction
    // between a NULL domain and the empty string ("") domain.  For reasons
    // only the security people understand, the NULL domain can not be
    // used to authenticate UPNs.  And unfortunately few of the apps which
    // pass in explicit credentials can be expected to know this, much less
    // whether the user name field is a UPN or not.  So if the user name
    // contains "@" and the domain field is NULL, we substitute the empty
    // string for the NULL domain.  If this fails with ERROR_ACCESS_DENIED
    // and the user name is <= 20 chars, than it might indeed be a legacy
    // user name with an "@" in it, and we retry once with the NULL domain
    // again.

    DWORD                       cNullDomainRetries = 0;
    DWORD                       cUnavailableRetries = 0;
    SEC_WINNT_AUTH_IDENTITY_W   *pAuthInfo;
    PWCHAR                      emptyStringAorW = L"";
    BOOL                        fNullDomainRetryWarranted = FALSE;
    ULONG                       ImpersonationType;

    // Pass process ID to server.  Used to help track DRS handle leaks.
    ClientExtensions.cb = sizeof(DRS_EXTENSIONS_INT) - sizeof(DWORD);
    ClientExtensions.pid = _getpid();
    
    __try
    {
        // All fields of SEC_WINNT_AUTH_IDENTITY are in the same place in A and W
        // versions so assign temp variable at the same time we test for NULL.

        if (    (pAuthInfo = (PSEC_WINNT_AUTH_IDENTITY_W) AuthIdentity)
             && !pAuthInfo->Domain )
        {
            if (    (    (SEC_WINNT_AUTH_IDENTITY_UNICODE & pAuthInfo->Flags)
                      && wmemchr(pAuthInfo->User, L'@',
                                 pAuthInfo->UserLength) )
                 || (    (SEC_WINNT_AUTH_IDENTITY_ANSI & pAuthInfo->Flags)
                      && memchr((PCHAR) pAuthInfo->User, '@',
                                pAuthInfo->UserLength) ) )
            {
                    pAuthInfo->Domain = emptyStringAorW;
                    pAuthInfo->DomainLength = 0;
                    fNullDomainRetryWarranted = TRUE;
                    DPRINT(0, "NULL domain for name with '@' in it\n");
            }
        }

DsBindRetry:

        dwErr = NO_ERROR;
        hRpc = NULL;
        pBindingAddress = NULL;
        flags = ( DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME );
        hDrs = NULL;
        pServerExtensions = NULL;

        // Sanity check arguments.

        if ( NULL == phDS )
        {
            return(ERROR_INVALID_PARAMETER);
        }

        *phDS = NULL;

        if ( NULL != DomainControllerName )
        {
            pBindingAddress = DomainControllerName;
        }
        else
        {
            // An LPC binding will only succeed if the NetBios name
            // of this computer is used. So don't attempt an LPC binding
            // with the dns name returned by DsGetDcName, it will just fail.
            fUseLPC = FALSE;

            // Find a DC to talk to.

            if ( NULL == DnsDomainName )
            {
                flags |= DS_GC_SERVER_REQUIRED;
            }

            if ( 1 == cUnavailableRetries )
            {
                flags |= DS_FORCE_REDISCOVERY;
            }

            //
            // Don't bother retrying DsGetDcName() if the LPC
            // binding failed. DsGetDcName() would likely just
            // return the same info. Yes, I know that setting
            // fUseLPC to false above makes this check unnecessary.
            // But, if the LPC binding problem is ever fixed...
            //
            if (NULL == pDcInfo)
            {
                RpcTryExcept
                {
                    DPRINT(0, "DsGetDcNameW:\n");
                    DPRINT1(0, "    flags        : %08x\n", flags);
                    DPRINT1(0, "    ComputerName : %ws\n", NULL);
                    DPRINT1(0, "    DnsDomainName: %ws\n", DnsDomainName);
                    dwErr = DsGetDcNameW(
                                    NULL,                       // computer name
                                    DnsDomainName,              // DNS domain name
                                    NULL,                       // domain guid
                                    NULL,                       // site guid
                                    flags,
                                    &pDcInfo);
                }
                RpcExcept(1)
                {
                    dwErr = RpcExceptionCode();
                }
                RpcEndExcept;

                DPRINT1(0, "DsGetDcNameW ==> 0x%x\n", dwErr);

                if ( NO_ERROR != dwErr )
                {
                    return(dwErr);
                }
            }
            pBindingAddress = pDcInfo->DomainControllerName;
        }

        DPRINT(0, "NtdsapiGetBinding:\n");
        DPRINT1(0, "    pBindingAddress: %ws\n", pBindingAddress);
        DPRINT1(0, "    fUseLPC        : %d\n", fUseLPC);
        dwErr = NtdsapiGetBinding(pBindingAddress, fUseLPC, &hRpc, _drsuapi_ClientIfHandle);
        DPRINT1(0, "NtdsapiGetBinding ==> 0x%x\n", dwErr);

        if ( 0 == dwErr )
        {
            if ( NULL != hRpc )
            {
                if ( fUseLPC )
                {
                    // LPC is always RPC_C_AUTHN_WINNT.  Don't bother with
                    // SPN mutual auth against older DCs.

                    AuthnSvc = RPC_C_AUTHN_WINNT;
                }
                else
                {
                    // Sometimes, it helps to force kerberos when debugging
                    // AuthnSvc = RPC_C_AUTHN_GSS_KERBEROS;
                    AuthnSvc = RPC_C_AUTHN_GSS_NEGOTIATE;
                }

                ImpersonationType = RPC_C_IMP_LEVEL_DELEGATE;
ImpersonateRetry:
                // Make sure to pass caller's original DomainControllerName
                // and DnsDomainName - not something we derived else we are
                // circumventing caller's control of mutual authentication.
                dwErr = SetUpMutualAuthAndEncryption(
                                        hRpc,
                                        DomainControllerName,
                                        DnsDomainName,
                                        pDcInfo,
                                        AuthnSvc,
                                        RPC_C_PROTECT_LEVEL_PKT_PRIVACY,
                                        AuthIdentity,
                                        ServicePrincipalName,
                                        ImpersonationType);
                if ( RPC_S_OK == dwErr )
                {

                    RpcTryExcept
                    {
                        dwErr = _IDL_DRSBind(
                                        hRpc,
                                        &guid,
                                        (DRS_EXTENSIONS *) &ClientExtensions,
                                        &pServerExtensions,
                                        &hDrs);
                        DPRINT1(0, "IDL_DRSBind ==> 0x%x\n", dwErr);
                        MAP_SECURITY_PACKAGE_ERROR( dwErr );
                        DPRINT1(0, "IDL_DRSBind ==> (mapped) 0x%x\n", dwErr);
                    }
                    RpcExcept(1)
                    {
                        dwErr = RpcExceptionCode();
                        DPRINT1(0, "IDL_DRSBind exception ==> 0x%x\n", dwErr);
                        MAP_SECURITY_PACKAGE_ERROR( dwErr );
                        DPRINT1(0, "IDL_DRSBind exception ==> (mapped) 0x%x\n", dwErr);
                    }
                    RpcEndExcept;

                    // DBG only
                    DPRINT_RPC_EXTENDED_ERROR(dwErr);
                }
                // The target DC doesn't support delegation; retry with
                // simple impersonation. WARN: DsAddSidHistory may fail
                // with ACCESS_DENIED when using this binding-with-impersonation
                // if the caller passes in NULL creds. NULL creds tells
                // DsAddSidHistory to use the caller's creds. DsAddSidHistory
                // then fails because the DstDc is unable to delegate the
                // caller's creds to the SrcDc because IMPERSONATE is
                // used instead of DELEGATE in this binding. However, the
                // call succeeds if the client is running on the DstDc
                // and the DomainControllerName is the NetBIOS name of the
                // DstDc (forces LRPC). Alternatively, Delegation could
                // be enabled at the DstDc.
                if (   SEC_E_SECURITY_QOS_FAILED == dwErr
                    && RPC_C_IMP_LEVEL_DELEGATE == ImpersonationType) {
                    ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
                    goto ImpersonateRetry;
                }

                RpcBindingFree(&hRpc);
            }
            else
            {
                dwErr = RPC_S_NO_BINDINGS;
            }
        }

        if ( !dwErr )
        {
            *phDS = LocalAlloc(LPTR,
                               sizeof(BindState) +
                               sizeof(WCHAR) * (wcslen(pBindingAddress) + 1));

            if ( NULL == *phDS )
            {
                if ( NULL != pServerExtensions )
                {
                    MIDL_user_free(pServerExtensions);
                }

                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                memset(*phDS, 0, sizeof(BindState));
                strcpy(((BindState *) *phDS)->signature, NTDSAPI_SIGNATURE);
                ((BindState *) *phDS)->hDrs = hDrs;
                ((BindState *) *phDS)->pServerExtensions = pServerExtensions;
                wcscpy(((BindState *) *phDS)->bindAddr, pBindingAddress);

            }
        }

        DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsBind]"));
        DSLOG((0,"[SV=%ws][DN=%ws][PA=%s][ST=%u][ET=%u][ER=%u][-]\n",
               DomainControllerName
                    ? DomainControllerName
                    : L"NULL",
               DnsDomainName
                    ? DnsDomainName
                    : L"NULL",
               pBindingAddress, startTime, GetTickCount(), dwErr))

        // Test for LPC failure retry.
        if ( dwErr && fUseLPC  )
        {
            DPRINT(0, "Retrying without LPC\n");
            fUseLPC = FALSE;
            goto DsBindRetry;
        }

        if ( NULL != pDcInfo )
        {
            NetApiBufferFree(pDcInfo);
            pDcInfo = NULL;
        }

        // Force rediscovery if we found the server for caller, the server
        // was obviously unavailable, and its our first time through.

        if (    (NULL == DomainControllerName)
             && (0 == cUnavailableRetries)
             && (IsServerUnavailableError(dwErr)) )
        {
            DPRINT(0, "Retrying DsGetDcName with DS_FORCE_REDISCOVERY\n");
            cUnavailableRetries++;
            goto DsBindRetry;
        }

        // Test for NULL domain handling conditions.
        if ( fNullDomainRetryWarranted )
        {
            // We're going to retry or return to caller.  Either way,
            // we need to restore the NULL domain pointer.
            pAuthInfo->Domain = NULL;

            if (    (0 == cNullDomainRetries++)
                 && (ERROR_ACCESS_DENIED == dwErr)
                 && (pAuthInfo->UserLength <= 20) )
            {
                DPRINT(0, "Retrying with NULL domain\n");
                goto DsBindRetry;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        dwErr = GetExceptionCode();
        DPRINT1(0, "DsBindWithSpnW() Exception ==> %08x\n", dwErr);
        dwErr = ERROR_INVALID_PARAMETER;
    }

    //
    // CLEANUP
    //
    __try
    {
        if ( NULL != pDcInfo )
        {
            NetApiBufferFree(pDcInfo);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
    return(dwErr);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsBindWithSpnA                                                       //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsBindWithSpnA(
    LPCSTR  DomainControllerName,
    LPCSTR  DnsDomainName,
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    LPCSTR  ServicePrincipalName,
    HANDLE  *phDS
    )

/*++

Routine Description:

    Starts an RPC session with a particluar DC.  See ntdsapi.h for
    description of DomainControllerName and DnsDomainName arguments.

    Bind is performed using supplied credentials.

Arguments:

    DomainControllerName - Same field as in DOMAIN_CONTROLLER_INFO.

    DnsDomainName - Dotted DNS name for a domain.

    AuthIdentity - Credentials to use, or NULL

    ServicePrincipalName - SPN to use during mutual auth or NULL.

    phDS - Pointer to HANDLE which is filled in with BindState address
        on success.

Return Value:

    0 on success.  Miscellaneous RPC and DsGetDcName errors otherwise.

--*/
{
    DWORD           dwErr = NO_ERROR;
    WCHAR           *pwszAddress = NULL;
    WCHAR           *pwszDomain = NULL;
    WCHAR           *pwszSpn = NULL;
    int             cChar;

    __try
    {
        // Sanity check arguments.

        if ( NULL == phDS )
        {
            return(ERROR_INVALID_PARAMETER);
        }

        *phDS = NULL;

        if ( NULL != DomainControllerName )
        {
            cChar = MultiByteToWideChar(
                                CP_ACP,
                                MB_PRECOMPOSED,
                                DomainControllerName,
                                -1,
                                NULL,
                                0);

            if ( 0 == cChar )
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }

            pwszAddress = (WCHAR *)
                            LocalAlloc(LPTR, sizeof(WCHAR) * (cChar + 1));

            if ( NULL == pwszAddress )
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            if ( FALSE == MultiByteToWideChar(
                                CP_ACP,
                                MB_PRECOMPOSED,
                                DomainControllerName,
                                -1,
                                pwszAddress,
                                cChar + 1) )
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }

        if ( NULL != DnsDomainName )
        {
            cChar = MultiByteToWideChar(
                                CP_ACP,
                                MB_PRECOMPOSED,
                                DnsDomainName,
                                -1,
                                NULL,
                                0);

            if ( 0 == cChar )
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }

            pwszDomain = (WCHAR *)
                            LocalAlloc(LPTR, sizeof(WCHAR) * (cChar + 1));

            if ( NULL == pwszDomain )
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            if ( FALSE == MultiByteToWideChar(
                                CP_ACP,
                                MB_PRECOMPOSED,
                                DnsDomainName,
                                -1,
                                pwszDomain,
                                cChar + 1) )
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }

        if ( NULL != ServicePrincipalName )
        {
            cChar = MultiByteToWideChar(
                                CP_ACP,
                                MB_PRECOMPOSED,
                                ServicePrincipalName,
                                -1,
                                NULL,
                                0);

            if ( 0 == cChar )
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }

            pwszSpn = (WCHAR *)
                            LocalAlloc(LPTR, sizeof(WCHAR) * (cChar + 1));

            if ( NULL == pwszSpn )
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            if ( FALSE == MultiByteToWideChar(
                                CP_ACP,
                                MB_PRECOMPOSED,
                                ServicePrincipalName,
                                -1,
                                pwszSpn,
                                cChar + 1) )
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }

        dwErr = DsBindWithSpnW(
                    pwszAddress,
                    pwszDomain,
                    AuthIdentity,
                    pwszSpn,
                    phDS);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }

Cleanup:

    if ( NULL != pwszAddress )
    {
        LocalFree(pwszAddress);
    }

    if ( NULL != pwszDomain )
    {
        LocalFree(pwszDomain);
    }

    if ( NULL != pwszSpn )
    {
        LocalFree(pwszSpn);
    }

    return(dwErr);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsBindWithCredW                                                      //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsBindWithCredW(
    IN  LPCWSTR DomainControllerName,
    IN  LPCWSTR DnsDomainName,
    IN  RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    OUT HANDLE  *phDS
    )
{
    return(DsBindWithSpnW(DomainControllerName, DnsDomainName,
                          AuthIdentity, NULL, phDS));
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsBindWithCredA                                                      //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsBindWithCredA(
    LPCSTR  DomainControllerName,
    LPCSTR  DnsDomainName,
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    HANDLE  *phDS
    )
{
    return(DsBindWithSpnA(DomainControllerName, DnsDomainName,
                          AuthIdentity, NULL, phDS));
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsUnBindW                                                            //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsUnBindW(
    HANDLE  *phDS
    )

/*++

Routine Description:

    Ends an RPC session with the DS.

Arguments:

    phDS - pointer to BindState returned by DsBind(A/W).

Return Value:

    NO_ERROR

--*/

{
    BindState *pState = NULL;

#if DBG
    __try
    {
        // Catch all those people passing a handle instead of
        // pointer to handle.

        if ( !strncmp(((BindState *) phDS)->signature,
                      NTDSAPI_SIGNATURE,
                      strlen(NTDSAPI_SIGNATURE) + 1) )
        {
#ifndef WIN95
            DbgPrint("Process 0x%x passing handle, not &handle to DsUnBind\n",
                     GetCurrentProcessId());
#else
            NULL;
#endif
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        NULL;
    }
#endif

    __try
    {
        pState = (BindState *) *phDS;

        DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsUnbind]"));
        DSLOG((0,"[PA=%s][-]\n", pState->bindAddr))

        if ( NULL != pState )
        {
            if ( NULL != pState->pServerExtensions )
            {
                MIDL_user_free(pState->pServerExtensions);
            }

            __try
            {
                // If the server may not be reachable, don't bother
                // attempting the unbind at the server. An unreachable
                // server may take many 10's of seconds to timeout
                // and we wouldn't want to punish correctly behaving
                // apps that are attempting an unbind after a failing
                // server call; eg, DsCrackNames.
                //
                // The server-side RPC will eventually issue a
                // callback to our server code that will effectivly
                // unbind at the server.
                if (!pState->bServerNotReachable) {
                    _IDL_DRSUnbind(&pState->hDrs);
                    pState->hDrs = NULL;
                }
            }
            __finally
            {
                if ( pState->hDrs && (* (VOID **) pState->hDrs) )
                {
                    RpcSsDestroyClientContext(&pState->hDrs);
                }

                LocalFree(pState);
            }
            *phDS = NULL;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        NULL;
    }

    return(NO_ERROR);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsUnBindA                                                            //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsUnBindA(
    HANDLE  *phDS
    )

/*++

Routine Description:

    Ends an RPC session with the DS.

Arguments:

    phDS - pointer to BindState returned by DsBind(A/W).

Return Value:

    NO_ERROR

--*/

{
    return(DsUnBindW(phDS));
}


NTDSAPI
DWORD
WINAPI
DsMakePasswordCredentialsW(
    LPCWSTR User,
    LPCWSTR Domain,
    LPCWSTR Password,
    RPC_AUTH_IDENTITY_HANDLE *pAuthIdentity
    )

/*++

Routine Description:

Create a credential structure for use of DsBindWithCred.

A credential structure can apparently self-describe either Ascii or Unicode.
For simplicity, we only create the Unicode version.

Arguments:

    User -
    Domain -
    Password -
    ppAuthIdentity - pointer to pointer, to receive pointer to cred

Return Value:

    WINAPI -

--*/

{
    DWORD status;
    PSEC_WINNT_AUTH_IDENTITY_W pCred = NULL;

    // Validate
    if (pAuthIdentity == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    // User wanted NULL credentials
    if ( (User == NULL) && (Domain == NULL) && (Password == NULL) ) {
        *pAuthIdentity = NULL;
        return ERROR_SUCCESS;
    }

    // Otherwise, must have supplied a username
    if (User == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate the credential block

    // Result is zero'd, which simplifies cleanup in later failures
    pCred = LocalAlloc( LPTR, sizeof( SEC_WINNT_AUTH_IDENTITY_W ) );
    if (pCred == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // User parameter
    pCred->UserLength = wcslen( User );
    pCred->User = (LPWSTR) LocalAlloc( LPTR,
                               ( pCred->UserLength + 1 ) * sizeof(WCHAR) );

    if (pCred->User == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    wcscpy( pCred->User, User );

    // Domain parameter
    if (Domain) {
        pCred->DomainLength = wcslen( Domain );
        pCred->Domain = (LPWSTR) LocalAlloc( LPTR,
                                   ( pCred->DomainLength + 1 ) * sizeof(WCHAR) );

        if (pCred->Domain == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        wcscpy( pCred->Domain, Domain );
    }

    // Password parameter
    if (Password) {
        pCred->PasswordLength = wcslen( Password );
        pCred->Password = (LPWSTR) LocalAlloc( LPTR,
                                   ( pCred->PasswordLength + 1 ) * sizeof(WCHAR) );

        if (pCred->Password == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        wcscpy( pCred->Password, Password );
    }

    // Flags
    pCred->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    *pAuthIdentity = (RPC_AUTH_IDENTITY_HANDLE) pCred;
    pCred = NULL; // Don't cleanup since we've given it to the user

    status = ERROR_SUCCESS;

cleanup:

    if (pCred != NULL) {
        // Rely on fact that this routine can clean up partial structures
        DsFreePasswordCredentials( (RPC_AUTH_IDENTITY_HANDLE) pCred );
    }

    return status;
} /* DsMakePasswordCredentialsW */


NTDSAPI
DWORD
WINAPI
DsMakePasswordCredentialsA(
    LPCSTR User,
    LPCSTR Domain,
    LPCSTR Password,
    RPC_AUTH_IDENTITY_HANDLE *pAuthIdentity
    )

/*++

Routine Description:

    Ascii wrapper for DsMakeCredentials. Convert all parameters to Wide
    and call DsMakeCredentialsW.  See above.

Arguments:

    User -
    Domain -
    Password -
    ppAuthIdentity -

Return Value:

    WINAPI -

--*/

{
    DWORD status;
    LPWSTR userW = NULL, domainW = NULL, passwordW = NULL;

    status = AllocConvertWide( User, &userW );
    if (status != ERROR_SUCCESS) {
        return status;
    }

    status = AllocConvertWide( Domain, &domainW );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    status = AllocConvertWide( Password, &passwordW );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // Do it!
    status = DsMakePasswordCredentialsW(
        userW, domainW, passwordW, pAuthIdentity );

cleanup:
    if (userW != NULL) {
        LocalFree( userW );
    }
    if (domainW != NULL) {
        LocalFree( domainW );
    }
    if (passwordW != NULL) {
        LocalFree( passwordW );
    }

    return status;
} /* DsMakeCredentialsA */


NTDSAPI
VOID
WINAPI
DsFreePasswordCredentials(
    RPC_AUTH_IDENTITY_HANDLE pAuthIdentity
    )

/*++

Routine Description:

   Free a credential structure.
   This routine can clean up partially allocated structures.

Arguments:

    pAuthIdentity -

Return Value:

    WINAPI -

--*/

{
    PSEC_WINNT_AUTH_IDENTITY_W pCred =
        (PSEC_WINNT_AUTH_IDENTITY_W) pAuthIdentity;

    if (pCred == NULL) {
        return;
    }

    if (pCred->User) {
        LocalFree( pCred->User );
    }
    if (pCred->Domain) {
        LocalFree( pCred->Domain );
    }
    if (pCred->Password) {
        LocalFree( pCred->Password );
    }

    LocalFree( pCred );
} /* DsFreeCredentials */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsapi\dsdebug.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    dsdebug.h

Abstract:

    debug definitions inside ntdsapi.dll

Author:

    Billy Fuller (billyf) 14-May-1999

Environment:

    User Mode - Win32

Notes:
    The debug layer is limited to CHK builds.

--*/

#ifndef __DS_DEBUG_H__
#define __DS_DEBUG_H__

//
// DEBUG ONLY
//
#if DBG

//
// DLL Initialization/Termination
//
#define INIT_DS_DEBUG()         InitDsDebug()
#define TERMINATE_DS_DEBUG()    TerminateDsDebug()

//
// Global debug info
//
extern DWORD gdwNtDsApiLevel;
extern DWORD gdwNtDsApiFlags;

//
// Flags
//
#define NTDSAPI_FLAGS_PRINT (0x00000001)
#define NTDSAPI_FLAGS_SPEW  (0x00000002)
#define NTDSAPI_FLAGS_LOG   (0x00000004)

#define NTDSAPI_FLAGS_ANY_OUT   (NTDSAPI_FLAGS_PRINT | \
                                 NTDSAPI_FLAGS_SPEW  | \
                                 NTDSAPI_FLAGS_LOG)

// print rpc extended error. Enable extended rpc errors by
//
#define DPRINT_RPC_EXTENDED_ERROR(_dwErr_) \
    DsDebugPrintRpcExtendedError(_dwErr_)

//
// Optional, guarded output
//
#define DPRINT(_Level, _Format) \
    DsDebugPrint(_Level, (PUCHAR)_Format, DEBSUB, __LINE__)

#define DPRINT1(_Level, _Format, _p1) \
    DsDebugPrint(_Level, (PUCHAR)_Format, DEBSUB, __LINE__, _p1)

#define DPRINT2(_Level, _Format, _p1, _p2) \
    DsDebugPrint(_Level, (PUCHAR)_Format, DEBSUB, __LINE__, _p1, _p2)

#define DPRINT3(_Level, _Format, _p1, _p2, _p3) \
    DsDebugPrint(_Level, (PUCHAR)_Format, DEBSUB, __LINE__, _p1, _p2, _p3)

#define DPRINT4(_Level, _Format, _p1, _p2, _p3, _p4) \
    DsDebugPrint(_Level, (PUCHAR)_Format, DEBSUB, __LINE__, _p1, _p2, _p3, _p4)

#define DPRINT5(_Level, _Format, _p1, _p2, _p3, _p4, _p5) \
    DsDebugPrint(_Level, (PUCHAR)_Format, DEBSUB, __LINE__, _p1, _p2, _p3, _p4, _p5)

#define DPRINT6(_Level, _Format, _p1, _p2, _p3, _p4, _p5, _p6) \
    DsDebugPrint(_Level, (PUCHAR)_Format, DEBSUB, __LINE__, _p1, _p2, _p3, _p4, _p5, _p6)

#define DPRINT7(_Level, _Format, _p1, _p2, _p3, _p4, _p5, _p6, _p7) \
    DsDebugPrint(_Level, (PUCHAR)_Format, DEBSUB, __LINE__, _p1, _p2, _p3, _p4, _p5, _p6, _p7)
    
//
// Forwards
//
VOID
InitDsDebug(
     VOID
     );
VOID
TerminateDsDebug(
     VOID
     );
VOID
DsDebugPrintRpcExtendedError(
    IN _dwErr_
    );
VOID
DsDebugPrint(
    IN DWORD    Level,
    IN PUCHAR   Format,
    IN PCHAR    DebSub,
    IN UINT     LineNo,
    IN ...
    );
#else DBG

//
// DEBUG NOT ENABLED!
//
#define INIT_DS_DEBUG()
#define TERMINATE_DS_DEBUG()
#define DPRINT_RPC_EXTENDED_ERROR(_dwErr_)
#define DPRINT(_Level, _Format)
#define DPRINT1(_Level, _Format, _p1)
#define DPRINT2(_Level, _Format, _p1, _p2)
#define DPRINT3(_Level, _Format, _p1, _p2, _p3)
#define DPRINT4(_Level, _Format, _p1, _p2, _p3, _p4)
#define DPRINT5(_Level, _Format, _p1, _p2, _p3, _p4, _p5)
#define DPRINT6(_Level, _Format, _p1, _p2, _p3, _p4, _p5, _p6)
#define DPRINT7(_Level, _Format, _p1, _p2, _p3, _p4, _p5, _p6, _p7)

#endif DBG

#endif __DS_DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsapi\cracknam.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cracknam.c

Abstract:

    Implementation of DsCrackNames API and helper functions.

Author:

    DaveStr     09-Aug-96

Environment:

    User Mode - Win32

Revision History:

    DaveStr     20-Oct-97
        Beta2 changes - UPN, DS_NAME_FLAG_SYNTACTICAL_ONLY, move to drs.idl.

--*/

#define _NTDSAPI_           // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <malloc.h>         // alloca()
#include <crt\excpt.h>      // EXCEPTION_EXECUTE_HANDLER
#include <crt\stdlib.h>     // wcstol, wcstoul
#include <dsgetdc.h>        // DsGetDcName()
#include <rpc.h>            // RPC defines
#include <rpcndr.h>         // RPC defines
#include <rpcbind.h>        // GetBindingInfo(), etc.
#include <drs_w.h>          // wire function prototypes
#include <bind.h>           // BindState
#include <ntdsa.h>          // GetRDNInfo
#include <scache.h>         // req'd for mdlocal.h
#include <dbglobal.h>       // req'd for mdlocal.h
#include <mdglobal.h>       // req'd for mdlocal.h
#include <mdlocal.h>        // CountNameParts
#include <attids.h>         // ATT_DOMAIN_COMPONENT
#include <ntdsapip.h>       // private ntdsapi defines
#include <sddl.h>           // SDDL_* definitions
#include <dststlog.h>
#include <dsutil.h>         // MAP_SECURITY_PACKAGE_ERROR

typedef struct _RdnValue
{
    WCHAR           val[MAX_RDN_SIZE];
    ULONG           len;

} RdnValue;

typedef DWORD (*SyntacticCrackFunc)(
    DS_NAME_FLAGS           flags,          // in
    DS_NAME_FORMAT          formatOffered,  // in
    DS_NAME_FORMAT          formatDesired,  // in
    LPCWSTR                 pName,          // in
    DS_NAME_RESULT_ITEMW    *pItem,         // out
    WCHAR                   **ppLastSlash); // out
    
BOOL
LocalConvertStringSidToSid (
    IN  PWSTR       StringSid,
    OUT PSID       *Sid,
    OUT PWSTR      *End);

BOOL
IsFPO(
    RdnValue        *pRdn,
    ATTRTYP         type);

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// NumCanonicalDelimiter                                                //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD 
NumCanonicalDelimiter(
    LPCWSTR     pName           // in
    )
/*++

    Returns the count of DS_CANONICAL_NAME delimiters (L'/') in the input.

--*/
{
    WCHAR   *p;
    DWORD   cDelim = 0;

    for (p = (WCHAR *)pName; *p; ++p)
    {
        if ( L'/' == *p || L'\\' == *p)
        {
            cDelim++;
        }
    }

    return(cDelim);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// CanonicalRdnConcat                                                   //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID 
CanonicalRdnConcat(
    WCHAR       *pwszDst,   // in
    RdnValue    *pRdnVal    // out
    )
/*++

Routine Description:

    Concatenates an RdnValue to a DS_CANONICAL_NAME escaping embedded '/'
    characters as "\/" if required.  The server side unescapes these when
    cracking from DS_CANONICAL_NAME.

Arguments:

    pwszDst - NULL terminated destination string.

    pRdnVal - RdnValue to concatenate.

Return Value:

    None.

--*/
{
    DWORD   i;
    
    // Advance to end of pwszDst;

    pwszDst += wcslen(pwszDst);

    for ( i = 0; i < pRdnVal->len; i++ )
    {
        if ( L'/' == pRdnVal->val[i] || L'\\' == pRdnVal->val[i])
        {
            *pwszDst++ = L'\\';
        }

        *pwszDst++ = pRdnVal->val[i];
    }
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// SyntacticFqdnItemToCanonicalW                                        //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD 
SyntacticFqdnItemToCanonicalW(
    DS_NAME_FLAGS           flags,          // in
    DS_NAME_FORMAT          formatOffered,  // in
    DS_NAME_FORMAT          formatDesired,  // in
    LPCWSTR                 pName,          // in
    DS_NAME_RESULT_ITEMW    *pItem,         // out
    WCHAR                   **ppLastSlash   // out
    )
/*++

Routine Description:

    Parses a purported DN and syntactically converts it into
    DS_CANONICAL_NAME format.

    See also: 

    ftp://ds.internic.net/internet-drafts/draft-ietf-asid-ldap-domains-02.txt

Arguments:

    flags - flags as defined in ntdsapi.h

    formatOffered - identifies the DS_NAME_FORMAT of input names.

    formatDesired - identifies DS_NAME_FORMAT of output names.

    pName - purported FQDN input name.

    pItem - pointer to output data structure.

    ppLastSlash - pointer to pointer to location of last '/' in output name.

Return Value:

    NO_ERROR                        - success
    ERROR_INVALID_PARAMETER         - invalid parameter
    ERROR_NOT_ENOUGH_MEMORY         - allocation error

    Individual name mapping errors are reported in
    (*ppResult)->rItems[i].status.

--*/

{
    int         i;
    DWORD       cBytes, cBytes1;
    DWORD       dwErr;
    int         cParts;
    int         firstDomainPart = 0;   //initialized to avoid C4701
    int         cDomainParts;
    int         cDomainRelativeParts;
    RdnValue    *pTmpRdn;
    RdnValue    *rRdnValues;
    ATTRTYP     type;
    DWORD       lastType;
    DWORD       len;
    DSNAME      *pTmp;
    DSNAME      *pDSName;
    DSNAME      *scratch;

    // Allocate some DSNAME buffers.

    cBytes = (DWORD)DSNameSizeFromLen(wcslen(pName));
    pDSName = (DSNAME *) alloca(cBytes);
    scratch = (DSNAME *) alloca(cBytes);

    // Init scratch buffer with purported FQDN.

    memset(pDSName, 0, cBytes);
    pDSName->structLen = cBytes;
    pDSName->NameLen = wcslen(pName);
    wcscpy(pDSName->StringName, pName);

    // Sanity check the purported FQDN.

    if ( 0 != CountNameParts(pDSName, (unsigned *) &cParts) )
    {
        pItem->status = DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING;
        return(NO_ERROR);
    }

    // Allocate return buffers.  We're conservative and say that
    // output name can't be more than the length in bytes of the DSNAME
    // which holds the input name plus N extra characters for escaped
    // canonical delimiters.

    pItem->pDomain = (WCHAR *) MIDL_user_allocate(cBytes);
    cBytes1 = cBytes + (sizeof(WCHAR) * NumCanonicalDelimiter(pName));
    pItem->pName = (WCHAR *) MIDL_user_allocate(cBytes1);

    if ( ( NULL == pItem->pDomain ) || ( NULL == pItem->pName ) )
    {
        // Caller is expected to clean up allocations on error.
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    memset(pItem->pDomain, 0, cBytes);
    memset(pItem->pName, 0, cBytes1);

    // Strip off the intra-domain name components leaf to root
    // putting them in a linked list. 

    lastType = ATT_ORGANIZATION_NAME;  // anything but ATT_DOMAIN_COMPONENT
    cDomainParts = 0;
    cDomainRelativeParts = 0;
    rRdnValues = (RdnValue *) alloca(cParts * sizeof(RdnValue));

    for ( i = 0; i < cParts; i++ )
    {
        pTmpRdn = &rRdnValues[i];

        dwErr = GetRDNInfoExternal(pDSName, pTmpRdn->val, &pTmpRdn->len, &type);

        // Ignore unknown rdntypes. We really only care about a
        // few well-known types that allow us to distinguish the
        // domain part of the canonical name. All other RDNs are
        // non-domain parts.
        if ((dwErr == ERROR_DS_NAME_TYPE_UNKNOWN)
            && (0 == (dwErr = GetRDNInfoExternal(pDSName, pTmpRdn->val, &pTmpRdn->len, NULL)))) {
            type = -1;
        }

        if (    (0 != dwErr)
             || (    (0 == i) 
                  && !(DS_NAME_FLAG_PRIVATE_PURE_SYNTACTIC & flags)
                  && IsFPO(pTmpRdn, type) ) )
        {
            pItem->status = DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING;
            return(NO_ERROR);
        }

        // Following logic needs to handle two special cases:
        //
        // 1) Case of old style DC= name with O=Internet at the end.
        //    Eg: CN=xxx,OU=yyy,DC=foo,DC=bar,DC=com,O=internet
        // 
        // 2) Case of object which has DC= naming within the domain, but
        //    separated from domain root by at least one non-DC= component.
        //    Eg: DC=xxx,OU=yyy,DC=foo,DC=bar,DC=com

        if (    ( ATT_ORGANIZATION_NAME == type )
             && ( i == (cParts - 1) )
             && ( cDomainParts >= 1 )
             && ( 8 == pTmpRdn->len )
             // To avoid pulling in more 'C' runtimes we just compare
             // the eight characters directly.
             && ( (L'i' == pTmpRdn->val[0]) || (L'I' == pTmpRdn->val[0]) )
             && ( (L'n' == pTmpRdn->val[1]) || (L'N' == pTmpRdn->val[1]) )
             && ( (L't' == pTmpRdn->val[2]) || (L'T' == pTmpRdn->val[2]) )
             && ( (L'e' == pTmpRdn->val[3]) || (L'E' == pTmpRdn->val[3]) )
             && ( (L'r' == pTmpRdn->val[4]) || (L'R' == pTmpRdn->val[4]) )
             && ( (L'n' == pTmpRdn->val[5]) || (L'N' == pTmpRdn->val[5]) )
             && ( (L'e' == pTmpRdn->val[6]) || (L'E' == pTmpRdn->val[6]) )
             && ( (L't' == pTmpRdn->val[7]) || (L'T' == pTmpRdn->val[7]) ) )
        {
            // This is an old style DC= name with O=Internet on the
            // end - just skip this component and exit the loop.

            cParts--;
            break;
        }
        else if (    (ATT_DOMAIN_COMPONENT == type)
                  && (ATT_DOMAIN_COMPONENT != lastType) )
        {
            // Start of a new DC= subsequence.
            firstDomainPart = i;
            cDomainParts = 1;
        }
        else if (    (ATT_DOMAIN_COMPONENT == type)
                  && (ATT_DOMAIN_COMPONENT == lastType) )
        {
            // In the middle of a DC= subsequence.
            cDomainParts++;
        }
        else if (    (ATT_DOMAIN_COMPONENT != type)
                  && (ATT_DOMAIN_COMPONENT == lastType) )
        {
            // End of a DC= subsequence - assign DC= subsequence counts
            // to the domain relative part of the name.
            cDomainRelativeParts += cDomainParts;
            cDomainParts = 0;
            cDomainRelativeParts++;
        }
        else
        {
            // In the middle of a non-DC= subsequence.
            cDomainRelativeParts++;
        }

        lastType = type;

        // Trim the DSNAME by one so we can call GetRDNInfo on the next piece
        // on next pass through the loop.

        dwErr = TrimDSNameBy(pDSName, 1, scratch);

        if ( 0 != dwErr )
        {
            pItem->status = DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING;
            return(NO_ERROR);
        }

        pTmp = pDSName;
        pDSName = scratch;
        scratch = pTmp;
    }

    if ( 0 == cDomainParts )
    {
        // No DC= component in the purported FQDN - therefore can't parse.

        pItem->status = DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING;
        return(NO_ERROR);
    }

    // All components of the DN are now in rRdnValues[] in the following
    // order (for example): DC=xxx,OU=yyy,DC=foo,DC=bar,DC=com
    // Items firstDomainPart through cParts-1 represent the DNS domain name
    // in desired leaf to root order.  Items firstDomainPart-1 down to 0
    // represent the domain relative name components in root to leaf order.

    for ( i = firstDomainPart; i < cParts; i++ )
    {
        if ( i > firstDomainPart )
        {
            wcscat(pItem->pDomain, L".");
            wcscat(pItem->pName, L".");
        }

        wcsncat(pItem->pDomain, rRdnValues[i].val, rRdnValues[i].len);
        wcsncat(pItem->pName, rRdnValues[i].val, rRdnValues[i].len);
    }

    // Remember that we always want a '/' after the DNS domain name, even if
    // there are no domain relative components.

    if ( 0 == cDomainRelativeParts )
    {
        *ppLastSlash = &(pItem->pName[wcslen(pItem->pName)]);
        wcscat(pItem->pName, L"/");
        pItem->status = DS_NAME_NO_ERROR;
        return(NO_ERROR);
    }

    // Now the domain relative parts.

    for ( i = (firstDomainPart-1); i >= 0; i-- )
    {
        if ( 0 == i )
        {
            *ppLastSlash = &(pItem->pName[wcslen(pItem->pName)]);
        }

        wcscat(pItem->pName, L"/");
        CanonicalRdnConcat(pItem->pName, &rRdnValues[i]);
    }

    pItem->status = DS_NAME_NO_ERROR;

    return(NO_ERROR);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// SyntacticCanonicalItemToFqdnW                                        //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD 
SyntacticCanonicalItemToFqdnW(
    DS_NAME_FLAGS           flags,          // in
    DS_NAME_FORMAT          formatOffered,  // in
    DS_NAME_FORMAT          formatDesired,  // in
    LPCWSTR                 pName,          // in
    DS_NAME_RESULT_ITEMW    *pItem,         // out
    WCHAR                   **ppLastSlash   // out
    )
/*++

Routine Description:

    Parses a purported canonical name and syntactically converts it into
    DS_FQDN_1779_NAME format.  However, we really only can do this for
    domain names in canonical form - i.e. end in '/' or '\n' in the case
    of CANONICAL_EX.

    See also: 

    ftp://ds.internic.net/internet-drafts/draft-ietf-asid-ldap-domains-02.txt

Arguments:

    flags - flags as defined in ntdsapi.h

    formatOffered - identifies the DS_NAME_FORMAT of input names.

    formatDesired - identifies DS_NAME_FORMAT of output names.

    pName - purported canonical input name.

    pItem - pointer to output data structure.

    ppLastSlash - pointer to pointer to location of last '/' in output name.
        Not used.

Return Value:

    NO_ERROR                        - success
    ERROR_INVALID_PARAMETER         - invalid parameter
    ERROR_NOT_ENOUGH_MEMORY         - allocation error

    Individual name mapping errors are reported in
    (*ppResult)->rItems[i].status.

--*/
{
    DWORD   cChar = wcslen(pName);
    DWORD   i, j, cPieces;
    DWORD   cBytesName, cBytesDomain;

    if (    // Must have at least one char followed by '/' or '\n'
            (cChar < 2)
            // Test format offered
         || (    (DS_CANONICAL_NAME != formatOffered) 
              && (DS_CANONICAL_NAME_EX != formatOffered))
            // Test format desired
         || (DS_FQDN_1779_NAME != formatDesired)
            // Regular canonical needs '/' at end
         || (    (DS_CANONICAL_NAME == formatOffered) 
              && (L'/' != pName[cChar-1]))
            // Extended canonical needs '\n' at end
         || (    (DS_CANONICAL_NAME_EX == formatOffered) 
              && (L'\n' != pName[cChar-1]))
            // Canonical name can't start with '.'
         || (L'.' == *pName)
            // Don't be fooled by escaped '/' at end - i.e. "\/"
         || ( (L'/' == pName[cChar-1] ) && (L'\\' == pName[cChar-2]) ) )
    {
        pItem->status = DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING;
        return(NO_ERROR);
    }

    // Strip trailing delimiter.

    cChar -= 1;

    // Strip trailing '.' as we don't want that in the DN.

    if ( L'.' == pName[cChar-1] )
    {
        cChar -= 1;
    }

    // Count components.

    for ( i = 1, cPieces = 1; i < cChar; i++ )
    {
        if ( L'.' == pName[i] )
        {
            cPieces += 1;
        }
    }

    // Allocate return buffers.

    cBytesDomain = (cChar + 1) * sizeof(WCHAR);
    cBytesName = (cChar + 1 + (cPieces * 4)) * sizeof(WCHAR);
    pItem->pDomain = (WCHAR *) MIDL_user_allocate(cBytesDomain);
    pItem->pName = (WCHAR *) MIDL_user_allocate(cBytesName);

    if ( ( NULL == pItem->pDomain ) || ( NULL == pItem->pName ) )
    {
        // Caller is expected to clean up allocations on error.
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    // Construct return data.

    memcpy(pItem->pDomain, pName, cBytesDomain);
    pItem->pDomain[(cBytesDomain / sizeof(WCHAR)) - 1] = L'\0';

    for ( i = 0, j = 0; i < cChar; i++ )
    {
        if ( L'.' == pName[i] )
        {
            pItem->pName[j++] = L',';
        }

        if ( (0 == i) || (L'.' == pName[i]) )
        {
            pItem->pName[j++] = L'D';
            pItem->pName[j++] = L'C';
            pItem->pName[j++] = L'=';
        }

        if ( L'.' != pName[i] )
        {
            pItem->pName[j++] = pName[i];
        }
    }

    pItem->pName[j] = L'\0';

    pItem->status = DS_NAME_NO_ERROR;
    return(NO_ERROR);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// SyntacticCrackPossible                                               //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

BOOL
SyntacticCrackPossible(
    DS_NAME_FORMAT      formatOffered,      // in
    DS_NAME_FORMAT      formatDesired,      // in
    SyntacticCrackFunc  *pfn                // out - optional
    )
/*++

Description:

    Returns FALSE if syntactic cracking is definitely NOT possible.
    Returns TRUE if syntactic cracking might be possible - but with 
        no guarantee that it is.  In this case, also returns a function
        pointer indicating the function to use for syntactic cracking.

--*/

{
    // We can crack syntactically from CANONICAL to FQDN if the CANONICAL
    // name has only domain components.  eg: foo.bar.com/

    if (    (    (DS_CANONICAL_NAME == formatOffered)
              || (DS_CANONICAL_NAME_EX == formatOffered) )
         && (DS_FQDN_1779_NAME == formatDesired) )
    {
        if ( pfn )
        {
            *pfn = SyntacticCanonicalItemToFqdnW;
        }

        return(TRUE);
    }
    
    // We can crack syntactically from FQDN to both CANONICAL forms.
    // So return FALSE of the output format is anything other than CANONICAL
    // as we have no other combinations we can crack syntactially.
    // Make no test on input format as SyntacticFqdnItemToCanonicalW will
    // either parse the item as DS_FQDN_1779_NAME or else return 
    // DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING.

    if (    ( DS_CANONICAL_NAME != formatDesired )
         && ( DS_CANONICAL_NAME_EX != formatDesired ) )
    {
        return(FALSE);
    }

    if ( pfn )
    {
        *pfn = SyntacticFqdnItemToCanonicalW;
    }

    return(TRUE);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// SyntacticMappingW                                                    //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
SyntacticMappingW(
    DS_NAME_FLAGS       flags,              // in
    DS_NAME_FORMAT      formatOffered,      // in
    DS_NAME_FORMAT      formatDesired,      // in
    DWORD               cNames,             // in
    const LPCWSTR       *rpNames,           // in
    PDS_NAME_RESULTW    *ppResult           // out
    )
/*++

Routine Description:

    Perform a purely syntactic mapping without going on the wire.  
    Intended usage is for the UI which wishes to display "tool tips" 
    when the cursor rests on members of a list box, for example, 
    without going across the wire for each one.  This routine does a 
    syntactic mapping using various assumptions about the ubiquity 
    of DC= naming.  The only syntactic mapping supported is from 
    DS_FQDN_1779_NAME to DS_CANONICAL_NAME(_EX).

Arguments:

    flags - flags as defined in ntdsapi.h

    formatOffered - identifies the DS_NAME_FORMAT of input names.

    formatDesired - identifies DS_NAME_FORMAT of output names.

    cNames - input/output name count.

    rpNames - arry of input name WCHAR pointers.

    ppResult - pointer to pointer of DS_NAME_RESULTW block.

Return Value:

    NO_ERROR                        - success
    ERROR_INVALID_PARAMETER         - invalid parameter
    ERROR_NOT_ENOUGH_MEMORY         - allocation error

    Individual name mapping errors are reported in
    (*ppResult)->rItems[i].status.

--*/

{
    DWORD               cBytes;
    DWORD               i;
    WCHAR               *pLastSlash;
    DWORD               err;
    SyntacticCrackFunc  pSyntacticFunc;

    // Allocate and clear return data.

    cBytes = sizeof(DS_NAME_RESULTW);
    *ppResult = (PDS_NAME_RESULTW) MIDL_user_allocate(cBytes);

    if ( NULL == *ppResult )
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    memset(*ppResult, 0, cBytes);
    cBytes = cNames * sizeof(DS_NAME_RESULT_ITEMW);
    (*ppResult)->rItems = (PDS_NAME_RESULT_ITEMW) MIDL_user_allocate(cBytes);

    if ( NULL == (*ppResult)->rItems )
    {
        DsFreeNameResultW(*ppResult);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    memset((*ppResult)->rItems, 0, cBytes);

    // Initialize status for worst case.

    for ( i = 0; i < cNames; i++ )
    {
        (*ppResult)->rItems[i].status = 
                        DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING;
    }

    (*ppResult)->cItems = cNames;

    // Now that return data is allocated and initialized, bail if we
    // know a-priori that a syntactic crack is not possible.

    if ( !SyntacticCrackPossible(formatOffered, 
                                 formatDesired, 
                                 &pSyntacticFunc) )
    {
        return(NO_ERROR);
    }

    // Syntactical mapping is possible.

    for ( i = 0; i < cNames; i++ )
    {
        
        err = (*pSyntacticFunc)(
                            flags,
                            formatOffered,
                            formatDesired,
                            rpNames[i],
                            &(*ppResult)->rItems[i],
                            &pLastSlash);

        if ( NO_ERROR != err )
        {
            DsFreeNameResultW(*ppResult);
            return(err);
        }

        if (    (DS_CANONICAL_NAME_EX == formatDesired)
             && (DS_NAME_NO_ERROR == (*ppResult)->rItems[i].status) )
        {
            *pLastSlash = L'\n';
        }
    }

    return(NO_ERROR);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsCrackNamesW                                                        //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsCrackNamesW(
    HANDLE              hDS,                // in
    DS_NAME_FLAGS       flags,              // in
    DS_NAME_FORMAT      formatOffered,      // in
    DS_NAME_FORMAT      formatDesired,      // in
    DWORD               cNames,             // in
    const LPCWSTR       *rpNames,           // in
    PDS_NAME_RESULTW    *ppResult           // out
    )
/*++

Routine Description:

    Cracks a bunch of names from one format to another.  See external
    prototype and definitions in ntdsapi.h

Arguments:

    hDS - Pointer to BindState for this session.

    flags - flags as defined in ntdsapi.h

    formatOffered - identifies DS_NAME_FORMAT of input names.

    formatDesired - identifies DS_NAME_FORMAT of output names.

    cNames - input/output name count.

    rpNames - arry of input name WCHAR pointers.

    ppResult - pointer to pointer of DS_NAME_RESULTW block.

Return Value:

    NO_ERROR                        - success
    ERROR_INVALID_PARAMETER         - invalid parameter
    ERROR_NOT_ENOUGH_MEMORY         - allocation error

    Individual name mapping errors are reported in
    (*ppResult)->rItems[i].status.

--*/

{
    DWORD                   dwErr = NO_ERROR;
    DWORD                   i;
    DWORD                   cBytes;
    DRS_MSG_CRACKREQ        crackReq;
    DRS_MSG_CRACKREPLY      crackReply;
    DWORD                   dwOutVersion;
    BOOL                    fRedoAtServer = FALSE;
#if DBG
    DWORD                   startTime = GetTickCount();
#endif
    __try
    {
        // Sanity check arguments.

        if ( // Don't check anything which may be changed by server upgrade.
                (    (NULL == hDS) 
                  && !(flags & DS_NAME_FLAG_SYNTACTICAL_ONLY) )
             || (0 == cNames)
             || (NULL == rpNames)
             || (NULL == ppResult)
             || (*ppResult && FALSE)
             || (    (flags & (  DS_NAME_FLAG_EVAL_AT_DC
                               | DS_NAME_FLAG_GCVERIFY))
                  && (flags & DS_NAME_FLAG_SYNTACTICAL_ONLY) ) )
        {
            return(ERROR_INVALID_PARAMETER);
        }
    
        *ppResult = NULL;
    
        for ( i = 0; i < cNames; i++ )
        {
            if ( (NULL == rpNames[i]) ||
                 (0 == *rpNames[i]) )
            {
                return(ERROR_INVALID_PARAMETER);
            }
        }

        // Go the no-wire route if explicitly requested.

        if ( flags & DS_NAME_FLAG_SYNTACTICAL_ONLY )
        {
            dwErr = SyntacticMappingW(
                                flags,
                                formatOffered,
                                formatDesired,
                                cNames,
                                rpNames,
                                ppResult);

            goto exit;
        }

        // If the offered and desired formats might support syntactic
        // cracking, then try that by default.  However, if syntactic
        // cracking fails with DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING
        // (as might be in the case of FPOs or other unrecognized formats), 
        // then free the result and go across the wire for real.

        if (    SyntacticCrackPossible(formatOffered, formatDesired, NULL)
             && !(flags & DS_NAME_FLAG_EVAL_AT_DC) )
        {
            dwErr = SyntacticMappingW(
                                flags,
                                formatOffered,
                                formatDesired,
                                cNames,
                                rpNames,
                                ppResult);

            if ( NO_ERROR != dwErr )
            {
                goto exit;
            }

            // Check for occurrences of DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING.

            for ( i = 0; i < (*ppResult)->cItems; i++ )
            {
                if ( DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING ==
                                                (*ppResult)->rItems[i].status )
                {
                    fRedoAtServer = TRUE;
                    DsFreeNameResultW(*ppResult);
                    *ppResult = NULL;
                    break;
                }
            }

            if ( !fRedoAtServer )
            {
                goto exit;
            }
        }

        // We really need to go across the wire to crack the names.

        memset(&crackReq, 0, sizeof(crackReq));
        memset(&crackReply, 0, sizeof(crackReply));

        crackReq.V1.CodePage = GetACP();
        crackReq.V1.LocaleId = GetUserDefaultLCID();
        crackReq.V1.dwFlags = flags;
        crackReq.V1.formatOffered = formatOffered;
        crackReq.V1.formatDesired = formatDesired;
        crackReq.V1.cNames = cNames;
        crackReq.V1.rpNames = (WCHAR **) rpNames;

        RpcTryExcept
        {
            // Following call returns WIN32 errors, not DRAERR_* values.
            dwErr = _IDL_DRSCrackNames(
                            ((BindState *) hDS)->hDrs,
                            1,                              // dwInVersion
                            &crackReq,
                            &dwOutVersion,
                            &crackReply);
        }
        RpcExcept(1)
        {
            dwErr = RpcExceptionCode();
            CHECK_RPC_SERVER_NOT_REACHABLE(hDS, dwErr);
        }
        RpcEndExcept;

        if ( 0 == dwErr )
        {
            if ( 1 != dwOutVersion )
            {
                dwErr = RPC_S_INTERNAL_ERROR;
            }
            else
            {
                *ppResult = crackReply.V1.pResult;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        dwErr = RpcExceptionCode();
    }

    MAP_SECURITY_PACKAGE_ERROR( dwErr );

exit:

    if ( dwErr )
    {
        *ppResult = NULL;
    }

    // Note that in the syntactical only case, we don't have a valid hDS.
    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsCrackNames]"));
    DSLOG((0,"[PA=%ws][FL=0x%x][FO=0x%x]"
             "[FD=0x%x][PA=0x%x][PA=%ws][ST=%u][ET=%u][ER=%u][-]\n",
            (flags & DS_NAME_FLAG_SYNTACTICAL_ONLY) ? L"syntactic only"
                                        : ((BindState *) hDS)->bindAddr, 
            flags, formatOffered, formatDesired, cNames, rpNames[0], startTime,
            GetTickCount(), dwErr));
    return(dwErr);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsCrackNamesA                                                        //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsCrackNamesA(
    HANDLE              hDS,                // in
    DS_NAME_FLAGS       flags,              // in
    DS_NAME_FORMAT      formatOffered,      // in
    DS_NAME_FORMAT      formatDesired,      // in
    DWORD               cNames,             // in
    const LPCSTR        *rpNames,           // in
    PDS_NAME_RESULTA    *ppResult           // out
    )
/*++

Routine Description:
Arguments:
Return Value:

    See DsCrackNamesW.

--*/

{
    DWORD           dwErr = NO_ERROR;
    WCHAR           **rpUnicodeNames = NULL;
    DS_NAME_RESULTW *pUnicodeResult = NULL;
    DWORD           i;
    ULONG           cb, cbDomain, cbName;
    NTSTATUS        status;
    WCHAR           *unicodeBuffer = NULL;
    ULONG           unicodeBufferSize = 0;
    int             cChar;

    __try
    {
        // Sanity check arguments.

        if ( // Don't check anything which may be changed by server upgrade.
             ( (NULL == hDS) && !(flags & DS_NAME_FLAG_SYNTACTICAL_ONLY) ) ||
             (0 == cNames) ||
             (NULL == rpNames) ||
             (NULL == ppResult) ||
             (*ppResult && FALSE) )
        {
            return(ERROR_INVALID_PARAMETER);
        }

        // Convert rpNames to UNICODE.

        cb = (ULONG) (cNames * sizeof(WCHAR *));
        rpUnicodeNames = (WCHAR **) LocalAlloc(LPTR, cb);

        if ( NULL == rpUnicodeNames )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        memset(rpUnicodeNames, 0, cb);

        for ( i = 0; i < cNames; i++ )
        {
            cChar = MultiByteToWideChar(
                                CP_ACP,
                                MB_PRECOMPOSED,
                                rpNames[i],
                                -1,
                                NULL,
                                0);

            if ( 0 == cChar )
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }

            rpUnicodeNames[i] = (WCHAR *) 
                        LocalAlloc(LPTR, (cChar + 1) * sizeof(WCHAR));

            if ( NULL == rpUnicodeNames[i] )
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            if ( 0 == MultiByteToWideChar(
                                CP_ACP,
                                MB_PRECOMPOSED,
                                rpNames[i],
                                -1,
                                rpUnicodeNames[i],
                                cChar + 1) )
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }

        // Make the UNICODE call.

        dwErr = DsCrackNamesW(
                        hDS,
                        flags,
                        formatOffered,
                        formatDesired,
                        cNames,
                        rpUnicodeNames,
                        &pUnicodeResult);

        if ( NO_ERROR != dwErr )
        {
            goto Cleanup;
        }

        // Convert return data to ANSI.  Since UNICODE strings are twice the
        // length of ANSI strings and since the RPC return data is already
        // MIDL allocated, we convert in place without having to reallocate.

        unicodeBufferSize = 2048;
        unicodeBuffer = (WCHAR *) LocalAlloc(LPTR, unicodeBufferSize);

        if ( NULL == unicodeBuffer )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        for ( i = 0; i < pUnicodeResult->cItems; i++ )
        {
            // Note that DsCrackNamesW can return data even if
            // pUnicodeResult->rItems[i].status is non-zero.
            // Eg: DS_NAME_ERROR_DOMAIN_ONLY case.

            // Insure conversion buffer is big enough.

            if ( NULL != pUnicodeResult->rItems[i].pDomain )
            {
                cbDomain = sizeof(WCHAR) *
                           (wcslen(pUnicodeResult->rItems[i].pDomain) + 1);
            }
            else
            {
                cbDomain = 0;
            }

            if ( NULL != pUnicodeResult->rItems[i].pName )
            {
                cbName = sizeof(WCHAR) *
                         (wcslen(pUnicodeResult->rItems[i].pName) + 1);
            }
            else
            {
                cbName = 0;
            }

            cb = (cbName > cbDomain) ? cbName : cbDomain;

            if ( cb > unicodeBufferSize )
            {
                // Reallocate unicodeBuffer.

                LocalFree(unicodeBuffer);
                unicodeBufferSize = cb;
                unicodeBuffer = LocalAlloc(LPTR, unicodeBufferSize);

                if ( NULL == unicodeBuffer )
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }
            }

            // Convert domain name.

            if ( NULL != pUnicodeResult->rItems[i].pDomain )
            {
                wcscpy(unicodeBuffer, pUnicodeResult->rItems[i].pDomain);

                if ( 0 == WideCharToMultiByte(
                                    CP_ACP,
                                    0,                          // flags
                                    unicodeBuffer,
                                    -1,
                                    (LPSTR) pUnicodeResult->rItems[i].pDomain,
                                    cbDomain,
                                    NULL,                       // default char
                                    NULL) )                     // default used
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }
            }

            // Convert object name.

            if ( NULL != pUnicodeResult->rItems[i].pName )
            {
                wcscpy(unicodeBuffer, pUnicodeResult->rItems[i].pName);

                if ( 0 == WideCharToMultiByte(
                                    CP_ACP,
                                    0,                          // flags
                                    unicodeBuffer,
                                    -1,
                                    (LPSTR) pUnicodeResult->rItems[i].pName,
                                    cbName,
                                    NULL,                       // default char
                                    NULL) )                     // default used
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }
            }
        }

        if ( 0 == dwErr )
        {
            *ppResult = (DS_NAME_RESULTA *) pUnicodeResult;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        *ppResult = NULL;
    }

Cleanup:

    if ( NULL != rpUnicodeNames )
    {
        for ( i = 0; i < cNames; i++ )
        {
            LocalFree(rpUnicodeNames[i]);
        }

        LocalFree(rpUnicodeNames);
    }

    if ( NULL != unicodeBuffer )
    {
        LocalFree(unicodeBuffer);
    }

    if ( (0 != dwErr) && (NULL != pUnicodeResult) )
    {
        DsFreeNameResultW(pUnicodeResult);
    }

    return(dwErr);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsFreeNameResultW                                                    //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
DsFreeNameResultW(
    DS_NAME_RESULTW *pResult

)

/*++

Routine Description:

    Releases data returned by DsCrackNamesW.

Arguments:

    pResult - DS_NAME_RESULTW as returned by DsCrackNamesW.

Return Value:

    None.

--*/

{
    DWORD i;

    if ( NULL != pResult )
    {
        if ( NULL != pResult->rItems )
        {
            for ( i = 0; i < pResult->cItems; i++ )
            {
                if ( NULL != pResult->rItems[i].pDomain )
                {
                    MIDL_user_free(pResult->rItems[i].pDomain);
                }

                if ( NULL != pResult->rItems[i].pName )
                {
                    MIDL_user_free(pResult->rItems[i].pName);
                }
            }

            MIDL_user_free(pResult->rItems);
        }

        MIDL_user_free(pResult);
    }
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsFreeNameResultA                                                    //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
DsFreeNameResultA(
    DS_NAME_RESULTA *pResult
    )

/*++

Routine Description:
Arguments:
Return Value:

    See DsFreeNameResultW.

--*/

{
    DsFreeNameResultW((DS_NAME_RESULTW *) pResult);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// LocalConvertStringSidToSid                                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

// This routine is copied almost verbatim from windows\base\advapi\sddl.c
// because the string SID conversion routines are not available on win95.
// Once they become available, we should use the public routines in sddl.h.

BOOL
LocalConvertStringSidToSid (
    IN  PWSTR       StringSid,
    OUT PSID       *Sid,
    OUT PWSTR      *End
    )
/*++

Routine Description:

    This routine will convert a string representation of a SID back into
    a sid.  The expected format of the string is:
                "S-1-5-32-549"
    If a string in a different format or an incorrect or incomplete string
    is given, the operation is failed.

    The returned sid must be free via a call to LocalFree


Arguments:

    StringSid - The string to be converted

    Sid - Where the created SID is to be returned

    End - Where in the string we stopped processing


Return Value:

    TRUE - Success.

    FALSE - Failure.  Additional information returned from GetLastError().  Errors set are:

            ERROR_SUCCESS indicates success

            ERROR_NOT_ENOUGH_MEMORY indicates a memory allocation for the ouput sid
                                    failed
            ERROR_NONE_MAPPED indicates that the given string did not represent a sid

--*/
{
    DWORD Err = ERROR_SUCCESS;
    UCHAR Revision, Subs;
    SID_IDENTIFIER_AUTHORITY IDAuth;
    PULONG SubAuth = NULL;
    PWSTR CurrEnd, Curr, Next;
    WCHAR Stub = 0, *StubPtr = NULL;
    ULONG Index;

    if (    (wcslen(StringSid) < 2)
         || ((*StringSid != L'S') && (*StringSid != L's'))
         || (*(StringSid + 1) != L'-') ) {

        SetLastError( ERROR_NONE_MAPPED );
        return( FALSE );
    }

    Curr = StringSid + 2;

    Revision = ( UCHAR )wcstol( Curr, &CurrEnd, 10 );

    Curr = CurrEnd + 1;

    //
    // Count the number of characters in the indentifer authority...
    //
    Next = wcschr( Curr, L'-' );

    if ( Next && ((Next - Curr) == 6) ) {

        for ( Index = 0; Index < 6; Index++ ) {

            IDAuth.Value[Index] = (UCHAR)Next[Index];
        }

        Curr +=6;

    } else {

         ULONG Auto = wcstoul( Curr, &CurrEnd, 10 );
         IDAuth.Value[0] = IDAuth.Value[1] = 0;
         IDAuth.Value[5] = ( UCHAR )Auto & 0xF;
         IDAuth.Value[4] = ( UCHAR )(( Auto >> 8 ) & 0xFF );
         IDAuth.Value[3] = ( UCHAR )(( Auto >> 16 ) & 0xFF );
         IDAuth.Value[2] = ( UCHAR )(( Auto >> 24 ) & 0xFF );
         Curr = CurrEnd;
    }

    //
    // Now, count the number of sub auths
    //
    Subs = 0;
    Next = Curr;

    //
    // We'll have to count our sub authoritys one character at a time,
    // since there are several deliminators that we can have...
    //
    while ( Next ) {

        Next++;

        if ( *Next == L'-' ) {

            //
            // We've found one!
            //
            Subs++;

        } else if ( *Next == SDDL_SEPERATORC || *Next  == L'\0' || *Next == SDDL_ACE_ENDC ) {

            if ( *( Next - 1 ) == L'-' ) {

                Next--;
            }

            *End = Next;
            Subs++;
            break;

        } else if ( !iswxdigit( *Next ) ) {

            *End = Next;
            Subs++;
            break;

        } else {

            //
            // Some of the tags (namely 'D' for Dacl) fall under the category of iswxdigit, so
            // if the current character is a character we care about and the next one is a
            // delminiator, we'll quit
            //
            if ( *Next == 'D' && *( Next + 1 ) == SDDL_DELIMINATORC ) {

                //
                // We'll also need to temporarily truncate the string to this length so
                // we don't accidentally include the character in one of the conversions
                //
                Stub = *Next;
                StubPtr = Next;
                *StubPtr = UNICODE_NULL;
                *End = Next;
                Subs++;
                break;
            }

        }
    }

    if ( Err == ERROR_SUCCESS ) {

        if ( Subs != 0 ) {

            Curr++;

            SubAuth = ( PULONG )LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Subs * sizeof( ULONG ) );

            if ( SubAuth == NULL ) {

                Err = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                for ( Index = 0; Index < Subs; Index++ ) {

                    SubAuth[Index] = wcstoul( Curr, &CurrEnd, 10 );
                    Curr = CurrEnd + 1;
                }
            }

        } else {

            Err = ERROR_NONE_MAPPED;
        }
    }

    //
    // Now, create the SID
    //
    if ( Err == ERROR_SUCCESS ) {

        *Sid = ( PSID )LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                   sizeof( SID ) + Subs * sizeof( ULONG ) );

        if ( *Sid == NULL ) {

            Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            PISID ISid = ( PISID )*Sid;
            ISid->Revision = Revision;
            ISid->SubAuthorityCount = Subs;
            memcpy( &( ISid->IdentifierAuthority ), &IDAuth,
                           sizeof( SID_IDENTIFIER_AUTHORITY ) );
            memcpy( ISid->SubAuthority, SubAuth, Subs * sizeof( ULONG ) );
        }
    }

    LocalFree( SubAuth );

    //
    // Restore any character we may have stubbed out
    //
    if ( StubPtr ) {

        *StubPtr = Stub;
    }

    SetLastError( Err );

    return( Err == ERROR_SUCCESS );
}
                         
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// IsFPO                                                                //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

BOOL
IsFPO(
    RdnValue        *pRdn,
    ATTRTYP         type
    )
/*++

  Routine Description:

    Determines if a particular RdnValue is a string SID or not.  This is
    imperfect as an FPO may have been renamed to a non-string-SID RDN, or
    there can exist a non-FPO whose RDN is a string SID.  But it is the 
    best we can do during a syntactic map.  The server side does the
    right thing when we are not restricted to purely syntactical mapping.

  Parameters:

    pRdn - pointer to RdnValue to check.

    type - ATTRTYP of the RDN.

  Return Values:

--*/
{
    SID     *pSid;
    WCHAR   *pEnd;

    // The RDN-Att-ID for foreign security principals is Common-Name.
    // String SIDs are less than MAX_RDN_SIZE in length, therefore we can
    // use that as a quick sanity check, and also as an assurance that we
    // can NULL terminate the RDN within the provided buffer.

    if ( (ATT_COMMON_NAME != type) || (pRdn->len >= MAX_RDN_SIZE) )
    {
        return(FALSE);
    }

    pRdn->val[pRdn->len] = L'\0';

    if ( LocalConvertStringSidToSid(pRdn->val, &pSid, &pEnd) )
    {
        if ( pEnd == &pRdn->val[pRdn->len] )
        {
            LocalFree(pSid);
            return(TRUE);
        }

        LocalFree(pSid);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsapi\ntdsmidl.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       allocc.c
//
//--------------------------------------------------------------------------

/*
File: allocc.c

Description:
    
    Routines to handle allocation and deallocation for the client
    side RPC.
    
    Note: the RPC system allows the different MIDL_user_allocate()
    routines on the client and server sides. The DSA uses a
    special implementation of these routines. The client
    side is a simple malloc/free combination. The server side
    uses the THAlloc*() routines.
*/

#pragma warning( disable:4114)  // "same type qualifier used more than once"
#include <NTDSpch.h>
#pragma hdrstop
#pragma warning( default:4114)

#include <memory.h>

#include "dsaalloc.h"

#ifdef DEBUG
/* gAllocated keeps track of the number of times that
the MIDL allocater is called. It is intended to help spot memory leaks.
*/

volatile int gAllocated = 0;
#endif

/*
MIDL_user_allocate

On the server stub side, called by the stub to allocate space for [in]
parameters. Upon return from the called proceedure, the stub will
call MIDL_user_free to deallocate this memory.

The server stub also presumes that this routine is called to allocate
memory for [out] parameters. Upon return from the called proceedure, the
stub will call MIDL_user_free to deallocate [out] parameters.
*/

void* __RPC_USER MIDL_user_allocate( size_t bytes )
{
    void*   ret;
    
    /* Keep track of the number of times the
    allocater is called. Helps in spotting memory leaks.
    Assumes the following operation is atomic.
    */
    
#ifdef DEBUG
    gAllocated++;
#endif

    ret = malloc( (size_t) bytes );
    if ( ret == NULL ) {
        return( ret );
    } else {
        /* Zero out the memory */
        memset( ret, 0, (size_t) bytes );
    }
    
    /* Normal return */
    
    return( ret );
}


void __RPC_USER MIDL_user_free( void* memory )
{
    /* Keep track of the number of times the
    deallocater is called. Helps in spotting memory leaks.
    Assumes the following operation is atomic.
    */
    
#ifdef DEBUG
    gAllocated--;
#endif
    free( memory );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsapi\dsdebug.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dsdebug.c

Abstract:

    Implementation of DsMakeQuotedRdn/DsMakeUnquotedRdn API and
    helper functions.

Author:

    Billy Fuller (billyf) 14-May-1999

Environment:

    User Mode - Win32

Notes:
    The debug layer is limited to CHK builds.

Revision History:

--*/

#define _NTDSAPI_       // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <rpc.h>        // RPC defines
#include <stdio.h>      // for printf
#include <stdlib.h>     // atol
#include <dststlog.h>   // DSLOG

#include "dsdebug.h"

#define DEBSUB  "NTDSAPI_DSDEBUG"

//
// CHK BUILDS ONLY!
//
#if DBG

//
// Flags controls user settable options such as debug output.
// The user can set the flags word with an environment variable
// (set _NTDSAPI_FLAGS=0x1) or with ntsd (ed dwNtDsApiFlags 0x1).
//
DWORD   gdwNtDsApiFlags;

//
// Level controls user settable output level.
// The user can set the level word with an environment variable
// (set _NTDSAPI_LEVEL=0x1) or with ntsd (ed dwNtDsApiLevel 0x1).
//
DWORD   gdwNtDsApiLevel;

//
// For various debug ops such as printing a line
//
CRITICAL_SECTION    DsDebugLock;

//
// ProcessId (for spew)
//
DWORD   DsDebugProcessId;

//
// Line for spew (spew is single threaded)
//
CHAR    DsDebugLine[512];

//
// Optional log file for spew (environment variable _NTDSAPI_LOG);
//
CHAR    DsDebugLog[MAX_PATH];
HANDLE  DsDebugHandle = INVALID_HANDLE_VALUE;

BOOL
DsDebugFormatLine(
    IN PCHAR    DebSub,
    IN UINT     LineNo,
    IN PCHAR    Line,
    IN ULONG    LineSize,
    IN PUCHAR   Format,
    IN va_list  argptr
    )
/*++
Routine Description:
    Format the line of debug output.

Arguments:
    Not documented.

Return Value:
    None.
--*/
{
    ULONG       LineUsed;
    SYSTEMTIME  SystemTime;
    BOOL        Ret = TRUE;

    //
    // Increment the line count here to prevent counting
    // the several DPRINTs that don't have a newline.
    //
    GetLocalTime(&SystemTime);
    if (_snprintf(Line, LineSize, "<%-15s %04x.%04x: %5u: %02d:%02d:%02d> ",
              (DebSub) ? DebSub : "NoName",
              DsDebugProcessId,
              GetCurrentThreadId(),
              LineNo,
              SystemTime.wHour,
              SystemTime.wMinute,
              SystemTime.wSecond) < 0) {
        Ret = FALSE;
    } else {
        LineUsed = strlen(Line);
        if (((LineUsed + 1) >= LineSize) ||
            (_vsnprintf(Line + LineUsed,
                       LineSize - LineUsed,
                       Format,
                       argptr) < 0)) {
            Ret = FALSE;
        }
    }
    return Ret;
}

VOID
DsDebugPrint(
    IN DWORD   Level,
    IN PUCHAR  Format,
    IN PCHAR   DebSub,
    IN UINT    LineNo,
    IN ...
    )
/*++
Routine Description:
    Format and print a line of output.

Arguments:
    Format  - printf format
    DebSub  - module name
    LineNo  - file's line number

Return Value:
    None.
--*/
{
    DWORD           BytesWritten;
    va_list         arglist;

    //
    // Not important enough, ignore;
    //
    if (Level > gdwNtDsApiLevel) {
        return;
    }

    //
    // No output requested; ignore
    //
    if ((gdwNtDsApiFlags & NTDSAPI_FLAGS_ANY_OUT) == 0) {
        return;
    }

    //
    // Print the line
    //
    va_start(arglist, LineNo);
    __try {
        __try {
            EnterCriticalSection(&DsDebugLock);
            if (DsDebugFormatLine(DebSub,
                                  LineNo,
                                  DsDebugLine,
                                  sizeof(DsDebugLine),
                                  Format,
                                  arglist)) {
                //
                // Print a line
                //
                if (gdwNtDsApiFlags & NTDSAPI_FLAGS_PRINT) {
                    printf("%s", DsDebugLine);
                }

#ifndef WIN95
                //
                // Spew a line
                //
                if (gdwNtDsApiFlags & NTDSAPI_FLAGS_SPEW) {
                    DbgPrint(DsDebugLine);
                }
#endif !WIN95

                //
                // Log a line
                //
                if (gdwNtDsApiFlags & NTDSAPI_FLAGS_LOG) {
                    if (DsDebugLog[0] != '\0' &&
                        DsDebugHandle == INVALID_HANDLE_VALUE) {
                        //
                        // Try to open the file once.
                        //
                        DsDebugHandle = CreateFileA(DsDebugLog,
                                                    GENERIC_WRITE|GENERIC_WRITE,
                                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                    NULL,
                                                    OPEN_ALWAYS,
                                                    FILE_ATTRIBUTE_NORMAL,
                                                    NULL);
                        //
                        // DON'T RETRY!
                        //
                        if (DsDebugHandle == INVALID_HANDLE_VALUE) {
                            DsDebugLog[0] = '\0';
                        }
                    }
                    if (DsDebugHandle != INVALID_HANDLE_VALUE) {
                        //
                        // Weak attempt at multi-process access
                        //
                        SetFilePointer(DsDebugHandle,
                                       0,
                                       NULL,
                                       FILE_END);
                        //
                        // Not much we can do if this doesn't work
                        //
                        if (!WriteFile(DsDebugHandle,
                                       DsDebugLine,
                                       strlen(DsDebugLine),
                                       &BytesWritten,
                                       NULL)) {
                            //
                            // DON'T RETRY!
                            //
                            CloseHandle(DsDebugHandle);
                            DsDebugHandle = INVALID_HANDLE_VALUE;
                            DsDebugLog[0] = '\0';
                        }
                    }
                }
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            // trap AVs so the caller is not affected
        }
    } __finally {
        LeaveCriticalSection(&DsDebugLock);
    }
    va_end(arglist);
}

VOID
InitDsDebug(
     VOID
     )
/*++

 Routine Description:

   Initialize the DsDebug subsystem at ntdsapi.dll load.

 Arguments:

   None.

 Return Value:

    None.
--*/
{
    DWORD   nChars;

    //
    // For various debug ops such as printing a line
    //
    InitializeCriticalSection(&DsDebugLock);

    //
    // For messages
    //
    DsDebugProcessId = GetCurrentProcessId();

    //
    // No Log file
    //
    DsDebugLog[0] = '\0';

    //
    // read environment variables
    //
    __try {
        //
        // User settable flags (or with ntsd.exe command -- ed gdwNtDsApiLevel 0x1)
        //
        nChars = GetEnvironmentVariableA("_NTDSAPI_LEVEL",
                                         DsDebugLine,
                                         sizeof(DsDebugLine));
        if (nChars && nChars < sizeof(DsDebugLine)) {
            gdwNtDsApiLevel = strtoul(DsDebugLine, NULL, 0);
        }

        //
        // User settable flags (or with ntsd.exe command -- ed gdwNtDsApiFlags 0x1)
        //
        nChars = GetEnvironmentVariableA("_NTDSAPI_FLAGS",
                                         DsDebugLine,
                                         sizeof(DsDebugLine));
        if (nChars && nChars < sizeof(DsDebugLine)) {
            gdwNtDsApiFlags = strtoul(DsDebugLine, NULL, 0);
        }

        //
        // User settable log file (cannot be set with ntsd.exe!)
        //
        nChars = GetEnvironmentVariableA("_NTDSAPI_LOG",
                                         DsDebugLine,
                                         sizeof(DsDebugLine));
        if (nChars != 0 && nChars < sizeof(DsDebugLine)) {
            nChars = ExpandEnvironmentStringsA(DsDebugLine,
                                               DsDebugLog,
                                               sizeof(DsDebugLog));
            if (nChars == 0 || nChars > sizeof(DsDebugLog)) {
                DsDebugLog[0] = '\0';
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }

    DPRINT1(0, "gdwNtDsApiLevel ==> %08x\n", gdwNtDsApiLevel);
    DPRINT1(0, "gdwNtDsApiFlags ==> %08x\n", gdwNtDsApiFlags);
    DPRINT1(0, "DsDebugLog ==> %s\n", DsDebugLog);
}

VOID
TerminateDsDebug(
     VOID
     )
/*++

 Routine Description:

   Uninitialize the DsDebug subsystem at ntdsapi.dll unload.

 Arguments:

   None.

 Return Value:

    None.
--*/
{
    DeleteCriticalSection(&DsDebugLock);
    if (DsDebugHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(DsDebugHandle);
    }
}

#define MAX_COMPONENTS  (8)
PCHAR aComponents[MAX_COMPONENTS + 1] = {
    "Unknown",              // 0
    "Application",          // 1
    "RPC Runtime",          // 2
    "Security Provider",    // 3
    "NPFS",                 // 4
    "RDR",                  // 5
    "NMP",                  // 6
    "IO",                   // 7
    "Winsock",              // 8
};

VOID
DsDebugPrintRpcExtendedError(
    IN DWORD    dwErr
    )
/*++
Routine Description:
    Dump the rpc extended error info.

Arguments:
    dwErr - from rpc call

Return Value:
    None.
--*/
{
    LONG    i;
    BOOL    Result;
    RPC_ERROR_ENUM_HANDLE   EnumHandle;
    RPC_EXTENDED_ERROR_INFO ErrorInfo;

    // No error
    if (RPC_S_OK == dwErr) {
        return;
    }

    //
    // No output requested; ignore
    //
    if ((gdwNtDsApiFlags & NTDSAPI_FLAGS_ANY_OUT) == 0) {
        return;
    }

    DPRINT1(0, "RPC_EXTENDED: Original status: 0x%x\n", dwErr);

    // Start enumeration
    dwErr = RpcErrorStartEnumeration(&EnumHandle);
    if (RPC_S_OK != dwErr) {
        // No extended error
        if (dwErr == RPC_S_ENTRY_NOT_FOUND) {
            return;
        }
        // error getting extended error
        DPRINT1(0, "RpcErrorStartEnumeration() ==> 0x%x\n", dwErr);
        return;
    }

    while (RPC_S_OK == dwErr) {
        // Get next record
        memset(&ErrorInfo, 0, sizeof(ErrorInfo));
        ErrorInfo.Version = RPC_EEINFO_VERSION;
        ErrorInfo.NumberOfParameters = MaxNumberOfEEInfoParams;
        dwErr = RpcErrorGetNextRecord(&EnumHandle, FALSE, &ErrorInfo);
        if (RPC_S_OK != dwErr) {
            if (dwErr != RPC_S_ENTRY_NOT_FOUND) {
                // error getting next extended error
                DPRINT1(0, "RpcErrorGetNextRecord() ==> 0x%x\n", dwErr);
            }
            break;
        }

        // Dump it with findstr tag RPC EXTENDED
        DPRINT1(0, "RPC_EXTENDED: Box      : %ws\n", ErrorInfo.ComputerName);
        DPRINT1(0, "RPC_EXTENDED: ProcessId: %d\n", ErrorInfo.ProcessID);
        DPRINT2(0, "RPC_EXTENDED: Component: %d (%s)\n", 
                ErrorInfo.GeneratingComponent,
                (ErrorInfo.GeneratingComponent <= MAX_COMPONENTS)
                    ? aComponents[ErrorInfo.GeneratingComponent]
                    : "Unknown");
        DPRINT1(0, "RPC_EXTENDED: Status   : %d\n", ErrorInfo.Status);
        DPRINT1(0, "RPC_EXTENDED: Location : %d\n", (int)ErrorInfo.DetectionLocation);
        DPRINT1(0, "RPC_EXTENDED: Flags    : 0x%x\n", ErrorInfo.Flags);
        DPRINT1(0, "RPC_EXTENDED: nParams  : %d\n", ErrorInfo.NumberOfParameters);
        for (i = 0; i < ErrorInfo.NumberOfParameters; ++i) {
            switch(ErrorInfo.Parameters[i].ParameterType) {
            case eeptAnsiString:
                DPRINT1(0, "RPC_EXTENDED: Ansi string   : %s\n", 
                    ErrorInfo.Parameters[i].u.AnsiString);
                break;

            case eeptUnicodeString:
                DPRINT1(0, "RPC_EXTENDED: Unicode string: %ws\n", 
                    ErrorInfo.Parameters[i].u.UnicodeString);
                break;

            case eeptLongVal:
                DPRINT2(0, "RPC_EXTENDED: Long val      : 0x%x (%d)\n", 
                    ErrorInfo.Parameters[i].u.LVal,
                    ErrorInfo.Parameters[i].u.LVal);
                break;

            case eeptShortVal:
                DPRINT2(0, "RPC_EXTENDED: Short val     : 0x%x (%d)\n", 
                    (int)ErrorInfo.Parameters[i].u.SVal,
                    (int)ErrorInfo.Parameters[i].u.SVal);
                break;

            case eeptPointerVal:
                DPRINT1(0, "RPC_EXTENDED: Pointer val   : 0x%x\n", 
                    (ULONG)ErrorInfo.Parameters[i].u.PVal);
                break;

            case eeptNone:
                DPRINT(0, "RPC_EXTENDED: Truncated\n");
                break;

            default:
                DPRINT2(0, "RPC_EXTENDED: Invalid type  : 0x%x (%d)\n", 
                    ErrorInfo.Parameters[i].ParameterType,
                    ErrorInfo.Parameters[i].ParameterType);
            }
        }
    }
    RpcErrorEndEnumeration(&EnumHandle);
}
//
// CHK BUILDS ONLY!
//
#endif DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsapi\dsrsa.c ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dsrsa.c

ABSTRACT:

    Syncs a specified server with all others in its site, using transitive replication
    as necessary.

DETAILS:

CREATED:

    06/30/98	Aaron Siegel (t-asiege)

REVISION HISTORY:

    12/11/98    Will Lees (wlees)
      1. Allow to work for synchronous (RPC-based) intersite connections
      2. Implement a "push mode" to force a change out to all servers

Suggestions for future enhancements:
o Add support for mail-based replicas. Perhaps these could be allowed as "leaf nodes" at the last,
  most distant phase of replication?
o Abstract the list handling into a class.  Right now some of the list handling is embedded in
  the body of the code.  Not the mention the fact that the lists are unusual: the list always has
  an allocated but uninitialized element hanging at the end.
o Abstract the binary tree routines into a class.

QUESTIONS
o Can threads get stuck if an exception is thrown?
o NameMatched doesn't impose an ordering on DNs; could this lead to problems?

--*/

#define _NTDSAPI_

#if !WIN95 && !WINNT4
    #include <process.h>
    #include <nt.h>
    #include <ntrtl.h>
    #include <ntdspch.h>
    #include <winerror.h>
    #include <ntdsa.h>
    #include <winldap.h>
    #include <w32topl.h>
    #include <drs.h>
    #include <bind.h>
    #include "util.h"
    #include "minmax.h"

// Debugging stuff.  Note order is important, just want the Assert() from debug.h, but not the DPRINTs, because
//   we have our own DPRINTs in dsrsa.h
    #include <debug.h>
    #define DEBSUB     "DSRSA:"           // define the subsystem for debugging
    #undef DPRINT
    #undef DPRINT1
    #undef DPRINT2
    #include "dsrsa.h"

    #if DBG
DWORD gdwDsRSADbgLevel = 0;
    #endif

// 38 = (32 GUID numerals + 4 hyhens + 1 dot + 6 chars + 1 dot + 1 null terminator)
    #define ADDITIONAL_BYTES_FOR_GUID_DNS	45

    #define DsRSAChkErr(x) { DWORD _dwWin32Err = (x); if (NO_ERROR != _dwWin32Err) DsRSAException (_dwWin32Err); }

    #define DsRSAChkLdap(x) { DWORD _dwLDAPErr = (x); if (NO_ERROR != _dwLDAPErr) DsRSAException (LdapMapErrorToWin32 (_dwLDAPErr)); }

    #define DsRSAFree(heap,lpMem) HeapFree (heap, 0L, lpMem)

    #define DsRSAHeapCreate(pHeap) \
	((*(pHeap) = HeapCreate (0L, 0L, 0L)) == NULL ? GetLastError () : NO_ERROR)

    #define DsRSAHeapDestroy(heap) \
	(HeapDestroy (heap) == FALSE ? GetLastError () : NO_ERROR)

    #define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))

    #define SITES_PREFIX L"CN=Sites,"
    #define IP_PREFIX L"CN=IP,"
    #define IP_PREFIX_LEN  (ARRAY_SIZE(IP_PREFIX) - 1)
    #define DEFAULT_PAGED_SEARCH_PAGE_SIZE          (1000)

// All exceptions generated by DsReplicaSyncAll will have exception code DS_RSAI_EXCEPTION.
// The win32 error responsible for the exception is stored as the first argument.

VOID
DsRSAException (
    DWORD           dwWin32Err
    ) {
    UINT_PTR err = dwWin32Err;

    RaiseException (DS_RSAI_EXCEPTION,
        EXCEPTION_NONCONTINUABLE,
        1,
        &err);
}

// This is just a wrapper that allocates memory from a private heap.

LPVOID
DsRSAAlloc (
    HANDLE          heap,
    DWORD           dwBytes
    ) {
    LPVOID          pMem;

    if( (pMem = HeapAlloc (heap, 0L, dwBytes)) == NULL )
        DsRSAException (GetLastError ());

    return pMem;
}

// Inserts an element into a list and returns a pointer to the next (empty)
// location in the list.
// Note that the style of list used in this module is for the last element to be allocated
// but not initialized.

PDS_RSAI_LIST
DsRSAListInsert (
    HANDLE          heap,
    PDS_RSAI_LIST   pList,
    ULONG_PTR       ulpData
    ) {
    pList->ulpItem = ulpData;
    pList->next = (PDS_RSAI_LIST) DsRSAAlloc (heap, sizeof (DS_RSAI_LIST));
    pList->next->next = NULL;
    return(pList->next);
}

// Destroys a list.
// Note that the pItem in each element is NOT deallocated. Caller must dispose.

VOID
DsRSAListDestroy (
    HANDLE          heap,
    PDS_RSAI_LIST       pList
    ) {

    PDS_RSAI_LIST       plistTemp;

    while( pList != NULL ) {
        plistTemp = pList->next;
        DsRSAFree (heap, pList);
        pList = plistTemp;
    }
}

// Converts a unicode string to an ANSI string, allocating a buffer of
// appropriate size.

LPSTR
DsRSAAllocToANSI (
    HANDLE          heap,
    LPWSTR          pszW
    ) {

    LPSTR           pszA;
    ULONG           ulBufSize;

    if( pszW == NULL ) {
        pszA = NULL;
    }
    else {
        ulBufSize = (wcslen (pszW) + 1) * sizeof (CHAR);
        pszA = (LPSTR) DsRSAAlloc (heap, ulBufSize);
        WideCharToMultiByte (
            CP_ACP,
            0L,
            pszW,
            -1,
            pszA,
            ulBufSize,
            NULL,
            NULL);
    }
    return(pszA);
}

// Perform unicode -> ANSI conversion for callback updates.

BOOL
DsRSAIssueANSIUpdate (
    HANDLE          heap,
    BOOL (__stdcall *       pFnCallBackA) (LPVOID, PDS_REPSYNCALL_UPDATEA),
    LPVOID          pCallbackData,
    PDS_REPSYNCALL_UPDATEW  pUpdateW
    ) {

    DS_REPSYNCALL_ERRINFOA  errorA;
    DS_REPSYNCALL_SYNCA     syncA;
    DS_REPSYNCALL_UPDATEA   updateA;
    BOOL            bReturn;

    if( pUpdateW->pSync == NULL ) {
        updateA.pSync = NULL;
    }
    else {
        syncA.pszSrcId = DsRSAAllocToANSI (heap, pUpdateW->pSync->pszSrcId);
        syncA.pszDstId = DsRSAAllocToANSI (heap, pUpdateW->pSync->pszDstId);
        syncA.pszNC = DsRSAAllocToANSI (heap, pUpdateW->pSync->pszNC);
        syncA.pguidSrc = pUpdateW->pSync->pguidSrc;
        syncA.pguidDst = pUpdateW->pSync->pguidDst;
        updateA.pSync = &syncA;
    }
    if( pUpdateW->pErrInfo == NULL ) {
        updateA.pErrInfo = NULL;
    }
    else {
        errorA.pszSvrId = DsRSAAllocToANSI (heap, pUpdateW->pErrInfo->pszSvrId);
        errorA.error = pUpdateW->pErrInfo->error;
        errorA.dwWin32Err = pUpdateW->pErrInfo->dwWin32Err;
        errorA.pszSrcId = DsRSAAllocToANSI (heap, pUpdateW->pErrInfo->pszSrcId);
        updateA.pErrInfo = &errorA;
    }
    updateA.event = pUpdateW->event;

    bReturn = pFnCallBackA (pCallbackData, &updateA);

    if( updateA.pSync ) {
        if( syncA.pszSrcId ) DsRSAFree (heap, syncA.pszSrcId);
        if( syncA.pszDstId ) DsRSAFree (heap, syncA.pszDstId);
        if( syncA.pszNC ) DsRSAFree (heap, syncA.pszNC);
    }
    if( updateA.pErrInfo ) {
        if( errorA.pszSvrId ) DsRSAFree (heap, errorA.pszSvrId);
        if( errorA.pszSrcId ) DsRSAFree (heap, errorA.pszSrcId);
    }

    return bReturn;
}

// Send out an update using the callback function in pMainInfo.

VOID
DsRSAIssueUpdate (
    HANDLE          heap,
    PDS_RSAI_MAININFO       pMainInfo,
    DS_REPSYNCALL_EVENT     event,
    PDS_REPSYNCALL_ERRINFOW pErrInfo,
    PDS_REPSYNCALL_SYNCW    pSync
    ) {

    DS_REPSYNCALL_UPDATEW   update;
    BOOL            bContinueExecution;

    update.event = event;
    update.pErrInfo = pErrInfo;
    update.pSync = pSync;
    bContinueExecution = TRUE;
    if( pMainInfo->pFnCallBackA ) {
        bContinueExecution = DsRSAIssueANSIUpdate (heap, pMainInfo->pFnCallBackA, pMainInfo->pCallbackData, &update);
    }
    if( pMainInfo->pFnCallBackW ) {
        bContinueExecution = pMainInfo->pFnCallBackW (pMainInfo->pCallbackData, &update);
    }
    if( !bContinueExecution ) {
        DsRSAException (ERROR_CANCELLED);               // Zap!
    }
}

// A wrapper that simplifies issuing updates of syncs.

VOID
DsRSAIssueUpdateSync (
    HANDLE          heap,
    PDS_RSAI_MAININFO       pMainInfo,
    DS_REPSYNCALL_EVENT     event,
    PDS_RSAI_SVRINFO            pSrcSvrInfo,
    PDS_RSAI_SVRINFO            pDstSvrInfo
    ) {

    DS_REPSYNCALL_SYNCW     sync;

    sync.pszSrcId = pSrcSvrInfo->pszMsgId;
    sync.pszDstId = pDstSvrInfo->pszMsgId;
    sync.pszNC = pMainInfo->pdsnameNameContext->StringName;
    sync.pguidSrc = &(pSrcSvrInfo->guid);
    sync.pguidDst = &(pDstSvrInfo->guid);

    DsRSAIssueUpdate (heap, pMainInfo, event, NULL, &sync);
}

// When a nonfatal error occurs, this routine reports it to the callback function
// and inserts it to the error list maintained in pMainInfo.

VOID
DsRSADoError (
    HANDLE          heap,
    PDS_RSAI_MAININFO       pMainInfo,
    LPWSTR          pszSvrId,
    DS_REPSYNCALL_ERROR     error,
    DWORD           dwWin32Err,
    LPWSTR          pszSrcId
    ) {

    PDS_REPSYNCALL_ERRINFOW pErrInfo;

    pErrInfo = DsRSAAlloc (heap, sizeof (DS_REPSYNCALL_ERRINFOW));
    pErrInfo->pszSvrId = pszSvrId;
    pErrInfo->error = error;
    pErrInfo->dwWin32Err = dwWin32Err;
    pErrInfo->pszSrcId = pszSrcId;
    DsRSAIssueUpdate (heap, pMainInfo, DS_REPSYNCALL_EVENT_ERROR, pErrInfo, NULL);
    pMainInfo->plistNextError = DsRSAListInsert (heap, pMainInfo->plistNextError, (ULONG_PTR) pErrInfo);
}

// Destroys a list of errors.

VOID
DsRSAErrListDestroy (
    HANDLE          heap,
    PDS_RSAI_LIST       plistFirstError
    ) {

    PDS_RSAI_LIST       plistNextError;

    for( plistNextError = plistFirstError;
         plistNextError->next != NULL;
         plistNextError = plistNextError->next ) {
        DsRSAFree (heap, (LPVOID) plistNextError->ulpItem);
    }
    DsRSAListDestroy (heap, plistFirstError);
}

PDSNAME
DsRSAAllocBuildDsname (
    HANDLE          heap,
    LPCWSTR                      pszDn
    ) {

    PDSNAME         pdsnameLocal;
    PDSNAME         pdsnameHeap;

    pdsnameLocal = pdsnameHeap = NULL;

    __try {

        DsRSAChkErr (AllocBuildDsname (pszDn, &pdsnameLocal));

        // Note that if pszDN is NULL, AllocBuildDsname succeeds and sets
        // pdsnameLocal to NULL, in which case pdsnameHeap remains NULL.

        if (NULL != pdsnameLocal) {
            pdsnameHeap = DsRSAAlloc (heap, pdsnameLocal->structLen);
            memcpy (pdsnameHeap, pdsnameLocal, pdsnameLocal->structLen);
        }
    } __finally {

        if( pdsnameLocal != NULL ) LocalFree (pdsnameLocal);

    }

    return pdsnameHeap;
}

// Compares two DNs.  Returns 0 if they are the same, < 0 if Dn1 < Dn2, and > 0 if Dn1 > Dn2.

INT
DsRSADnCmp (
    PDSNAME         pDsname1,
    PDSNAME         pDsname2
    ) {

    INT             iCmp;

    // if (NameMatched (pDsname1, pDsname2)) iCmp = 0;
    // else

    iCmp = _wcsicmp (pDsname1->StringName, pDsname2->StringName);

    return iCmp;
}

// DS_RSAI_SVMAP is a mapping between servers and vertices, stored as a binary
// search tree.  This routine updates the root node of a tree.

VOID
DsRSASvMapUpdate (
    HANDLE          heap,
    PDS_RSAI_SVMAP      pSvMap,
    PDSNAME         pDsname,
    TOPL_VERTEX         vertex
    ) {

    if( pSvMap != NULL ) {
        pSvMap->vertex = vertex;
        if( pSvMap->pDsname != NULL ) {
            DsRSAFree (heap, pSvMap->pDsname);
        }
        if( pDsname == NULL ) {
            pSvMap->pDsname = NULL;
        }
        else {
            pSvMap->pDsname = pDsname;
        }
    }
}

// Creates a new tree, assigning the specified attributes to the root node.

PDS_RSAI_SVMAP
DsRSASvMapCreate (
    HANDLE          heap,
    PDSNAME         pDsname,
    TOPL_VERTEX         vertex
    ) {

    PDS_RSAI_SVMAP      pSvMap;

    pSvMap = (PDS_RSAI_SVMAP) DsRSAAlloc (heap, sizeof (DS_RSAI_SVMAP));
    pSvMap->left = NULL;
    pSvMap->right = NULL;
    pSvMap->pDsname = NULL;
    DsRSASvMapUpdate (heap, pSvMap, pDsname, vertex);

    return pSvMap;
}

// Inserts a server-vertex pair into an SvMap tree.

PDS_RSAI_SVMAP
DsRSASvMapInsert (
    HANDLE          heap,
    PDS_RSAI_SVMAP      pSvMap,
    PDSNAME         pDsname,
    TOPL_VERTEX         vertex
    ) {

    PDS_RSAI_SVMAP      psvmapTemp = pSvMap;
    INT             iCmp;

    if( pSvMap == NULL ) {
        pSvMap = DsRSASvMapCreate (heap, pDsname, vertex);
    }

    else {
        while( psvmapTemp != NULL ) {
            iCmp = DsRSADnCmp (pDsname, psvmapTemp->pDsname);
            if( iCmp == 0 ) {
                DsRSASvMapUpdate (heap, pSvMap, pDsname, vertex);
                break;
            }
            if( iCmp < 0 ) {
                if( psvmapTemp->left == NULL ) {
                    psvmapTemp->left = DsRSASvMapCreate (heap, pDsname, vertex);
                    break;
                }
                else {
                    psvmapTemp = psvmapTemp->left;
                }
            }
            else {
                if( psvmapTemp->right == NULL ) {
                    psvmapTemp->right = DsRSASvMapCreate (heap, pDsname, vertex);
                    break;
                }
                else {
                    psvmapTemp = psvmapTemp->right;
                }
            }
        }
    }

    return pSvMap;
}

// Returns the vertex that has been associated with a given Dn.

TOPL_VERTEX
DsRSASvMapGetVertex (
    HANDLE          heap,
    PDS_RSAI_SVMAP      pSvMap,
    LPWSTR          pszDn
    ) {

    TOPL_VERTEX         vertex = NULL;
    PDSNAME         pDsname;
    INT             iCmp;

    pDsname = DsRSAAllocBuildDsname (heap, pszDn);

    while( pSvMap != NULL ) {
        iCmp = DsRSADnCmp (pDsname, pSvMap->pDsname);
        if( iCmp == 0 ) {
            vertex = pSvMap->vertex;
            break;
        }
        if( iCmp < 0 ) {
            pSvMap = pSvMap->left;
        }
        else {
            pSvMap = pSvMap->right;
        }
    }

    DsRSAFree (heap, pDsname);

    return vertex;
}

// Frees an SvMap tree.  Free the elements recursively.

VOID
DsRSASvMapDestroy (
    HANDLE          heap,
    PDS_RSAI_SVMAP      pSvMap
    ) {

    if( pSvMap != NULL ) {
        DsRSAFree (heap, pSvMap->pDsname);
        DsRSASvMapDestroy (heap, pSvMap->left);
        DsRSASvMapDestroy (heap, pSvMap->right);
        DsRSAFree (heap, pSvMap);
    }
}

// This converts a root domain and a GUID to a GUID DNS.  The return
// value should be freed with DsRSAFree ().

LPWSTR
DsRSAAllocGuidDNS (
    HANDLE          heap,
    LPWSTR          pszRootDomain,
    GUID *          pGuid
    ) {

    LPWSTR          pszGuidDNS;

    pszGuidDNS = (LPWSTR) DsRSAAlloc (heap, (wcslen (pszRootDomain) + ADDITIONAL_BYTES_FOR_GUID_DNS) * sizeof (WCHAR));
    swprintf (pszGuidDNS, L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x._msdcs.%s",
        pGuid->Data1,
        pGuid->Data2,
        pGuid->Data3,
        pGuid->Data4[0],
        pGuid->Data4[1],
        pGuid->Data4[2],
        pGuid->Data4[3],
        pGuid->Data4[4],
        pGuid->Data4[5],
        pGuid->Data4[6],
        pGuid->Data4[7],
        pszRootDomain);
    return pszGuidDNS;
}

// Builds the topology.

VOID
DsRSABuildTopology (
    HANDLE          heap,
    LDAP *          hld,
    RPC_AUTH_IDENTITY_HANDLE    hRpcai,
    PDS_RSAI_MAININFO       pMainInfo,
    PDS_RSAI_TOPLINFO *     ppToplInfo
    ) {

    LPWSTR          ppszNtdsDsaSearch [] = {    L"hasMasterNCs",
        L"objectGUID",
        NULL};

    LPWSTR          ppszConnectionSearch [] = { L"transportType",
        L"fromServer",
        NULL};

    LPWSTR          pszNtdsDsaSearchTemplate =
        L"(&(objectCategory=ntdsDsa)(|(hasMasterNCs=%s)(hasPartialReplicaNCs=%s)))";

    LPWSTR          pszNtdsConnSearchTemplate =
        L"(&(objectCategory=nTDSConnection)(enabledConnection=TRUE))";

    HANDLE          hDS = NULL;
    DWORD           dwWin32Err;

    PDS_NAME_RESULTW        pResult = NULL;                 // For CrackNames
    PDSNAME         pDsname;
    PDSNAME         pdsnameHome;
    PDSNAME         pdsnameServer;

    LDAPMessage *       pldmRootResults = NULL;
    LDAPMessage *       pldmRootEntry = NULL;
    LPWSTR *            ppszConfigurationNC = NULL;
    LPWSTR *            ppszServiceName = NULL;
    LPWSTR *            ppszRootDNC = NULL;

    LPWSTR          pszNtdsDsaSearchFilter;
    LDAPSearch *        pDsaSearch = NULL;
    LDAPMessage *       pldmNtdsDsaResults = NULL;
    LDAPMessage *       pldmNtdsDsaEntry = NULL;
    LPWSTR *            ppszMasterNCs = NULL;
    struct berval **        ppbvObjectGUID = NULL;
    LPWSTR          pszServerDn = NULL;
    LPWSTR          pszServerTempDn = NULL;
    LPWSTR          pszSitesContainerDn = NULL;

    LDAPSearch *        pConnSearch = NULL;
    LDAPMessage *       pldmConnectionResults = NULL;
    LDAPMessage *       pldmConnectionEntry = NULL;
    LPWSTR *            ppszConnectionFrom = NULL;
    LPWSTR *            ppszTransportType = NULL;

    PDS_RSAI_SVMAP      pSvMapDnToVertex = NULL;
    PDS_RSAI_LIST       plistFirstServer;
    PDS_RSAI_LIST       plistNextServer;
    PDS_RSAI_SVRINFO        pSvrInfo;
    LPWSTR          pszGuidDNS;
    LONG            lNCAt;

    TOPL_VERTEX         vertex;
    TOPL_VERTEX         vHere;
    TOPL_VERTEX         vThere;
    TOPL_EDGE           edge;
    DWORD               dwThisId;
    ULONG               ul;
    INT                 iCmp;

    DWORD               dwLdapErr;
    DWORD               dwInnerLdapErr;
    ULONG               ulTotalEstimate = 0;
    ULONG               ulInnerTotalEstimate = 0;

    __try {

        // Set up the topology.
        *ppToplInfo = (PDS_RSAI_TOPLINFO) DsRSAAlloc (heap, sizeof (DS_RSAI_TOPLINFO));
        (*ppToplInfo)->toplGraph = NULL;

        // Create a list that will be used to store the servers.
        plistFirstServer = (PDS_RSAI_LIST) DsRSAAlloc (heap, sizeof (DS_RSAI_LIST));
        plistFirstServer->next = NULL;
        plistNextServer = plistFirstServer;

        DsRSAChkLdap (ldap_search_sW (
            hld,
            NULL,
            LDAP_SCOPE_BASE,
            L"(objectCategory=*)",
            NULL,
            0,
            &pldmRootResults));

        if ((NULL == (pldmRootEntry = ldap_first_entry(hld, pldmRootResults)))
            || (NULL == (ppszConfigurationNC
                         = ldap_get_valuesW(hld, pldmRootEntry,
                                            L"configurationNamingContext")))
            || (NULL == (ppszServiceName
                         = ldap_get_valuesW(hld, pldmRootEntry,
                                            L"dsServiceName")))
            || (NULL == (ppszRootDNC
                         = ldap_get_valuesW(hld, pldmRootEntry,
                                            L"rootDomainNamingContext")))) {
            DsRSAException(ERROR_DS_NO_ATTRIBUTE_OR_VALUE);
        }

        DPRINT1( 3, "Home = %ws\n", ppszServiceName[0] );
        pdsnameHome = DsRSAAllocBuildDsname (heap, ppszServiceName[0]);

        // If the NC is NULL, default to the configuration NC
        if( pMainInfo->pdsnameNameContext == NULL ) {
            pMainInfo->pdsnameNameContext = DsRSAAllocBuildDsname (heap, ppszConfigurationNC[0]);
        }

        (*ppToplInfo)->toplGraph = ToplGraphCreate ();
        (*ppToplInfo)->vHome = NULL;

        // We use DsCrackNamesW to convert the Root Domain NC to the Root Domain Name
        // (e.g. DC=nttest,DC=microsoft,DC=com => nttest.microsoft.com)

        DsRSAChkErr (DsCrackNamesW (
            NULL,
            DS_NAME_FLAG_SYNTACTICAL_ONLY,
            DS_FQDN_1779_NAME,
            DS_CANONICAL_NAME_EX,
            1,
            ppszRootDNC,
            &pResult));

        (*ppToplInfo)->pszRootDomain = DsRSAAlloc (heap, (wcslen (pResult->rItems[0].pDomain) + 1) * sizeof (WCHAR));
        wcscpy ((*ppToplInfo)->pszRootDomain, pResult->rItems[0].pDomain);

        // *******************************************************************************************

        if( pMainInfo->ulFlags & DS_REPSYNCALL_CROSS_SITE_BOUNDARIES ) {
            // Form the Sites container dn from the sites prefix and the configuration NC DN

            pszSitesContainerDn = DsRSAAlloc( heap, sizeof( SITES_PREFIX ) + ((wcslen( ppszConfigurationNC[0] ) + 1) * sizeof( WCHAR )) );
            wcscpy( pszSitesContainerDn, SITES_PREFIX );
            wcscat( pszSitesContainerDn, ppszConfigurationNC[0] );
        }
        else {
            PDSNAME pdsnameTrimmed;
            // ppszServiceName[0] is the DN of the home server's NTDS Settings object.
            // This object is the grandchild of the Servers container, so we use TrimDSNameBy
            // to shorten its DN.
            pdsnameTrimmed = (PDSNAME) DsRSAAlloc (heap, pdsnameHome->structLen);
            TrimDSNameBy (pdsnameHome, 2, pdsnameTrimmed);

            pszSitesContainerDn = DsRSAAlloc( heap, (wcslen( pdsnameTrimmed->StringName ) + 1) * sizeof(WCHAR) );
            wcscpy( pszSitesContainerDn,  pdsnameTrimmed->StringName );
        }

        DPRINT1( 2, "Sites container = %ws\n", pszSitesContainerDn );

        // Now perform the main search to get all applicable servers.  We want references
        // to the servers' NTDS Settings objects.  Note that, because of the filter, on those
        // servers holding the desired NC (either writable or read-only) are included.
        pszNtdsDsaSearchFilter = DsRSAAlloc (heap, (wcslen (pszNtdsDsaSearchTemplate) +
                                     2 * wcslen (pMainInfo->pdsnameNameContext->StringName) + 1) * sizeof (WCHAR));
        swprintf (pszNtdsDsaSearchFilter, pszNtdsDsaSearchTemplate,
            pMainInfo->pdsnameNameContext->StringName,
            pMainInfo->pdsnameNameContext->StringName);
	
        DPRINT1( 2, "Search filter = %ws\n", pszNtdsDsaSearchFilter );

        pDsaSearch = ldap_search_init_pageW(hld,
					pszSitesContainerDn,
					LDAP_SCOPE_SUBTREE,
					pszNtdsDsaSearchFilter,
					ppszNtdsDsaSearch,
					FALSE, NULL, NULL, 0, 0, NULL);
	if(pDsaSearch == NULL){
	    DsRSAChkLdap(LdapGetLastError());
	}

	DsRSAFree (heap, pszNtdsDsaSearchFilter);
        DsRSAFree (heap, pszSitesContainerDn);	

        // *******************************************************************************************

        // Cycle through the applicable servers and add them into the plistNextServer list.

        dwThisId = 0L;      // Start the IDs at 0
		
	dwLdapErr = ldap_get_next_page_s(hld,
					 pDsaSearch,
					 0,
					 DEFAULT_PAGED_SEARCH_PAGE_SIZE,
					 &ulTotalEstimate,
					 &pldmNtdsDsaResults);

        while(dwLdapErr == LDAP_SUCCESS){

            pldmNtdsDsaEntry = ldap_first_entry (hld, pldmNtdsDsaResults);
	    while( pldmNtdsDsaEntry != NULL ) {
		
                pszServerDn = ldap_get_dnW (hld, pldmNtdsDsaEntry);     // The server's DN

                DPRINT1( 3, "ServerDn = %ws\n", pszServerDn );

                // Create a DS_RSAI_SVRINFO structure for this server.
		pSvrInfo = (PDS_RSAI_SVRINFO) DsRSAAlloc (heap, sizeof (DS_RSAI_SVRINFO));
		pSvrInfo->dwId = dwThisId;

                // Cache the Dn in the pSvrInfo structure
                pSvrInfo->pszSvrDn = (LPWSTR) DsRSAAlloc (heap, (wcslen(pszServerDn) + 1)  * sizeof(WCHAR));
                wcscpy(pSvrInfo->pszSvrDn, pszServerDn);

                // Check if this server is a master for this NC (otherwise it is partial)
		pSvrInfo->bIsMaster = FALSE;
		ppszMasterNCs = ldap_get_valuesW (hld, pldmNtdsDsaEntry, L"hasMasterNCs");
		for( lNCAt = 0;
		    ppszMasterNCs && ppszMasterNCs[lNCAt];
		    lNCAt++ ) {
		    pDsname = DsRSAAllocBuildDsname (heap, ppszMasterNCs[lNCAt]);
		    iCmp = DsRSADnCmp (pDsname, pMainInfo->pdsnameNameContext);
		    DsRSAFree (heap, pDsname);
		    if( 0 == iCmp ) {
			pSvrInfo->bIsMaster = TRUE;
			break;
		    }
		}
		ldap_value_freeW (ppszMasterNCs);
		ppszMasterNCs = NULL;

		// Get this server's GUID and store a copy in pSvrInfo.
		ppbvObjectGUID = ldap_get_values_lenW (hld, pldmNtdsDsaEntry, L"objectGUID");
                if (NULL == ppbvObjectGUID) {
                    DsRSAException(ERROR_DS_NO_ATTRIBUTE_OR_VALUE);
                }
		memcpy ((LPVOID) &pSvrInfo->guid, (LPVOID) ppbvObjectGUID[0]->bv_val, ppbvObjectGUID[0]->bv_len);

		// Get this server's GUID DNS.
		pszGuidDNS = DsRSAAllocGuidDNS (heap, (*ppToplInfo)->pszRootDomain, (GUID *) ppbvObjectGUID[0]->bv_val);
		// Create the string in pSvrInfo that will be used to identify this server when reporting errors.
		if( pMainInfo->ulFlags & DS_REPSYNCALL_ID_SERVERS_BY_DN ) {
		    pSvrInfo->pszMsgId = (LPWSTR) DsRSAAlloc (heap, (wcslen (pszServerDn) + 1) * sizeof (WCHAR));
		    wcscpy (pSvrInfo->pszMsgId, pszServerDn);
		}
		else {
		    pSvrInfo->pszMsgId = pszGuidDNS;        // (pszGuidDNS has already been allocated)
		}

		// Check if this server is responding.
		if( (pMainInfo->ulFlags & DS_REPSYNCALL_SKIP_INITIAL_CHECK) ||
		    ((dwWin32Err = DsBindWithCredW (pszGuidDNS, NULL, hRpcai, &hDS)) == NO_ERROR) ) {
                    DPRINT1( 4, "Server %ws is responding.\n", pszServerDn );
		    // Either we're supposed to skip the check, or the check was successful.  Add this
		    // server to the graph.
		    if( !(pMainInfo->ulFlags & DS_REPSYNCALL_SKIP_INITIAL_CHECK) ) {
			DsUnBindW (&hDS);
		    }
		    vertex = ToplVertexCreate ();
		    ToplVertexSetId (vertex, dwThisId);
		    ToplGraphAddVertex ((*ppToplInfo)->toplGraph, vertex, vertex);
		    // Is this the home server?
		    pdsnameServer = DsRSAAllocBuildDsname (heap, pszServerDn);
		    if( 0 == DsRSADnCmp (pdsnameServer, pdsnameHome) ) {
			(*ppToplInfo)->vHome = vertex;
		    }

		    // Insert this server-vertex pair into the SvMap.
		    pSvMapDnToVertex = DsRSASvMapInsert (heap, pSvMapDnToVertex, pdsnameServer, vertex);
		    pSvrInfo->bIsInGraph = TRUE;
		}
		else {
		    // The check was unsuccessful.  Do not add this server to the graph.
		    hDS = NULL;
		    if( !(pMainInfo->ulFlags & DS_REPSYNCALL_SKIP_INITIAL_CHECK) ) {
			DsRSADoError (heap, pMainInfo, pSvrInfo->pszMsgId, DS_REPSYNCALL_WIN32_ERROR_CONTACTING_SERVER, dwWin32Err, NULL);
		    }
		    pSvrInfo->bIsInGraph = FALSE;
		}

		// If pSvrInfo->pszMsgId points to the GUID DNS then we don't need to free it.
		if( pMainInfo->ulFlags & DS_REPSYNCALL_ID_SERVERS_BY_DN ) {
		    DsRSAFree (heap, pszGuidDNS);
		}

		// Insert this pSvrInfo structure into the list of servers.
		plistNextServer = DsRSAListInsert (heap, plistNextServer, (ULONG_PTR) pSvrInfo);

		ldap_value_free_len (ppbvObjectGUID);
		ppbvObjectGUID = NULL;

		ldap_memfreeW (pszServerDn);
		pszServerDn = NULL;

		dwThisId++;
		pldmNtdsDsaEntry = ldap_next_entry (hld, pldmNtdsDsaEntry);

	    }  // while( pldmNtdsDsaEntry != NULL )

	    ldap_msgfree(pldmNtdsDsaResults);
	    pldmNtdsDsaResults = NULL;

	    dwLdapErr = ldap_get_next_page_s(hld,
					     pDsaSearch,
					     0,
					     DEFAULT_PAGED_SEARCH_PAGE_SIZE,
					     &ulTotalEstimate,
					     &pldmNtdsDsaResults);

	} // while there is not error from the next paged search result set.
	
	if(dwLdapErr != LDAP_NO_RESULTS_RETURNED){
	    DsRSAChkLdap(dwLdapErr);
	}
        dwLdapErr = ldap_search_abandon_page(hld, pDsaSearch);
	pDsaSearch = NULL; // subtlty here, need to set NULL, before calling DsRSAChkLdap()
	DsRSAChkLdap(dwLdapErr);

        // Store the total number of servers (including servers that were not added to the graph.)
        DPRINT1( 2, "Servers found = %d\n", dwThisId );
        (*ppToplInfo)->ulSize = (ULONG) dwThisId;
        if (!dwThisId) {
            // No servers found during search - abort
            DsRSAException (ERROR_DS_CANT_FIND_EXPECTED_NC);
        }

	// Convert the DS_RSAI_SVRINFO list into an array.
        (*ppToplInfo)->servers = (PDS_RSAI_SVRINFO *) DsRSAAlloc (heap, dwThisId * sizeof (PDS_RSAI_SVRINFO));
        plistNextServer = plistFirstServer;
        for( ul = 0; plistNextServer->next != NULL; ul++ ) {
            (*ppToplInfo)->servers[ul] = (PDS_RSAI_SVRINFO) plistNextServer->ulpItem;
            plistNextServer = plistNextServer->next;
        }
        DsRSAListDestroy (heap, plistFirstServer);

        // *******************************************************************************************

        // Now add the connections between servers (graph edges.)

        // Code.Improvement: It would be better to do a single subtree search for ntdsaConnection
        //    objects once, instead of issuing one search for each ntdsa object, as is done below
        //    in the inner loop and ldap_search_init_pageW().

        for(ul = 0; ul < (*ppToplInfo)->ulSize; ul++){

            pszServerTempDn = (*ppToplInfo)->servers[ul]->pszSvrDn;

            vHere = DsRSASvMapGetVertex (heap, pSvMapDnToVertex, pszServerTempDn);

            // We only analyze this server if both:
	    // (a) vHere is alive (that is, DsRSASvMapGetVertex did not return NULL);
	    // (b) if DS_REPSYNCALL_SYNC_ADJACENT_SERVERS_ONLY is set, then vHere is home
            //     (i.e. either DS_REPSYNCALL_SYNC_ADJACENT_SERVERS_ONLY is clear or vHere is home.)
            if( vHere != NULL && (     !(pMainInfo->ulFlags & DS_REPSYNCALL_SYNC_ADJACENT_SERVERS_ONLY)
                                       ||  (vHere == (*ppToplInfo)->vHome)) ) {

                // Get all connections directed into this server.
                // The filter enforces only enabled connections
		
                pConnSearch = ldap_search_init_pageW(hld,
                                                     pszServerTempDn,
                                                     LDAP_SCOPE_ONELEVEL,
                                                     pszNtdsConnSearchTemplate,
                                                     ppszConnectionSearch,
                                                     FALSE, NULL, NULL, 0, 0, NULL);
                if(pConnSearch == NULL){
                    DsRSAChkLdap(LdapGetLastError());
                }

                dwInnerLdapErr = ldap_get_next_page_s(hld,
                                                      pConnSearch,
                                                      0,
                                                      DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                                      &ulInnerTotalEstimate,
                                                      &pldmConnectionResults);

                // Cycle through those connections, adding edges to the graph.
                while(dwInnerLdapErr == LDAP_SUCCESS){

                    pldmConnectionEntry = ldap_first_entry (hld, pldmConnectionResults);

                    while( pldmConnectionEntry != NULL ) {

                        ppszTransportType = ldap_get_valuesW (hld, pldmConnectionEntry, L"transportType");
                        if( (ppszTransportType == NULL) ||
                            (_wcsnicmp( ppszTransportType[0], IP_PREFIX, IP_PREFIX_LEN ) == 0) ) {

                            ppszConnectionFrom = ldap_get_valuesW (hld, pldmConnectionEntry, L"fromServer");
                            if (NULL == ppszConnectionFrom) {
                                DsRSAException(ERROR_DS_NO_ATTRIBUTE_OR_VALUE);
                            }

                            // Determine which vertex the connection comes from.
                            vThere = DsRSASvMapGetVertex (heap, pSvMapDnToVertex, ppszConnectionFrom[0]);
                            // We only add this connection if both:
                            // (a) vThere is alive (that is, DsRSASvMapGetVertex did not return NULL);
                            // (b) either vHere is a partialReplica or vThere is a master for this NC.
                            if( vThere != NULL &&
                                ( !(*ppToplInfo)->servers[ToplVertexGetId (vHere )]->bIsMaster ||
                                  (*ppToplInfo)->servers[ToplVertexGetId (vThere)]->bIsMaster) ) {
                                edge = ToplEdgeCreate ();
                                ToplEdgeSetToVertex (edge, vHere);
                                ToplEdgeSetFromVertex (edge, vThere);
                                ToplEdgeAssociate (edge);
                                // Dump edges
                                DPRINT2( 3, "to:%ws <-- from:%ws\n",
                                         pszServerTempDn, ppszConnectionFrom[0] );
                            }
			}
                        if( ppszTransportType ) {
                            ldap_value_freeW (ppszTransportType);
                            ppszTransportType = NULL;
                        }
                        ldap_value_freeW (ppszConnectionFrom);
                        ppszConnectionFrom = NULL;
                        pldmConnectionEntry = ldap_next_entry (hld, pldmConnectionEntry);
                    } // end INNER while (pldmConnectionEntry != NULL)

                    ldap_msgfree (pldmConnectionResults);
                    pldmConnectionResults = NULL;
		
                    dwInnerLdapErr = ldap_get_next_page_s(hld,
                                                          pConnSearch,
                                                          0,
                                                          DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                                          &ulInnerTotalEstimate,
                                                          &pldmConnectionResults);
                } // end INNER page search while loop
                if(dwInnerLdapErr != LDAP_NO_RESULTS_RETURNED){
                    DsRSAChkLdap(dwInnerLdapErr);
                }

                dwInnerLdapErr = ldap_search_abandon_page(hld, pConnSearch);
                pConnSearch = NULL; // subtlty here, need to set NULL, before calling DsRSAChkLdap()
                DsRSAChkLdap(dwInnerLdapErr);

                pldmConnectionResults = NULL;
            } // end if( vHere != ....)

        } // end for each DC get the connections ...


    } __finally {

	if( pDsaSearch )
	    ldap_search_abandon_page(hld, pDsaSearch);
	if( pConnSearch )
	    ldap_search_abandon_page(hld, pConnSearch);
	if( ppszConnectionFrom )
            ldap_value_freeW (ppszConnectionFrom);
        if( pldmConnectionResults )
            ldap_msgfree (pldmConnectionResults);
        if( hDS )
            DsUnBindW (&hDS);
        if( ppszMasterNCs )
            ldap_value_freeW (ppszMasterNCs);
        if( ppbvObjectGUID )
            ldap_value_free_len (ppbvObjectGUID);
        if( pszServerDn )
            ldap_memfreeW (pszServerDn);
        if( pResult )
            DsFreeNameResultW (pResult);
        if( pldmNtdsDsaResults )
            ldap_msgfree (pldmNtdsDsaResults);
        if( ppszRootDNC )
            ldap_value_freeW (ppszRootDNC);
        if( ppszServiceName )
            ldap_value_freeW (ppszServiceName);
        if( ppszConfigurationNC )
            ldap_value_freeW (ppszConfigurationNC);
        if( pldmRootResults )
            ldap_msgfree (pldmRootResults);
        if( pSvMapDnToVertex )
            DsRSASvMapDestroy (heap, pSvMapDnToVertex);

    }

}


VOID
DsRSAToplGraphDestroy (
    TOPL_GRAPH          toplGraph
    ) {

    TOPL_ITERATOR       iter;
    TOPL_VERTEX         vertex;
    DWORD           dwInEdges;
    DWORD           dw;

    // ToplGraphFree doesn't destroy edges, so we must do that manually.
    iter = ToplIterCreate ();
    if( iter != NULL ) {
        ToplGraphSetVertexIter (toplGraph, iter);
        while( (vertex = (TOPL_VERTEX) ToplIterGetObject (iter)) != NULL ) {
            dwInEdges = ToplVertexNumberOfInEdges (vertex);
            for( dw = 0; dw < dwInEdges; dw++ ) {
                ToplEdgeFree (ToplVertexGetInEdge (vertex, dw));
            }
            ToplIterAdvance (iter);
        }
        ToplIterFree (iter);
    }               // If iter is NULL there's not a whole lot we can do.

    ToplGraphFree (toplGraph, TRUE);        // Free the graph & vertices
}

// This cleans the DS_RSAI_TOPLINFO structure returned by DsRSABuildTopology ().

VOID
DsRSAToplInfoDestroy (
    HANDLE          heap,
    PDS_RSAI_TOPLINFO       pToplInfo
    ) {

    ULONG           ul;

    DsRSAToplGraphDestroy (pToplInfo->toplGraph);
    for( ul = 0; ul < pToplInfo->ulSize; ul++ ) {
        DsRSAFree (heap, pToplInfo->servers[ul]->pszMsgId);
        DsRSAFree (heap, pToplInfo->servers[ul]->pszSvrDn);
        DsRSAFree (heap, pToplInfo->servers[ul]);
    }
    DsRSAFree (heap, pToplInfo->servers);
    DsRSAFree (heap, pToplInfo->pszRootDomain);
    DsRSAFree (heap, pToplInfo);

}

/*
 * This routine executes a breadth-first algorithm.  It assigns two properties to each
 * vertex in a directed graph:
 * (a) The length of the shortest path from that vertex to a stated home vertex;
 * (b) The next vertex along that path.
 *
 * The algorithm works as follows.  DsRSAToplAssignDistances identifies only those
 * vertices of distance lMaxDepth from the home vertex.  In order for
 * DsRSAToplAssignDistances to function correctly at lMaxDepth = n, it must already
 * have been called with lMaxDepth = n-1.  It traverses the paths identified by its
 * previous iteration(s) to guarantee that the distances it finds are minimal.
 * For example, if DsRSAToplAssignDistances finds an unidentified vertex with
 * lMaxDepth = 5, it can be guaranteed that no path of length 4 exists from that
 * vertex home, since the vertex was not discovered by any previous iteration.
 * DsRSAToplAssignDistances returns TRUE if new vertices were found, indicating that
 * another iteration may be necessary in order to completely assign distances.
 *
 *	BOOL DsRSAToplAssignDistances (
 *	    IN OUT	PLONG		alDistances,	// Array that stores the min distances
 *	    IN OUT	PDWORD		adwOtherEnds,	// Array that stores the target vertices
 *	    IN		TOPL_VERTEX	vHere,		// The home node
 *	    IN		LONG		lMaxDepth,	// See description above
 *	    IN		LONG		lThisDepth	// The current depth of the search
 *	    )
 */

BOOL
DsRSAToplAssignDistances (
    PLONG           alDistances,
    PDWORD          adwOtherEnds,
    TOPL_VERTEX         vHere,
    LONG            lMaxDepth,
    LONG            lThisDepth,
    ULONG                       ulFlags
    ) {

    BOOL            bAltered;
    DWORD           dwEdges;
    DWORD           dwThisId;
    DWORD           dwNextId;
    DWORD           dw;
    PVERTEX                     vertex;

    bAltered = FALSE;
    if( ulFlags & DS_REPSYNCALL_PUSH_CHANGES_OUTWARD ) {
        dwEdges = ToplVertexNumberOfOutEdges (vHere);
    }
    else {
        dwEdges = ToplVertexNumberOfInEdges (vHere);
    }
    dwThisId = ToplVertexGetId (vHere);

    if( lThisDepth == lMaxDepth-1 ) {
        // We're almost at lMaxDepth.  This means all currently unidentified vertices directed into
        // vHere should be assigned distance lMaxDepth.
        for( dw = 0; dw < dwEdges; dw++ ) {  // Cycle through all in-edges
            // Get the id of the vertex corresponding to this in-edge
            if( ulFlags & DS_REPSYNCALL_PUSH_CHANGES_OUTWARD ) {
                vertex = ToplEdgeGetToVertex (ToplVertexGetOutEdge (vHere, dw));
            }
            else {
                vertex = ToplEdgeGetFromVertex (ToplVertexGetInEdge (vHere, dw));
            }
            dwNextId = ToplVertexGetId (vertex);
            if( alDistances [dwNextId] == -1 ) {     // Not yet identified
                bAltered = TRUE;            // A new vertex has now been discovered
                alDistances [dwNextId] = lMaxDepth; // Assign this vertex distance lMaxDepth
                adwOtherEnds [dwNextId] = dwThisId; // The vertex's target is vHere (source for push)
            }
        }
    }
    else {
        // We haven't reached lMaxDepth yet.  Recursively penetrate further into the graph.  That is,
        // scan through the list of vertices directed into vHere.  For each such vertex, if that
        // vertex's target is vHere, call DsRSAToplAssignDistances with that vertex as home and
        // lThisDepth incremented by 1.  This way we will reach each vertex exactly once in our search
        // and still preserve distance minimality.
        for( dw = 0; dw < dwEdges; dw++ ) {
            if( ulFlags & DS_REPSYNCALL_PUSH_CHANGES_OUTWARD ) {
                vertex = ToplEdgeGetToVertex (ToplVertexGetOutEdge (vHere, dw));
            }
            else {
                vertex = ToplEdgeGetFromVertex (ToplVertexGetInEdge (vHere, dw));
            }
            dwNextId = ToplVertexGetId ( vertex );
            if( dwThisId == adwOtherEnds [dwNextId] )
                bAltered |= DsRSAToplAssignDistances (alDistances,
                                adwOtherEnds,
                                vertex,
                                lMaxDepth,
                                lThisDepth + 1L,
                                ulFlags);
        }
    }
    return bAltered;
}

// Analyze the topology generated by DsRSABuildTopology and construct a set of replications that will
// bring pToplInfo->vHome completely up-to-date.

VOID
DsRSAAnalyzeTopology (
    HANDLE          heap,
    PDS_RSAI_MAININFO       pMainInfo,
    PDS_RSAI_TOPLINFO       pToplInfo,
    PDS_RSAI_REPLIST **     papReps
    ) {

    PLONG           alDistances = NULL;
    PDWORD          adwOtherEnds = NULL;
    LONG            lDepth;
    LONG            lMaxDistance;
    ULONG           ul;
    LONG            l;
    PDS_RSAI_REPLIST *      apreplistPoss = NULL;

    *papReps = NULL;
    lMaxDistance = 0L;

    __try {
        alDistances = (LONG *) DsRSAAlloc (heap, pToplInfo->ulSize * sizeof (LONG));
        adwOtherEnds = (DWORD *) DsRSAAlloc (heap, pToplInfo->ulSize * sizeof (DWORD));

        // Initially all servers are flagged as unreachable (distance = -1).
        for( ul = 0; ul < pToplInfo->ulSize; ul++ )
            alDistances[ul] = -1L;
        alDistances[ToplVertexGetId (pToplInfo->vHome)] = 0L;   // Home vertex has distance 0

        // Iteratively call DsRSAToplAssignDistances until FALSE is returned, incrementing lDepth each time.
        lDepth = 1L;
        while( DsRSAToplAssignDistances (alDistances, adwOtherEnds, pToplInfo->vHome, lDepth++, 0L, pMainInfo->ulFlags) );

        // Determine the maximum distance given by DsRSAToplAssignDistances.
        for( ul = 0; ul < pToplInfo->ulSize; ul++ ) {
            DPRINT2( 2, "alDistances[%d] = %d\n", ul, alDistances[ul] );
            DPRINT2( 2, "adwOtherEnds[%d] = %d\n", ul, adwOtherEnds[ul] );
            if( alDistances[ul] > lMaxDistance ) lMaxDistance = alDistances[ul];
        }
        DPRINT1( 2, "maxDistance = %d\n", lMaxDistance );

    #if DBG
        if( pToplInfo->servers[ToplVertexGetId(pToplInfo->vHome)]->bIsMaster )
            DPRINT( 2, "Home hosts a master replica for this NC.\n" );
        else
            DPRINT( 2, "Home hosts a partial replica for this NC.\n" );
    #endif

        // Compile a list of unreachable nodes.
        // If we're only syncing adjacent nodes, this is irrelevant since all available servers are reachable.
        
	// If we're pulling, then only the masters matter to us, and disconected
        // partials may be ignored.    

	// If we are pushing from a master, everyone should be connected to it to recieve changes, and nothing
	// should be ignored.  If we are pushing from a partial, everything could possibly be ignored.

        if( (!(pMainInfo->ulFlags & DS_REPSYNCALL_SYNC_ADJACENT_SERVERS_ONLY))
	    &&
       	    ( (pToplInfo->servers[ToplVertexGetId(pToplInfo->vHome)]->bIsMaster) 
	      ||
	      (!(pMainInfo->ulFlags & DS_REPSYNCALL_PUSH_CHANGES_OUTWARD))
	    )
	   ) {  
            for( ul = 0L; ul < pToplInfo->ulSize; ul++ ) { 
		if( (alDistances[ul] == -1L) 
		     && 
		     (pToplInfo->servers[ul]->bIsInGraph) 
		     &&
		    (   
		     ( (pMainInfo->ulFlags & DS_REPSYNCALL_PUSH_CHANGES_OUTWARD) 
		       &&
		       (pToplInfo->servers[ToplVertexGetId(pToplInfo->vHome)]->bIsMaster)  
		     )
		     ||
		     ( (!(pMainInfo->ulFlags & DS_REPSYNCALL_PUSH_CHANGES_OUTWARD)) 
		       &&  
		       (pToplInfo->servers[ul]->bIsMaster)  
		     )
		    )
		  ) {    
		    DsRSADoError (heap, pMainInfo, pToplInfo->servers[ul]->pszMsgId, DS_REPSYNCALL_SERVER_UNREACHABLE, NO_ERROR, NULL);
		}
	    }
	}
                // Now we generate the replication pattern.  The idea is as follows.
                // We return an array of (PDS_RSAI_REPLIST)s.  Each element of the array
                // corresponds to a list of replications that may be performed
                // asynchronously.  However, all replications in the first list must
                // be performed before any replications in the second, and so on.
                // Thus each list corresponds to a particular depth in the topology.
                //
                // If the depth is 3 (say), then array[0] will contain the list of
                // 3->2 replications, array[1] 2->1 replications, array[2] 1->0
                // replications and array[3] NULL.  Thus the actual replication
                // issuer need know nothing about the topology.

                // Allocate space for the array, and allocate space for an array of PDS_RSAI_REPLIST objects that
                // track the current location in each list.
        *papReps = (PDS_RSAI_REPLIST *) DsRSAAlloc (heap, (lMaxDistance + 1) * sizeof (PDS_RSAI_REPLIST));
        apreplistPoss = (PDS_RSAI_REPLIST *) DsRSAAlloc (heap, lMaxDistance * sizeof (PDS_RSAI_REPLIST));
        // Initialize each list.
        for( l = 0L; l < lMaxDistance; l++ ) {
            (*papReps)[l] = (PDS_RSAI_REPLIST) DsRSAAlloc (heap, sizeof (DS_RSAI_REPLIST));
            apreplistPoss[l] = (*papReps)[l];
        }
        (*papReps)[lMaxDistance] = NULL;

        // Transfer all the data into the list.
        for( ul = 0L; ul < pToplInfo->ulSize; ul++ ) {
            l = alDistances[ul];
            if( l != -1L && l != 0L ) {  // This node is reachable, and isn't the home vertex
                if( pMainInfo->ulFlags & DS_REPSYNCALL_PUSH_CHANGES_OUTWARD ) {
                    l--;                        // Convert distance (1 based) to index (0 based)
                    apreplistPoss[l]->dwIdSrc = adwOtherEnds[ul];
                    apreplistPoss[l]->dwIdDst = ul;
                }
                else {
                    l = lMaxDistance - l;   // We want the list in reverse order
                    apreplistPoss[l]->dwIdSrc = ul;
                    apreplistPoss[l]->dwIdDst = adwOtherEnds[ul];
                }
                apreplistPoss[l]->next = (PDS_RSAI_REPLIST) DsRSAAlloc (heap, sizeof (DS_RSAI_REPLIST));
                apreplistPoss[l] = apreplistPoss[l]->next;
            }
        }

        // Terminate each list
        for( l = 0; l < lMaxDistance; l++ )
            apreplistPoss[l]->next = NULL;
    }
    __finally {
        if( alDistances )
            DsRSAFree (heap, alDistances);
        if( adwOtherEnds )
            DsRSAFree (heap, adwOtherEnds);
        if( apreplistPoss )
            DsRSAFree (heap, apreplistPoss);
        // The apreplistPoss[i] correspond to part of the (*papReps)[i] lists
        // so we don't need to go through and delete them
        if( AbnormalTermination() ) {
            if( *papReps != NULL ) {
                DsRSAReplicationsFree( heap, *papReps );
                *papReps = NULL;
            }
        }
    }
}

// This destroys a set of replications as generated by DsRSAAnalyzeTopology ().

VOID
DsRSAReplicationsFree (
    HANDLE          heap,
    PDS_RSAI_REPLIST *      apReps
    ) {

    PDS_RSAI_REPLIST        preplistPos;
    PDS_RSAI_REPLIST        preplistTemp;
    LONG            l;

    l = 0;
    if( apReps != NULL )
        while( (preplistPos = apReps[l++]) != NULL )
            while( preplistPos != NULL ) {
                preplistTemp = preplistPos->next;
                DsRSAFree (heap, preplistPos);
                preplistPos = preplistTemp;
            }
}

// This dumps a set of replications as generated by DsRSAAnalyzeTopology ().
#if DBG
VOID
DsRSAReplicationsDump (
    PDS_RSAI_TOPLINFO       pToplInfo,
    PDS_RSAI_REPLIST *      apReps
    ) {

    PDS_RSAI_REPLIST        preplistPos;
    LONG            l;
    ULONG                       index;

    if( pToplInfo != NULL ) {
        DPRINT1( 1, "Servers: %d\n", pToplInfo->ulSize );
        for( index = 0; index < pToplInfo->ulSize; index++ ) {
            DPRINT2( 1, "\t[%d] =%ws", index, pToplInfo->servers[index]->pszMsgId );
            if( pToplInfo->servers[index]->bIsMaster ) {
                DPRINT( 1, " (master)\n" );
            }
            else {
                DPRINT( 1, " (partial)\n" );
            }
        }
    }
    if( apReps != NULL ) {
        DPRINT( 1, "Replication ordering dump:\n" );
        l = 0;
        while( (preplistPos = apReps[l++]) != NULL ) {
            DPRINT1( 1, "Level %d:\n", l );
            while( preplistPos->next != NULL ) {
                DPRINT2(1, "\tDest:%ws <-- Source:%ws\n",
                    pToplInfo->servers[preplistPos->dwIdDst]->pszMsgId,
                    pToplInfo->servers[preplistPos->dwIdSrc]->pszMsgId
                    );
                preplistPos = preplistPos->next;
            }
        }
    }
}
#endif

/*
 * The next few functions are involved with issuing the replications found with DsRSAAnalyzeTopology.
 * Multiple threads are used to permit replications to be issued asynchronously.  Events are used to
 * facilitate communication between threads.  (Also see dsrsa.h.)
 *
 */

// Sets this thread's state to threadState and waits for the primary thread to process that information.

VOID
DsRSASignalAndWait (
    PDS_RSAI_REPINFO        pRepInfo,
    DS_RSAI_THREAD_STATE    threadState
    ) {

    *pRepInfo->pThreadState = threadState;
    SetEvent (pRepInfo->hWaiting);
    WaitForSingleObject (pRepInfo->hReady, INFINITE);
    *pRepInfo->pThreadState = DS_RSAI_THREAD_ACTIVE;
}


// These are some defines for DsRSAIssueXXXXX functions();
#define INVALID_SERVER_INDEX  0xFFFFFFFF
#define MAX_SYNC_PARALLELISM 63

// The entry function of each auxiliary thread.  lpData should point to a DS_RSAI_REPINFO structure.
// This will issue a list of replications with the same destination server.

VOID
__cdecl
DsRSAIssueRep (
    LPVOID          lpData
    ) {
/*++

Routine Description:

    This routin will do a single destination sync.  It runs through the list of source syncs it has to
    do and signals the parent thread (in DsRSAIssueLevelOfReplications()) when finnished

Arguments:

    lpData - This is a little structure holding the destinations server to be syncd, and a list of source servers

Return Value:

--*/
    PDS_RSAI_REPINFO        pRepInfo = (PDS_RSAI_REPINFO) lpData;
    HANDLE          hDS;
    PDS_RSAI_LIST       plistPos;
    *pRepInfo->pdwWin32Err = DsBindWithCredW (pRepInfo->pszDstGuidDNS, NULL, pRepInfo->hRpcai, &hDS);
    if( *pRepInfo->pdwWin32Err != NO_ERROR ) {        // Problem binding!
        // Signal the primary thread that we could not bind to this server
        DsRSASignalAndWait (pRepInfo, DS_RSAI_THREAD_BIND_ERROR);
    }
    else {

        // Iterate through each source server.
        plistPos = pRepInfo->plistSrcs;
        while( plistPos->next != NULL ) {
            // Update pRepInfo so that the primary thread knows which source server is being synced.
            *pRepInfo->pdwSyncAt = ((PDS_RSAI_SVRINFO) plistPos->ulpItem)->dwId;
            DsRSASignalAndWait (pRepInfo, DS_RSAI_THREAD_BEGIN_SYNC);
            if( pRepInfo->bDoSync ) {
                // Perform the actual sync!
                *pRepInfo->pdwWin32Err = DsReplicaSyncW (hDS,
                                             pRepInfo->pdsnameNameContext->StringName,
                                             &((PDS_RSAI_SVRINFO) plistPos->ulpItem)->guid,
                                             DS_REPSYNC_FORCE);
                if( *pRepInfo->pdwWin32Err != NO_ERROR ) {
                    DsRSASignalAndWait (pRepInfo, DS_RSAI_THREAD_SYNC_ERROR);
                }
                else {
                    DsRSASignalAndWait (pRepInfo, DS_RSAI_THREAD_DONE_SYNC);       // The sync was successful.
                }
            }
            else {
                *pRepInfo->pdwWin32Err = ERROR_CANCELLED;               // The user chose not to sync.
                DsRSASignalAndWait (pRepInfo, DS_RSAI_THREAD_SYNC_ERROR);       // (i.e. DS_REPSYNCALL_DO_NOT_SYNC set)
            }
            plistPos = plistPos->next;
        }
        DsUnBindW (&hDS);
    }

    // We're done!
    *pRepInfo->pThreadState = DS_RSAI_THREAD_FINISHED;
    SetEvent (pRepInfo->hWaiting);
    _endthread ();
}

// This issues a set of replications.
// The replications in the list apReps[i] may be issued asynchronously, but all
// replications in apReps[i] must be issued before any in apReps[i+1].

VOID
DsRSAIssueLevelOfReplications (
    HANDLE          heap,
    ULONG                       ulLevelSize,
    PULONG                      pulGlobalToLocal,
    PULONG                      pulLocalToGlobal,
    PDS_RSAI_REPLIST        preplistPos,
    PDS_RSAI_MAININFO       pMainInfo,
    PDS_RSAI_TOPLINFO       pToplInfo,
    PDS_RSAI_REPLIST *      apReps,
    RPC_AUTH_IDENTITY_HANDLE    hRpcai
    )
/*++

Routine Description:

    This routine will take do replications for ulLevelSize destinations, it uses the pulGlobalToLocal and
    pulLocalToGlobal to make the indirection happen that was needed to get around the fact that
    WaitForMultipleObject() can only wait on 64 objects.

Arguments:

    heap - a private heap
    ulLevelSize - The number of destination servers to sync in this level
    pulGlobalToLocal - an array of pToplInfo->ulSize, that maps an index in the array of apReps to an index in
       the arrays to be allocated in this routine for the worker thread.
    pulLocalToGlobal - an array of ulLevelSize, that maps an index from the arrays to be allocated in this routine
       to handle the different threads, and the value returned by WaitForMultipleObject to an array (global) index
       in apReps.
    pMainInfo - the main info for the thing
    pToplInfo - the topology info
    apReps - the different levels of replications that can happen in parrallel.  It is an array of linked lists
        that give all the replications to happen (Dst-Src Pairs)
    hRpcai - handle to the user credentials security structure

Return Value:

--*/
{
    PDS_RSAI_REPINFO        aRepInfo = NULL;
    PDS_RSAI_LIST *     aplistNextSrc = NULL;
    PDWORD          adwWin32Err = NULL;
    PDWORD          adwSyncAt = NULL;
    PDS_RSAI_THREAD_STATE   aThreadState = NULL;
    PHANDLE         ahWaiting = NULL;
    PHANDLE         ahReady = NULL;
    PBOOL           abFinished = NULL;
    BOOL            bAllFinished;

    DS_REPSYNCALL_UPDATEW   update;

    ULONG           ulDummy;
    ULONG           ulDstId;
    ULONG           ulRepNum;
    ULONG           ul;

    if( ulLevelSize == 0 ) {
        return;  // This means this function was called with 0 syncs for it to do in this run.
    }

    __try {

        aRepInfo = (PDS_RSAI_REPINFO) DsRSAAlloc (heap, ulLevelSize * sizeof (DS_RSAI_REPINFO));
        aplistNextSrc = (PDS_RSAI_LIST *) DsRSAAlloc (heap, ulLevelSize * sizeof (PDS_RSAI_LIST));
        ahWaiting = (PHANDLE) DsRSAAlloc (heap, ulLevelSize * sizeof (HANDLE));
        ahReady = (PHANDLE) DsRSAAlloc (heap, ulLevelSize * sizeof (HANDLE));
        adwWin32Err = (PULONG) DsRSAAlloc (heap, ulLevelSize * sizeof (ULONG));
        adwSyncAt = (PDWORD) DsRSAAlloc (heap, ulLevelSize * sizeof (DWORD));
        aThreadState = (PDS_RSAI_THREAD_STATE) DsRSAAlloc (heap, ulLevelSize * sizeof (DS_RSAI_THREAD_STATE));
        abFinished = (PBOOL) DsRSAAlloc (heap, ulLevelSize * sizeof (BOOL));

        for( ulDstId = 0; ulDstId < ulLevelSize; ulDstId++ ) {
            ahReady[ulDstId] = NULL;
            ahWaiting[ulDstId] = NULL;
        }

        // Set up the aRepInfo[i] structures.  These are passed to the auxiliary threads and are used
        // for interthread communications.
        for( ulDstId = 0; ulDstId < ulLevelSize; ulDstId++ ) {
            aRepInfo[ulDstId].bDoSync = (pMainInfo->ulFlags & DS_REPSYNCALL_DO_NOT_SYNC ? FALSE : TRUE);
            aRepInfo[ulDstId].pdsnameNameContext = pMainInfo->pdsnameNameContext;
            aRepInfo[ulDstId].hRpcai = hRpcai;
            Assert(pulLocalToGlobal[ulDstId] != INVALID_SERVER_INDEX);
            aRepInfo[ulDstId].pszDstGuidDNS = DsRSAAllocGuidDNS (heap, pToplInfo->pszRootDomain,
                                                  &pToplInfo->servers[pulLocalToGlobal[ulDstId]]->guid);
            if( (ahReady[ulDstId] = CreateEvent (NULL, FALSE, FALSE, NULL)) == NULL ) {
                DsRSAException (GetLastError ());
            }
            aRepInfo[ulDstId].hReady = ahReady[ulDstId];
            if( (ahWaiting[ulDstId] = CreateEvent (NULL, FALSE, FALSE, NULL)) == NULL ) {
                DsRSAException (GetLastError ());
            }
            aRepInfo[ulDstId].hWaiting = ahWaiting[ulDstId];
            aRepInfo[ulDstId].pdwWin32Err = &(adwWin32Err[ulDstId]);
            aRepInfo[ulDstId].pdwSyncAt = &(adwSyncAt[ulDstId]);
            aRepInfo[ulDstId].pThreadState = &(aThreadState[ulDstId]);
        }

        // Initialization.
        for( ulDstId = 0; ulDstId < ulLevelSize; ulDstId++ ) {
            ResetEvent (ahWaiting[ulDstId]);        // Reset the events.
            ResetEvent (ahReady[ulDstId]);
            // Right now, no destination servers have been assigned any replications so they are all trivially finished.
            abFinished[ulDstId] = TRUE;
            // Initialize the lists of source servers.
            aRepInfo[ulDstId].plistSrcs = (PDS_RSAI_LIST) DsRSAAlloc (heap, sizeof (DS_RSAI_LIST));
            aRepInfo[ulDstId].plistSrcs->next = NULL;
            aplistNextSrc[ulDstId] = aRepInfo[ulDstId].plistSrcs;
        }
        bAllFinished = TRUE;

        // Collate the replications at this iteration by server.  For each replication, add the SvrInfo structure
        // of the source server to the list that corresponds to the destination server's aRepInfo structure.
        while( preplistPos->next != NULL ) {
            if( pulGlobalToLocal[preplistPos->dwIdDst] != INVALID_SERVER_INDEX ) {
                aplistNextSrc[pulGlobalToLocal[preplistPos->dwIdDst]]->ulpItem = (ULONG_PTR) pToplInfo->servers[preplistPos->dwIdSrc];
                aplistNextSrc[pulGlobalToLocal[preplistPos->dwIdDst]]->next = (PDS_RSAI_LIST) DsRSAAlloc (heap, sizeof (DS_RSAI_LIST));
                aplistNextSrc[pulGlobalToLocal[preplistPos->dwIdDst]] = aplistNextSrc[pulGlobalToLocal[preplistPos->dwIdDst]]->next;
                aplistNextSrc[pulGlobalToLocal[preplistPos->dwIdDst]]->next = NULL;
            } // end if one of the destinations we are doing in this invocation of the function.
            preplistPos = preplistPos->next;
        }

        // Issue each list of replications (i.e. create the threads.)
        for( ulDstId = 0; ulDstId < ulLevelSize; ulDstId++ ) {
            // If this server is the destination of some replications, create a thread.
            if( aRepInfo[ulDstId].plistSrcs->next != NULL ) {
                adwWin32Err[ulDstId] = ERROR_INTERNAL_ERROR;
                adwSyncAt[ulDstId] = INVALID_SERVER_INDEX;
                aThreadState[ulDstId] = DS_RSAI_THREAD_ACTIVE;
                abFinished[ulDstId] = FALSE;    // Now this destination server has replications, so it isn't finished.
                bAllFinished = FALSE;
                if( _beginthread (
                    DsRSAIssueRep,
                    0,
                    (LPVOID) (&aRepInfo[ulDstId])) == -1 ) {
                    DsRSAException (GetLastError ());
                }
            }
        }

        // Now continue waiting for the threads to send messages until all threads have finished.
        while( !bAllFinished ) {
            ulDstId = WaitForMultipleObjects (ulLevelSize,
                          ahWaiting,
                          FALSE,
                          INFINITE);
            if( ulDstId == WAIT_FAILED ) DsRSAException (GetLastError ());
            Assert(pulLocalToGlobal[ulDstId] != INVALID_SERVER_INDEX);
            // This is where the global to local redirections are about to get confusing, because adwSyncAt is actually another
            //   redirection vector like LocalToGlobal.
            switch( aThreadState[ulDstId] ) {
                case DS_RSAI_THREAD_ACTIVE:     // Thread is active; no action.
                    break;
                case DS_RSAI_THREAD_BEGIN_SYNC: // Sync begun; issue callback message.
                    DsRSAIssueUpdateSync (heap,
                        pMainInfo,
                        DS_REPSYNCALL_EVENT_SYNC_STARTED,
                        pToplInfo->servers[adwSyncAt[ulDstId]],
                        pToplInfo->servers[pulLocalToGlobal[ulDstId]]);
                    break;
                case DS_RSAI_THREAD_DONE_SYNC:  // Sync finished; issue callback message.
                    DsRSAIssueUpdateSync(heap,
                        pMainInfo,
                        DS_REPSYNCALL_EVENT_SYNC_COMPLETED,
                        pToplInfo->servers[adwSyncAt[ulDstId]],
                        pToplInfo->servers[pulLocalToGlobal[ulDstId]]);
                    break;
                case DS_RSAI_THREAD_SYNC_ERROR: // Error syncing.
                    DsRSADoError (heap,
                        pMainInfo,
                        pToplInfo->servers[pulLocalToGlobal[ulDstId]]->pszMsgId,
                        DS_REPSYNCALL_WIN32_ERROR_REPLICATING,
                        adwWin32Err[ulDstId],
                        pToplInfo->servers[adwSyncAt[ulDstId]]->pszMsgId);
                    break;
                case DS_RSAI_THREAD_BIND_ERROR: // Error binding.
                    // The source parameter is null here because we have not chosen a source yet.
                    // The adwSyncAt[] is not defined at this time.
                    DsRSADoError (heap,
                        pMainInfo,
                        pToplInfo->servers[pulLocalToGlobal[ulDstId]]->pszMsgId,
                        DS_REPSYNCALL_WIN32_ERROR_CONTACTING_SERVER,
                        adwWin32Err[ulDstId],
                        NULL);
                    break;
                case DS_RSAI_THREAD_FINISHED:   // Thread is finished.
                    abFinished[ulDstId] = TRUE;
                    bAllFinished = TRUE;
                    for( ul = 0;bAllFinished && (ul < ulLevelSize); ul++ )   // See if any threads are still unfinished.
                        bAllFinished &= abFinished[ul];
                    break;
                default:
                    break;
            }
            SetEvent (ahReady[ulDstId]);    // Notify the thread that we are done processing it.
        }

        // Initialization.

    } __finally {

        for( ulDstId = 0; ulDstId < ulLevelSize; ulDstId++ ) {

            if( ahReady[ulDstId] != NULL ) CloseHandle (ahReady[ulDstId]);
            if( ahWaiting[ulDstId] != NULL ) CloseHandle (ahWaiting[ulDstId]);

            if( aRepInfo[ulDstId].pszDstGuidDNS != NULL ) DsRSAFree (heap, aRepInfo[ulDstId].pszDstGuidDNS);

            DsRSAListDestroy(heap, aRepInfo[ulDstId].plistSrcs);
        }

        if( abFinished != NULL )
            DsRSAFree (heap, abFinished);
        if( aThreadState != NULL )
            DsRSAFree (heap, aThreadState);
        if( adwSyncAt != NULL )
            DsRSAFree (heap, adwSyncAt);
        if( adwWin32Err != NULL )
            DsRSAFree (heap, adwWin32Err);
        if( ahReady != NULL )
            DsRSAFree (heap, ahReady);
        if( ahWaiting != NULL )
            DsRSAFree (heap, ahWaiting);
        if( aplistNextSrc != NULL )
            DsRSAFree (heap, aplistNextSrc);
        if( aRepInfo != NULL )
            DsRSAFree (heap, aRepInfo);
    }
}


// This issues a set of replications.
// The replications in the list apReps[i] may be issued asynchronously, but all
// replications in apReps[i] must be issued before any in apReps[i+1].

VOID
DsRSAIssueReplications (
    HANDLE          heap,
    PDS_RSAI_MAININFO       pMainInfo,
    PDS_RSAI_TOPLINFO       pToplInfo,
    PDS_RSAI_REPLIST *      apReps,
    RPC_AUTH_IDENTITY_HANDLE    hRpcai
    )
/*++

Routine Description:

    This routine takes each level of destination replications that can happen in parallel and hands them to
    DsRSAIssueLevelOfReplications().  If there are more than ulMaxParallelism destinations, then it will spawn
    off ...IssueLevelOfRep.. early and continue on to finnish that level.

Arguments:

    heap - a private heap
    pMainInfo - the main info for the thing
    pToplInfo - the topology info
    apReps - the different levels of replications that can happen in parrallel.  It is an array of linked lists
        that give all the replications to happen (Dst-Src Pairs)
    hRpcai - the user credentials structure

Return Value:

--*/
{
    ULONG                       ulLevelSize;
    ULONG                       ulMaxParallelism;
    ULONG                       ul, ulTemp, ulRepNum;
    PDS_RSAI_REPLIST            preplistPos;
    // These 3 variables are to redirect for each call to DsRSAIssueLevelOfReplications(), the first two
    //   are reused for each call to ...IssueLevelOfRep..., and they must be reset after each call to it.
    // maps the global list of all servers to the temporary (local) list of servers for one sync level
    PULONG                      pulGlobalToLocal = NULL;
    // maps the temporary list of server back to the global list at any given sync level.
    PULONG                      pulLocalToGlobal = NULL;
    // maps the global list of all servers to the temporary list of servers for one sync level
    PBOOL                       pbDstServerWillBeSyncd = NULL;

    // Set the max parallelism to a reasonable maximum.
    ulMaxParallelism = min(MAXIMUM_WAIT_OBJECTS - 1, MAX_SYNC_PARALLELISM);
    // Uncomment this line to serialize all the Syncs
    //ulMaxParallelism = min(MAXIMUM_WAIT_OBJECTS - 1, 1);

    __try {

        pulGlobalToLocal = (PULONG) DsRSAAlloc (heap, pToplInfo->ulSize * sizeof(ULONG));
        pbDstServerWillBeSyncd = (PBOOL) DsRSAAlloc (heap, pToplInfo->ulSize * sizeof(BOOL));
        pulLocalToGlobal = (PULONG) DsRSAAlloc (heap, ulMaxParallelism * sizeof(ULONG));

        Assert(pulGlobalToLocal != NULL);
        Assert(pbDstServerWillBeSyncd != NULL);
        Assert(pulLocalToGlobal != NULL);

        for( ul = 0; ul < pToplInfo->ulSize; ul++ ) {
            pulGlobalToLocal[ul] = INVALID_SERVER_INDEX;
            pbDstServerWillBeSyncd[ul] = FALSE;
        }
        for( ul = 0; ul < ulMaxParallelism; ul++ ) {
            pulLocalToGlobal[ul] = INVALID_SERVER_INDEX;
        }

        ulRepNum = 0;
        while( preplistPos = apReps[ulRepNum] ) { // Do one level of syncs.

            ulLevelSize = 0;
            while( preplistPos->next != NULL ) { // process each element of the current preplistPos for level ulRepNum

                if( !pbDstServerWillBeSyncd[preplistPos->dwIdDst] ) {
                    pbDstServerWillBeSyncd[preplistPos->dwIdDst] = TRUE;
                    pulGlobalToLocal[preplistPos->dwIdDst] = ulLevelSize;
                    pulLocalToGlobal[ulLevelSize] = preplistPos->dwIdDst;
                    ulLevelSize++;
                }

                Assert(ulLevelSize != INVALID_SERVER_INDEX);

                if( ulLevelSize >= ulMaxParallelism ) {
                    // This is an exceptional case, rarely will there be 63 or more simultaneous
                    //   destination machines that can sync in parallel ... but just in case. :)
                    //   this little section will take care of the current ulMaxParallelism cases
                    //   and reset the counter and move on.

                    DsRSAIssueLevelOfReplications(heap,
                        ulLevelSize,
                        pulGlobalToLocal,
                        pulLocalToGlobal,
                        apReps[ulRepNum],
                        pMainInfo,
                        pToplInfo,
                        apReps,
                        hRpcai);

                    // Clean up - reset the arrays (technically this shouldn't be necessary)
                    for( ul = 0; ul < ulMaxParallelism; ul++ ) {
                        if( pulLocalToGlobal[ul] != INVALID_SERVER_INDEX ) {
                            pulGlobalToLocal[pulLocalToGlobal[ul]] = INVALID_SERVER_INDEX;
                        }
                        pulLocalToGlobal[ul] = INVALID_SERVER_INDEX;
                    }
                    for( ul = 0; ul < pToplInfo->ulSize; ul++ ) {
                        Assert(pulGlobalToLocal[ul] == INVALID_SERVER_INDEX);
                    }
                    for( ul = 0; ul < ulMaxParallelism; ul++ ) {
                        Assert(pulLocalToGlobal[ul] == INVALID_SERVER_INDEX);
                    }

                    ulLevelSize = 0;
                }
                preplistPos = preplistPos->next;


            } // end while processing one sync

            // The normal case is the above while loop will quit without reaching ulMaxParralelism
            //   destination machines.
            DsRSAIssueLevelOfReplications(heap,
                ulLevelSize,
                pulGlobalToLocal,
                pulLocalToGlobal,
                apReps[ulRepNum],
                pMainInfo,
                pToplInfo,
                apReps,
                hRpcai);

            // Clean up
            for( ul = 0; ul < ulLevelSize; ul++ ) {
                if( pulLocalToGlobal[ul] != INVALID_SERVER_INDEX ) {
                    Assert(pulGlobalToLocal[pulLocalToGlobal[ul]] != INVALID_SERVER_INDEX);
                    pulGlobalToLocal[pulLocalToGlobal[ul]] = INVALID_SERVER_INDEX;
                }
                pulLocalToGlobal[ul] = INVALID_SERVER_INDEX;
            }
            for( ul = 0; ul < pToplInfo->ulSize; ul++ ) {
                Assert(pulGlobalToLocal[ul] == INVALID_SERVER_INDEX);
            }
            for( ul = 0; ul < ulMaxParallelism; ul++ ) {
                Assert(pulLocalToGlobal[ul] == INVALID_SERVER_INDEX);
            }

            ulRepNum++;

        } // end while doing whole level

    } __finally {

        if( pulLocalToGlobal != NULL )
            DsRSAFree (heap, pulLocalToGlobal);
        if( pbDstServerWillBeSyncd != NULL )
            DsRSAFree (heap, pbDstServerWillBeSyncd);
        if( pulGlobalToLocal != NULL )
            DsRSAFree (heap, pulGlobalToLocal);

    }
}

// Copy the error list, as an array, into one contiguous block of memory in the local heap.

VOID
DsRSABuildUnicodeErrorArray (
    PDS_RSAI_LIST       plistFirstError,
    PDS_REPSYNCALL_ERRINFOW **  papErrInfo
    ) {
    PDS_REPSYNCALL_ERRINFOW perrinfoCur;
    PDS_RSAI_LIST       plistNextError;
    LPBYTE          lpMemPos, lpMemPosVar, lpMemBaseVar;
    ULONG           ulArraySize;
    ULONG           ulMemRequired;
    ULONG           ul;

    ulArraySize = ulMemRequired = 0L;

    // Compute the size of the array.
    for( plistNextError = plistFirstError;
        plistNextError->next != NULL;
        plistNextError = plistNextError->next ) {
        ulArraySize++;
    }

    // Compute how much memory we'll need.
    // Complex structure looks like this:
    //    array of ulArraySize + 1 PDS_REPSYNCALL_ERRINFOA
    //    array of ulArraySize of DS_REPSYNCALL_ERRINFOA
    //    variable length string storage

    // For the pointers to array objects
    ulMemRequired += (ulArraySize + 1) * sizeof (PDS_REPSYNCALL_ERRINFOW);
    // For the array objects themselves
    ulMemRequired += ulArraySize * sizeof (DS_REPSYNCALL_ERRINFOW);

    for( plistNextError = plistFirstError;
        plistNextError->next != NULL;
        plistNextError = plistNextError->next ) {       // For the strings
        perrinfoCur = (PDS_REPSYNCALL_ERRINFOW) plistNextError->ulpItem;
        ulMemRequired += (wcslen (perrinfoCur->pszSvrId) + 1) * sizeof (WCHAR);
        if( perrinfoCur->pszSrcId != NULL ) {
            ulMemRequired += (wcslen (perrinfoCur->pszSrcId) + 1) * sizeof (WCHAR);
        }
    }

    // *papErrInfo is the base of the array of pointers
    if( (*papErrInfo = LocalAlloc (LMEM_FIXED, ulMemRequired)) == NULL )
        DsRSAException (GetLastError ());

    // Base of the structures
    // lpMemPos - Current position moving forward in array of structures
    lpMemPos = (LPBYTE) (*papErrInfo) + (ulArraySize + 1) * sizeof (PDS_REPSYNCALL_ERRINFOW);
    // lpMemBaseVar - Base of the variable length string storage
    // lpMemPosVar - Current position moving forward in variable storage
    lpMemBaseVar = lpMemPosVar = lpMemPos + ulArraySize * sizeof (DS_REPSYNCALL_ERRINFOW);

    for( ul = 0L, plistNextError = plistFirstError;
        plistNextError->next != NULL;
        ul++, plistNextError = plistNextError->next ) {

        perrinfoCur = (PDS_REPSYNCALL_ERRINFOW) plistNextError->ulpItem;

        Assert( lpMemPos < lpMemBaseVar );
        Assert( ul < ulArraySize );
        (*papErrInfo)[ul] = (PDS_REPSYNCALL_ERRINFOW) lpMemPos;
        lpMemPos += sizeof (DS_REPSYNCALL_ERRINFOW);

        (*papErrInfo)[ul]->error = perrinfoCur->error;
        (*papErrInfo)[ul]->dwWin32Err = perrinfoCur->dwWin32Err;

        Assert( lpMemPosVar < (((LPBYTE) (*papErrInfo)) + ulMemRequired) );
        (*papErrInfo)[ul]->pszSvrId = (LPWSTR) lpMemPosVar;
        wcscpy ((*papErrInfo)[ul]->pszSvrId, perrinfoCur->pszSvrId);
        lpMemPosVar += (wcslen (perrinfoCur->pszSvrId) + 1) * sizeof (WCHAR);

        if( perrinfoCur->pszSrcId != NULL ) {
            Assert( lpMemPosVar < (((LPBYTE) (*papErrInfo)) + ulMemRequired) );
            (*papErrInfo)[ul]->pszSrcId = (LPWSTR) lpMemPosVar;
            wcscpy ((*papErrInfo)[ul]->pszSrcId, perrinfoCur->pszSrcId);
            lpMemPosVar += (wcslen (perrinfoCur->pszSrcId) + 1) * sizeof (WCHAR);
        }
        else {
            (*papErrInfo)[ul]->pszSrcId = NULL;
        }
    }
    (*papErrInfo)[ul] = NULL;               // Null terminator
}

VOID
DsRSABuildANSIErrorArray (
    HANDLE          heap,
    PDS_RSAI_LIST       plistFirstError,
    PDS_REPSYNCALL_ERRINFOA **  papErrInfo
    ) {
    PDS_REPSYNCALL_ERRINFOW perrinfoCur;
    PDS_RSAI_LIST       plistNextError;
    LPBYTE          lpMemPos, lpMemPosVar, lpMemBaseVar;
    LPSTR           pszA;
    ULONG           ulArraySize;
    ULONG           ulMemRequired;
    ULONG           ul;

    ulArraySize = ulMemRequired = 0L;

    // Compute the size of the array.
    for( plistNextError = plistFirstError;
        plistNextError->next != NULL;
        plistNextError = plistNextError->next ) {
        ulArraySize++;
    }

    // Compute how much memory we'll need.
    // Complex structure looks like this:
    //    array of ulArraySize + 1 PDS_REPSYNCALL_ERRINFOA
    //    array of ulArraySize of DS_REPSYNCALL_ERRINFOA
    //    variable length string storage

    // For the pointers to array objects
    ulMemRequired += (ulArraySize + 1) * sizeof (PDS_REPSYNCALL_ERRINFOA);
    // For the array objects themselves
    ulMemRequired += ulArraySize * sizeof (DS_REPSYNCALL_ERRINFOA);

    for( plistNextError = plistFirstError;
        plistNextError->next != NULL;
        plistNextError = plistNextError->next ) {       // For the strings
        perrinfoCur = (PDS_REPSYNCALL_ERRINFOW) plistNextError->ulpItem;
        ulMemRequired += (wcslen (perrinfoCur->pszSvrId) + 1) * sizeof (CHAR);
        if( perrinfoCur->pszSrcId != NULL ) {
            ulMemRequired += (wcslen (perrinfoCur->pszSrcId) + 1) * sizeof (CHAR);
        }
    }

    // *papErrInfo is the base of the array of pointers
    if( (*papErrInfo = LocalAlloc (LMEM_FIXED, ulMemRequired)) == NULL ) {
        DsRSAException (GetLastError ());
    }

    // Base of structures
    // lpMemPos - Current position moving forward in array of structures
    lpMemPos = (LPBYTE) (*papErrInfo) + (ulArraySize + 1) * sizeof (PDS_REPSYNCALL_ERRINFOA);
    // lpMemBaseVar - Base of variable length string storage
    // lpMemPosVar - Current position moving forward in variable storage

    lpMemBaseVar = lpMemPosVar =
        (lpMemPos + (ulArraySize * sizeof (DS_REPSYNCALL_ERRINFOA)));

    for( ul = 0L, plistNextError = plistFirstError;
        plistNextError->next != NULL;
        ul++, plistNextError = plistNextError->next ) {

        perrinfoCur = (PDS_REPSYNCALL_ERRINFOW) plistNextError->ulpItem;
        Assert( lpMemPos < lpMemBaseVar );
        Assert( ul < ulArraySize );
        (*papErrInfo)[ul] = (PDS_REPSYNCALL_ERRINFOA) lpMemPos;
        lpMemPos += sizeof (DS_REPSYNCALL_ERRINFOA);

        (*papErrInfo)[ul]->error = perrinfoCur->error;
        (*papErrInfo)[ul]->dwWin32Err = perrinfoCur->dwWin32Err;

        Assert( lpMemPosVar < (((LPBYTE) (*papErrInfo)) + ulMemRequired) );
        (*papErrInfo)[ul]->pszSvrId = (LPSTR) lpMemPosVar;
        pszA = DsRSAAllocToANSI (heap, perrinfoCur->pszSvrId);
        //
        // PREFIX: PREFIX complains that pszA is never checked for NULL.
        // However, DsRSAAllocToAnsi will throw an exception if it is
        // unable to alloc the necessary memory.  The only other reason
        // that it might return NULL is if perrinfoCur->pszSvrId is NULL.
        // But perrinfoCur->pszSvrId can't be NULL because it comes from
        // papErrInfo which was alloced above.
        //
        Assert( strlen( pszA ) == wcslen( perrinfoCur->pszSvrId ) );
        strcpy ((*papErrInfo)[ul]->pszSvrId, pszA);
        DsRSAFree (heap, pszA);
        lpMemPosVar += (wcslen (perrinfoCur->pszSvrId) + 1) * sizeof (CHAR);

        if( perrinfoCur->pszSrcId != NULL ) {
            Assert( lpMemPosVar < (((LPBYTE) (*papErrInfo)) + ulMemRequired) );
            (*papErrInfo)[ul]->pszSrcId = (LPSTR) lpMemPosVar;
            pszA = DsRSAAllocToANSI (heap, perrinfoCur->pszSrcId);
            Assert( strlen( pszA ) == wcslen( perrinfoCur->pszSrcId ) );
            strcpy ((*papErrInfo)[ul]->pszSrcId, pszA);
            DsRSAFree (heap, pszA);
            lpMemPosVar += (wcslen (perrinfoCur->pszSrcId) + 1) * sizeof (CHAR);
        }
        else {
            (*papErrInfo)[ul]->pszSrcId = NULL;
        }
    }
    (*papErrInfo)[ul] = NULL;               // Null terminator
}

// This is the generic filter expression for the top level dsRRA
// exception handlers.

DWORD
DsRSAGetException (
    EXCEPTION_POINTERS* pExceptPtrs, ULONG *pret) {
    DWORD dwException;
    ULONG_PTR * pExceptInfo;
    ULONG ulErrorCode;

    dwException = pExceptPtrs->ExceptionRecord->ExceptionCode;
    // If it's a DS_RSAI_EXCEPTION then handle it here
    if( dwException != DS_RSAI_EXCEPTION ) {
        *pret = 0;
        return EXCEPTION_CONTINUE_SEARCH;
    }
    pExceptInfo = pExceptPtrs->ExceptionRecord->ExceptionInformation;
    ulErrorCode = (ULONG)pExceptInfo[0];
    DPRINT1( 1, "Handling exception %d\n", ulErrorCode );
    *pret = ulErrorCode;
    return EXCEPTION_EXECUTE_HANDLER;
}

DWORD
DsReplicaSyncAllMain (
    HANDLE          hDS,
    LPCWSTR         pszNameContext,
    ULONG           ulFlags,
    BOOL (__stdcall *       pFnCallBackW) (LPVOID, PDS_REPSYNCALL_UPDATEW),
    BOOL (__stdcall *       pFnCallBackA) (LPVOID, PDS_REPSYNCALL_UPDATEA),
    LPVOID          pCallbackData,
    PDS_REPSYNCALL_ERRINFOW **  papErrInfoW,
    PDS_REPSYNCALL_ERRINFOA **  papErrInfoA
    ) {
    HANDLE          heap;
    LDAP *          hld;
    LPWSTR          lpSvr = NULL;
    RPC_AUTH_IDENTITY_HANDLE    hRpcai = NULL;
    DS_RSAI_MAININFO        mainInfo;
    PDS_RSAI_TOPLINFO       pTopl;
    PDS_RSAI_REPLIST *      apReps;
    PDS_RSAI_LIST       plistFirstError;
    DWORD           dwWin32Err;
    ULONG           ulOptions;

    heap = NULL;
    hld = NULL;
    pTopl = NULL;
    apReps = NULL;
    plistFirstError = NULL;
    dwWin32Err = NO_ERROR;


    if( hDS == NULL ) {
        // can't do anything w/out an opened handle
        return ERROR_INVALID_PARAMETER;
    }

    if( papErrInfoW != NULL ) {
        *papErrInfoW = NULL;        // Set the error structure to NULL -- no errors yet
    }
    if( papErrInfoA != NULL ) {
        *papErrInfoA = NULL;
    }

    __try {

        DsRSAChkErr (DsRSAHeapCreate (&heap));          // Create the heap
        plistFirstError = (PDS_RSAI_LIST) DsRSAAlloc (heap, sizeof (DS_RSAI_LIST));
        plistFirstError->next = NULL;
        mainInfo.pdsnameNameContext = pszNameContext ? DsRSAAllocBuildDsname( heap, pszNameContext ) :
                                      NULL;
        mainInfo.ulFlags = ulFlags;
        mainInfo.pFnCallBackW = pFnCallBackW;
        mainInfo.pFnCallBackA = pFnCallBackA;
        mainInfo.pCallbackData = pCallbackData;
        mainInfo.plistNextError = plistFirstError;

        if ( ((BindState *) hDS)->bindAddr ) {
            // point to target svr
            lpSvr = ((BindState *) hDS)->bindAddr;
            // advance to skip leading backslashes.
            while(*lpSvr == '\\') {
                lpSvr++;
            }
        }
        if( (hld = ldap_initW (lpSvr, LDAP_PORT)) == NULL ) {
            DsRSAException (ERROR_DS_DRA_CONNECTION_FAILED);
        }
        if( ((BindState *) hDS)->hDrs == NULL ) {
            DsRSAException (ERROR_DS_DRA_CONNECTION_FAILED);
        }

        DsRSAChkErr ( RpcBindingInqAuthInfo (NDRCContextBinding ((NDR_CCONTEXT) ((BindState *) hDS)->hDrs),
            NULL, NULL, NULL, &hRpcai, NULL) );

        // use only A record dns name discovery
        ulOptions = PtrToUlong(LDAP_OPT_ON);
        (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );
        // Connect to the LDAP server and build the topology
        DsRSAChkLdap (ldap_bind_sW (hld, NULL, (LPWSTR) hRpcai, LDAP_AUTH_SSPI));

        DsRSABuildTopology (heap, hld, hRpcai, &mainInfo, &pTopl);
        ldap_unbind (hld);

        // Analyze topology and issue replications
        if( pTopl->vHome == NULL ) {
            DsRSAException (ERROR_DS_DRA_BAD_NC);       // The home server is not in this NC
        }
        DsRSAAnalyzeTopology (heap, &mainInfo, pTopl, &apReps);
    #if DBG
        DsRSAReplicationsDump (pTopl, apReps);
    #endif
        // If ABORT_IF_SERVER_UNAVAILABLE and there are any errors, then abort.
        if( (ulFlags & DS_REPSYNCALL_ABORT_IF_SERVER_UNAVAILABLE) && plistFirstError->next != NULL ) {
            DsRSAException (ERROR_CANCELLED);
        }

        DsRSAIssueReplications (heap, &mainInfo, pTopl, apReps, hRpcai);
        if( papErrInfoW != NULL && plistFirstError->next != NULL ) {
            DsRSABuildUnicodeErrorArray (plistFirstError, papErrInfoW);
        }
        if( papErrInfoA != NULL && plistFirstError->next != NULL ) {
            DsRSABuildANSIErrorArray (heap, plistFirstError, papErrInfoA);
        }

        // Cleanup
        DsRSAErrListDestroy (heap, plistFirstError);
        DsRSAReplicationsFree (heap, apReps);
        DsRSAToplInfoDestroy (heap, pTopl);
        DsRSAIssueUpdate (heap, &mainInfo, DS_REPSYNCALL_EVENT_FINISHED, NULL, NULL);
        DsRSAFree (heap, mainInfo.pdsnameNameContext);
        DsRSAHeapDestroy (heap);

    } __except( DsRSAGetException( GetExceptionInformation(), &dwWin32Err ) ) {
        // The topology is not on the heap so we must free it
        if( pTopl && pTopl->toplGraph ) DsRSAToplGraphDestroy (pTopl->toplGraph);
        // The error structure is allocated from the local heap so we must free it
        if( papErrInfoW != NULL && *papErrInfoW != NULL ) {
            LocalFree (*papErrInfoW);
        }
        if( papErrInfoA != NULL && *papErrInfoA != NULL ) {
            LocalFree (*papErrInfoA);
        }
        // We must free the ldap handle also
        if( hld ) {
            ldap_unbind (hld);
        }
        // And the heap . . .
        if( heap ) {
            DsRSAHeapDestroy (heap);
        }
    }

    return dwWin32Err;
}

NTDSAPI
DWORD
WINAPI
DsReplicaSyncAllW (
    HANDLE          hDS,
    LPCWSTR                pszNameContext,
    ULONG           ulFlags,
    BOOL (__stdcall *       pFnCallBack) (LPVOID, PDS_REPSYNCALL_UPDATEW),
    LPVOID          pCallbackData,
    PDS_REPSYNCALL_ERRINFOW **  papErrInfo
    ) {
    return DsReplicaSyncAllMain (
        hDS,
        pszNameContext,
        ulFlags,
        pFnCallBack,
        NULL,
        pCallbackData,
        papErrInfo,
        NULL);
}

NTDSAPI
DWORD
WINAPI
DsReplicaSyncAllA (
    HANDLE          hDS,
    LPCSTR                 pszNameContext,
    ULONG           ulFlags,
    BOOL (__stdcall *       pFnCallBack) (LPVOID, PDS_REPSYNCALL_UPDATEA),
    LPVOID          pCallbackData,
    PDS_REPSYNCALL_ERRINFOA **  papErrInfo
    ) {
    LPWSTR          pszNameContextW;
    DWORD           dwErr;

    pszNameContextW = NULL;
    dwErr = AllocConvertWide (pszNameContext, &pszNameContextW);

    if( dwErr == NO_ERROR ) {
        dwErr = DsReplicaSyncAllMain (
                    hDS,
                    pszNameContextW,
                    ulFlags,
                    NULL,
                    pFnCallBack,
                    pCallbackData,
                    NULL,
                    papErrInfo);

    }
    if( pszNameContextW != NULL ) {
        LocalFree (pszNameContextW);
    }

    return dwErr;
}
//
// -----
// NOT SUPPORTED IN WIN95
// -----
//
#else !WIN95 && !WINNT4
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <windows.h>
    #include <rpc.h>
    #include <drs.h>
NTDSAPI
DWORD
WINAPI
DsReplicaSyncAllW (
    HANDLE                      hDS,
    LPCWSTR                pszNameContext,
    ULONG                       ulFlags,
    BOOL (__stdcall *           pFnCallBack) (LPVOID, PDS_REPSYNCALL_UPDATEW),
    LPVOID                      pCallbackData,
    PDS_REPSYNCALL_ERRINFOW **  papErrInfo
    ) {
    return ERROR_NOT_SUPPORTED;
}
NTDSAPI
DWORD
WINAPI
DsReplicaSyncAllA (
    HANDLE                      hDS,
    LPCSTR                 pszNameContext,
    ULONG                       ulFlags,
    BOOL (__stdcall *           pFnCallBack) (LPVOID, PDS_REPSYNCALL_UPDATEA),
    LPVOID                      pCallbackData,
    PDS_REPSYNCALL_ERRINFOA **  papErrInfo
    ) {
    return ERROR_NOT_SUPPORTED;
}
#endif !WIN95 && !WINNT4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsapi\dsrsa.h ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dsrsa.h

ABSTRACT:

    Header file for dsrsa.c.

DETAILS:

CREATED:

    06/30/98	Aaron Siegel (t-asiege)

REVISION HISTORY:

--*/

#ifndef _DSRSA_H_
#define _DSRSA_H_

// Debugging support

ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );

#if DBG
#define DPRINT( level, format ) if (gdwDsRSADbgLevel >= level) DbgPrint( format )
#define DPRINT1( level, format, arg1 ) if (gdwDsRSADbgLevel >= level) DbgPrint( format, arg1 )
#define DPRINT2( level, format, arg1, arg2 ) if (gdwDsRSADbgLevel >= level) DbgPrint( format, arg1, arg2 )
#else
#define DPRINT( level, format ) 
#define DPRINT1( level, format, arg1 ) 
#define DPRINT2( level, format, arg1, arg2 ) 
#endif

// This is the format of the exception
// Bits 31, 30    11 for severity of error
// Bit 29         1 for application
// Bit 28         0 reserved
// remaining high word = facility = 2
// low word = code in facility = 1
#define DS_RSAI_EXCEPTION	0xE0020001

// DS_REPSYNCALL_* refers to public datatypes / constants / structures.
// DS_RSAI_* refers to internal datatypes / constants / structures.  (RepSyncAll Internal)

typedef enum {

	DS_RSAI_THREAD_ACTIVE,			// Currently active
	DS_RSAI_THREAD_BEGIN_SYNC,		// About to perform a sync
	DS_RSAI_THREAD_DONE_SYNC,		// Just finished performing a sync
	DS_RSAI_THREAD_BIND_ERROR,		// Encountered a bind error
	DS_RSAI_THREAD_SYNC_ERROR,		// Encountered a sync error
	DS_RSAI_THREAD_FINISHED			// Finished

} DS_RSAI_THREAD_STATE, * PDS_RSAI_THREAD_STATE;

struct _DS_RSAI_LIST {
    struct _DS_RSAI_LIST *	next;
    ULONG_PTR			ulpItem;
} typedef DS_RSAI_LIST, * PDS_RSAI_LIST;

struct _DS_RSAI_SVMAP {
    struct _DS_RSAI_SVMAP *	left;
    struct _DS_RSAI_SVMAP *	right;
    PDSNAME			pDsname;
    TOPL_VERTEX			vertex;
} typedef DS_RSAI_SVMAP, * PDS_RSAI_SVMAP;

struct _DS_RSAI_REPLIST {
    struct _DS_RSAI_REPLIST *	next;
    DWORD			dwIdSrc;
    DWORD			dwIdDst;
} typedef DS_RSAI_REPLIST, * PDS_RSAI_REPLIST;

typedef struct {
    DWORD			dwId;
    GUID			guid;
    LPWSTR			pszMsgId;
    LPWSTR                      pszSvrDn;
    BOOL			bIsInGraph;
    BOOL			bIsMaster;
} DS_RSAI_SVRINFO, * PDS_RSAI_SVRINFO;

typedef struct {
    TOPL_GRAPH			toplGraph;
    TOPL_VERTEX			vHome;
    ULONG			ulSize;			// Number of servers; not necessarily number of nodes in topl
    LPWSTR			pszRootDomain;
    PDS_RSAI_SVRINFO *		servers;		// Array of SvrInfo structures
} DS_RSAI_TOPLINFO, * PDS_RSAI_TOPLINFO;

typedef struct {
    BOOL			bDoSync;		// TRUE if we should sync; false otherwise
    PDSNAME			pdsnameNameContext;	// The naming context.
    LPWSTR			pszDstGuidDNS;		// The destination server name.
    PDS_RSAI_LIST		plistSrcs;		// A list of source server SvrInfos.
    HANDLE			hReady;			// Event that is set if it's ok for the thread to act
    HANDLE			hWaiting;		// Event that the thread sets when it is waiting
    PDWORD			pdwWin32Err;		// Win32 error code
    PDWORD			pdwSyncAt;		// id of the server currently syncing from
    PDS_RSAI_THREAD_STATE	pThreadState;		// state of this thread
    RPC_AUTH_IDENTITY_HANDLE    hRpcai;                 // handle to the user credentials structure
} DS_RSAI_REPINFO, * PDS_RSAI_REPINFO;

typedef struct {
    PDSNAME			pdsnameNameContext;
    ULONG			ulFlags;
    BOOL (__stdcall *		pFnCallBackW) (LPVOID, PDS_REPSYNCALL_UPDATEW);
    BOOL (__stdcall *		pFnCallBackA) (LPVOID, PDS_REPSYNCALL_UPDATEA);
    LPVOID			pCallbackData;
    PDS_RSAI_LIST		plistNextError;
} DS_RSAI_MAININFO, * PDS_RSAI_MAININFO;

// Prototypes

VOID
DsRSAException (
    DWORD			dwWin32Err
    );

LPVOID
DsRSAAlloc (
    HANDLE			heap,
    DWORD			dwBytes
    );

PDS_RSAI_LIST
DsRSAListInsert (
    HANDLE          heap,
    PDS_RSAI_LIST   pList,
    ULONG_PTR       dwData
    );

VOID
DsRSAListDestroy (
    HANDLE			heap,
    PDS_RSAI_LIST		pList
    );

LPSTR
DsRSAAllocToANSI (
    HANDLE			heap,
    LPWSTR			pszW
    );

BOOL
DsRSAIssueANSIUpdate (
    HANDLE			heap,
    BOOL (__stdcall *		pFnCallBackA) (LPVOID, PDS_REPSYNCALL_UPDATEA),
    LPVOID			pCallbackData,
    PDS_REPSYNCALL_UPDATEW	pUpdateW
    );

VOID
DsRSAIssueUpdate (
    HANDLE			heap,
    PDS_RSAI_MAININFO		pMainInfo,
    DS_REPSYNCALL_EVENT		event,
    PDS_REPSYNCALL_ERRINFOW	pErrInfo,
    PDS_REPSYNCALL_SYNCW	pSync
    );

VOID
DsRSAIssueUpdateSync (
    HANDLE			heap,
    PDS_RSAI_MAININFO		pMainInfo,
    DS_REPSYNCALL_EVENT		event,
    PDS_RSAI_SVRINFO            pSrcSvrInfo,
    PDS_RSAI_SVRINFO            pDstSvrInfo
    );

VOID
DsRSADoError (
    HANDLE			heap,
    PDS_RSAI_MAININFO		pMainInfo,
    LPWSTR			pszSvrId,
    DS_REPSYNCALL_ERROR		error,
    DWORD			dwWin32Err,
    LPWSTR			pszSrcId
    );

VOID
DsRSAErrListDestroy (
    HANDLE			heap,
    PDS_RSAI_LIST		plistFirstError
    );

VOID
DsRSASvMapUpdate (
    HANDLE			heap,
    PDS_RSAI_SVMAP		pSvMap,
    PDSNAME			pDsname,
    TOPL_VERTEX			vertex
    );

PDS_RSAI_SVMAP
DsRSASvMapCreate (
    HANDLE			heap,
    PDSNAME			pDsname,
    TOPL_VERTEX			vertex
    );

PDS_RSAI_SVMAP
DsRSASvMapInsert (
    HANDLE			heap,
    PDS_RSAI_SVMAP		pSvMap,
    PDSNAME			pDsname,
    TOPL_VERTEX			vertex
);

TOPL_VERTEX
DsRSASvMapGetVertex (
    HANDLE			heap,
    PDS_RSAI_SVMAP		pSvMap,
    LPWSTR			pszDn
);

VOID
DsRSASvMapDestroy (
    HANDLE			heap,
    PDS_RSAI_SVMAP		pSvMap
);

LPWSTR
DsRSADnStartAtNth (
    LPWSTR			pszDn,
    INT				iN
);

LPWSTR
DsRSAToGuidDNS (
    HANDLE			heap,
    LPWSTR			pszRootDomain,
    GUID *			pGuid
);

VOID
DsRSABuildTopology (
    HANDLE			heap,
    LDAP *			hld,
    RPC_AUTH_IDENTITY_HANDLE    hRpcai,
    PDS_RSAI_MAININFO		pMainInfo,
    PDS_RSAI_TOPLINFO *		ppToplInfo
);

VOID
DsRSAToplInfoDestroy (
    HANDLE			heap,
    PDS_RSAI_TOPLINFO		pToplInfo
);

BOOL
DsRSAToplAssignDistances (
    PLONG			alDistances,
    PDWORD			adwTargets,
    TOPL_VERTEX			vHere,
    LONG			lMaxDepth,
    LONG			lThisDepth,
    ULONG                       ulFlags
);

VOID
DsRSAAnalyzeTopology (
    HANDLE			heap,
    PDS_RSAI_MAININFO		pMainInfo,
    PDS_RSAI_TOPLINFO		pToplInfo,
    PDS_RSAI_REPLIST **		papReps
);

VOID
DsRSAReplicationsFree (
    HANDLE			heap,
    PDS_RSAI_REPLIST *		apReps
);

VOID
DsRSAWaitOnState (
    PDS_RSAI_THREAD_STATE	pThreadState
);

VOID __cdecl
DsRSAIssueRep (
    LPVOID			lpData
);

VOID
DsRSAIssueReplications (
    HANDLE			heap,
    PDS_RSAI_MAININFO		pMainInfo,
    PDS_RSAI_TOPLINFO		pToplInfo,
    PDS_RSAI_REPLIST *		apReps,
    RPC_AUTH_IDENTITY_HANDLE    hRpcai
);

VOID
DsRSABuildUnicodeErrorArray (
    PDS_RSAI_LIST		plistFirstError,
    PDS_REPSYNCALL_ERRINFOW **	papErrInfo
);

VOID
DsRSABuildANSIErrorArray (
    HANDLE			heap,
    PDS_RSAI_LIST		plistFirstError,
    PDS_REPSYNCALL_ERRINFOA **	papErrInfo
);

DWORD
DsReplicaSyncAllMain (
    HANDLE			hDS,
    LPCWSTR                     pszNameContext,
    ULONG			ulFlags,
    BOOL (__stdcall *		pFnCallBackW) (LPVOID, PDS_REPSYNCALL_UPDATEW),
    BOOL (__stdcall *		pFnCallBackA) (LPVOID, PDS_REPSYNCALL_UPDATEA),
    LPVOID			pCallbackData,
    PDS_REPSYNCALL_ERRINFOW **	papErrInfoW,
    PDS_REPSYNCALL_ERRINFOA **	papErrInfoA
);

#endif	// _DSRSA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsapi\main.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    main.c

Abstract:

   DLL entry point

Author:

    Will Lees (wlees) 21-Jan-1998

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#pragma hdrstop

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>            // RPC defines
#include <drs.h>            // DSNAME
#include "util.h"           // TerminateWinSock
#include "dsdebug.h"        // DsDebug Subsystem
#include "tlog.h"           // ds logging

BOOL
WINAPI
DllMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL
     )
/*++

 Routine Description:

   This function DllLibMain() is the main initialization function for
    this DLL. It initializes local variables and prepares it to be invoked
    subsequently.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.
--*/
{
    BOOL  fReturn = TRUE;

    switch (fdwReason )
    {
    case DLL_PROCESS_ATTACH:
    {
        // Intialize DsLogEntry (functionality exists only in chk'ed builds)
        INITDSLOG();

        //
        // Initialize debug output (CHK builds only)
        // InitDsLog() MUST PRECEED THIS CALL!
        //
        INIT_DS_DEBUG();

        // don't call us back for thread creations/deaths
        DisableThreadLibraryCalls(hinstDll);
        break;
    }
    case DLL_PROCESS_DETACH:
    {
        TerminateWinsockIfNeeded();

        //
        // Terminate debug output (CHK builds only)
        //
        TERMINATE_DS_DEBUG();

        // cleanup DsLogEntry (functionality exists only in chk'ed builds)
        TERMDSLOG();
        break;
    }
    default:
        break;
    }   /* switch */

    return ( fReturn);
}  /* DllLibMain() */

/* end main.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsapi\parsedn.c ===
/*++

Copyright (c) 1987-1997 Microsoft Corporation

Module Name:

    parsedn.c

Abstract:

    This file is a superset of ds\src\dsamain\src\parsedn.c by virtue
    of #include of the aforementioned source file.  The idea is that
    the ntdsapi.dll client needs to do some client side DN parsing and
    we do not want to duplicate the code.  And build.exe won't find
    files any other place than in the directory being built or the
    immediate parent directory.

    This file additionally defines some no-op functions which otherwise
    would result in unresolved external references.

Author:

    Dave Straube    (davestr)   26-Oct-97

Revision History:

    Dave Straube    (davestr)   26-Oct-97
        Genesis  - #include of src\dsamain\src\parsedn.c and no-op DoAssert().

--*/

// Define the symbol which turns off varios capabilities in the original
// parsedn.c which we don't need or would take in too many helpers which we
// don't want on the client side.  For example, we disable recognition of
// "OID=1.2.3.4" type tags and any code which uses THAlloc/THFree.

#define CLIENT_SIDE_DN_PARSING 1

// Include the original source in all its glory.

#include "..\ntdsa\src\parsedn.c"

// Provide stubs for what would otherwise be unresolved externals.

void 
DoAssert(
    char    *szExp, 
    char    *szFile, 
    int     nLine)
{
    char    *msg;
    char    *format = "\n*** Assertion failed: %s\n*** File: %s, line: %ld\n";
    HWND    hWindow;

#if DBG

    // Emit message at debugger and put up a message box.  Developer
    // can attach to client process before selecting 'OK' if he wants
    // to debug the problem.

#ifndef WIN95
    DbgPrint(format, szExp, szFile, nLine);
    DbgBreakPoint();
#endif
    msg = alloca(strlen(szExp) + strlen(szFile) + 40);
    sprintf(msg, format, szExp, szFile, nLine);

    if ( NULL != (hWindow = GetFocus()) )
    {
        MessageBox(
            hWindow, 
            msg, 
            "Assert in NTDSAPI.DLL", 
            MB_APPLMODAL | MB_DEFAULT_DESKTOP_ONLY | MB_OK | MB_SETFOREGROUND);
    }
        
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsapi\rdn.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rdn.c

Abstract:

    Implementation of DsQuoteRdnValue/DsUnquoteRdnValue API and
    helper functions.

Author:

    BillyF     30-Apr-99

Environment:

    User Mode - Win32

Revision History:

--*/

#define _NTDSAPI_       // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <rpc.h>        // RPC defines
#include <drs.h>        // wire function prototypes
#include "util.h"       // ntdsapi private routines

#define DEBSUB  "NTDSAPI_RDN"


NTDSAPI
DWORD
WINAPI
DsQuoteRdnValueA(
    IN     DWORD    cUnquotedRdnValueLength,
    IN     LPCCH    psUnquotedRdnValue,
    IN OUT DWORD    *pcQuotedRdnValueLength,
    OUT    LPCH     psQuotedRdnValue
    )
/*++

Description
Arguments:
Return Value:

    See DsQuoteRdnValueW()

--*/
{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   Number;
    DWORD   QuotedRdnValueLengthW;
    PWCHAR  QuotedRdnValueW = NULL;
    PWCHAR  UnquotedRdnValueW = NULL;

    __try {
        //
        // Verify Input
        //
        if ( (cUnquotedRdnValueLength == 0) ||
             (psUnquotedRdnValue == NULL) ||
             (pcQuotedRdnValueLength == NULL) ||
             ( (psQuotedRdnValue == NULL) && (*pcQuotedRdnValueLength != 0) ) ) {
            Status = ERROR_INVALID_PARAMETER;
            __leave;
        }

        //
        // Convert unquoted RDN into WCHAR
        //
        Status = AllocConvertWideBuffer(cUnquotedRdnValueLength,
                                        psUnquotedRdnValue,
                                        &UnquotedRdnValueW);
        if (Status != ERROR_SUCCESS) {
            __leave;
        }

        //
        // Allocate a WCHAR output buffer for the quoted RDN (if needed)
        //
        QuotedRdnValueLengthW = *pcQuotedRdnValueLength;
        if (QuotedRdnValueLengthW) {
            QuotedRdnValueW = LocalAlloc(LPTR,
                                    QuotedRdnValueLengthW * sizeof(WCHAR));
            if (QuotedRdnValueW == NULL) {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                __leave;
            }
        }

        //
        // Call WCHAR version of DsQuoteRdnValue()
        //
        Status = DsQuoteRdnValueW(cUnquotedRdnValueLength,
                                  UnquotedRdnValueW,
                                  &QuotedRdnValueLengthW,
                                  QuotedRdnValueW);
        if (Status != ERROR_SUCCESS) {
            if (Status == ERROR_BUFFER_OVERFLOW) {
                //
                // return needed length
                //
                *pcQuotedRdnValueLength = QuotedRdnValueLengthW;
            }
            __leave;
        }

        //
        // Convert quoted RDN value into multi-byte
        //

        if (psQuotedRdnValue) {
            Number = WideCharToMultiByte(CP_ACP,
                                         0,
                                         QuotedRdnValueW,
                                         QuotedRdnValueLengthW,
                                         (LPSTR)psQuotedRdnValue,
                                         *pcQuotedRdnValueLength,
                                         NULL,
                                         NULL);
            if (Number == 0) {
                Status = ERROR_INVALID_PARAMETER;
                __leave;
            }
        }

        //
        // Return number of characters
        //
        *pcQuotedRdnValueLength = Number;

        //
        // SUCCESS
        //
        Status = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        Status = ERROR_INVALID_PARAMETER;
    }

    //
    // CLEANUP
    //
    __try {
        if (UnquotedRdnValueW != NULL) {
            LocalFree(UnquotedRdnValueW);
        }
        if (QuotedRdnValueW != NULL) {
            LocalFree(QuotedRdnValueW);
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
    return Status;
}


NTDSAPI
DWORD
WINAPI
DsQuoteRdnValueW(
    IN     DWORD    cUnquotedRdnValueLength,
    IN     LPCWCH   psUnquotedRdnValue,
    IN OUT DWORD    *pcQuotedRdnValueLength,
    OUT    LPWCH    psQuotedRdnValue
    )
/*++
    CHANGES TO THIS HEADER SHOULD BE RELFECTED IN NTDSAPI.H.

Description

    This client call converts an RDN value into a quoted RDN value if
    the RDN value contains characters that require quotes. The resultant
    RDN can be submitted as part of a DN to the DS using various APIs
    such as LDAP.

    No quotes are added if none are needed. In this case, the
    output RDN value will be the same as the input RDN value.

    Quotes are needed if:
        - There are leading or trailing spaces
        - There are special charcters (See ISSPECIAL()). The special
          chars are escaped.
        - There are embedded \0's (string terminators)

    The input and output RDN values are *NOT* NULL terminated.

    The changes made by this call can be undone by calling
    DsUnquoteRdnValue().

Arguments:

    cUnquotedRdnValueLength - The length of psUnquotedRdnValue in chars.

    psUnquotedRdnValue - Unquoted RDN value.

    pcQuotedRdnValueeLength - IN, maximum length of psQuotedRdnValue, in chars
                        OUT ERROR_SUCCESS, chars utilized in psQuotedRdnValue
                        OUT ERROR_BUFFER_OVERFLOW, chars needed in psQuotedRdnValue

    psQuotedRdnValue - The resultant and perhaps quoted RDN value

Return Value:
    ERROR_SUCCESS
        If quotes or escapes were needed, then psQuotedRdnValue contains
        the quoted, escaped version of psUnquotedRdnValue. Otherwise,
        psQuotedRdnValue contains a copy of psUnquotedRdnValue. In either
        case, pcQuotedRdnValueLength contains the space utilized, in chars.

    ERROR_BUFFER_OVERFLOW
        psQuotedRdnValueLength contains the space needed, in chars,
        to hold psQuotedRdnValue.

    ERROR_INVALID_PARAMETER
        Invalid parameter.

    ERROR_NOT_ENOUGH_MEMORY
        Allocation error.

--*/
{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   Number;
    __try {
        //
        // Verify Input
        //
        if ( (cUnquotedRdnValueLength == 0) ||
             (psUnquotedRdnValue == NULL) ||
             (pcQuotedRdnValueLength == NULL) ||
             ( (psQuotedRdnValue == NULL) && (*pcQuotedRdnValueLength != 0) ) ) {
            Status = ERROR_INVALID_PARAMETER;
            __leave;
        }
        //
        // Convert unquoted RDN into quoted RDN (if quotes are needed)
        //
        Number = QuoteRDNValue(psUnquotedRdnValue,
                               cUnquotedRdnValueLength,
                               psQuotedRdnValue,
                               *pcQuotedRdnValueLength);
        if (Number == 0) {
            Status = ERROR_INVALID_PARAMETER;
            __leave;
        }
        //
        // Output buffer is too small
        //
        if (Number > *pcQuotedRdnValueLength) {
            //
            // Return number of chars needed
            //
            *pcQuotedRdnValueLength = Number;
            Status = ERROR_BUFFER_OVERFLOW;
            __leave;
        }

        //
        // Return number of chars converted
        //
        *pcQuotedRdnValueLength = Number;

        //
        // SUCCESS
        //
        Status = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        Status = ERROR_INVALID_PARAMETER;
    }

    //
    // CLEANUP
    //
    return Status;
}


NTDSAPI
DWORD
WINAPI
DsUnquoteRdnValueA(
    IN     DWORD    cQuotedRdnValueLength,
    IN     LPCCH    psQuotedRdnValue,
    IN OUT DWORD    *pcUnquotedRdnValueLength,
    OUT    LPCH     psUnquotedRdnValue
    )
/*++

Description
Arguments:
Return Value:

    See DsUnquoteRdnValueW()

--*/
{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   Number;
    DWORD   UnquotedRdnValueLengthW;
    PWCHAR  UnquotedRdnValueW = NULL;
    PWCHAR  QuotedRdnValueW = NULL;

    __try {
        //
        // Verify Input
        //
        if ( (cQuotedRdnValueLength == 0) ||
             (psQuotedRdnValue == NULL) ||
             (pcUnquotedRdnValueLength == NULL) ||
             ( (psUnquotedRdnValue == NULL) && (*pcUnquotedRdnValueLength != 0) ) ) {
            Status = ERROR_INVALID_PARAMETER;
            __leave;
        }

        //
        // Convert quoted RDN into WCHAR
        //
        Status = AllocConvertWideBuffer(cQuotedRdnValueLength,
                                        psQuotedRdnValue,
                                        &QuotedRdnValueW);
        if (Status != ERROR_SUCCESS) {
            __leave;
        }

        //
        // Allocate a WCHAR output buffer for the unquoted RDN (if needed)
        //
        UnquotedRdnValueLengthW = *pcUnquotedRdnValueLength;
        if (UnquotedRdnValueLengthW) {
            UnquotedRdnValueW = LocalAlloc(LPTR,
                                      UnquotedRdnValueLengthW * sizeof(WCHAR));
            if (UnquotedRdnValueW == NULL) {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                __leave;
            }
        }

        //
        // Call WCHAR version of DsQuoteRdnValue()
        //
        Status = DsUnquoteRdnValueW(cQuotedRdnValueLength,
                                    QuotedRdnValueW,
                                    &UnquotedRdnValueLengthW,
                                    UnquotedRdnValueW);
        if (Status != ERROR_SUCCESS) {
            if (Status == ERROR_BUFFER_OVERFLOW) {
                // return needed length
                *pcUnquotedRdnValueLength = UnquotedRdnValueLengthW;
            }
            __leave;
        }

        //
        // Convert quoted RDN into multi-byte
        //

        if (psUnquotedRdnValue) {
            Number = WideCharToMultiByte(CP_ACP,
                                         0,
                                         UnquotedRdnValueW,
                                         UnquotedRdnValueLengthW,
                                         (LPSTR)psUnquotedRdnValue,
                                         *pcUnquotedRdnValueLength,
                                         NULL,
                                         NULL);
            if (Number == 0) {
                Status = ERROR_INVALID_PARAMETER;
                __leave;
            }
        }

        //
        // Return number of characters
        //
        *pcUnquotedRdnValueLength = Number;

        //
        // SUCCESS
        //
        Status = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        Status = ERROR_INVALID_PARAMETER;
    }

    //
    // CLEANUP
    //
    __try {
        if (QuotedRdnValueW != NULL) {
            LocalFree(QuotedRdnValueW);
        }
        if (UnquotedRdnValueW != NULL) {
            LocalFree(UnquotedRdnValueW);
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
    return Status;
}


NTDSAPI
DWORD
WINAPI
DsUnquoteRdnValueW(
    IN     DWORD    cQuotedRdnValueLength,
    IN     LPCWCH   psQuotedRdnValue,
    IN OUT DWORD    *pcUnquotedRdnValueLength,
    OUT    LPWCH    psUnquotedRdnValue
    )
/*++
    CHANGES TO THIS HEADER SHOULD BE RELFECTED IN NTDSAPI.H.

Description

    This client call converts a quoted RDN Value into an unquoted RDN
    Value. The resultant RDN value should *NOT* be submitted as part
    of a DN to the DS using various APIs such as LDAP.

    When psQuotedRdnValue is quoted:
        The leading and trailing quote are removed.

        Whitespace before the first quote is discarded.

        Whitespace trailing the last quote is discarded.

        Escapes are removed and the char following the escape is kept.

    The following actions are taken when psQuotedRdnValue is unquoted:

        Leading whitespace is discarded.

        Trailing whitespace is kept.

        Escaped non-special chars return an error.

        Unescaped special chars return an error.

        RDN values beginning with # (ignoring leading whitespace) are
        treated as a stringized BER value and converted accordingly.

        Escaped hex digits (\89) are converted into a binary byte (0x89).

        Escapes are removed from escaped special chars.

    The following actions are always taken:
        Escaped special chars are unescaped.

    The input and output RDN values are not NULL terminated.

Arguments:

    cQuotedRdnValueLength - The length of psQuotedRdnValue in chars.

    psQuotedRdnValue - RDN value that may be quoted and may be escaped.

    pcUnquotedRdnValueLength - IN, maximum length of psUnquotedRdnValue, in chars
                          OUT ERROR_SUCCESS, chars used in psUnquotedRdnValue
                          OUT ERROR_BUFFER_OVERFLOW, chars needed for psUnquotedRdnValue

    psUnquotedRdnValue - The resultant unquoted RDN value.

Return Value:
    ERROR_SUCCESS
        psUnquotedRdnValue contains the unquoted and unescaped version
        of psQuotedRdnValue. pcUnquotedRdnValueLength contains the space
        used, in chars.

    ERROR_BUFFER_OVERFLOW
        psUnquotedRdnValueLength contains the space needed, in chars,
        to hold psUnquotedRdnValue.

    ERROR_INVALID_PARAMETER
        Invalid parameter.

    ERROR_NOT_ENOUGH_MEMORY
        Allocation error.

--*/
{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   Number;
    WCHAR   Rdn[MAX_RDN_SIZE];

    __try {
        //
        // Verify Input
        //
        if ( (cQuotedRdnValueLength == 0) ||
             (psQuotedRdnValue == NULL) ||
             (pcUnquotedRdnValueLength == NULL) ||
             ( (psUnquotedRdnValue == NULL) && (*pcUnquotedRdnValueLength != 0) ) ) {
            Status = ERROR_INVALID_PARAMETER;
            __leave;
        }
        //
        // Convert unquoted RDN into quoted RDN (if quotes are needed)
        //
        Number = UnquoteRDNValue(psQuotedRdnValue,
                                 cQuotedRdnValueLength,
                                 Rdn);
        if (Number == 0) {
            Status = ERROR_INVALID_PARAMETER;
            __leave;
        }
        //
        // Output buffer is too small
        //
        if (Number > *pcUnquotedRdnValueLength) {
            //
            // Return number of chars needed
            //
            *pcUnquotedRdnValueLength = Number;
            Status = ERROR_BUFFER_OVERFLOW;
            __leave;
        }

        //
        // Return the number of chars converted and the converted RDN
        //
        if (psUnquotedRdnValue != NULL) {
            CopyMemory(psUnquotedRdnValue, Rdn, Number * sizeof(WCHAR));
        }
        *pcUnquotedRdnValueLength = Number;

        //
        // SUCCESS
        //
        Status = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        Status = ERROR_INVALID_PARAMETER;
    }

    //
    // CLEANUP
    //
    return Status;
}

NTDSAPI
DWORD
WINAPI
DsGetRdnW(
    IN OUT LPCWCH   *ppDN,
    IN OUT DWORD    *pcDN,
    OUT    LPCWCH   *ppKey,
    OUT    DWORD    *pcKey,
    OUT    LPCWCH   *ppVal,
    OUT    DWORD    *pcVal
    )
/*++
    CHANGES TO THIS HEADER SHOULD BE RELFECTED IN NTDSAPI.H.

Description

    This client call accepts a DN with quoted RDNs and returns the address
    and length, in chars, of the key and value for the first RDN in the DN.
    The RDN value returned is still quoted. Use DsUnquoteRdnValue to unquote
    the value for display.

    This client call also returns the address and length of the rest of the
    DN. A subsequent call using the returned DN address and length will
    return information about the next RDN.

    The following loop processes each RDN in pDN:
        ccDN = wcslen(pDN)
        while (ccDN) {
            error = DsGetRdn(&pDN,
                             &ccDN,
                             &pKey,
                             &ccKey,
                             &pVal,
                             &ccVal);
            if (error != ERROR_SUCCESS) {
                process error;
                return;
            }
            if (ccKey) {
                process pKey;
            }
            if (ccVal) {
                process pVal;
            }
        }

    For example, given the DN "cn=bob,dc=com", the first call to DsGetRdnW
    returns the addresses for ",dc=com", "cn", and "bob" with respective
    lengths of 7, 2, and 3. A subsequent call with ",dc=com" returns "",
    "dc", and "com" with respective lengths 0, 2, and 3.

Arguments:
    ppDN
        IN : *ppDN points to a DN
        OUT: *ppDN points to the rest of the DN following the first RDN
    pcDN
        IN : *pcDN is the count of chars in the input *ppDN, not including
             any terminating NULL
        OUT: *pcDN is the count of chars in the output *ppDN, not including
             any terminating NULL
    ppKey
        OUT: Undefined if *pcKey is 0. Otherwise, *ppKey points to the first
             key in the DN
    pcKey
        OUT: *pcKey is the count of chars in *ppKey.

    ppVal
        OUT: Undefined if *pcVal is 0. Otherwise, *ppVal points to the first
             value in the DN
    pcVal
        OUT: *pcVal is the count of chars in *ppVal

Return Value:
    ERROR_SUCCESS
        If *pccDN is not 0, then *ppDN points to the rest of the DN following
        the first RDN. If *pccDN is 0, then *ppDN is undefined.

        If *pccKey is not 0, then *ppKey points to the first key in DN. If
        *pccKey is 0, then *ppKey is undefined.

        If *pccVal is not 0, then *ppVal points to the first value in DN. If
        *pccVal is 0, then *ppVal is undefined.

    ERROR_DS_NAME_UNPARSEABLE
        The first RDN in *ppDN could not be parsed. All output parameters
        are undefined.

    Any other error
        All output parameters are undefined.

--*/
{
    DWORD   Status;

    __try {
        Status = GetRDN(ppDN,
                        pcDN,
                        ppKey,
                        pcKey,
                        ppVal,
                        pcVal);

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        Status = ERROR_INVALID_PARAMETER;
    }

    return Status;
}


NTDSAPI
BOOL
WINAPI
DsCrackUnquotedMangledRdnA(
    IN LPCSTR pszRDN,
    IN DWORD cchRDN,
    OUT OPTIONAL GUID *pGuid,
    OUT OPTIONAL DS_MANGLE_FOR *peDsMangleFor
    )

/*++

Routine Description:

    See ntdsapi.w

Arguments:

    pszRDN - 
    cchRDN - 
    pGuid - 
    peDsMangleFor - 

Return Value:

    WINAPI - 

--*/

{
    BOOL fResult;
    DWORD status;
    LPWSTR pszRDNW = NULL;

    if ( (pszRDN == NULL) ||
         (cchRDN == 0) ) {
        return FALSE;
    }

    //
    // Convert unquoted RDN into WCHAR
    //
    status = AllocConvertWideBuffer( cchRDN, pszRDN, &pszRDNW );
    if (status != ERROR_SUCCESS) {
        return FALSE;
    }

    //
    // Perform the function
    //
    fResult = DsCrackUnquotedMangledRdnW( pszRDNW, cchRDN, pGuid, peDsMangleFor );

    //
    // Cleanup
    //
    if (pszRDNW) {
        LocalFree( pszRDNW );
    }

    return fResult;
} /* DsCrackUnquotedMangledRdnA */


NTDSAPI
BOOL
WINAPI
DsCrackUnquotedMangledRdnW(
    IN LPCWSTR pszRDN,
    IN DWORD cchRDN,
    OUT OPTIONAL GUID *pGuid,
    OUT OPTIONAL DS_MANGLE_FOR *peDsMangleFor
    )

/*++

Routine Description:

    See ntdsapi.w

Arguments:

    pszRDN - 
    cchRDN - 
    pGuid - 
    peDsMangleFor - 

Return Value:

    WINAPI - 

--*/

{
    GUID guidDummy;
    MANGLE_FOR peMangleFor;
    BOOL fResult;

    if ( (pszRDN == NULL) ||
         (cchRDN == 0) ) {
        return FALSE;
    }

    if (!pGuid) {
        pGuid = &guidDummy;
    }
    fResult = IsMangledRDN( (LPWSTR) pszRDN, cchRDN, pGuid, &peMangleFor );
    if (!fResult) {
        return FALSE;
    }

    // Convert out parameters
    if (peDsMangleFor) {
        switch (peMangleFor) {
        case MANGLE_OBJECT_RDN_FOR_DELETION:
            *peDsMangleFor = DS_MANGLE_OBJECT_RDN_FOR_DELETION;
            break;
        case MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT:
        case MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT:
            // The distinction between object and phantom conflicts is not preserved
            // out of IsMangledRDN. I felt it simpler for the external user not even
            // to be aware of the difference. I map both types to the same external
            // value.
            *peDsMangleFor = DS_MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT;
            break;
        default:
            *peDsMangleFor = DS_MANGLE_UNKNOWN;
            break;
        }
    }

    return TRUE;
} /* DsCrackUnquotedMangledRdnW */


NTDSAPI
BOOL
WINAPI
DsIsMangledRdnValueA(
    LPCSTR pszRdn,
    DWORD cRdn,
    DS_MANGLE_FOR eDsMangleForDesired
    )

/*++

Routine Description:

    See DsIsMangledRdnValueW

Arguments:

    pszRdn - 
    cRdn - 
    eDsMangleForDesired - 

Return Value:

    WINAPI - 

--*/

{
    BOOL fResult;
    DWORD status;
    LPWSTR pszRdnW = NULL;

    if ( (pszRdn == NULL) ||
         (cRdn == 0) ) {
        return FALSE;
    }

    //
    // Convert unquoted RDN into WCHAR
    //
    status = AllocConvertWideBuffer( cRdn, pszRdn, &pszRdnW );
    if (status != ERROR_SUCCESS) {
        return FALSE;
    }

    //
    // Perform the function
    //
    fResult = DsIsMangledRdnValueW( pszRdnW, cRdn, eDsMangleForDesired );

    //
    // Cleanup
    //
    if (pszRdnW) {
        LocalFree( pszRdnW );
    }

    return fResult;

} /* DsIsMangledRdnValueA */


NTDSAPI
BOOL
WINAPI
DsIsMangledRdnValueW(
    LPCWSTR pszRdn,
    DWORD cRdn,
    DS_MANGLE_FOR eDsMangleForDesired
    )

/*++

Routine Description:

    Determine if the given RDN is mangled, and of the given type

    The name may be quoted or unquoted.  This routine tries to unquote the value.  If
    the unquote operation fails, the routine proceeds to attempt the unmangle.

    A change was made in the default quoting behavior of DNs returned from the DS
    between Windows 2000 and Windows XP. This routine transparently handles RDNs with
    special characters in either form.

    The routine expects the value part of the RDN.

    If you have full DN, use IsDeletedDN below.

    To check for deleted name:
        DsIsMangledRdnValueW( rdn, rdnlen, DS_MANGLE_OBJECT_FOR_DELETION )
    To check for a conflicted name:
        DsIsMangledRdnValueW( rdn, rdnlen, DS_MANGLE_OBJECT_FOR_NAME_CONFLICT )

Arguments:

    pszRdn - 
    cRdn - 
    eDsMangleForDesired - 

Return Value:

    WINAPI - 

--*/

{
    DWORD status, cUnquoted = MAX_RDN_SIZE;
    WCHAR rgchUnquoted[MAX_RDN_SIZE];
    DS_MANGLE_FOR mangleType;

    if ( (pszRdn == NULL) ||
         (cRdn == 0) ) {
        return FALSE;
    }

    // Unquote the RDN. This is needed when receiving DNs from Whistler Beta 2
    // and later systems.  This may fail when passed RDNs from W2K systems which
    // contain unquoted special characters, especially in mangled names.
    // Because of the change in quoting behavior for mangled names, applications
    // need to be able to deal with both forms of names.
    status = DsUnquoteRdnValueW( cRdn,
                                 pszRdn,
                                 &cUnquoted,
                                 rgchUnquoted );
    if (!status) {
        // If the unquoting was successful, use the unquoted names instead
        pszRdn = rgchUnquoted;
        cRdn = cUnquoted;
    }

    // Unmangle
    return DsCrackUnquotedMangledRdnW( pszRdn, cRdn, NULL, &mangleType ) &&
        (mangleType == eDsMangleForDesired);

} /* DsIsMangledRdnValueW */


NTDSAPI
BOOL
WINAPI
DsIsMangledDnA(
    LPCSTR pszDn,
    DS_MANGLE_FOR eDsMangleFor
    )

/*++

Routine Description:

    See DsIsMangledDnW()

Arguments:

    pszDn - 
    eDsMangleFor - 

Return Value:

    WINAPI - 

--*/

{
    BOOL fResult;
    DWORD status;
    LPWSTR pszDnW = NULL;

    if (pszDn == NULL) {
        return FALSE;
    }

    //
    // Convert unquoted RDN into WCHAR
    //
    status = AllocConvertWide( pszDn, &pszDnW );
    if (status != ERROR_SUCCESS) {
        return FALSE;
    }

    //
    // Perform the function
    //
    fResult = DsIsMangledDnW( pszDnW, eDsMangleFor );

    //
    // Cleanup
    //
    if (pszDnW) {
        LocalFree( pszDnW );
    }

    return fResult;

} /* DsIsMangledDnA */


NTDSAPI
BOOL
WINAPI
DsIsMangledDnW(
    LPCWSTR pszDn,
    DS_MANGLE_FOR eDsMangleFor
    )

/*++

Routine Description:

    Determine if the first RDN in this DN is a mangled name of given type

    The dn may be in quoted form as returned from DS functions.

    To check for deleted name:
        DsIsMangledDnW( rdn, rdnlen, DS_MANGLE_OBJECT_FOR_DELETION )
    To check for a conflicted name:
        DsIsMangledDnW( rdn, rdnlen, DS_MANGLE_OBJECT_FOR_NAME_CONFLICT )

Arguments:

    pszDn - Dn from which first RDN is taken. Null terminated.

    eDsMangleFor - Type of mangled name to check for

Return Value:

    WINAPI - 

--*/

{
    DWORD status;
    LPCWSTR pDN, pKey, pVal;
    DWORD cDN, cKey, cVal;

    if (pszDn == NULL) {
        return FALSE;
    }

    pDN = pszDn;
    cDN = wcslen(pszDn);

    status = DsGetRdnW( &pDN, &cDN, &pKey, &cKey, &pVal, &cVal );
    if (status) {
        return FALSE;
    }

    return DsIsMangledRdnValueW( pVal, cVal, eDsMangleFor );
} /* DsIsMangledDnW */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsapi\exscript.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    exscript.c

Abstract:

    Implementation of DsExecuteScript API and helper functions.

Author:

    MariosZ - Dec 2000

Environment:

    User Mode - Win32

Revision History:

--*/

#define _NTDSAPI_           // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <malloc.h>         // alloca()
#include <lmcons.h>         // MAPI constants req'd for lmapibuf.h
#include <lmapibuf.h>       // NetApiBufferFree()
#include <crt\excpt.h>      // EXCEPTION_EXECUTE_HANDLER
#include <dsgetdc.h>        // DsGetDcName()
#include <rpc.h>            // RPC defines
#include <rpcndr.h>         // RPC defines
#include <drs_w.h>            // wire function prototypes
#include <bind.h>           // BindState
#include <msrpc.h>          // DS RPC definitions
#include <stdio.h>          // for printf during debugging!
#include <dststlog.h>       // DSLOG
#include <dsutil.h>         // MAP_SECURITY_PACKAGE_ERROR
#define SECURITY_WIN32 1
#include <sspi.h>
#include <winsock.h>
#include <process.h>

#define DEBSUB  "NTDSAPI_EXSCRIPT:"

#include "util.h"           // ntdsapi internal utility functions
#include "dsdebug.h"        // debug utility functions

#if !WIN95 && !WINNT4    

extern const wchar_t *wmemchr(const wchar_t *_S, wchar_t _C, size_t _N);

extern DWORD
NtdsapiGetBinding(
    LPCWSTR             pwszAddress,
    BOOL                fUseLPC,
    RPC_BINDING_HANDLE  *phRpc,
    RPC_IF_HANDLE       clientIfHandle
    );

extern DWORD
SetUpMutualAuthAndEncryption(
    RPC_BINDING_HANDLE          hRpc,
    LPCWSTR                     DomainControllerName,
    LPCWSTR                     DnsDomainName,
    DOMAIN_CONTROLLER_INFOW     *pDcInfo,
    ULONG                       AuthnSvc,
    ULONG                       AuthnLevel,
    RPC_AUTH_IDENTITY_HANDLE    AuthIdentity,
    LPCWSTR                     ServicePrincipalName,
    ULONG                       ImpersonationType
    );

extern BOOL
IsServerUnavailableError(
    DWORD   dwErr
    );

DWORD
DsaopBindWithSpn(
    IN  LPCWSTR DomainControllerName,
    IN  LPCWSTR DnsDomainName,
    IN  RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN  ULONG AuthnSvc,
    IN  ULONG AuthnLevel,
    IN  LPCWSTR ServicePrincipalName,
    OUT RPC_BINDING_HANDLE  *phRpc
    )

/*++

Routine Description:

    Starts an RPC session with a particluar DC.  See ntdsapi.h for
    description of DomainControllerName and DnsDomainName arguments.

    Bind is performed using supplied credentials.

Arguments:

    DomainControllerName - Same field as in DOMAIN_CONTROLLER_INFO.

    DnsDomainName - Dotted DNS name for a domain.

    AuthIdentity - Credentials to use, or NULL.

    ServicePrincipalName - SPN to use during mutual auth or NULL.

    phDS - Pointer to HANDLE which is filled in with BindState address
        on success.
        
    AuthnSvc - Specification of which authentication service is desired.
        
    AuthnLevel - the authentication protection level needed (e.g. RPC_C_PROTECT_LEVEL_PKT_PRIVACY)
                 if not specified (0), the default (RPC_C_PROTECT_LEVEL_PKT_PRIVACY) is used.


Return Value:

    0 on success.  Miscellaneous RPC and DsGetDcName errors otherwise.

--*/

{
    DWORD                   dwErr;
    DOMAIN_CONTROLLER_INFOW *pDcInfo = NULL;
    RPC_BINDING_HANDLE      hRpc;
    LPCWSTR                 pBindingAddress;
    ULONG                   flags;
    BOOL                    fUseLPC = TRUE;
#if DBG
    DWORD                   startTime = GetTickCount();
#endif

    // We perform special semantics for explicit credentials whose
    // username has an "@" in it.  The assumption is that "@" is rare in
    // legacy user names, thus existence of an "@" probably means a UPN
    // has been presented.  The security subsystem makes the distinction
    // between a NULL domain and the empty string ("") domain.  For reasons
    // only the security people understand, the NULL domain can not be
    // used to authenticate UPNs.  And unfortunately few of the apps which
    // pass in explicit credentials can be expected to know this, much less
    // whether the user name field is a UPN or not.  So if the user name
    // contains "@" and the domain field is NULL, we substitute the empty
    // string for the NULL domain.  If this fails with ERROR_ACCESS_DENIED
    // and the user name is <= 20 chars, than it might indeed be a legacy
    // user name with an "@" in it, and we retry once with the NULL domain
    // again.

    DWORD                       cNullDomainRetries = 0;
    DWORD                       cUnavailableRetries = 0;
    SEC_WINNT_AUTH_IDENTITY_W   *pAuthInfo;
    PWCHAR                      emptyStringAorW = L"";
    BOOL                        fNullDomainRetryWarranted = FALSE;
    ULONG                       ImpersonationType;

    __try
    {
        // All fields of SEC_WINNT_AUTH_IDENTITY are in the same place in A and W
        // versions so assign temp variable at the same time we test for NULL.

        if (AuthnLevel == 0) {
            AuthnLevel = RPC_C_PROTECT_LEVEL_PKT_PRIVACY;
            DPRINT (0, "Using default AuthLevel: RPC_C_PROTECT_LEVEL_PKT_PRIVACY\n");
        }

        if (    (pAuthInfo = (PSEC_WINNT_AUTH_IDENTITY_W) AuthIdentity)
             && !pAuthInfo->Domain )
        {
            if (    (    (SEC_WINNT_AUTH_IDENTITY_UNICODE & pAuthInfo->Flags)
                      && wmemchr(pAuthInfo->User, L'@',
                                 pAuthInfo->UserLength) )
                 || (    (SEC_WINNT_AUTH_IDENTITY_ANSI & pAuthInfo->Flags)
                      && memchr((PCHAR) pAuthInfo->User, '@',
                                pAuthInfo->UserLength) ) )
            {
                    pAuthInfo->Domain = emptyStringAorW;
                    pAuthInfo->DomainLength = 0;
                    fNullDomainRetryWarranted = TRUE;
                    DPRINT(0, "NULL domain for name with '@' in it\n");
            }
        }

DsBindRetry:

        dwErr = NO_ERROR;
        hRpc = NULL;
        pBindingAddress = NULL;
        flags = ( DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME );

        // Sanity check arguments.

        if ( NULL == phRpc )
        {
            return(ERROR_INVALID_PARAMETER);
        }

        *phRpc = NULL;

        if ( NULL != DomainControllerName )
        {
            pBindingAddress = DomainControllerName;
        }
        else
        {
            // An LPC binding will only succeed if the NetBios name
            // of this computer is used. So don't attempt an LPC binding
            // with the dns name returned by DsGetDcName, it will just fail.
            fUseLPC = FALSE;

            // Find a DC to talk to.

            if ( NULL == DnsDomainName )
            {
                flags |= DS_GC_SERVER_REQUIRED;
            }

            if ( 1 == cUnavailableRetries )
            {
                flags |= DS_FORCE_REDISCOVERY;
            }

            //
            // Don't bother retrying DsGetDcName() if the LPC
            // binding failed. DsGetDcName() would likely just
            // return the same info. Yes, I know that setting
            // fUseLPC to false above makes this check unnecessary.
            // But, if the LPC binding problem is ever fixed...
            //
            if (NULL == pDcInfo)
            {
                RpcTryExcept
                {
                    DPRINT(0, "DsGetDcNameW:\n");
                    DPRINT1(0, "    flags        : %08x\n", flags);
                    DPRINT1(0, "    ComputerName : %ws\n", NULL);
                    DPRINT1(0, "    DnsDomainName: %ws\n", DnsDomainName);
                    dwErr = DsGetDcNameW(
                                    NULL,                       // computer name
                                    DnsDomainName,              // DNS domain name
                                    NULL,                       // domain guid
                                    NULL,                       // site guid
                                    flags,
                                    &pDcInfo);
                }
                RpcExcept(1)
                {
                    dwErr = RpcExceptionCode();
                }
                RpcEndExcept;

                DPRINT1(0, "DsGetDcNameW ==> 0x%x\n", dwErr);

                if ( NO_ERROR != dwErr )
                {
                    return(dwErr);
                }
            }
            pBindingAddress = pDcInfo->DomainControllerName;
        }

        if (AuthnSvc == RPC_C_AUTHN_NONE &&
            AuthnLevel == RPC_C_PROTECT_LEVEL_NONE) {
                        
            fUseLPC = FALSE;
        }

        DPRINT(0, "NtdsapiGetBinding:\n");
        DPRINT1(0, "    pBindingAddress: %ws\n", pBindingAddress);
        DPRINT1(0, "    fUseLPC        : %d\n", fUseLPC);
        dwErr = NtdsapiGetBinding(pBindingAddress, fUseLPC, &hRpc, _dsaop_ClientIfHandle);
        DPRINT1(0, "NtdsapiGetBinding ==> 0x%x\n", dwErr);

        if ( 0 == dwErr )
        {
            if ( NULL != hRpc )
            {

                // this binding used Impersonation. The DsBind starts with delegation
                if (AuthnSvc == RPC_C_AUTHN_NONE &&
                    AuthnLevel == RPC_C_PROTECT_LEVEL_NONE) {
                    ImpersonationType = RPC_C_IMP_LEVEL_ANONYMOUS;
                }
                else {
                    ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
                }
                
                // Make sure to pass caller's original DomainControllerName
                // and DnsDomainName - not something we derived else we are
                // circumventing caller's control of mutual authentication.
                dwErr = SetUpMutualAuthAndEncryption(
                                        hRpc,
                                        DomainControllerName,
                                        DnsDomainName,
                                        pDcInfo,
                                        AuthnSvc,
                                        AuthnLevel,
                                        AuthIdentity,
                                        ServicePrincipalName,
                                        ImpersonationType);
                
                if (dwErr) {
                    RpcBindingFree(&hRpc);
                }
            }
            else
            {
                dwErr = RPC_S_NO_BINDINGS;
            }
        }

        DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsBind]"));
        DSLOG((0,"[SV=%ws][DN=%ws][PA=%s][ST=%u][ET=%u][ER=%u][-]\n",
               DomainControllerName
                    ? DomainControllerName
                    : L"NULL",
               DnsDomainName
                    ? DnsDomainName
                    : L"NULL",
               pBindingAddress, startTime, GetTickCount(), dwErr))

        // Test for LPC failure retry.
        if ( dwErr && fUseLPC  )
        {
            DPRINT(0, "Retrying without LPC\n");
            fUseLPC = FALSE;
            goto DsBindRetry;
        }

        if ( NULL != pDcInfo )
        {
            NetApiBufferFree(pDcInfo);
            pDcInfo = NULL;
        }

        // Force rediscovery if we found the server for caller, the server
        // was obviously unavailable, and its our first time through.

        if (    (NULL == DomainControllerName)
             && (0 == cUnavailableRetries)
             && (IsServerUnavailableError(dwErr)) )
        {
            DPRINT(0, "Retrying DsGetDcName with DS_FORCE_REDISCOVERY\n");
            cUnavailableRetries++;
            goto DsBindRetry;
        }

        // Test for NULL domain handling conditions.
        if ( fNullDomainRetryWarranted )
        {
            // We're going to retry or return to caller.  Either way,
            // we need to restore the NULL domain pointer.
            pAuthInfo->Domain = NULL;

            if (    (0 == cNullDomainRetries++)
                 && (ERROR_ACCESS_DENIED == dwErr)
                 && (pAuthInfo->UserLength <= 20) )
            {
                DPRINT(0, "Retrying with NULL domain\n");
                goto DsBindRetry;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        dwErr = GetExceptionCode();
        DPRINT1(0, "DsBindWithSpnW() Exception ==> %08x\n", dwErr);
        dwErr = ERROR_INVALID_PARAMETER;
    }

    //
    // CLEANUP
    //
    __try
    {
        if ( NULL != pDcInfo )
        {
            NetApiBufferFree(pDcInfo);
        }

        if (!dwErr) {
            *phRpc = hRpc;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    DPRINT1(0, "DsBindWithSpnW() ReturnCode ==> %08x\n", dwErr);

    return(dwErr);
}

DWORD
DsaopUnBind(
    RPC_BINDING_HANDLE  *phRpc
    )
{
    DWORD dwErr = 0;

    if ( NULL == phRpc )
    {
        return(ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept
    {
        dwErr = RpcBindingFree(phRpc);
    }
    RpcExcept(1)
    {
        dwErr = RpcExceptionCode();
        DPRINT1(0, "RpcEpResolveBinding Exception ==> 0x%x\n", dwErr);
    }
    RpcEndExcept;

    return dwErr;
}


DWORD
DsaopExecuteScript (
    IN  PVOID                  phAsync,
    IN  RPC_BINDING_HANDLE     hRpc,
    IN  DWORD                  cbPassword,
    IN  BYTE                  *pbPassword,
    OUT DWORD                 *dwOutVersion,
    OUT PVOID                  reply

    )
{
    DWORD dwErr = ERROR_SUCCESS;
    DSA_MSG_EXECUTE_SCRIPT_REQ           req;
    
    if (     !hRpc
          || !pbPassword
          || !reply ) {
         return(ERROR_INVALID_PARAMETER);
    }

    memset(&req, 0, sizeof(req));
    memset(reply, 0, sizeof(reply));

    req.V1.Flags = 0;
    req.V1.cbPassword = cbPassword;
    req.V1.pbPassword = pbPassword;


    RpcTryExcept
    {
        _IDL_DSAExecuteScript ((PRPC_ASYNC_STATE)phAsync, hRpc, 1, &req, dwOutVersion, (DSA_MSG_EXECUTE_SCRIPT_REPLY*)reply);

        DPRINT1 (0, "ExecuteScript: Error==> 0x%x\n", dwErr);

    }
    RpcExcept(1)
    {
        dwErr = RpcExceptionCode();
        DPRINT1 (0, "ExecuteScript: Exception ==> 0x%x\n", dwErr);

    }
    RpcEndExcept;

    return dwErr;
}

DWORD
DsaopPrepareScript (
    IN  PVOID                        phAsync,
    IN  RPC_BINDING_HANDLE           hRpc,
    OUT DWORD                        *dwOutVersion,
    OUT PVOID                        reply
    )
{
    DWORD dwErr = 0;
    DSA_MSG_PREPARE_SCRIPT_REQ req;
    
    if (     !hRpc
          || !phAsync
          || !dwOutVersion
          || !reply  )
    {
        return(ERROR_INVALID_PARAMETER);
    }

    memset(&req, 0, sizeof(req));
    
    RpcTryExcept
    {
        _IDL_DSAPrepareScript ((PRPC_ASYNC_STATE)phAsync, hRpc, 1, &req, dwOutVersion, (DSA_MSG_PREPARE_SCRIPT_REPLY*)reply);
    }
    RpcExcept(1)
    {
        dwErr = RpcExceptionCode();
    }
    RpcEndExcept;

    return dwErr;
}


#else

DWORD
DsaopExecuteScript (
    IN  PVOID                  phAsync,
    IN  RPC_BINDING_HANDLE     hRpc,
    IN  DWORD                  cbPassword,
    IN  WCHAR                 *pbPassword,
    OUT DWORD                 *dwOutVersion,
    OUT PVOID                  reply

    )
{
    return ERROR_NOT_SUPPORTED;
}

DWORD
DsaopPrepareScript (
    IN  PVOID                        phAsync,
    IN  RPC_BINDING_HANDLE           hRpc,
    OUT DWORD                        *dwOutVersion,
    OUT PVOID                        reply
    )
{
    return ERROR_NOT_SUPPORTED;
}


DWORD
DsaopUnBind(
    RPC_BINDING_HANDLE  *phRpc
    )
{
    return ERROR_NOT_SUPPORTED;
}

DWORD
DsaopBindWithSpn(
    IN  LPCWSTR DomainControllerName,
    IN  LPCWSTR DnsDomainName,
    IN  RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN  ULONG AuthnSvc,
    IN  ULONG AuthnLevel,
    IN  LPCWSTR ServicePrincipalName,
    OUT RPC_BINDING_HANDLE  *phRpc
    )
{
    return ERROR_NOT_SUPPORTED;
}
#endif


DWORD
DsaopBindWithCred(
    IN  LPCWSTR DomainControllerName,
    IN  LPCWSTR DnsDomainName,
    IN  RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN  ULONG AuthnSvc,
    IN  ULONG AuthnLevel,
    OUT RPC_BINDING_HANDLE  *phRpc
    )
{
    return(DsaopBindWithSpn(DomainControllerName, 
                            DnsDomainName,
                            AuthIdentity, 
                            AuthnSvc,
                            AuthnLevel, 
                            NULL, 
                            phRpc));
}

DWORD
DsaopBind(
    IN  LPCWSTR DomainControllerName,
    IN  LPCWSTR DnsDomainName,
    IN  ULONG AuthnSvc,
    IN  ULONG AuthnLevel,
    OUT RPC_BINDING_HANDLE  *phRpc
    )
{
    return DsaopBindWithCred( DomainControllerName,
                            DnsDomainName,
                            NULL, // credentials
                            AuthnSvc,
                            AuthnLevel,
                            phRpc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsapi\replica.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    replica.c

Abstract:

    This module implements the public interfaces to the replica routines:

    DsReplicaSync();
    DsReplicaAdd();
    DsReplicaDelete();
    DsReplicaModify();

Author:

    Will Lees (wlees) 30-Jan-1998

Environment:

Notes:

Revision History:

--*/

#define UNICODE 1

#define _NTDSAPI_           // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <rpc.h>            // RPC defines
#include <stdlib.h>         // atoi, itoa


#include <dnsapi.h>         // for DnsValidateName_W

#include <ntdsapi.h>        // CrackNam apis
#include <drs_w.h>          // wire function prototypes
#include <bind.h>           // BindState

#include <drserr.h>         // DRSERR_ codes

#include <dsaapi.h>         // DRS_UPDATE_* flags
#define INCLUDE_OPTION_TRANSLATION_TABLES
#include <draatt.h>         // Dra option flags for replication
#undef INCLUDE_OPTION_TRANSLATION_TABLES

#include <msrpc.h>          // DS RPC definitions
#include <dsutil.h>         // MAP_SECURITY_PACKAGE_ERROR
#include "util.h"           // ntdsapi utility functions
#include <dststlog.h>       // DSLOG

#if DBG
#include <stdio.h>          // printf for debugging
#endif

#include <debug.h>
#include <fileno.h>
#define FILENO FILENO_NTDSAPI_REPLICA

/* Forward */

DWORD
translateOptions(
    DWORD PublicOptions,
    POPTION_TRANSLATION Table
    );

UCHAR * UuidToStr(CONST UUID* pUuid, UCHAR *pOutUuid);
#define SZUUID_LEN ((2*sizeof(UUID)) + MAX_PATH +2)

/* End Forward */


NTDSAPI
DWORD
WINAPI
DsReplicaSyncA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN const UUID *pUuidDsaSrc,
    IN ULONG Options
    )

/*++

Routine Description:

Ascii version of ReplicaSync. Calls DsReplicaSyncW.

Arguments:

    hDS -
    NameContext -
    pUuidDsaSrc -
    Options -

Return Value:

    WINAPI -

--*/

{
    DWORD status;
    LPWSTR nameContextW = NULL;

    status = AllocConvertWide( NameContext, &nameContextW );
    if (status != ERROR_SUCCESS) {
        return status;
    }

    status = DsReplicaSyncW( hDS, nameContextW, pUuidDsaSrc, Options );

    if (nameContextW != NULL) {
        LocalFree( nameContextW );
    }

    return status;
} /* DsReplicaSyncA */


NTDSAPI
DWORD
WINAPI
DsReplicaSyncW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN const UUID *pUuidDsaSrc,
    IN ULONG Options
    )

/*++

Routine Description:

Synchronize a naming context with one of its sources.

See comments on ntdsapi.h.

Arguments:

    hDS - bind handle
    NameContext - dn of naming context
    pUuidDsaSrc - uuid of one of its sources
    Options - flags which control operation

Return Value:

    WINAPI -

--*/

{
    DRS_MSG_REPSYNC syncReq;
    DWORD status;
    DSNAME *pName = NULL;
#if DBG
    DWORD  startTime = GetTickCount();
    CHAR tmpUuid [SZUUID_LEN];
#endif

    // Validate

    if ( (hDS == NULL) ||
         (NameContext == NULL) ||
         (wcslen( NameContext ) == 0) ||
         (pUuidDsaSrc == NULL) ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Construct a DSNAME for the NameContext
    status = AllocBuildDsname( NameContext, &pName );
    if (status != ERROR_SUCCESS) {
        return status;
    }

    // Map public options to private dra options

    Options = translateOptions( Options, RepSyncOptionToDra );

    // Initialize Structure

    memset( &syncReq, 0, sizeof( syncReq ) );

    syncReq.V1.pNC = pName;
    syncReq.V1.uuidDsaSrc = *pUuidDsaSrc;
    // pszDsaSrc is Null
    syncReq.V1.ulOptions = Options;

    // Call the server

    __try
    {
        // Returns WIN32 status defined in winerror.h
        status = _IDL_DRSReplicaSync(
                        ((BindState *) hDS)->hDrs,
                        1,                              // dwInVersion
                        &syncReq );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = RpcExceptionCode();
    }

    MAP_SECURITY_PACKAGE_ERROR( status );

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsReplicaSync]"));
    DSLOG((0,"[PA=%ws][PA=%s][PA=0x%x][ST=%u][ET=%u][ER=%u][-]\n",
           NameContext,
           pUuidDsaSrc ? UuidToStr(pUuidDsaSrc, tmpUuid) : "NULL",
           Options,
           startTime, GetTickCount(), status))

    LocalFree( pName );

    return status;
} /* DsReplicaSyncW */


NTDSAPI
DWORD
WINAPI
DsReplicaAddA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN LPCSTR SourceDsaDn,
    IN LPCSTR TransportDn,
    IN LPCSTR SourceDsaAddress,
    IN const PSCHEDULE pSchedule,
    IN DWORD Options
    )

/*++

Routine Description:

Ascii version of ReplicaAdd. Calls DsReplicaAddW.

Arguments:

    hDS -
    NameContext -
    SourceDsaDn -
    TransportDn -
    SourceDsaAddress -
    pSchedule -
    Options -

Return Value:

    WINAPI -

--*/

{
    DWORD status;
    LPWSTR nameContextW = NULL;
    LPWSTR sourceDsaDnW = NULL;
    LPWSTR transportDnW = NULL;
    LPWSTR sourceDsaAddressW = NULL;

    if (NameContext) {
        status = AllocConvertWide( NameContext, &nameContextW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    if (SourceDsaDn) {
        status = AllocConvertWide( SourceDsaDn, &sourceDsaDnW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    if (TransportDn) {
        status = AllocConvertWide( TransportDn, &transportDnW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    if (SourceDsaAddress) {
        status = AllocConvertWide( SourceDsaAddress, &sourceDsaAddressW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    status = DsReplicaAddW( hDS,
                            nameContextW,
                            sourceDsaDnW,
                            transportDnW,
                            sourceDsaAddressW,
                            pSchedule,
                            Options );

cleanup:
    if (nameContextW) {
        LocalFree( nameContextW );
    }
    if (sourceDsaDnW) {
        LocalFree( sourceDsaDnW );
    }
    if (transportDnW) {
        LocalFree( transportDnW );
    }
    if (sourceDsaAddressW) {
        LocalFree( sourceDsaAddressW );
    }

    return status;
} /* DsReplicaAddA */


NTDSAPI			 
DWORD
WINAPI
DsReplicaAddW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN LPCWSTR SourceDsaDn,
    IN LPCWSTR TransportDn,
    IN LPCWSTR SourceDsaAddress,
    IN const PSCHEDULE pSchedule,
    IN DWORD Options
    )

/*++

Routine Description:

Add a source to a naming context.

See comments on this routine in ntdsapi.h

Arguments:

    hDS - bind handle
    NameContext - dn of naming context
    SourceDsaDn - dn of source's ntds-dsa (settings) object
    TransportDn - dn of transport to be used
    SourceDsaAddress - transport-specific address of source
    pSchedule - schedule when link is available
    Options - controls operation

Return Value:

    WINAPI -

--*/

{
    DRS_MSG_REPADD addReq;
    DWORD status, version;
    DSNAME *pName = NULL, *pSource = NULL, *pTransport = NULL;
    LPSTR sourceDsaAddressA = NULL;
    REPLTIMES internalSchedule;
#if DBG
    DWORD  startTime = GetTickCount();
#endif

    // Validate

    if ( (hDS == NULL) ||
         (NameContext == NULL) ||
         (wcslen( NameContext ) == 0) ||
         (SourceDsaAddress == NULL) ||
         (wcslen( SourceDsaAddress ) == 0) ) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( (SourceDsaDn &&
          wcslen( SourceDsaDn ) == 0) ||
         (TransportDn &&
          wcslen( TransportDn ) == 0) ) {
        // prevent empty string processing.
        // (note: this matches return for A routines. see AllocConvertWide)
        return ERROR_INVALID_PARAMETER;
    }

    // Construct a DSNAME for the NameContext
    // Required
    status = AllocBuildDsname( NameContext, &pName );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // May be Null
    status = AllocBuildDsname( SourceDsaDn, &pSource );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // May be Null
    status = AllocBuildDsname( TransportDn, &pTransport );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // dsaSrc is in UTF8 multi-byte
    //   - Validate FQ dns name
    //   - Required
    status = DnsValidateName_W( SourceDsaAddress, DnsNameHostnameFull );
    if ( status == ERROR_INVALID_NAME ||
         NULL == wcschr(SourceDsaAddress, L'.') ) {
        // Note: all other possible error codes are valid
        // (see Dns_ValidateName_UTF for more)
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    status = AllocConvertNarrowUTF8( SourceDsaAddress, &sourceDsaAddressA );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // pSchedule is optional
    if (pSchedule) {
        status = ConvertScheduleToReplTimes( pSchedule, &internalSchedule );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    // Map public options to private dra options

    Options = translateOptions( Options, RepAddOptionToDra );

    // Initialize the right version Structure
    // If new-style arguments are not present, use old style call.  Server
    // must support both.

    memset( &addReq, 0, sizeof( addReq ) );

    if ( (SourceDsaDn == NULL) && (TransportDn == NULL) ) {
        version = 1;
        addReq.V1.pNC = pName;
        addReq.V1.pszDsaSrc = sourceDsaAddressA;
        if (pSchedule) {   // may be null
            CopyMemory( &(addReq.V1.rtSchedule),
                        &internalSchedule, sizeof( REPLTIMES ) );
        }
        addReq.V1.ulOptions = Options;
    } else {
        version = 2;
        addReq.V2.pNC = pName;
        addReq.V2.pSourceDsaDN = pSource; // may be null
        addReq.V2.pTransportDN = pTransport; // may be null
        addReq.V2.pszSourceDsaAddress = sourceDsaAddressA;
        if (pSchedule) {   // may be null
            CopyMemory( &(addReq.V2.rtSchedule),
                        &internalSchedule, sizeof( REPLTIMES ) );
        }
        addReq.V2.ulOptions = Options;
    }

    // Check if requested version is supported

    if ( (2 == version) &&
       !IS_DRS_REPADD_V2_SUPPORTED(((BindState *) hDS)->pServerExtensions) ) {
        status = ERROR_NOT_SUPPORTED;
        goto cleanup;
    }

    // Call the server

    __try
    {
        // Returns WIN32 status defined in winerror.h
        status = _IDL_DRSReplicaAdd(
                        ((BindState *) hDS)->hDrs,
                        version,                              // dwInVersion
                        &addReq );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = RpcExceptionCode();
    }

    MAP_SECURITY_PACKAGE_ERROR( status );

cleanup:

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsReplicaAdd]"));
    DSLOG((0,"[PA=%ws][PA=%ws][PA=%ws][PA=%ws][PA=0x%x][ST=%u][ET=%u][ER=%u][-]\n",
           NameContext,
           SourceDsaDn ? SourceDsaDn : L"NULL",
           TransportDn ? TransportDn : L"NULL",
           SourceDsaAddress, Options,
           startTime, GetTickCount(), status))

    if (pName) {
        LocalFree( pName );
    }
    if (pSource) {
        LocalFree( pSource );
    }
    if (pTransport) {
        LocalFree( pTransport );
    }
    if (sourceDsaAddressA) {
        LocalFree( sourceDsaAddressA );
    }

    return status;
} /* DsReplicaAddW */


NTDSAPI
DWORD
WINAPI
DsReplicaDelA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN LPCSTR DsaSrc,
    IN ULONG Options
    )

/*++

Routine Description:

Ascii version of ReplicaDel.  Calls ReplicaDelW().

Arguments:

    hDS -
    NameContext -
    DsaSrc -
    Options -

Return Value:

    WINAPI -

--*/

{
    DWORD status;
    LPWSTR nameContextW = NULL, dsaSrcW = NULL;

    if (NameContext) {
        status = AllocConvertWide( NameContext, &nameContextW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    if (DsaSrc) {
        status = AllocConvertWide( DsaSrc, &dsaSrcW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    status = DsReplicaDelW( hDS, nameContextW, dsaSrcW, Options );

cleanup:
    if (nameContextW) {
        LocalFree( nameContextW );
    }
    if (dsaSrcW) {
        LocalFree( dsaSrcW );
    }

    return status;
} /* DsReplicaDelA */


NTDSAPI
DWORD
WINAPI
DsReplicaDelW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN LPCWSTR DsaSrc,
    IN ULONG Options
    )

/*++

Routine Description:

Delete a source from a naming context.
Source is identified by the transport-specific address.

See comments in ntdsapi.h

Arguments:

    hDS - bind handle
    NameContext - dn of naming context
    DsaSrc - transport specific address of source
    Options -

Return Value:

    WINAPI -

--*/

{
    DRS_MSG_REPDEL delReq;
    DWORD status;
    DSNAME *pName = NULL;
    LPSTR dsaSrcA = NULL;
#if DBG
    DWORD  startTime = GetTickCount();
#endif

    // Validate

    if ( (hDS == NULL) ||
         (NameContext == NULL) ||
         (wcslen( NameContext ) == 0) ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Construct a DSNAME for the NameContext

    status = AllocBuildDsname( NameContext, &pName );
    if (status != ERROR_SUCCESS) {
        return status;
    }

    // dsaSrc is in UTF8 multi-byte

    status = AllocConvertNarrowUTF8( DsaSrc, &dsaSrcA );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // Map public options to private dra options

    Options = translateOptions( Options, RepDelOptionToDra );

    // Initialize Structure

    memset( &delReq, 0, sizeof( delReq ) );

    delReq.V1.pNC = pName;
    delReq.V1.pszDsaSrc = dsaSrcA;
    delReq.V1.ulOptions = Options;

    // Call the server

    __try
    {
        // Returns WIN32 status defined in winerror.h
        status = _IDL_DRSReplicaDel(
                        ((BindState *) hDS)->hDrs,
                        1,                              // dwInVersion
                        &delReq );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = RpcExceptionCode();
    }

    MAP_SECURITY_PACKAGE_ERROR( status );

cleanup:

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsReplicaDel]"));
    DSLOG((0,"[PA=%ws][PA=%ws][PA=0x%x][ST=%u][ET=%u][ER=%u][-]\n",
           NameContext, DsaSrc, Options,
           startTime, GetTickCount(), status))

    if (pName) {
        LocalFree( pName );
    }
    if (dsaSrcA) {
        LocalFree( dsaSrcA );
    }

    return status;
} /* DsReplicaDelW */


NTDSAPI
DWORD
WINAPI
DsReplicaModifyA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN const UUID *pUuidSourceDsa,
    IN LPCSTR TransportDn,
    IN LPCSTR SourceDsaAddress,
    IN const PSCHEDULE pSchedule,
    IN DWORD ReplicaFlags,
    IN DWORD ModifyFields,
    IN DWORD Options
    )

/*++

Routine Description:

Ascii version of ReplicaModify.  Calls ReplicaModifyW().

Arguments:

    hDS -
    NameContext -
    pUuidSourceDsa -
    TransportDn -
    SourceDsaAddress -
    pSchedule -
    ReplicaFlags -
    ModifyFields -
    Options -

Return Value:

    WINAPI -

--*/

{
    DWORD status;
    LPWSTR nameContextW = NULL;
    LPWSTR transportDnW = NULL;
    LPWSTR sourceDsaAddressW = NULL;

    if (NameContext) {
        status = AllocConvertWide( NameContext, &nameContextW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    if (SourceDsaAddress) {
        status = AllocConvertWide( SourceDsaAddress, &sourceDsaAddressW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    if (TransportDn) {
        status = AllocConvertWide( TransportDn, &transportDnW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    status = DsReplicaModifyW( hDS,
                               nameContextW,
                               pUuidSourceDsa,
                               transportDnW,
                               sourceDsaAddressW,
                               pSchedule,
                               ReplicaFlags,
                               ModifyFields,
                               Options );

cleanup:
    if (nameContextW) {
        LocalFree( nameContextW );
    }
    if (transportDnW) {
        LocalFree( transportDnW );
    }
    if (sourceDsaAddressW) {
        LocalFree( sourceDsaAddressW );
    }

    return status;
} /* DsReplicaModifyA */


NTDSAPI
DWORD
WINAPI
DsReplicaModifyW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN const UUID *pUuidSourceDsa,
    IN LPCWSTR TransportDn,
    IN LPCWSTR SourceDsaAddress,
    IN const PSCHEDULE pSchedule,
    IN DWORD ReplicaFlags,
    IN DWORD ModifyFields,
    IN DWORD Options
    )

/*++

Routine Description:

Modify a source of a naming context.

See comments in ntdsapi.h

Arguments:

    hDS - bind handle
    NameContext - dn of naming context
    pUuidSourceDsa - uuid of source dsa
    TransportDn - dn of transport, not supported at moment
    SourceDsaAddress - transport specific address of source
    pSchedule - schedule when link is up
    ReplicaFlags - new flags
    ModifyFields - Which field is to be modified
    Options - operation qualifiers

Return Value:

    WINAPI -

--*/

{
    DRS_MSG_REPMOD modReq;
    DWORD status;
    DSNAME *pName = NULL, *pTransport = NULL;
    LPSTR sourceDsaAddressA = NULL;
    REPLTIMES internalSchedule;
#if DBG
    DWORD  startTime = GetTickCount();
    CHAR tmpUuid [SZUUID_LEN];
#endif

    // Validate

    if ( (hDS == NULL) ||
         (NameContext == NULL) ||
         (wcslen( NameContext ) == 0) ||
         (ModifyFields == 0) ||
         ( (pUuidSourceDsa == NULL) && (SourceDsaAddress == NULL) ) ) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( (SourceDsaAddress &&
          wcslen( SourceDsaAddress ) == 0) ||
         (TransportDn &&
          wcslen( TransportDn ) == 0) ) {
        // prevent empty string processing.
        // (note: this matches return for A routines. see AllocConvertWide)
        return ERROR_INVALID_PARAMETER;
    }

    // Note, we cannot restrict which flags are set or cleared at this
    // level because we pass in the after-image of the flags. We cannot
    // distinguish between a flag that is already set (or clear) before
    // and a flag that is being changed by the user.

    // Construct a DSNAME for the NameContext
    // Required
    status = AllocBuildDsname( NameContext, &pName );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

#if 1
    // TransportDn is reserved for future use
    // Once happy w/ this should collapse param checkin on this
    // above.
    if (TransportDn != NULL) {
        status = ERROR_NOT_SUPPORTED;
        goto cleanup;
    }
#else
    // May be Null
    status = AllocBuildDsname( TransportDn, &pTransport );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }
#endif

    // Map public Replica Flags
    ReplicaFlags = translateOptions( ReplicaFlags, RepNbrOptionToDra );

    // dsaSrc is in UTF8 multi-byte
    // May be Null
    status = AllocConvertNarrowUTF8( SourceDsaAddress, &sourceDsaAddressA );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // pSchedule is optional
    if (pSchedule) {
        status = ConvertScheduleToReplTimes( pSchedule, &internalSchedule );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }
    else if ( ModifyFields & DS_REPMOD_UPDATE_SCHEDULE ) {
        // but isn't if the update_sched option's on.
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // Map public ModifyFields

    ModifyFields = translateOptions( ModifyFields, RepModFieldsToDra );


    // Map public options to private dra options

    Options = translateOptions( Options, RepModOptionToDra );




    // Initialize the right version Structure

    memset( &modReq, 0, sizeof( modReq ) );

    modReq.V1.pNC = pName;
    if (pUuidSourceDsa) {   // may be null
        CopyMemory( &(modReq.V1.uuidSourceDRA), pUuidSourceDsa, sizeof(UUID) );
    }
    modReq.V1.pszSourceDRA = sourceDsaAddressA;   // may be null
//    addReq.V2.pTransportDN = pTransport; // may be null
    if (pSchedule) {   // may be null
        CopyMemory( &(modReq.V1.rtSchedule),
                    &internalSchedule, sizeof( REPLTIMES ));
    }
    modReq.V1.ulReplicaFlags = ReplicaFlags;
    modReq.V1.ulModifyFields = ModifyFields;
    modReq.V1.ulOptions = Options;



    // Call the server

    __try
    {
        // Returns WIN32 status defined in winerror.h
        status = _IDL_DRSReplicaModify(
                        ((BindState *) hDS)->hDrs,
                        1,                              // dwInVersion
                        &modReq );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = RpcExceptionCode();
    }

    MAP_SECURITY_PACKAGE_ERROR( status );

cleanup:

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsReplicaModify]"));
    DSLOG((0,"[PA=%ws][PA=%s][PA=%ws][PA=%ws][PA=0x%x][PA=0x%x][PA=0x%x][ST=%u][ET=%u][ER=%u][-]\n",
           NameContext,
           pUuidSourceDsa ? UuidToStr(pUuidSourceDsa, tmpUuid) : "NULL",
           TransportDn ? TransportDn : L"NULL",
           SourceDsaAddress ? SourceDsaAddress : L"NULL",
           ReplicaFlags, ModifyFields, Options,
           startTime, GetTickCount(), status))

    if (pName) {
        LocalFree( pName );
    }
#if 0
    if (pTransport) {
        LocalFree( pTransport );
    }
#endif
    if (sourceDsaAddressA) {
        LocalFree( sourceDsaAddressA );
    }

    return status;
} /* DsReplicaModifyW */


NTDSAPI
DWORD
WINAPI
DsReplicaUpdateRefsA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN LPCSTR DsaDest,
    IN const UUID *pUuidDsaDest,
    IN ULONG Options
    )

/*++

Routine Description:

Ascii version of ReplicaUpdateRefs. Calls DsReplicaUpdateRefsW.

Arguments:

    hDS -
    NameContext -
    pUuidDsaSrc -
    Options -

Return Value:

    WINAPI -

--*/

{
    DWORD status;
    LPWSTR nameContextW = NULL, dsaDestW = NULL;

    status = AllocConvertWide( NameContext, &nameContextW );
    if (status != ERROR_SUCCESS) {
        return status;
    }

    if (DsaDest) {
        status = AllocConvertWide( DsaDest, &dsaDestW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    status = DsReplicaUpdateRefsW(
        hDS,
        nameContextW,
        dsaDestW,
        pUuidDsaDest,
        Options );

cleanup:

    if (dsaDestW != NULL) {
        LocalFree( dsaDestW );
    }

    if (nameContextW != NULL) {
        LocalFree( nameContextW );
    }

    return status;
} /* DsReplicaUpdateRefsA */


NTDSAPI
DWORD
WINAPI
DsReplicaUpdateRefsW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN LPCWSTR DsaDest,
    IN const UUID *pUuidDsaDest,
    IN ULONG Options
    )

/*++

Routine Description:

Add or remove a "replication to" reference for a destination from a source

See comments on ntdsapi.h.

Arguments:
    hDS - bind handle
    NameContext - dn of naming context
    DsaDest - transport-specific address of the destination
    pUuidDsaDest - uuid of one of its destination
    Options - flags which control operation

Return Value:

    WINAPI -

--*/

{
    DRS_MSG_UPDREFS updRefs;
    DWORD status;
    DSNAME *pName = NULL;
    LPSTR dsaDestA = NULL;
#if DBG
    DWORD  startTime = GetTickCount();
    CHAR tmpUuid [SZUUID_LEN];
#endif

    // Validate

    if ( (hDS == NULL) ||
         (NameContext == NULL) ||
         (wcslen( NameContext ) == 0) ||
         (DsaDest == NULL) ||
         (wcslen( DsaDest ) == 0) ||
         (pUuidDsaDest == NULL) ||
         ( (Options & (DRS_ADD_REF|DRS_DEL_REF)) == 0 ) ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Construct a DSNAME for the NameContext
    status = AllocBuildDsname( NameContext, &pName );
    if (status != ERROR_SUCCESS) {
        return status;
    }

    // dsaDest is in UTF8 multi-byte

    status = AllocConvertNarrowUTF8( DsaDest, &dsaDestA );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // Map public options to private dra options

    Options = translateOptions( Options, UpdRefOptionToDra );

    // Initialize Structure

    memset( &updRefs, 0, sizeof( updRefs ) );

    updRefs.V1.pNC = pName;
    updRefs.V1.pszDsaDest = dsaDestA;
    updRefs.V1.uuidDsaObjDest = *pUuidDsaDest;
    updRefs.V1.ulOptions = Options;

    // Call the server

    __try
    {
        // Returns WIN32 status defined in winerror.h
        status = _IDL_DRSUpdateRefs(
                        ((BindState *) hDS)->hDrs,
                        1,                              // dwInVersion
                        &updRefs );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = RpcExceptionCode();
    }

    MAP_SECURITY_PACKAGE_ERROR( status );

cleanup:

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsReplicaUpdateRefs]"));
    DSLOG((0,"[PA=%ws][PA=%ws][PA=%s][PA=0x%x][ST=%u][ET=%u][ER=%u][-]\n",
           NameContext,
           DsaDest,
           pUuidDsaDest ? UuidToStr(pUuidDsaDest, tmpUuid) : "NULL",
           Options,
           startTime, GetTickCount(), status))

    LocalFree( pName );

    if (dsaDestA) {
        LocalFree( dsaDestA );
    }

    return status;
} /* DsReplicaSyncW */


NTDSAPI
DWORD
WINAPI
DsReplicaConsistencyCheck(
    IN HANDLE        hDS,
    IN DS_KCC_TASKID TaskID,
    IN DWORD         dwFlags
    )
/*++

Routine Description:

    Force the KCC to run.

Arguments:

    hDS - DS handle returned by a prior call to DsBind*().

    TaskID - A DS_KCC_TASKID_*, as defined in ntdsapi.h.

    dwFlags - One or more DS_KCC_FLAG_* bits, as defined in ntdsapi.h.

Return Value:

    0 on success or Win32 error code on failure.

--*/
{
    DWORD               status;
    DRS_MSG_KCC_EXECUTE msg;
#if DBG
    DWORD  startTime = GetTickCount();
#endif

    if (NULL == hDS) {
        return ERROR_INVALID_PARAMETER;
    }

    if (!IS_DRS_KCC_EXECUTE_V1_SUPPORTED(
            ((BindState *) hDS)->pServerExtensions)) {
        return ERROR_NOT_SUPPORTED;
    }

    // Construct request message.
    msg.V1.dwTaskID = TaskID;
    msg.V1.dwFlags  = dwFlags;

    // Call the server.
    __try {
        status = _IDL_DRSExecuteKCC(((BindState *) hDS)->hDrs, 1, &msg);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        status = RpcExceptionCode();
        MAP_SECURITY_PACKAGE_ERROR(status);
    }

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsReplicaConsistencyCheck]"));
    DSLOG((0,"[PA=0x%x][PA=0x%x][ST=%u][ET=%u][ER=%u][-]\n",
           TaskID, dwFlags,
           startTime, GetTickCount(), status))

    return status;
} /* DsReplicaConsistencyCheck */


NTDSAPI
DWORD
WINAPI
DsReplicaGetInfoW(
    IN  HANDLE              hDS,
    IN  DS_REPL_INFO_TYPE   InfoType,
    IN  LPCWSTR             pszObjectDN,
    IN  UUID *              puuidForSourceDsaObjGuid,
    OUT VOID **             ppInfo
    )
/*++

Routine Description:

    Retrieve replication information (e.g., last replication status with
    neighbors).

Arguments:

    hDS (IN) - DS handle returned by a prior call to DsBind*().

    InfoType (IN) - DS_REPL_INFO_TYPE (public) or DS_REPL_INFO_TYPEP (private)
        enum.

    puuidForSourceDsaObjGuid

Return Value:

    0 on success or Win32 error code on failure.

--*/
{
    return DsReplicaGetInfo2W(hDS,
                              InfoType,
                              pszObjectDN,
                              puuidForSourceDsaObjGuid,
                              NULL,
                              NULL,
                              0,
                              0,
                              ppInfo);
} /* DsReplicaGetInfo */


NTDSAPI
DWORD
WINAPI
DsReplicaGetInfo2W(
    IN  HANDLE              hDS,
    IN  DS_REPL_INFO_TYPE   InfoType,
    IN  LPCWSTR             pszObjectDN OPTIONAL,
    IN  UUID *              puuidForSourceDsaObjGuid OPTIONAL,
    IN  LPCWSTR             pszAttributeName OPTIONAL,
    IN  LPCWSTR             pszValueDN OPTIONAL,
    IN  DWORD               dwFlags,
    IN  DWORD               dwEnumerationContext,
    OUT VOID **             ppInfo
    )
/*++

Routine Description:

    Retrieve replication information (e.g., last replication status with
    neighbors).

Arguments:

    hDS (IN) - DS handle returned by a prior call to DsBind*().

    InfoType (IN) - DS_REPL_INFO_TYPE (public) or DS_REPL_INFO_TYPEP (private)
        enum.

    pszObjectDN - Either the dn or the guid must be specified

    puuidForSourceDsaObjGuid - 

    pszAttributeName - Attribute name

    pszObjectDN - Particular dn from a set that is desired

    dwEnumerationContext - 0 first time, or previous value

    dwFlags - Not used

    ppInfo - Returned info

Return Value:

    WINAPI - 

--*/
{
    DWORD                   status;
    DRS_MSG_GETREPLINFO_REQ MsgIn = {0};
    DWORD                   dwInVersion;
    DWORD                   dwOutVersion;
    DRS_EXTENSIONS *        pExt = hDS ? ((BindState *) hDS)->pServerExtensions : NULL;
#if DBG
    DWORD  startTime = GetTickCount();
    CHAR tmpUuid [SZUUID_LEN];
#endif

    if ((NULL == hDS)
        || (NULL == ppInfo)
        || (((ULONG) InfoType >= DS_REPL_INFO_TYPE_MAX)
            && ((ULONG) InfoType <= DS_REPL_INFO_TYPEP_MIN))) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( pszObjectDN &&
         (wcslen( pszObjectDN ) == 0) ) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( pszAttributeName &&
         (wcslen( pszAttributeName ) == 0) ) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( pszValueDN &&
         (wcslen( pszValueDN ) == 0) ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Does server support this info type?
    switch (InfoType) {
    case DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES:
    case DS_REPL_INFO_KCC_DSA_LINK_FAILURES:
        if (!IS_DRS_GET_REPL_INFO_KCC_DSA_FAILURES_SUPPORTED(pExt)) {
            // Server does not support these extensions -- i.e., < Win2k RC1 DC.
            return ERROR_NOT_SUPPORTED;
        }
        break;

    case DS_REPL_INFO_PENDING_OPS:
        if (!IS_DRS_GET_REPL_INFO_PENDING_SYNCS_SUPPORTED(pExt)) {
            // Server does not support these extensions -- i.e., < Win2k RC1 DC.
            return ERROR_NOT_SUPPORTED;
        }
        break;

    case DS_REPL_INFO_METADATA_FOR_ATTR_VALUE:
        if (!IS_DRS_GET_REPL_INFO_METADATA_FOR_ATTR_VALUE_SUPPORTED(pExt)) {
            // Server does not support these extensions -- i.e., < Whistler Beta 1 DC.
            return ERROR_NOT_SUPPORTED;
        }
        break;

    case DS_REPL_INFO_CURSORS_2_FOR_NC:
        if (!IS_DRS_GET_REPL_INFO_CURSORS_2_FOR_NC_SUPPORTED(pExt)) {
            // Server does not support these extensions -- i.e., < Whistler Beta 2 DC.
            return ERROR_NOT_SUPPORTED;
        }
        break;
    
    case DS_REPL_INFO_CURSORS_3_FOR_NC:
        if (!IS_DRS_GET_REPL_INFO_CURSORS_3_FOR_NC_SUPPORTED(pExt)) {
            // Server does not support these extensions -- i.e., < Whistler Beta 2 DC.
            return ERROR_NOT_SUPPORTED;
        }
        break;

    case DS_REPL_INFO_METADATA_2_FOR_OBJ:
        if (!IS_DRS_GET_REPL_INFO_METADATA_2_FOR_OBJ_SUPPORTED(pExt)) {
            // Server does not support these extensions -- i.e., < Whistler Beta 2 DC.
            return ERROR_NOT_SUPPORTED;
        }
        break;
    
    case DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE:
        if (!IS_DRS_GET_REPL_INFO_METADATA_2_FOR_ATTR_VALUE_SUPPORTED(pExt)) {
            // Server does not support these extensions -- i.e., < Whistler Beta 2 DC.
            return ERROR_NOT_SUPPORTED;
        }
        break;

    default:
        if (!IS_DRS_GET_REPL_INFO_SUPPORTED(pExt)) {
            // Server does not support this API.
            return ERROR_NOT_SUPPORTED;
        }
        break;
    }
    
    // Build our request.
    if ((NULL != pszAttributeName)
        || (NULL != pszValueDN)
        || (0 != dwFlags)
        || (0 != dwEnumerationContext)) {
        // Requires V2 message to describe request.
        dwInVersion = 2;
    
        MsgIn.V2.InfoType    = InfoType;
        MsgIn.V2.pszObjectDN = (LPWSTR) pszObjectDN;
    
        if (NULL != puuidForSourceDsaObjGuid) {
            MsgIn.V2.uuidSourceDsaObjGuid = *puuidForSourceDsaObjGuid;
        }
    
        MsgIn.V2.ulFlags = dwFlags;
        MsgIn.V2.pszAttributeName = (LPWSTR) pszAttributeName;
        MsgIn.V2.pszValueDN = (LPWSTR) pszValueDN;
        MsgIn.V2.dwEnumerationContext = dwEnumerationContext;
    } else {
        // Can describe with V1 request.
        dwInVersion = 1;
        
        MsgIn.V1.InfoType    = InfoType;
        MsgIn.V1.pszObjectDN = (LPWSTR) pszObjectDN;
    
        if (NULL != puuidForSourceDsaObjGuid) {
            MsgIn.V1.uuidSourceDsaObjGuid = *puuidForSourceDsaObjGuid;
        }
    }

    if ((2 == dwInVersion) && !IS_DRS_GET_REPL_INFO_REQ_V2_SUPPORTED(pExt)) {
        // Server does not support these extensions -- i.e., < Whistler Beta 1 DC.
        return ERROR_NOT_SUPPORTED;
    }

    // Call the server.
    *ppInfo = NULL;
    __try {
        status = _IDL_DRSGetReplInfo(((BindState *) hDS)->hDrs,
                                    dwInVersion,
                                    &MsgIn,
                                    &dwOutVersion,
                                    (DRS_MSG_GETREPLINFO_REPLY *) ppInfo);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        status = RpcExceptionCode();
        MAP_SECURITY_PACKAGE_ERROR(status);
    }

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsReplicaGetInfo2]"));
    DSLOG((0,"[PA=0x%x][PA=%ws][PA=%s][PA=%ws][PA=%ws][PA=0x%x][PA=0x%x][ST=%u][ET=%u][ER=%u][-]\n",
           InfoType,
           pszObjectDN ? pszObjectDN : L"NULL",
           puuidForSourceDsaObjGuid ? UuidToStr(puuidForSourceDsaObjGuid, tmpUuid) : "NULL",
           pszAttributeName ? pszAttributeName : L"NULL",
           pszValueDN ? pszValueDN : L"NULL",
           dwFlags,
           dwEnumerationContext,
           startTime, GetTickCount(), status));

    return status;
} /* DsReplicaGetInfo2W */


NTDSAPI
VOID
WINAPI
DsReplicaFreeInfo(
    DS_REPL_INFO_TYPE   InfoType,
    VOID *              pInfo
    )
/*++

Routine Description:

    Free a structure returned by a prior call to DsReplicaGetInfo().

Arguments:

    pInfo (IN) - Structure to free.

Return Value:

    None.

--*/
{
    if (NULL != pInfo) {
#define FREE(x) if (NULL != x) MIDL_user_free(x)

        DS_REPL_NEIGHBORSW *              pNeighbors;
        DS_REPL_OBJ_META_DATA *           pObjMetaData;
        DS_REPL_KCC_DSA_FAILURES *        pFailures;
        DS_REPL_PENDING_OPSW *            pPendingOps;
        DS_REPL_ATTR_VALUE_META_DATA *    pAttrValueMetaData;
        DS_REPL_CURSORS_3W *              pCursors3;
        DS_REPL_OBJ_META_DATA_2 *         pObjMetaData2;
        DS_REPL_ATTR_VALUE_META_DATA_2 *  pAttrValueMetaData2;
        DWORD                             i;

        // 98-10-29 JeffParh
        // RPC started stomping past the ned of its memory allocations when I
        // began using allocate(all_nodes) for these structures.  So we're
        // going to have to walk all the embedded pointers and free each one
        // individually.  Fun, eh? :-)

        switch (InfoType) {
        case DS_REPL_INFO_NEIGHBORS:
        case DS_REPL_INFO_REPSTO:
            pNeighbors = (DS_REPL_NEIGHBORSW *) pInfo;
            for (i = 0; i < pNeighbors->cNumNeighbors; i++) {
                FREE(pNeighbors->rgNeighbor[i].pszNamingContext);
                FREE(pNeighbors->rgNeighbor[i].pszSourceDsaDN);
                FREE(pNeighbors->rgNeighbor[i].pszSourceDsaAddress);
                FREE(pNeighbors->rgNeighbor[i].pszAsyncIntersiteTransportDN);
            }
            break;

        case DS_REPL_INFO_CURSORS_FOR_NC:
        case DS_REPL_INFO_CURSORS_2_FOR_NC:
        case DS_REPL_INFO_CLIENT_CONTEXTS:
            // No embedded pointers.
            break;

        case DS_REPL_INFO_METADATA_FOR_OBJ:
            pObjMetaData = (DS_REPL_OBJ_META_DATA *) pInfo;
            for (i = 0; i < pObjMetaData->cNumEntries; i++) {
                FREE(pObjMetaData->rgMetaData[i].pszAttributeName);
            }
            break;

        case DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES:
        case DS_REPL_INFO_KCC_DSA_LINK_FAILURES:
            pFailures = (DS_REPL_KCC_DSA_FAILURES *) pInfo;
            for (i = 0; i < pFailures->cNumEntries; i++) {
                FREE(pFailures->rgDsaFailure[i].pszDsaDN);
            }
            break;

        case DS_REPL_INFO_PENDING_OPS:
            pPendingOps = (DS_REPL_PENDING_OPSW *) pInfo;
            for (i = 0; i < pPendingOps->cNumPendingOps; i++) {
                FREE(pPendingOps->rgPendingOp[i].pszNamingContext);
                FREE(pPendingOps->rgPendingOp[i].pszDsaDN);
                FREE(pPendingOps->rgPendingOp[i].pszDsaAddress);
            }
            break;

        case DS_REPL_INFO_METADATA_FOR_ATTR_VALUE:
            pAttrValueMetaData = (DS_REPL_ATTR_VALUE_META_DATA *) pInfo;
            for (i = 0; i < pAttrValueMetaData->cNumEntries; i++) {
                FREE(pAttrValueMetaData->rgMetaData[i].pszObjectDn);
                FREE(pAttrValueMetaData->rgMetaData[i].pbData);
            }
            break;

        case DS_REPL_INFO_CURSORS_3_FOR_NC:
            pCursors3 = (DS_REPL_CURSORS_3W *) pInfo;
            for (i = 0; i < pCursors3->cNumCursors; i++) {
                FREE(pCursors3->rgCursor[i].pszSourceDsaDN);
            }
            break;

        case DS_REPL_INFO_METADATA_2_FOR_OBJ:
            pObjMetaData2 = (DS_REPL_OBJ_META_DATA_2 *) pInfo;
            for (i = 0; i < pObjMetaData2->cNumEntries; i++) {
                FREE(pObjMetaData2->rgMetaData[i].pszAttributeName);
                FREE(pObjMetaData2->rgMetaData[i].pszLastOriginatingDsaDN);
            }
            break;

        case DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE:
            pAttrValueMetaData2 = (DS_REPL_ATTR_VALUE_META_DATA_2 *) pInfo;
            for (i = 0; i < pAttrValueMetaData2->cNumEntries; i++) {
                FREE(pAttrValueMetaData2->rgMetaData[i].pszObjectDn);
                FREE(pAttrValueMetaData2->rgMetaData[i].pbData);
                FREE(pAttrValueMetaData2->rgMetaData[i].pszLastOriginatingDsaDN);
            }
            break;

        default:
            Assert(!"Unknown DS_REPLICA_INFO type!");
            break;
        }
#undef FREE

        MIDL_user_free(pInfo);
    }
} /* DsReplicaFreeInfo */



NTDSAPI
DWORD
WINAPI
DsReplicaVerifyObjectsW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN const UUID *pUuidDsaSrc,
    IN ULONG ulOptions
    )

/*++

Routine Description:

Verify all objects for an NC with a source.

Arguments:

    hDS - bind handle
    NameContext - dn of naming context
    pUuidDsaSrc - uuid of the source
    ulOptions - 
    
Return Value:

    WINAPI -

--*/

{
    DRS_MSG_REPVERIFYOBJ msgRepVerify;
    DWORD status;
    DSNAME *pName = NULL;

    // Validate

    if ( (hDS == NULL) ||
         (NameContext == NULL) ||
         (wcslen( NameContext ) == 0) ||
         (pUuidDsaSrc == NULL) ) {
        return ERROR_INVALID_PARAMETER;
    }

    if (!IS_DRS_REPLICA_VERIFY_OBJECT_V1_SUPPORTED(
	((BindState *) hDS)->pServerExtensions)) {
	return ERROR_NOT_SUPPORTED;
    }

    // Construct a DSNAME for the NameContext
    status = AllocBuildDsname( NameContext, &pName );
    if (status != ERROR_SUCCESS) {
        return status;
    }

    // Initialize Structure

    memset( &msgRepVerify, 0, sizeof( msgRepVerify ) );

    msgRepVerify.V1.pNC = pName;
    msgRepVerify.V1.uuidDsaSrc = *pUuidDsaSrc;
    msgRepVerify.V1.ulOptions = ulOptions;

    // Call the server

    __try
    {
        status = _IDL_DRSReplicaVerifyObjects(
                        ((BindState *) hDS)->hDrs,
                        1,                              // dwInVersion
                        &msgRepVerify );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = RpcExceptionCode();
    }

    MAP_SECURITY_PACKAGE_ERROR( status );

    LocalFree( pName );

    return status;
} /* DsReplicaVerifyObjectsW */


NTDSAPI
DWORD
WINAPI
DsReplicaVerifyObjectsA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN const UUID *pUuidDsaSrc,
    IN ULONG ulOptions
    )

/*++

Routine Description:

Ascii version of ReplicaVerifyObjects. Calls DsReplicaVerifyObjectsW.

Arguments:

    hDS -
    NameContext -
    pUuidDsaSrc -
    dwFlags -

Return Value:

    WINAPI -

--*/

{
    DWORD status;
    LPWSTR nameContextW = NULL;

    status = AllocConvertWide( NameContext, &nameContextW );
    if (status != ERROR_SUCCESS) {
        return status;
    }

    status = DsReplicaVerifyObjectsW( hDS, nameContextW, pUuidDsaSrc, ulOptions );

    if (nameContextW != NULL) {
        LocalFree( nameContextW );
    }

    return status;
} /* DsReplicaVerifyObjectsA */


DWORD
translateOptions(
    DWORD PublicOptions,
    POPTION_TRANSLATION Table
    )

/*++

Routine Description:

Utility routine to translate options.

Performs a simple list lookup.

ENHANCEMENT: if the tables were sorted, we could do a binary search

Arguments:

    PublicOptions -
    Table -

Return Value:

    DWORD -

--*/

{
    DWORD i, internalOptions;

    internalOptions = 0;
    for( i = 0; 0 != Table[i].PublicOption; i++ ) {
        if (PublicOptions & Table[i].PublicOption) {
            internalOptions |= Table[i].InternalOption;
        }
    }

    return internalOptions;
} /* translateOptions */

#if WIN95 || WINNT4

//
// *** COPIED FROM dscommon/dsutil.c ***
//

UUID gNullUuid = {0,0,0,{0,0,0,0,0,0,0,0}};

// Return TRUE if the ptr to the UUID is NULL, or the uuid is all zeroes

BOOL fNullUuid (const UUID *pUuid)
{
    if (!pUuid) {
        return TRUE;
    }

    if (memcmp (pUuid, &gNullUuid, sizeof (UUID))) {
        return FALSE;
    }
    return TRUE;
}

#if DBG
UCHAR * UuidToStr(CONST UUID* pUuid, UCHAR *pOutUuid)
{
    int i;
    unsigned char * pchar;

    if (!fNullUuid (pUuid)) {
        pchar = (char*) pUuid;

        for (i=0;i < sizeof(UUID);i++) {
             sprintf (&(pOutUuid[i*2]), "%.2x", (*(pchar++)));
        }
    } else {
        memset (pOutUuid, '0', sizeof(UUID)*2);
        pOutUuid[sizeof(UUID)*2] = 0;
    }
    return pOutUuid;
}
#endif
#endif

/* end replica.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsapi\schguid.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    schguid.c

Abstract:

    Implementation of DsMapSchemaGuid APIs.

Author:

    DaveStr     19-May-98

Environment:

    User Mode - Win32

Revision History:

--*/

#define _NTDSAPI_           // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <lmcons.h>         // MAPI constants req'd for lmapibuf.h
#include <lmapibuf.h>       // NetApiBufferFree()
#include <crt\excpt.h>      // EXCEPTION_EXECUTE_HANDLER
#include <dsgetdc.h>        // DsGetDcName()
#include <rpc.h>            // RPC defines
#include <rpcndr.h>         // RPC defines
#include <rpcbind.h>        // GetBindingInfo(), etc.
#include <drs.h>            // wire function prototypes
#include <bind.h>           // BindState
#include <util.h>           // OFFSET macro
#include <msrpc.h>          // DS RPC definitions
#include <stdio.h>          // sprintf, etc.
#include <ntdsapip.h>       // DS_LIST_* definitions

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Typedefs and such                                                    //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

typedef struct {
    VOID                *pDsNameResult;
    DS_SCHEMA_GUID_MAPW map[1];
} PrivateMapW;

#define PrivateMapFromMapW(p)                                           \
    ((PrivateMapW *) (((CHAR *) pMap) - OFFSET(PrivateMapW, map[0])))

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsFreeSchemaGuidMap                                                  //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
DsFreeSchemaGuidMapW(
    DS_SCHEMA_GUID_MAPW *pMap
    )
{
    PrivateMapW *pPrivateMap;
    
    if ( pMap )
    {
        pPrivateMap = PrivateMapFromMapW(pMap);
        DsFreeNameResultW(pPrivateMap->pDsNameResult);
        LocalFree(pPrivateMap);
    }
}

VOID
DsFreeSchemaGuidMapA(
    DS_SCHEMA_GUID_MAPA *pMap
    )
{
    DsFreeSchemaGuidMapW((DS_SCHEMA_GUID_MAPW *) pMap);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// PrivateGuidStatusToPublicGuidStatus                                  //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
PrivateGuidStatusToPublicGuidStatus(
    DWORD   privateStatus,
    DWORD   *pPublicStatus
    )
{
    switch ( privateStatus )
    {
    case DS_NAME_ERROR_SCHEMA_GUID_ATTR:

        *pPublicStatus = DS_SCHEMA_GUID_ATTR;
        break;

    case DS_NAME_ERROR_SCHEMA_GUID_ATTR_SET:
    
        *pPublicStatus = DS_SCHEMA_GUID_ATTR_SET;
        break;

    case DS_NAME_ERROR_SCHEMA_GUID_CLASS:
    
        *pPublicStatus = DS_SCHEMA_GUID_CLASS;
        break;

    case DS_NAME_ERROR_SCHEMA_GUID_CONTROL_RIGHT:
    
        *pPublicStatus = DS_SCHEMA_GUID_CONTROL_RIGHT;
        break;

    case DS_NAME_ERROR_SCHEMA_GUID_NOT_FOUND:
    default:

        *pPublicStatus = DS_SCHEMA_GUID_NOT_FOUND;
        break;
    }
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsMapSchemaGuidsCommon                                               //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsMapSchemaGuidsCommon(
    BOOL                    fUnicode,       // in
    HANDLE                  hDs,            // in
    DWORD                   cGuids,         // in
    GUID                    *rGuids,        // in
    DS_SCHEMA_GUID_MAPW     **ppGuidMapW    // out
    )

/*++

  Routine Description:

    Common routine for DsMapSchemaGuids.

  Parameters:

    Same as DsMapSchemaGuids plus fUnicode flag.

  Return Values:

    Same as DsMapSchemaGuids.

--*/
{
    DWORD           i;
    PWCHAR          *rpNames = NULL;
    DWORD           dwErr = ERROR_SUCCESS;
    DS_NAME_RESULTW *pResultW = NULL;
    DWORD           cBytes;
    PrivateMapW     *pPrivateMapW = NULL;

    // Reject invalid parameters.

    if ( !hDs || !cGuids || !rGuids || !ppGuidMapW )
    {
        return(ERROR_INVALID_PARAMETER);
    }

    *ppGuidMapW = NULL;

    // String-ize the GUIDs.

    rpNames = (PWCHAR *) LocalAlloc(LPTR, cGuids * sizeof(PWCHAR));

    if ( !rpNames )
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    for ( i = 0; i < cGuids; i++ )
    {
        rpNames[i] = (PWCHAR) LocalAlloc(LPTR, 40 * sizeof(WCHAR));

        if ( !rpNames[i] )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        if ( fUnicode )
        {
            swprintf(
                rpNames[i],
                L"{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
                rGuids[i].Data1,    rGuids[i].Data2,        rGuids[i].Data3,
                rGuids[i].Data4[0], rGuids[i].Data4[1],     rGuids[i].Data4[2],
                rGuids[i].Data4[3], rGuids[i].Data4[4],     rGuids[i].Data4[5],
                rGuids[i].Data4[6], rGuids[i].Data4[7]);
        }
        else
        {
            sprintf(
                (CHAR *) rpNames[i],
                "{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
                rGuids[i].Data1,    rGuids[i].Data2,        rGuids[i].Data3,
                rGuids[i].Data4[0], rGuids[i].Data4[1],     rGuids[i].Data4[2],
                rGuids[i].Data4[3], rGuids[i].Data4[4],     rGuids[i].Data4[5],
                rGuids[i].Data4[6], rGuids[i].Data4[7]);
        }
    }

    // Call DsCrackNames with the right private formatOffered value.
    
    if ( fUnicode )
    {
        dwErr = DsCrackNamesW(  hDs,
                                DS_NAME_NO_FLAGS,
                                DS_MAP_SCHEMA_GUID,
                                DS_DISPLAY_NAME,
                                cGuids,
                                rpNames,
                                &pResultW);
    }
    else
    {
        dwErr = DsCrackNamesA(  hDs,
                                DS_NAME_NO_FLAGS,
                                DS_MAP_SCHEMA_GUID,
                                DS_DISPLAY_NAME,
                                cGuids,
                                (PCHAR *) rpNames,
                                (PDS_NAME_RESULTA *) &pResultW);
    }

    if (    dwErr
         || (NULL == pResultW)
         || (0 == pResultW->cItems)
         || (NULL == pResultW->rItems) )
    {
        if ( !dwErr )
        {
            dwErr = ERROR_DS_OPERATIONS_ERROR;
        }

        goto ErrorExit;
    }

    // Morph DsCrackNames result into DS_SCHEMA_GUID_MAP.

    cBytes =   sizeof(PrivateMapW)
             + (cGuids * sizeof(DS_SCHEMA_GUID_MAPW));
    pPrivateMapW = (PrivateMapW *) LocalAlloc(LPTR, cBytes);

    if ( !pPrivateMapW )
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }
    
    pPrivateMapW->pDsNameResult = pResultW;

    for ( i = 0; i < cGuids; i++ )
    {
        pPrivateMapW->map[i].guid = rGuids[i];
        PrivateGuidStatusToPublicGuidStatus(
                        pResultW->rItems[i].status,
                        &pPrivateMapW->map[i].guidType);
    
        if (    (DS_NAME_ERROR_SCHEMA_GUID_NOT_FOUND != 
                                            pPrivateMapW->map[i].guidType)
             && pResultW->rItems[i].pName )
        {
            pPrivateMapW->map[i].pName = pResultW->rItems[i].pName;
        }
    }

    // Now return address of DS_SCHEMA_GUID_MAP which DsFreeSchemaGuidMap
    // knows is an offset within PrivateMap.

    *ppGuidMapW = (DS_SCHEMA_GUID_MAPW *) &pPrivateMapW->map;

ErrorExit:

    if ( rpNames ) 
    {
        for ( i = 0; i < cGuids; i++ )
        {
            if ( rpNames[i] )
            {
                LocalFree(rpNames[i]);
            }
        }

        LocalFree(rpNames);
    }

    if ( dwErr && pResultW )
    {
        DsFreeNameResultW(pResultW);
    }

    if ( dwErr && pPrivateMapW )
    {
        LocalFree(pPrivateMapW);
    }

    return(dwErr);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsMapSchemaGuids{A|W}                                                //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsMapSchemaGuidsA(
    HANDLE                  hDs,            // in
    DWORD                   cGuids,         // in
    GUID                    *rGuids,        // in
    DS_SCHEMA_GUID_MAPA     **ppGuidMap     // out
    )
{
    return( DsMapSchemaGuidsCommon( FALSE,
                                    hDs,
                                    cGuids,
                                    rGuids,
                                    (DS_SCHEMA_GUID_MAPW **) ppGuidMap));
}

DWORD
DsMapSchemaGuidsW(
    HANDLE                  hDs,            // in
    DWORD                   cGuids,         // in
    GUID                    *rGuids,        // in
    DS_SCHEMA_GUID_MAPW     **ppGuidMap     // out
    )
{
    return( DsMapSchemaGuidsCommon( TRUE,
                                    hDs,
                                    cGuids,
                                    rGuids,
                                    ppGuidMap));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsapi\remove.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    remove.c

Abstract:

    Implementation of ntdsapi.dll DsRemoveServer/Domain routines

Author:

    ColinBr     14-Jan-98

Environment:

    User Mode - Win32

Revision History:

--*/

#define _NTDSAPI_           // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>

#include <malloc.h>         // alloca()
#include <crt\excpt.h>      // EXCEPTION_EXECUTE_HANDLER
#include <dsgetdc.h>        // DsGetDcName()
#include <rpc.h>            // RPC defines
#include <rpcndr.h>         // RPC defines
#include <rpcbind.h>        // GetBindingInfo(), etc.
#include <drs_w.h>          // wire function prototypes
#include <bind.h>           // BindState
#include <msrpc.h>          // DS RPC definitions, MAP_SECURITY_STATUS
#include <dsutil.h>         // MAP_SECURITY_PACKAGE_ERROR
#include <dststlog.h>       // DSLOG

//
// Dll Entrypoints
//
DWORD
DsRemoveDsServerW(
    HANDLE  hDs,             // in
    LPWSTR  ServerDN,        // in
    LPWSTR  DomainDN,        // in,  optional
    BOOL   *fLastDcInDomain, // out, optional
    BOOL    fCommit          // in
    )
/*++

Routine Description:

    This routine removes all traces of a directory service agent from the 
    global area of the directory service (configuration container).  A 
    server dn is passed in; that server is not removed but the ntdsa object
    "underneath" that server is removed.  In addition, this function will 
    return whether the server deleted is the last dc in the domain, as 
    indicated by information on this ds.

Arguments:

    hDs            : a valid handle returned from DsBind
    
    ServerDN       : a null terminated string representing the string DN name
                     of a server object
                    
    DomainDN       : a null terminated string of a domain that is hosted by 
                     ServerDN
                    
    fLastDcInDomain: pointer to bool set on function success if ServerDN is the
                     last DC in the DomainDN
                                       
    fCommit        : boolean indicating the caller really wants to remove 
                     the server.  If false, this function will still check
                     the object's existence and fLastDcInDomain status

Return Value:

    A winerror, notably:
    
    ERROR_SUCCESS: 
    
    DS_ERR_CANT_DELETE_DSA_OBJ:  the ServerDN is the server that we currently
                                 bound to
    
    DS_ERR_NO_CROSSREF_FOR_NC:   can't find a crossref object for DomainDN

    ERROR_ACCESS_DENIED:         the caller doesn't have the correct permissions
                                 to delete the object    

--*/
{
    DWORD WinError;

    DRS_MSG_RMSVRREQ   RequestParam;
    DRS_MSG_RMSVRREPLY ReplyParam;
    DWORD              dwInVersion = 1;
    DWORD              dwOutVersion = 0;
    LPWSTR             NtdsServerDN = NULL;
#if DBG
    DWORD               startTime = GetTickCount();
#endif

    //
    // Parameter check
    //
    if ( NULL == hDs 
      || NULL == ServerDN 
      || 0    == wcslen( ServerDN ) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // First see if this function is exported
    //
    if ( !IS_DRS_REMOVEAPI_SUPPORTED( ((BindState *) hDs)->pServerExtensions ) )
    {
        return RPC_S_CANNOT_SUPPORT;
    }

    __try
    {

        RtlZeroMemory( &RequestParam, sizeof( RequestParam ) );
        RtlZeroMemory( &ReplyParam, sizeof( ReplyParam ) );


        //
        // Set up request
        //
        RequestParam.V1.ServerDN = ServerDN;
        RequestParam.V1.DomainDN = DomainDN;
        RequestParam.V1.fCommit  = fCommit;

        //
        // Call the server
        //
        WinError = _IDL_DRSRemoveDsServer( ((BindState *) hDs)->hDrs,
                                          dwInVersion,
                                         &RequestParam,
                                         &dwOutVersion,
                                         &ReplyParam );

        if ( ERROR_SUCCESS == WinError )
        {
            if ( 1 != dwOutVersion )
            {
                WinError = RPC_S_INVALID_VERS_OPTION;
            }
            else
            {
                //
                // Extract results
                //
                if ( fLastDcInDomain )
                {
                    *fLastDcInDomain = (BOOL)ReplyParam.V1.fLastDcInDomain;
                }

            }
        }

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        WinError = RpcExceptionCode();
    }

    MAP_SECURITY_PACKAGE_ERROR( WinError );

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsRemoveDsServer]"));
    DSLOG((0,"[SV=%ws][DN=%ws][PA=0x%x][ST=%u][ET=%u][ER=%u][-]\n",
           ServerDN, 
           DomainDN ? DomainDN : L"NULL", 
           fCommit, startTime, GetTickCount(), WinError))

    return( WinError );
}


DWORD
DsRemoveDsServerA(
    HANDLE  hDs,              // in
    LPSTR   ServerDN,         // in
    LPSTR   DomainDN,         // in,  optional
    BOOL   *fLastDcInDomain,  // out, optional
    BOOL    fCommit           // in
    )
/*++

Routine Description:

    This function is an ANSI wrapper for DsRemoveDsServerW.  

Arguments:

Return Value:

--*/
{
    DWORD WinError;
    ULONG Size, Length;

    LPWSTR wcServerDN = NULL;
    LPWSTR wcDomainDN = NULL;

    if ( ServerDN )
    {
        Length = MultiByteToWideChar( CP_ACP,
                                      MB_PRECOMPOSED,
                                      ServerDN,
                                      -1,   // calculate length of ServerDN
                                      NULL,
                                      0 );

        if ( Length > 0 )
        {

            Size = (Length + 1) * sizeof( WCHAR );
            wcServerDN = (LPWSTR) alloca( Size );
            RtlZeroMemory( wcServerDN, Size );
        
            Length = MultiByteToWideChar( CP_ACP,
                                          MB_PRECOMPOSED,
                                          ServerDN,
                                          -1,  // calculate length of ServerDN
                                          wcServerDN,
                                          Length + 1 );
        }

        if ( 0 == Length )
        {
            WinError = GetLastError();
            goto Cleanup;
        }

    }


    if ( DomainDN )
    {
        Length = MultiByteToWideChar( CP_ACP,
                                      MB_PRECOMPOSED,
                                      DomainDN,
                                      -1,   // calculate length of DomainDN
                                      NULL,
                                      0 );

        if ( Length > 0 )
        {

            Size = (Length + 1) * sizeof( WCHAR );
            wcDomainDN = (LPWSTR) alloca( Size );
            RtlZeroMemory( wcDomainDN, Size );
        
            Length = MultiByteToWideChar( CP_ACP,
                                          MB_PRECOMPOSED,
                                          DomainDN,
                                          -1,  // calculate length of DomainDN
                                          wcDomainDN,
                                          Length + 1 );
        }

        if ( 0 == Length )
        {
            WinError = GetLastError();
            goto Cleanup;
        }

    }

    WinError =  DsRemoveDsServerW( hDs,
                                   wcServerDN,
                                   wcDomainDN,
                                   fLastDcInDomain,
                                   fCommit );

    
Cleanup:


    return WinError;
}

DWORD
DsRemoveDsDomainW(
    HANDLE  hDs,               // in
    LPWSTR  DomainDN           // in
    )
/*++

Routine Description:

    This routine removes all traces of the domain naming context specified
    by DomainDN from the global area of the directory service (configuration
    container). 

Arguments:

    hDs            : a valid handle returned from DsBind
    
    DomainDN       : a null terminated string of a domain to be removed
    
Return Value:

    DS_ERR_CANT_DELETE:          can't delete the domain object as there
                                 are still servers (dc's) that host that domain
                                 
--*/
{
    DWORD WinError;

    DRS_MSG_RMDMNREQ   RequestParam;
    DRS_MSG_RMDMNREPLY ReplyParam;
    DWORD              dwInVersion = 1;
    DWORD              dwOutVersion = 0;
#if DBG
    DWORD               startTime = GetTickCount();
#endif

    //
    // Parameter check
    //
    if ( (NULL == hDs) 
      || (NULL == DomainDN) 
      || (0    == wcslen( DomainDN )) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // First see if this function is exported
    //
    if ( !IS_DRS_REMOVEAPI_SUPPORTED( ((BindState *) hDs)->pServerExtensions ) )
    {
        return RPC_S_CANNOT_SUPPORT;
    }


    __try
    {

        RtlZeroMemory( &RequestParam, sizeof( RequestParam ) );
        RtlZeroMemory( &ReplyParam, sizeof( ReplyParam ) );

        //
        // Set up request
        //
        RequestParam.V1.DomainDN = DomainDN;

        //
        // Call the server
        //
        WinError = _IDL_DRSRemoveDsDomain( ((BindState *) hDs)->hDrs,
                                           dwInVersion,
                                          &RequestParam,
                                          &dwOutVersion,
                                          &ReplyParam );

        if ( ERROR_SUCCESS != WinError )
        {
            if ( 1 != dwOutVersion )
            {
                WinError = RPC_S_INVALID_VERS_OPTION;
            }
            else
            {
                //
                // There are not out parameters in version 1
                //
                NOTHING;
            }
        }

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        WinError = RpcExceptionCode();
    }

    MAP_SECURITY_PACKAGE_ERROR( WinError );

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsRemoveDsDomain]"));
    DSLOG((0,"[DN=%ws][ST=%u][ET=%u][ER=%u][-]\n",
           DomainDN, startTime, GetTickCount(), WinError))

    return( WinError );
}

DWORD
DsRemoveDsDomainA(
    HANDLE  hDs,               // in
    LPSTR   DomainDN           // in
    )
/*++

Routine Description:

    This function is an ansi wrapper for DsRemoveDsDomainW.

Arguments:

Return Value:

--*/
{

    DWORD WinError;
    ULONG Size, Length;

    LPWSTR wcDomainDN = NULL;

    if ( (NULL == hDs) 
      || (NULL == DomainDN) 
      || (0    == strlen( DomainDN )) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    Length = MultiByteToWideChar( CP_ACP,
                                  MB_PRECOMPOSED,
                                  DomainDN,
                                  -1,   // calculate length of DomainDN
                                  NULL,
                                  0 );

    if ( Length > 0 )
    {

        Size = (Length + 1) * sizeof( WCHAR );
        wcDomainDN = (LPWSTR) alloca( Size );
        RtlZeroMemory( wcDomainDN, Size );
    
        Length = MultiByteToWideChar( CP_ACP,
                                      MB_PRECOMPOSED,
                                      DomainDN,
                                      -1,  // calculate length of DomainDN
                                      wcDomainDN,
                                      Length + 1 );
    }

    if ( 0 == Length )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    WinError =  DsRemoveDsDomainW( hDs,
                                   wcDomainDN );

    
Cleanup:

    return WinError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsapi\tlog.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    tlog.c

Abstract:

    Routines dealing with ds logging

Author:

    Johnson Apacible    (JohnsonA)  23-Oct-1998

--*/

#include <windows.h>
#include <winsock.h>
#include <winerror.h>
#include <rpc.h>            // RPC defines
#include <stdlib.h>         // atoi, itoa
#include <dststlog.h>
#include <tlog.h>           // ds logging

// DsLogEntry is supported on chk'ed builds of w2k or greater
#if DBG && !WIN95 && !WINNT4

CRITICAL_SECTION csLogFile;
BOOL fInitializedLogCS = FALSE;
BOOL LogFileOpened = FALSE;

//
// from dscommon\filelog.c
//

VOID
DsPrintRoutineV(
    IN DWORD Flags,
    IN LPSTR Format,
    va_list arglist
    );

BOOL
DsOpenLogFile(
    IN PCHAR FilePrefix,
    IN PCHAR MiddleName,
    IN BOOL fCheckDSLOGMarker
    );

VOID
DsCloseLogFile(
    VOID
    );

BOOL
DsLogEntry(
    IN DWORD    Flags,
    IN LPSTR    Format,
    ...
    )
{
    va_list arglist;
    static BOOL LogFileOpened = FALSE;

    if ( !fInitializedLogCS ) {
        return FALSE;
    }

    //
    // vsprintf isn't multithreaded + we don't want to intermingle output
    // from different threads.
    //

    EnterCriticalSection( &csLogFile );

    if ( !LogFileOpened ) {
        LogFileOpened = DsOpenLogFile("ds", NULL, TRUE);
    }

    //
    // Simply change arguments to va_list form and call DsPrintRoutineV
    //

    va_start(arglist, Format);

    DsPrintRoutineV( Flags, Format, arglist );

    va_end(arglist);

    LeaveCriticalSection( &csLogFile );
    return TRUE;
}


VOID
InitDsLog(
    VOID
    )
{
    fInitializedLogCS = InitializeCriticalSectionAndSpinCount(&csLogFile,400);
    pfnDsPrintLog=(DS_PRINTLOG)DsLogEntry;
    return;
} // InitDsLog

VOID
TermDsLog(
    VOID
    )
{
    if (fInitializedLogCS) {
        if (LogFileOpened) {
            DsCloseLogFile();
        }
        LogFileOpened = FALSE;
        DeleteCriticalSection(&csLogFile);
        fInitializedLogCS = FALSE;
        pfnDsPrintLog=(DS_PRINTLOG)NULL;
    }
    return;
} // TermDsLog

//
// -----
// NOT SUPPORTED IN WIN95 AND WINNT4
// -----
//
#else DBG && !WIN95 && !WINNT4
BOOL
DsLogEntry(
    IN DWORD    Flags,
    IN LPSTR    Format,
    ...
    )
{
#if !WIN95 && !WINNT4
    return TRUE;
#else
    return FALSE;
#endif
}
#endif DBG && !WIN95 && !WINNT4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsapi\siteinfo.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    siteinfo.c

Abstract:

    Implementation of site/server/domain info APIs.

Author:

    DaveStr     06-Apr-98

Environment:

    User Mode - Win32

Revision History:

--*/

#define _NTDSAPI_           // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <malloc.h>         // alloca()
#include <crt\excpt.h>      // EXCEPTION_EXECUTE_HANDLER
#include <dsgetdc.h>        // DsGetDcName()
#include <rpc.h>            // RPC defines
#include <rpcndr.h>         // RPC defines
#include <rpcbind.h>        // GetBindingInfo(), etc.
#include <drs.h>            // wire function prototypes
#include <bind.h>           // BindState
#include <ntdsa.h>          // GetRDNInfo
#include <scache.h>         // req'd for mdlocal.h
#include <dbglobal.h>       // req'd for mdlocal.h
#include <mdglobal.h>       // req'd for mdlocal.h
#include <mdlocal.h>        // CountNameParts
#include <attids.h>         // ATT_DOMAIN_COMPONENT
#include <ntdsapip.h>       // DS_LIST_* definitions

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsListSites                                                          //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsListSitesA(
    HANDLE              hDs,            // in
    PDS_NAME_RESULTA    *ppSites)       // out

/*++

  Routine Description:

    Lists sites in the enterprise.

  Parameters:

    hDS - Pointer to BindState for this session.

    ppSites - Pointer to PDS_NAME_RESULT which receives knowns sites
        on return.

  Return Values:

    Win32 error codes as per DsCrackNames.

--*/
{
    LPSTR dummy = "dummy";

    *ppSites = NULL;
    return(DsCrackNamesA(   hDs,
                            DS_NAME_NO_FLAGS,
                            DS_LIST_SITES,
                            DS_FQDN_1779_NAME,
                            1,
                            &dummy,
                            ppSites));
}
                            
DWORD
DsListSitesW(
    HANDLE              hDs,            // in
    PDS_NAME_RESULTW    *ppSites)       // out
{
    LPWSTR dummy = L"dummy";
    
    *ppSites = NULL;
    return(DsCrackNamesW(   hDs,
                            DS_NAME_NO_FLAGS,
                            DS_LIST_SITES,
                            DS_FQDN_1779_NAME,
                            1,
                            &dummy,
                            ppSites));
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsListServersInSite                                                  //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsListServersInSiteA(
    HANDLE              hDs,            // in
    LPCSTR              site,           // in
    PDS_NAME_RESULTA    *ppServers)     // out
/*++

  Routine Description:

    Lists servers in a site.

  Parameters:

    hDS - Pointer to BindState for this session.

    site - Name of site whose servers to list.

    ppSites - Pointer to PDS_NAME_RESULT which receives knowns servers
        on return.

  Return Values:

    Win32 error codes as per DsCrackNames.

--*/
{
    *ppServers = NULL;
    return(DsCrackNamesA(   hDs,
                            DS_NAME_NO_FLAGS,
                            DS_LIST_SERVERS_IN_SITE,
                            DS_FQDN_1779_NAME,
                            1,
                            &site,
                            ppServers));
}

DWORD
DsListServersInSiteW(
    HANDLE              hDs,            // in
    LPCWSTR             site,           // in
    PDS_NAME_RESULTW    *ppServers)     // out
{
    *ppServers = NULL;
    return(DsCrackNamesW(   hDs,
                            DS_NAME_NO_FLAGS,
                            DS_LIST_SERVERS_IN_SITE,
                            DS_FQDN_1779_NAME,
                            1,
                            &site,
                            ppServers));
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsListDomainsInSite                                                  //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsListDomainsInSiteA(
    HANDLE              hDs,            // in
    LPCSTR              site,           // in
    PDS_NAME_RESULTA    *ppDomains)     // out
/*++

  Routine Description:

    Lists domains in a site.

  Parameters:

    hDS - Pointer to BindState for this session.

    site - Name of site whose domains to list.  Use NULL for all
        domains in all sites.

    ppSites - Pointer to PDS_NAME_RESULT which receives knowns domains
        on return.

  Return Values:

    Win32 error codes as per DsCrackNames.

--*/
{
    CHAR *dummy = "dummyArg";

    *ppDomains = NULL;
    return(DsCrackNamesA(   hDs,
                            DS_NAME_NO_FLAGS,
                            NULL == site  
                                ? DS_LIST_DOMAINS
                                : DS_LIST_DOMAINS_IN_SITE,
                            DS_FQDN_1779_NAME,
                            1,
                            NULL == site ? &dummy : &site,
                            ppDomains));
}

DWORD
DsListDomainsInSiteW(
    HANDLE              hDs,            // in
    LPCWSTR             site,           // in
    PDS_NAME_RESULTW    *ppDomains)     // out
{
    WCHAR *dummy = L"dummyArg";

    *ppDomains = NULL;
    return(DsCrackNamesW(   hDs,
                            DS_NAME_NO_FLAGS,
                            NULL == site
                                ? DS_LIST_DOMAINS
                                : DS_LIST_DOMAINS_IN_SITE,
                            DS_FQDN_1779_NAME,
                            1,
                            NULL == site ? &dummy : &site,
                            ppDomains));
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsListServersForDomainInSite                                         //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsListServersForDomainInSiteA(
    HANDLE              hDs,            // in
    LPCSTR              domain,         // in
    LPCSTR              site,           // in
    PDS_NAME_RESULTA    *ppServers)     // out
/*++

  Routine Description:

    Lists servers for a domains in a site.

  Parameters:

    hDS - Pointer to BindState for this session.

    domain - Name of domains whose servers to list.

    site - Name of site whose servers to list.

    ppSites - Pointer to PDS_NAME_RESULT which receives knowns servers
        on return.

  Return Values:

    Win32 error codes as per DsCrackNames.

--*/
{
    LPCSTR  args[2] = { 0, 0 };
    DWORD   retVal;

    *ppServers = NULL;

    if ( NULL == domain )
    {
        args[0] = site;
        retVal = DsCrackNamesA( hDs,
                                DS_NAME_NO_FLAGS,
                                DS_LIST_SERVERS_WITH_DCS_IN_SITE,
                                DS_FQDN_1779_NAME,
                                1,
                                args,
                                ppServers);
    }
    else
    {
        args[0] = domain;
        args[1] = site;
        retVal = DsCrackNamesA( hDs,
                                DS_NAME_NO_FLAGS,
                                DS_LIST_SERVERS_FOR_DOMAIN_IN_SITE,
                                DS_FQDN_1779_NAME,
                                2,
                                args,
                                ppServers);
    }

    return(retVal);
}

DWORD
DsListServersForDomainInSiteW(
    HANDLE              hDs,            // in
    LPCWSTR             domain,         // in
    LPCWSTR             site,           // in
    PDS_NAME_RESULTW    *ppServers)     // out
{
    LPCWSTR args[2] = { 0, 0 };
    DWORD   retVal;

    *ppServers = NULL;

    if ( NULL == domain )
    {
        args[0] = site;
        retVal = DsCrackNamesW( hDs,
                                DS_NAME_NO_FLAGS,
                                DS_LIST_SERVERS_WITH_DCS_IN_SITE,
                                DS_FQDN_1779_NAME,
                                1,
                                args,
                                ppServers);
    }
    else
    {
        args[0] = domain;
        args[1] = site;
        retVal = DsCrackNamesW( hDs,
                                DS_NAME_NO_FLAGS,
                                DS_LIST_SERVERS_FOR_DOMAIN_IN_SITE,
                                DS_FQDN_1779_NAME,
                                2,
                                args,
                                ppServers);
    }

    return(retVal);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsListInfoForServer                                                  //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsListInfoForServerA(
    HANDLE              hDs,            // in
    LPCSTR              server,         // in
    PDS_NAME_RESULTA    *ppInfo)        // out
/*++

  Routine Description:

    Lists misc. info for a server.

  Parameters:

    hDS - Pointer to BindState for this session.

    server - Name of server of interest.

    ppInfo - Pointer to PDS_NAME_RESULT which receives knowns info
        on return.

  Return Values:

    Win32 error codes as per DsCrackNames.

--*/
{
    *ppInfo = NULL;
    return(DsCrackNamesA(   hDs,
                            DS_NAME_NO_FLAGS,
                            DS_LIST_INFO_FOR_SERVER,
                            DS_FQDN_1779_NAME,
                            1,
                            &server,
                            ppInfo));
}

DWORD
DsListInfoForServerW(
    HANDLE              hDs,            // in
    LPCWSTR             server,         // in
    PDS_NAME_RESULTW    *ppInfo)        // out
{
    *ppInfo = NULL;
    return(DsCrackNamesW(   hDs,
                            DS_NAME_NO_FLAGS,
                            DS_LIST_INFO_FOR_SERVER,
                            DS_FQDN_1779_NAME,
                            1,
                            &server,
                            ppInfo));
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DsListRoles                                                          //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DsListRolesA(
    HANDLE              hDs,            // in
    PDS_NAME_RESULTA    *ppRoles)       // out

/*++

  Routine Description:

    Lists the roles this server knows about.  Not the same as the
    roles this server owns - though that would be a subset.

  Parameters:

    hDS - Pointer to BindState for this session.

    ppSites - Pointer to PDS_NAME_RESULT which receives knowns roles
        on return.

  Return Values:

    Win32 error codes as per DsCrackNames.

--*/
{
    LPSTR dummy = "dummy";

    *ppRoles = NULL;
    return(DsCrackNamesA(   hDs,
                            DS_NAME_NO_FLAGS,
                            DS_LIST_ROLES,
                            DS_FQDN_1779_NAME,
                            1,
                            &dummy,
                            ppRoles));
}
                            
DWORD
DsListRolesW(
    HANDLE              hDs,            // in
    PDS_NAME_RESULTW    *ppRoles)       // out
{
    LPWSTR dummy = L"dummy";
    
    *ppRoles = NULL;
    return(DsCrackNamesW(   hDs,
                            DS_NAME_NO_FLAGS,
                            DS_LIST_ROLES,
                            DS_FQDN_1779_NAME,
                            1,
                            &dummy,
                            ppRoles));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsapi\tlog.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    tlog.h

Abstract:

    Routines dealing with ds logging


Environment:

    User Mode - Win32

--*/

#ifndef __TLOG_H__
#define __TLOG_H__

// DsLogEntry is supported on chk'ed builds of w2k or greater
#if DBG && !WIN95 && !WINNT4

VOID InitDsLog(VOID);
VOID TermDsLog(VOID);
#define INITDSLOG() InitDsLog()
#define TERMDSLOG() TermDsLog()

#else DBG && !WIN95 && !WINNT4

#define INITDSLOG()
#define TERMDSLOG()

#endif DBG && !WIN95 && !WINNT4

#endif __TLOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsapi\util.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    private.h

Abstract:

    Private definitions inside ntdsapi.dll

Author:

    Will Lees (wlees) 02-Feb-1998

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#ifndef _PRIVATE_
#define _PRIVATE_

#define OFFSET(s,m) \
    ((size_t)((BYTE*)&(((s*)0)->m)-(BYTE*)0))

#define NUMBER_ELEMENTS( A ) ( sizeof( A ) / sizeof( A[0] ) )

// util.c

DWORD
InitializeWinsockIfNeeded(
    VOID
    );

VOID
TerminateWinsockIfNeeded(
    VOID
    );

DWORD
AllocConvertWide(
    IN LPCSTR StringA,
    OUT LPWSTR *pStringW
    );

DWORD
AllocConvertWideBuffer(
    IN  DWORD   LengthA,
    IN  PCCH    BufferA,
    OUT PWCHAR  *OutBufferW
    );

DWORD
AllocConvertNarrow(
    IN LPCWSTR StringW,
    OUT LPSTR *pStringA
    );

DWORD
AllocConvertNarrowUTF8(
    IN LPCWSTR StringW,
    OUT LPSTR *pStringA
    );

DWORD
AllocBuildDsname(
    IN LPCWSTR StringDn,
    OUT DSNAME **ppName
    );

DWORD
ConvertScheduleToReplTimes(
    PSCHEDULE pSchedule,
    REPLTIMES *pReplTimes
    );

#endif /* _PRIVATE_ */

/* end private.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsapi\util.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    util.c

Abstract:

   Common utility routines
   For internal use inside ntdsapi.dll
   DO NOT EXPOSE IN NTDSAPI.DEF

Author:

    Will Lees (wlees) 02-Feb-1998

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#define UNICODE 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock.h>
#include <winerror.h>
#include <rpc.h>            // RPC defines
#include <stdlib.h>         // atoi, itoa

#include <drs.h>            // wire function prototypes
#include <bind.h>           // BindState

#include <drserr.h>         // DRS error codes
#define DEFS_ONLY
#include <draatt.h>         // Dra option flags for replication
#undef DEFS_ONLY

#include "util.h"           // ntdsapi utility functions

#if DBG
#include <stdio.h>          // printf for debugging
#endif

/* External */

ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );

/* Static */

static LONG WinSockInitialized = FALSE;

/* Forward */ /* Generated by Emacs 19.34.1 on Wed Oct 07 16:18:49 1998 */

DWORD
InitializeWinsockIfNeeded(
    VOID
    );

VOID
TerminateWinsockIfNeeded(
    VOID
    );

DWORD
AllocConvertNarrow(
    IN LPCWSTR StringW,
    OUT LPSTR *pStringA
    );

DWORD
AllocConvertNarrowUTF8(
    IN LPCWSTR StringW,
    OUT LPSTR *pStringA
    );

static DWORD
allocConvertNarrowCodePage(
    IN DWORD CodePage,
    IN LPCWSTR StringW,
    OUT LPSTR *pStringA
    );

DWORD
AllocConvertWide(
    IN LPCSTR StringA,
    OUT LPWSTR *pStringW
    );

DWORD
AllocConvertWideBuffer(
    IN  DWORD   LengthA,
    IN  PCCH    BufferA,
    OUT PWCHAR  *OutBufferW
    );

DWORD
AllocBuildDsname(
    IN LPCWSTR StringDn,
    OUT DSNAME **ppName
    );

DWORD
ConvertScheduleToReplTimes(
    PSCHEDULE pSchedule,
    REPLTIMES *pReplTimes
    );

/* End Forward */


DWORD
InitializeWinsockIfNeeded(
    VOID
    )

/*++

Routine Description:

Initialize winsock dll if not initialized already.
Moved here from dllEntry because of dll ordering problems.

Arguments:

    VOID -

Return Value:

    DWORD -

--*/

{
    WSADATA wsaData;
    DWORD status;
    LONG oldValue;

#ifndef WIN95
    // Compare the synchonization variable against FALSE
    // If it is FALSE, set it to TRUE and return FALSE
    // If it is TRUE, return TRUE
    oldValue = InterlockedCompareExchange(
        &WinSockInitialized,       // Destination
        TRUE,                      // Exchange
        FALSE                      // Comperand
        );

    // If already initialized, no need to call startup
    if (oldValue == TRUE) {
        return ERROR_SUCCESS;
    }
#else
    if (WinSockInitialized == FALSE) {
        WinSockInitialized = TRUE;
    } else {
        return ERROR_SUCCESS;
    }
#endif

    // Initialize winsock
    // Look for Winsock 1.1 because that is the default on win95
    status = WSAStartup(MAKEWORD(1,1),&wsaData);
    if (status != 0) {
#ifndef WIN95
        DbgPrint( "ntdsapi: WSAStartup failed %d\n", status );
#else
        NULL;
#endif
        // Clear initialized flag on failure
#ifndef WIN95
        InterlockedExchange(
            &WinSockInitialized,   // Target
            FALSE                   // Value
            );
#else
        WinSockInitialized = FALSE;
#endif
    }

    return status;
} /* InitializeWinsockIfNeeded */


VOID
TerminateWinsockIfNeeded(
    VOID
    )

/*++

Routine Description:

Terminate winsock dll if initialized.
Moved here from dllEntry because of dll ordering problems.

Arguments:

    VOID -

Return Value:

    DWORD -

--*/

{
    WSADATA wsaData;
    DWORD status;
    LONG oldValue;

#ifndef WIN95
    // Compare the synchonization variable against TRUE
    // If it is TRUE, set it to FALSE and return TRUE
    // If it is FALSE, return FALSE
    oldValue = InterlockedCompareExchange(
        &WinSockInitialized,       // Destination
        FALSE,                     // Exchange
        TRUE                       // Comperand
        );

    // If not initialized, no need to clean up
    if (oldValue == FALSE) {
        return;
    }
#else
    if (WinSockInitialized == TRUE) {
        WinSockInitialized = FALSE;
    } else {
        return;
    }
#endif

    // Cleanup winsock
    WSACleanup();

} /* TerminateWinsockIfNeeded */


DWORD
AllocConvertNarrow(
    IN LPCWSTR StringW,
    OUT LPSTR *pStringA
    )

/*++

Routine Description:

Helper routine to convert a wide string to a newly allocated narrow one

Arguments:

    StringW -
    pStringA -

Return Value:

    DWORD -

--*/

{
    return allocConvertNarrowCodePage( CP_ACP, StringW, pStringA );
}


DWORD
AllocConvertNarrowUTF8(
    IN LPCWSTR StringW,
    OUT LPSTR *pStringA
    )

/*++

Routine Description:

Helper routine to convert a wide string to a newly allocated narrow one

Arguments:

    StringW -
    pStringA -

Return Value:

    DWORD -

--*/

{
    return allocConvertNarrowCodePage( CP_UTF8, StringW, pStringA );
}


static DWORD
allocConvertNarrowCodePage(
    IN DWORD CodePage,
    IN LPCWSTR StringW,
    OUT LPSTR *pStringA
    )

/*++

Routine Description:

Helper routine to convert a wide string to a newly allocated narrow one

Arguments:

    StringW -
    pStringA -

Return Value:

    DWORD -

--*/

{
    DWORD numberNarrowChars, numberConvertedChars, status;
    LPSTR stringA;

    if (pStringA == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (StringW == NULL) {
        *pStringA = NULL;
        return ERROR_SUCCESS;
    }

    // Get the needed length
    numberNarrowChars = WideCharToMultiByte(
        CodePage,
        0,
        StringW,              // input buffer
        -1,                   // null terminated
        NULL,                 // output buffer
        0,                    // output length
        NULL,                 // default char
        NULL                  // default used
        );

    if (numberNarrowChars == 0) {
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate the new buffer
    stringA = LocalAlloc( LPTR, (numberNarrowChars + 1) * sizeof( CHAR ) );
    if (stringA == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Do the conversion into the new buffer
    numberConvertedChars = WideCharToMultiByte(
        CodePage,
        0,
        StringW,         //input
        -1,
        stringA,         // output
        numberNarrowChars + 1,
        NULL,            // default char
        NULL             // default used
        );
    if (numberConvertedChars == 0) {
        LocalFree( stringA );
        return ERROR_INVALID_PARAMETER;
    }

    // return user parameter
    *pStringA = stringA;

    return ERROR_SUCCESS;
} /* allocConvertNarrow */


DWORD
AllocConvertWide(
    IN LPCSTR StringA,
    OUT LPWSTR *pStringW
    )

/*++

Routine Description:

Helper routine to convert a narrow string to a newly allocated wide one

Arguments:

    StringA -
    pStringW -

Return Value:

    DWORD -

--*/

{
    DWORD numberWideChars, numberConvertedChars, status;
    LPWSTR stringW;

    if (pStringW == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (StringA == NULL) {
        *pStringW = NULL;
        return ERROR_SUCCESS;
    }

    // Get the needed length
    numberWideChars = MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        StringA,
        -1,
        NULL,
        0);

    if (numberWideChars == 0) {
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate the new buffer
    stringW = LocalAlloc( LPTR, (numberWideChars + 1) * sizeof( WCHAR ) );
    if (stringW == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Do the conversion into the new buffer
    numberConvertedChars = MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        StringA,
        -1,
        stringW,
        numberWideChars + 1);
    if (numberConvertedChars == 0) {
        LocalFree( stringW );
        return ERROR_INVALID_PARAMETER;
    }

    // return user parameter
    *pStringW = stringW;

    return ERROR_SUCCESS;
} /* allocConvertWide */


DWORD
AllocConvertWideBuffer(
    IN  DWORD   LengthA,
    IN  PCCH    BufferA,
    OUT PWCHAR  *OutBufferW
    )

/*++

Routine Description:

    Converts narrow buffer to newly allocated wide one

Arguments:

    LengthA    - number of chars in BufferA
    BufferA    - Buffer of narrow chars
    OutBufferW - Address of buffer of wide chars

Return Value:

    Win32 Status

--*/
{
    DWORD   Status;
    DWORD   NumberWideChars;
    DWORD   ConvertedChars;
    PWCHAR  BufferW;

    //
    // no output buffer address; error
    //
    if (OutBufferW == NULL) {
        return ERROR_INVALID_PARAMETER;
    }
    *OutBufferW = NULL;

    //
    // No input buffer; return NULL
    //
    if (BufferA == NULL || LengthA == 0) {
        *OutBufferW = NULL;
        return ERROR_SUCCESS;
    }

    //
    // Get the needed length in chars
    //
    NumberWideChars = MultiByteToWideChar(CP_ACP,
                                          MB_PRECOMPOSED,
                                          BufferA,
                                          LengthA,
                                          NULL,
                                          0);

    if (NumberWideChars == 0) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Allocate the new buffer
    //
    BufferW = LocalAlloc(LPTR,
                         NumberWideChars * sizeof(WCHAR));
    if (BufferW == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Do the conversion into the new buffer
    //
    ConvertedChars = MultiByteToWideChar(CP_ACP,
                                         MB_PRECOMPOSED,
                                         BufferA,
                                         LengthA,
                                         BufferW,
                                         NumberWideChars);
    if (ConvertedChars == 0) {
        LocalFree(BufferW);
        return ERROR_INVALID_PARAMETER;
    }

    // return user parameter
    *OutBufferW = BufferW;

    return ERROR_SUCCESS;
} /* AllocConvertWideBuffer */


DWORD
AllocBuildDsname(
    IN LPCWSTR StringDn,
    OUT DSNAME **ppName
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD length, dsnameBytes;
    DSNAME *pName;

    if (StringDn == NULL) {
        *ppName = NULL;
        return ERROR_SUCCESS;
    }

    length = wcslen( StringDn );
    dsnameBytes = DSNameSizeFromLen( length );

    pName = (DSNAME *) LocalAlloc( LPTR, dsnameBytes );
    if (pName == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    pName->NameLen = length;
    pName->structLen = dsnameBytes;
    wcscpy( pName->StringName, StringDn );

    *ppName = pName;

    return ERROR_SUCCESS;
}


DWORD
ConvertScheduleToReplTimes(
    PSCHEDULE pSchedule,
    REPLTIMES *pReplTimes
    )

/*++

Routine Description:

Convert a public SCHEDULE into a REPLTIMES structure.

The public schedule must be of INTERVAL type, and only contain one header.

The difference between the data in a public SCHEDULE and the data in a
REPLTIMES is that the former only uses 1 byte for each hour, with the high
nybble unused, while the latter encodes two hours in each byte.

Arguments:

    pSchedule -
    pReplTimes -

Return Value:

    DWORD -

--*/

{
    PUCHAR pData = (PUCHAR) (pSchedule + 1);  // point just after structure
    DWORD hour;

    if ( (pSchedule == NULL) ||
         (pReplTimes == NULL) ||
         (pSchedule->Size != sizeof( SCHEDULE ) + SCHEDULE_DATA_ENTRIES) ||
         (pSchedule->NumberOfSchedules != 1) ||
         (pSchedule->Schedules[0].Type != SCHEDULE_INTERVAL) ||
         (pSchedule->Schedules[0].Offset != sizeof( SCHEDULE ) ) ) {
        return ERROR_INVALID_PARAMETER;
    }

    for( hour = 0; hour < SCHEDULE_DATA_ENTRIES; hour += 2 ) {
        pReplTimes->rgTimes[hour/2] =
            (UCHAR) (((pData[hour + 1] & 0xf) << 4) | (pData[hour] & 0xf));
    }

    return ERROR_SUCCESS;
} /* ConvertScheduleToReplTimes */

/* end util.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsapi\spn.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    spn.c

Abstract:

    Implementation of SPN API and helper functions.

    See \nt\public\specs\nt5\ds\spnapi.doc, by Paulle

    See comments in \nt\public\sdk\inc\ntdsapi.h

    Only one of the Spn Api's goes over the wire: DsWriteAccountSpn

    The Spn functions are spread out over a number of directories:

nt\public\sdk\inc\ntdsapi.h - api header file

ds\src\test\spn\testspn.c - unit test
ds\src\ntdsapi\spn.c - client side spn functions
ds\src\ntdsapi\drs_c.c - client stub

ds\src\dsamain\drsserv\drs_s.c - server stub
ds\src\dsamain\dra\ntdsapi.c - server rpc entry points for ntdsapi functions
ds\src\dsamain\dra\spnop.c - ntdsa core functions to do the work

    The APIs are:

    DsMakeSpn{A,W}
    DsGetSpn{A,W}
    DsFreeSpnArray{A,W}
    DSCrackSpn{A,W}
    DSWriteAccountSpn{A,W}

    DsClientMakeSpnForTargetServer{A,W}
    DsServerRegisterSpn{A,W}

Author:

    Wlees     19-Jan-1998

    The guts of DsServerRegisterSpn was written by RichardW

Environment:

    User Mode - Win32

Revision History:

    Aug 11, 1998  wlees  Added DsClientMakeSpnForTargetServer and
                         DsServerRegisterSpn

--*/

#define UNICODE 1

#define _NTDSAPI_           // see conditionals in ntdsapi.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <winsock.h>        // Use V1.1, since that is default on Win95
#include <rpc.h>            // RPC defines

#define SECURITY_WIN32      // Who should set this, and to what?
#include <security.h>       // GetComputerNameEx
#include <sspi.h>
#include <secext.h>
#include <lm.h>             // Netp functions

#include <stdlib.h>         // atoi, itoa

#include <dsgetdc.h>        // DsGetDcName()
#include <ntdsapi.h>        // CrackNam apis
#include <drs_w.h>          // wire function prototypes
#include <bind.h>           // BindState
#include <msrpc.h>          // DS RPC definitions
#include <dsutil.h>         // MAP_SECURITY_PACKAGE_ERROR
#include <dststlog.h>       // DSLOG

#include "util.h"        // ntdsapi private routines

#include <debug.h>          // Assert()
#include <stdio.h>          // printf for debugging

// Max size for a computer dist name

#define MAX_COMPUTER_DN 1024

// Max size for an IP address

#define MAX_IP_STRING 15

// Static

// Cannonical DNS names are recognized by their first component being a well-
// known constant.
// See Paulle for the RFC with the complete list
static LPWSTR WellKnownDnsPrefixes[] = {
    L"www.",
    L"ftp.",
    L"ldap."
};

#define NUMBER_ELEMENTS( A ) ( sizeof( A ) / sizeof( A[0] ) )

// Forward

static DWORD
allocBuildSpn(
    IN LPCWSTR ServiceClass,
    IN LPCWSTR InstanceName,
    IN USHORT InstancePort,
    IN LPCWSTR ServiceName,
    OUT LPWSTR *pSpn
    );

static BOOLEAN
isCanonicalDnsName(
    IN LPCWSTR DnsName
    );

DWORD
extractString(
    IN LPCWSTR Start,
    IN DWORD Length,
    IN DWORD *pSize,
    OUT LPWSTR Output
    );


NTDSAPI
DWORD
WINAPI
DsClientMakeSpnForTargetServerA(
    IN LPCSTR ServiceClass,
    IN LPCSTR ServiceName,
    IN OUT DWORD *pcSpnLength,
    OUT LPSTR pszSpn
    )

/*++

Routine Description:

Convert arguments to wide and call DsClientMakeSpnForTargetServerW

Arguments:

    ServiceClass -
    ServerName -
    pcSpnLength -
    pszSpn -

Return Value:

    WINAPI -

--*/

{
    DWORD status, number, principalNameLength;
    LPWSTR serviceClassW = NULL;
    LPWSTR serviceNameW = NULL;
    LPWSTR principalNameW = NULL;

    if ( (ServiceClass == NULL) ||
         (ServiceName == NULL) ||
         (pcSpnLength == NULL) ||
         ( (pszSpn == NULL) && (*pcSpnLength != 0) ) ) {
        return ERROR_INVALID_PARAMETER;
    }

    status = AllocConvertWide( ServiceClass, &serviceClassW );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    status = AllocConvertWide( ServiceName, &serviceNameW );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    principalNameLength = *pcSpnLength;  // in characters
    if (principalNameLength) {
        principalNameW = LocalAlloc( LPTR,
                                     principalNameLength * sizeof( WCHAR ) );
        if (principalNameW == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    status = DsClientMakeSpnForTargetServerW(
        serviceClassW,
        serviceNameW,
        &principalNameLength,
        principalNameW );
    if (status != ERROR_SUCCESS) {
        if (status == ERROR_BUFFER_OVERFLOW) {
            // return needed length
            *pcSpnLength = principalNameLength;
        }
        goto cleanup;
    }

    // Convert back to multi-byte
    number = WideCharToMultiByte(
        CP_ACP,
        0,                          // flags
        principalNameW,
        principalNameLength,        // length in characters
        (LPSTR) pszSpn,             // Caller's buffer
        *pcSpnLength,            // Caller's length
        NULL,                       // default char
        NULL                     // default used
        );
    if (number == 0) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // Return out parameter
    *pcSpnLength = number;

    status = ERROR_SUCCESS;

cleanup:

    if (serviceClassW != NULL) {
        LocalFree( serviceClassW );
    }

    if (serviceNameW != NULL) {
        LocalFree( serviceNameW );
    }

    if (principalNameW != NULL) {
        LocalFree( principalNameW );
    }

    return status;
} /* DsClientMakeSpnForTargetServerA */


NTDSAPI
DWORD
WINAPI
DsClientMakeSpnForTargetServerW(
    IN LPCWSTR ServiceClass,
    IN LPCWSTR ServiceName,
    IN OUT DWORD *pcSpnLength,
    OUT LPWSTR pszSpn
    )

/*++

Routine Description:

Constructs a Service Principal Name suitable to identify the desired server.
The service class and part of a dns hostname must be supplied.

This routine is a simplified wrapper to DsMakeSpn.
The ServiceName is made canonical by resolving through DNS.
Guid-based dns names are not supported.

The simplified SPN constructed looks like this:

ServiceClass / ServiceName / ServiceName

The instance name portion (2nd position) is always defaulted.  The port and
referrer fields are not used.

Arguments:

    ServiceClass - Class of service, defined by the service, can be any
        string unique to the service

    ServiceName - dns hostname, fully qualified or not
       Stringized IP address is also resolved if necessary

    pcSpnLength - IN, maximum length of buffer, in chars
                  OUT, space utilized, in chars, including terminator

    pszSpn - Buffer, atleast of length *pcSpnLength

Return Value:

    WINAPI -

--*/

{
    DWORD status, length;
    LPSTR serviceNameA = NULL;
    LPWSTR serviceNameW = NULL;
    LPWSTR domainPart;
    struct hostent *pHostEntry = NULL;

    status = InitializeWinsockIfNeeded();
    if (status != ERROR_SUCCESS) {
        return status;
    }

    if ( (NULL == ServiceClass) ||
         (NULL == ServiceName) ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Treat netbios names like dns names, remove \\ prefix
    if (*ServiceName == L'\\') {
        ServiceName++;
        if (*ServiceName == L'\\') {
            ServiceName++;
        }
    }

    // Handle IP addresses too. Reverse to DNS.
    length = wcslen( ServiceName );
    if ( (length <= MAX_IP_STRING) && (iswdigit( *ServiceName )) ) {
        LONG ipAddress;

        status = AllocConvertNarrow( ServiceName, &serviceNameA );
        if (status) {
            goto cleanup;
        }

        ipAddress = inet_addr( serviceNameA );
        if (ipAddress != INADDR_NONE) {
            pHostEntry = gethostbyaddr( (char *)&ipAddress,sizeof( LONG ),AF_INET);
            if (pHostEntry) {
                status = AllocConvertWide( pHostEntry->h_name, &serviceNameW );
                if (status) {
                    goto cleanup;
                }
                ServiceName = serviceNameW;
            } else {
                // IP syntax was good, but could not be reverse translated
                status = ERROR_INCORRECT_ADDRESS;
                goto cleanup;
            }
        }
    }

    // Check for fully qualified DNS name.  If not, lookup in DNS
    domainPart = wcschr( ServiceName, L'.' );
    if (NULL == domainPart) {

        if (serviceNameA) {
            LocalFree( serviceNameA );
        }
        status = AllocConvertNarrow( ServiceName, &serviceNameA );
        if (status) {
            goto cleanup;
        }

        pHostEntry = gethostbyname( serviceNameA );
        if (pHostEntry) {
            if (serviceNameW) {
                LocalFree( serviceNameW );
            }

            status = AllocConvertWide( pHostEntry->h_name, &serviceNameW );
            if (status) {
                goto cleanup;
            }
            ServiceName = serviceNameW;

            domainPart = wcschr( ServiceName, L'.' );
        }
    }

    // Sanity check name
    if (NULL == domainPart) {
        status = ERROR_INVALID_DOMAINNAME;
        goto cleanup;
    }

    // Guid based names are not supported here
    // TODO: check for them

    status = DsMakeSpnW(
        ServiceClass,
        ServiceName,
        NULL,
        0,
        NULL,
        pcSpnLength,
        pszSpn );

cleanup:

    if (serviceNameW) {
        LocalFree( serviceNameW );
    }
    if (serviceNameA) {
        LocalFree( serviceNameA );
    }

    return status;

} /* DsMakeSpnForTargetServerW */


NTDSAPI
DWORD
WINAPI
DsServerRegisterSpnA(
    DS_SPN_WRITE_OP Operation,
    IN LPCSTR ServiceClass,
    IN OPTIONAL LPCSTR UserObjectDN
    )

/*++

Routine Description:

   This function converts parameters to wide, and calls DsServerRegisterSpnW

Arguments:

    ServiceClass - unique string identifying service
    UserObjectDN - Optional, DN of user-class object to write SPN

Return Value:

    WINAPI -

--*/

{
    DWORD status;
    LPWSTR serviceClassW = NULL;
    LPWSTR userObjectDNW = NULL;

    if (ServiceClass == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    status = AllocConvertWide( ServiceClass, &serviceClassW );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // May be NULL
    status = AllocConvertWide( UserObjectDN, &userObjectDNW );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    status = DsServerRegisterSpnW(
        Operation,
        serviceClassW,
        userObjectDNW );

cleanup:

    if (serviceClassW != NULL) {
        LocalFree( serviceClassW );
    }

    if (userObjectDNW != NULL) {
        LocalFree( userObjectDNW );
    }

    return status;
} /* DsServerRegisterSpnA */


NTDSAPI
DWORD
WINAPI
DsServerRegisterSpnW(
    DS_SPN_WRITE_OP Operation,
    IN LPCWSTR ServiceClass,
    IN OPTIONAL LPCWSTR UserObjectDN
    )

/*++

Routine Description:

Register Service Principal Names for a server application.

This routine does the following:
1. Enumerates a list of server SPNs using DsGetSpn and the provided class
2. Determines the domain of the current user context
3. Determines the DN of the current user context if not supplied
4. Locates a domain controller
5. Binds to the domain controller
6. Uses DsWriteAccountSpn to write the SPNs on the named object DN
7. Unbinds

Construct server SPNs for this service, and write them to the right object.

If the userObjectDn is specified, the SPN is written to that object.

Otherwise the Dn is defaulted, to the user object, then computer.

Now, bind to the DS, and register the name on the object for the
user this service is running as.  So, if we're running as local
system, we'll register it on the computer object itself.  If we're
running as a domain user, we'll add the SPN to the user's object.

Arguments:

    Operation - What should be done with the values: add, replace or delete
    ServiceClass - Unique string identifying service
    UserObjectDN - Optional, dn of object to write SPN to

Return Value:

    WINAPI -

--*/

{
    DWORD Status ;
    LPWSTR * SpnDns = NULL, * SpnNetBios = NULL ;
    DWORD SpnCountDns = 0, SpnCountNetBios = 0 ;
    DWORD i ;
    WCHAR SamName[ 48 ];
    DWORD NameSize ;
    PWSTR DN = NULL ;
    PDOMAIN_CONTROLLER_INFO DcInfo ;
    HANDLE hDs ;

    if (ServiceClass == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    Status = DsGetSpnW(
                    DS_SPN_DNS_HOST,
                    ServiceClass,
                    NULL,
                    0,
                    0,
                    NULL,
                    NULL,
                    &SpnCountDns,
                    &SpnDns );

    if ( Status != 0 )
    {
        return Status ;
    }

    Status = DsGetSpnW(
                    DS_SPN_NB_HOST,
                    ServiceClass,
                    NULL,
                    0,
                    0,
                    NULL,
                    NULL,
                    &SpnCountNetBios,
                    &SpnNetBios );

    if ( Status != 0 )
    {
        goto Register_Cleanup ;
    }

    // Determine the domain name

#if !WIN95 && !WINNT4
    NameSize = sizeof( SamName ) / sizeof( WCHAR );

    if ( GetUserNameEx( NameSamCompatible, SamName, &NameSize ) )
    {
        PWSTR Whack ;

        Whack = wcschr( SamName, L'\\' );
        if ( Whack )
        {
            *Whack = L'\0';
        }

    }
    else
    {
        Status = GetLastError() ;

        goto Register_Cleanup ;
    }
#else
    *SamName = L'\0';
#endif

    //
    // Get my full DN (we'll need that next):
    //

    if (NULL == UserObjectDN) {

#if !WIN95 && !WINNT4
        NameSize = 128 ;

        DN = LocalAlloc( 0, NameSize * sizeof( WCHAR ) );

        if ( !DN )
        {
            Status = GetLastError();

            goto Register_Cleanup ;
        }

        if ( !GetUserNameEx( NameFullyQualifiedDN, DN, &NameSize ) )
        {
            if ( GetLastError() == ERROR_MORE_DATA )
            {
                LocalFree( DN );

                DN = LocalAlloc( 0, NameSize * sizeof( WCHAR ) );

                if ( !DN )
                {
                    Status = GetLastError();

                    goto Register_Cleanup ;
                }

                if ( !GetUserNameEx( NameFullyQualifiedDN, DN, &NameSize ) )
                {
                    Status = GetLastError();

                    goto Register_Cleanup ;
                }
            }
            else
            {
                Status = GetLastError();

                goto Register_Cleanup;
            }

        }

        UserObjectDN = DN;
#else
        Status = ERROR_INVALID_PARAMETER;
        goto Register_Cleanup;
#endif
    }


    //
    // Bind to that DS:
    //

    Status = DsGetDcName(
                    NULL,
                    SamName,
                    NULL,
                    NULL,
                    DS_IS_FLAT_NAME |
                        DS_RETURN_DNS_NAME |
                        DS_DIRECTORY_SERVICE_REQUIRED,
                    &DcInfo );

    if ( Status != 0 )
    {
        goto Register_Cleanup ;
    }

    Status = DsBind( DcInfo->DomainControllerName,
                     NULL,
                     &hDs );

    NetApiBufferFree( DcInfo );

    if ( Status != 0 )
    {
        goto Register_Cleanup ;
    }

    //
    // Got a binding, ready to go now:
    //

    // Register Dns based spns
    Status = DsWriteAccountSpn(
                        hDs,
                        Operation,
                        UserObjectDN,
                        SpnCountDns,
                        SpnDns );

    if (Status == ERROR_SUCCESS) {

        // Register Netbios based spns
        Status = DsWriteAccountSpn(
            hDs,
            Operation,
            UserObjectDN,
            SpnCountNetBios,
            SpnNetBios );
    }

    DsUnBind( &hDs );


Register_Cleanup:

    DsFreeSpnArray( SpnCountDns, SpnDns );
    DsFreeSpnArray( SpnCountNetBios, SpnNetBios );

    if ( DN )
    {
        LocalFree( DN );
    }

    return Status ;
} /* DsServerRegisterSpnW */


NTDSAPI
DWORD
WINAPI
DsMakeSpnA(
    IN LPCSTR ServiceClass,
    IN LPCSTR ServiceName,
    IN LPCSTR InstanceName OPTIONAL,
    IN USHORT InstancePort,
    IN LPCSTR Referrer OPTIONAL,
    IN OUT DWORD *pcSpnLength,
    OUT LPSTR pszSpn
)

/*++

Routine Description:

    Convert arguments to wide and call DsMakeSpnW

    See DsMakeSpnW

Arguments:

    ServiceClass -
    ServiceName -
    InstanceName -
    InstancePort -
    Referrer -
    pcSpnLength -
    pszSPN -

pcSpnLength must be non-Null.  Needed length returned here.
if *pcSpnLength != 0, pszSpn must be non-NUll
pszSpn may be null. If non-null, some or all of name returned.

Return Value:

    WINAPI -

--*/

{
    DWORD status, number, principalNameLength;
    LPWSTR serviceClassW = NULL;
    LPWSTR serviceNameW = NULL;
    LPWSTR instanceNameW = NULL;
    LPWSTR referrerW = NULL;
    LPWSTR principalNameW = NULL;

    if ( (ServiceClass == NULL) ||
         (ServiceName == NULL) ||
         (pcSpnLength == NULL) ||
         ( (pszSpn == NULL) && (*pcSpnLength != 0) ) ) {
        return ERROR_INVALID_PARAMETER;
    }

    status = AllocConvertWide( ServiceClass, &serviceClassW );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    status = AllocConvertWide( ServiceName, &serviceNameW );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // May be NULL
    status = AllocConvertWide( InstanceName, &instanceNameW );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // May be NULL
    status = AllocConvertWide( Referrer, &referrerW );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    principalNameLength = *pcSpnLength;  // in characters
    if (principalNameLength) {
        principalNameW = LocalAlloc( LPTR,
                                     principalNameLength * sizeof( WCHAR ) );
        if (principalNameW == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    status = DsMakeSpnW( serviceClassW,
                         serviceNameW,
                         instanceNameW,
                         InstancePort,
                         referrerW,
                         &principalNameLength,
                         principalNameW );
    if (status != ERROR_SUCCESS) {
        if (status == ERROR_BUFFER_OVERFLOW) {
            // return needed length
            *pcSpnLength = principalNameLength;
        }
        goto cleanup;
    }

    // If we get this far, pszSpn != NULL.
    // If (pszSpn==NULL)&&(*pcSpnLength!=0) we exit ERROR_INVALID_PARAMETER.
    // If (pszSpn==NULL)&&(*pcSpnLength==0) we goto cleanup with ERROR_BUFFER_OVERFLOW.
    Assert( pszSpn != NULL );

    // The checks at the top require that if pszSpn == NULL, *pcSpnLength == 0.
    // The description of WideCharToMultiByte says that if the sixth argument
    // is zero, the fifth argument is ignored.  Thus it is not necessary to screen
    // out pszSpn == NULL before calling this function.

    // Convert back to multi-byte
    number = WideCharToMultiByte(
        CP_ACP,
        0,                          // flags
        principalNameW,
        principalNameLength,        // length in characters
        (LPSTR) pszSpn,             // Caller's buffer
        *pcSpnLength,            // Caller's length
        NULL,                       // default char
        NULL                     // default used
        );
    if (number == 0) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // Return out parameter
    *pcSpnLength = number;

    status = ERROR_SUCCESS;

cleanup:

    if (serviceClassW != NULL) {
        LocalFree( serviceClassW );
    }

    if (serviceNameW != NULL) {
        LocalFree( serviceNameW );
    }

    if (instanceNameW != NULL) {
        LocalFree( instanceNameW );
    }

    if (referrerW != NULL) {
        LocalFree( referrerW );
    }

    if (principalNameW != NULL) {
        LocalFree( principalNameW );
    }

    return status;
} /* DsMakeSpnA */


NTDSAPI
DWORD
WINAPI
DsMakeSpnW(
    IN LPCWSTR ServiceClass,
    IN LPCWSTR ServiceName,
    IN LPCWSTR InstanceName OPTIONAL,
    IN USHORT InstancePort,
    IN LPCWSTR Referrer OPTIONAL,
    IN OUT DWORD *pcSpnLength,
    OUT LPWSTR pszSpn
)

/*++

Routine Description:

    Client call to create SPN for a service to which it wants to mutually
    authenticate

    Construct a SPN of the form

        class/instance:port/service

    If instance is NULL, the service name is used
    The port is only appended if non-zero.
    If service is an IP address, use referrer address

    // NOTE - not enforced.:
    // If the service name is a DNS host name, or cannonical DNS service name,
       then instance must
    // be null.
    // If service name is Netbios machine name, instance must be NULL
    // If service name is a DN, then client must supply the instance name
    // If service name is a Netbios domain name, then the client must supply
       the instance name
    // Validate service class

    Note: pszSpn may be null, or pcSpnLength may be 0, to request the final
    buffer size in advance.
    pcSpnLength must be non-Null.  Needed length returned here.
    if *pcSpnLength != 0, pszSpn must be non-NUll
    pszSpn may be null. If non-null, some or all of name returned.

    If buffer is not large enough, ERROR_BUFFER_OVERFLOW is returned and the
    needed length is given in pcSpnLength (including the NULL terminator).

Arguments:

    IN LPCTSTR ServiceClass,
        // e.g. "http", "ftp", "ldap", GUID
    IN LPCTSTR ServiceName,
        // DNS or DN or IP;
        // assumes we can compute domain from service name
    IN LPCTSTR InstanceName OPTIONAL,
        // DNS name or IP address of host for instance of service
    IN USHORT InstancePort,
        // port number for instance (0 if default)
    IN LPCTSTR Referrer OPTIONAL,
        // DNS name of host that gave this referral
    IN OUT PULONG pcSpnLength,
        // in -- max length IN CHARS of principal name;
        // out -- actual
    OUT LPTSTR pszSPN
        // server principal name

Return Value:

    DWORD -

--*/

{
    DWORD status;
    LPCWSTR currentServiceName, currentInstanceName;
    WCHAR pszPort[8];
    LPWSTR Spn = NULL;
    USHORT ipA[4];

    if ( (ServiceClass == NULL) ||
         (ServiceName == NULL) ||
         (wcslen( ServiceName ) == 0) ||
         (wcslen( ServiceClass ) == 0) ||
         (wcschr( ServiceName, L'/' ) != NULL) ||
         (wcschr( ServiceClass, L'/' ) != NULL) ||
         (pcSpnLength == NULL) ||
         ( (pszSpn == NULL) && (*pcSpnLength != 0) ) ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Part 1 - Use Service Class as is

    // Part 2 - Instance name, use service name if null

    if (InstanceName != NULL) {
        if ( (wcslen( InstanceName ) == 0) ||
             (wcschr( InstanceName, L'/' ) != NULL) ) {
            return ERROR_INVALID_PARAMETER;
        }
        currentInstanceName = InstanceName;
    } else {
        currentInstanceName = ServiceName;
    }

    // Part 3 - Service name, if ip address, use referrer
    //
    // Use length to disqualify long names, since a guid-based dns name
    // looks like an IP address in the first 16 characters.
    // This API supports only standard, most common fully qualified
    // ip addresses as ServiceName: "%hu.%hu.%hu.%hu"
    //
    // Other forms aren't supported (such as not FQ, hex or octal
    // representations).
    // No range specifications are performed (i.e. 192929.3.2.1 is
    // isn't rejected).
    //
    // ToDo: IPv6 support.

    if (wcslen( ServiceName ) <= MAX_IP_STRING &&
        4 == swscanf(ServiceName,L"%hu.%hu.%hu.%hu",
                          &ipA[0], &ipA[1], &ipA[2], &ipA[3])) {
        if ( (Referrer == NULL) ||
             (wcslen( Referrer ) == 0) ||
             (wcschr( Referrer, L'/' ) != NULL) ) {
            return ERROR_INVALID_PARAMETER;
        }
        // good ip address + referrer exists.
        currentServiceName = Referrer;
    } else {
        // not an ip address.
        currentServiceName = ServiceName;
    }

    // If Service Name == Instance Name, drop the service
    // This is for host-based SPNs, which look like <type>\dnshostname.
    // Because we can't tell the user's request for a host-based SPN
    // from a service-based SPN, we may construct a "a/b" form spn for
    // a non-host based service.

    if (_wcsicmp( currentInstanceName, currentServiceName ) == 0) {
        currentServiceName = NULL;
    }

    // Construct the spn in temporary memory

    status = allocBuildSpn( ServiceClass,
                            currentInstanceName,
                            InstancePort,
                            currentServiceName,
                            &Spn );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // Copy out and truncate, as necessary
    if (*pcSpnLength >= wcslen( Spn ) + 1) {
        if (pszSpn) {
            wcscpy( pszSpn, Spn );
        }
    } else {
        status = ERROR_BUFFER_OVERFLOW;
    }
    *pcSpnLength = wcslen( Spn ) + 1;

cleanup:

    if (Spn) {
        LocalFree( Spn );
    }

    return status;

} /* DsMakeSpnW */


NTDSAPI
DWORD
WINAPI
DsGetSpnA(
    IN DS_SPN_NAME_TYPE ServiceType,
    IN LPCSTR ServiceClass,
    IN LPCSTR ServiceName,
    IN USHORT InstancePort,
    IN USHORT cInstanceNames,
    IN LPCSTR *pInstanceNames,
    IN const USHORT *pInstancePorts,
    OUT DWORD *pcSpn,
    OUT LPSTR **prpszSpn
    )

/*++

Routine Description:

    Convert arguments to wide and call DsGetSpnW

Arguments:

    eType -
    ServiceClass -
    ServiceName -
    InstancePort -
    cInstanceNames -
    pInstanceNames -
    pInstancePorts -
    pcSpn -
    prpszSPN -

Return Value:

    WINAPI -

--*/

{
    DWORD status, i, cSpn = 0;
    LPWSTR serviceClassW = NULL;
    LPWSTR serviceNameW = NULL;
    LPWSTR *pInstanceNamesW = NULL;
    LPWSTR *pSpn = NULL;
    LPSTR *pSpnA = NULL;

    if ( (!pcSpn) || (!prpszSpn) ) {
        status = ERROR_INVALID_PARAMETER;
        return status;
    }

    //
    // Convert in
    //

    status = AllocConvertWide( ServiceClass, &serviceClassW );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    if (ServiceName) {
        status = AllocConvertWide( ServiceName, &serviceNameW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    if (cInstanceNames) {
        if (pInstanceNames == NULL) {                  // Must be supplied
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        pInstanceNamesW = LocalAlloc( LPTR, cInstanceNames * sizeof( LPWSTR ) );
        if (!pInstanceNamesW) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        for( i = 0; i < cInstanceNames; i++ ) {
            status = AllocConvertWide( pInstanceNames[i], &(pInstanceNamesW[i]) );
            if (status != ERROR_SUCCESS) {
                goto cleanup;
            }
        }
    }

    //
    // Call the wide version of the routine
    //

    status = DsGetSpnW(
        ServiceType,
        serviceClassW,
        serviceNameW,
        InstancePort,
        cInstanceNames,
        pInstanceNamesW,
        pInstancePorts,
        &cSpn,
        &pSpn
        );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Convert out
    //

    if (cSpn) {
        pSpnA = LocalAlloc( LPTR, cSpn * sizeof( LPSTR ) );
        if (!pSpnA) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        for( i = 0; i < cSpn; i++ ) {
            status = AllocConvertNarrow( pSpn[i], &(pSpnA[i]) );
            if (status != ERROR_SUCCESS) {
                goto cleanup;
            }
        }
    }

    *pcSpn = cSpn;
    *prpszSpn = pSpnA;
    pSpnA = NULL; // don't cleanup

    status = ERROR_SUCCESS;
cleanup:
    if (serviceClassW) {
        LocalFree( serviceClassW );
    }
    if (serviceNameW) {
        LocalFree( serviceNameW );
    }
    if (pInstanceNamesW) {
        for( i = 0; i < cInstanceNames; i++ ) {
            LocalFree( pInstanceNamesW[i] );
        }
        LocalFree( pInstanceNamesW );
    }
    if (pSpn != NULL) {
        DsFreeSpnArrayW( cSpn, pSpn );
    }
    if (pSpnA != NULL) {
        // rely on ability to clean up partially allocated spn array
        DsFreeSpnArrayA( cSpn, pSpnA );
    }

    return status;
} /* DsGetSpnA */


NTDSAPI
DWORD
WINAPI
DsGetSpnW(
    IN DS_SPN_NAME_TYPE ServiceType,
    IN LPCWSTR ServiceClass,
    IN LPCWSTR ServiceName,
    IN USHORT InstancePort,
    IN USHORT cInstanceNames,
    IN LPCWSTR *pInstanceNames,
    IN const USHORT *pInstancePorts,
    OUT DWORD *pcSpn,
    OUT LPWSTR **prpszSpn
    )

/*++

Routine Description:

    Construct an array of server SPNs.

    An Spn consists of the following:
           class/instance:port/servicename
    The instance and service name are constructed according to various substitution and
    default rules too numerous to list here.  See spnapi.doc

    If cInstances is non-zero, use those instance supplied.
    Otherwise, use a defaulted instance name, if possible.
    Othewise, use the hostname

    Feb 17, 1999 - DNS hostname aliases are no longer registered

Arguments:

    eType -
    ServiceClass -
    ServiceName -
    InstancePort -
    cInstanceNames -
    pInstanceNames -
    pInstancePorts -
    pcSpn -
    prpszSPN -

Return Value:

    WINAPI -

--*/

{
    DWORD status, i, cSpn = 0, length;
    LPCWSTR currentServiceName;
    LPWSTR *pSpnList = NULL, primaryDnsHostname = NULL;
    WCHAR computerName[MAX_COMPUTERNAME_LENGTH+1];
    struct hostent *he;
    PDS_NAME_RESULTW pResult = NULL;
    LPWSTR currentInstanceName, aliasW;
    LPWSTR computerDn = NULL;
    WCHAR dummy;

    status = InitializeWinsockIfNeeded();
    if (status != ERROR_SUCCESS) {
        return status;
    }

    if ( (ServiceClass == NULL) ||
         (wcslen(ServiceClass) == 0) ||
         (wcschr(ServiceClass, L'/') != NULL) ||
         ( (ServiceName != NULL) &&
           ( (wcslen(ServiceName) == 0) ||
             (wcschr( ServiceName, L'/' ) != NULL) ) ) ||
         (!pcSpn) ||
         (!prpszSpn)
        ) {
        return ERROR_INVALID_PARAMETER;
    }

#if WIN95 || WINNT4
    // Get Dns hostname
    he = gethostbyname( "" );
    if (he == NULL) {
        status = WSAGetLastError();
        return status;
    }

    // Convert to unicode
    status = AllocConvertWide( he->h_name, &primaryDnsHostname );
    if (status != ERROR_SUCCESS) {
        return status;
    }
#else
    // Get the required length for the computer name ex
    length = 1;
    GetComputerNameExW( ComputerNameDnsFullyQualified, &dummy, &length );
    // Allocate it
    primaryDnsHostname = (LPWSTR) LocalAlloc( LPTR,
                                              (length+1) * sizeof( WCHAR ) );
    if (primaryDnsHostname == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    if (!GetComputerNameExW( ComputerNameDnsFullyQualified,
                             primaryDnsHostname, &length )) {
        status = GetLastError();
        goto cleanup;
    }
#endif

    // Get Netbios hostname

    length = MAX_COMPUTERNAME_LENGTH + 1;
    if (!GetComputerName( computerName, &length )) {
        status = GetLastError();
        goto cleanup;
    }

    // Calculate the service name for all cases

    switch (ServiceType) {
    case DS_SPN_DNS_HOST:
        if (ServiceName != NULL) {                   // Should NOT be supplied
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        // Service name will follow instance name, which is primaryDnsHostname
        currentServiceName = NULL; // drop service name component
        break;
    case DS_SPN_DN_HOST:
        if (ServiceName != NULL) {                   // Should NOT be supplied
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
#if 0
// This code doesn't work on WIN95
        computerDn = (LPWSTR) LocalAlloc( LPTR,
                                          MAX_COMPUTER_DN * sizeof( WCHAR ) );
        if (computerDn == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        length = MAX_COMPUTER_DN;
        // This may fail on a non-DC
        if (!GetComputerObjectName( NameFullyQualifiedDN, computerDn, &length )) {
            status = GetLastError();
            goto cleanup;
        }
        currentServiceName = computerDn;
#endif

        currentServiceName = NULL; // drop service name component
        break;
    case DS_SPN_NB_HOST:
        if (ServiceName != NULL) {                // Should NOT be supplied
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        // Service name will follow instance name, which is computerName
        currentServiceName = NULL; // drop service name component
        break;
    case DS_SPN_DOMAIN:
        if (ServiceName == NULL) {                   // Must be supplied
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }

        // If name is DN, convert to DNS
        if (wcschr( ServiceName, L'=' )) {
            LPWSTR slash;
            status = DsCrackNamesW(
                (HANDLE) (-1),
                DS_NAME_FLAG_SYNTACTICAL_ONLY,
                DS_FQDN_1779_NAME,
                DS_CANONICAL_NAME,
                1,
                &ServiceName,
                &pResult);
            if (status != ERROR_SUCCESS) {
                goto cleanup;
            }

            if ( (pResult == NULL) ||
                 (pResult->rItems == NULL) ||
                 (pResult->rItems[0].status != DS_NAME_NO_ERROR ) ) {
                status = ERROR_DS_BAD_NAME_SYNTAX;
                goto cleanup;
            }
            currentServiceName = pResult->rItems[0].pName;
            // Replace trailing / with \0
            slash = wcschr( currentServiceName, L'/' );
            if (slash) {
                *slash = L'\0';
            }
        } else {
            currentServiceName = ServiceName;
        }
        break;
    case DS_SPN_NB_DOMAIN:
        if (ServiceName == NULL) {                    // Must be supplied
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        currentServiceName = ServiceName;
        break;
    case DS_SPN_SERVICE:
        if (ServiceName == NULL) {                   // Must be supplied
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        currentServiceName = ServiceName;
        break;
    default:
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // Calculate number of SPNs
    //

    if (cInstanceNames) {
        // Must be supplied
        if (pInstanceNames == NULL)
        {
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        // Check supplied strings for validity
        for( i = 0; i < cInstanceNames; i++ ) {
            if ( (pInstanceNames[i] == NULL) ||
                 (wcslen( pInstanceNames[i] ) == 0) ||
                 (wcschr( pInstanceNames[i], L'/' ) != NULL) ) {
                status = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
        }
        cSpn = cInstanceNames;
    } else if ( (ServiceType == DS_SPN_SERVICE) &&
                (isCanonicalDnsName( currentServiceName )) ) {
        cSpn = 1;
    } else if ( (ServiceType == DS_SPN_NB_HOST) ||
                (ServiceType == DS_SPN_NB_DOMAIN) ) {
        cSpn = 1;
    } else {
        cSpn = 1; // count primary
    }

    //
    // Allocate array for SPNs
    //

    pSpnList = (LPWSTR *) LocalAlloc( LPTR, cSpn * sizeof( LPWSTR ) );
    if (pSpnList == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    //
    // Construct the SPNs
    //

    if (cInstanceNames) {

        for( i = 0; i < cInstanceNames; i++ ) {
            status = allocBuildSpn( ServiceClass,
                                    pInstanceNames[i],
                         (USHORT) (pInstancePorts ? pInstancePorts[i] : 0),
                                    currentServiceName,
                                    &pSpnList[i] );
            if (status != ERROR_SUCCESS) {
                goto cleanup;
            }
        }

    } else if ( (ServiceType == DS_SPN_SERVICE) &&
                (isCanonicalDnsName( currentServiceName )) ) {

        status = allocBuildSpn( ServiceClass,
                                currentServiceName,
                                InstancePort,
                                currentServiceName,
                                &pSpnList[0] );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }

    } else if ( (ServiceType == DS_SPN_NB_HOST) ||
                (ServiceType == DS_SPN_NB_DOMAIN) ) {

        status = allocBuildSpn( ServiceClass,
                                computerName,
                                InstancePort,
                                currentServiceName,
                                &pSpnList[0] );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }

    } else {

        // Add primary
        status = allocBuildSpn( ServiceClass,
                                primaryDnsHostname,
                                InstancePort,
                                currentServiceName,
                                &pSpnList[0] );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    *pcSpn = cSpn;
    *prpszSpn = pSpnList;
    pSpnList = NULL; // do not clean up, given away to caller

    status = ERROR_SUCCESS;

cleanup:
    if (pSpnList) {
        // Rely on ability of this routine to clean up partial spn arrays
        DsFreeSpnArrayW( cSpn, pSpnList );
    }

    if (primaryDnsHostname) {
        LocalFree( primaryDnsHostname );
    }

    if (computerDn) {
        LocalFree( computerDn );
    }

    if (pResult) {
        DsFreeNameResult( pResult );
    }

    return status;

} /* DsGetSpnW */


NTDSAPI
void
WINAPI
DsFreeSpnArrayA(
    IN DWORD cSpn,
    OUT LPSTR *rpszSpn
    )

/*++

Routine Description:

See DsFreeSpnArrayW

Arguments:

    rpszSPN -

Return Value:

    WINAPI -

--*/

{
    DsFreeSpnArrayW( cSpn, (LPWSTR *)rpszSpn );

} /* DsFreeSpnArrayA */


NTDSAPI
void
WINAPI
DsFreeSpnArrayW(
    IN DWORD cSpn,
    OUT LPWSTR *rpszSpn
    )

/*++

Routine Description:

Free Spn Array
This routine is extra defensive by checking for null items.  It can be used
to clean up partially allocated spn arrays in event of errors in other
routines.

Arguments:

    rpszSPN -

Return Value:

    WINAPI -

--*/

{
    DWORD i;

    if (!rpszSpn) {
        return;
    }

    for( i = 0; i < cSpn; i++ ) {
        if (rpszSpn[i]) {
            LocalFree( rpszSpn[i] );
        }
    }

    LocalFree( rpszSpn );

} /* DsFreeSpnArrayW */


NTDSAPI
DWORD
WINAPI
DsCrackSpnA(
    IN LPCSTR pszSpn,
    IN OUT DWORD *pcServiceClass,
    OUT LPSTR ServiceClass,
    IN OUT DWORD *pcServiceName,
    OUT LPSTR ServiceName,
    IN OUT DWORD *pcInstanceName,
    OUT LPSTR InstanceName,
    OUT USHORT *pInstancePort
    )
/*++

Routine Description:

Convert arguments to wide, and call DsCrackSpnW
See DsCrackSpnW

Arguments:

    pszSpn -
    pcServiceClass -
    ServiceClass -
    pcServiceName -
    ServiceName -
    pcInstanceName -
    InstanceName -
    pInstancePort -

Return Value:

    WINAPI -

--*/
{
    DWORD status, number;
    LPWSTR spnW = NULL;
    LPWSTR serviceClassW = NULL, serviceNameW = NULL, instanceNameW = NULL;

    status = ERROR_SUCCESS;

    // Convert In

    if (pszSpn) {
        status = AllocConvertWide( pszSpn, &spnW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    // Allocate space for out

    if ( (pcServiceClass) && (*pcServiceClass) && (ServiceClass) ) {
        serviceClassW = LocalAlloc( LPTR, (*pcServiceClass) * sizeof(WCHAR) );
        if (serviceClassW == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    if ( (pcServiceName) && (*pcServiceName) && (ServiceName) ) {
        serviceNameW = LocalAlloc( LPTR, (*pcServiceName) * sizeof(WCHAR) );
        if (serviceNameW == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    if ( (pcInstanceName) && (*pcInstanceName) && (InstanceName) ) {
        instanceNameW = LocalAlloc( LPTR, (*pcInstanceName) * sizeof(WCHAR) );
        if (instanceNameW == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    // Perform the function

    status = DsCrackSpnW( spnW,
                          pcServiceClass, serviceClassW,
                          pcServiceName, serviceNameW,
                          pcInstanceName, instanceNameW,
                          pInstancePort );
    if (status != ERROR_SUCCESS) {
        // Note that on ERROR_BUFFER_OVERFLOW we abort immediately without
        // trying to determine which component actually failed
        goto cleanup;
    }

    // Convert out

    if ( (pcServiceClass) && (*pcServiceClass) && (ServiceClass) ) {
        // Convert back to multi-byte
        number = WideCharToMultiByte(
            CP_ACP,
            0,                          // flags
            serviceClassW,
            *pcServiceClass,        // length in characters
            (LPSTR) ServiceClass,             // Caller's buffer
            *pcServiceClass,            // Caller's length
            NULL,                       // default char
            NULL                     // default used
            );
        if (number == 0) {
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    if ( (pcServiceName) && (*pcServiceName) && (ServiceName) ) {
        // Convert back to multi-byte
        number = WideCharToMultiByte(
            CP_ACP,
            0,                          // flags
            serviceNameW,
            *pcServiceName,        // length in characters
            (LPSTR) ServiceName,             // Caller's buffer
            *pcServiceName,            // Caller's length
            NULL,                       // default char
            NULL                     // default used
            );
        if (number == 0) {
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    if ( (pcInstanceName) && (*pcInstanceName) && (InstanceName) ) {
        // Convert back to multi-byte
        number = WideCharToMultiByte(
            CP_ACP,
            0,                          // flags
            instanceNameW,
            *pcInstanceName,        // length in characters
            (LPSTR) InstanceName,             // Caller's buffer
            *pcInstanceName,            // Caller's length
            NULL,                       // default char
            NULL                     // default used
            );
        if (number == 0) {
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    // Success!

cleanup:
    if (spnW) {
        LocalFree( spnW );
    }
    if (serviceClassW) {
        LocalFree( serviceClassW );
    }
    if (serviceNameW) {
        LocalFree( serviceNameW );
    }
    if (instanceNameW) {
        LocalFree( instanceNameW );
    }

    return status;
}


NTDSAPI
DWORD
WINAPI
DsCrackSpnW(
    IN LPCWSTR pszSpn,
    IN OUT DWORD *pcServiceClass,
    OUT LPWSTR ServiceClass,
    IN OUT DWORD *pcServiceName,
    OUT LPWSTR ServiceName,
    IN OUT DWORD *pcInstanceName,
    OUT LPWSTR InstanceName,
    OUT USHORT *pInstancePort
    )

/*++

Routine Description:

// DsCrackSpn() -- parse an SPN into the ServiceClass,
// ServiceName, and InstanceName (and InstancePort) pieces.
// An SPN is passed in, along with a pointer to the maximum length
// for each piece and a pointer to a buffer where each piece should go.
// On exit, the maximum lengths are updated to the actual length for each piece
// and the buffer contain the appropriate piece.
// Each length, buffer pair must be both present or both absent
//The InstancePort is 0 if not present.
//
// DWORD DsCrackSpn(
//  IN LPTSTR pszSPN,           // the SPN to parse
//  IN OUT PUSHORT pcServiceClass OPTIONAL,
//      input -- max length of ServiceClass;
//      output -- actual length
//   OUT LPCTSTR ServiceClass OPTIONAL, // the ServiceClass part of the SPN
//   IN OUT PUSHORT pcServiceName OPTIONAL,
//       input -- max length of ServiceName;
//       output -- actual length
//   OUT LPCTSTR ServiceName OPTIONAL,  // the ServiceName part of the SPN
//   IN OUT PUSHORT pcInstance OPTIONAL,
//        input -- max length of ServiceClass;
//        output -- actual length
//   OUT LPCTSTR InstanceName OPTIONAL,  // the InstanceName part of the SPN
//   OUT PUSHORT InstancePort OPTIONAL    // instance port
//
// Note: lengths are in characters; all string lengths include terminators
//
// We always return the needed length.  We only copy out the data if there is
// room for the data and the terminator.  If any of the three fields have
// insufficient space, buffer overflow will be returned.  To determine which
// one actually overflowed, you must compare the returned length with the
// supplied length.
//

Arguments:

    pszSpn - Input Spn
    pcServiceClass - pointer to dword, on input, max length,
                     on output current length
    ServiceClass - buffer, or zero
    pcServiceName - pointer to dword, on input, max length,
                    on output current length
    ServiceName - buffer, or zero
    pcInstanceName - pointer to dword, on input, max length,
                     on output current length
    InstanceNames - buffer, or zero
    pInstancePort - pointer to short, to receive port

Return Value:

    WINAPI -

--*/
{
    DWORD status, status1, length, classLength, instanceLength, serviceLength;
    LPCWSTR class, c1, port, p1, instance, p2, service, p3;

    // Reject empty

    if (pszSpn == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    // Reject too small
    length = wcslen( pszSpn );
    if (length < 3 ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Calculate length, extract components
    // Calculate positions of syntax components

    // Class component
    class = pszSpn;
    p1 = wcschr( pszSpn, L'/' );
    if (p1 == NULL) {
        return ERROR_INVALID_PARAMETER;
    }
    classLength = (ULONG)(p1 - class);

    instance = p1 + 1;
    c1 = wcschr( instance, L':' );
    port = c1 + 1;

    // service name part is optional
    p2 = wcschr( instance, L'/' );
    if (p2 != NULL) {
        instanceLength = (ULONG)((c1 ? c1 : p2) - instance);

        service = p2 + 1;
        serviceLength = wcslen( service );

        // Check for extra separators, which are not allowed
        p3 = wcschr( service, L'/' );
        if (p3 != NULL) {
            return ERROR_INVALID_PARAMETER;
        }
    } else {
        service = NULL;
        serviceLength = 0;
        if (c1) {
            instanceLength = (ULONG) (c1 - instance);
        } else {
            instanceLength = wcslen( instance );
        }
    }

    status = ERROR_SUCCESS;

    // Service Class part

    if ( (pcServiceClass) && (*pcServiceClass) && (ServiceClass) ) {
        status1 = extractString( class, classLength, pcServiceClass, ServiceClass );
        if (status1 == ERROR_BUFFER_OVERFLOW) {
            status = status1;
        }
    }

    // Instance name part

    if ( (pcInstanceName) && (*pcInstanceName) && (InstanceName) ) {
        status1 = extractString( instance, instanceLength,pcInstanceName, InstanceName );
        if (status1 == ERROR_BUFFER_OVERFLOW) {
            status = status1;
        }
    }

    // Service name part

    if ( (pcServiceName) && (*pcServiceName) && (ServiceName) ) {
        if (p2) {
            status1 = extractString( service, serviceLength, pcServiceName, ServiceName);
        } else {
            // Return the instance name as the service name
            status1 = extractString( instance, instanceLength,
                                     pcServiceName, ServiceName );
        }
        if (status1 == ERROR_BUFFER_OVERFLOW) {
            status = status1;
        }
    }

    // Instance port part

    if ( pInstancePort ) {
        if (c1) {
            *pInstancePort = (USHORT)_wtoi( port );
        } else {
            *pInstancePort = 0;
        }
    }

    return status;

}


NTDSAPI
DWORD
WINAPI
DsCrackSpn2A(
    IN LPCSTR pszSpn,
    IN DWORD cSpn,
    IN OUT DWORD *pcServiceClass,
    OUT LPSTR ServiceClass,
    IN OUT DWORD *pcServiceName,
    OUT LPSTR ServiceName,
    IN OUT DWORD *pcInstanceName,
    OUT LPSTR InstanceName,
    OUT USHORT *pInstancePort
    )
/*++

Routine Description:

Convert arguments to wide, and call DsCrackSpn2W
See DsCrackSpn2W

Arguments:

    pszSpn -
    cSpn -
    pcServiceClass -
    ServiceClass -
    pcServiceName -
    ServiceName -
    pcInstanceName -
    InstanceName -
    pInstancePort -

Return Value:

    WINAPI -

--*/
{
    DWORD status, number;
    LPWSTR spnW = NULL;
    LPWSTR serviceClassW = NULL, serviceNameW = NULL, instanceNameW = NULL;

    status = ERROR_SUCCESS;

    // Convert In

    if (pszSpn) {
        status = AllocConvertWideBuffer( cSpn, pszSpn, &spnW );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    // Allocate space for out

    if ( (pcServiceClass) && (*pcServiceClass) && (ServiceClass) ) {
        serviceClassW = LocalAlloc( LPTR, (*pcServiceClass) * sizeof(WCHAR) );
        if (serviceClassW == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    if ( (pcServiceName) && (*pcServiceName) && (ServiceName) ) {
        serviceNameW = LocalAlloc( LPTR, (*pcServiceName) * sizeof(WCHAR) );
        if (serviceNameW == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    if ( (pcInstanceName) && (*pcInstanceName) && (InstanceName) ) {
        instanceNameW = LocalAlloc( LPTR, (*pcInstanceName) * sizeof(WCHAR) );
        if (instanceNameW == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    // Perform the function

    status = DsCrackSpn2W( spnW,
                          cSpn,
                          pcServiceClass, serviceClassW,
                          pcServiceName, serviceNameW,
                          pcInstanceName, instanceNameW,
                          pInstancePort );
    if (status != ERROR_SUCCESS) {
        // Note that on ERROR_BUFFER_OVERFLOW we abort immediately without
        // trying to determine which component actually failed
        goto cleanup;
    }

    // Convert out

    if ( (pcServiceClass) && (*pcServiceClass) && (ServiceClass) ) {
        // Convert back to multi-byte
        number = WideCharToMultiByte(
            CP_ACP,
            0,                          // flags
            serviceClassW,
            *pcServiceClass,        // length in characters
            (LPSTR) ServiceClass,             // Caller's buffer
            *pcServiceClass,            // Caller's length
            NULL,                       // default char
            NULL                     // default used
            );
        if (number == 0) {
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    if ( (pcServiceName) && (*pcServiceName) && (ServiceName) ) {
        // Convert back to multi-byte
        number = WideCharToMultiByte(
            CP_ACP,
            0,                          // flags
            serviceNameW,
            *pcServiceName,        // length in characters
            (LPSTR) ServiceName,             // Caller's buffer
            *pcServiceName,            // Caller's length
            NULL,                       // default char
            NULL                     // default used
            );
        if (number == 0) {
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    if ( (pcInstanceName) && (*pcInstanceName) && (InstanceName) ) {
        // Convert back to multi-byte
        number = WideCharToMultiByte(
            CP_ACP,
            0,                          // flags
            instanceNameW,
            *pcInstanceName,        // length in characters
            (LPSTR) InstanceName,             // Caller's buffer
            *pcInstanceName,            // Caller's length
            NULL,                       // default char
            NULL                     // default used
            );
        if (number == 0) {
            status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    // Success!

cleanup:
    if (spnW) {
        LocalFree( spnW );
    }
    if (serviceClassW) {
        LocalFree( serviceClassW );
    }
    if (serviceNameW) {
        LocalFree( serviceNameW );
    }
    if (instanceNameW) {
        LocalFree( instanceNameW );
    }

    return status;
}


NTDSAPI
DWORD
WINAPI
DsCrackSpn2W(
    IN LPCWSTR pszSpn,
    IN DWORD cSpn,
    IN OUT DWORD *pcServiceClass,
    OUT LPWSTR ServiceClass,
    IN OUT DWORD *pcServiceName,
    OUT LPWSTR ServiceName,
    IN OUT DWORD *pcInstanceName,
    OUT LPWSTR InstanceName,
    OUT USHORT *pInstancePort
    )
/*++

Routine Description:

// DsCrackSpn2() -- parse an SPN into the ServiceClass,
// ServiceName, and InstanceName (and InstancePort) pieces.
// An SPN is passed in, along with a pointer to the maximum length
// for each piece and a pointer to a buffer where each piece should go.
// The length of the SPN string passed in is also provided. The string does
// not have to be NULL-terminated.
// On exit, the maximum lengths are updated to the actual length for each piece
// and the buffer contain the appropriate piece.
// Each length, buffer pair must be both present or both absent
//The InstancePort is 0 if not present.
//
// DWORD DsCrackSpn(
//  IN LPTSTR pszSPN,           // the SPN to parse (does not have to be NULL-terminated)
//  IN DWORD cSpn,            // length of pszSPN
//  IN OUT PUSHORT pcServiceClass OPTIONAL,
//      input -- max length of ServiceClass;
//      output -- actual length
//   OUT LPCTSTR ServiceClass OPTIONAL, // the ServiceClass part of the SPN
//   IN OUT PUSHORT pcServiceName OPTIONAL,
//       input -- max length of ServiceName;
//       output -- actual length
//   OUT LPCTSTR ServiceName OPTIONAL,  // the ServiceName part of the SPN
//   IN OUT PUSHORT pcInstance OPTIONAL,
//        input -- max length of ServiceClass;
//        output -- actual length
//   OUT LPCTSTR InstanceName OPTIONAL,  // the InstanceName part of the SPN
//   OUT PUSHORT InstancePort OPTIONAL    // instance port
//
// Note: lengths are in characters; all string lengths include terminators
//
// We always return the needed length.  We only copy out the data if there is
// room for the data and the terminator.  If any of the three fields have
// insufficient space, buffer overflow will be returned.  To determine which
// one actually overflowed, you must compare the returned length with the
// supplied length.
//

Arguments:

    pszSpn - Input Spn
    cSpn - Length of pszSpn
    pcServiceClass - pointer to dword, on input, max length,
                     on output current length
    ServiceClass - buffer, or zero
    pcServiceName - pointer to dword, on input, max length,
                    on output current length
    ServiceName - buffer, or zero
    pcInstanceName - pointer to dword, on input, max length,
                     on output current length
    InstanceNames - buffer, or zero
    pInstancePort - pointer to short, to receive port

Return Value:

    WINAPI -

--*/
{
    DWORD status, status1, classLength, instanceLength, serviceLength;
    LPCWSTR class, c1, port, p1, instance, p2, service, p3;

    // Reject empty

    if (pszSpn == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    // Reject too small
    if (cSpn < 3 ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Calculate length, extract components
    // Calculate positions of syntax components

    // Class component
    class = pszSpn;
//  p1 = wcschr( pszSpn, L'/' );
    p1 = pszSpn;
    while ( p1 < pszSpn+cSpn ) {
        if ( *p1 == L'/' ) {
            break;
        }
        p1++;
    }
    if (p1 >= pszSpn+cSpn) {
        return ERROR_INVALID_PARAMETER;
    }
    classLength = (ULONG)(p1 - class);

    instance = p1 + 1;
//  c1 = wcschr( instance, L':' );
    c1 = instance;
    while (c1 < pszSpn + cSpn) {
        if (*c1 == L':') {
            break;
        }
        c1++;
    }
    if (c1 >= pszSpn+cSpn) {
        c1 = NULL;
    }
    port = c1 + 1;

    // service name part is optional
//  p2 = wcschr( instance, L'/' );
    p2 = instance;
    while (p2 < pszSpn+cSpn) {
        if (*p2 == L'/') {
            break;
        }
        p2++;
    }
    if (p2 >= pszSpn+cSpn) {
        p2 = NULL;
    }

    if (p2 != NULL) {
        instanceLength = (ULONG)((c1 ? c1 : p2) - instance);

        service = p2 + 1;
        serviceLength = cSpn - ( ULONG )(service - pszSpn); // wcslen( service );

        // Check for extra separators, which are not allowed
//      p3 = wcschr( service, L'/' );
        p3 = service;
        while (p3 < pszSpn+cSpn) {
            if (*p3 == L'/') {
                break;
            }
            p3++;
        }
        if (p3 >= pszSpn+cSpn) {
            p3 = NULL;
        }
        if (p3 != NULL) {
            return ERROR_INVALID_PARAMETER;
        }
    } else {
        service = NULL;
        serviceLength = 0;
        if (c1) {
            instanceLength = (ULONG) (c1 - instance);
        } else {
            instanceLength = cSpn - ( ULONG )(instance - pszSpn); // wcslen( instance );
        }
    }

    status = ERROR_SUCCESS;

    // Service Class part

    if ( (pcServiceClass) && (*pcServiceClass) && (ServiceClass) ) {
        status1 = extractString( class, classLength, pcServiceClass, ServiceClass );
        if (status1 == ERROR_BUFFER_OVERFLOW) {
            status = status1;
        }
    }

    // Instance name part

    if ( (pcInstanceName) && (*pcInstanceName) && (InstanceName) ) {
        status1 = extractString( instance, instanceLength,pcInstanceName, InstanceName );
        if (status1 == ERROR_BUFFER_OVERFLOW) {
            status = status1;
        }
    }

    // Service name part

    if ( (pcServiceName) && (*pcServiceName) && (ServiceName) ) {
        if (p2) {
            status1 = extractString( service, serviceLength, pcServiceName, ServiceName);
        } else {
            // Return the instance name as the service name
            status1 = extractString( instance, instanceLength,
                                     pcServiceName, ServiceName );
        }
        if (status1 == ERROR_BUFFER_OVERFLOW) {
            status = status1;
        }
    }

    // Instance port part

    if ( pInstancePort ) {
        if (c1) {
//          *pInstancePort = (USHORT)_wtoi( port );
            *pInstancePort = 0;
            while (port < pszSpn+cSpn) {
                if ( iswdigit( *port )) {
                    *pInstancePort = *pInstancePort * 10 + (*port - L'0');
                } else {
                    break;
                }
                port++;
            }
            if ( port < pszSpn+cSpn && *port != L'/' ) {
                status = ERROR_INVALID_PARAMETER;
            }
        } else {
            *pInstancePort = 0;
        }
    }

    return status;

} /* DsCrackSpnW */

NTDSAPI
DWORD
WINAPI
DsCrackSpn3W(
    IN LPCWSTR pszSpn,
    IN DWORD cSpn,
    IN OUT DWORD *pcHostName,
    OUT LPWSTR HostName,
    IN OUT DWORD *pcInstanceName,
    OUT LPWSTR InstanceName,
    OUT USHORT *pPortNumber,
    IN OUT DWORD *pcDomainName,
    OUT LPWSTR DomainName,
    IN OUT DWORD *pcRealmName,
    OUT LPWSTR RealmName
    )
{
    DWORD status, status2;
    LPCWSTR host = NULL, instance = NULL, port = NULL, domain = NULL, realm = NULL;
    LPCWSTR p1, p2, p3, p4;
    DWORD hostLength = 0, instanceLength = 0, domainLength = 0, realmLength = 0, dwPort = 0;

    // Reject empty

    if ( pszSpn == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Reject too small
    if ( cSpn < 3 ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Host name is required
    host = pszSpn;
    p1 = pszSpn;
    while ( p1 < pszSpn + cSpn ) {
        if ( *p1 == L'/' )
            break;
        p1++;
        hostLength++;
    }

    // reject no instance and no host
    // examples: "host" or "/instance"
    if ( p1 >= pszSpn + cSpn || hostLength == 0 ) {
        return ERROR_INVALID_PARAMETER;
    }

    // reject no instance
    // example: "host/"
    instance = p1 + 1;
    if ( instance >= pszSpn+cSpn ) {
        return ERROR_INVALID_PARAMETER;
    }

    // instance ends with ':' if port is next
    // or with '/' if domain name is next
    p2 = instance;
    while ( p2 < pszSpn + cSpn ) {
        if ( *p2 == L':' || *p2 == L'/' )
            break;
        p2++;
        instanceLength++;
    }

    // reject empty instance name
    // examples: "host/:123" or "host//domain"
    if ( instanceLength == 0 ) {
        return ERROR_INVALID_PARAMETER;
    } else if ( *p2 == L':' ) {
        port = p2 + 1;
    } else if ( *p2 == L'/' ) {
        domain = p2 + 1;
    } else {
        ASSERT( p2 >= pszSpn + cSpn );
    }

    // port number is optional, but should be well-formed
    if ( port != NULL ) {
        p3 = port;
        while ( p3 < pszSpn + cSpn ) {
            if ( iswdigit( *p3 )) {
                // port numbers are unsigned 16-bit quantities
                dwPort = dwPort * 10 + ( *p3 - L'0' );
                if ( dwPort > MAXUSHORT ) {
                   return ERROR_INVALID_PARAMETER;
                }
            } else {
                break;
            }
            p3++;
        }

        // reject empty or zero port numbers
        // examples: "host/instance:0" or "host/instance:/domain"
        if ( dwPort == 0 ) {
            return ERROR_INVALID_PARAMETER;
        }
        else if ( p3 < pszSpn + cSpn ) {
            // reject port numbers that are followed by
            // anything except a domain name
            // example: "host/instance:123abc"
            if ( *p3 != L'/' ) {
                return ERROR_INVALID_PARAMETER;
            }
            ASSERT( domain == NULL );
            domain = p3 + 1;
        }
    }

    // domain name is optional
    if ( domain != NULL ) {
        LPCWSTR last = NULL;
        p4 = domain;
        while ( p4 < pszSpn + cSpn ) {
            if ( *p4 == L'@' ) {
                last = p4;
            }
            p4++;
        }
        if ( last == NULL ) {
            domainLength = ( USHORT )( p4 - domain );
        } else {
            domainLength = ( USHORT )( last - domain );
        }

        // reject empty domain names
        // examples: "host/instance/" or "host/instance/@realm"
        if ( domainLength == 0 ) {
            return ERROR_INVALID_PARAMETER;
        // reject empty realm names
        // example: "host/instance/domain@"
        } else if ( last + 1 == pszSpn + cSpn ) {
            return ERROR_INVALID_PARAMETER;
        }

        if ( last != NULL ) {
            realm = last + 1;
            realmLength = cSpn - ( ULONG )( realm - pszSpn );
        }
    }

    status = ERROR_SUCCESS;

    // Host name part

    if ( pcHostName && HostName ) {
        status2 = extractString( host, hostLength, pcHostName, HostName );
        if ( status2 == ERROR_BUFFER_OVERFLOW ) {
            status = status2;
        }
    }

    // InstanceName name part

    if ( pcInstanceName && InstanceName ) {
        status2 = extractString( instance, instanceLength, pcInstanceName, InstanceName );
        if ( status2 == ERROR_BUFFER_OVERFLOW ) {
            status = status2;
        }
    }

    // Port part

    if ( pPortNumber ) {
        *pPortNumber = ( USHORT )dwPort;
    }

    // DomainName name part

    if ( pcDomainName && DomainName ) {
        status2 = extractString( domain, domainLength, pcDomainName, DomainName );
        if ( status2 == ERROR_BUFFER_OVERFLOW ) {
            status = status2;
        }
    }

    // RealmName name part

    if ( pcRealmName && RealmName ) {
        status2 = extractString( realm, realmLength, pcRealmName, RealmName );
        if ( status2 == ERROR_BUFFER_OVERFLOW ) {
            status = status2;
        }
    }

    return status;
}



NTDSAPI
DWORD
WINAPI
DsWriteAccountSpnA(
    IN HANDLE hDS,
    IN DS_SPN_WRITE_OP Operation,
    IN LPCSTR pszAccount,
    IN DWORD cSpn,
    IN LPCSTR *rpszSpn
    )

/*++

Routine Description:

Convert arguments to Unicode and call DsWriteAccountSpnW

Arguments:

    hDS - DS Rpc handle, from calling DsBind{A,W}
    Operation - Operation code
    pszAccount - DN of a computer object
    cSpn - Count of spns, may be zero for replace operation
    rpszSpn - Spn array

Return Value:

    WINAPI -

--*/

{
    DWORD status, i;
    LPWSTR accountW = NULL;
    LPWSTR *pSpnW = NULL;

    // Validate
    // cSpn may be 0 and pSpn may be null under some circumstances

    if ( (hDS == NULL ) ||
         (pszAccount == NULL) ||
         ( (cSpn == 0) != (rpszSpn == NULL) )
        ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Convert IN

    status = AllocConvertWide( pszAccount, &accountW );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    if ( (cSpn) && (rpszSpn) ) {
        pSpnW = (LPWSTR *) LocalAlloc( LPTR, cSpn * sizeof( LPWSTR ) );
        if (pSpnW == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        for( i = 0; i < cSpn; i++ ) {
            status = AllocConvertWide( rpszSpn[i], &(pSpnW[i]) );
            if (status != ERROR_SUCCESS) {
                goto cleanup;
            }
        }
    }

    // Call the wide version of the function

    status = DsWriteAccountSpnW( hDS, Operation, accountW, cSpn, pSpnW );

    // No other operations required

    // status already set, fall through
cleanup:
    if (accountW) {
        LocalFree( accountW );
    }

    if ( (cSpn) && (pSpnW) ) {
        for( i = 0; i < cSpn; i++ ) {
            if (pSpnW[i] != NULL) {
                LocalFree( pSpnW[i] );
            }
        }
        LocalFree( pSpnW );
    }

    return status;

} /* DsWriteAccountSpnA */


NTDSAPI
DWORD
WINAPI
DsWriteAccountSpnW(
    IN HANDLE hDS,
    IN DS_SPN_WRITE_OP Operation,
    IN LPCWSTR pszAccount,
    IN DWORD cSpn,
    IN LPCWSTR *rpszSpn
    )

/*++

Routine Description:

Write SPNs to the Directory Service.  The are actually added to the Service-
Principal-Name attribute of a computer object.

The caller must have write access to the object and attribute in order for
this function to succeed.

cSpn is allowed to be zero when doing a replace, meaning "remove the
attribute".

There is a certain ambibuity regarding status when multiple SPNs are provided.
It appears the semantics of the core functions are that success is returned if
any complete successfully.  The modification is done "permissively", meaning
that soft errors are not returned, such as adding a value which already exists
is NOT an error.

Arguments:

    hDS - DS Rpc handle, from calling DsBind{A,W}
    Operation - Operation code
    pszAccount - DN of a computer object
    cSpn - Count of spns, may be zero for replace operation
    rpszSpn - Spn array

Return Value:

    WINAPI -

--*/

{
    DRS_MSG_SPNREQ spnReq;
    DRS_MSG_SPNREPLY spnReply;
    DWORD status, i, dwOutVersion;
#if DBG
    DWORD startTime = GetTickCount();
#endif

    // Validate
    // cSpn may be 0 and pSpn may be null under some circumstances

    if ( (hDS == NULL ) ||
         (pszAccount == NULL) ||
         ( (cSpn == 0) != (rpszSpn == NULL) )
        ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Input parameters

    memset(&spnReq, 0, sizeof(spnReq));
    memset(&spnReply, 0, sizeof(spnReply));

    spnReq.V1.operation = Operation;
    spnReq.V1.pwszAccount = pszAccount;
    spnReq.V1.cSPN = cSpn;
    spnReq.V1.rpwszSPN = rpszSpn;

    status = ERROR_SUCCESS;

    // Call the server

    __try
    {
        // Following call returns WIN32 errors, not DRAERR_* values.
        status = _IDL_DRSWriteSPN(
                        ((BindState *) hDS)->hDrs,
                        1,                              // dwInVersion
                        &spnReq,
                        &dwOutVersion,
                        &spnReply);

        if ( 0 == status )
        {
            if ( 1 != dwOutVersion )
            {
                status = RPC_S_INTERNAL_ERROR;
            }
            else
            {
                status = spnReply.V1.retVal;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = RpcExceptionCode();
    }

    MAP_SECURITY_PACKAGE_ERROR( status );

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=DsWriteAccountSpn]"));
    DSLOG((0,"[PA=%u][PA=%ws][ST=%u][ET=%u][ER=%u][-]\n",
           Operation, pszAccount, startTime, GetTickCount(), status))

    return status;

} /* DsWriteAccountSpnW */


DWORD
extractString(
    IN LPCWSTR Start,
    IN DWORD Length,
    IN OUT DWORD *pSize,
    OUT LPWSTR Output
    )

/*++

Routine Description:

Helper routine to write a counted substring to an output buffer, with length

If the supplied buffer length is not sufficient for the data and the
terminator, return the needed length and a status of overflow.
Arguments:

    Start - pointer to start of string
    Length - length, in characters
    pSize - pointer to dword, in max length, out curr length
    Output - output buffer, optional

Return Value:

    DWORD - status, ERROR_SUCCESS or ERROR_BUFFER_OVERFLOW

--*/

{
    DWORD available = *pSize;

    *pSize = Length + 1; // return needed length in all cases

    if (available <= Length) {
        return ERROR_BUFFER_OVERFLOW;
    }

    wcsncpy( Output, Start, Length );
    Output[Length] = L'\0';

    return ERROR_SUCCESS;
} /* extractString */


static DWORD
allocBuildSpn(
    IN LPCWSTR ServiceClass,
    IN LPCWSTR InstanceName,
    IN USHORT InstancePort,
    IN LPCWSTR ServiceName OPTIONAL,
    OUT LPWSTR *pSpn
    )

/*++

Routine Description:

Helper routine to construct a spn.  Given the components, allocate enough
space and construct the spn.

13-May-99, Paulle says:

Essentially, a poll was taken, to see whether there should be a trailing dot or
not. In favor of trailing dots was the general DNS conventions that "real"
FQDNs have "." at the end. Against seemed to be the preponderance of existing
code, such as gethostbyname(). So we decided that DNS names in SPNs wouldn't have
"." at the end, and that as a service the DsSpn API would remove them if present.

Arguments:

    ServiceClass -
    InstanceName -
    InstancePort -
    ServiceName -
    pSpn -

Return Value:

    DWORD -

--*/

{
    DWORD status, length;
    WCHAR numberBuffer[10];
    LPWSTR Spn = NULL, pwzPart;

    // Calculate length, including optional components

    length = wcslen( ServiceClass ) +
        wcslen( InstanceName ) + 2;
    if (ServiceName) {
        length += wcslen( ServiceName ) + 1;
    }

    if (InstancePort) {
        _itow(InstancePort, numberBuffer, 10);
        length += 1 + wcslen( numberBuffer );
    }

    // Allocate space

    Spn = LocalAlloc( LPTR, length * sizeof(WCHAR) );
    if (Spn == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        return status;
    }

    // Fill it in

    pwzPart = Spn;

    wcscpy( pwzPart, ServiceClass );
    pwzPart += wcslen( ServiceClass );
    wcscpy( pwzPart, L"/" );
    pwzPart++;
    wcscpy( pwzPart, InstanceName );
    pwzPart += wcslen( InstanceName );

    // If instance has a trailing dot
    pwzPart--;
    if (*pwzPart == L'.') {
        *pwzPart = L'\0';
    } else {
        pwzPart++;
    }

    if (InstancePort) {
        wcscpy( pwzPart, L":" );
        pwzPart++;
        wcscpy( pwzPart, numberBuffer );
        pwzPart += wcslen( numberBuffer );
    }

    if (ServiceName) {
        wcscpy( pwzPart, L"/" );
        pwzPart++;
        wcscpy( pwzPart, ServiceName );
        pwzPart += wcslen( ServiceName );

        // If ServiceName has a trailing dot, remove it
        pwzPart--;
        if (*pwzPart == L'.') {
            *pwzPart = L'\0';
        } else {
            pwzPart++;
        }
    }

    // Return value to caller
    *pSpn = Spn;

    return ERROR_SUCCESS;
} /* allocBuildSpn */


static BOOLEAN
isCanonicalDnsName(
    IN LPCWSTR DnsName
    )

/*++

Routine Description:

Check if a dns service name is "canonical".  Do this by looking for a well-
known prefix at the start of the name.

Arguments:

    DnsName -

Return Value:

    BOOLEAN -

--*/

{
    DWORD i;

    // PERFHINT SCALING: linear search. Use binary search someday

    for( i = 0; i < NUMBER_ELEMENTS( WellKnownDnsPrefixes ); i++ ) {
        if ( wcsstr( DnsName, WellKnownDnsPrefixes[i] ) == DnsName ) {
            return TRUE;
        }
    }

    return FALSE;
} /* isCanonicalDnsName */

/* end of spn.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsapi\win95\apibuff.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    apibuff.c

Abstract:

    Implementation of NetApiBufferFree since it isn't supplied on Win95.
    See also private\net\api\apibuff.c.

Author:

    DaveStr     10-Dec-97

Environment:

    User Mode - Win32

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <lmcons.h>         // MAPI constants req'd for lmapibuf.h
#include <lmapibuf.h>       // NetApiBufferFree()
#include <align.h>
#include <rpc.h>
#include <rpcndr.h>         // MIDL_user_free()

NET_API_STATUS NET_API_FUNCTION
NetApiBufferFree (
    IN LPVOID Buffer
    )
{
    if ( NULL == Buffer )
    {
        return(NO_ERROR);
    }

    if ( !POINTER_IS_ALIGNED(Buffer, ALIGN_WORST) )
    {
        return(ERROR_INVALID_PARAMETER);
    }

    MIDL_user_free(Buffer);

    return(NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\client\bind.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    wrappers.c

Abstract:

    This file contains all SAM rpc binding routines.

Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "samclip.h"
#include <rpcasync.h>




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////






///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

RPC_BINDING_HANDLE
PSAMPR_SERVER_NAME_bind (
    PSAMPR_SERVER_NAME ServerName
    )

/*++

Routine Description:

    This routine calls a common bind routine that is shared by all services.
    This routine is called from SamConnect server stub to connect to the
    server.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    RPC_BINDING_HANDLE          BindingHandle = NULL;
    WCHAR                       *StringBinding = NULL;
    DWORD                       dwErr;
    RPC_SECURITY_QOS            qos;
    TlsInfo                     *pTlsInfo;

    if (    (pTlsInfo = (TlsInfo *) TlsGetValue(gTlsIndex))
         && pTlsInfo->Creds )
    {
        RpcTryExcept
        {
            if ( 0 == wcsncmp(ServerName, L"\\\\", 2) )
            {
                ServerName += 2;
            }

            dwErr = RpcStringBindingComposeW(
                                    NULL,
                                    L"ncacn_ip_tcp",
                                    ServerName,
                                    NULL,
                                    NULL,
                                    &StringBinding);

            if ( RPC_S_OK == dwErr )
            {
                dwErr = RpcBindingFromStringBindingW(
                                    StringBinding,
                                    &BindingHandle);

                if ( RPC_S_OK == dwErr )
                {
                    dwErr = RpcEpResolveBinding(
                                    BindingHandle,
                                    samr_ClientIfHandle);

                    if ( RPC_S_OK == dwErr )
                    {
                        qos.Version = RPC_C_SECURITY_QOS_VERSION;
                        qos.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;
                        qos.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;
                        qos.ImpersonationType = RPC_C_IMP_LEVEL_DEFAULT;
                        
                        dwErr = RpcBindingSetAuthInfoExW(
                                    BindingHandle,
                                    (pTlsInfo->Spn) ? pTlsInfo->Spn 
                                                    : L"samr",
                                    RPC_C_PROTECT_LEVEL_PKT_PRIVACY,
                                    (pTlsInfo->Spn) ? RPC_C_AUTHN_GSS_NEGOTIATE
                                                    : RPC_C_AUTHN_WINNT,
                                    pTlsInfo->Creds,
                                    0,
                                    &qos);
                    }
                }
            }
        } 
        RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
        {
            dwErr = RpcExceptionCode();
        }
        RpcEndExcept;

        if ( dwErr && BindingHandle )
        {
            RpcBindingFree(&BindingHandle);
        }

        if ( StringBinding )
        {
            RpcStringFreeW(&StringBinding);
        }
    }
    else
    {
        dwErr =  RpcpBindRpc(ServerName, L"samr", 0, &BindingHandle);

        if ( dwErr && BindingHandle )
        {
            RpcpUnbindRpc(BindingHandle);
            BindingHandle = NULL;
        }
    }

    return(BindingHandle);
}


void
PSAMPR_SERVER_NAME_unbind (
    PSAMPR_SERVER_NAME ServerName,
    RPC_BINDING_HANDLE BindingHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.

    This routine is called from the SamConnect client stub to
    unbind from the SAM client.


Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);     // This parameter is not used


    RpcpUnbindRpc ( BindingHandle );
    return;
}

RPC_BINDING_HANDLE
SampSecureBind(
    LPWSTR ServerName,
    ULONG AuthnLevel
    )

/*++

Routine Description:

    This routine calls a common bind routine that is shared by all services.
    This routine is called from SamConnect server stub to connect to the
    server.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

    AuthnLevel - Authentication level to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    RPC_BINDING_HANDLE  BindingHandle = NULL;
    RPC_STATUS          RpcStatus;

#if 1
    RpcpBindRpc (  ServerName,
                   L"samr",
                   0,
                   &BindingHandle
                   );
#else
    LPWSTR StringBinding;
    RpcStatus = RpcStringBindingComposeW(
                    0,
                    L"ncacn_spx",
                    ServerName+2,
                    NULL,           // dynamic endpoint
                    NULL,           // no options
                    &StringBinding
                    );
    if (RpcStatus != 0)
    {
        return(NULL);
    }
    RpcStatus = RpcBindingFromStringBindingW(
                    StringBinding,
                    &BindingHandle
                    );
    RpcStringFreeW(&StringBinding);

#endif


    if ( (BindingHandle != NULL) &&
         (AuthnLevel != RPC_C_AUTHN_LEVEL_NONE) ) {

        RpcStatus = RpcBindingSetAuthInfoW(
                        BindingHandle,
                        NULL,               // server principal name
                        AuthnLevel,
                        RPC_C_AUTHN_WINNT,
                        NULL,
                        RPC_C_AUTHZ_DCE
                        );
        if (RpcStatus != 0) {
            RpcBindingFree(&BindingHandle);
        }

    }



    return( BindingHandle);
}



void
SampSecureUnbind (
    RPC_BINDING_HANDLE BindingHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.

    This routine is called from the SamConnect client stub to
    unbind from the SAM client.


Arguments:

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{


    RpcpUnbindRpc ( BindingHandle );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\client\dllentry.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dllentry.c

Abstract:

    This file contains DLL entry point code.

Author:

    DaveStr     12-Mar-99

Environment:

    User Mode - Win32

Revision History:

--*/

#include "samclip.h"

DWORD gTlsIndex = 0xFFFFFFFF;

BOOL InitializeDll(
    IN  HINSTANCE hdll,
    IN  DWORD     dwReason,
    IN  LPVOID    lpReserved
    )
{
    UNREFERENCED_PARAMETER(hdll);
    UNREFERENCED_PARAMETER(lpReserved);

    if ( DLL_PROCESS_ATTACH  == dwReason )
    {
        gTlsIndex = TlsAlloc();

        if ( (0xFFFFFFFF == gTlsIndex) || !TlsSetValue(gTlsIndex, NULL) )
        {
            gTlsIndex = 0xFFFFFFFF;
            return(FALSE);
        }
    }
    else if ( dwReason == DLL_PROCESS_DETACH )
    {
        if ( 0xFFFFFFFF != gTlsIndex )
        {
            TlsFree(gTlsIndex);
            gTlsIndex = 0xFFFFFFFF;
        }
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\client\password.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    wrappers.c

Abstract:

    This file contains all SAM rpc wrapper routines.

Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "samclip.h"


NTSTATUS
SampRandomFill(
    IN ULONG BufferSize,
    IN OUT PUCHAR Buffer
)
/*++

Routine Description:

    This routine fills a buffer with random data.

Parameters:

    BufferSize - Length of the input buffer, in bytes.

    Buffer - Input buffer to be filled with random data.

Return Values:

    Errors from NtQuerySystemTime()


--*/
{
    ULONG Index;
    LARGE_INTEGER Time;
    ULONG Seed;
    NTSTATUS NtStatus;


    NtStatus = NtQuerySystemTime(&Time);
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    Seed = Time.LowPart ^ Time.HighPart;

    for (Index = 0 ; Index < BufferSize ; Index++ )
    {
        *Buffer++ = (UCHAR) (RtlRandom(&Seed) % 256);
    }
    return(STATUS_SUCCESS);

}


NTSTATUS
SampCalculateLmPassword(
    IN PUNICODE_STRING NtPassword,
    OUT PCHAR *LmPasswordBuffer
    )

/*++

Routine Description:

    This service converts an NT password into a LM password.

Parameters:

    NtPassword - The Nt password to be converted.

    LmPasswordBuffer - On successful return, points at the LM password
                The buffer should be freed using MIDL_user_free

Return Values:

    STATUS_SUCCESS - LMPassword contains the LM version of the password.

    STATUS_NULL_LM_PASSWORD - The password is too complex to be represented
        by a LM password. The LM password returned is a NULL string.


--*/
{

#define LM_BUFFER_LENGTH    (LM20_PWLEN + 1)

    NTSTATUS       NtStatus;
    ANSI_STRING    LmPassword;

    //
    // Prepare for failure
    //

    *LmPasswordBuffer = NULL;


    //
    // Compute the Ansi version to the Unicode password.
    //
    //  The Ansi version of the Cleartext password is at most 14 bytes long,
    //      exists in a trailing zero filled 15 byte buffer,
    //      is uppercased.
    //

    LmPassword.Buffer = MIDL_user_allocate(LM_BUFFER_LENGTH);
    if (LmPassword.Buffer == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    LmPassword.MaximumLength = LmPassword.Length = LM_BUFFER_LENGTH;
    RtlZeroMemory( LmPassword.Buffer, LM_BUFFER_LENGTH );

    NtStatus = RtlUpcaseUnicodeStringToOemString( &LmPassword, NtPassword, FALSE );


    if ( !NT_SUCCESS(NtStatus) ) {

        //
        // The password is longer than the max LM password length
        //

        NtStatus = STATUS_NULL_LM_PASSWORD; // Informational return code
        RtlZeroMemory( LmPassword.Buffer, LM_BUFFER_LENGTH );

    }




    //
    // Return a pointer to the allocated LM password
    //

    if (NT_SUCCESS(NtStatus)) {

        *LmPasswordBuffer = LmPassword.Buffer;

    } else {

        MIDL_user_free(LmPassword.Buffer);
    }

    return(NtStatus);
}


NTSTATUS
SamiEncryptPasswords(
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword,
    OUT PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldNt,
    OUT PENCRYPTED_NT_OWF_PASSWORD OldNtOwfEncryptedWithNewNt,
    OUT PBOOLEAN LmPresent,
    OUT PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,
    OUT PENCRYPTED_NT_OWF_PASSWORD OldLmOwfEncryptedWithNewNt
)
/*++

Routine Description:

    This routine takes old and new cleartext passwords, converts them to
    LM passwords, generates OWF passwords, and produces reversibly
    encrypted cleartext and OWF passwords.

Arguments:

    OldPassword - The current cleartext password for the user.

    NewPassword - The new cleartext password for the user.

    NewEncryptedWithOldNt - The new password, in an SAMPR_USER_PASSWORD
        structure, reversibly encrypted with the old NT OWF password.

    OldNtOwfEncryptedWithNewNt - The old NT OWF password reversibly
        encrypted with the new NT OWF password.

    LmPresent - Indicates whether or not LM versions of the passwords could
        be calculated.

    NewEncryptedWithOldLm - The new password, in an SAMPR_USER_PASSWORD
        structure, reversibly encrypted with the old LM OWF password.

    OldLmOwfEncryptedWithNewNt - The old LM OWF password reversibly
        encrypted with the new NT OWF password.


Return Value:

    Errors from RtlEncryptXXX functions

--*/
{
    PCHAR OldLmPassword = NULL;
    PCHAR NewLmPassword = NULL;
    LM_OWF_PASSWORD OldLmOwfPassword;
    NT_OWF_PASSWORD OldNtOwfPassword;
    NT_OWF_PASSWORD NewNtOwfPassword;
    PSAMPR_USER_PASSWORD NewNt = (PSAMPR_USER_PASSWORD) NewEncryptedWithOldNt;
    PSAMPR_USER_PASSWORD NewLm = (PSAMPR_USER_PASSWORD) NewEncryptedWithOldLm;
    struct RC4_KEYSTRUCT Rc4Key;
    NTSTATUS NtStatus;
    BOOLEAN OldLmPresent = TRUE;
    BOOLEAN NewLmPresent = TRUE;


    //
    // Initialization
    //

    *LmPresent = TRUE;

    //
    // Make sure the password isn't too long.
    //

    if (NewPassword->Length > SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Calculate the LM passwords. This may fail because the passwords are
    // too complex, but we can deal with that, so just remember what failed.
    //

    NtStatus = SampCalculateLmPassword(
                OldPassword,
                &OldLmPassword
                );

    if (NtStatus != STATUS_SUCCESS) {
        OldLmPresent = FALSE;
        *LmPresent = FALSE;

        //
        // If the error was that it couldn't calculate the password, that
        // is o.k.
        //

        if (NtStatus == STATUS_NULL_LM_PASSWORD) {
            NtStatus = STATUS_SUCCESS;
        }

    }



    //
    // Calculate the LM OWF passwords
    //

    if (NT_SUCCESS(NtStatus) && OldLmPresent) {
        NtStatus = RtlCalculateLmOwfPassword(
                    OldLmPassword,
                    &OldLmOwfPassword
                    );
    }


    //
    // Calculate the NT OWF passwords
    //

    if (NT_SUCCESS(NtStatus)) {
        NtStatus = RtlCalculateNtOwfPassword(
                    OldPassword,
                    &OldNtOwfPassword
                    );
    }

    if (NT_SUCCESS(NtStatus)) {
        NtStatus = RtlCalculateNtOwfPassword(
                    NewPassword,
                    &NewNtOwfPassword
                    );
    }

    //
    // Calculate the encrypted old passwords
    //

    if (NT_SUCCESS(NtStatus)) {
        NtStatus = RtlEncryptNtOwfPwdWithNtOwfPwd(
                    &OldNtOwfPassword,
                    &NewNtOwfPassword,
                    OldNtOwfEncryptedWithNewNt
                    );
    }

    //
    // Compute the encrypted old LM password.  Always use the new NT OWF
    // to encrypt it, since we may not have a new LM OWF password.
    //


    if (NT_SUCCESS(NtStatus) && OldLmPresent) {
        ASSERT(LM_OWF_PASSWORD_LENGTH == NT_OWF_PASSWORD_LENGTH);

        NtStatus = RtlEncryptLmOwfPwdWithLmOwfPwd(
                    &OldLmOwfPassword,
                    (PLM_OWF_PASSWORD) &NewNtOwfPassword,
                    OldLmOwfEncryptedWithNewNt
                    );
    }

    //
    // Calculate the encrypted new passwords
    //

    if (NT_SUCCESS(NtStatus)) {

        ASSERT(sizeof(SAMPR_ENCRYPTED_USER_PASSWORD) == sizeof(SAMPR_USER_PASSWORD));

        //
        // Compute the encrypted new password with NT key.
        //

        rc4_key(
            &Rc4Key,
            NT_OWF_PASSWORD_LENGTH,
            (PUCHAR) &OldNtOwfPassword
            );

        RtlCopyMemory(
            ((PUCHAR) NewNt->Buffer) +
                SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR) -
                NewPassword->Length,
            NewPassword->Buffer,
            NewPassword->Length
            );

        *(ULONG UNALIGNED *) &NewNt->Length = NewPassword->Length;

        //
        // Fill the rest of the buffer with random numbers
        //

        NtStatus = SampRandomFill(
                    (SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                        NewPassword->Length,
                    (PUCHAR) NewNt->Buffer
                    );
    }

    if (NT_SUCCESS(NtStatus))
    {
        rc4(&Rc4Key,
            sizeof(SAMPR_USER_PASSWORD),
            (PUCHAR) NewEncryptedWithOldNt
            );

    }

    //
    // Compute the encrypted new password with LM key if it exists.
    //


    if (NT_SUCCESS(NtStatus) && OldLmPresent) {

        rc4_key(
            &Rc4Key,
            LM_OWF_PASSWORD_LENGTH,
            (PUCHAR) &OldLmOwfPassword
            );

        RtlCopyMemory(
            ((PUCHAR) NewLm->Buffer) +
                (SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                NewPassword->Length,
            NewPassword->Buffer,
            NewPassword->Length
            );

        *(ULONG UNALIGNED *) &NewLm->Length = NewPassword->Length;

        NtStatus = SampRandomFill(
                    (SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                        NewPassword->Length,
                    (PUCHAR) NewLm->Buffer
                    );


    }

    //
    // Encrypt the password (or, if the old LM OWF password does not exist,
    // zero it).

    if (NT_SUCCESS(NtStatus) && OldLmPresent) {

        rc4(&Rc4Key,
            sizeof(SAMPR_USER_PASSWORD),
            (PUCHAR) NewEncryptedWithOldLm
            );

    } else {
        RtlZeroMemory(
            NewLm,
            sizeof(SAMPR_ENCRYPTED_USER_PASSWORD)
            );
    }



    //
    // Make sure to zero the passwords before freeing so we don't have
    // passwords floating around in the page file.
    //

    if (OldLmPassword != NULL) {

        RtlZeroMemory(
            OldLmPassword,
            lstrlenA(OldLmPassword)
            );

        MIDL_user_free(OldLmPassword);
    }


    return(NtStatus);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\client\samrpc_c_stub.c ===
#include "samrpc_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\client\samclip.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    samclip.h

Abstract:

    This file contains definitions needed by SAM client stubs.

Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/

#ifndef _NTSAMP_CLIENT_
#define _NTSAMP_CLIENT_




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>      // DbgPrint prototype
#include <rpc.h>        // DataTypes and runtime APIs
#include <nturtl.h>     // needed for winbase.h
#include <windows.h>    // LocalAlloc
//#include <winbase.h>    // LocalAlloc

#include <string.h>     // strlen
#include <stdio.h>      // sprintf
//#include <tstring.h>    // Unicode string macros

#include <ntrpcp.h>     // prototypes for MIDL user functions
#include <samrpc_c.h>   // midl generated client SAM RPC definitions
#include <lmcons.h>     // To get LM password length
#include <ntsam.h>
#include <ntsamp.h>
#include <ntlsa.h>      // for LsaOpenPolicy...
#include <rc4.h>        // rc4, rc4_key
#include <rpcndr.h>     // RpcSsDestroyContext




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Defines                                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// data types                                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _TlsInfo {
    RPC_AUTH_IDENTITY_HANDLE    Creds;
    PWCHAR                      Spn;
    BOOL                        fDstIsW2K;
} TlsInfo;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Prototypes                                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

extern DWORD gTlsIndex;

void
SampSecureUnbind (
    RPC_BINDING_HANDLE BindingHandle
    );

RPC_BINDING_HANDLE
SampSecureBind(
    LPWSTR ServerName,
    ULONG AuthnLevel
    );

NTSTATUS
SamiEncryptPasswords(
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword,
    OUT PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldNt,
    OUT PENCRYPTED_NT_OWF_PASSWORD OldNtOwfEncryptedWithNewNt,
    OUT PBOOLEAN LmPresent,
    OUT PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,
    OUT PENCRYPTED_NT_OWF_PASSWORD OldLmOwfEncryptedWithNewNt
    );

NTSTATUS
SampCalculateLmPassword(
    IN PUNICODE_STRING NtPassword,
    OUT PCHAR *LmPasswordBuffer
    );

NTSTATUS
SampRandomFill(
    IN ULONG BufferSize,
    IN OUT PUCHAR Buffer
    );

#endif // _NTSAMP_CLIENT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\client\tconnect.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tconnect.c

Abstract:

    This is the file for a simple connection test to SAM.

Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntsam.h>
#include <ntrtl.h>      // DbgPrint()





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID
main (
    VOID
    )

/*++

Routine Description:

    This is the main entry routine for this test.

Arguments:

    None.

Return Value:


    Note:


--*/
{
    NTSTATUS            NtStatus;
    SAM_HANDLE          ServerHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;


    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL );


    NtStatus = SamConnect(
                  NULL,                     // ServerName (Local machine)
                  &ServerHandle,
                  SAM_SERVER_ALL_ACCESS,
                  &ObjectAttributes
                  );

    DbgPrint("SAM TEST (Connect): Status of SamConnect() is: 0x%lx\n", NtStatus);


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\client\tchgpwd.c ===
// Test changing a SAM password



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <nt.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <ntlsa.h>
#include <ntrpcp.h>     // prototypes for MIDL user functions
#include <seopaque.h>
#include <string.h>


VOID
main (argc, argv)
int argc;
char **argv;

{
    NTSTATUS                    Status;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQos;
    PSID                        DomainSid = NULL;
    PULONG                      UserId = NULL;
    PSID_NAME_USE               NameUse = NULL;
    SAM_HANDLE                  SamHandle = NULL;
    SAM_HANDLE                  DomainHandle = NULL;
    SAM_HANDLE                  UserHandle = NULL;
    WCHAR                       UserNameBuffer[80];
    WCHAR                       OldPasswordBuffer[80];
    WCHAR                       NewPasswordBuffer[80];
    UNICODE_STRING              UserName;
    UNICODE_STRING              Domain;
    UNICODE_STRING              OldPassword;
    UNICODE_STRING              NewPassword;
    ANSI_STRING                 AnsiString;

    UserName.Buffer = UserNameBuffer;
    UserName.MaximumLength = sizeof(UserNameBuffer);

    OldPassword.Buffer = OldPasswordBuffer;
    OldPassword.MaximumLength = sizeof(OldPasswordBuffer);

    NewPassword.Buffer = NewPasswordBuffer;
    NewPassword.MaximumLength = sizeof(NewPasswordBuffer);

    RtlInitUnicodeString(&Domain, L"Account");


    RtlInitAnsiString(&AnsiString, argv[1]);
    RtlAnsiStringToUnicodeString(&UserName, &AnsiString, FALSE);

    if (*(argv[2]) == '-') {
        *(argv[2]) = 0;
    }
    RtlInitAnsiString(&AnsiString, argv[2]);
    RtlAnsiStringToUnicodeString(&OldPassword, &AnsiString, FALSE);

    if (*(argv[3]) == '-') {
        *(argv[3]) = 0;
    }
    RtlInitAnsiString(&AnsiString, argv[3]);
    RtlAnsiStringToUnicodeString(&NewPassword, &AnsiString, FALSE);

    //
    // Setup ObjectAttributes for SamConnect call.
    //

    InitializeObjectAttributes(&ObjectAttributes, NULL, 0, 0, NULL);
    ObjectAttributes.SecurityQualityOfService = &SecurityQos;

    SecurityQos.Length = sizeof(SecurityQos);
    SecurityQos.ImpersonationLevel = SecurityIdentification;
    SecurityQos.ContextTrackingMode = SECURITY_STATIC_TRACKING;
    SecurityQos.EffectiveOnly = FALSE;

    Status = SamConnect(
                 NULL,
                 &SamHandle,
                 GENERIC_EXECUTE,
                 &ObjectAttributes
                 );

    if ( !NT_SUCCESS(Status) ) {
        DbgPrint("MspChangePasswordSam: SamConnect failed, status %8.8x\n", Status);
        goto Cleanup;
    }


    Status = SamLookupDomainInSamServer(
                 SamHandle,
                 &Domain,
                 &DomainSid
                 );

    if ( !NT_SUCCESS(Status) ) {
        DbgPrint("MspChangePasswordSam: Cannot find account domain, status %8.8x\n", Status);
        Status = STATUS_CANT_ACCESS_DOMAIN_INFO;
        goto Cleanup;
    }

    Status = SamOpenDomain(
                 SamHandle,
                 GENERIC_EXECUTE,
                 DomainSid,
                 &DomainHandle
                 );

    if ( !NT_SUCCESS(Status) ) {
        DbgPrint("MspChangePasswordSam: Cannot open account domain, status %8.8x\n", Status);
        Status = STATUS_CANT_ACCESS_DOMAIN_INFO;
        goto Cleanup;
    }

    Status = SamLookupNamesInDomain(
                 DomainHandle,
                 1,
                 &UserName,
                 &UserId,
                 &NameUse
                 );

    if ( !NT_SUCCESS(Status) ) {
        DbgPrint("MspChangePasswordSam: Cannot lookup user %wZ, status %8.8x\n", &UserName, Status);
        goto Cleanup;
    }

    Status = SamOpenUser(
                 DomainHandle,
                 USER_CHANGE_PASSWORD,
                 *UserId,
                 &UserHandle
                 );

    if ( !NT_SUCCESS(Status) ) {
        DbgPrint("MspChangePasswordSam: Cannot open user %wZ, status %8.8x\n",
                 &UserName, Status);
        goto Cleanup;
    }

    Status = SamChangePasswordUser(
                 UserHandle,
                 &OldPassword,
                 &NewPassword
                 );

    if ( !NT_SUCCESS(Status) ) {
        DbgPrint("MspChangePasswordSam: Failed to change user password, status %8.8x\n", Status);
    }


Cleanup:

    //
    // Free DomainSid if used.
    //

    if (DomainSid) {
        SamFreeMemory(DomainSid);
    }

    //
    // Free UserId if used.
    //

    if (UserId) {
        SamFreeMemory(UserId);
    }

    //
    // Free NameUse if used.
    //

    if (NameUse) {
        SamFreeMemory(NameUse);
    }

    //
    // Close UserHandle if open.
    //

    if (UserHandle) {
        SamCloseHandle(UserHandle);
    }

    //
    // Close DomainHandle if open.
    //

    if (DomainHandle) {
        SamCloseHandle(DomainHandle);
    }

    //
    // Close SamHandle if open.
    //

    if (SamHandle) {
        SamCloseHandle(SamHandle);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\client\temp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    temp.c

Abstract:

    This file contains temporary SAM rpc wrapper routines.

Author:

    Jim Kelly    (JimK)  14-Feb-1992

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "samclip.h"


typedef struct _SAMP_TEMP_USER_STRINGS {
    ULONG  Rid;
    WCHAR  LogonName[14];
    WCHAR  FullName[24];
    WCHAR  AdminComment[24];
} SAMP_TEMP_USER_STRINGS, *PSAMP_TEMP_USER_STRINGS;


#define SAMP_TEMP_USER_COUNT (40)
#define SAMP_TEMP_USER1      (25)
#define SAMP_TEMP_USER2      (15)


typedef struct _SAMP_TEMP_MACHINE_STRINGS {
    ULONG  Rid;
    WCHAR  Machine[14];
    WCHAR  Comment[24];
} SAMP_TEMP_MACHINE_STRINGS, *PSAMP_TEMP_MACHINE_STRINGS;


#define SAMP_TEMP_MACHINE_COUNT (40)
#define SAMP_TEMP_MACHINE1      (16)
#define SAMP_TEMP_MACHINE2      (24)


SAMP_TEMP_USER_STRINGS DummyUsers[SAMP_TEMP_USER_COUNT] = {

      {1031, L"Abba"          , L"Abb Abb"              , L"Admin Comment Field"},
      {1021, L"Acea"          , L"Ace Abb"              , L"Value Admin Comment"},
      {1526, L"beverlyE"      , L"Beverly Eng"          , L"Field Value Admin"},
      {1743, L"BorisB"        , L"Boris Borsch"         , L"Comment Field Value"},
      {1734, L"BruceK"        , L"Bruce Kane"           , L"Comment Field Value"},
      {1289, L"BullS"         , L"Bull Shiite"          , L"Comment Field Value"},
      {1830, L"CallieW"       , L"Callie Wilson"        , L"Comment Field Value"},
      {1628, L"CarrieT"       , L"Carrie Tibbits"       , L"Comment Field Value"},
      {1943, L"ChrisR"        , L"Christopher Robin"    , L"40 acre woods"},
      {1538, L"CorneliaG"     , L"Cornelia Gutierrez"   , L"Comment Field Value"},
      {1563, L"CoryA"         , L"Cory Ander"           , L"Comment Field Value"},
      {1758, L"DanielJ"       , L"Daniel John"          , L"Comment Field Value"},
      {1249, L"Dory"          , L"Dory"                 , L"Comment Field Value"},
      {1957, L"EltonJ"        , L"Elton John"           , L"Comment Field Value"},
      {1555, L"HarrisonF"     , L"Harrison Ford"        , L"Comment Field Value"},
      {1795, L"HarryB"        , L"Harry Belafonte"      , L"Comment Field Value"},
      {1458, L"IngridB"       , L"Ingrid Bergman"       , L"Comment Field Value"},
      {1672, L"Ingris"        , L"Ingris"               , L"Comment Field Value"},
      {1571, L"JenniferB"     , L"Jennifer Black"       , L"Comment Field Value"},
      {1986, L"JoyceG"        , L"Joyce Gerace"         , L"Comment Field Value"},
      {1267, L"KristinM"      , L"Kristin McKay"        , L"Comment Field Value"},
      {1321, L"LeahD"         , L"Leah Dootson"         , L"The Lovely Miss D"},
      {2021, L"LisaP"         , L"Lisa Perazzoli"       , L"Wild On Skis"},
      {1212, L"MeganB"        , L"Megan Bombeck"        , L"M1"},
      {2758, L"MelisaB"       , L"Melisa Bombeck"       , L"M3"},
      {2789, L"MichaelB"      , L"Michael Bombeck"      , L"M2"},
      {2682, L"PanelopiP"     , L"Panelopi Pitstop"     , L"Comment Field Value"},
      {2438, L"Prudence"      , L"Prudence Peackock"    , L"Comment Field Value"},
      {2648, L"QwertyU"       , L"Qwerty Uiop"          , L"Comment Field Value"},
      {2681, L"ReaddyE"       , L"Readdy Eddy"          , L""},
      {2456, L"SovietA"       , L"Soviet Union - NOT"   , L"Soviet Union Aint"},
      {1753, L"TAAAA"         , L"TTT   AAAA"           , L"Comment Field Value"},
      {1357, L"TBBB"          , L"Ingris"               , L"Comment Field Value"},
      {1951, L"TCCCCC"        , L"Jennifer Black"       , L"Comment Field Value"},
      {1159, L"TCAAAAAA"      , L"Joyce Gerace"         , L"Comment Field Value"},
      {1654, L"Ulga"          , L"Ulga Bulga"           , L"Comment Field Value"},
      {1456, L"UnixY"         , L"Unix Yuck"            , L"Unix - why ask why?"},
      {1852, L"Vera"          , L"Vera Pensicola"       , L""},
      {1258, L"WinP"          , L"Winnie The Pooh"      , L"Comment Field Value"},
      {2821, L"Zoro"          , L"Zoro"                 , L"The sign of the Z"}
};





SAMP_TEMP_MACHINE_STRINGS DummyMachines[SAMP_TEMP_MACHINE_COUNT] = {

      {1031, L"WKS$abba"          , L"Admin Comment Field"},
      {1021, L"WKS$Acea"          , L"Value Admin Comment"},
      {1526, L"WKS$beverlyE"      , L"Field Value Admin"},
      {1743, L"WKS$BorisB"        , L"Comment Field Value"},
      {1734, L"WKS$BruceK"        , L"Comment Field Value"},
      {1289, L"WKS$BullS"         , L"Comment Field Value"},
      {1830, L"WKS$CallieW"       , L"Comment Field Value"},
      {1628, L"WKS$CarrieT"       , L"Comment Field Value"},
      {1943, L"WKS$ChrisR"        , L"40 acre woods Server"},
      {1538, L"WKS$CorneliaG"     , L"Comment Field Value"},
      {1563, L"WKS$CoryA"         , L"Comment Field Value"},
      {1758, L"WKS$DanielJ"       , L"Comment Field Value"},
      {1249, L"WKS$Dory"          , L"Comment Field Value"},
      {1957, L"WKS$EltonJ"        , L"Comment Field Value"},
      {1555, L"WKS$HarrisonF"     , L"Comment Field Value"},
      {1795, L"WKS$HarryB"        , L"Comment Field Value"},
      {1458, L"WKS$IngridB"       , L"Comment Field Value"},
      {1672, L"WKS$Ingris"        , L"Comment Field Value"},
      {1571, L"WKS$JenniferB"     , L"Comment Field Value"},
      {1986, L"WKS$JoyceG"        , L"Comment Field Value"},
      {1267, L"WKS$KristinM"      , L"Comment Field Value"},
      {1321, L"WKS$LeahD"         , L"The Lovely Miss D's"},
      {2021, L"WKS$LisaP"         , L"Wild On Skis Server"},
      {1212, L"WKS$MeganB"        , L"M1 Machine"},
      {2758, L"WKS$MelisaB"       , L"M3 Machine"},
      {2789, L"WKS$MichaelB"      , L"M2 Machine"},
      {2682, L"WKS$PanelopiP"     , L"Comment Field Value"},
      {2438, L"WKS$Prudence"      , L"Comment Field Value"},
      {2648, L"WKS$QwertyU"       , L"Comment Field Value"},
      {2681, L"WKS$ReaddyE"       , L"Ready Eddy Computer"},
      {2456, L"WKS$SovietA"       , L"Soviet Union Aint"},
      {1753, L"WKS$TAAAA"         , L"Comment Field Value"},
      {1357, L"WKS$TBBB"          , L"Comment Field Value"},
      {1951, L"WKS$TCCCCC"        , L"Comment Field Value"},
      {1159, L"WKS$TCAAAAAA"      , L"Comment Field Value"},
      {1654, L"WKS$Ulga"          , L"Comment Field Value"},
      {1456, L"WKS$UnixY"         , L"Unix - why ask why?"},
      {1852, L"WKS$Vera"          , L"Vera tissue"},
      {1258, L"WKS$WinP"          , L"Comment Field Value"},
      {2821, L"WKS$Zoro"          , L"The sign of the Z"}
};




VOID
SampBuildDummyAccounts(
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    ULONG      Index,
      OUT   PULONG     TotalAvailable,
      OUT   PULONG     TotalReturned,
      OUT   PULONG     ReturnedEntryCount,
      OUT   PVOID      *SortedBuffer
    );



VOID
SampBuildDummyAccounts(
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    ULONG      Index,
      OUT   PULONG     TotalAvailable,
      OUT   PULONG     TotalReturned,
      OUT   PULONG     ReturnedEntryCount,
      OUT   PVOID      *SortedBuffer
    )

{
    ULONG AccountCount, Account1, Account2;
    ULONG i, j, BeginIndex, EndIndex;
    ULONG ReturnStructSize, ArrayLength, StringLengths;
    PCHAR NextByte;
    UNICODE_STRING Us;



    ASSERT (SAMP_TEMP_USER1 != 0);
    ASSERT (SAMP_TEMP_USER2 != 0);
    ASSERT (SAMP_TEMP_MACHINE1 != 0);
    ASSERT (SAMP_TEMP_MACHINE2 != 0);

    if (DisplayInformation == DomainDisplayUser) {

        ReturnStructSize = sizeof(DOMAIN_DISPLAY_USER);
        Account1 = SAMP_TEMP_USER1;
        Account2 = SAMP_TEMP_USER2;
        AccountCount = SAMP_TEMP_USER_COUNT;

    } else {

        ReturnStructSize = sizeof(DOMAIN_DISPLAY_MACHINE);
        Account1 = SAMP_TEMP_MACHINE1;
        Account2 = SAMP_TEMP_MACHINE2;
        AccountCount = SAMP_TEMP_MACHINE_COUNT;

    }



    //
    // Build up a number of dummy accounts in a single buffer.
    //


    if (Index < Account1) {

        //
        // Give the first group of accounts
        //

        ArrayLength  = ReturnStructSize * Account1;
        BeginIndex = 0;
        EndIndex   = Account1;


    } else {

        //
        // Give the second group of accounts
        //

        ArrayLength  = ReturnStructSize * Account2;
        BeginIndex = Account1;
        EndIndex   = AccountCount;

    }



    //
    // Figure out how large a buffer is needed.
    //

    StringLengths = 0;
    for (i=BeginIndex; i<EndIndex; i++) {

        if (DisplayInformation == DomainDisplayUser) {

            RtlInitUnicodeString( &Us, DummyUsers[i].LogonName);
            StringLengths += Us.Length;
            RtlInitUnicodeString( &Us, DummyUsers[i].FullName);
            StringLengths += Us.Length;
            RtlInitUnicodeString( &Us, DummyUsers[i].AdminComment);
            StringLengths += Us.Length;

        } else {

            RtlInitUnicodeString( &Us, DummyMachines[i].Machine);
            StringLengths += Us.Length;
            RtlInitUnicodeString( &Us, DummyMachines[i].Comment);
            StringLengths += Us.Length;

        }

    }
    (*SortedBuffer) = MIDL_user_allocate( ArrayLength + StringLengths );
    ASSERT(SortedBuffer != NULL);


    //
    // First free byte in the return buffer
    //

    NextByte = (PCHAR)((ULONG)(*SortedBuffer) + (ULONG)ArrayLength);


    //
    // Now copy the structures

    if (DisplayInformation == DomainDisplayUser) {

        PDOMAIN_DISPLAY_USER r;
        r = (PDOMAIN_DISPLAY_USER)(*SortedBuffer);

        j=0;
        for (i=BeginIndex; i<EndIndex; i++) {

            r[j].AccountControl = USER_NORMAL_ACCOUNT;
            r[j].Index = i;
            r[j].Rid = DummyUsers[i].Rid;


            //
            // copy the logon name
            //

            RtlInitUnicodeString( &Us, DummyUsers[i].LogonName);
            r[j].LogonName.MaximumLength = Us.Length;
            r[j].LogonName.Length = Us.Length;
            r[j].LogonName.Buffer = (PWSTR)NextByte;
            RtlMoveMemory(NextByte, Us.Buffer, r[j].LogonName.Length);
            NextByte += r[j].LogonName.Length;

            //
            // copy the full name
            //

            RtlInitUnicodeString( &Us, DummyUsers[i].FullName);
            r[j].FullName.MaximumLength = Us.Length;
            r[j].FullName.Length = Us.Length;
            r[j].FullName.Buffer = (PWSTR)NextByte;
            RtlMoveMemory(NextByte, Us.Buffer, r[j].FullName.Length);
            NextByte += r[j].FullName.Length;

            //
            // copy the admin comment
            //

            RtlInitUnicodeString( &Us, DummyUsers[i].AdminComment);
            r[j].AdminComment.MaximumLength = Us.Length;
            r[j].AdminComment.Length = Us.Length;
            r[j].AdminComment.Buffer = (PWSTR)NextByte;
            RtlMoveMemory(NextByte, Us.Buffer, r[j].AdminComment.Length);
            NextByte += r[j].AdminComment.Length;

            j++;

        }

    } else {

        PDOMAIN_DISPLAY_MACHINE r;
        r = (PDOMAIN_DISPLAY_MACHINE)(*SortedBuffer);

        j=0;
        for (i=BeginIndex; i<EndIndex; i++) {


            r[j].AccountControl = USER_WORKSTATION_TRUST_ACCOUNT;
            r[j].Index = i;
            r[j].Rid = DummyMachines[i].Rid;


            //
            // copy the logon name
            //

            RtlInitUnicodeString( &Us, DummyMachines[i].Machine);
            r[j].Machine.MaximumLength = Us.Length;
            r[j].Machine.Length = Us.Length;
            r[j].Machine.Buffer = (PWSTR)NextByte;
            RtlMoveMemory(NextByte, Us.Buffer, r[j].Machine.Length);
            NextByte += r[j].Machine.Length;


            //
            // copy the admin comment
            //

            RtlInitUnicodeString( &Us, DummyMachines[i].Comment);
            r[j].Comment.MaximumLength = Us.Length;
            r[j].Comment.Length = Us.Length;
            r[j].Comment.Buffer = (PWSTR)NextByte;
            RtlMoveMemory(NextByte, Us.Buffer, r[j].Comment.Length);
            NextByte += r[j].Comment.Length;

            j++;

        }


    }

    (*TotalAvailable) = 6*1024;        // A lie, but just a little lie.
    (*TotalReturned) = ArrayLength + StringLengths;
    (*ReturnedEntryCount) = EndIndex - BeginIndex;


    return;


}



NTSTATUS
SamQueryDisplayInformation (
      IN    SAM_HANDLE DomainHandle,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    ULONG      Index,
      IN    ULONG      PreferredMaximumLength,
      OUT   PULONG     TotalAvailable,
      OUT   PULONG     TotalReturned,
      OUT   PULONG     ReturnedEntryCount,
      OUT   PVOID      *SortedBuffer
      )

/*++

Routine Description:

    This routine provides fast return of information commonly
    needed to be displayed in user interfaces.

    NT User Interface has a requirement for quick enumeration of SAM
    accounts for display in list boxes.  (Replication has similar but
    broader requirements.)

    The netui listboxes all contain similar information.  That is:

      o  AccountControl, the bits that identify the account type,
         eg, HOME, REMOTE, SERVER, WORKSTATION, etc.

      o  Logon name (machine name for computers)

      o  Full name (not used for computers)

      o  Comment (admin comment for users)

    SAM maintains this data locally in two sorted indexed cached
    lists identified by infolevels.

      o DomainDisplayUser:       HOME and REMOTE user accounts only

      o  DomainDisplayMachine:   SERVER and WORKSTATION accounts only

    Note that trust accounts, groups, and aliases are not in either of
    these lists.

Parameters:

    DomainHandle - A handle to an open domain for DOMAIN_LIST_ACCOUNTS.

    DisplayInformation - Indicates which information is to be enumerated.

    Index - The index of the first entry to be retrieved.

    PreferedMaximumLength - A recommended upper limit to the number of
        bytes to be returned.  The returned information is allocated by
        this routine.

    TotalAvailable - Total number of bytes availabe in the specified info
        class.

    TotalReturned - Number of bytes actually returned for this call.  Zero
        indicates there are no entries with an index as large as that
        specified.

    ReturnedEntryCount - Number of entries returned by this call.  Zero
        indicates there are no entries with an index as large as that
        specified.


    SortedBuffer - Receives a pointer to a buffer containing a sorted
        list of the requested information.  This buffer is allocated
        by this routine and contains the following structure:


            DomainDisplayMachine --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_USER.  This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_USER structures.

            DomainDisplayMachine --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_MACHINE.  This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_MACHINE structures.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_ACCESS_DENIED - The specified handle was not opened for
        the necessary access.

    STATUS_INVALID_HANDLE - The specified handle is not that of an
        opened Domain object.

    STATUS_INVALID_INFO_CLASS - The requested class of information
        is not legitimate for this service.





--*/
{



//    if ((DisplayInformation != DomainDisplayUser) &&
//        (DisplayInformation != DomainDisplayMachine) ) {
//        return( STATUS_INVALID_INFO_CLASS );
//
//    }



    SampBuildDummyAccounts( DisplayInformation,
                            Index,
                            TotalAvailable,
                            TotalReturned,
                            ReturnedEntryCount,
                            SortedBuffer);

    return(STATUS_SUCCESS);

    DBG_UNREFERENCED_PARAMETER(DomainHandle);
    DBG_UNREFERENCED_PARAMETER(PreferredMaximumLength);

}


NTSTATUS
SamGetDisplayEnumerationIndex (
      IN    SAM_HANDLE        DomainHandle,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    PUNICODE_STRING   Prefix,
      OUT   PULONG            Index
      )

/*++

Routine Description:

    This routine returns the index of the entry which alphabetically
    immediatly preceeds a specified prefix.  If no such entry exists,
    then zero is returned as the index.

Parameters:

    DomainHandle - A handle to an open domain for DOMAIN_LIST_ACCOUNTS.

    DisplayInformation - Indicates which sorted information class is
        to be searched.

    Prefix - The prefix to compare.

    Index - Receives the index of the entry of the information class
        with a LogonName (or MachineName) which immediatly preceeds the
        provided prefix string.  If there are no elements which preceed
        the prefix, then zero is returned.


Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_ACCESS_DENIED - The specified handle was not opened for
        the necessary access.

    STATUS_INVALID_HANDLE - The specified handle is not that of an
        opened Domain object.


--*/
{

    (*Index) = 0;

    return(STATUS_SUCCESS);


    DBG_UNREFERENCED_PARAMETER(DomainHandle);
    DBG_UNREFERENCED_PARAMETER(DisplayInformation);
    DBG_UNREFERENCED_PARAMETER(Prefix);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\client\tmachine.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tmachine.c

Abstract:

    This module tests the machine account creation facilities
    of SAM.

Author:

    Jim Kelly    (JimK)  7-Feb-1994

Environment:

    User Mode - Win32

Revision History:


--*/







///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <nt.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <ntlsa.h>
#include <ntrpcp.h>     // prototypes for MIDL user functions
#include <seopaque.h>
#include <string.h>



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Macros                                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


#ifndef SHIFT
#define SHIFT(c,v)      {c--; v++;}
#endif //SHIFT



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
TSampGetLsaDomainInfo(
    IN  PUNICODE_STRING             ServerName,
    OUT PPOLICY_ACCOUNT_DOMAIN_INFO *PolicyAccountDomainInfo
    )

/*++

Routine Description:

    This routine retrieves ACCOUNT domain information from the LSA
    policy database.


Arguments:

    ServerName - name of machine to get account domain information
        from.

    PolicyAccountDomainInfo - Receives a pointer to a
        POLICY_ACCOUNT_DOMAIN_INFO structure containing the account
        domain info.


Return Value:

    STATUS_SUCCESS - Succeeded.

    Other status values that may be returned from:

             LsaOpenPolicy()
             LsaQueryInformationPolicy()
--*/

{
    NTSTATUS
        NtStatus,
        IgnoreStatus;

    LSA_HANDLE
        PolicyHandle;

    OBJECT_ATTRIBUTES
        PolicyObjectAttributes;

    //
    // Open the policy database
    //

    InitializeObjectAttributes( &PolicyObjectAttributes,
                                  NULL,             // Name
                                  0,                // Attributes
                                  NULL,             // Root
                                  NULL );           // Security Descriptor

    NtStatus = LsaOpenPolicy( ServerName,
                              &PolicyObjectAttributes,
                              POLICY_VIEW_LOCAL_INFORMATION,
                              &PolicyHandle );

    if ( NT_SUCCESS(NtStatus) ) {

        //
        // Query the account domain information
        //

        NtStatus = LsaQueryInformationPolicy( PolicyHandle,
                                              PolicyAccountDomainInformation,
                                              (PVOID *)PolicyAccountDomainInfo );


        IgnoreStatus = LsaClose( PolicyHandle );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    return(NtStatus);
}


NTSTATUS
TSampConnectToServer(
    IN  PUNICODE_STRING         ServerName,
    IN  ACCESS_MASK             DomainAccess,
    OUT PHANDLE                 ServerHandle,
    OUT PHANDLE                 DomainHandle,
    OUT PSID                    *DomainSid
    )

/*++

Routine Description:

    Open a handle to the SAM server on the specified server
    and then open the account domain on that same server.

Arguments:

    ServerName - Name of server to connect to.

    DomainAccess - accesses needed to the account domain.

    ServerHandle - Receives a handle to the SAM server on the specified
        system.

    DomainHandle - Receives a handle to the account domain.

    DomainSid - Receives a pointer to the SID of the account domain.


Return Value:




--*/
{
    NTSTATUS
        NtStatus;

    OBJECT_ATTRIBUTES
        ObjectAttributes;

    PPOLICY_ACCOUNT_DOMAIN_INFO
        AccountDomainInfo;

    //
    // get account domain info
    //

    NtStatus = TSampGetLsaDomainInfo( ServerName,
                                      &AccountDomainInfo);

    if (!NT_SUCCESS(NtStatus)) {
        printf("SAM TEST: Failed to get lsa domain info...\n"
               "          Completion status is 0x%lx\n", NtStatus);
        return(NtStatus);
    }
    printf("SAM TEST: Target domain is %wZ\n", &AccountDomainInfo->DomainName);

    (*DomainSid) = AccountDomainInfo->DomainSid;

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL );


    NtStatus = SamConnect(
                  ServerName,
                  ServerHandle,
                  SAM_SERVER_READ | SAM_SERVER_EXECUTE,
                  &ObjectAttributes
                  );


    if (!NT_SUCCESS(NtStatus)) {
        printf("SAM TEST: Failed to connect...\n"
               "          Completion status is 0x%lx\n", NtStatus);
        return(NtStatus);
    }


    NtStatus = SamOpenDomain(
                   (*ServerHandle),
                   DomainAccess,
                   *DomainSid,
                   DomainHandle
                   );

    if (!NT_SUCCESS(NtStatus)) {
        printf("Failed account domain open\n"
               "        Completion status is 0x%lx\n", NtStatus);
        return(NtStatus);
    }
    
    return(STATUS_SUCCESS);


}


BOOLEAN
TSampEnableMachinePrivilege( VOID )

/*++

Routine Description:

    This function enabled the SeMachineAccountPrivilege privilege.

Arguments:

    None.

Return Value:

    TRUE  if privilege successfully enabled.
    FALSE if not successfully enabled.

--*/
{

    NTSTATUS Status;
    HANDLE Token;
    LUID SecurityPrivilege;
    PTOKEN_PRIVILEGES NewState;
    ULONG ReturnLength;


    //
    // Open our own token
    //

    Status = NtOpenProcessToken(
                 NtCurrentProcess(),
                 TOKEN_ADJUST_PRIVILEGES,
                 &Token
                 );
    if (!NT_SUCCESS(Status)) {
        printf("SAM TEST: Can't open process token to enable Privilege.\n"
               "          Completion status of NtOpenProcessToken() is: 0x%lx\n", Status);
        return(FALSE);
    }


    //
    // Initialize the adjustment structure
    //

    SecurityPrivilege =
        RtlConvertLongToLargeInteger(SE_MACHINE_ACCOUNT_PRIVILEGE);

    ASSERT( (sizeof(TOKEN_PRIVILEGES) + sizeof(LUID_AND_ATTRIBUTES)) < 100);
    NewState = RtlAllocateHeap( RtlProcessHeap(), 0, 100 );

    NewState->PrivilegeCount = 1;
    NewState->Privileges[0].Luid = SecurityPrivilege;
    NewState->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;


    //
    // Set the state of the privilege to ENABLED.
    //

    Status = NtAdjustPrivilegesToken(
                 Token,                            // TokenHandle
                 FALSE,                            // DisableAllPrivileges
                 NewState,                         // NewState
                 0,                                // BufferLength
                 NULL,                             // PreviousState (OPTIONAL)
                 &ReturnLength                     // ReturnLength
                 );
    // don't use NT_SUCCESS here because STATUS_NOT_ALL_ASSIGNED is a success status
    if (Status != STATUS_SUCCESS) {
        return(FALSE);
    }


    //
    // Clean up some stuff before returning
    //

    RtlFreeHeap( RtlProcessHeap(), 0, NewState );
    Status = NtClose( Token );
    ASSERT(NT_SUCCESS(Status));


    return TRUE;

}


NTSTATUS
TSampCreateMachine(
    IN  SAM_HANDLE              DomainHandle,
    IN  PUNICODE_STRING         AccountName
    )

/*++

Routine Description:

    This routine attempts to create a machine account.

    One of two cases may be tested:

        1) DomainHandle is open for DOMAIN_CREATE_USER,
    or
        2) DomainHandle is open for DOMAIN_LOOKUP and
           the SeMachineAccountPrivilege privilege is
           enabled.

    It is the caller's responsibility to establish the
    correct case criteria before calling.

Arguments:

    DomainHandle - handle to domain to create account in.

    AccountName - Name of the account to create.


Return Value:

--*/

{
    NTSTATUS
        NtStatus,
        IgnoreStatus;

    SAM_HANDLE
        UserHandle;

    ACCESS_MASK
        GrantedAccess;

    ULONG
        Rid;

    NtStatus = SamCreateUser2InDomain( DomainHandle,
                                       AccountName,
                                       USER_WORKSTATION_TRUST_ACCOUNT,
                                       MAXIMUM_ALLOWED,
                                       &UserHandle,
                                       &GrantedAccess,
                                       &Rid);

    if (NT_SUCCESS(NtStatus)) {
        IgnoreStatus = SamCloseHandle( UserHandle );
        ASSERT(NT_SUCCESS(IgnoreStatus));
        printf("SAM TEST: Machine account created.\n"
               "              GrantedAccess: 0x%lx\n"
               "              Rid:           %d (0x%lx)\n",
               GrantedAccess, Rid, Rid);
    } else {
        printf("SAM TEST: Machine account creation failed.\n"
               "              Status: 0x%lx\n", NtStatus);
    }


    return(NtStatus);


}


NTSTATUS
TSampSetPasswordMachine(
    IN  SAM_HANDLE              DomainHandle,
    IN  PUNICODE_STRING         AccountName,
    IN  PUNICODE_STRING         Password
    )

/*++

Routine Description:

    This routine attempts to set the password of a machine account.


Arguments:

    DomainHandle - handle to domain account is in.

    AccountName - Name of the account to set password.

    Password - New password.

Return Value:

--*/

{
    NTSTATUS
        NtStatus;

    SAM_HANDLE
        UserHandle;

    PULONG
        RelativeIds;

    PSID_NAME_USE
        Use;

    USER_SET_PASSWORD_INFORMATION
        PasswordInfo;


    PasswordInfo.Password = (*Password);
    PasswordInfo.PasswordExpired = FALSE;

    NtStatus = SamLookupNamesInDomain( DomainHandle,
                                       1,
                                       AccountName,
                                       &RelativeIds,
                                       &Use);
    if (!NT_SUCCESS(NtStatus)) {
        printf("SAM TEST: Couldn't find account to set password.\n"
               "              Lookup status: 0x%lx\n", NtStatus);
        return(NtStatus);
    }


    NtStatus = SamOpenUser( DomainHandle,
                            USER_FORCE_PASSWORD_CHANGE,
                            RelativeIds[0],
                            &UserHandle);
                            
    if (!NT_SUCCESS(NtStatus)) {
        printf("SAM TEST: Couldn't open user account for FORCE_PASSWORD_CHANGE.\n"
               "              Lookup status: 0x%lx\n", NtStatus);
        return(NtStatus);
    }

    NtStatus = SamSetInformationUser( UserHandle,
                                      UserSetPasswordInformation,
                                      &PasswordInfo
                                      );
    if (!NT_SUCCESS(NtStatus)) {
        printf("SAM TEST: Couldn't set password on user account.\n"
               "              Set Info status: 0x%lx\n", NtStatus);
        return(NtStatus);
    }


    return(STATUS_SUCCESS);


}


NTSTATUS
TSampDeleteMachine(
    IN  SAM_HANDLE              DomainHandle,
    IN  PUNICODE_STRING         AccountName
    )

/*++

Routine Description:

    This routine attempts to delete a machine account.


Arguments:

    DomainHandle - handle to domain to delete account from.

    AccountName - Name of the account to delete.


Return Value:

--*/

{
    NTSTATUS
        NtStatus;

    SAM_HANDLE
        UserHandle;

    PULONG
        RelativeIds;

    PSID_NAME_USE
        Use;

    NtStatus = SamLookupNamesInDomain( DomainHandle,
                                       1,
                                       AccountName,
                                       &RelativeIds,
                                       &Use);
    if (!NT_SUCCESS(NtStatus)) {
        printf("SAM TEST: Couldn't find account to delete.\n"
               "              Lookup status: 0x%lx\n", NtStatus);
        return(NtStatus);
    }


    NtStatus = SamOpenUser( DomainHandle,
                            DELETE,
                            RelativeIds[0],
                            &UserHandle);
                            
    if (!NT_SUCCESS(NtStatus)) {
        printf("SAM TEST: Couldn't open user account for delete.\n"
               "              Open status: 0x%lx\n", NtStatus);
        return(NtStatus);
    }

    NtStatus = SamDeleteUser( UserHandle );
    if (!NT_SUCCESS(NtStatus)) {
        printf("SAM TEST: Couldn't delete user account.\n"
               "              DeleteUser status: 0x%lx\n", NtStatus);
        return(NtStatus);
    }


    return(STATUS_SUCCESS);


}


VOID
TSampPrintYesOrNo(
    IN BOOLEAN b
    )
{
    if (b) {
        printf("Yes\n");
    } else {
        printf("No\n");
    }
}



VOID
TSampUsage( VOID )
{

    printf("\n\n Command format:\n");
    printf("          tmachine [/c] [/p] [/d] <account-name> <machine> [<password>]\n");
    printf("\n");
    printf(" Switches\n");
    printf("          /c - create account\n");
    printf("          /p - set password on account\n");
    printf("          /d - delete account\n");
    printf("\n");
    printf(" if multiple switches are specified, they are attempted in\n");
    printf(" the order listed above.  An error in any attempt will prevent\n");
    printf(" any further attempts.\n");
    printf("\n");
    return;
}


VOID
main (c,v)
int c;
char **v;

/*++

Routine Description:

    This is the main entry routine for this test.

Arguments:

    Argv[1] - account name to create or delete

    Argv[2] - domain controller machine name

    Argv[3] - 'D' to delete account, otherwise account is created.



Return Value:




--*/
{
    NTSTATUS
        NtStatus,
        IgnoreStatus;

    UNICODE_STRING
        AccountName,
        ControllerName,
        Password;

    WCHAR
        AccountNameBuffer[80],
        ControllerNameBuffer[80],
        PasswordBuffer[80];

    ANSI_STRING
        AnsiString;

    SAM_HANDLE
        ServerHandle,
        ServerHandle2,
        DomainHandle,
        DomainHandle2;

    PSID
        DomainSid;

    BOOLEAN
        Create = FALSE,
        SetPassword = FALSE,
        Delete = FALSE;

    ULONG
        ArgNum = 0;

    PCHAR
        p;

    CHAR
        ch;

    AccountName.Length = 0;
    ControllerName.Length = 0;
    Password.Length = 0;



    //
    // Command format:
    //
    //          tmachine [/c] [/p] [/d] <account-name> <machine> [<password>]
    //
    // Switches
    //          /c - create account
    //          /p - set password on account
    //          /d - delete account
    //
    // if multiple switches are specified, they are attempted in
    // the order listed above.  An error in any attempt will prevent
    // any further attempts.
    //

    SHIFT (c,v);
    while ((c > 0) && ((ch = *v[0]))) {
        p = *v;
        if (ch == '/') {
            while (*++p != '\0') {
                if ((*p == 'c') || (*p == 'C')) {
                    Create = TRUE;
//                    printf("Create\n");
                } else if ((*p == 'p') || (*p == 'P')) {
                    SetPassword = TRUE;
//                    printf("SetPassword\n");
                } else if ((*p == 'd') || (*p == 'D')) {
                    Delete = TRUE;
//                    printf("Delete\n");
                } else {
                    TSampUsage();
                    return;
                }
            }
        } else {

            switch (ArgNum) {
                case 0:

                    //
                    // collecting account name
                    //

                    AccountName.Buffer = AccountNameBuffer;
                    AccountName.MaximumLength = sizeof(AccountNameBuffer);
                    RtlInitAnsiString(&AnsiString, (*v));
                    RtlAnsiStringToUnicodeString(&AccountName, &AnsiString, FALSE);

//                    printf("account: %wZ\n", &AccountName);
                    break;

                case 1:

                    //
                    // collecting machine name
                    //

                    ControllerName.Buffer = ControllerNameBuffer;
                    ControllerName.MaximumLength = sizeof(ControllerNameBuffer);
                    RtlInitAnsiString(&AnsiString, (*v));
                    RtlAnsiStringToUnicodeString(&ControllerName, &AnsiString, FALSE);

//                    printf("machine: %wZ\n", &ControllerName);
                    break;


                case 2:

                    //
                    // collecting password name
                    //

                    Password.Buffer = PasswordBuffer;
                    Password.MaximumLength = sizeof(PasswordBuffer);
                    RtlInitAnsiString(&AnsiString, (*v));
                    RtlAnsiStringToUnicodeString(&Password, &AnsiString, FALSE);

//                    printf("password: %wZ\n", &Password);
                    break;

                default:

                    //
                    // collecting garbage.
                    //

                    break;
            }

            ArgNum++;
        }
    SHIFT(c,v);
    }



    printf("parameters:\n");
    printf("    Create Account:  "); TSampPrintYesOrNo( Create );
    printf("    Set Password  :  "); TSampPrintYesOrNo( SetPassword );
    printf("    Delete Account:  "); TSampPrintYesOrNo( Delete );
    printf("    Account       :  *%wZ*\n", &AccountName);
    printf("    Machine       :  *%wZ*\n", &ControllerName);
    printf("    Password      :  *%wZ*\n", &Password);


    //
    // Make sure we don't have conflicting parameters
    //
    // Rules:
    //
    //      1) account name is always required.
    //      2) password and machine are required if /P was specified.
    //      3) machine is optional if /P not specified.
    //
    //

    if ( (AccountName.Length == 0)                          ||
         ( SetPassword && (ControllerName.Length == 0) )    ||
         ( SetPassword && (Password.Length == 0) ) ) {
        TSampUsage();
        return;
    }


    //
    // Open the server and the account domain
    //

    NtStatus = TSampConnectToServer(&ControllerName,
                                    DOMAIN_LOOKUP | DOMAIN_READ_PASSWORD_PARAMETERS,
                                    &ServerHandle,
                                    &DomainHandle,
                                    &DomainSid);


    if (Create) {
        //
        // try to create the machine account with privilege.
        //


        printf("SAM TEST: Creating machine account with privilege.\n");
        TSampEnableMachinePrivilege();
        NtStatus = TSampCreateMachine( DomainHandle, &AccountName );
        if (NT_SUCCESS(NtStatus)) {
            printf("          Status: successful\n");
        } else {

            if (NtStatus == STATUS_ACCESS_DENIED) {
                //
                // We didn't have the privilege, and didn't have
                // the domain open so that it would work without
                // the privilege.
                //

                printf("      Couldn't create account with privilege (0x%lx)\n"
                       "      Attempting normal creation (without privilege)\n"
                       , NtStatus);
                NtStatus = TSampConnectToServer(&ControllerName,
                                                DOMAIN_LOOKUP |
                                                DOMAIN_READ_PASSWORD_PARAMETERS |
                                                DOMAIN_CREATE_USER,
                                                &ServerHandle2,
                                                &DomainHandle2,
                                                &DomainSid);
                if (!NT_SUCCESS(NtStatus)) {
                    printf("      Can't open domain for CREATE_USER access (0x%lx)\n", NtStatus);
                } else {
                    NtStatus = TSampCreateMachine( DomainHandle2,
                                                   &AccountName );
                    if (NT_SUCCESS(NtStatus)) {
                        printf("          Status: successful\n");
                    } else {
                        printf("          Failed: 0x%lx\n", NtStatus);
                    }

                    IgnoreStatus = SamCloseHandle( DomainHandle2 );

                }
            }
            if (!NT_SUCCESS(NtStatus)) {
                printf("          Status: 0x%lx", NtStatus);
                return;
            }
        }
    }


    if (SetPassword) {

        //
        // Try to set the password on the account
        //

        printf("SAM TEST: Setting password of account ...\n");
        NtStatus = TSampSetPasswordMachine( DomainHandle, &AccountName, &Password );
        if (NT_SUCCESS(NtStatus)) {
            printf("          Status: successful\n");
        } else {
            printf("          Status: 0x%lx", NtStatus);
            return;
        }
    }


    if (Delete) {

        printf("SAM TEST: Deleting account ...\n");
        NtStatus = TSampDeleteMachine( DomainHandle, &AccountName );
        if (NT_SUCCESS(NtStatus)) {
            printf("          Status: successful\n");
        } else {
            printf("          Status: 0x%lx", NtStatus);
            return;
        }
    }


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\client\tmultipl.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tmultipl.c

Abstract:

    This module tests the addition and removal of multiple
    alias members.

Author:

    Jim Kelly    (JimK)  11-Oct-1994

Environment:

    User Mode - Win32

Revision History:


--*/







///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <nt.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <ntlsa.h>
#include <ntrpcp.h>     // prototypes for MIDL user functions
#include <seopaque.h>
#include <string.h>



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Macros and defines                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define TSAMP_MEMBER_COUNT          35

#ifndef SHIFT
#define SHIFT(c,v)      {c--; v++;}
#endif //SHIFT



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


VOID
TSampUsage( VOID )
{

    printf("\n\n Test multiple member operations on alias\n");
    printf("\n\n Command format:\n");
    printf("          tmultipl [/a] [/r]\n");
    printf("\n");
    printf(" Switches\n");
    printf("          /a - causes members to be added to an alias\n");
    printf("          /r - causes members to be removed from alias\n");
    printf("\n");
    printf(" If multiple switches are specified, first adding will be attempted\n");
    printf(" and then removal.\n");
    printf(" Defaults to Account Operator alias.\n");
    printf("\n");
    return;
}


VOID
TSampParseCommandLine(
    IN  int c,
    IN  char **v,
    OUT PBOOLEAN    Add,
    OUT PBOOLEAN    Remove
    )

{
    PCHAR
        p;

    CHAR
        ch;


    //
    // Command format:
    //
    //          tmultipl [/a] [/r]
    //
    // Switches
    //          /a - causes members to be added to an alias\n");
    //          /r - causes members to be removed from alias\n");
    //
    //      if multiple switches are specified, first adding will be
    //      attempted and then removal.
    //

    (*Add) = FALSE;
    (*Remove) = FALSE;

    SHIFT (c,v);
    while ((c > 0) && ((ch = *v[0]))) {
        p = *v;
        if (ch == '/') {
            while (*++p != '\0') {
                if ((*p == 'a') || (*p == 'A')) {
                    (*Add) = TRUE;
                    printf("Add\n");
                } else if ((*p == 'r') || (*p == 'R')) {
                    (*Remove) = TRUE;
                    printf("Remove\n");
                } else {
                    TSampUsage();
                    return;
                }
            }
        }
        SHIFT(c,v);
    }
}

NTSTATUS
TSampGetLsaDomainInfo(
    IN  PUNICODE_STRING             ServerName,
    OUT PPOLICY_ACCOUNT_DOMAIN_INFO *PolicyAccountDomainInfo
    )

/*++

Routine Description:

    This routine retrieves ACCOUNT domain information from the LSA
    policy database.


Arguments:

    ServerName - name of machine to get account domain information
        from.

    PolicyAccountDomainInfo - Receives a pointer to a
        POLICY_ACCOUNT_DOMAIN_INFO structure containing the account
        domain info.


Return Value:

    STATUS_SUCCESS - Succeeded.

    Other status values that may be returned from:

             LsaOpenPolicy()
             LsaQueryInformationPolicy()
--*/

{
    NTSTATUS
        NtStatus,
        IgnoreStatus;

    LSA_HANDLE
        PolicyHandle;

    OBJECT_ATTRIBUTES
        PolicyObjectAttributes;

    //
    // Open the policy database
    //

    InitializeObjectAttributes( &PolicyObjectAttributes,
                                  NULL,             // Name
                                  0,                // Attributes
                                  NULL,             // Root
                                  NULL );           // Security Descriptor

    NtStatus = LsaOpenPolicy( ServerName,
                              &PolicyObjectAttributes,
                              POLICY_VIEW_LOCAL_INFORMATION,
                              &PolicyHandle );

    if ( NT_SUCCESS(NtStatus) ) {

        //
        // Query the account domain information
        //

        NtStatus = LsaQueryInformationPolicy( PolicyHandle,
                                              PolicyAccountDomainInformation,
                                              (PVOID *)PolicyAccountDomainInfo );


        IgnoreStatus = LsaClose( PolicyHandle );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    return(NtStatus);
}


NTSTATUS
TSampConnectToServer(
    IN  PUNICODE_STRING         ServerName,
    IN  ACCESS_MASK             DomainAccess,
    OUT PHANDLE                 ServerHandle,
    OUT PHANDLE                 AccountDomain       OPTIONAL,
    OUT PSID                    *AccountDomainSid   OPTIONAL,
    OUT PHANDLE                 BuiltinDomain       OPTIONAL,
    OUT PSID                    *BuiltinDomainSid   OPTIONAL
    )

/*++

Routine Description:

    Open a handle to the SAM server on the specified server
    and then open the account and builtin domains on that same
    server.

Arguments:

    ServerName - Name of server to connect to.

    DomainAccess - accesses needed to the account domain.

    ServerHandle - Receives a handle to the SAM server on the specified
        system.

    AccountDomain - Receives a handle to the account domain.

    AccountDomainSid - Receives a pointer to the SID of the account domain.
        Must be present if AccountDomain is present.

    BuiltinDomain - Receives a handle to the Builtin domain.

    BuiltinDomainSid - Receives a pointer to the SID of the Builtin domain.
        Must be present if BuiltinDomain is present.


Return Value:




--*/
{
    NTSTATUS
        NtStatus;

    OBJECT_ATTRIBUTES
        ObjectAttributes;

    PPOLICY_ACCOUNT_DOMAIN_INFO
        AccountDomainInfo;

    SID_IDENTIFIER_AUTHORITY
        BuiltinAuthority = SECURITY_NT_AUTHORITY;

    //
    // Connect to the server
    //

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL );


    NtStatus = SamConnect(
                  ServerName,
                  ServerHandle,
                  SAM_SERVER_READ | SAM_SERVER_EXECUTE,
                  &ObjectAttributes
                  );


    if (!NT_SUCCESS(NtStatus)) {
        printf("SAM TEST: Failed to connect...\n"
               "          Completion status is 0x%lx\n", NtStatus);
        return(NtStatus);
    }


    //
    // Get account domain handle and sid
    //

    if (ARGUMENT_PRESENT(AccountDomain)) {
        //
        // get account domain info
        //
        
        NtStatus = TSampGetLsaDomainInfo( ServerName,
                                          &AccountDomainInfo);
        
        if (!NT_SUCCESS(NtStatus)) {
            printf("SAM TEST: Failed to get lsa domain info...\n"
                   "          Completion status is 0x%lx\n", NtStatus);
            return(NtStatus);
        }
        
        (*AccountDomainSid) = AccountDomainInfo->DomainSid;
        
        
        NtStatus = SamOpenDomain(
                       (*ServerHandle),
                       DomainAccess,
                       *AccountDomainSid,
                       AccountDomain
                       );
        
        if (!NT_SUCCESS(NtStatus)) {
            printf("Failed account domain open\n"
                   "        Completion status is 0x%lx\n", NtStatus);
            return(NtStatus);
        }
    } //end_if


    //
    // Get builtin domain handle and sid
    //

    if (ARGUMENT_PRESENT(BuiltinDomain)) {

        NtStatus = RtlAllocateAndInitializeSid(
                        &BuiltinAuthority,
                        1,  //SubAuthorities
                        SECURITY_BUILTIN_DOMAIN_RID,
                        0, 0, 0, 0, 0, 0, 0,
                        BuiltinDomainSid
                        );

        if (!NT_SUCCESS(NtStatus)) {
            printf("SAM TEST: Failed to allocate and init builtin domain sid...\n"
                   "          status is 0x%lx\n", NtStatus);
            return(NtStatus);
        }
        
        NtStatus = SamOpenDomain(
                       (*ServerHandle),
                       DomainAccess,
                       *BuiltinDomainSid,
                       BuiltinDomain
                       );
        
        if (!NT_SUCCESS(NtStatus)) {
            printf("Failed builtin domain open\n"
                   "        Completion status is 0x%lx\n", NtStatus);
            return(NtStatus);
        }
    } //end_if

    return(STATUS_SUCCESS);
}




VOID
TSampInitializeSids(
    OUT PSID        *MemberSids,
    IN  ULONG       MemberCount
    )
{

    //
    // Return and array of sids.
    //

    NTSTATUS
        NtStatus;

    ULONG
        i;

    SID_IDENTIFIER_AUTHORITY
        BuiltinAuthority    = SECURITY_NT_AUTHORITY,
        UnusedSidAuthority  = {0, 0, 0, 0, 0, 6};  //Authority that isn't used

    //
    // Fill MemberSids with MemberCount SIDs
    //

    for (i=0; i<MemberCount; i++) {

        NtStatus = RtlAllocateAndInitializeSid(
                                    &UnusedSidAuthority,
                                    3,             //SubAuthorityCount
                                    72549230,
                                    i,
                                    i*17,
                                    0, 0, 0, 0, 0,
                                    &MemberSids[i]
                                    );
        if (!NT_SUCCESS(NtStatus)) {
            printf("Tsamp:  Couldn't allocate or initialize sid %d, status: 0x%lx\n", NtStatus);
            return;
        }
    } // end_for


    return;

}


NTSTATUS
TSampTestAddMembers(
    IN  SAM_HANDLE          AliasHandle,
    IN  PSID                *MemberSids,
    IN  ULONG               MemberCount
    )
{
    NTSTATUS
        NtStatus;

    NtStatus = SamAddMultipleMembersToAlias(
                    AliasHandle,
                    MemberSids,
                    MemberCount
                    );
    printf("TSamp:  Added %d members to alias.  Status: 0x%lx\n",
            MemberCount, NtStatus);
    return(NtStatus);
}


NTSTATUS
TSampTestRemoveMembers(
    IN  SAM_HANDLE          AliasHandle,
    IN  PSID                *MemberSids,
    IN  ULONG               MemberCount
    )
{
    NTSTATUS
        NtStatus;

    NtStatus = SamRemoveMultipleMembersFromAlias(
                    AliasHandle,
                    MemberSids,
                    MemberCount
                    );
    printf("TSamp:  Removed %d members from alias.  Status: 0x%lx\n",
            MemberCount, NtStatus);
    return(NtStatus);
}


//VOID
__cdecl
main(c,v)
int c;
char **v;

/*++

Routine Description:

    This is the main entry routine for this test.

Arguments:




Return Value:




--*/
{
    NTSTATUS
        NtStatus;

    BOOLEAN
        Add,
        Remove;

    UNICODE_STRING
        ControllerName;

    WCHAR
        ControllerNameBuffer[80];

    SAM_HANDLE
        ServerHandle,
        AccountDomainHandle,
        BuiltinHandle,
        AliasHandle;

    ULONG
        MemberCount = TSAMP_MEMBER_COUNT;

    PSID
        MemberSids[TSAMP_MEMBER_COUNT],
        AccountDomainSid,
        BuiltinSid;


    ControllerName.Length = 0;
    ControllerName.Buffer = ControllerNameBuffer;
    ControllerName.MaximumLength = sizeof(ControllerNameBuffer);


    TSampParseCommandLine( c, v, &Add, &Remove );

    if (!Add && !Remove) {
        TSampUsage();
        return;
    }

    //
    // Open the server and its domains
    //

    NtStatus = TSampConnectToServer(&ControllerName,
                                    DOMAIN_LOOKUP | DOMAIN_READ_PASSWORD_PARAMETERS,
                                    &ServerHandle,
                                    &AccountDomainHandle,
                                    &AccountDomainSid,
                                    &BuiltinHandle,
                                    &BuiltinSid);
    ASSERT(NT_SUCCESS(NtStatus));

    //
    // Initialize a bunch of SIDs to add to the alias.
    //

    TSampInitializeSids( MemberSids, MemberCount );

    //
    // Open the alias we are going to play with
    //

    NtStatus = SamOpenAlias( BuiltinHandle,
                             (ALIAS_ADD_MEMBER | ALIAS_REMOVE_MEMBER),
                             DOMAIN_ALIAS_RID_ACCOUNT_OPS,
                             &AliasHandle);

    if (Add) {
        NtStatus = TSampTestAddMembers( AliasHandle, MemberSids, MemberCount );
    }

    if (Remove) {
        NtStatus = TSampTestRemoveMembers( AliasHandle, MemberSids, MemberCount );
    }
    



    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\client\tdisplay.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tdisplay.c

Abstract:

    This file is a temporary test for the Display query apis.

Author:

    Jim Kelly    (JimK)  14-Feb-1992

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


#include <nt.h>
#include <ntsam.h>
#include <ntrtl.h>



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


SAM_HANDLE                  SamHandle;
SAM_HANDLE                  DomainHandle;
PSID                        DomainSid;




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



VOID __cdecl
main( VOID )

{
    NTSTATUS                    Status;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQos;
    UNICODE_STRING              Domain;

    UNICODE_STRING              TestString;
    ULONG                       TestIndex;


    ULONG TotalAvailable, TotalReturned, ReturnedEntryCount, i;
    PDOMAIN_DISPLAY_USER SortedUsers;
    PDOMAIN_DISPLAY_MACHINE SortedMachines;
    PDOMAIN_DISPLAY_GROUP SortedGroups;
    PDOMAIN_DISPLAY_OEM_USER SortedOemUsers;
    PDOMAIN_DISPLAY_OEM_GROUP SortedOemGroups;



    SamHandle = NULL;
    DomainHandle = NULL;
    DomainSid = NULL;

    DbgPrint("\n\n\nSAM TEST: Testing SamQueryDisplayInformation() api\n");

    //
    // Setup ObjectAttributes for SamConnect call.
    //

    InitializeObjectAttributes(&ObjectAttributes, NULL, 0, 0, NULL);
    ObjectAttributes.SecurityQualityOfService = &SecurityQos;

    SecurityQos.Length = sizeof(SecurityQos);
    SecurityQos.ImpersonationLevel = SecurityIdentification;
    SecurityQos.ContextTrackingMode = SECURITY_STATIC_TRACKING;
    SecurityQos.EffectiveOnly = FALSE;

    Status = SamConnect(
                 NULL,
                 &SamHandle,
                 GENERIC_EXECUTE,
                 &ObjectAttributes
                 );

    if ( !NT_SUCCESS(Status) ) {
        DbgPrint("SamConnect failed, status %8.8x\n", Status);
        goto Cleanup;
    }

    RtlInitUnicodeString(&Domain, L"JIMK_DOM2");

    Status = SamLookupDomainInSamServer(
                 SamHandle,
                 &Domain,
                 &DomainSid
                 );

    if ( !NT_SUCCESS(Status) ) {
        DbgPrint("Cannot find account domain, status %8.8x\n", Status);
        Status = STATUS_CANT_ACCESS_DOMAIN_INFO;
        goto Cleanup;
    }

    Status = SamOpenDomain(
                 SamHandle,
                 GENERIC_EXECUTE,
                 DomainSid,
                 &DomainHandle
                 );

    if ( !NT_SUCCESS(Status) ) {
        DbgPrint("Cannot open account domain, status %8.8x\n", Status);
        Status = STATUS_CANT_ACCESS_DOMAIN_INFO;
        goto Cleanup;
    }


    //
    // normal users ...
    //

    DbgPrint("Query users - zero index...\n");
    Status =  SamQueryDisplayInformation (
                  DomainHandle,
                  DomainDisplayUser,
                  0,                        //Index
                  10,                       // Entries
                  1000,                     //PreferredMaximumLength,
                  &TotalAvailable,
                  &TotalReturned,
                  &ReturnedEntryCount,
                  &((PVOID)SortedUsers)
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint("   Buffer Address: 0x%lx\n", SortedUsers);
        DbgPrint("   TotalAvailable: 0x%lx\n", TotalAvailable);
        DbgPrint("    TotalReturned: 0x%lx\n", TotalReturned);
        DbgPrint(" Entries Returned: %d\n", ReturnedEntryCount);

        DbgPrint("\n\n");

        for (i=0;i<ReturnedEntryCount ; i++) {

            DbgPrint("Array entry: [%d]\n", i);
            DbgPrint("        Index:    %d\n",SortedUsers[i].Index);
            DbgPrint("          Rid:    %d\n", SortedUsers[i].Rid);
            DbgPrint("   Logon Name:    *%Z*\n", &SortedUsers[i].LogonName);
            DbgPrint("    Full Name:    *%Z*\n", &SortedUsers[i].FullName);
            DbgPrint("Admin Comment:    *%Z*\n\n\n", &SortedUsers[i].AdminComment);
        }

        Status = SamFreeMemory( SortedUsers );
        if (!NT_SUCCESS(Status)) {
            DbgPrint("\n\n\n ********  SamFreeMemory() failed.  *********\n");
            DbgPrint("\n\n\n ********  Status: 0x%lx            *********\n", Status);
        }
    }

    DbgPrint("Query users - Nonzero index (index = 2)...\n");
    Status =  SamQueryDisplayInformation (
                  DomainHandle,
                  DomainDisplayUser,
                  2,                        // Index
                  10,                       // Entries
                  100,                      // PreferredMaximumLength,
                  &TotalAvailable,
                  &TotalReturned,
                  &ReturnedEntryCount,
                  &((PVOID)SortedUsers)
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint("   Buffer Address: 0x%lx\n", SortedUsers);
        DbgPrint("   TotalAvailable: 0x%lx\n", TotalAvailable);
        DbgPrint("    TotalReturned: 0x%lx\n", TotalReturned);
        DbgPrint(" Entries Returned: %d\n", ReturnedEntryCount);

        DbgPrint("\n\n");

        for (i=0;i<ReturnedEntryCount ; i++) {

            DbgPrint("Array entry: [%d]\n", i);
            DbgPrint("        Index:    %d\n",SortedUsers[i].Index);
            DbgPrint("          Rid:    %d\n", SortedUsers[i].Rid);
            DbgPrint("   Logon Name:    *%Z*\n", &SortedUsers[i].LogonName);
            DbgPrint("    Full Name:    *%Z*\n", &SortedUsers[i].FullName);
            DbgPrint("Admin Comment:    *%Z*\n\n\n", &SortedUsers[i].AdminComment);
        }

        Status = SamFreeMemory( SortedUsers );
        if (!NT_SUCCESS(Status)) {
            DbgPrint("\n\n\n ********  SamFreeMemory() failed.  *********\n");
            DbgPrint("\n\n\n ********  Status: 0x%lx            *********\n", Status);
        }
    }


    DbgPrint("Get enumeration index...\n");

    RtlInitUnicodeString(&TestString, L"BString");

    Status =  SamGetDisplayEnumerationIndex (
                  DomainHandle,
                  DomainDisplayUser,
                  &TestString,
                  &TestIndex
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint(" Enumeration index for %wZ is %d\n", &TestString, TestIndex);
    }



    //
    // Machine accounts ...
    //

    DbgPrint("\n\nQuery Machines - zero index...\n");
    Status =  SamQueryDisplayInformation (
                  DomainHandle,
                  DomainDisplayMachine,
                  0,                        //Index
                  10,                       // Entries
                  1000,                     //PreferredMaximumLength,
                  &TotalAvailable,
                  &TotalReturned,
                  &ReturnedEntryCount,
                  &((PVOID)SortedMachines)
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint("   Buffer Address: 0x%lx\n", SortedMachines);
        DbgPrint("   TotalAvailable: 0x%lx\n", TotalAvailable);
        DbgPrint("    TotalReturned: 0x%lx\n", TotalReturned);
        DbgPrint(" Entries Returned: %d\n", ReturnedEntryCount);

        DbgPrint("\n\n");

        for (i=0;i<ReturnedEntryCount ; i++) {

            DbgPrint("Array entry: [%d]\n", i);
            DbgPrint("        Index:    %d\n",SortedMachines[i].Index);
            DbgPrint("          Rid:    %d\n", SortedMachines[i].Rid);
            DbgPrint("      Machine:    *%Z*\n", &SortedMachines[i].Machine);
            DbgPrint("      Comment:    *%Z*\n\n\n", &SortedMachines[i].Comment);
        }

        Status = SamFreeMemory( SortedMachines );
        if (!NT_SUCCESS(Status)) {
            DbgPrint("\n\n\n ********  SamFreeMemory() failed.  *********\n");
            DbgPrint("\n\n\n ********  Status: 0x%lx            *********\n", Status);
        }
    }

    DbgPrint("Query Machines - Nonzero index (index = 1)...\n");
    Status =  SamQueryDisplayInformation (
                  DomainHandle,
                  DomainDisplayMachine,
                  1,                        //Index
                  10,                       // Entries
                  1000,                     //PreferredMaximumLength,
                  &TotalAvailable,
                  &TotalReturned,
                  &ReturnedEntryCount,
                  &((PVOID)SortedMachines)
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint("   Buffer Address: 0x%lx\n", SortedMachines);
        DbgPrint("   TotalAvailable: 0x%lx\n", TotalAvailable);
        DbgPrint("    TotalReturned: 0x%lx\n", TotalReturned);
        DbgPrint(" Entries Returned: %d\n", ReturnedEntryCount);

        DbgPrint("\n\n");

        for (i=0;i<ReturnedEntryCount ; i++) {

            DbgPrint("Array entry: [%d]\n", i);
            DbgPrint("        Index:    %d\n",SortedMachines[i].Index);
            DbgPrint("          Rid:    %d\n", SortedMachines[i].Rid);
            DbgPrint("      Machine:    *%Z*\n", &SortedMachines[i].Machine);
            DbgPrint("      Comment:    *%Z*\n\n\n", &SortedMachines[i].Comment);
        }

        Status = SamFreeMemory( SortedMachines );
        if (!NT_SUCCESS(Status)) {
            DbgPrint("\n\n\n ********  SamFreeMemory() failed.  *********\n");
            DbgPrint("\n\n\n ********  Status: 0x%lx            *********\n", Status);
        }
    }


    DbgPrint("Get enumeration index...\n");

    RtlInitUnicodeString(&TestString, L"BString");

    Status =  SamGetDisplayEnumerationIndex (
                  DomainHandle,
                  DomainDisplayMachine,
                  &TestString,
                  &TestIndex
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint(" Enumeration index for %wZ is %d\n", &TestString, TestIndex);
    }




    //
    // normal Groups ...
    //

    DbgPrint("Query Groups - zero index...\n");
    Status =  SamQueryDisplayInformation (
                  DomainHandle,
                  DomainDisplayGroup,
                  0,                        //Index
                  10,                       // Entries
                  1000,                     //PreferredMaximumLength,
                  &TotalAvailable,
                  &TotalReturned,
                  &ReturnedEntryCount,
                  &((PVOID)SortedGroups)
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint("   Buffer Address: 0x%lx\n", SortedGroups);
        DbgPrint("   TotalAvailable: 0x%lx\n", TotalAvailable);
        DbgPrint("    TotalReturned: 0x%lx\n", TotalReturned);
        DbgPrint(" Entries Returned: %d\n", ReturnedEntryCount);

        DbgPrint("\n\n");

        for (i=0;i<ReturnedEntryCount ; i++) {

            DbgPrint("Array entry: [%d]\n", i);
            DbgPrint("        Index:    %d\n",SortedGroups[i].Index);
            DbgPrint("          Rid:    %d\n", SortedGroups[i].Rid);
            DbgPrint("         Name:    *%Z*\n", &SortedGroups[i].Group);
            DbgPrint("Admin Comment:    *%Z*\n\n\n", &SortedGroups[i].Comment);
        }

        Status = SamFreeMemory( SortedGroups );
        if (!NT_SUCCESS(Status)) {
            DbgPrint("\n\n\n ********  SamFreeMemory() failed.  *********\n");
            DbgPrint("\n\n\n ********  Status: 0x%lx            *********\n", Status);
        }
    }

    DbgPrint("Query Groups - Nonzero index (index = 2)...\n");
    Status =  SamQueryDisplayInformation (
                  DomainHandle,
                  DomainDisplayGroup,
                  2,                        // Index
                  10,                       // Entries
                  100,                      // PreferredMaximumLength,
                  &TotalAvailable,
                  &TotalReturned,
                  &ReturnedEntryCount,
                  &((PVOID)SortedGroups)
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint("   Buffer Address: 0x%lx\n", SortedGroups);
        DbgPrint("   TotalAvailable: 0x%lx\n", TotalAvailable);
        DbgPrint("    TotalReturned: 0x%lx\n", TotalReturned);
        DbgPrint(" Entries Returned: %d\n", ReturnedEntryCount);

        DbgPrint("\n\n");

        for (i=0;i<ReturnedEntryCount ; i++) {

            DbgPrint("Array entry: [%d]\n", i);
            DbgPrint("        Index:    %d\n",SortedGroups[i].Index);
            DbgPrint("          Rid:    %d\n", SortedGroups[i].Rid);
            DbgPrint("         Name:    *%Z*\n", &SortedGroups[i].Group);
            DbgPrint("Admin Comment:    *%Z*\n\n\n", &SortedGroups[i].Comment);
        }

        Status = SamFreeMemory( SortedGroups );
        if (!NT_SUCCESS(Status)) {
            DbgPrint("\n\n\n ********  SamFreeMemory() failed.  *********\n");
            DbgPrint("\n\n\n ********  Status: 0x%lx            *********\n", Status);
        }
    }


    DbgPrint("Get enumeration index...\n");

    RtlInitUnicodeString(&TestString, L"BString");

    Status =  SamGetDisplayEnumerationIndex (
                  DomainHandle,
                  DomainDisplayGroup,
                  &TestString,
                  &TestIndex
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint(" Enumeration index for %wZ is %d\n", &TestString, TestIndex);
    }


    //
    // OEM user ...
    //

    DbgPrint("Query OEM users - zero index...\n");
    Status =  SamQueryDisplayInformation (
                  DomainHandle,
                  DomainDisplayOemUser,
                  0,                        //Index
                  10,                       // Entries
                  1000,                     //PreferredMaximumLength,
                  &TotalAvailable,
                  &TotalReturned,
                  &ReturnedEntryCount,
                  &((PVOID)SortedOemUsers)
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint("   Buffer Address: 0x%lx\n", SortedOemUsers);
        DbgPrint("   TotalAvailable: 0x%lx (should be garbage)\n", TotalAvailable);
        DbgPrint("    TotalReturned: 0x%lx\n", TotalReturned);
        DbgPrint(" Entries Returned: %d\n", ReturnedEntryCount);


        DbgPrint("\n\n");

        for (i=0;i<ReturnedEntryCount ; i++) {

            DbgPrint("Array entry: [%d]\n", i);
            DbgPrint("        Index:    %d\n",SortedOemUsers[i].Index);
            DbgPrint("         User:    *%Z*\n", &SortedOemUsers[i].User);
        }

        Status = SamFreeMemory( SortedOemUsers );
        if (!NT_SUCCESS(Status)) {
            DbgPrint("\n\n\n ********  SamFreeMemory() failed.  *********\n");
            DbgPrint("\n\n\n ********  Status: 0x%lx            *********\n", Status);
        }
    }

    DbgPrint("Query OEM users - Nonzero index (index = 2)...\n");
    Status =  SamQueryDisplayInformation (
                  DomainHandle,
                  DomainDisplayOemUser,
                  2,                        // Index
                  10,                       // Entries
                  100,                      // PreferredMaximumLength,
                  &TotalAvailable,
                  &TotalReturned,
                  &ReturnedEntryCount,
                  &((PVOID)SortedOemUsers)
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint("   Buffer Address: 0x%lx\n", SortedOemUsers);
        DbgPrint("   TotalAvailable: 0x%lx (should be garbage)\n", TotalAvailable);
        DbgPrint("    TotalReturned: 0x%lx\n", TotalReturned);
        DbgPrint(" Entries Returned: %d\n", ReturnedEntryCount);

        DbgPrint("\n\n");


        for (i=0;i<ReturnedEntryCount ; i++) {

            DbgPrint("Array entry: [%d]\n", i);
            DbgPrint("        Index:    %d\n",SortedOemUsers[i].Index);
            DbgPrint("         User:    *%Z*\n", &SortedOemUsers[i].User);
        }

        Status = SamFreeMemory( SortedOemUsers );
        if (!NT_SUCCESS(Status)) {
            DbgPrint("\n\n\n ********  SamFreeMemory() failed.  *********\n");
            DbgPrint("\n\n\n ********  Status: 0x%lx            *********\n", Status);
        }
    }




    //
    // OEM groups ...
    //

    DbgPrint("Query OEM groups - zero index...\n");
    Status =  SamQueryDisplayInformation (
                  DomainHandle,
                  DomainDisplayOemGroup,
                  0,                        //Index
                  10,                       // Entries
                  1000,                     //PreferredMaximumLength,
                  &TotalAvailable,
                  &TotalReturned,
                  &ReturnedEntryCount,
                  &((PVOID)SortedOemGroups)
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint("   Buffer Address: 0x%lx\n", SortedOemGroups);
        DbgPrint("   TotalAvailable: 0x%lx (should be garbage)\n", TotalAvailable);
        DbgPrint("    TotalReturned: 0x%lx\n", TotalReturned);
        DbgPrint(" Entries Returned: %d\n", ReturnedEntryCount);


        DbgPrint("\n\n");

        for (i=0;i<ReturnedEntryCount ; i++) {

            DbgPrint("Array entry: [%d]\n", i);
            DbgPrint("        Index:    %d\n",SortedOemGroups[i].Index);
            DbgPrint("        Group:    *%Z*\n", &SortedOemGroups[i].Group);
        }

        Status = SamFreeMemory( SortedOemGroups );
        if (!NT_SUCCESS(Status)) {
            DbgPrint("\n\n\n ********  SamFreeMemory() failed.  *********\n");
            DbgPrint("\n\n\n ********  Status: 0x%lx            *********\n", Status);
        }
    }

    DbgPrint("Query OEM Groups - Nonzero index (index = 2)...\n");
    Status =  SamQueryDisplayInformation (
                  DomainHandle,
                  DomainDisplayOemGroup,
                  2,                        // Index
                  10,                       // Entries
                  100,                      // PreferredMaximumLength,
                  &TotalAvailable,
                  &TotalReturned,
                  &ReturnedEntryCount,
                  &((PVOID)SortedGroups)
                  );


    DbgPrint("Completion Status: 0x%lx\n", Status);
    if (NT_SUCCESS(Status)) {
        DbgPrint("   Buffer Address: 0x%lx\n", SortedGroups);
        DbgPrint("   TotalAvailable: 0x%lx (should be garbage)\n", TotalAvailable);
        DbgPrint("    TotalReturned: 0x%lx\n", TotalReturned);
        DbgPrint(" Entries Returned: %d\n", ReturnedEntryCount);

        DbgPrint("\n\n");

        for (i=0;i<ReturnedEntryCount ; i++) {

            DbgPrint("Array entry: [%d]\n", i);
            DbgPrint("        Index:    %d\n",SortedOemGroups[i].Index);
            DbgPrint("        Group:    *%Z*\n", &SortedOemGroups[i].Group);
        }

        Status = SamFreeMemory( SortedOemGroups );
        if (!NT_SUCCESS(Status)) {
            DbgPrint("\n\n\n ********  SamFreeMemory() failed.  *********\n");
            DbgPrint("\n\n\n ********  Status: 0x%lx            *********\n", Status);
        }
    }






    DbgPrint("\n\n  Th Tha That's all folks\n");


Cleanup:

    //
    // Close DomainHandle if open.
    //

    if (DomainHandle) {
        SamCloseHandle(DomainHandle);
    }

    //
    // Close SamHandle if open.
    //

    if (SamHandle) {
        SamCloseHandle(SamHandle);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\client\toempass.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    toempass.c

Abstract:

    This file contains test code for the oem password change routine.

Author:

    Mike Swift      (MikeSw)  4-January-1995

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "samclip.h"


NTSTATUS
SampEncryptLmPasswords(
    IN LPSTR OldPassword,
    IN LPSTR NewPassword,
    OUT PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,
    OUT PENCRYPTED_NT_OWF_PASSWORD OldLmOwfEncryptedWithNewLm
)
/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    LM_OWF_PASSWORD OldLmOwfPassword;
    LM_OWF_PASSWORD NewLmOwfPassword;
    PSAMPR_USER_PASSWORD NewLm = (PSAMPR_USER_PASSWORD) NewEncryptedWithOldLm;
    struct RC4_KEYSTRUCT Rc4Key;
    NTSTATUS NtStatus;
    CHAR LocalNewPassword[SAM_MAX_PASSWORD_LENGTH];
    CHAR LocalOldPassword[SAM_MAX_PASSWORD_LENGTH];

    if ((lstrlenA(OldPassword) > SAM_MAX_PASSWORD_LENGTH - 1) ||
        (lstrlenA(NewPassword) > SAM_MAX_PASSWORD_LENGTH - 1) )
    {
        return(STATUS_PASSWORD_RESTRICTION);
    }

    //
    // Upcase the passwords
    //
    lstrcpyA(LocalOldPassword,OldPassword);
    lstrcpyA(LocalNewPassword,NewPassword);

    strupr(LocalOldPassword);
    strupr(LocalNewPassword);



    //
    // Calculate the LM OWF passwords
    //


    NtStatus = RtlCalculateLmOwfPassword(
                    LocalOldPassword,
                    &OldLmOwfPassword
                    );


    if (NT_SUCCESS(NtStatus)) {
        NtStatus = RtlCalculateLmOwfPassword(
                    LocalNewPassword,
                    &NewLmOwfPassword
                    );
    }



    //
    // Calculate the encrypted old passwords
    //

    if (NT_SUCCESS(NtStatus)) {
        NtStatus = RtlEncryptLmOwfPwdWithLmOwfPwd(
                    &OldLmOwfPassword,
                    &NewLmOwfPassword,
                    OldLmOwfEncryptedWithNewLm
                    );
    }


    //
    // Calculate the encrypted new passwords
    //

    if (NT_SUCCESS(NtStatus)) {

        ASSERT(sizeof(SAMPR_ENCRYPTED_USER_PASSWORD) == sizeof(SAMPR_USER_PASSWORD));


        //
        // Compute the encrypted new password with LM key.
        //


        rc4_key(
            &Rc4Key,
            LM_OWF_PASSWORD_LENGTH,
            (PUCHAR) &OldLmOwfPassword
            );

        RtlCopyMemory(
            ((PUCHAR) NewLm->Buffer) +
                (SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                strlen(NewPassword),
            NewPassword,
            strlen(NewPassword)
            );

        NewLm->Length = strlen(NewPassword);
        rc4(&Rc4Key,
            sizeof(SAMPR_USER_PASSWORD),
            (PUCHAR) NewEncryptedWithOldLm
            );


    }

    return(NtStatus);

}



NTSTATUS
SamOemChangePassword(
    LPWSTR ServerName,
    LPSTR UserName,
    LPSTR OldPassword,
    LPSTR NewPassword
    )
{
    handle_t BindingHandle = NULL;
    NTSTATUS Status;
    SAMPR_ENCRYPTED_USER_PASSWORD NewLmEncryptedWithOldLm;
    ENCRYPTED_NT_OWF_PASSWORD OldLmOwfEncryptedWithNewLm;
    STRING UserString;
    UNICODE_STRING ServerUnicodeString;
    STRING ServerString;

    RtlInitUnicodeString(
        &ServerUnicodeString,
        ServerName
        );

    Status = RtlUnicodeStringToOemString(
                &ServerString,
                &ServerUnicodeString,
                TRUE
                );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    RtlInitString(
        &UserString,
        UserName
        );

    Status = SampEncryptLmPasswords(
                OldPassword,
                NewPassword,
                &NewLmEncryptedWithOldLm,
                &OldLmOwfEncryptedWithNewLm
                );

    if (!NT_SUCCESS(Status)) {
        RtlFreeOemString(&ServerString);
        return(Status);
    }
    BindingHandle = SampSecureBind(
                        ServerName,
                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY
                        );
    if (BindingHandle == NULL) {
        RtlFreeOemString(&ServerString);
        return(RPC_NT_INVALID_BINDING);
    }

    RpcTryExcept{

        Status = SamrOemChangePasswordUser2(
                       BindingHandle,
                       (PRPC_STRING) &ServerString,
                       (PRPC_STRING) &UserString,
                       &NewLmEncryptedWithOldLm,
                       &OldLmOwfEncryptedWithNewLm
                       );

    } RpcExcept( EXCEPTION_EXECUTE_HANDLER ) {

        Status = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    RtlFreeOemString(&ServerString);
    return(Status);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\client\tsamobj.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tsamobj.c

Abstract:

    This is the primary SAM object test.
    It contains a suite of tests for each type of SAM object.

Author:

    Jim Kelly    (JimK)  12-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/







///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <nt.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <ntlsa.h>
#include <ntrpcp.h>     // prototypes for MIDL user functions
#include <seopaque.h>
#include <string.h>



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Definitions                                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////





#define TMPP_USER_NAME_ADMIN           "Administrator"
#define TMPP_USER_NAME_GUEST           "Guest"
#define TMPP_GROUP_NAME_ADMINS         "Domain Admins"
#define TMPP_GROUP_NAME_USERS          "Domain Users"
#define TMPP_GROUP_NAME_NONE           "None"
#define TMPP_ALIAS_NAME_ADMINS         "Administrators"
#define TMPP_ALIAS_NAME_SYSTEM_OPS     "System Operators"
#define TMPP_ALIAS_NAME_POWER_USERS    "Power Users"
#define TMPP_ALIAS_NAME_USERS          "Users"
#define TMPP_ALIAS_NAME_GUESTS         "Guests"
#define TMPP_ALIAS_NAME_ACCOUNT_OPS    "Account Operators"
#define TMPP_ALIAS_NAME_PRINT_OPS      "Print Operators"
#define TMPP_ALIAS_NAME_BACKUP_OPS     "Backup Operators"



#define GROUP_NAME1             "GROUP1"
#define ALIAS_NAME1             "ALIAS1"
#define ALIAS_NAME2             "ALIAS2"
#define USER_NAME1              "USER1"
#define USER_NAME2              "USER2"
#define USER_NAME3              "USER3"

// Keep these names not longer than 8 char's until long registry names supported
#define DUMMY_NAME1             "DName1"
#define DUMMY_NAME2             "2emaNuD"

#define DUMMY_STRING1           "This is test string 1"
#define DUMMY_STRING2           "Test String2 - test string 2 - tEST sTRING 2"

#define ALL_NAMES_COUNT         (3)
#define SOME_NAMES_COUNT        (7)
#define NO_NAMES_COUNT          (2)

#define LOOKUP_KNOWN_NAME0      TMPP_USER_NAME_ADMIN
#define LOOKUP_KNOWN_NAME1_A    TMPP_GROUP_NAME_NONE
#define LOOKUP_KNOWN_NAME2_A    TMPP_GROUP_NAME_NONE
#define LOOKUP_KNOWN_NAME1_P    TMPP_GROUP_NAME_USERS
#define LOOKUP_KNOWN_NAME2_P    TMPP_GROUP_NAME_USERS

#define LOOKUP_KNOWN_NAME0_RID  DOMAIN_USER_RID_ADMIN
#define LOOKUP_KNOWN_NAME1_RID  DOMAIN_GROUP_RID_USERS
#define LOOKUP_KNOWN_NAME2_RID  DOMAIN_GROUP_RID_USERS

#define LOOKUP_UNKNOWN_NAME0    "JoeJoe"
#define LOOKUP_UNKNOWN_NAME1    "Tanya"
#define LOOKUP_UNKNOWN_NAME2    "Fred"
#define LOOKUP_UNKNOWN_NAME3    "Anyone"

#define LOOKUP_KNOWN_NAME0_USE  (SidTypeUser)
#define LOOKUP_KNOWN_NAME1_USE  (SidTypeGroup)
#define LOOKUP_KNOWN_NAME2_USE  (SidTypeGroup)


//
// This byte is expected to be different in the DummyLogonHours and
// NoRestrictionLogonHours.
//

#define LOGON_HOURS_DIFFERENT_OFFSET    (5)



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

LARGE_INTEGER LargeInteger1,
              LargeInteger2;

UNICODE_STRING DummyName1,
               DummyName2,
               DummyString1,
               DummyString2;

STRING         DummyAnsiString1,
               DummyAnsiString2;

LOGON_HOURS    NoLogonRestriction,
               DummyLogonHours;

CHAR           NoLogonRestrictionBitMask[21],
               DummyLogonHoursBitMask[21];


UNICODE_STRING  AllNames[ALL_NAMES_COUNT],
                SomeNames[SOME_NAMES_COUNT],
                NoNames[NO_NAMES_COUNT];


SID_NAME_USE    AllUses[ALL_NAMES_COUNT],
                SomeUses[SOME_NAMES_COUNT],
                NoUses[NO_NAMES_COUNT];

ULONG           AllRids[ALL_NAMES_COUNT],
                SomeRids[SOME_NAMES_COUNT],
                NoRids[NO_NAMES_COUNT];


PSID            BuiltinDomainSid,
                AccountDomainSid,
                PrimaryDomainSid,
                WorldSid,
                AdminsAliasSid,
                AccountAliasSid;


UNICODE_STRING  BuiltinDomainName,
                AccountDomainName,
                PrimaryDomainName;

BOOLEAN         AccountDomainIsNotPrimaryDomain;


//
// These are NOT mutually exclusive
//

BOOLEAN         BuiltinDomainTest,      // Test the builting domain
                SecurityOperatorTest,   // Test auditing accessibility
                AccountOpAliasTest,     // Test account operator functions
                AdminsAliasTest;        // Test domain admin functions



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private macros                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


//
// VOID
// TST_SUCCESS_ASSERT( IN NTSTATUS S );
//

#define TST_SUCCESS_ASSERT( S )                                             \
{                                                                           \
    if ( !NT_SUCCESS((S)) ) {                                               \
        printf("\n** SUCCESS STATUS ASSERTION FAILURE **\n");             \
        printf("   Status is:  0x%lx\n", (S) );                           \
        ASSERT(NT_SUCCESS((S)));                                            \
    }                                                                       \
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////




BOOLEAN
TInitialize( VOID );

BOOLEAN
EnableSecurityPrivilege( VOID );

VOID
DetermineTestsToRun( VOID );

VOID
SeeIfSidIsSpecial(
    IN PSID Sid
    );

BOOLEAN
ServerTestSuite(
    PHANDLE ServerHandle,
    PHANDLE DomainHandle,
    PHANDLE BuiltinDomainHandle,
    PSID    *DomainSid
    );

BOOLEAN
SecurityTestSuite(
    HANDLE ServerHandle,
    HANDLE DomainHandle,
    ULONG Pass
    );

BOOLEAN
CheckReturnedSD(
    IN SECURITY_INFORMATION SI,
    IN PSECURITY_DESCRIPTOR SD,
    IN BOOLEAN              PrintTestSuccess
    );


BOOLEAN
DomainTestSuite(
    HANDLE DomainHandle
    );

BOOLEAN
GroupTestSuite(
    HANDLE DomainHandle,
    ULONG  Pass
    );

BOOLEAN
AliasTestSuite(
    HANDLE DomainHandle,
    HANDLE BuiltinDomainHandle,
    PSID DomainSid,
    ULONG  Pass
    );

BOOLEAN
UserTestSuite(
    HANDLE DomainHandle,
    ULONG Pass
    );


NTSTATUS
SampSetDomainPolicy( VOID );


NTSTATUS
SampGetLsaDomainInfo(
    PPOLICY_ACCOUNT_DOMAIN_INFO *PolicyAccountDomainInfo,
    PPOLICY_PRIMARY_DOMAIN_INFO *PolicyPrimaryDomainInfo
    );


//
// The following are in WRAPPERS.C, but are prototyped here since this
// test is the only thing that should ever call them.
//

NTSTATUS
SamTestPrivateFunctionsDomain(
    IN HANDLE DomainHandle
    );

NTSTATUS
SamTestPrivateFunctionsUser(
    IN HANDLE UserHandle
    );



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID
__cdecl main (
    VOID
    )

/*++

Routine Description:

    This is the main entry routine for this test.

Arguments:

    None.

Return Value:


    Note:


--*/
{
    NTSTATUS            NtStatus;
    SAM_HANDLE          ServerHandle, DomainHandle, BuiltinDomainHandle;
    PSID                DomainSid;
    BOOLEAN             TestSucceeded = FALSE;


    printf("\n\n\n\n");
    printf("                              Test:   TSAMOBJ\n\n");
    printf("                         Test Date:   \n");
    printf("                         Test Time:   \n");




    //
    // Initialize and determine which flavor test(s) to run
    //

    if (!TInitialize()) {
        return;
    }

    if (ServerTestSuite( &ServerHandle, &DomainHandle, &BuiltinDomainHandle, &DomainSid )) {

        //
        // Do security manipulation tests on domain object
        //

        if (SecurityTestSuite( ServerHandle, DomainHandle, 1)) {

            if (AdminsAliasTest) {

            //
            // Do individual tests for domain, group, and user objects.
            //

                if (DomainTestSuite( DomainHandle )) {

                    if (AdminsAliasTest) {

                        if (GroupTestSuite( DomainHandle, 1)) {

                            if (AliasTestSuite( DomainHandle, BuiltinDomainHandle, DomainSid, 1)) {

                                if (UserTestSuite( DomainHandle, 1 )) {

                                    if (SecurityTestSuite( ServerHandle, DomainHandle, 2)) {

                                        if (GroupTestSuite( DomainHandle, 2)) {

                                            if (AliasTestSuite( DomainHandle, BuiltinDomainHandle, DomainSid, 2)) {

                                                if (UserTestSuite( DomainHandle, 2)) {

                                                    TestSucceeded = TRUE;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                TestSucceeded = TRUE;
            }
        }

        SamFreeMemory(DomainSid);

        NtStatus = SamCloseHandle( DomainHandle );
        if (!NT_SUCCESS(NtStatus)) {
            printf("SAM TEST: Status of SamCloseHandle(Domain) is: 0x%lx\n", NtStatus);
            DbgBreakPoint();
            return;
        }

        NtStatus = SamCloseHandle( ServerHandle );
        if (!NT_SUCCESS(NtStatus)) {
            printf("SAM TEST: Status of SamCloseHandle(Server) is: 0x%lx\n", NtStatus);
            DbgBreakPoint();
            return;
        }

    }

    printf("\n");
    printf("\n");
    printf("  SAM Test:   ");
    if (TestSucceeded) {
        printf("Succeeded\n");
    } else {
        printf("**  Failed  **\n");
    }


    return;
}


BOOLEAN
TInitialize (
    VOID
    )

/*++

Routine Description:

    Initialize test variables, et cetera.

Arguments:

    None.

Return Value:


    Note:


--*/
{
    NTSTATUS NtStatus;
    STRING Name;
    ULONG i;

    SID_IDENTIFIER_AUTHORITY    WorldSidAuthority        = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    DomainSidAuthority       = {0,0,0,0,0,0};
    SID_IDENTIFIER_AUTHORITY    BuiltinAuthority         = SECURITY_NT_AUTHORITY;


    //
    // Get the domain SIDs from the policy database...
    //

    NtStatus = SampSetDomainPolicy();
    ASSERT(NT_SUCCESS(NtStatus));


    //
    // A random large integer value..
    //

    LargeInteger1.LowPart = 1234;
    LargeInteger1.HighPart = 0;

    LargeInteger2.LowPart = 4321;
    LargeInteger2.HighPart = 0;


    RtlInitString( &Name, DUMMY_NAME1 );
    NtStatus = RtlAnsiStringToUnicodeString( &DummyName1, &Name, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);

    RtlInitString( &Name, DUMMY_NAME2 );
    NtStatus = RtlAnsiStringToUnicodeString( &DummyName2, &Name, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);


    RtlInitString( &DummyAnsiString1, DUMMY_STRING1 );
    NtStatus = RtlAnsiStringToUnicodeString( &DummyString1, &DummyAnsiString1, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);

    RtlInitString( &DummyAnsiString2, DUMMY_STRING2 );
    NtStatus = RtlAnsiStringToUnicodeString( &DummyString2, &DummyAnsiString2, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);


    DummyLogonHours.UnitsPerWeek = SAM_HOURS_PER_WEEK;
    DummyLogonHours.LogonHours   = &DummyLogonHoursBitMask[0];
    DummyLogonHoursBitMask[LOGON_HOURS_DIFFERENT_OFFSET] = 103; // Any non-zero value

    NoLogonRestriction.UnitsPerWeek = SAM_HOURS_PER_WEEK;
    NoLogonRestriction.LogonHours   = &NoLogonRestrictionBitMask[0];
    for ( i=0; i<(ULONG)((NoLogonRestriction.UnitsPerWeek+7)/8); i++) {
        NoLogonRestrictionBitMask[0] = 0;
    }



    //
    //  Initialize some SIDs
    //


    WorldSid = RtlAllocateHeap( RtlProcessHeap(), 0, RtlLengthRequiredSid(1) );
    ASSERT(WorldSid != NULL);
    RtlInitializeSid( WorldSid, &WorldSidAuthority, 1 );
    *(RtlSubAuthoritySid( WorldSid, 0 )) = SECURITY_WORLD_RID;

    AdminsAliasSid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 2 ));
    ASSERT(AdminsAliasSid != NULL);
    RtlInitializeSid( AdminsAliasSid,   &BuiltinAuthority, 2 );
    *(RtlSubAuthoritySid( AdminsAliasSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( AdminsAliasSid,  1 )) = DOMAIN_ALIAS_RID_ADMINS;

    AccountAliasSid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 2 ));
    ASSERT(AccountAliasSid != NULL);
    RtlInitializeSid( AccountAliasSid,   &BuiltinAuthority, 2 );
    *(RtlSubAuthoritySid( AccountAliasSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( AccountAliasSid,  1 )) = DOMAIN_ALIAS_RID_ACCOUNT_OPS;




    //
    // Initialize some stuff for SID and NAME lookup operations
    //

    RtlInitString( &Name, LOOKUP_KNOWN_NAME0 );

    AllUses[0] = LOOKUP_KNOWN_NAME0_USE;  AllRids[0] = LOOKUP_KNOWN_NAME0_RID;
    NtStatus = RtlAnsiStringToUnicodeString( &AllNames[0], &Name, TRUE ); TST_SUCCESS_ASSERT(NtStatus);
    SomeUses[0] = LOOKUP_KNOWN_NAME0_USE;  SomeRids[0] = LOOKUP_KNOWN_NAME0_RID;
    NtStatus = RtlAnsiStringToUnicodeString( &SomeNames[0], &Name, TRUE ); TST_SUCCESS_ASSERT(NtStatus);


    if (AccountDomainIsNotPrimaryDomain == TRUE) {
        RtlInitString( &Name, LOOKUP_KNOWN_NAME1_A );
    } else {
        RtlInitString( &Name, LOOKUP_KNOWN_NAME1_P );
    }
    AllUses[1] = LOOKUP_KNOWN_NAME1_USE;  AllRids[1] = LOOKUP_KNOWN_NAME1_RID;
    NtStatus = RtlAnsiStringToUnicodeString( &AllNames[1], &Name, TRUE ); TST_SUCCESS_ASSERT(NtStatus);
    SomeUses[1] = LOOKUP_KNOWN_NAME1_USE;  SomeRids[1] = LOOKUP_KNOWN_NAME1_RID;
    NtStatus = RtlAnsiStringToUnicodeString( &SomeNames[1], &Name, TRUE ); TST_SUCCESS_ASSERT(NtStatus);

    RtlInitString( &Name, LOOKUP_UNKNOWN_NAME0 );

    SomeUses[2] = SidTypeUnknown;
    NtStatus = RtlAnsiStringToUnicodeString( &SomeNames[2], &Name, TRUE ); TST_SUCCESS_ASSERT(NtStatus);
    NoUses[0] = SidTypeUnknown;
    NtStatus = RtlAnsiStringToUnicodeString( &NoNames[0], &Name, TRUE ); TST_SUCCESS_ASSERT(NtStatus);


    RtlInitString( &Name, LOOKUP_UNKNOWN_NAME1 );

    SomeUses[3] = SidTypeUnknown;
    NtStatus = RtlAnsiStringToUnicodeString( &SomeNames[3], &Name, TRUE ); TST_SUCCESS_ASSERT(NtStatus);
    NoUses[1] = SidTypeUnknown;
    NtStatus = RtlAnsiStringToUnicodeString( &NoNames[1], &Name, TRUE ); TST_SUCCESS_ASSERT(NtStatus);



    RtlInitString( &Name, LOOKUP_UNKNOWN_NAME2 );

    SomeUses[4] = SidTypeUnknown;
    NtStatus = RtlAnsiStringToUnicodeString( &SomeNames[4], &Name, TRUE ); TST_SUCCESS_ASSERT(NtStatus);


    if (AccountDomainIsNotPrimaryDomain == TRUE) {
        RtlInitString( &Name, LOOKUP_KNOWN_NAME2_A );
    } else {
        RtlInitString( &Name, LOOKUP_KNOWN_NAME2_P );
    }
    AllUses[2] = LOOKUP_KNOWN_NAME2_USE;  AllRids[2] = LOOKUP_KNOWN_NAME2_RID;
    NtStatus = RtlAnsiStringToUnicodeString( &AllNames[2], &Name, TRUE ); TST_SUCCESS_ASSERT(NtStatus);
    SomeUses[5] = LOOKUP_KNOWN_NAME2_USE;  SomeRids[5] = LOOKUP_KNOWN_NAME2_RID;
    NtStatus = RtlAnsiStringToUnicodeString( &SomeNames[5], &Name, TRUE ); TST_SUCCESS_ASSERT(NtStatus);



    RtlInitString( &Name, LOOKUP_UNKNOWN_NAME3 );

    SomeUses[6] = SidTypeUnknown;
    NtStatus = RtlAnsiStringToUnicodeString( &SomeNames[6], &Name, TRUE ); TST_SUCCESS_ASSERT(NtStatus);


    DetermineTestsToRun();

    return(TRUE);
}


NTSTATUS
SampSetDomainPolicy(
    )
/*++


Routine Description:

    This routine sets the names and SIDs for the builtin and account domains.
    The builtin account domain has a well known name and SID.
    The account domain has these stored in the Policy database.


    It places the information for these domains in:

            BuiltinDomainSid
            BuiltinDomainName
            AccountDomainSid
            AccountDomainName
            PrimaryDomainSid
            PrimaryDomainName

    It also sets the boolean:

            AccountDomainIsNotPrimaryDomain

    to TRUE if the account domain is found to be different from the
    Primary Domain.

Arguments:

    None.

Return Value:

--*/

{
    NTSTATUS NtStatus;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyAccountDomainInfo;
    PPOLICY_PRIMARY_DOMAIN_INFO PolicyPrimaryDomainInfo;
    SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;

    //
    // Builtin domain - well-known name and SID
    //

    RtlInitUnicodeString( &BuiltinDomainName, L"Builtin");

    BuiltinDomainSid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 1 ));
    ASSERT( BuiltinDomainSid != NULL );
    RtlInitializeSid( BuiltinDomainSid,   &BuiltinAuthority, 1 );
    *(RtlSubAuthoritySid( BuiltinDomainSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;

    //
    // Account domain
    //

    NtStatus = SampGetLsaDomainInfo(
                   &PolicyAccountDomainInfo,
                   &PolicyPrimaryDomainInfo
                   );

    if (!NT_SUCCESS(NtStatus)) {

        return(NtStatus);
    }

    AccountDomainSid = PolicyAccountDomainInfo->DomainSid;
    AccountDomainName = PolicyAccountDomainInfo->DomainName;

    PrimaryDomainSid = PolicyPrimaryDomainInfo->Sid;
    PrimaryDomainName = PolicyPrimaryDomainInfo->Name;

    //
    // Determine whether the account domain is a primary domain.
    //

    AccountDomainIsNotPrimaryDomain =
        !RtlEqualUnicodeString( &PrimaryDomainName, &AccountDomainName, TRUE);

    return(NtStatus);;
}



NTSTATUS
SampGetLsaDomainInfo(
    PPOLICY_ACCOUNT_DOMAIN_INFO *PolicyAccountDomainInfo,
    PPOLICY_PRIMARY_DOMAIN_INFO *PolicyPrimaryDomainInfo
    )

/*++

Routine Description:

    This routine retrieves ACCOUNT domain information from the LSA
    policy database.


Arguments:

    PolicyAccountDomainInfo - Receives a pointer to a
        POLICY_ACCOUNT_DOMAIN_INFO structure containing the account
        domain info.

    PolicyPrimaryDomainInfo - Receives a pointer to a
        POLICY_PRIMARY_DOMAIN_INFO structure containing the Primary
        domain info.


Return Value:

    STATUS_SUCCESS - Succeeded.

    Other status values that may be returned from:

             LsaOpenPolicy()
             LsaQueryInformationPolicy()
--*/

{
    NTSTATUS Status, IgnoreStatus;

    LSA_HANDLE PolicyHandle;
    OBJECT_ATTRIBUTES PolicyObjectAttributes;

    //
    // Open the policy database
    //

    InitializeObjectAttributes( &PolicyObjectAttributes,
                                  NULL,             // Name
                                  0,                // Attributes
                                  NULL,             // Root
                                  NULL );           // Security Descriptor

    Status = LsaOpenPolicy( NULL,
                            &PolicyObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &PolicyHandle );
    if ( NT_SUCCESS(Status) ) {

        //
        // Query the account domain information
        //

        Status = LsaQueryInformationPolicy( PolicyHandle,
                                            PolicyAccountDomainInformation,
                                            (PVOID *)PolicyAccountDomainInfo );
#if DBG
        if ( NT_SUCCESS(Status) ) {
            ASSERT( (*PolicyAccountDomainInfo) != NULL );
            ASSERT( (*PolicyAccountDomainInfo)->DomainSid != NULL );
            ASSERT( (*PolicyAccountDomainInfo)->DomainName.Buffer != NULL );
        }
#endif \\DBG

        //
        // Query the Primary domain information
        //

        Status = LsaQueryInformationPolicy( PolicyHandle,
                                            PolicyPrimaryDomainInformation,
                                            (PVOID *)PolicyPrimaryDomainInfo );
#if DBG
        if ( NT_SUCCESS(Status) ) {
            ASSERT( (*PolicyPrimaryDomainInfo) != NULL );
            ASSERT( (*PolicyPrimaryDomainInfo)->Sid != NULL );
            ASSERT( (*PolicyPrimaryDomainInfo)->Name.Buffer != NULL );
        }
#endif \\DBG

        IgnoreStatus = LsaClose( PolicyHandle );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    return(Status);
}




PSID
CreateUserSid(
    PSID    DomainSid,
    ULONG   Rid
    )

/*++

Routine Description:

    This function creates a domain account sid given a domain sid and
    the relative id of the account within the domain.

Arguments:

    None.

Return Value:

    Pointer to Sid, or NULL on failure.
    The returned Sid must be freed with DeleteUserSid

--*/
{

    NTSTATUS IgnoreStatus;
    PSID AccountSid;
    UCHAR AccountSubAuthorityCount = *RtlSubAuthorityCountSid(DomainSid) + (UCHAR)1;
    ULONG AccountSidLength = RtlLengthRequiredSid(AccountSubAuthorityCount);
    PULONG  RidLocation;

    // Temp sanity check
    ASSERT(AccountSidLength == RtlLengthSid(DomainSid) + sizeof(ULONG));

    //
    // Allocate space for the account sid
    //

    AccountSid = MIDL_user_allocate(AccountSidLength);

    if (AccountSid != NULL) {

        //
        // Copy the domain sid into the first part of the account sid
        //

        IgnoreStatus = RtlCopySid(AccountSidLength, AccountSid, DomainSid);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // Increment the account sid sub-authority count
        //

        *RtlSubAuthorityCountSid(AccountSid) = AccountSubAuthorityCount;

        //
        // Add the rid as the final sub-authority
        //

        RidLocation = RtlSubAuthoritySid(AccountSid, AccountSubAuthorityCount - 1);
        *RidLocation = Rid;
    }

    return(AccountSid);
}



VOID
DeleteUserSid(
    PSID    UserSid
    )

/*++

Routine Description:

    Frees a sid returned by CreateUserSid.

Arguments:

    None.

Return Value:

    None.

--*/
{
    MIDL_user_free(UserSid);
}



BOOLEAN
EnableSecurityPrivilege(
    VOID
    )

/*++

Routine Description:

    This function enabled the SeSecurityPrivilege privilege.

Arguments:

    None.

Return Value:

    TRUE  if privilege successfully enabled.
    FALSE if not successfully enabled.

--*/
{

    NTSTATUS Status;
    HANDLE Token;
    LUID SecurityPrivilege;
    PTOKEN_PRIVILEGES NewState;
    ULONG ReturnLength;


    //
    // Open our own token
    //

    Status = NtOpenProcessToken(
                 NtCurrentProcess(),
                 TOKEN_ADJUST_PRIVILEGES,
                 &Token
                 );
    if (!NT_SUCCESS(Status)) {
        printf(" \n\n\n");
        printf("Tsamobj: Can't open process token to enable Security Privilege.\n");
        printf("         Completion status of NtOpenProcessToken() is: 0x%lx\n", Status);
        printf("\n");
        return(FALSE);
    }


    //
    // Initialize the adjustment structure
    //

    SecurityPrivilege =
        RtlConvertLongToLargeInteger(SE_SECURITY_PRIVILEGE);

    ASSERT( (sizeof(TOKEN_PRIVILEGES) + sizeof(LUID_AND_ATTRIBUTES)) < 100);
    NewState = RtlAllocateHeap( RtlProcessHeap(), 0, 100 );

    NewState->PrivilegeCount = 1;
    NewState->Privileges[0].Luid = SecurityPrivilege;
    NewState->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;


    //
    // Set the state of the privilege to ENABLED.
    //

    Status = NtAdjustPrivilegesToken(
                 Token,                            // TokenHandle
                 FALSE,                            // DisableAllPrivileges
                 NewState,                         // NewState
                 0,                                // BufferLength
                 NULL,                             // PreviousState (OPTIONAL)
                 &ReturnLength                     // ReturnLength
                 );
    // don't use NT_SUCCESS here because STATUS_NOT_ALL_ASSIGNED is a success status
    if (Status != STATUS_SUCCESS) {
        return(FALSE);
    }


    //
    // Clean up some stuff before returning
    //

    RtlFreeHeap( RtlProcessHeap(), 0, NewState );
    Status = NtClose( Token );
    ASSERT(NT_SUCCESS(Status));


    return TRUE;

}



VOID
printfSid(
    PSID    Sid
    )

/*++

Routine Description:

    Prints a sid

Arguments:

    None.

Return Value:

    None.

--*/
{
    UCHAR   Buffer[128];
    UCHAR   String[128];
    UCHAR   i;
    ULONG   Tmp;
    PISID   iSid = (PISID)Sid;  // pointer to opaque structure
    PSID    NextSid = (PSID)Buffer;

    ASSERT(sizeof(Buffer) >= RtlLengthRequiredSid(1));

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_WORLD_SID_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_WORLD_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            printf("World");
            return;
        }
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_LOCAL_SID_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_LOCAL_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            printf("Local");
            return;
        }
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_CREATOR_OWNER_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            printf("Creator");
            return;
        }
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_DIALUP_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            printf("Dialup");
            return;
        }
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_NETWORK_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            printf("Network");
            return;
        }
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_BATCH_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            printf("Batch");
            return;
        }
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_INTERACTIVE_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            printf("Interactive");
            return;
        }
    }


    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_LOCAL_SYSTEM_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            printf("Local System");
            return;
        }
    }



    sprintf(Buffer, "S-%u-", (USHORT)iSid->Revision );
    strcpy(String, Buffer);

    if (  (iSid->IdentifierAuthority.Value[0] != 0)  ||
          (iSid->IdentifierAuthority.Value[1] != 0)     ){
        sprintf(Buffer, "0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)iSid->IdentifierAuthority.Value[0],
                    (USHORT)iSid->IdentifierAuthority.Value[1],
                    (USHORT)iSid->IdentifierAuthority.Value[2],
                    (USHORT)iSid->IdentifierAuthority.Value[3],
                    (USHORT)iSid->IdentifierAuthority.Value[4],
                    (USHORT)iSid->IdentifierAuthority.Value[5] );
        strcat(String, Buffer);
    } else {
        Tmp = (ULONG)iSid->IdentifierAuthority.Value[5]          +
              (ULONG)(iSid->IdentifierAuthority.Value[4] <<  8)  +
              (ULONG)(iSid->IdentifierAuthority.Value[3] << 16)  +
              (ULONG)(iSid->IdentifierAuthority.Value[2] << 24);
        sprintf(Buffer, "%lu", Tmp);
        strcat(String, Buffer);
    }


    for (i=0;i<iSid->SubAuthorityCount ;i++ ) {
        sprintf(Buffer, "-%lu", iSid->SubAuthority[i]);
        strcat(String, Buffer);
    }

    printf(Buffer);

    return;
}


VOID
DetermineTestsToRun(
    VOID
    )

/*++

Routine Description:

    This function determines which tests are to be run.


Arguments:

    None.

Return Value:

    None.


--*/
{

    NTSTATUS            Status;
    HANDLE              Token;

    PTOKEN_USER         User;
    PTOKEN_GROUPS       Groups;

    ULONG               ReturnLength,
                        i;



    //
    // See if we can play with auditing information
    //

    SecurityOperatorTest = EnableSecurityPrivilege();


    //
    // Open our own token
    //

    Status = NtOpenProcessToken(
                 NtCurrentProcess(),
                 TOKEN_QUERY,
                 &Token
                 );
    if (!NT_SUCCESS(Status)) {
        printf(" \n\n\n");
        printf("Tsamobj: Can't open process token to query owner.\n");
        printf("         Completion status of NtOpenProcessToken() is: 0x%lx\n", Status);
        printf("\n");
        return;
    }


    //
    // Query the user id
    //

    User   = RtlAllocateHeap( RtlProcessHeap(), 0, 1000 ); // should be plenty big
    Status = NtQueryInformationToken( Token, TokenUser, User, 1000, &ReturnLength );
    ASSERT(NT_SUCCESS(Status));

    //
    // See if the ID is one of the special IDs (e.g., local admin,
    // domain account operator, or domain admin)
    //

    SeeIfSidIsSpecial( User->User.Sid );



    //
    // Query the group ids
    //

    Groups = RtlAllocateHeap( RtlProcessHeap(), 0, 1000 ); // should be plenty big
    Status = NtQueryInformationToken( Token, TokenGroups, Groups, 1000, &ReturnLength );
    ASSERT(NT_SUCCESS(Status));

    //
    // See if any of these IDs are special IDs
    //

    for (i=0; i<Groups->GroupCount; i++) {
        SeeIfSidIsSpecial( Groups->Groups[i].Sid );
    }





    //
    // Clean up some stuff before returning
    //

    RtlFreeHeap( RtlProcessHeap(), 0, User );
    RtlFreeHeap( RtlProcessHeap(), 0, Groups );
    Status = NtClose( Token );
    ASSERT(NT_SUCCESS(Status));



    printf("\n\n\n\nPerforming:\n\n");

    printf("        Administrator Alias Test. . . . . ");
    if (AdminsAliasTest) {
        printf("Yes\n\n");
    } else {
        printf("No\n\n");
    }

    printf("        Account Operator Alias  Test  . . ");
    if (AccountOpAliasTest) {
        printf("Yes\n\n");
    } else {
        printf("No\n\n");
    }

    printf("        Security Operator  Test . . . . . ");
    if (SecurityOperatorTest) {
        printf("Yes\n\n");
    } else {
        printf("No\n\n");
    }

    printf("\n\n\n");



    return;

}


VOID
SeeIfSidIsSpecial(
    IN PSID Sid
    )

/*++

Routine Description:

    This function determines whether the passed SID is one of the special
    SIDs, such as ADMINISTRATORS alias, or DomainAccountOperator, and
    sets test flags accordingly.


Arguments:

    Sid - Pointer to the SID to check.

Return Value:

    None.


--*/
{




    if (RtlEqualSid( Sid, AdminsAliasSid )){
        AdminsAliasTest = TRUE;
    }

    if (RtlEqualSid( Sid, AccountAliasSid )){
        AccountOpAliasTest = TRUE;
    }

    return;

}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Server Object Test Suite                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


BOOLEAN
ServerTestSuite(
    PHANDLE ServerHandle,
    PHANDLE DomainHandle,
    PHANDLE BuiltinDomainHandle,
    PSID    *DomainSid
    )

{
    NTSTATUS                        NtStatus;
    OBJECT_ATTRIBUTES               ObjectAttributes;
    BOOLEAN                         TestStatus = TRUE;
    ULONG                           CountReturned;
    SAM_ENUMERATE_HANDLE            EnumerationContext;
    PSAM_RID_ENUMERATION            EnumerationBuffer;
    PSID                            BuiltinDomainSid;
    ACCESS_MASK                     ServerAccessMask, DomainAccessMask;





    printf("\n");
    printf("\n");
    printf("  Server Object                                           Test\n");

    ///////////////////////////////////////////////////////////////////////////
    //                                                                       //
    // Connect To Server                                                     //
    //                                                                       //
    ///////////////////////////////////////////////////////////////////////////

    printf("\n");
    printf("    Connect / Disconnect. . . . . . . . . . . . . . . . .   Suite\n");

    printf("      Connect . . . . . . . . . . . . . . . . . . . . . .     ");


    ServerAccessMask = SAM_SERVER_READ | SAM_SERVER_EXECUTE;
    if (AdminsAliasTest) {
        ServerAccessMask |= SAM_SERVER_ALL_ACCESS;
    }
    if (SecurityOperatorTest) {
        ServerAccessMask |= ACCESS_SYSTEM_SECURITY;
    }

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL );


    NtStatus = SamConnect(
                  NULL,                     // ServerName (Local machine)
                  ServerHandle,
                  ServerAccessMask,
                  &ObjectAttributes
                  );


    if (!NT_SUCCESS(NtStatus)) {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    } else {
        printf("Succeeded\n");
    }


    if (NT_SUCCESS(NtStatus)) {

        printf("      Disconnect  . . . . . . . . . . . . . . . . . . . .     ");

        NtStatus = SamCloseHandle( (*ServerHandle) );

        if (!NT_SUCCESS(NtStatus)) {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        } else {
            printf("Succeeded\n");
        }
    }



    printf("      Re-Connect  . . . . . . . . . . . . . . . . . . . .     ");


    NtStatus = SamConnect(
                  NULL,                     // ServerName (Local machine)
                  ServerHandle,
                  ServerAccessMask,
                  &ObjectAttributes
                  );


    if (!NT_SUCCESS(NtStatus)) {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    } else {
        printf("Succeeded\n");
    }


    ///////////////////////////////////////////////////////////////////////////
    //                                                                       //
    // Lookup/Enumerate Domains Suite                                        //
    //                                                                       //
    ///////////////////////////////////////////////////////////////////////////


    printf("\n");
    printf("    Domain Lookup/Enumerate/Open  . . . . . . . . . . . .   Suite\n");



    if (NT_SUCCESS(NtStatus)) {

        printf("      Lookup Account Domain . . . . . . . . . . . . . . .     ");


        NtStatus = SamLookupDomainInSamServer(
                       (*ServerHandle),
                       &AccountDomainName,
                       DomainSid
                       );

        if (!NT_SUCCESS(NtStatus)) {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        } else {
            if ( TRUE != RtlEqualSid((*DomainSid), AccountDomainSid)) {
                printf("Failed\n");
                printf("        The SID retrieved from the policy database did not\n");
                printf("        match the SID retrieved from SAM for the account\n");
                printf("        domain.\n");
                printf("        Sid from Policy Database is: ");
                printfSid(      AccountDomainSid ); printf("\n");
                printf("        Sid from SAM is: ");
                printfSid(      (*DomainSid) ); printf("\n");
                TestStatus = FALSE;
            } else {
                printf("Succeeded\n");
            }
        }

    }






    if (NT_SUCCESS(NtStatus)) {

        printf("      Enumerate Domain  . . . . . . . . . . . . . . . . .     ");


        EnumerationContext = 0;
        EnumerationBuffer = NULL;
        NtStatus = SamEnumerateDomainsInSamServer(
                       (*ServerHandle),
                       &EnumerationContext,
                       (PVOID *)&EnumerationBuffer,
                       1024,                        // PreferedMaximumLength
                       &CountReturned
                       );

        if (!NT_SUCCESS(NtStatus)) {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        } else {

            if (CountReturned == 0) {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                printf("        CountReturned is: 0x%lx\n", CountReturned);
                printf("        EnumerationContext is: 0x%lx\n", EnumerationContext);
                printf("        EnumerationBuffer Address is: 0x%lx\n", (ULONG)EnumerationBuffer);
                TestStatus = FALSE;

            } else {
                printf("Succeeded\n");
            }

            SamFreeMemory( EnumerationBuffer );
        }

    }






    if (NT_SUCCESS(NtStatus)) {

        printf("      Open Account Domain . . . . . . . . . . . . . . . .     ");

        if (NT_SUCCESS(NtStatus)) {

            DomainAccessMask = DOMAIN_READ | DOMAIN_EXECUTE;
            if (AccountOpAliasTest) {
                DomainAccessMask |= DOMAIN_READ | DOMAIN_WRITE | DOMAIN_EXECUTE;
            }
            if (AdminsAliasTest) {
                DomainAccessMask |= DOMAIN_ALL_ACCESS;
            }
            if (SecurityOperatorTest) {
                DomainAccessMask |= ACCESS_SYSTEM_SECURITY;
            }
            NtStatus = SamOpenDomain(
                           (*ServerHandle),
                           DomainAccessMask,
                           *DomainSid,
                           DomainHandle
                           );

            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            } else {
                printf("Succeeded\n");
            }
        }

    }

    if (NT_SUCCESS(NtStatus)) {

        printf("      Open Builtin Domain . . . . . . . . . . . . . . . .     ");

        NtStatus = SamLookupDomainInSamServer(
                       (*ServerHandle),
                       &BuiltinDomainName,
                       &BuiltinDomainSid
                       );

        if (NT_SUCCESS(NtStatus)) {

            DomainAccessMask = DOMAIN_READ | DOMAIN_EXECUTE;
            if (AccountOpAliasTest) {
                DomainAccessMask |= DOMAIN_READ | DOMAIN_WRITE | DOMAIN_EXECUTE;
            }
            if (AdminsAliasTest) {
                DomainAccessMask |= (DOMAIN_EXECUTE | DOMAIN_READ |
                                     DOMAIN_READ_OTHER_PARAMETERS |
                                     DOMAIN_ADMINISTER_SERVER     |
                                     DOMAIN_CREATE_ALIAS);
            }
//            if (SecurityOperatorTest) {
//                DomainAccessMask |= ACCESS_SYSTEM_SECURITY;
//            }
            NtStatus = SamOpenDomain(
                           (*ServerHandle),
                           DomainAccessMask,
                           BuiltinDomainSid,
                           BuiltinDomainHandle
                           );

            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            } else {
                printf("Succeeded\n");
            }
        }

    }

    return(TestStatus);


}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Security Manipulation Test Suite                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


BOOLEAN
SecurityTestSuite(
    HANDLE ServerHandle,
    HANDLE DomainHandle,
    ULONG Pass
    )
{

    BOOLEAN                 TestStatus = TRUE;
    NTSTATUS                NtStatus;

    PSECURITY_DESCRIPTOR    OriginalServerSD,
                            OriginalDomainSD,
                            OriginalUserSD,
                            OriginalGroupSD,
                            SD1;

    SECURITY_INFORMATION    SI1;
    PVOID TmpPointer1;

    SECURITY_DESCRIPTOR     SD1_Body;

    HANDLE                  GroupHandle,
                            UserHandle;




    printf("\n");
    printf("\n");
    printf("\n");

    if (Pass == 1) {

        printf("  Security Manipulation (Pass #1)                         Test\n");

        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Query Suite                                                           //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Query Security  . . . . . . . . . . . . . . . . . . .   Suite\n");


        //
        // Get Server's original SD
        //


        SI1 = 0;
        if (AdminsAliasTest) {
            SI1 |= OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                   DACL_SECURITY_INFORMATION;
        }
        if (SecurityOperatorTest) {
            SI1 |= SACL_SECURITY_INFORMATION;
        }
        if (SI1 != 0) {
            printf("      Query Server Security Descriptor  . . . . . . . . . .     ");
            SD1 = NULL;
            NtStatus = SamQuerySecurityObject(
                           ServerHandle,
                           SI1,
                           &SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                TestStatus = CheckReturnedSD( SI1, SD1, TRUE );

                //
                // Normally we would do a "SamFreeMemory( SD1 )" here.
                // However, we want to save this SD for future reference
                // and use.
                //

                OriginalServerSD = SD1;

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }
        }





        //
        // Get domain's original SD
        //


        SI1 = 0;
        if (AdminsAliasTest) {
            SI1 |= OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                   DACL_SECURITY_INFORMATION;
        }
        if (SecurityOperatorTest) {
            SI1 |= SACL_SECURITY_INFORMATION;
        }
        if (SI1 != 0) {
            printf("      Query Domain Security Descriptor  . . . . . . . . . .     ");
            SD1 = NULL;
            NtStatus = SamQuerySecurityObject(
                           DomainHandle,
                           SI1,
                           &SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                TestStatus = CheckReturnedSD( SI1, SD1, TRUE );

                //
                // Normally we would do a "SamFreeMemory( SD1 )" here.
                // However, we want to save this SD for future reference
                // and use.
                //

                OriginalDomainSD = SD1;

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }
        }






        //
        // Make sure the wrapper doesn't choke on a non-null pointer being passed
        // (assuming we have allocated memory).
        //


        SI1 = 0;
        if (AdminsAliasTest) {
            SI1 |= OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                   DACL_SECURITY_INFORMATION;
        }
        if (SecurityOperatorTest) {
            SI1 |= SACL_SECURITY_INFORMATION;
        }
        if (SI1 != 0) {
            printf("      Query Passing Non-null return buffer  . . . . . . . .     ");
            SD1 = RtlAllocateHeap( RtlProcessHeap(), 0, 1000 ); ASSERT(SD1 != NULL);
            TmpPointer1 = SD1;
            NtStatus = SamQuerySecurityObject(
                           DomainHandle,
                           SI1,
                           &SD1
                           );
            if (NT_SUCCESS(NtStatus)) {
                if (SD1 != TmpPointer1) {

                    TestStatus = CheckReturnedSD( SI1, SD1, TRUE );
                    if (TestStatus) {
                        SamFreeMemory( SD1 );
                    }


                } else {
                    printf("Failed\n");
                    printf("        Passed buffer address used on return.\n");
                    printf("        RPC should have allocated another buffer.\n");
                    TestStatus = FALSE;
                }
            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }


            RtlFreeHeap( RtlProcessHeap(), 0, TmpPointer1 );

        }






        //
        // Make sure we can query nothing
        //

        printf("      Query Nothing . . . . . . . . . . . . . . . . . . . .     ");

        SI1 = 0;
        SD1 = NULL;
        NtStatus = SamQuerySecurityObject(
                       DomainHandle,
                       SI1,
                       &SD1
                       );
        if (NT_SUCCESS(NtStatus)) {

            TestStatus = CheckReturnedSD( SI1, SD1, TRUE );
            if (TestStatus) {
                SamFreeMemory( SD1 );
            }

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }





        //
        // Query owner
        //


        if (AdminsAliasTest) {
            printf("      Query Owner (Server Object) . . . . . . . . . . . . .     ");
            SI1 = OWNER_SECURITY_INFORMATION;
            SD1 = NULL;
            NtStatus = SamQuerySecurityObject(
                           ServerHandle,
                           SI1,
                           &SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                TestStatus = CheckReturnedSD( SI1, SD1, TRUE );
                if (TestStatus) {
                    SamFreeMemory( SD1 );
                }

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }
        }




        if (AdminsAliasTest) {
            printf("      Query Owner (Domain Object) . . . . . . . . . . . . .     ");
            SI1 = OWNER_SECURITY_INFORMATION;
            SD1 = NULL;
            NtStatus = SamQuerySecurityObject(
                           DomainHandle,
                           SI1,
                           &SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                TestStatus = CheckReturnedSD( SI1, SD1, TRUE );
                if (TestStatus) {
                    SamFreeMemory( SD1 );
                }

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }
        }





        if (AdminsAliasTest) {

            //
            // Query Group
            //

            printf("      Query Group . . . . . . . . . . . . . . . . . . . . .     ");

            SI1 = GROUP_SECURITY_INFORMATION;
            SD1 = NULL;
            NtStatus = SamQuerySecurityObject(
                           DomainHandle,
                           SI1,
                           &SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                TestStatus = CheckReturnedSD( SI1, SD1, TRUE );
                if (TestStatus) {
                    SamFreeMemory( SD1 );
                }

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }





            //
            // Query Dacl
            //

            printf("      Query DACL  . . . . . . . . . . . . . . . . . . . . .     ");

            SI1 = DACL_SECURITY_INFORMATION;
            SD1 = NULL;
            NtStatus = SamQuerySecurityObject(
                           DomainHandle,
                           SI1,
                           &SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                TestStatus = CheckReturnedSD( SI1, SD1, TRUE );
                if (TestStatus) {
                    SamFreeMemory( SD1 );
                }

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }





            //
            // Query Sacl
            //

            printf("      Query SACL  . . . . . . . . . . . . . . . . . . . . .     ");

            SI1 = SACL_SECURITY_INFORMATION;
            SD1 = NULL;
            NtStatus = SamQuerySecurityObject(
                           DomainHandle,
                           SI1,
                           &SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                TestStatus = CheckReturnedSD( SI1, SD1, TRUE );
                if (TestStatus) {
                    SamFreeMemory( SD1 );
                }

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }

        }  // end_if (AdminsAliasTest)





        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Set Suite                                                             //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Set Security  . . . . . . . . . . . . . . . . . . . .   Suite\n");


        //
        // Make sure we can set nothing
        //

        printf("      Set Nothing . . . . . . . . . . . . . . . . . . . . .     ");

        SI1 = 0;
        SD1 = &SD1_Body;
        NtStatus = RtlCreateSecurityDescriptor( SD1, SECURITY_DESCRIPTOR_REVISION1 );
        ASSERT( NT_SUCCESS(NtStatus) );
        NtStatus = SamSetSecurityObject(
                       DomainHandle,
                       SI1,     // <------ This is invalid
                       SD1
                       );
        if (NtStatus == STATUS_INVALID_PARAMETER) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }






        //
        // set something not passed
        //

        printf("      Set something not passed. . . . . . . . . . . . . . .     ");

        SI1 = GROUP_SECURITY_INFORMATION;
        SD1 = &SD1_Body;
        NtStatus = RtlCreateSecurityDescriptor( SD1, SECURITY_DESCRIPTOR_REVISION1 );
        ASSERT( NT_SUCCESS(NtStatus) );
        NtStatus = SamSetSecurityObject(
                       DomainHandle,
                       SI1,
                       SD1
                       );
        if (NtStatus == STATUS_BAD_DESCRIPTOR_FORMAT) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }






        //
        // set a non-existant DACL
        //

        if (AdminsAliasTest) {
            printf("      Set non-existant DACL (Server object) . . . . . . . .     ");

            SI1 = DACL_SECURITY_INFORMATION;
            SD1 = &SD1_Body;
            NtStatus = RtlCreateSecurityDescriptor( SD1, SECURITY_DESCRIPTOR_REVISION1 );
            SD1_Body.Control = SE_DACL_PRESENT;
            ASSERT( NT_SUCCESS(NtStatus) );
            NtStatus = SamSetSecurityObject(
                           ServerHandle,
                           SI1,
                           SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }
        }



        if (AdminsAliasTest) {
            printf("      Set non-existant DACL (Domain Object) . . . . . . . .     ");

            SI1 = DACL_SECURITY_INFORMATION;
            SD1 = &SD1_Body;
            NtStatus = RtlCreateSecurityDescriptor( SD1, SECURITY_DESCRIPTOR_REVISION1 );
            SD1_Body.Control = SE_DACL_PRESENT;
            ASSERT( NT_SUCCESS(NtStatus) );
            NtStatus = SamSetSecurityObject(
                           DomainHandle,
                           SI1,
                           SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }
        }





        //
        // set original DACL (From original SD)
        //

        if (AdminsAliasTest) {

            printf("      Set original DACL (Server Object) . . . . . . . . . .     ");

            SI1 = DACL_SECURITY_INFORMATION;
            SD1 = OriginalServerSD;
            NtStatus = SamSetSecurityObject(
                           ServerHandle,
                           SI1,
                           SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }
        }



        if (AdminsAliasTest) {

            printf("      Set original DACL (Domain Object) . . . . . . . . . .     ");

            SI1 = DACL_SECURITY_INFORMATION;
            SD1 = OriginalDomainSD;
            NtStatus = SamSetSecurityObject(
                           DomainHandle,
                           SI1,
                           SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }
        }





        if (AdminsAliasTest) {

            //
            // set a non-existant SACL
            //

            printf("      Set non-existant SACL . . . . . . . . . . . . . . . .     ");

            SI1 = SACL_SECURITY_INFORMATION;
            SD1 = &SD1_Body;
            NtStatus = RtlCreateSecurityDescriptor( SD1, SECURITY_DESCRIPTOR_REVISION1 );
            SD1_Body.Control = SE_SACL_PRESENT;
            ASSERT( NT_SUCCESS(NtStatus) );
            NtStatus = SamSetSecurityObject(
                           DomainHandle,
                           SI1,
                           SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }






            //
            // set original SACL (From original SD)
            //

            printf("      Set original SACL . . . . . . . . . . . . . . . . . .     ");

            SI1 = SACL_SECURITY_INFORMATION;
            SD1 = OriginalDomainSD;
            NtStatus = SamSetSecurityObject(
                           DomainHandle,
                           SI1,
                           SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }





            //
            // set a owner to null
            //

            printf("      Set null Owner  . . . . . . . . . . . . . . . . . . .     ");

            SI1 = OWNER_SECURITY_INFORMATION;
            SD1 = &SD1_Body;
            NtStatus = RtlCreateSecurityDescriptor( SD1, SECURITY_DESCRIPTOR_REVISION1 );
            SD1_Body.Owner = NULL;
            ASSERT( NT_SUCCESS(NtStatus) );
            NtStatus = SamSetSecurityObject(
                           DomainHandle,
                           SI1,
                           SD1
                           );
            if (NtStatus == STATUS_BAD_DESCRIPTOR_FORMAT) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }





            //
            // set owner to invalid value
            //

            printf("      Set owner to invalid value  . . . . . . . . . . . . .     ");

            SI1 = OWNER_SECURITY_INFORMATION;
            SD1 = &SD1_Body;
            NtStatus = RtlCreateSecurityDescriptor( SD1, SECURITY_DESCRIPTOR_REVISION1 );
            SD1_Body.Owner = WorldSid;
            ASSERT( NT_SUCCESS(NtStatus) );
            NtStatus = SamSetSecurityObject(
                           DomainHandle,
                           SI1,
                           SD1
                           );
            if (NtStatus == STATUS_INVALID_OWNER) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }




            //
            // set a owner to valid value
            //

            printf("      Set owner to valid value  . . . . . . . . . . . . . .     ");

            printf("Untested\n");





            //
            // set group to null
            //

            printf("      Set null Group  . . . . . . . . . . . . . . . . . . .     ");

            SI1 = GROUP_SECURITY_INFORMATION;
            SD1 = &SD1_Body;
            NtStatus = RtlCreateSecurityDescriptor( SD1, SECURITY_DESCRIPTOR_REVISION1 );
            SD1_Body.Group = NULL;
            ASSERT( NT_SUCCESS(NtStatus) );
            NtStatus = SamSetSecurityObject(
                           DomainHandle,
                           SI1,
                           SD1
                           );
            if (NtStatus == STATUS_BAD_DESCRIPTOR_FORMAT) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }






            //
            // set Group to valid value
            //

            printf("      Set Group to valid value  . . . . . . . . . . . . . .     ");

            SI1 = GROUP_SECURITY_INFORMATION;
            SD1 = &SD1_Body;
            NtStatus = RtlCreateSecurityDescriptor( SD1, SECURITY_DESCRIPTOR_REVISION1 );
            SD1_Body.Group = WorldSid;
            ASSERT( NT_SUCCESS(NtStatus) );
            NtStatus = SamSetSecurityObject(
                           DomainHandle,
                           SI1,
                           SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }





            //
            // set Group back to original value
            //

            printf("      Set Group to original value . . . . . . . . . . . . .     ");

            SI1 = GROUP_SECURITY_INFORMATION;
            SD1 = OriginalDomainSD;
            NtStatus = SamSetSecurityObject(
                           DomainHandle,
                           SI1,
                           SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }
        }




    }   // end Pass1


    if (Pass == 2) {

        ACCESS_MASK         AccessMask;
        PSID_NAME_USE       LookedUpUses;
        PULONG              LookedUpRids;
        UNICODE_STRING      AccountNames[10];
        STRING              AccountNameAnsi;


        //
        // This pass depends upon user and group accounts established in pass #1
        //





        if (AdminsAliasTest) {


            printf("  Security Manipulation (Pass #2)                         Test\n");

            ///////////////////////////////////////////////////////////////////////////
            //                                                                       //
            // Query Suite                                                           //
            //                                                                       //
            ///////////////////////////////////////////////////////////////////////////

            printf("\n");
            printf("    Query Security (User Object). . . . . . . . . . . . .   Suite\n");


            AccessMask = READ_CONTROL;
            if (SecurityOperatorTest) {
                AccessMask |= ACCESS_SYSTEM_SECURITY;
            }

            //
            // Open the user created in pass #1
            //

            RtlInitString( &AccountNameAnsi, USER_NAME1 );
            NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
            TST_SUCCESS_ASSERT(NtStatus);

            NtStatus = SamLookupNamesInDomain(
                           DomainHandle,
                           1,
                           &AccountNames[0],
                           &LookedUpRids,
                           &LookedUpUses
                           );
            RtlFreeUnicodeString( &AccountNames[0] );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(LookedUpUses[0] == SidTypeUser);
            NtStatus = SamOpenUser(
                           DomainHandle,
                           AccessMask,
                           LookedUpRids[0],
                           &UserHandle);
            SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );
            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed to open user account created in pass #1\n");
            }
            TST_SUCCESS_ASSERT(NT_SUCCESS(NtStatus));



            //
            // Get user's original SD
            //

            SI1 |= OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                   DACL_SECURITY_INFORMATION;
            if (SecurityOperatorTest) {
                SI1 |= SACL_SECURITY_INFORMATION;
            }

            printf("      Query User Security Descriptor  . . . . . . . . . . .     ");
            SD1 = NULL;
            NtStatus = SamQuerySecurityObject(
                           UserHandle,
                           SI1,
                           &SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                TestStatus = CheckReturnedSD( SI1, SD1, TRUE );

                //
                // Normally we would do a "SamFreeMemory( SD1 )" here.
                // However, we want to save this SD for future reference
                // and use.
                //

                OriginalUserSD = SD1;

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }





            NtStatus = SamCloseHandle( UserHandle );
            TST_SUCCESS_ASSERT( UserHandle );



            ///////////////////////////////////////////////////////////////////////////
            //                                                                       //
            // Set Suite                                                             //
            //                                                                       //
            ///////////////////////////////////////////////////////////////////////////

            printf("\n");
            printf("    Set Security  (User Object) . . . . . . . . . . . . .   Suite\n");

            AccessMask = WRITE_DAC | WRITE_OWNER;
            if (SecurityOperatorTest) {
                AccessMask |= ACCESS_SYSTEM_SECURITY;
            }

            //
            // Open the user created in pass #1
            //

            RtlInitString( &AccountNameAnsi, USER_NAME1 );
            NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
            TST_SUCCESS_ASSERT(NtStatus);

            NtStatus = SamLookupNamesInDomain(
                           DomainHandle,
                           1,
                           &AccountNames[0],
                           &LookedUpRids,
                           &LookedUpUses
                           );
            RtlFreeUnicodeString( &AccountNames[0] );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(LookedUpUses[0] == SidTypeUser);
            NtStatus = SamOpenUser(
                           DomainHandle,
                           AccessMask,
                           LookedUpRids[0],
                           &UserHandle);
            SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );
            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed to open user account created in pass #1\n");
            }
            TST_SUCCESS_ASSERT(NT_SUCCESS(NtStatus));


            //
            // Make sure we can set nothing
            //

            printf("      Set Nothing . . . . . . . . . . . . . . . . . . . . .     ");

            SI1 = 0;
            SD1 = &SD1_Body;
            NtStatus = RtlCreateSecurityDescriptor( SD1, SECURITY_DESCRIPTOR_REVISION1 );
            ASSERT( NT_SUCCESS(NtStatus) );
            NtStatus = SamSetSecurityObject(
                           UserHandle,
                           SI1,     // <------ This is invalid
                           SD1
                           );
            if (NtStatus == STATUS_INVALID_PARAMETER) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }






            //
            // set something not passed
            //

            printf("      Set something not passed. . . . . . . . . . . . . . .     ");

            SI1 = GROUP_SECURITY_INFORMATION;
            SD1 = &SD1_Body;
            NtStatus = RtlCreateSecurityDescriptor( SD1, SECURITY_DESCRIPTOR_REVISION1 );
            ASSERT( NT_SUCCESS(NtStatus) );
            NtStatus = SamSetSecurityObject(
                           UserHandle,
                           SI1,
                           SD1
                           );
            if (NtStatus == STATUS_BAD_DESCRIPTOR_FORMAT) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }








            printf("      Set non-existant DACL . . . . . . . . . . . . . . . .     ");

            SI1 = DACL_SECURITY_INFORMATION;
            SD1 = &SD1_Body;
            NtStatus = RtlCreateSecurityDescriptor( SD1, SECURITY_DESCRIPTOR_REVISION1 );
            SD1_Body.Control = SE_DACL_PRESENT;
            ASSERT( NT_SUCCESS(NtStatus) );
            NtStatus = SamSetSecurityObject(
                           UserHandle,
                           SI1,
                           SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }






            //
            // set original DACL (From original SD)
            //


            printf("      Set original DACL . . . . . . . . . . . . . . . . . .     ");

            SI1 = DACL_SECURITY_INFORMATION;
            SD1 = OriginalUserSD;
            NtStatus = SamSetSecurityObject(
                           UserHandle,
                           SI1,
                           SD1
                           );
            if (NT_SUCCESS(NtStatus)) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }







            NtStatus = SamCloseHandle( UserHandle );
            TST_SUCCESS_ASSERT( UserHandle );



        }

        DBG_UNREFERENCED_LOCAL_VARIABLE( GroupHandle );
        DBG_UNREFERENCED_LOCAL_VARIABLE( OriginalGroupSD );
    }





    return TestStatus;
}


BOOLEAN
CheckReturnedSD(
    IN SECURITY_INFORMATION SI,
    IN PSECURITY_DESCRIPTOR SD,
    IN BOOLEAN              PrintTestSuccess
    )


{
    NTSTATUS NtStatus;

    BOOLEAN  Failed = FALSE,
             IgnoreBoolean,
             AclPresent,
             TestStatus = TRUE;

    PSID     SID;
    PACL     ACL;



    //
    // Check a returned security descriptor agains the information requested.
    //

    if (SD == NULL) {
        TestStatus = FALSE;
        if (PrintTestSuccess) {
            printf("Failed\n");
            Failed = TRUE;
            printf("        The SecurityDescriptor return address was not properly\n");
            printf("        set.\n");
        }
    }


    if (TestStatus) {

        //
        // Check owner
        //

        NtStatus = RtlGetOwnerSecurityDescriptor ( SD, &SID, &IgnoreBoolean);
        ASSERT(NT_SUCCESS(NtStatus));
        if (SI & OWNER_SECURITY_INFORMATION) {
            if (SID == NULL) {
                if (PrintTestSuccess) {
                    if (!Failed) {
                        printf("Failed\n");
                        printf("        Security descriptor address is 0x%lx\n", SD );
                        Failed = TRUE;
                    }
                    printf("        An owner was requested but the owner field of the\n");
                    printf("        security descriptor is not set.\n");
                    TestStatus = FALSE;

                }
            }
        } else {    // Owner not specified
            if (SID != NULL) {
                if (PrintTestSuccess) {
                    if (!Failed) {
                        printf("Failed\n");
                        printf("        Security descriptor address is 0x%lx\n", SD );
                        Failed = TRUE;
                    }
                    printf("        An owner was not requested but the owner field of the\n");
                    printf("        security descriptor is set.\n");
                    TestStatus = FALSE;
                }
            }
        }




        //
        // Check group
        //

        NtStatus = RtlGetGroupSecurityDescriptor ( SD, &SID, &IgnoreBoolean);
        ASSERT(NT_SUCCESS(NtStatus));
        if (SI & GROUP_SECURITY_INFORMATION) {
            if (SID == NULL) {
                if (PrintTestSuccess) {
                    if (!Failed) {
                        printf("Failed\n");
                        printf("        Security descriptor address is 0x%lx\n", SD );
                        Failed = TRUE;
                    }
                    printf("        A group was requested but the group field of the\n");
                    printf("        security descriptor is not set.\n");
                    TestStatus = FALSE;

                }
            }
        } else {    // Group not specified
            if (SID != NULL) {
                if (PrintTestSuccess) {
                    if (!Failed) {
                        printf("Failed\n");
                        printf("        Security descriptor address is 0x%lx\n", SD );
                        Failed = TRUE;
                    }
                    printf("        A group was not requested but the group field of the\n");
                    printf("        security descriptor is set.\n");
                    TestStatus = FALSE;
                }
            }
        }




        //
        // Check sacl
        //

        NtStatus = RtlGetSaclSecurityDescriptor ( SD, &AclPresent, &ACL, &IgnoreBoolean);
        ASSERT(NT_SUCCESS(NtStatus));
        if (SI & SACL_SECURITY_INFORMATION) {
            if (!AclPresent) {
                if (PrintTestSuccess) {
                    if (!Failed) {
                        printf("Failed\n");
                        printf("        Security descriptor address is 0x%lx\n", SD );
                        Failed = TRUE;
                    }
                    printf("        An SACL was requested but the SaclPresent flag\n");
                    printf("        of the security descriptor is not set.\n");
                    TestStatus = FALSE;

                }
            }
        } else {    // sacl not specified
            if (AclPresent) {
                if (PrintTestSuccess) {
                    if (!Failed) {
                        printf("Failed\n");
                        printf("        Security descriptor address is 0x%lx\n", SD );
                        Failed = TRUE;
                    }
                    printf("        An SACL was not requested but the SaclPresent flag\n");
                    printf("        of the security descriptor is set.\n");
                    TestStatus = FALSE;
                }
            }
        }





        //
        // Check Dacl
        //

        NtStatus = RtlGetDaclSecurityDescriptor ( SD, &AclPresent, &ACL, &IgnoreBoolean);
        ASSERT(NT_SUCCESS(NtStatus));
        if (SI & DACL_SECURITY_INFORMATION) {
            if (!AclPresent) {
                if (PrintTestSuccess) {
                    if (!Failed) {
                        printf("Failed\n");
                        printf("        Security descriptor address is 0x%lx\n", SD );
                        Failed = TRUE;
                    }
                    printf("        A DACL was requested but the DaclPresent flag\n");
                    printf("        of the security descriptor is not set.\n");
                    TestStatus = FALSE;

                }
            }
        } else {    // Dacl not specified
            if (AclPresent) {
                if (PrintTestSuccess) {
                    if (!Failed) {
                        printf("Failed\n");
                        printf("        Security descriptor address is 0x%lx\n", SD );
                        Failed = TRUE;
                    }
                    printf("        A DACL was not requested but the DaclPresent flag\n");
                    printf("        of the security descriptor is set.\n");
                    TestStatus = FALSE;
                }
            }
        }





    }




    if (PrintTestSuccess) {
        if (TestStatus) {
            printf("Succeeded\n");
        }
    }



    return(TestStatus);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Domain Object Test Suite                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


BOOLEAN
DomainTestSuite(
    HANDLE DomainHandle
    )
{

    BOOLEAN  TestStatus = TRUE;
    NTSTATUS NtStatus, IgnoreStatus;
    PVOID    Buffer, Buffer1, Buffer2;
    CHAR     UnusedBuffer[20];
    UNICODE_STRING      AccountName;
    STRING              AccountNameAnsi;
    HANDLE GroupHandle = NULL;
    HANDLE AliasHandle = NULL;
    HANDLE UserHandle = NULL;
    HANDLE ValidUserHandle = NULL;
    ULONG  GroupRid, AliasRid, UserRid, SavedGroupRid, SavedAliasRid, AccountCount, i;
    SAM_ENUMERATE_HANDLE EnumerationContext;
    ULONG   CountReturned;
    USHORT NameLength;
    PUNICODE_STRING  LookedUpNames;
    PSID_NAME_USE    LookedUpUses;
    PULONG           LookedUpRids;


    printf("\n");
    printf("\n");
    printf("\n");
    printf("  Domain                                                  Test\n");

    ///////////////////////////////////////////////////////////////////////////
    //                                                                       //
    // Query Suite                                                           //
    //                                                                       //
    ///////////////////////////////////////////////////////////////////////////

    printf("\n");
    printf("    Query Information . . . . . . . . . . . . . . . . . .   Suite\n");


    //
    // Make sure the wrapper doesn't choke on a non-null pointer being passed
    // (assuming we have allocated memory).
    //

    printf("      Query Buffer Allocation Test  . . . . . . . . . . . .     ");

    Buffer = &UnusedBuffer[0];
    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainStateInformation,
                   &Buffer
                   );
    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != &UnusedBuffer[0]) {
            if (Buffer != NULL) {
                printf("Succeeded\n");
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Passed buffer address used on return.\n");
            printf("        RPC should have allocated another buffer.\n");
            TestStatus = FALSE;
        }
    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }


    //
    // Query all the fixed length info levels
    //  Query - Password, Logoff, ServerRole, DomainState, ModifiedCount, LockoutInfo
    //

    printf("      Query DomainState . . . . . . . . . . . . . . . . . .     ");

    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainStateInformation,
                   &Buffer
                   );
    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {
                printf("Succeeded\n");
                SamFreeMemory( Buffer );
        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            TestStatus = FALSE;
        }
    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;

    }


    printf("      Query ServerRole  . . . . . . . . . . . . . . . . . .     ");
    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainServerRoleInformation,
                   &Buffer
                   );
    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {
                printf("Succeeded\n");
                SamFreeMemory( Buffer );
        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            TestStatus = FALSE;
        }
    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;

    }


    printf("      Query Password Information  . . . . . . . . . . . . .     ");
    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainPasswordInformation,
                   &Buffer
                   );
    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {
                printf("Succeeded\n");
                SamFreeMemory( Buffer );
        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            TestStatus = FALSE;
        }
    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;

    }


    printf("      Query Logoff Information  . . . . . . . . . . . . . .     ");
    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainLogoffInformation,
                   &Buffer
                   );
    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {
                printf("Succeeded\n");
                SamFreeMemory( Buffer );
        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            TestStatus = FALSE;
        }
    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;

    }


    printf("      Query Modified  . . . . . . . . . . . . . . . . . . .     ");
    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainModifiedInformation,
                   &Buffer
                   );
    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {
                printf("Succeeded\n");
                SamFreeMemory( Buffer );
        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            TestStatus = FALSE;
        }
    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;

    }


    printf("      Query Lockout . . . . . . . . . . . . . . . . . . . .     ");
    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainLockoutInformation,
                   &Buffer
                   );
    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {
                printf("Succeeded\n");
                SamFreeMemory( Buffer );
        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            TestStatus = FALSE;
        }
    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;

    }





    //
    // Query the name of the domain ...
    //

    printf("      Query Domain Name . . . . . . . . . . . . . . . . . .     ");

    Buffer = NULL;
    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainNameInformation,
                   &Buffer
                   );
    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {
            if ( (((DOMAIN_NAME_INFORMATION *)Buffer)->DomainName.MaximumLength > 0) &&
                 (((DOMAIN_NAME_INFORMATION *)Buffer)->DomainName.Buffer != NULL) ) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        String body returned and allocated,\n");
                printf("        but character buffer pointer is NULL.\n");
                TestStatus = FALSE;
            }
            SamFreeMemory( Buffer );
        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            TestStatus = FALSE;
        }
    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }



    //
    // Query whatever is in the OEM Information field ...
    //

    printf("      Query OEM Information . . . . . . . . . . . . . . . .     ");

    Buffer = NULL;
    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainOemInformation,
                   &Buffer
                   );
    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {
            if ( (((DOMAIN_OEM_INFORMATION *)Buffer)->OemInformation.MaximumLength >= 0) &&
                 (((DOMAIN_OEM_INFORMATION *)Buffer)->OemInformation.Buffer != NULL) ) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        String body returned and allocated,\n");
                printf("        but character buffer pointer is NULL.\n");
                TestStatus = FALSE;
            }
            SamFreeMemory( Buffer );
        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            TestStatus = FALSE;
        }
    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }



    //
    // Query whatever is in the Replication Information field ...
    //

    printf("      Query Replication Information . . . . . . . . . . . .     ");

    Buffer = NULL;
    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainReplicationInformation,
                   &Buffer
                   );
    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {
            if ( (((DOMAIN_REPLICATION_INFORMATION *)Buffer)->ReplicaSourceNodeName.MaximumLength >= 0) &&
                 (((DOMAIN_REPLICATION_INFORMATION *)Buffer)->ReplicaSourceNodeName.Buffer != NULL) ) {

                printf("Succeeded\n");

            } else {
                printf("Failed\n");
                printf("        String body returned and allocated,\n");
                printf("        but character buffer pointer is NULL.\n");
                TestStatus = FALSE;
            }
            SamFreeMemory( Buffer );
        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            TestStatus = FALSE;
        }
    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }



    //
    // Query domain general Information...
    //

    printf("      Query General Information . . . . . . . . . . . . . .     ");

    Buffer = NULL;
    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainGeneralInformation,
                   &Buffer
                   );
    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {

            printf("Succeeded\n");
            printf("          Number of Users  is: 0x%lx\n",
                 ((DOMAIN_GENERAL_INFORMATION *)Buffer)->UserCount );
            printf("          Number of groups is: 0x%lx\n",
                 ((DOMAIN_GENERAL_INFORMATION *)Buffer)->GroupCount);
            printf("          Number of aliases is: 0x%lx\n",
                 ((DOMAIN_GENERAL_INFORMATION *)Buffer)->AliasCount);


            SamFreeMemory( Buffer );

        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            TestStatus = FALSE;
        }
    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }



    //
    // Query domain general Information...
    //

    printf("      Query General Information 2 . . . . . . . . . . . . .     ");

    Buffer = NULL;
    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainGeneralInformation2,
                   &Buffer
                   );
    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {

            printf("Succeeded\n");
            printf("          Number of Users  is: 0x%lx\n",
                 ((DOMAIN_GENERAL_INFORMATION2 *)Buffer)->I1.UserCount );
            printf("          Number of groups is: 0x%lx\n",
                 ((DOMAIN_GENERAL_INFORMATION2 *)Buffer)->I1.GroupCount);
            printf("          Number of aliases is: 0x%lx\n",
                 ((DOMAIN_GENERAL_INFORMATION2 *)Buffer)->I1.AliasCount);


            SamFreeMemory( Buffer );

        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            TestStatus = FALSE;
        }
    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }








    ///////////////////////////////////////////////////////////////////////////
    //                                                                       //
    // Set Suite                                                             //
    //                                                                       //
    ///////////////////////////////////////////////////////////////////////////

    printf("    Set Information . . . . . . . . . . . . . . . . . . .   Suite\n");

    //
    // Set all the fixed length info levels
    //   - Password, Logoff, ServerRole, DomainState, ModifiedCount
    //

/*
 *  CANT TEST SERVER STATE SETTING WITHOUT BREAKING THE REST OF THE TEST.
 *  THE REASON IS, ONCE THE STATE IS CHANGED, NOTHING ELSE CAN BE DONE.
 *
 *    printf("      Set DomainState . . . . . . . . . . . . . . . . . . .     ");
 *
 *    //
 *    // Get the current value...
 *    //
 *
 *    NtStatus = SamQueryInformationDomain(
 *                   DomainHandle,
 *                   DomainStateInformation,
 *                   &Buffer1
 *                   );
 *    ASSERT( NT_SUCCESS(NtStatus) );
 *
 *    //
 *    // Change the field to a new value and write it out.
 *    //
 *
 *    if ( ((DOMAIN_STATE_INFORMATION *)Buffer1)->DomainServerState ==
 *         DomainServerEnabled ) {
 *        ((DOMAIN_STATE_INFORMATION *)Buffer1)->DomainServerState =
 *            DomainServerDisabled;
 *    } else {
 *        ((DOMAIN_STATE_INFORMATION *)Buffer1)->DomainServerState =
 *            DomainServerEnabled;
 *    }
 *
 *    NtStatus = SamSetInformationDomain(
 *                   DomainHandle,
 *                   DomainStateInformation,
 *                   Buffer1
 *                   );
 *    if ( NT_SUCCESS(NtStatus) ) {
 *
 *        //
 *        // Now check that the change was really made...
 *        //
 *
 *        NtStatus = SamQueryInformationDomain(
 *                       DomainHandle,
 *                       DomainStateInformation,
 *                       &Buffer2
 *                       );
 *        ASSERT(NT_SUCCESS( NtStatus ) );
 *        if (((DOMAIN_STATE_INFORMATION *)Buffer1)->DomainServerState ==
 *            ((DOMAIN_STATE_INFORMATION *)Buffer2)->DomainServerState    ) {
 *
 *                printf("Succeeded\n");
 *
 *        } else {
 *
 *            printf("Failed\n");
 *            printf("        Value queried doesn't match value written\n");
 *            printf("        Value Written is   0x%lx\n",
 *                (ULONG)((DOMAIN_STATE_INFORMATION *)Buffer1)->DomainServerState);
 *            printf("        Value Retrieved is 0x%lx\n",
 *                (ULONG)((DOMAIN_STATE_INFORMATION *)Buffer2)->DomainServerState);
 *
 *            TestStatus = FALSE;
 *
 *        }
 *
 *        SamFreeMemory( Buffer1 );
 *        SamFreeMemory( Buffer2 );
 *
 *    } else {
 *        printf("Failed\n");
 *        printf("        Completion status is 0x%lx\n", NtStatus);
 *        TestStatus = FALSE;
 *        SamFreeMemory( Buffer1 );
 *
 *    }
 */



/*
 *  CANT TEST SERVER ROLE SETTING WITHOUT BREAKING THE REST OF THE TEST.
 *  THE REASON IS, ONCE THE ROLE IS SET TO BACKUP, NOTHING ELSE CAN BE
 *  SET.
 *
 *   printf("      Set ServerRole  . . . . . . . . . . . . . . . . . . .     ");
 *
 *   //
 *   // Get the current value...
 *   //
 *
 *   NtStatus = SamQueryInformationDomain(
 *                  DomainHandle,
 *                  DomainServerRoleInformation,
 *                  &Buffer1
 *                  );
 *   ASSERT( NT_SUCCESS(NtStatus) );
 *
 *   //
 *   // Change the field to a new value and write it out.
 *   //
 *
 *   if ( ((DOMAIN_SERVER_ROLE_INFORMATION *)Buffer1)->DomainServerRole ==
 *        DomainServerRolePrimary ) {
 *       ((DOMAIN_SERVER_ROLE_INFORMATION *)Buffer1)->DomainServerRole =
 *           DomainServerRoleBackup;
 *   } else {
 *       ((DOMAIN_SERVER_ROLE_INFORMATION *)Buffer1)->DomainServerRole =
 *           DomainServerRolePrimary;
 *   }
 *
 *   NtStatus = SamSetInformationDomain(
 *                  DomainHandle,
 *                  DomainServerRoleInformation,
 *                  Buffer1
 *                  );
 *   if ( NT_SUCCESS(NtStatus) ) {
 *
 *       //
 *       // Now check that the change was really made...
 *       //
 *
 *       NtStatus = SamQueryInformationDomain(
 *                      DomainHandle,
 *                      DomainServerRoleInformation,
 *                      &Buffer2
 *                      );
 *       ASSERT(NT_SUCCESS( NtStatus ) );
 *       if (((DOMAIN_SERVER_ROLE_INFORMATION *)Buffer1)->DomainServerRole ==
 *           ((DOMAIN_SERVER_ROLE_INFORMATION *)Buffer2)->DomainServerRole    ) {
 *
 *               printf("Succeeded\n");
 *
 *       } else {
 *
 *           printf("Failed\n");
 *           printf("        Value queried doesn't match value written\n");
 *           printf("        Value Written is   0x%lx\n",
 *               (ULONG)((DOMAIN_SERVER_ROLE_INFORMATION *)Buffer1)->DomainServerRole);
 *           printf("        Value Retrieved is 0x%lx\n",
 *               (ULONG)((DOMAIN_SERVER_ROLE_INFORMATION *)Buffer2)->DomainServerRole);
 *
 *           TestStatus = FALSE;
 *
 *       }
 *
 *       SamFreeMemory( Buffer1 );
 *       SamFreeMemory( Buffer2 );
 *
 *   } else {
 *       printf("Failed\n");
 *       printf("        Completion status is 0x%lx\n", NtStatus);
 *       TestStatus = FALSE;
 *       SamFreeMemory( Buffer1 );
 *
 *   }
 */



    printf("      Set Password Information  . . . . . . . . . . . . . .     ");


    //
    // Get the current value...
    //

    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainPasswordInformation,
                   &Buffer1
                   );
    ASSERT( NT_SUCCESS(NtStatus) );

    //
    // Change a field to a new value and write it out.
    //

    if ( ((DOMAIN_PASSWORD_INFORMATION *)Buffer1)->MinPasswordLength == 0 ) {
         ((DOMAIN_PASSWORD_INFORMATION *)Buffer1)->MinPasswordLength =  6;
    } else {
        ((DOMAIN_PASSWORD_INFORMATION *)Buffer1)->MinPasswordLength =   0;
    }

    //
    // Set PasswordProperties to COMPLEX so that tests run after this one
    // are a little more interesting.
    //

    ((DOMAIN_PASSWORD_INFORMATION *)Buffer1)->PasswordProperties |= DOMAIN_PASSWORD_COMPLEX;

    NtStatus = SamSetInformationDomain(
                   DomainHandle,
                   DomainPasswordInformation,
                   Buffer1
                   );
    if ( NT_SUCCESS(NtStatus) ) {

        //
        // Now check that the change was really made...
        //

        NtStatus = SamQueryInformationDomain(
                       DomainHandle,
                       DomainPasswordInformation,
                       &Buffer2
                       );
        ASSERT(NT_SUCCESS( NtStatus ) );
        if (((DOMAIN_PASSWORD_INFORMATION *)Buffer1)->MinPasswordLength ==
            ((DOMAIN_PASSWORD_INFORMATION *)Buffer2)->MinPasswordLength    ) {

                printf("Succeeded\n");

        } else {

            printf("Failed\n");
            printf("        Value queried doesn't match value written\n");
            printf("        Value Written is   0x%lx\n",
                (ULONG)((DOMAIN_PASSWORD_INFORMATION *)Buffer1)->MinPasswordLength);
            printf("        Value Retrieved is 0x%lx\n",
                (ULONG)((DOMAIN_PASSWORD_INFORMATION *)Buffer2)->MinPasswordLength);

            TestStatus = FALSE;

        }

        SamFreeMemory( Buffer1 );
        SamFreeMemory( Buffer2 );

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
        SamFreeMemory( Buffer1 );

    }



    printf("      Set Logoff Information  . . . . . . . . . . . . . . .     ");

    //
    // Get the current value...
    //

    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainLogoffInformation,
                   &Buffer1
                   );
    ASSERT( NT_SUCCESS(NtStatus) );

    //
    // Change the field to a new value and write it out.
    //

    if ( ((DOMAIN_LOGOFF_INFORMATION *)Buffer1)->ForceLogoff.LowPart == 0 ) {
         ((DOMAIN_LOGOFF_INFORMATION *)Buffer1)->ForceLogoff.LowPart = 1000;
    } else {
        ((DOMAIN_LOGOFF_INFORMATION *)Buffer1)->ForceLogoff.LowPart =   0;
    }

    NtStatus = SamSetInformationDomain(
                   DomainHandle,
                   DomainLogoffInformation,
                   Buffer1
                   );
    if ( NT_SUCCESS(NtStatus) ) {

        //
        // Now check that the change was really made...
        //

        NtStatus = SamQueryInformationDomain(
                       DomainHandle,
                       DomainLogoffInformation,
                       &Buffer2
                       );
        ASSERT(NT_SUCCESS( NtStatus ) );
        if (((DOMAIN_LOGOFF_INFORMATION *)Buffer1)->ForceLogoff.LowPart ==
            ((DOMAIN_LOGOFF_INFORMATION *)Buffer2)->ForceLogoff.LowPart    ) {

                printf("Succeeded\n");

        } else {

            printf("Failed\n");
            printf("        Value queried doesn't match value written\n");
            printf("        Value Written is   0x%lx\n",
                (ULONG)((DOMAIN_LOGOFF_INFORMATION *)Buffer1)->ForceLogoff.LowPart);
            printf("        Value Retrieved is 0x%lx\n",
                (ULONG)((DOMAIN_LOGOFF_INFORMATION *)Buffer2)->ForceLogoff.LowPart);

            TestStatus = FALSE;

        }

        SamFreeMemory( Buffer1 );
        SamFreeMemory( Buffer2 );

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
        SamFreeMemory( Buffer1 );

    }



    printf("      Set Modified  . . . . . . . . . . . . . . . . . . . .     ");


    NtStatus = SamSetInformationDomain(
                   DomainHandle,
                   DomainModifiedInformation,
                   &LargeInteger1
                   );

    if (NtStatus != STATUS_INVALID_INFO_CLASS) {

        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    } else {
        printf("Succeeded\n");
    }


    printf("      Set Lockout Information . . . . . . . . . . . . . . .     ");

    //
    // Get the current value...
    //

    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainLockoutInformation,
                   &Buffer1
                   );
    ASSERT( NT_SUCCESS(NtStatus) );

    //
    // Change the field to a new value and write it out.
    //

    if ( ((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutDuration.LowPart == 0 ) {
         ((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutDuration.LowPart = 9000000;
    } else {
        ((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutDuration.LowPart =   0;
    }
    if ( ((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutObservationWindow.LowPart == 0 ) {
         ((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutObservationWindow.LowPart = 8000000;
    } else {
        ((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutObservationWindow.LowPart =   0;
    }
    if ( ((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutThreshold == 0 ) {
         ((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutThreshold =  2;
    } else {
        ((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutThreshold  =  0;
    }

    NtStatus = SamSetInformationDomain(
                   DomainHandle,
                   DomainLockoutInformation,
                   Buffer1
                   );
    if ( NT_SUCCESS(NtStatus) ) {

        //
        // Now check that the change was really made...
        //

        NtStatus = SamQueryInformationDomain(
                       DomainHandle,
                       DomainLockoutInformation,
                       &Buffer2
                       );
        ASSERT(NT_SUCCESS( NtStatus ) );
        if ( (((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutDuration.LowPart ==
             ((DOMAIN_LOCKOUT_INFORMATION *)Buffer2)->LockoutDuration.LowPart    ) &&
             (((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutObservationWindow.LowPart ==
             ((DOMAIN_LOCKOUT_INFORMATION *)Buffer2)->LockoutObservationWindow.LowPart    ) &&
             (((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutThreshold ==
             ((DOMAIN_LOCKOUT_INFORMATION *)Buffer2)->LockoutThreshold    ) ) {

                printf("Succeeded\n");

        } else {

            printf("Failed\n");
            printf("        Value queried doesn't match value written\n");
            printf("        Duration Written is   0x%lx\n",
                (ULONG)((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutDuration.LowPart);
            printf("        Duration  Retrieved is 0x%lx\n",
                (ULONG)((DOMAIN_LOCKOUT_INFORMATION *)Buffer2)->LockoutDuration.LowPart);
            printf("        Window Written is   0x%lx\n",
                (ULONG)((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutObservationWindow.LowPart);
            printf("        Window  Retrieved is 0x%lx\n",
                (ULONG)((DOMAIN_LOCKOUT_INFORMATION *)Buffer2)->LockoutObservationWindow.LowPart);
            printf("        Duration Written is   0x%lx\n",
                (ULONG)((DOMAIN_LOCKOUT_INFORMATION *)Buffer1)->LockoutThreshold);
            printf("        Duration  Retrieved is 0x%lx\n",
                (ULONG)((DOMAIN_LOCKOUT_INFORMATION *)Buffer2)->LockoutThreshold);

            TestStatus = FALSE;

        }

        SamFreeMemory( Buffer1 );
        SamFreeMemory( Buffer2 );

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
        SamFreeMemory( Buffer1 );

    }




    printf("      Set Domain Name . . . . . . . . . . . . . . . . . . .     ");


    NtStatus = SamSetInformationDomain(
                   DomainHandle,
                   DomainNameInformation,
                   &DummyName1
                   );

    if (NtStatus != STATUS_INVALID_INFO_CLASS) {

        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    } else {
        printf("Succeeded\n");
    }


    printf("      Set OEM Information . . . . . . . . . . . . . . . . .     ");

    //
    // Get the current value...
    //

    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainOemInformation,
                   &Buffer1
                   );
    ASSERT( NT_SUCCESS(NtStatus) );

    //
    // Change the field to a new value and write it out.
    //

    NameLength = ((DOMAIN_OEM_INFORMATION *)Buffer1)->OemInformation.Length;
    if (  NameLength == DummyName1.Length ) {
        ((DOMAIN_OEM_INFORMATION *)Buffer1)->OemInformation = DummyName2;
    } else {
        ((DOMAIN_OEM_INFORMATION *)Buffer1)->OemInformation = DummyName1;
    }

    NtStatus = SamSetInformationDomain(
                   DomainHandle,
                   DomainOemInformation,
                   Buffer1
                   );
    if ( NT_SUCCESS(NtStatus) ) {

        //
        // Now check that the change was really made...
        //

        NtStatus = SamQueryInformationDomain(
                       DomainHandle,
                       DomainOemInformation,
                       &Buffer2
                       );
        ASSERT(NT_SUCCESS( NtStatus ) );
        if (((DOMAIN_OEM_INFORMATION *)Buffer1)->OemInformation.Length ==
            ((DOMAIN_OEM_INFORMATION *)Buffer2)->OemInformation.Length    ) {

            printf("Succeeded\n");

        } else {

            printf("Failed\n");
            printf("        Value queried doesn't match value written\n");
            printf("        Value Written is   0x%lx\n",
                (ULONG)((DOMAIN_OEM_INFORMATION *)Buffer1)->OemInformation.Length);
            printf("        Value Retrieved is 0x%lx\n",
                (ULONG)((DOMAIN_OEM_INFORMATION *)Buffer2)->OemInformation.Length);

            TestStatus = FALSE;

        }

        SamFreeMemory( Buffer1 );
        SamFreeMemory( Buffer2 );

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
        SamFreeMemory( Buffer1 );

    }




    printf("      Set Replication Information . . . . . . . . . . . . .     ");

    //
    // Get the current value...
    //

    NtStatus = SamQueryInformationDomain(
                   DomainHandle,
                   DomainReplicationInformation,
                   &Buffer1
                   );
    ASSERT( NT_SUCCESS(NtStatus) );

    //
    // Change the field to a new value and write it out.
    //

    NameLength = ((DOMAIN_REPLICATION_INFORMATION *)Buffer1)->ReplicaSourceNodeName.Length;
    if (  NameLength == DummyName1.Length ) {
        ((DOMAIN_REPLICATION_INFORMATION *)Buffer1)->ReplicaSourceNodeName = DummyName2;
    } else {
        ((DOMAIN_REPLICATION_INFORMATION *)Buffer1)->ReplicaSourceNodeName = DummyName1;
    }

    NtStatus = SamSetInformationDomain(
                   DomainHandle,
                   DomainReplicationInformation,
                   Buffer1
                   );
    if ( NT_SUCCESS(NtStatus) ) {

        //
        // Now check that the change was really made...
        //

        NtStatus = SamQueryInformationDomain(
                       DomainHandle,
                       DomainReplicationInformation,
                       &Buffer2
                       );
        ASSERT(NT_SUCCESS( NtStatus ) );
        if (((DOMAIN_REPLICATION_INFORMATION *)Buffer1)->ReplicaSourceNodeName.Length ==
            ((DOMAIN_REPLICATION_INFORMATION *)Buffer2)->ReplicaSourceNodeName.Length    ) {

            printf("Succeeded\n");

        } else {

            printf("Failed\n");
            printf("        Value queried doesn't match value written\n");
            printf("        Value Written is   0x%lx\n",
                (ULONG)((DOMAIN_REPLICATION_INFORMATION *)Buffer1)->ReplicaSourceNodeName.Length);
            printf("        Value Retrieved is 0x%lx\n",
                (ULONG)((DOMAIN_REPLICATION_INFORMATION *)Buffer2)->ReplicaSourceNodeName.Length);

            TestStatus = FALSE;

        }

        SamFreeMemory( Buffer1 );
        SamFreeMemory( Buffer2 );

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
        SamFreeMemory( Buffer1 );

    }




    ///////////////////////////////////////////////////////////////////////////
    //                                                                       //
    // Create User/Group/Alias Suite                                         //
    //                                                                       //
    ///////////////////////////////////////////////////////////////////////////

    printf("    Create User/Group/Alias . . . . . . . . . . . . . . . .   Suite\n");


    printf("      Create Group  . . . . . . . . . . . . . . . . . . . .     ");

    RtlInitString( &AccountNameAnsi, GROUP_NAME1 );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);


    //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );

    GroupRid = 0;
    GroupHandle = NULL;
    NtStatus = SamCreateGroupInDomain(
                   DomainHandle,
                   &AccountName,
                   GROUP_ALL_ACCESS,
                   &GroupHandle,
                   &GroupRid
                   );
    RtlFreeUnicodeString( &AccountName );

    if (NT_SUCCESS(NtStatus)) {
        if ( (GroupHandle == NULL) || (GroupRid == 0) ) {

        printf("Failed\n");
        printf("        Invalid GroupHandle or GroupRid returned.\n");
        printf("        Completion status is  0x%lx\n", NtStatus);
        printf("        GroupHandle value is: 0x%lx\n", (ULONG)GroupHandle);
        printf("        GroupRid value is:    0x%lx\n", GroupRid);
        TestStatus = FALSE;
        } else {

            printf("Succeeded\n");
            SavedGroupRid = GroupRid;
            NtStatus = SamCloseHandle( GroupHandle );
            if (!NT_SUCCESS(NtStatus)) {
                printf("        SamCloseHandle() completion status is: 0x%lx\n", NtStatus);
            }
            ASSERT( NT_SUCCESS(NtStatus) );

        }

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }




    printf("      Create Duplicate Group  . . . . . . . . . . . . . . .     ");
    RtlInitString( &AccountNameAnsi, GROUP_NAME1 );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);

    //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );


    GroupRid = 0;
    GroupHandle = NULL;
    NtStatus = SamCreateGroupInDomain(
                   DomainHandle,
                   &AccountName,
                   GROUP_ALL_ACCESS,
                   &GroupHandle,
                   &GroupRid
                   );
    RtlFreeUnicodeString( &AccountName );

    if (NtStatus != STATUS_GROUP_EXISTS) {

        printf("Failed\n");
        printf("        Completion status should be STATUS_GROUP_EXISTS\n");
        printf("        Completion status is  0x%lx\n", NtStatus);
        TestStatus = FALSE;

    } else {

        printf("Succeeded\n");

    }



    printf("      Create Alias  . . . . . . . . . . . . . . . . . . . .     ");

    RtlInitString( &AccountNameAnsi, ALIAS_NAME1 );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);


    AliasRid = 0;
    AliasHandle = NULL;
    NtStatus = SamCreateAliasInDomain(
                   DomainHandle,
                   &AccountName,
                   ALIAS_ALL_ACCESS,
                   &AliasHandle,
                   &AliasRid
                   );
    RtlFreeUnicodeString( &AccountName );

    if (NT_SUCCESS(NtStatus)) {
        if ( (AliasHandle == NULL) || (AliasRid == 0) ) {

        printf("Failed\n");
        printf("        Invalid AliasHandle or AliasRid returned.\n");
        printf("        Completion status is  0x%lx\n", NtStatus);
        printf("        AliasHandle value is: 0x%lx\n", (ULONG)AliasHandle);
        printf("        AliasRid value is:    0x%lx\n", AliasRid);
        TestStatus = FALSE;
        } else {

            printf("Succeeded\n");
            SavedAliasRid = AliasRid;
            NtStatus = SamCloseHandle( AliasHandle );
            if (!NT_SUCCESS(NtStatus)) {
                printf("        SamCloseHandle() completion status is: 0x%lx\n", NtStatus);
            }
            ASSERT( NT_SUCCESS(NtStatus) );


            if (AliasRid == SavedGroupRid) {
                printf("      Create Group/Alias Comparison. . . . . . . . . . . . .     Failed\n");

                printf("        Same RID assigned to new alias and group.\n");
                TestStatus = FALSE;
            }
        }

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }




    printf("      Create another Alias  . . . . . . . . . . . . . . . .     ");

    RtlInitString( &AccountNameAnsi, ALIAS_NAME2 );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);


    AliasRid = 0;
    AliasHandle = NULL;
    NtStatus = SamCreateAliasInDomain(
                   DomainHandle,
                   &AccountName,
                   ALIAS_ALL_ACCESS,
                   &AliasHandle,
                   &AliasRid
                   );
    RtlFreeUnicodeString( &AccountName );

    if (NT_SUCCESS(NtStatus)) {
        if ( (AliasHandle == NULL) || (AliasRid == 0) ) {

        printf("Failed\n");
        printf("        Invalid AliasHandle or AliasRid returned.\n");
        printf("        Completion status is  0x%lx\n", NtStatus);
        printf("        AliasHandle value is: 0x%lx\n", (ULONG)AliasHandle);
        printf("        AliasRid value is:    0x%lx\n", AliasRid);
        TestStatus = FALSE;
        } else {

            printf("Succeeded\n");
            SavedAliasRid = AliasRid;
            NtStatus = SamCloseHandle( AliasHandle );
            if (!NT_SUCCESS(NtStatus)) {
                printf("        SamCloseHandle() completion status is: 0x%lx\n", NtStatus);
            }
            ASSERT( NT_SUCCESS(NtStatus) );


            if (AliasRid == SavedGroupRid) {
                printf("      Create Group/Alias Comparison. . . . . . . . . . . . .     Failed\n");

                printf("        Same RID assigned to new alias and group.\n");
                TestStatus = FALSE;
            }
        }

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }




    printf("      Create Duplicate Alias  . . . . . . . . . . . . . . .     ");
    RtlInitString( &AccountNameAnsi, ALIAS_NAME1 );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);


    AliasRid = 0;
    AliasHandle = NULL;
    NtStatus = SamCreateAliasInDomain(
                   DomainHandle,
                   &AccountName,
                   ALIAS_ALL_ACCESS,
                   &AliasHandle,
                   &AliasRid
                   );
    RtlFreeUnicodeString( &AccountName );

    if (NtStatus != STATUS_ALIAS_EXISTS) {

        printf("Failed\n");
        printf("        Completion status should be STATUS_ALIAS_EXISTS\n");
        printf("        Completion status is  0x%lx\n", NtStatus);
        TestStatus = FALSE;

    } else {

        printf("Succeeded\n");

    }





    printf("      Create User . . . . . . . . . . . . . . . . . . . . .     ");

    RtlInitString( &AccountNameAnsi, USER_NAME1 );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);


    UserRid = 0;
    UserHandle = NULL;
    NtStatus = SamCreateUserInDomain(
                   DomainHandle,
                   &AccountName,
                   USER_ALL_ACCESS,
                   &UserHandle,
                   &UserRid
                   );
    RtlFreeUnicodeString( &AccountName );

    if (NT_SUCCESS(NtStatus)) {
        if ( (UserHandle == NULL) || (UserRid == 0) ) {

        printf("Failed\n");
        printf("        Invalid UserHandle or UserRid returned.\n");
        printf("        Completion status is  0x%lx\n", NtStatus);
        printf("        UserHandle value is: 0x%lx\n", (ULONG)UserHandle);
        printf("        UserRid value is:    0x%lx\n", UserRid);
        TestStatus = FALSE;
        } else {

            printf("Succeeded\n");
            ValidUserHandle = UserHandle;


            if (UserRid == SavedGroupRid) {
                printf("      Create Group/User Comparison. . . . . . . . . . . . .     Failed\n");

                printf("        Same RID assigned to new user and group.\n");
                TestStatus = FALSE;
            }

            if (UserRid == SavedAliasRid) {
                printf("      Create Alias/User Comparison. . . . . . . . . . . . .     Failed\n");

                printf("        Same RID assigned to new user and alias.\n");
                TestStatus = FALSE;
            }
        }

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }







    printf("      Create Duplicate User . . . . . . . . . . . . . . . .     ");

    RtlInitString( &AccountNameAnsi, USER_NAME1 );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);


    UserRid = 0;
    UserHandle = NULL;
    NtStatus = SamCreateUserInDomain(
                   DomainHandle,
                   &AccountName,
                   USER_ALL_ACCESS,
                   &UserHandle,
                   &UserRid
                   );
    RtlFreeUnicodeString( &AccountName );

    if (NtStatus != STATUS_USER_EXISTS) {

        printf("Failed\n");
        printf("        Completion status should be STATUS_USER_EXISTS\n");
        printf("        Completion status is  0x%lx\n", NtStatus);
        TestStatus = FALSE;

    } else {

        printf("Succeeded\n");

    }




    printf("      Create Group With Same Name As User . . . . . . . . .     ");

    RtlInitString( &AccountNameAnsi, USER_NAME1 );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);


    GroupRid = 0;
    GroupHandle = NULL;
    NtStatus = SamCreateGroupInDomain(
                   DomainHandle,
                   &AccountName,
                   GROUP_ALL_ACCESS,
                   &GroupHandle,
                   &GroupRid
                   );
    RtlFreeUnicodeString( &AccountName );

    if (NtStatus != STATUS_USER_EXISTS) {

        printf("Failed\n");
        printf("        Completion status should be STATUS_USER_EXISTS\n");
        printf("        Completion status is  0x%lx\n", NtStatus);
        TestStatus = FALSE;

    } else {

        printf("Succeeded\n");

    }




    printf("      Create Group With Same Name As Alias. . . . . . . . .     ");

    RtlInitString( &AccountNameAnsi, ALIAS_NAME1 );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);


    GroupRid = 0;
    GroupHandle = NULL;
    NtStatus = SamCreateGroupInDomain(
                   DomainHandle,
                   &AccountName,
                   GROUP_ALL_ACCESS,
                   &GroupHandle,
                   &GroupRid
                   );
    RtlFreeUnicodeString( &AccountName );

    if (NtStatus != STATUS_ALIAS_EXISTS) {

        printf("Failed\n");
        printf("        Completion status should be STATUS_ALIAS_EXISTS\n");
        printf("        Completion status is  0x%lx\n", NtStatus);
        TestStatus = FALSE;

    } else {

        printf("Succeeded\n");

    }



    printf("      Create Alias With Same Name As Group. . . . . . . . .     ");

    RtlInitString( &AccountNameAnsi, GROUP_NAME1 );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);


    AliasRid = 0;
    AliasHandle = NULL;
    NtStatus = SamCreateAliasInDomain(
                   DomainHandle,
                   &AccountName,
                   GROUP_ALL_ACCESS,
                   &AliasHandle,
                   &AliasRid
                   );
    RtlFreeUnicodeString( &AccountName );

    if (NtStatus != STATUS_GROUP_EXISTS) {

        printf("Failed\n");
        printf("        Completion status should be STATUS_GROUP_EXISTS\n");
        printf("        Completion status is  0x%lx\n", NtStatus);
        TestStatus = FALSE;

    } else {

        printf("Succeeded\n");

    }



    printf("      Create User With Same Name As Group . . . . . . . . .     ");

    RtlInitString( &AccountNameAnsi, GROUP_NAME1 );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);

    //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );


    UserRid = 0;
    UserHandle = NULL;
    NtStatus = SamCreateUserInDomain(
                   DomainHandle,
                   &AccountName,
                   USER_ALL_ACCESS,
                   &UserHandle,
                   &UserRid
                   );
    RtlFreeUnicodeString( &AccountName );

    if (NtStatus != STATUS_GROUP_EXISTS) {

        printf("Failed\n");
        printf("        Completion status should be STATUS_GROUP_EXISTS\n");
        printf("        Completion status is  0x%lx\n", NtStatus);
        TestStatus = FALSE;

    } else {

        printf("Succeeded\n");

    }



    printf("      Create User With Same Name As Alias . . . . . . . . .     ");

    RtlInitString( &AccountNameAnsi, ALIAS_NAME1 );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
    TST_SUCCESS_ASSERT(NtStatus);


    UserRid = 0;
    UserHandle = NULL;
    NtStatus = SamCreateUserInDomain(
                   DomainHandle,
                   &AccountName,
                   USER_ALL_ACCESS,
                   &UserHandle,
                   &UserRid
                   );
    RtlFreeUnicodeString( &AccountName );

    if (NtStatus != STATUS_ALIAS_EXISTS) {

        printf("Failed\n");
        printf("        Completion status should be STATUS_ALIAS_EXISTS\n");
        printf("        Completion status is  0x%lx\n", NtStatus);
        TestStatus = FALSE;

    } else {

        printf("Succeeded\n");

    }



    ///////////////////////////////////////////////////////////////////////////
    //                                                                       //
    // Call server to test internal functions                                //
    //                                                                       //
    ///////////////////////////////////////////////////////////////////////////

    printf("\n");
    printf("    Test internal functions . . . . . . . . . . . . . . .   Suite\n");
    printf("      Test internal domain functions  . . . . . . . . . .       ");

    NtStatus = SamTestPrivateFunctionsDomain( DomainHandle );

    if ( NT_SUCCESS( NtStatus ) ) {

        printf("Succeeded.\n");

    } else {

        if ( NtStatus == STATUS_NOT_IMPLEMENTED ) {

            printf("Not Implemented\n");

        } else {

            printf("Failed.\n");
            printf("    Status = %lx\n", NtStatus );
            TestStatus = FALSE;
        }
    }

    printf("      Test internal user functions  . . . . . . . . . . .       ");

    if (ValidUserHandle == NULL) {

        printf("Test omitted - Valid User handle not available\n");
        TestStatus = FALSE;

    } else {

        NtStatus = SamTestPrivateFunctionsUser( ValidUserHandle );
        IgnoreStatus = SamCloseHandle( ValidUserHandle );
        ASSERT( NT_SUCCESS(IgnoreStatus) );

        if ( NT_SUCCESS( NtStatus ) ) {

            printf("Succeeded.\n");

        } else {

            if ( NtStatus == STATUS_NOT_IMPLEMENTED ) {

                printf("Not Implemented\n");

            } else {

                printf("Failed.\n");
                printf("    Status = %lx\n", NtStatus );
                TestStatus = FALSE;
            }
        }
    }


    ///////////////////////////////////////////////////////////////////////////
    //                                                                       //
    // Enumerate Users/Groups Suite                                          //
    //                                                                       //
    ///////////////////////////////////////////////////////////////////////////


    printf("    Enumerate Users/Groups/Aliases. . . . . . . . . . . .   Suite\n");

    printf("      Enumerate Groups - large prefered length  . . . . . .     ");


    EnumerationContext = 0;
    NtStatus = SamEnumerateGroupsInDomain(
                   DomainHandle,
                   &EnumerationContext,
                   &Buffer,
                   12000,                   // PreferedMaximumLength
                   &CountReturned
                   );
    AccountCount = CountReturned;       // Save for future test

    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {
            if (NtStatus == STATUS_SUCCESS) {

                if (CountReturned > 1) {
                    printf("Succeeded\n");
                    for (i=0; i<CountReturned; i++) {
                        printf("            Rid/Name(%ld): 0x%lx / %wZ\n",i,
                               ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId,
                              &((PSAM_RID_ENUMERATION)(Buffer))[i].Name
                              );
                    }

                } else {
                    printf("Failed\n");
                    printf("        Completion status is 0x%lx\n", NtStatus);
                    printf("        Expected several entries to be returned.\n");
                    printf("        Received 0x%lx entries instead.\n", CountReturned);
                    TestStatus = FALSE;
                }

            } else {

                printf("Failed\n");
                printf("        Expected STATUS_MORE_ENTRIES to be returned.\n");
                printf("        Received 0x%lx instead.\n", NtStatus);
                printf("        Buffer        = 0x%lx\n", (ULONG)Buffer);
                printf("        CountReturned = 0x%lx\n", CountReturned);
                TestStatus = FALSE;
            }

            SamFreeMemory( Buffer );

        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;

    }




    printf("      Enumerate Groups - small prefered length  . . . . . .     ");


    for ( i=0; i<AccountCount; i++) {
        EnumerationContext = i;
        NtStatus = SamEnumerateGroupsInDomain(
                       DomainHandle,
                       &EnumerationContext,
                       &Buffer,
                       0,                   // PreferedMaximumLength
                       &CountReturned
                       );

        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {
                if ( ((i >= AccountCount -1) && (NtStatus == STATUS_SUCCESS)) ||
                     ((i <= AccountCount -1) && (NtStatus == STATUS_MORE_ENTRIES))  ) {

                    if (CountReturned != 1) {
                        printf("Failed\n");
                        printf("        Completion status is 0x%lx\n", NtStatus);
                        printf("        Expected one entry to be returned.\n");
                        printf("        Received 0x%lx entries instead.\n", CountReturned);
                        TestStatus = FALSE;
                        i = AccountCount + 100;
                    }

                } else {

                    printf("Failed\n");
                    if (i < AccountCount -1 ) {
                        printf("        Expected STATUS_MORE_ENTRIES to be returned.\n");
                    } else {
                        printf("        Expected STATUS_SUCCESS to be returned.\n");
                    }
                    printf("        Received 0x%lx instead.\n", NtStatus);
                    printf("        Buffer        = 0x%lx\n", (ULONG)Buffer);
                    printf("        CountReturned = 0x%lx\n", CountReturned);
                    TestStatus = FALSE;
                    i = AccountCount + 100;
                }

                SamFreeMemory( Buffer );

            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
                i = AccountCount + 100;
            }

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
            i = AccountCount + 100;

        }
    }

    if ( i == AccountCount) {
        printf("Succeeded\n");
    }




    printf("      Enumerate Aliases - large prefered length . . . . . .     ");


    EnumerationContext = 0;
    NtStatus = SamEnumerateAliasesInDomain(
                   DomainHandle,
                   &EnumerationContext,
                   &Buffer,
                   12000,                   // PreferedMaximumLength
                   &CountReturned
                   );
    AccountCount = CountReturned;       // Save for future test

    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {
            if (NtStatus == STATUS_SUCCESS) {

                if (CountReturned > 1) {
                    printf("Succeeded\n");
                    for (i=0; i<CountReturned; i++) {
                        printf("            Rid/Name(%ld): 0x%lx / %wZ\n",i,
                               ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId,
                              &((PSAM_RID_ENUMERATION)(Buffer))[i].Name
                              );
                    }

                } else {
                    printf("Failed\n");
                    printf("        Completion status is 0x%lx\n", NtStatus);
                    printf("        Expected several entries to be returned.\n");
                    printf("        Received 0x%lx entries instead.\n", CountReturned);
                    TestStatus = FALSE;
                }

            } else {

                printf("Failed\n");
                printf("        Expected STATUS_MORE_ENTRIES to be returned.\n");
                printf("        Received 0x%lx instead.\n", NtStatus);
                printf("        Buffer        = 0x%lx\n", (ULONG)Buffer);
                printf("        CountReturned = 0x%lx\n", CountReturned);
                TestStatus = FALSE;
            }

            SamFreeMemory( Buffer );

        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;

    }




    printf("      Enumerate Aliases - small prefered length . . . . . .     ");


    for ( i=0; i<AccountCount; i++) {
        EnumerationContext = i;
        NtStatus = SamEnumerateAliasesInDomain(
                       DomainHandle,
                       &EnumerationContext,
                       &Buffer,
                       0,                   // PreferedMaximumLength
                       &CountReturned
                       );

        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {
                if ( ((i >= AccountCount -1) && (NtStatus == STATUS_SUCCESS)) ||
                     ((i <= AccountCount -1) && (NtStatus == STATUS_MORE_ENTRIES))  ) {

                    if (CountReturned != 1) {
                        printf("Failed\n");
                        printf("        Completion status is 0x%lx\n", NtStatus);
                        printf("        Expected one entry to be returned.\n");
                        printf("        Received 0x%lx entries instead.\n", CountReturned);
                        TestStatus = FALSE;
                        i = AccountCount + 100;
                    }

                } else {

                    printf("Failed\n");
                    if (i < AccountCount -1 ) {
                        printf("        Expected STATUS_MORE_ENTRIES to be returned.\n");
                    } else {
                        printf("        Expected STATUS_SUCCESS to be returned.\n");
                    }
                    printf("        Received 0x%lx instead.\n", NtStatus);
                    printf("        Buffer        = 0x%lx\n", (ULONG)Buffer);
                    printf("        CountReturned = 0x%lx\n", CountReturned);
                    TestStatus = FALSE;
                    i = AccountCount + 100;
                }

                SamFreeMemory( Buffer );

            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
                i = AccountCount + 100;
            }

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
            i = AccountCount + 100;

        }
    }

    if ( i == AccountCount) {
        printf("Succeeded\n");
    }





    printf("      Enumerate Users  - large prefered length  . . . . . .     ");


    EnumerationContext = 0;
    NtStatus = SamEnumerateUsersInDomain(
                   DomainHandle,
                   &EnumerationContext,
                   0,
                   &Buffer,
                   12000,                   // PreferedMaximumLength
                   &CountReturned
                   );
    AccountCount = CountReturned;       // Save for future test

    if (NT_SUCCESS(NtStatus)) {
        if (Buffer != NULL) {
            if (NtStatus == STATUS_SUCCESS) {

                if (CountReturned > 1) {
                    printf("Succeeded\n");
                    for (i=0; i<CountReturned; i++) {
                        printf("            Rid/Name(%ld): 0x%lx / %wZ\n",i,
                               ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId,
                              &((PSAM_RID_ENUMERATION)(Buffer))[i].Name
                              );
                    }

                } else {
                    printf("Failed\n");
                    printf("        Completion status is 0x%lx\n", NtStatus);
                    printf("        Expected several entries to be returned.\n");
                    printf("        Received 0x%lx entries instead.\n", CountReturned);
                    TestStatus = FALSE;
                }

            } else {

                printf("Failed\n");
                printf("        Expected STATUS_MORE_ENTRIES to be returned.\n");
                printf("        Received 0x%lx instead.\n", NtStatus);
                printf("        Buffer        = 0x%lx\n", (ULONG)Buffer);
                printf("        CountReturned = 0x%lx\n", CountReturned);
                TestStatus = FALSE;
            }

            SamFreeMemory( Buffer );

        } else {
            printf("Failed\n");
            printf("        Buffer address not set on return.\n");
            printf("        RPC should have allocated a buffer.\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;

    }




    printf("      Enumerate Users  - small prefered length  . . . . . .     ");


    for ( i=0; i<AccountCount; i++) {
        EnumerationContext = i;
        NtStatus = SamEnumerateUsersInDomain(
                       DomainHandle,
                       &EnumerationContext,
                       0,
                       &Buffer,
                       0,                   // PreferedMaximumLength
                       &CountReturned
                       );

        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {
                if ( ((i >= AccountCount -1) && (NtStatus == STATUS_SUCCESS)) ||
                     ((i <= AccountCount -1) && (NtStatus == STATUS_MORE_ENTRIES))  ) {

                    if (CountReturned != 1) {
                        printf("Failed\n");
                        printf("        Completion status is 0x%lx\n", NtStatus);
                        printf("        Expected one entry to be returned.\n");
                        printf("        Received 0x%lx entries instead.\n", CountReturned);
                        TestStatus = FALSE;
                        i = AccountCount + 100;
                    }

                } else {

                    printf("Failed\n");
                    if (i < AccountCount -1 ) {
                        printf("        Expected STATUS_MORE_ENTRIES to be returned.\n");
                    } else {
                        printf("        Expected STATUS_SUCCESS to be returned.\n");
                    }
                    printf("        Received 0x%lx instead.\n", NtStatus);
                    printf("        Buffer        = 0x%lx\n", (ULONG)Buffer);
                    printf("        CountReturned = 0x%lx\n", CountReturned);
                    TestStatus = FALSE;
                    i = AccountCount + 100;
                }

                SamFreeMemory( Buffer );

            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
                i = AccountCount + 100;
            }

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
            i = AccountCount + 100;

        }
    }

    if ( i == AccountCount) {
        printf("Succeeded\n");
    }










    ///////////////////////////////////////////////////////////////////////////
    //                                                                       //
    // Lookup Names/IDs Suite                                                //
    //                                                                       //
    ///////////////////////////////////////////////////////////////////////////


    // LATER add alias search to lookup name suite.....


    printf("\n");
    printf("    Lookup Names/IDs  . . . . . . . . . . . . . . . . . .   Suite\n");


    printf("      Lookup Names (all existing) . . . . . . . . . . . . .     ");

    NtStatus = SamLookupNamesInDomain(
                   DomainHandle,
                   ALL_NAMES_COUNT,
                   &AllNames[0],
                   &LookedUpRids,
                   &LookedUpUses
                   );


    if (NT_SUCCESS(NtStatus)) {
        ASSERT( LookedUpRids != NULL );
        ASSERT( LookedUpUses != NULL );

        if (
            (LookedUpRids[0] == AllRids[0]) && (LookedUpUses[0] == AllUses[0])
                                            &&
            (LookedUpRids[1] == AllRids[1]) && (LookedUpUses[1] == AllUses[1])
                                            &&
            (LookedUpRids[2] == AllRids[2]) && (LookedUpUses[2] == AllUses[2])
            ) {


            printf("Succeeded\n");


        } else {
            printf("Failed\n");
            printf("        Rids or Uses dont match expected values.\n");
            printf("        Expected Rids:  0x%lx, 0x%lx, 0x%lx\n",
                AllRids[0], AllRids[1], AllRids[2]);
            printf("        Received Rids:  0x%lx, 0x%lx, 0x%lx\n",
                LookedUpRids[0], LookedUpRids[1], LookedUpRids[2]);
            printf("        Expected Uses:  0x%lx, 0x%lx, 0x%lx\n",
                AllUses[0], AllUses[1], AllUses[2]);
            printf("        Received Uses:  0x%lx, 0x%lx, 0x%lx\n",
                LookedUpUses[0], LookedUpUses[1], LookedUpUses[2]);
            TestStatus = FALSE;
        }


        SamFreeMemory( LookedUpRids );
        SamFreeMemory( LookedUpUses );

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }




    printf("      Lookup Names (Some existing)  . . . . . . . . . . . .     ");

    NtStatus = SamLookupNamesInDomain(
                   DomainHandle,
                   SOME_NAMES_COUNT,
                   &SomeNames[0],
                   &LookedUpRids,
                   &LookedUpUses
                   );


    if (NtStatus == STATUS_SOME_NOT_MAPPED) {
        ASSERT( LookedUpRids != NULL );
        ASSERT( LookedUpUses != NULL );

        if (
            (LookedUpRids[0] == SomeRids[0]) && (LookedUpUses[0] == SomeUses[0])
                                             &&
            (LookedUpRids[1] == SomeRids[1]) && (LookedUpUses[1] == SomeUses[1])
                                             &&
            (LookedUpRids[2] == SomeRids[2]) && (LookedUpUses[2] == SomeUses[2])
                                             &&
            (LookedUpRids[3] == SomeRids[3]) && (LookedUpUses[3] == SomeUses[3])
                                             &&
            (LookedUpRids[4] == SomeRids[4]) && (LookedUpUses[4] == SomeUses[4])
                                             &&
            (LookedUpRids[5] == SomeRids[5]) && (LookedUpUses[5] == SomeUses[5])
                                             &&
            (LookedUpRids[6] == SomeRids[6]) && (LookedUpUses[6] == SomeUses[6])
            ) {


            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Rids or Uses dont match expected values.\n");
            printf("        Expected Rids:  0x%lx, 0x%lx, 0x%lx, 0x%lx,  0x%lx, 0x%lx, 0x%lx\n",
                SomeRids[0], SomeRids[1], SomeRids[2], SomeRids[3], SomeRids[4], SomeRids[5], SomeRids[6]);
            printf("        Received Rids:  0x%lx, 0x%lx, 0x%lx, 0x%lx,  0x%lx, 0x%lx, 0x%lx\n",
                LookedUpRids[0], LookedUpRids[1], LookedUpRids[2], LookedUpRids[3], LookedUpRids[4], LookedUpRids[5], LookedUpRids[6]);
            printf("        Expected Uses:  0x%lx, 0x%lx, 0x%lx, 0x%lx,  0x%lx, 0x%lx, 0x%lx\n",
                SomeUses[0], SomeUses[1], SomeUses[2], SomeUses[3], SomeUses[4], SomeUses[5], SomeUses[6]);
            printf("        Received Uses:  0x%lx, 0x%lx, 0x%lx, 0x%lx,  0x%lx, 0x%lx, 0x%lx\n",
                LookedUpUses[0], LookedUpUses[1], LookedUpUses[2], LookedUpUses[3], LookedUpUses[4], LookedUpUses[5], LookedUpUses[2]);
            TestStatus = FALSE;
        }


        SamFreeMemory( LookedUpRids );
        SamFreeMemory( LookedUpUses );

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }



    printf("      Lookup Names (None existing)  . . . . . . . . . . . .     ");

    NtStatus = SamLookupNamesInDomain(
                   DomainHandle,
                   NO_NAMES_COUNT,
                   &NoNames[0],
                   &LookedUpRids,
                   &LookedUpUses
                   );


    if (NtStatus == STATUS_NONE_MAPPED) {
        ASSERT( LookedUpRids == NULL );
        ASSERT( LookedUpUses == NULL );

        printf("Succeeded\n");

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }


 
    printf("      Lookup SIDs (all existing)  . . . . . . . . . . . . .     ");

    NtStatus = SamLookupIdsInDomain(
                   DomainHandle,
                   ALL_NAMES_COUNT,
                   &AllRids[0],
                   &LookedUpNames,
                   &LookedUpUses
                   );


    if (NT_SUCCESS(NtStatus)) {
        ASSERT( LookedUpUses  != NULL );
        ASSERT( LookedUpNames != NULL );
        ASSERT( LookedUpNames[0].Buffer != NULL );
        ASSERT( LookedUpNames[1].Buffer != NULL );
        ASSERT( LookedUpNames[2].Buffer != NULL );

        if (
            (LookedUpUses[0] == AllUses[0]) &&
            (LookedUpUses[1] == AllUses[1]) &&
            (LookedUpUses[2] == AllUses[2]) &&
            !RtlCompareString( (PSTRING)&LookedUpNames[0], (PSTRING)&AllNames[0], TRUE ) &&
            !RtlCompareString( (PSTRING)&LookedUpNames[1], (PSTRING)&AllNames[1], TRUE ) &&
            !RtlCompareString( (PSTRING)&LookedUpNames[2], (PSTRING)&AllNames[2], TRUE )
            ) {


            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Names or Uses dont match expected values.\n");
            printf("        Expected Name[0]:  %wZ\n", &AllNames[0] );
            printf("        Received Name[0]:  %wZ\n", &LookedUpNames[0] );
            printf("        Expected Name[1]:  %wZ\n", &AllNames[1] );
            printf("        Received Name[1]:  %wZ\n", &LookedUpNames[1] );
            printf("        Expected Name[2]:  %wZ\n", &AllNames[2] );
            printf("        Received Name[2]:  %wZ\n", &LookedUpNames[2] );

            printf("        Expected Uses:  0x%lx, 0x%lx, 0x%lx\n",
                AllUses[0], AllUses[1], AllUses[2]);
            printf("        Received Uses:  0x%lx, 0x%lx, 0x%lx\n",
                LookedUpUses[0], LookedUpUses[1], LookedUpUses[2]);
            TestStatus = FALSE;
        }


        SamFreeMemory( LookedUpUses );
        SamFreeMemory( LookedUpNames );

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }




    printf("      Lookup SIDs (Some existing) . . . . . . . . . . . . .     ");

    NtStatus = SamLookupIdsInDomain(
                   DomainHandle,
                   SOME_NAMES_COUNT,
                   &SomeRids[0],
                   &LookedUpNames,
                   &LookedUpUses
                   );


    if (NtStatus == STATUS_SOME_NOT_MAPPED) {
        ASSERT( LookedUpUses  != NULL );
        ASSERT( LookedUpNames != NULL );
        ASSERT( LookedUpNames[0].Buffer != NULL );
        ASSERT( LookedUpNames[1].Buffer != NULL );
        ASSERT( LookedUpNames[2].Buffer == NULL );  // Unknown
        ASSERT( LookedUpNames[3].Buffer == NULL );  // Unknown
        ASSERT( LookedUpNames[4].Buffer == NULL );  // Unknown
        ASSERT( LookedUpNames[5].Buffer != NULL );
        ASSERT( LookedUpNames[6].Buffer == NULL );  // Unknown

        if (
            (LookedUpUses[0] == SomeUses[0]) &&
            (LookedUpUses[1] == SomeUses[1]) &&
            (LookedUpUses[2] == SomeUses[2]) &&
            !RtlCompareString( (PSTRING)&LookedUpNames[0], (PSTRING)&SomeNames[0], TRUE ) &&
            !RtlCompareString( (PSTRING)&LookedUpNames[1], (PSTRING)&SomeNames[1], TRUE ) &&
            !RtlCompareString( (PSTRING)&LookedUpNames[5], (PSTRING)&SomeNames[5], TRUE )
            ) {


            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Names or Uses dont match expected values.\n");
            printf("        Expected Name[0]:  %wZ\n", &SomeNames[0] );
            printf("        Received Name[0]:  %wZ\n", &LookedUpNames[0] );
            printf("        Expected Name[1]:  %wZ\n", &SomeNames[1] );
            printf("        Received Name[1]:  %wZ\n", &LookedUpNames[1] );
            printf("                 Name[2]:  (Unknown)\n");
            printf("                 Name[3]:  (Unknown)\n");
            printf("                 Name[4]:  (Unknown)\n");
            printf("        Expected Name[5]:  %wZ\n", &SomeNames[5] );
            printf("        Received Name[5]:  %wZ\n", &LookedUpNames[5] );
            printf("                 Name[6]:  (Unknown)\n");

            printf("        Expected Uses:  0x%lx, 0x%lx, 0x%lx, 0x%lx,  0x%lx, 0x%lx, 0x%lx\n",
                SomeUses[0], SomeUses[1], SomeUses[2], SomeUses[3], SomeUses[4], SomeUses[5], SomeUses[6]);
            printf("        Received Uses:  0x%lx, 0x%lx, 0x%lx, 0x%lx,  0x%lx, 0x%lx, 0x%lx\n",
                LookedUpUses[0], LookedUpUses[1], LookedUpUses[2], LookedUpUses[3], LookedUpUses[4], LookedUpUses[5], LookedUpUses[2]);
            TestStatus = FALSE;
        }


        SamFreeMemory( LookedUpUses );
        SamFreeMemory( LookedUpNames );

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }




    printf("      Lookup SIDs (None existing) . . . . . . . . . . . . .     ");

    NtStatus = SamLookupIdsInDomain(
                   DomainHandle,
                   NO_NAMES_COUNT,
                   &NoRids[0],
                   &LookedUpNames,
                   &LookedUpUses
                   );


    if (NtStatus == STATUS_NONE_MAPPED) {
        ASSERT( LookedUpUses  == NULL );
        ASSERT( LookedUpNames == NULL );

        printf("Succeeded\n");

    } else {
        printf("Failed\n");
        printf("        Completion status is 0x%lx\n", NtStatus);
        TestStatus = FALSE;
    }







    return TestStatus;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Group  Object Test Suite                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


BOOLEAN
GroupTestSuite(
    HANDLE DomainHandle,
    ULONG  Pass
    )

{
    NTSTATUS            NtStatus, IgnoreStatus;
    HANDLE              GroupHandle1, GroupHandle2, UserHandle1;
    ULONG               CountReturned, NameLength, i, MemberCount;
    ULONG               UserRid, GroupRid;
    PVOID               Buffer, Buffer1, Buffer2;
    SAM_ENUMERATE_HANDLE EnumerationContext;
    PULONG              Members, Attributes;
    PSID_NAME_USE       LookedUpUses;
    PULONG              LookedUpRids;
    UNICODE_STRING      AccountNames[10], AccountName;
    STRING              AccountNameAnsi;

    BOOLEAN             IndividualTestSucceeded, DeleteUser;
    BOOLEAN             TestStatus = TRUE;


    if (Pass == 1) {
        //
        // This test suite assumes that lookup and enumeration API funciton
        // properly.
        //

        printf("\n");
        printf("\n");
        printf("  Group (Pass #1) . . . . . . . . . . . . . . . . . . .   Test\n");

        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Open Group Suite                                                      //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("    Open Group  . . . . . . . . . . . . . . . . . . . . .   Suite\n");
        printf("      Open Groups . . . . . . . . . . . . . . . . . . . . .     ");
        IndividualTestSucceeded = TRUE;
        EnumerationContext = 0;
        NtStatus = SamEnumerateGroupsInDomain(
                       DomainHandle,
                       &EnumerationContext,
                       &Buffer,
                       12000,                   // PreferedMaximumLength
                       &CountReturned
                       );

        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(Buffer != NULL);
        ASSERT(CountReturned > 0);

        for (i=0; i<CountReturned; i++) {

            NtStatus = SamOpenGroup(
                           DomainHandle,
                           GROUP_ALL_ACCESS,
                           ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId,
                           &GroupHandle1
                           );

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamOpenGroup(
                               DomainHandle,
                               GENERIC_READ,
                               ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId,
                               &GroupHandle2
                               );

                if (NT_SUCCESS(NtStatus)) {
                    IgnoreStatus = SamCloseHandle( GroupHandle2 );
                    ASSERT( NT_SUCCESS(IgnoreStatus) );
                } else {
                    printf("Failed\n");
                    printf("        Completion status is 0x%lx\n", NtStatus);
                    printf("        Failed opening group second time.\n");
                    printf("        Rid of account is:   0x%lx\n",
                        ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId);
                    printf("        Name of account is:  %wZ\n",
                        &((PSAM_RID_ENUMERATION)(Buffer))[i].Name );
                    TestStatus = FALSE;
                    IndividualTestSucceeded = FALSE;
                }

                IgnoreStatus = SamCloseHandle( GroupHandle1 );
                ASSERT( NT_SUCCESS(IgnoreStatus) );

            } else {

                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                printf("        Failed opening group for first time.\n");
                printf("        Rid of account is:   0x%lx\n",
                    ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId);
                printf("        Name of account is:  %wZ\n",
                    &((PSAM_RID_ENUMERATION)(Buffer))[i].Name );
                TestStatus = FALSE;
                IndividualTestSucceeded = FALSE;
            }

            if (!IndividualTestSucceeded) {
                printf("                                                                ");
            }
        }


        SamFreeMemory( Buffer );
        if (IndividualTestSucceeded) {
            printf("Succeeded\n");
        }



        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Query     Group Suite                                                 //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Query Group . . . . . . . . . . . . . . . . . . . . .   Suite\n");

        printf("      Query Group General Information . . . . . . . . . . .     ");


        NtStatus = SamOpenGroup(
                       DomainHandle,
                       GROUP_READ_INFORMATION,
                       DOMAIN_GROUP_RID_USERS,
                       &GroupHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationGroup(
                       GroupHandle1,
                       GroupGeneralInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((GROUP_GENERAL_INFORMATION *)Buffer)->Name.MaximumLength > 0) &&
                     (((GROUP_GENERAL_INFORMATION *)Buffer)->Name.Buffer != NULL)  ) {

                    printf("Succeeded\n");

                    printf("        Member Count is:  0x%lx\n",
                     (((GROUP_GENERAL_INFORMATION *)Buffer)->MemberCount) );
                    printf("        Attributes are:   0x%lx\n",
                     (((GROUP_GENERAL_INFORMATION *)Buffer)->Attributes) );
                    printf("        Group Name is:    %wZ\n",
                     &(((GROUP_GENERAL_INFORMATION *)Buffer)->Name) );



                } else {
                    printf("Failed\n");
                    printf("        Group Name not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( GroupHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query Group Name Information  . . . . . . . . . . . .     ");


        NtStatus = SamOpenGroup(
                       DomainHandle,
                       GROUP_READ_INFORMATION,
                       DOMAIN_GROUP_RID_USERS,
                       &GroupHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationGroup(
                       GroupHandle1,
                       GroupNameInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((GROUP_NAME_INFORMATION *)Buffer)->Name.MaximumLength > 0) &&
                     (((GROUP_NAME_INFORMATION *)Buffer)->Name.Buffer != NULL)  ) {

                    printf("Succeeded\n");

                    printf("        Group Name is:    %wZ\n",
                     &(((GROUP_NAME_INFORMATION *)Buffer)->Name) );



                } else {
                    printf("Failed\n");
                    printf("        Group Name not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( GroupHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query Group Admin Comment Information . . . . . . . .     ");


        NtStatus = SamOpenGroup(
                       DomainHandle,
                       GROUP_READ_INFORMATION,
                       DOMAIN_GROUP_RID_USERS,
                       &GroupHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationGroup(
                       GroupHandle1,
                       GroupAdminCommentInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((GROUP_ADM_COMMENT_INFORMATION *)Buffer)->AdminComment.MaximumLength >= 0) ) {

                    printf("Succeeded\n");

                    printf("        Group Admin Comment is:    %wZ\n",
                     &(((GROUP_ADM_COMMENT_INFORMATION *)Buffer)->AdminComment) );



                } else {
                    printf("Failed\n");
                    printf("        Group Admin Comment not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( GroupHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query Group Attribute Information . . . . . . . . . .     ");


        NtStatus = SamOpenGroup(
                       DomainHandle,
                       GROUP_READ_INFORMATION,
                       DOMAIN_GROUP_RID_USERS,
                       &GroupHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationGroup(
                       GroupHandle1,
                       GroupAttributeInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {


                printf("Succeeded\n");

                printf("        Attributes are:   0x%lx\n",
                 (((GROUP_ATTRIBUTE_INFORMATION *)Buffer)->Attributes) );


                SamFreeMemory( Buffer );

            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( GroupHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Get Members Of Group Suite                                            //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Get Members . . . . . . . . . . . . . . . . . . . . .   Suite\n");

        printf("      Get Members of Well-Known Account . . . . . . . . . .     ");

        NtStatus = SamOpenGroup(
                       DomainHandle,
                       GROUP_LIST_MEMBERS,
                       DOMAIN_GROUP_RID_USERS,
                       &GroupHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamGetMembersInGroup(
                       GroupHandle1,
                       &Members,
                       &Attributes,
                       &MemberCount
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Members != NULL || Attributes != NULL) {

                printf("Succeeded\n");


                printf("       Member Count:    %d Users\n", MemberCount);
                for ( i=0; i<MemberCount; i++) {

                    printf("       User[%d] Rid/Attributes:      0x%lx/0x%lx\n",
                        i, Members[i], Attributes[i]);


                }

                SamFreeMemory( Members );
                SamFreeMemory( Attributes );


            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( GroupHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );



        printf("      Get Members of Empty Group. . . . . . . . . . . . . .     ");

        //
        // This group was created earlier in the test
        //

        RtlInitString( &AccountNameAnsi, GROUP_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        NtStatus = SamLookupNamesInDomain(
                       DomainHandle,
                       1,
                       &AccountNames[0],
                       &LookedUpRids,
                       &LookedUpUses
                       );
        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(LookedUpUses[0] == SidTypeGroup);
        RtlFreeUnicodeString( &AccountNames[0] );



        GroupHandle1 = NULL;

        NtStatus = SamOpenGroup( DomainHandle, GROUP_LIST_MEMBERS, LookedUpRids[0], &GroupHandle1 );
        TST_SUCCESS_ASSERT(NtStatus);
        SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );

        NtStatus = SamGetMembersInGroup(
                       GroupHandle1,
                       &Members,
                       &Attributes,
                       &MemberCount
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (MemberCount == 0) {

                printf("Succeeded\n");




            } else {
                printf("Failed\n");
                printf("        Buffer addresses  set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                printf("       Member Count:    %d\n", MemberCount);
                for ( i=0; i<MemberCount; i++) {

                    printf("       User[%d] Rid/Attributes:      0x%lx/0x%lx\n",
                        i, Members[i], Attributes[i]);
                }

                SamFreeMemory( Members );
                SamFreeMemory( Attributes );
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( GroupHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );


        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Set Group Suite  (pass 1)                                             //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Set Group . . . . . . . . . . . . . . . . . . . . . .   Suite\n");


        printf("      Set Attribute . . . . . . . . . . . . . . . . . . . .     ");
        NtStatus = SamOpenGroup(
                       DomainHandle,
                       GROUP_WRITE_ACCOUNT | GROUP_READ_INFORMATION,
                       DOMAIN_GROUP_RID_USERS,
                       &GroupHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer1 = NULL;
        NtStatus = SamQueryInformationGroup(
                       GroupHandle1,
                       GroupAttributeInformation,
                       &Buffer1
                       );
        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(Buffer1 != NULL);

        //
        // Change the value and write it back
        //

        ((GROUP_ATTRIBUTE_INFORMATION *)Buffer1)->Attributes ^=
            SE_GROUP_ENABLED_BY_DEFAULT;


        NtStatus = SamSetInformationGroup(
                       GroupHandle1,
                       GroupAttributeInformation,
                       Buffer1
                       );
        if (NT_SUCCESS(NtStatus)) {

            //
            // Check the written value to make sure it stuck
            //

            Buffer2 = NULL;
            NtStatus = SamQueryInformationGroup(
                           GroupHandle1,
                           GroupAttributeInformation,
                           &Buffer2
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(Buffer2 != NULL);

            if (((GROUP_ATTRIBUTE_INFORMATION *)Buffer1)->Attributes ==
                ((GROUP_ATTRIBUTE_INFORMATION *)Buffer2)->Attributes   ) {

                printf("Succeeded\n");

                SamFreeMemory( Buffer2 );

            } else {
                printf("Failed\n");
                printf("        Returned Value Doesn't Match Set Value.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        SamFreeMemory( Buffer1 );
        IgnoreStatus = SamCloseHandle( GroupHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );





        printf("      Set Admin Comment . . . . . . . . . . . . . . . . . .     ");

            NtStatus = SamOpenGroup(
                           DomainHandle,
                           GROUP_WRITE_ACCOUNT | GROUP_READ_INFORMATION,
                           DOMAIN_GROUP_RID_USERS,
                           &GroupHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            //
            // Get the current value...
            //

            Buffer1 = NULL;
            NtStatus = SamQueryInformationGroup(
                           GroupHandle1,
                           GroupAdminCommentInformation,
                           &Buffer1
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(Buffer1 != NULL);


            //
            // Change the field to a new value and write it out.
            //

            NameLength = ((GROUP_ADM_COMMENT_INFORMATION *)Buffer1)->AdminComment.Length;
            if (  NameLength == DummyString1.Length ) {
                ((GROUP_ADM_COMMENT_INFORMATION *)Buffer1)->AdminComment = DummyString2;
            } else {
                ((GROUP_ADM_COMMENT_INFORMATION *)Buffer1)->AdminComment = DummyString1;
            }

            NtStatus = SamSetInformationGroup(
                           GroupHandle1,
                           GroupAdminCommentInformation,
                           Buffer1
                           );
            if ( NT_SUCCESS(NtStatus) ) {

                //
                // Now check that the change was really made...
                //

                Buffer2 = NULL;
                NtStatus = SamQueryInformationGroup(
                               GroupHandle1,
                               GroupAdminCommentInformation,
                               &Buffer2
                               );
                ASSERT(NT_SUCCESS( NtStatus ) );
                if (
                    !RtlCompareString(
                        (PSTRING)&((GROUP_ADM_COMMENT_INFORMATION *)Buffer1)->AdminComment,
                        (PSTRING)&((GROUP_ADM_COMMENT_INFORMATION *)Buffer2)->AdminComment,
                        TRUE)
                    ) {

                    printf("Succeeded\n");

                } else {

                    printf("Failed\n");
                    printf("        Value queried doesn't match value written\n");
                    printf("        Value Written is   %wZ\n",
                        (PUNICODE_STRING)&((GROUP_ADM_COMMENT_INFORMATION *)Buffer1)->AdminComment);
                    printf("        Value Retrieved is %wZ\n",
                        (PUNICODE_STRING)&((GROUP_ADM_COMMENT_INFORMATION *)Buffer2)->AdminComment);

                    TestStatus = FALSE;

                }

                SamFreeMemory( Buffer1 );
                SamFreeMemory( Buffer2 );

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
                SamFreeMemory( Buffer1 );

            }






    } // END PASS #1
    if (Pass == 2) {

        printf("\n");
        printf("\n");
        printf("  Group (Pass #2) . . . . . . . . . . . . . . . . . . .   Test\n");

        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Delete Group Suite                                                    //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Delete Group  . . . . . . . . . . . . . . . . . . . .   Suite\n");

        printf("      Delete Normal Group . . . . . . . . . . . . . . . . .     ");

        //
        // This group was created in pass #1
        //

        RtlInitString( &AccountNameAnsi, GROUP_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        NtStatus = SamLookupNamesInDomain(
                       DomainHandle,
                       1,
                       &AccountNames[0],
                       &LookedUpRids,
                       &LookedUpUses
                       );
        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(LookedUpUses[0] == SidTypeGroup);
        RtlFreeUnicodeString( &AccountNames[0] );



        GroupHandle1 = NULL;

        NtStatus = SamOpenGroup( DomainHandle, DELETE, LookedUpRids[0], &GroupHandle1 );
        TST_SUCCESS_ASSERT(NtStatus);
        SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );

        NtStatus = SamDeleteGroup( GroupHandle1 );
        if (NT_SUCCESS(NtStatus)) {
            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }




        printf("      Delete Well Known Group . . . . . . . . . . . . . . .     ");

        GroupHandle1 = NULL;

        NtStatus = SamOpenGroup( DomainHandle, DELETE, DOMAIN_GROUP_RID_USERS, &GroupHandle1 );
        TST_SUCCESS_ASSERT(NtStatus);

        NtStatus = SamDeleteGroup( GroupHandle1 );
        if (NtStatus == STATUS_SPECIAL_ACCOUNT) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }

        NtStatus = SamCloseHandle( GroupHandle1 );
        ASSERT(NT_SUCCESS(NtStatus));








        printf("      Delete Primary Group Of A User. . . . . . . . . . . .     ");

        //
        // Make a user (might already exist)
        // Make a group
        // Make the group the user's primary group
        // Attempt to delete the group
        // Change the user so the group isn't the primary group
        // delete the group
        // If we created the user, delete it.

        //
        // The following user might already exist (from earlier in the test)
        //

        RtlInitString( &AccountNameAnsi, USER_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );


        UserRid = 0;
        UserHandle1 = NULL;
        NtStatus = SamCreateUserInDomain(
                       DomainHandle,
                       &AccountName,
                       USER_ALL_ACCESS,
                       &UserHandle1,
                       &UserRid
                       );
        RtlFreeUnicodeString( &AccountName );
        DeleteUser = TRUE;
        if (NtStatus == STATUS_USER_EXISTS) {
            DeleteUser = FALSE;
            RtlInitString( &AccountNameAnsi, USER_NAME1 );
            NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
            TST_SUCCESS_ASSERT(NtStatus);

            NtStatus = SamLookupNamesInDomain(
                           DomainHandle,
                           1,
                           &AccountNames[0],
                           &LookedUpRids,
                           &LookedUpUses
                           );
            RtlFreeUnicodeString( &AccountNames[0] );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(LookedUpUses[0] == SidTypeUser);
            UserRid = LookedUpRids[0];
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_ALL_ACCESS,
                           UserRid,
                           &UserHandle1);
            SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );
        }

        ASSERT(NT_SUCCESS(NtStatus));

        //
        // create the group
        //

        RtlInitString( &AccountNameAnsi, GROUP_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );

        GroupRid = 0;
        GroupHandle1 = NULL;
        NtStatus = SamCreateGroupInDomain(
                       DomainHandle,
                       &AccountName,
                       GROUP_ALL_ACCESS,
                       &GroupHandle1,
                       &GroupRid
                       );
        RtlFreeUnicodeString( &AccountName );
        ASSERT(NT_SUCCESS(NtStatus));

        //
        // Make the user a member of this group
        //

        NtStatus = SamAddMemberToGroup(
                       GroupHandle1,
                       UserRid,
                       SE_GROUP_MANDATORY              |
                           SE_GROUP_ENABLED_BY_DEFAULT |
                           SE_GROUP_ENABLED
                       );
        ASSERT(NT_SUCCESS(NtStatus));




        //
        // Now try to delete the group
        //

        NtStatus = SamDeleteGroup( GroupHandle1 );
        if (NtStatus == STATUS_MEMBER_IN_GROUP) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


        //
        // Now get rid of the group and possibly the user account
        //

        NtStatus = SamRemoveMemberFromGroup(GroupHandle1, UserRid);
        ASSERT(NT_SUCCESS(NtStatus));


        NtStatus = SamDeleteGroup( GroupHandle1 );
        ASSERT(NT_SUCCESS(NtStatus));

        if (DeleteUser == TRUE) {
            NtStatus = SamDeleteUser( UserHandle1 );
            ASSERT(NT_SUCCESS(NtStatus));
        } else {
            NtStatus = SamCloseHandle( UserHandle1 );
            ASSERT(NT_SUCCESS(NtStatus));
        }



        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Add/Remove Member Suite                                               //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Add/Remove Member Suite . . . . . . . . . . . . . . .   Suite\n");

        printf("      Add Member  . . . . . . . . . . . . . . . . . . . . .     ");

        //
        // This test sets things up for the next test
        //

        //
        // The following user might already exist (from earlier in the test)
        //

        RtlInitString( &AccountNameAnsi, USER_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );

        UserRid = 0;
        UserHandle1 = NULL;
        NtStatus = SamCreateUserInDomain(
                       DomainHandle,
                       &AccountName,
                       USER_ALL_ACCESS,
                       &UserHandle1,
                       &UserRid
                       );
        RtlFreeUnicodeString( &AccountName );
        DeleteUser = TRUE;
        if (NtStatus == STATUS_USER_EXISTS) {
            DeleteUser = FALSE;
            RtlInitString( &AccountNameAnsi, USER_NAME1 );
            NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
            TST_SUCCESS_ASSERT(NtStatus);

            NtStatus = SamLookupNamesInDomain(
                           DomainHandle,
                           1,
                           &AccountNames[0],
                           &LookedUpRids,
                           &LookedUpUses
                           );
            RtlFreeUnicodeString( &AccountNames[0] );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(LookedUpUses[0] == SidTypeUser);
            UserRid = LookedUpRids[0];
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_ALL_ACCESS,
                           UserRid,
                           &UserHandle1);
            SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );
        }

        ASSERT(NT_SUCCESS(NtStatus));


        //
        // create the group
        //

        RtlInitString( &AccountNameAnsi, GROUP_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );

        GroupRid = 0;
        GroupHandle1 = NULL;
        NtStatus = SamCreateGroupInDomain(
                       DomainHandle,
                       &AccountName,
                       GROUP_ALL_ACCESS,
                       &GroupHandle1,
                       &GroupRid
                       );
        RtlFreeUnicodeString( &AccountName );
        ASSERT(NT_SUCCESS(NtStatus));

        //
        // Make the user a member of this group
        //

        NtStatus = SamAddMemberToGroup(
                       GroupHandle1,
                       UserRid,
                       SE_GROUP_MANDATORY              |
                           SE_GROUP_ENABLED_BY_DEFAULT |
                           SE_GROUP_ENABLED
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamGetMembersInGroup(
                           GroupHandle1,
                           &Members,
                           &Attributes,
                           &MemberCount
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            NtStatus = STATUS_MEMBER_NOT_IN_GROUP;
            for ( i=0; i<MemberCount; i++) {
                if (Members[i] == UserRid) {
                    NtStatus = STATUS_SUCCESS;
                    break;
                }
            }

            if (NT_SUCCESS(NtStatus)) {
                if (Attributes[i] == (SE_GROUP_MANDATORY          |
                                           SE_GROUP_ENABLED_BY_DEFAULT |
                                           SE_GROUP_ENABLED)) {
                    printf("Succeeded\n");
                } else {
                    printf("Failed\n");
                    printf("Member Added but attributes don't match expected value.\n");
                    printf("Expected value:  0x%lx\n",(SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED));
                    printf("Retrieved value:  0x%lx\n",Attributes[i]);
                    TestStatus = FALSE;
                }
            } else {
                printf("Failed\n");
                printf("Service returned SUCCESS, but user not in member list for group.\n");
                TestStatus = FALSE;
            }


            if (Members != NULL) {
                SamFreeMemory( Members );
                SamFreeMemory( Attributes );
            }


        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }




        printf("      Remove Member . . . . . . . . . . . . . . . . . . . .     ");

        //
        // The previous test sets this one up.
        //

        //
        // Now try to remove the user from the group
        //

        NtStatus = SamRemoveMemberFromGroup(GroupHandle1, UserRid);
        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamGetMembersInGroup(
                           GroupHandle1,
                           &Members,
                           &Attributes,
                           &MemberCount
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            for ( i=0; i<MemberCount; i++) {
                if (Members[i] == UserRid) {
                    NtStatus = STATUS_MEMBER_IN_GROUP;
                    break;
                }
            }

            if (NT_SUCCESS(NtStatus)) {
                printf("Succeeded\n");
            } else {
                printf("Failed\n");
                printf("Service returned SUCCESS, but user still in member list for group.\n");
                TestStatus = FALSE;
            }


            SamFreeMemory( Members );
            SamFreeMemory( Attributes );

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


        //
        // and clean up the user and group accounts
        //

        NtStatus = SamDeleteGroup( GroupHandle1 );
        ASSERT(NT_SUCCESS(NtStatus));

        if (DeleteUser == TRUE) {
            NtStatus = SamDeleteUser( UserHandle1 );
            ASSERT(NT_SUCCESS(NtStatus));
        } else {
            NtStatus = SamCloseHandle( UserHandle1 );
            ASSERT(NT_SUCCESS(NtStatus));
        }






        printf("      Add Non-Existant Member . . . . . . . . . . . . . . .     ");

        //
        // create the group
        //

        RtlInitString( &AccountNameAnsi, GROUP_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );

        GroupRid = 0;
        GroupHandle1 = NULL;
        NtStatus = SamCreateGroupInDomain(
                       DomainHandle,
                       &AccountName,
                       GROUP_ALL_ACCESS,
                       &GroupHandle1,
                       &GroupRid
                       );
        RtlFreeUnicodeString( &AccountName );
        ASSERT(NT_SUCCESS(NtStatus));

        //
        // Specify a non-existant user be added to this group
        //

        UserRid = 30732579;             // Pretty sure this user doesn't exist.
        NtStatus = SamAddMemberToGroup(
                       GroupHandle1,
                       UserRid,
                       SE_GROUP_MANDATORY              |
                           SE_GROUP_ENABLED_BY_DEFAULT |
                           SE_GROUP_ENABLED
                       );

        if (NtStatus == STATUS_NO_SUCH_USER) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


        NtStatus = SamDeleteGroup( GroupHandle1 );
        ASSERT(NT_SUCCESS(NtStatus));




        printf("      Remove Non-existant Member  . . . . . . . . . . . . .     ");

        //
        // create the group
        //

        RtlInitString( &AccountNameAnsi, GROUP_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );

        GroupRid = 0;
        GroupHandle1 = NULL;
        NtStatus = SamCreateGroupInDomain(
                       DomainHandle,
                       &AccountName,
                       GROUP_ALL_ACCESS,
                       &GroupHandle1,
                       &GroupRid
                       );
        RtlFreeUnicodeString( &AccountName );
        ASSERT(NT_SUCCESS(NtStatus));

        //
        // Specify a non-existant user be removed from this group
        //

        UserRid = 30732579;             // Pretty sure this user doesn't exist.
        NtStatus = SamRemoveMemberFromGroup( GroupHandle1, UserRid );

        if (NtStatus == STATUS_NO_SUCH_USER) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


        NtStatus = SamDeleteGroup( GroupHandle1 );
        ASSERT(NT_SUCCESS(NtStatus));




        printf("      Remove Primary Group Of Member  . . . . . . . . . . .     ");


        //
        // Make a user (might already exist)
        // Make a group
        // Make the group the user's primary group
        // Attempt to remove the group (should fail)
        // Change the user so the group isn't the primary group
        // remove the group
        // delete the group
        // If we created the user, delete it.

        //
        // The following user might already exist (from earlier in the test)
        //

        RtlInitString( &AccountNameAnsi, USER_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );

        UserRid = 0;
        UserHandle1 = NULL;
        NtStatus = SamCreateUserInDomain(
                       DomainHandle,
                       &AccountName,
                       USER_ALL_ACCESS,
                       &UserHandle1,
                       &UserRid
                       );
        RtlFreeUnicodeString( &AccountName );
        DeleteUser = TRUE;
        if (NtStatus == STATUS_USER_EXISTS) {
            DeleteUser = FALSE;
            RtlInitString( &AccountNameAnsi, USER_NAME1 );
            NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
            TST_SUCCESS_ASSERT(NtStatus);

            NtStatus = SamLookupNamesInDomain(
                           DomainHandle,
                           1,
                           &AccountNames[0],
                           &LookedUpRids,
                           &LookedUpUses
                           );
            RtlFreeUnicodeString( &AccountNames[0] );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(LookedUpUses[0] == SidTypeUser);
            UserRid = LookedUpRids[0];
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_ALL_ACCESS,
                           UserRid,
                           &UserHandle1);
            SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );
        }

        ASSERT(NT_SUCCESS(NtStatus));


        //
        // create the group
        //

        RtlInitString( &AccountNameAnsi, GROUP_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );

        GroupRid = 0;
        GroupHandle1 = NULL;
        NtStatus = SamCreateGroupInDomain(
                       DomainHandle,
                       &AccountName,
                       GROUP_ALL_ACCESS,
                       &GroupHandle1,
                       &GroupRid
                       );
        RtlFreeUnicodeString( &AccountName );
        ASSERT(NT_SUCCESS(NtStatus));

        //
        // Make the user a member of this group
        //

        NtStatus = SamAddMemberToGroup(
                       GroupHandle1,
                       UserRid,
                       SE_GROUP_MANDATORY              |
                           SE_GROUP_ENABLED_BY_DEFAULT |
                           SE_GROUP_ENABLED
                       );
        ASSERT(NT_SUCCESS(NtStatus));


        //
        // Set the user's primary group Id to be this group
        //

        NtStatus = SamSetInformationUser(
                       UserHandle1,
                       UserPrimaryGroupInformation,
                       &GroupRid
                       );
        ASSERT(NT_SUCCESS(NtStatus));



        //
        // Now try to remove the user from the group
        //

        NtStatus = SamRemoveMemberFromGroup(GroupHandle1, UserRid);
        if (NtStatus == STATUS_MEMBERS_PRIMARY_GROUP) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


        //
        // Set the user's primary group Id back and remove the user
        // from the group
        //

        GroupRid = DOMAIN_GROUP_RID_USERS;
        NtStatus = SamSetInformationUser(
                       UserHandle1,
                       UserPrimaryGroupInformation,
                       &GroupRid
                       );
        ASSERT(NT_SUCCESS(NtStatus));
        NtStatus = SamRemoveMemberFromGroup(GroupHandle1, UserRid);
        ASSERT(NT_SUCCESS(NtStatus));



        //
        // Now get rid of the group and possibly the user account
        //


        NtStatus = SamDeleteGroup( GroupHandle1 );
        ASSERT(NT_SUCCESS(NtStatus));

        if (DeleteUser == TRUE) {
            NtStatus = SamDeleteUser( UserHandle1 );
            ASSERT(NT_SUCCESS(NtStatus));
        } else {
            NtStatus = SamCloseHandle( UserHandle1 );
            ASSERT(NT_SUCCESS(NtStatus));
        }






        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Set Group Suite  (pass 2)                                             //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Set Group . . . . . . . . . . . . . . . . . . . . . .   Suite\n");


        printf("      Set Name  . . . . . . . . . . . . . . . . . . . . . .     ");
        printf("(Untested)\n");


        printf("      Set Name Of Well-Known Account  . . . . . . . . . . .     ");
        printf("(Untested)\n");

    }

    return(TestStatus);

}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Alias  Object Test Suite                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


BOOLEAN
AliasTestSuite(
    HANDLE DomainHandle,
    HANDLE BuiltinDomainHandle,
    PSID   DomainSid,
    ULONG  Pass
    )

{
    NTSTATUS            NtStatus, IgnoreStatus;
    HANDLE              AdminAliasHandle, AliasHandle1, AliasHandle2, UserHandle1, UserHandle2, UserHandle3;
    ULONG               CountReturned, i, MemberCount;
    ULONG               UserRid, UserRid2, UserRid3, AliasRid, AliasRid2;
    PVOID               Buffer, Buffer1, Buffer2;
    ULONG               NameLength;
    SAM_ENUMERATE_HANDLE EnumerationContext;
    PULONG              Members;
    PSID                *AliasMembers;
    PSID_NAME_USE       LookedUpUses;
    PULONG              LookedUpRids;
    UNICODE_STRING      AccountNames[10], AccountName;
    STRING              AccountNameAnsi;
    PSID                UserSid1, UserSid2, GroupSid;

    BOOLEAN             IndividualTestSucceeded, DeleteUser;
    BOOLEAN             TestStatus = TRUE;


    if (Pass == 1) {
        //
        // This test suite assumes that lookup and enumeration API funciton
        // properly.
        //

        printf("\n");
        printf("\n");
        printf("  Alias (Pass #1) . . . . . . . . . . . . . . . . . . .   Test\n");

        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Open Alias Suite                                                      //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("    Open Alias  . . . . . . . . . . . . . . . . . . . . .   Suite\n");
        printf("      Open Aliases . . . . . . . . . . . . . . . . . . . . .     ");
        IndividualTestSucceeded = TRUE;
        EnumerationContext = 0;
        NtStatus = SamEnumerateAliasesInDomain(
                       DomainHandle,
                       &EnumerationContext,
                       &Buffer,
                       12000,                   // PreferedMaximumLength
                       &CountReturned
                       );

        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(Buffer != NULL);
        ASSERT(CountReturned > 0);

        for (i=0; i<CountReturned; i++) {

            NtStatus = SamOpenAlias(
                           DomainHandle,
                           ALIAS_ALL_ACCESS,
                           ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId,
                           &AliasHandle1
                           );

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamOpenAlias(
                               DomainHandle,
                               GENERIC_READ,
                               ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId,
                               &AliasHandle2
                               );

                if (NT_SUCCESS(NtStatus)) {
                    IgnoreStatus = SamCloseHandle( AliasHandle2 );
                    ASSERT( NT_SUCCESS(IgnoreStatus) );
                } else {
                    printf("Failed\n");
                    printf("        Completion status is 0x%lx\n", NtStatus);
                    printf("        Failed opening alias second time.\n");
                    printf("        Rid of account is:   0x%lx\n",
                        ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId);
                    printf("        Name of account is:  %wZ\n",
                        &((PSAM_RID_ENUMERATION)(Buffer))[i].Name );
                    TestStatus = FALSE;
                    IndividualTestSucceeded = FALSE;
                }

                IgnoreStatus = SamCloseHandle( AliasHandle1 );
                ASSERT( NT_SUCCESS(IgnoreStatus) );

            } else {

                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                printf("        Failed opening alias for first time.\n");
                printf("        Rid of account is:   0x%lx\n",
                    ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId);
                printf("        Name of account is:  %wZ\n",
                    &((PSAM_RID_ENUMERATION)(Buffer))[i].Name );
                TestStatus = FALSE;
                IndividualTestSucceeded = FALSE;
            }

            if (!IndividualTestSucceeded) {
                printf("                                                                ");
            }
        }


        SamFreeMemory( Buffer );
        if (IndividualTestSucceeded) {
            printf("Succeeded\n");
        }



        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Query     Alias Suite                                                 //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////


        //
        // Get the rid of an alias created earlier in the test
        //

        RtlInitString( &AccountNameAnsi, ALIAS_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        NtStatus = SamLookupNamesInDomain(
                       DomainHandle,
                       1,
                       &AccountNames[0],
                       &LookedUpRids,
                       &LookedUpUses
                       );
        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(LookedUpUses[0] == SidTypeAlias);
        RtlFreeUnicodeString( &AccountNames[0] );

        AliasRid = LookedUpRids[0];

        SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );


        printf("\n");
        printf("    Query Alias . . . . . . . . . . . . . . . . . . . . .   Suite\n");

        printf("      Query Alias General Information . . . . . . . . . . .     ");


        NtStatus = SamOpenAlias(
                       DomainHandle,
                       ALIAS_READ_INFORMATION,
                       AliasRid,
                       &AliasHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationAlias(
                       AliasHandle1,
                       AliasGeneralInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((ALIAS_GENERAL_INFORMATION *)Buffer)->Name.MaximumLength > 0) &&
                     (((ALIAS_GENERAL_INFORMATION *)Buffer)->Name.Buffer != NULL)  ) {

                    printf("Succeeded\n");

                    printf("        Member Count is:  0x%lx\n",
                     (((ALIAS_GENERAL_INFORMATION *)Buffer)->MemberCount) );
                    printf("        Alias Name is:    %wZ\n",
                     &(((ALIAS_GENERAL_INFORMATION *)Buffer)->Name) );
                    
                } else {
                    printf("Failed\n");
                    printf("        Alias Name not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( AliasHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query Alias Name Information  . . . . . . . . . . . .     ");


        NtStatus = SamOpenAlias(
                       DomainHandle,
                       ALIAS_READ_INFORMATION,
                       AliasRid,
                       &AliasHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationAlias(
                       AliasHandle1,
                       AliasNameInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((ALIAS_NAME_INFORMATION *)Buffer)->Name.MaximumLength > 0) &&
                     (((ALIAS_NAME_INFORMATION *)Buffer)->Name.Buffer != NULL)  ) {

                    printf("Succeeded\n");

                    printf("        Alias Name is:    %wZ\n",
                     &(((ALIAS_NAME_INFORMATION *)Buffer)->Name) );
                } else {
                    printf("Failed\n");
                    printf("        Alias Name not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( AliasHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query Alias Admin Comment Information . . . . . . . .     ");


        NtStatus = SamOpenAlias(
                       DomainHandle,
                       ALIAS_READ_INFORMATION,
                       AliasRid,
                       &AliasHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationAlias(
                       AliasHandle1,
                       AliasAdminCommentInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((ALIAS_ADM_COMMENT_INFORMATION *)Buffer)->AdminComment.MaximumLength >= 0) ) {

                    printf("Succeeded\n");

                    printf("        Alias Admin Comment is:    %wZ\n",
                     &(((ALIAS_ADM_COMMENT_INFORMATION *)Buffer)->AdminComment) );
                } else {
                    printf("Failed\n");
                    printf("        Alias Admin Comment not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( AliasHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );





        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Get Members Of Alias Suite                                            //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Get Members . . . . . . . . . . . . . . . . . . . . .   Suite\n");

#ifdef LATER // ALIAS_LATER - well-know aliases ?


        davidc/chads - this needs to access the builtin domain.

        printf("      Get Members of Well-Known Account . . . . . . . . . .     ");

        NtStatus = SamOpenAlias(
                       DomainHandle,
                       ALIAS_LIST_MEMBERS,
                       DOMAIN_ALIAS_RID_ADMINS,
                       &AliasHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamGetMembersInAlias(
                       AliasHandle1,
                       &AliasMembers,
                       &Attributes,
                       &MemberCount
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Members != NULL || Attributes != NULL) {

                printf("Succeeded\n");


                printf("       Member Count:    %d Users\n", MemberCount);
                for ( i=0; i<MemberCount; i++) {

                    // printf("       User[%d] Sid:      0x%lx\n",
                    //    i, Members[i]);


                }

                SamFreeMemory( AliasMembers );
                SamFreeMemory( Attributes );


            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( AliasHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );
#endif


        printf("      Get Members of Empty Alias. . . . . . . . . . . . . .     ");

        //
        // This alias was created earlier in the test
        //

        RtlInitString( &AccountNameAnsi, ALIAS_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        NtStatus = SamLookupNamesInDomain(
                       DomainHandle,
                       1,
                       &AccountNames[0],
                       &LookedUpRids,
                       &LookedUpUses
                       );
        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(LookedUpUses[0] == SidTypeAlias);
        RtlFreeUnicodeString( &AccountNames[0] );



        AliasHandle1 = NULL;

        NtStatus = SamOpenAlias( DomainHandle, ALIAS_LIST_MEMBERS, LookedUpRids[0], &AliasHandle1 );
        TST_SUCCESS_ASSERT(NtStatus);
        SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );

        NtStatus = SamGetMembersInAlias(
                       AliasHandle1,
                       &AliasMembers,
                       &MemberCount
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (MemberCount == 0) {

                printf("Succeeded\n");




            } else {
                printf("Failed\n");
                printf("       Member Count > 0 :    %d\n", MemberCount);
                for ( i=0; i<MemberCount; i++) {

                    // printf("       User[%d] Rid/Attributes:      0x%lx/0x%lx\n",
                    //    i, Members[i], Attributes[i]);
                }

                SamFreeMemory( AliasMembers );
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( AliasHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );



        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Set Alias Suite  (pass 1)                                             //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Set Alias . . . . . . . . . . . . . . . . . . . . . .   Suite\n");
        //


        // Get the rid of an alias created earlier in the test
        //

        RtlInitString( &AccountNameAnsi, ALIAS_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        NtStatus = SamLookupNamesInDomain(
                       DomainHandle,
                       1,
                       &AccountNames[0],
                       &LookedUpRids,
                       &LookedUpUses
                       );
        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(LookedUpUses[0] == SidTypeAlias);
        RtlFreeUnicodeString( &AccountNames[0] );

        AliasRid = LookedUpRids[0];

        SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );



        printf("      Set Admin Comment . . . . . . . . . . . . . . . . . .     ");

        NtStatus = SamOpenAlias(
                       DomainHandle,
                       ALIAS_WRITE_ACCOUNT | ALIAS_READ_INFORMATION,
                       AliasRid,
                       &AliasHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        //
        // Get the current value...
        //

        Buffer1 = NULL;
        NtStatus = SamQueryInformationAlias(
                       AliasHandle1,
                       AliasAdminCommentInformation,
                       &Buffer1
                       );
        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(Buffer1 != NULL);


        //
        // Change the field to a new value and write it out.
        //

        NameLength = ((ALIAS_ADM_COMMENT_INFORMATION *)Buffer1)->AdminComment.Length;
        if (  NameLength == DummyString1.Length ) {
            ((ALIAS_ADM_COMMENT_INFORMATION *)Buffer1)->AdminComment = DummyString2;
        } else {
            ((ALIAS_ADM_COMMENT_INFORMATION *)Buffer1)->AdminComment = DummyString1;
        }

        NtStatus = SamSetInformationAlias(
                       AliasHandle1,
                       AliasAdminCommentInformation,
                       Buffer1
                       );
        if ( NT_SUCCESS(NtStatus) ) {

            //
            // Now check that the change was really made...
            //

            Buffer2 = NULL;
            NtStatus = SamQueryInformationAlias(
                           AliasHandle1,
                           AliasAdminCommentInformation,
                           &Buffer2
                           );
            ASSERT(NT_SUCCESS( NtStatus ) );
            if (
                !RtlCompareString(
                    (PSTRING)&((ALIAS_ADM_COMMENT_INFORMATION *)Buffer1)->AdminComment,
                    (PSTRING)&((ALIAS_ADM_COMMENT_INFORMATION *)Buffer2)->AdminComment,
                    TRUE)
                ) {

                printf("Succeeded\n");

            } else {

                printf("Failed\n");
                printf("        Value queried doesn't match value written\n");
                printf("        Value Written is   %wZ\n",
                    (PUNICODE_STRING)&((ALIAS_ADM_COMMENT_INFORMATION *)Buffer1)->AdminComment);
                printf("        Value Retrieved is %wZ\n",
                    (PUNICODE_STRING)&((ALIAS_ADM_COMMENT_INFORMATION *)Buffer2)->AdminComment);

                TestStatus = FALSE;

            }

            SamFreeMemory( Buffer1 );
            SamFreeMemory( Buffer2 );

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
            SamFreeMemory( Buffer1 );

        }





    } // END PASS #1
    if (Pass == 2) {

        printf("\n");
        printf("\n");
        printf("  Alias (Pass #2) . . . . . . . . . . . . . . . . . . .   Test\n");

        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Delete Alias Suite                                                    //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Delete Alias  . . . . . . . . . . . . . . . . . . . .   Suite\n");

        printf("      Delete Normal Alias . . . . . . . . . . . . . . . . .     ");

        //
        // This alias was created in pass #1
        //

        RtlInitString( &AccountNameAnsi, ALIAS_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        NtStatus = SamLookupNamesInDomain(
                       DomainHandle,
                       1,
                       &AccountNames[0],
                       &LookedUpRids,
                       &LookedUpUses
                       );
        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(LookedUpUses[0] == SidTypeAlias);
        RtlFreeUnicodeString( &AccountNames[0] );



        AliasHandle1 = NULL;

        NtStatus = SamOpenAlias( DomainHandle, DELETE, LookedUpRids[0], &AliasHandle1 );
        TST_SUCCESS_ASSERT(NtStatus);
        SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );

        NtStatus = SamDeleteAlias( AliasHandle1 );
        if (NT_SUCCESS(NtStatus)) {
            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


#ifdef LATER // ALIAS_LATER - well know aliases ?


        printf("      Delete Well Known Alias . . . . . . . . . . . . . . .     ");

        AliasHandle1 = NULL;

        NtStatus = SamOpenAlias( DomainHandle, DELETE, DOMAIN_GROUP_RID_USERS, &AliasHandle1 );
        TST_SUCCESS_ASSERT(NtStatus);

        NtStatus = SamDeleteAlias( AliasHandle1 );
        if (NtStatus == STATUS_SPECIAL_ACCOUNT) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }

        NtStatus = SamCloseHandle( AliasHandle1 );
        ASSERT(NT_SUCCESS(NtStatus));




        printf("      Delete Admin Alias. . . . . . . . . . . . . . . . . .     ");
        AliasHandle1 = NULL;

        NtStatus = SamOpenAlias( DomainHandle, DELETE, DOMAIN_ALIAS_RID_ADMINS, &AliasHandle1 );
        TST_SUCCESS_ASSERT(NtStatus);

        NtStatus = SamDeleteAlias( AliasHandle1 );
        if (NtStatus == STATUS_SPECIAL_ACCOUNT) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }

        NtStatus = SamCloseHandle( AliasHandle1 );
        ASSERT(NT_SUCCESS(NtStatus));


#endif



        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Add/Remove Member Suite                                               //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Add/Remove Member Suite . . . . . . . . . . . . . . .   Suite\n");

        printf("      Add Member  . . . . . . . . . . . . . . . . . . . . .     ");

        //
        // This test sets things up for the next test
        //

        //
        // The following user might already exist (from earlier in the test)
        //

        RtlInitString( &AccountNameAnsi, USER_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        UserRid = 0;
        UserHandle1 = NULL;
        NtStatus = SamCreateUserInDomain(
                       DomainHandle,
                       &AccountName,
                       USER_ALL_ACCESS,
                       &UserHandle1,
                       &UserRid
                       );
        RtlFreeUnicodeString( &AccountName );
        DeleteUser = TRUE;
        if (NtStatus == STATUS_USER_EXISTS) {
            DeleteUser = FALSE;
            RtlInitString( &AccountNameAnsi, USER_NAME1 );
            NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
            TST_SUCCESS_ASSERT(NtStatus);

            NtStatus = SamLookupNamesInDomain(
                           DomainHandle,
                           1,
                           &AccountNames[0],
                           &LookedUpRids,
                           &LookedUpUses
                           );
            RtlFreeUnicodeString( &AccountNames[0] );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(LookedUpUses[0] == SidTypeUser);
            UserRid = LookedUpRids[0];
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_ALL_ACCESS,
                           UserRid,
                           &UserHandle1);
            SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );
        }

        ASSERT(NT_SUCCESS(NtStatus));

        //
        // This account won't exist yet
        //

        RtlInitString( &AccountNameAnsi, USER_NAME2 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        UserRid2 = 0;
        UserHandle2 = NULL;
        NtStatus = SamCreateUserInDomain(
                       DomainHandle,
                       &AccountName,
                       USER_ALL_ACCESS,
                       &UserHandle2,
                       &UserRid2
                       );
        RtlFreeUnicodeString( &AccountName );

        ASSERT(NT_SUCCESS(NtStatus));


        //
        // create the alias
        //

        RtlInitString( &AccountNameAnsi, ALIAS_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        AliasRid = 0;
        AliasHandle1 = NULL;
        NtStatus = SamCreateAliasInDomain(
                       DomainHandle,
                       &AccountName,
                       ALIAS_ALL_ACCESS,
                       &AliasHandle1,
                       &AliasRid
                       );
        RtlFreeUnicodeString( &AccountName );
        ASSERT(NT_SUCCESS(NtStatus));

        //
        // Make user1 a member of this alias
        //

        UserSid1 = CreateUserSid(DomainSid, UserRid);
        ASSERT(UserSid1 != NULL);

        UserSid2 = CreateUserSid(DomainSid, UserRid2);
        ASSERT(UserSid2 != NULL);



        NtStatus = SamAddMemberToAlias(
                       AliasHandle1,
                       UserSid1
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamGetMembersInAlias(
                           AliasHandle1,
                           &AliasMembers,
                           &MemberCount
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
            for ( i=0; i<MemberCount; i++) {
                if (RtlEqualSid(AliasMembers[i], UserSid1)) {
                    NtStatus = STATUS_SUCCESS;
                    break;
                }
            }

            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed\n");
                printf("Service returned SUCCESS, but user not in member list for alias.\n");
                printf("Member list :\n");
                for (i=0; i<MemberCount; i++) {
                    printfSid(AliasMembers[i]);
                    printf("\n");
                }
                DebugBreak();
                TestStatus = FALSE;
            }


            if (AliasMembers != NULL) {
                SamFreeMemory( AliasMembers );
            }


            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamGetAliasMembership(
                               DomainHandle,
                               1,
                               &UserSid1,
                               &MemberCount,
                               &Members
                               );
                ASSERT(NT_SUCCESS(NtStatus));

                NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
                for ( i=0; i<MemberCount; i++) {
                    if (Members[i] == AliasRid) {
                        NtStatus = STATUS_SUCCESS;
                        break;
                    }
                }

                if (!NT_SUCCESS(NtStatus)) {
                    printf("Failed\n");
                    printf("Service returned SUCCESS, but alias not in account alias membership list.\n");
                    printf("Alias Membership :\n");
                    for (i=0; i<MemberCount; i++) {
                        printf("0x%lx\n", Members[i]);
                    }
                    DebugBreak();
                    TestStatus = FALSE;
                }

                if (Members != NULL) {
                    SamFreeMemory( Members );
                }


                //
                // Check for correct alias membership for multiple accounts
                // User1 should be in alias1
                // User2 should be no aliases.
                //

                if (NT_SUCCESS(NtStatus)) {

                    PSID    SidArray[2];
                    SidArray[0] = UserSid1;
                    SidArray[1] = UserSid2;

                    NtStatus = SamGetAliasMembership(
                                   DomainHandle,
                                   2,
                                   SidArray,
                                   &MemberCount,
                                   &Members
                                   );
                    ASSERT(NT_SUCCESS(NtStatus));

                    if (MemberCount != 1) {

                        printf("Failed\n");
                        printf("Service returned SUCCESS, but combined alias membership count for 2 accounts not correct.\n");
                        printf("Combined Alias Membership :\n");
                        for (i=0; i<MemberCount; i++) {
                            printf("0x%lx\n", Members[i]);
                        }
                        DebugBreak();
                        TestStatus = FALSE;

                    } else {

                        if (Members[0] != AliasRid) {
                            printf("Failed\n");
                            printf("Service returned SUCCESS, but combined alias membership for 2 accounts not correct.\n");
                            printf("Combined Alias Membership :\n");
                            for (i=0; i<MemberCount; i++) {
                                printf("0x%lx\n", Members[i]);
                            }
                            DebugBreak();
                            TestStatus = FALSE;

                        } else {
                            printf("Succeeded\n");
                        }
                    }

                    if (Members != NULL) {
                        SamFreeMemory( Members );
                    }
                }
            }


        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }







        printf("      Add another member to another alias . . . . . . . . .     ");






        //
        // Make user2 a member of alias2
        //

        //
        // This alias was created in pass #1
        //

        RtlInitString( &AccountNameAnsi, ALIAS_NAME2 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        NtStatus = SamLookupNamesInDomain(
                       DomainHandle,
                       1,
                       &AccountNames[0],
                       &LookedUpRids,
                       &LookedUpUses
                       );
        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(LookedUpUses[0] == SidTypeAlias);
        RtlFreeUnicodeString( &AccountNames[0] );

        AliasHandle2 = NULL;
        AliasRid2 = LookedUpRids[0];

        NtStatus = SamOpenAlias( DomainHandle, ALIAS_ALL_ACCESS, LookedUpRids[0], &AliasHandle2 );
        TST_SUCCESS_ASSERT(NtStatus);
        SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );


        NtStatus = SamAddMemberToAlias(
                       AliasHandle2,
                       UserSid2
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamGetMembersInAlias(
                           AliasHandle2,
                           &AliasMembers,
                           &MemberCount
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
            for ( i=0; i<MemberCount; i++) {
                if (RtlEqualSid(AliasMembers[i], UserSid2)) {
                    NtStatus = STATUS_SUCCESS;
                    break;
                }
            }

            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed\n");
                printf("Service returned SUCCESS, but user not in member list for alias.\n");
                printf("Member list :\n");
                for (i=0; i<MemberCount; i++) {
                    printfSid(AliasMembers[i]);
                    printf("\n");
                }
                DebugBreak();
                TestStatus = FALSE;
            }


            if (AliasMembers != NULL) {
                SamFreeMemory( AliasMembers );
            }


            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamGetAliasMembership(
                               DomainHandle,
                               1,
                               &UserSid2,
                               &MemberCount,
                               &Members
                               );
                ASSERT(NT_SUCCESS(NtStatus));

                NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
                for ( i=0; i<MemberCount; i++) {
                    if (Members[i] == AliasRid2) {
                        NtStatus = STATUS_SUCCESS;
                        break;
                    }
                }

                if (!NT_SUCCESS(NtStatus)) {
                    printf("Failed\n");
                    printf("Service returned SUCCESS, but alias not in account alias membership list.\n");
                    printf("Alias Membership :\n");
                    for (i=0; i<MemberCount; i++) {
                        printf("0x%lx\n", Members[i]);
                    }
                    DebugBreak();
                    TestStatus = FALSE;
                }

                if (Members != NULL) {
                    SamFreeMemory( Members );
                }

                //
                // Check for correct alias membership for multiple accounts
                // User1 should be in alias1
                // User2 should be in alias2.
                //

                if (NT_SUCCESS(NtStatus)) {

                    PSID    SidArray[2];
                    SidArray[0] = UserSid1;
                    SidArray[1] = UserSid2;

                    NtStatus = SamGetAliasMembership(
                                   DomainHandle,
                                   2,
                                   SidArray,
                                   &MemberCount,
                                   &Members
                                   );
                    ASSERT(NT_SUCCESS(NtStatus));

                    if (MemberCount != 2) {

                        printf("Failed\n");
                        printf("Service returned SUCCESS, but combined alias membership count for 2 accounts not correct.\n");
                        printf("Combined Alias Membership :\n");
                        for (i=0; i<MemberCount; i++) {
                            printf("0x%lx\n", Members[i]);
                        }
                        DebugBreak();
                        TestStatus = FALSE;

                    } else {

                        if (((Members[0] == AliasRid) && (Members[1] == AliasRid2)) ||
                            ((Members[0] == AliasRid2) && (Members[1] == AliasRid)) ) {
                            printf("Succeeded\n");
                        } else {
                            printf("Failed\n");
                            printf("Service returned SUCCESS, but combined alias membership for 2 accounts not correct.\n");
                            printf("Combined Alias Membership :\n");
                            for (i=0; i<MemberCount; i++) {
                                printf("0x%lx\n", Members[i]);
                            }
                            DebugBreak();
                            TestStatus = FALSE;
                        }
                    }

                    if (Members != NULL) {
                        SamFreeMemory( Members );
                    }
                }
            }


        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


        //
        // Remove user2 from alias2 again
        //

        NtStatus = SamRemoveMemberFromAlias(
                       AliasHandle2,
                       UserSid2
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamGetMembersInAlias(
                           AliasHandle2,
                           &AliasMembers,
                           &MemberCount
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
            for ( i=0; i<MemberCount; i++) {
                if (RtlEqualSid(AliasMembers[i], UserSid2)) {
                    NtStatus = STATUS_SUCCESS;
                    break;
                }
            }

            if (NtStatus != STATUS_MEMBER_NOT_IN_ALIAS) {
                printf("Failed\n");
                printf("Service returned SUCCESS, but user still in member list for alias.\n");
                printf("Member list :\n");
                for (i=0; i<MemberCount; i++) {
                    printfSid(AliasMembers[i]);
                    printf("\n");
                }
                DebugBreak();
                TestStatus = FALSE;
            }


            if (AliasMembers != NULL) {
                SamFreeMemory( AliasMembers );
            }


            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamGetAliasMembership(
                               DomainHandle,
                               1,
                               &UserSid2,
                               &MemberCount,
                               &Members
                               );
                ASSERT(NT_SUCCESS(NtStatus));

                for ( i=0; i<MemberCount; i++) {
                    if (Members[i] == AliasRid2) {
                        NtStatus = STATUS_MEMBER_IN_ALIAS;
                        break;
                    }
                }

                if (!NT_SUCCESS(NtStatus)) {
                    printf("Failed\n");
                    printf("Service returned SUCCESS, but alias still in account alias membership list.\n");
                    printf("Alias Membership :\n");
                    for (i=0; i<MemberCount; i++) {
                        printf("0x%lx\n", Members[i]);
                    }
                    DebugBreak();
                    TestStatus = FALSE;
                }

                if (Members != NULL) {
                    SamFreeMemory( Members );
                }

                //
                // Check for correct alias membership for multiple accounts
                // User1 should be in alias1
                // User2 should be in no aliases.
                //

                if (NT_SUCCESS(NtStatus)) {

                    PSID    SidArray[2];
                    SidArray[0] = UserSid1;
                    SidArray[1] = UserSid2;

                    NtStatus = SamGetAliasMembership(
                                   DomainHandle,
                                   2,
                                   SidArray,
                                   &MemberCount,
                                   &Members
                                   );
                    ASSERT(NT_SUCCESS(NtStatus));

                    if (MemberCount != 1) {

                        printf("Failed\n");
                        printf("Service returned SUCCESS, but combined alias membership count for 2 accounts not correct.\n");
                        printf("Combined Alias Membership :\n");
                        for (i=0; i<MemberCount; i++) {
                            printf("0x%lx\n", Members[i]);
                        }
                        DebugBreak();
                        TestStatus = FALSE;

                    } else {

                        if (Members[0] == AliasRid) {
                            printf("Succeeded\n");
                        } else {
                            printf("Failed\n");
                            printf("Service returned SUCCESS, but combined alias membership for 2 accounts not correct.\n");
                            printf("Combined Alias Membership :\n");
                            for (i=0; i<MemberCount; i++) {
                                printf("0x%lx\n", Members[i]);
                            }
                            DebugBreak();
                            TestStatus = FALSE;
                        }
                    }

                    if (Members != NULL) {
                        SamFreeMemory( Members );
                    }
                }
            }


        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


        NtStatus = SamCloseHandle( AliasHandle2 );
        ASSERT(NT_SUCCESS(NtStatus));





        printf("      Add Another Member  . . . . . . . . . . . . . . . . .     ");


        //
        // Make user2 a member of this alias
        //

        NtStatus = SamAddMemberToAlias(
                       AliasHandle1,
                       UserSid2
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamGetMembersInAlias(
                           AliasHandle1,
                           &AliasMembers,
                           &MemberCount
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
            for ( i=0; i<MemberCount; i++) {
                if (RtlEqualSid(AliasMembers[i], UserSid2)) {
                    NtStatus = STATUS_SUCCESS;
                    break;
                }
            }

            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed\n");
                printf("Service returned SUCCESS, but user not in member list for alias.\n");
                printf("Member list :\n");
                for (i=0; i<MemberCount; i++) {
                    printfSid(AliasMembers[i]);
                    printf("\n");
                }
                DebugBreak();
                TestStatus = FALSE;
            }


            if (AliasMembers != NULL) {
                SamFreeMemory( AliasMembers );
            }


            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamGetAliasMembership(
                               DomainHandle,
                               1,
                               &UserSid2,
                               &MemberCount,
                               &Members
                               );
                ASSERT(NT_SUCCESS(NtStatus));

                NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
                for ( i=0; i<MemberCount; i++) {
                    if (Members[i] == AliasRid) {
                        NtStatus = STATUS_SUCCESS;
                        break;
                    }
                }

                if (!NT_SUCCESS(NtStatus)) {
                    printf("Failed\n");
                    printf("Service returned SUCCESS, but alias not in account alias membership list.\n");
                    printf("Alias Membership :\n");
                    for (i=0; i<MemberCount; i++) {
                        printf("0x%lx\n", Members[i]);
                    }
                    DebugBreak();
                    TestStatus = FALSE;
                }

                if (Members != NULL) {
                    SamFreeMemory( Members );
                }

                //
                // Check for correct alias membership for multiple accounts
                // User1 should be in alias1
                // User2 should be in alias1.
                //

                if (NT_SUCCESS(NtStatus)) {

                    PSID    SidArray[2];
                    SidArray[0] = UserSid1;
                    SidArray[1] = UserSid2;

                    NtStatus = SamGetAliasMembership(
                                   DomainHandle,
                                   2,
                                   SidArray,
                                   &MemberCount,
                                   &Members
                                   );
                    ASSERT(NT_SUCCESS(NtStatus));

                    if (MemberCount != 1) {

                        printf("Failed\n");
                        printf("Service returned SUCCESS, but combined alias membership count for 2 accounts not correct.\n");
                        printf("Combined Alias Membership :\n");
                        for (i=0; i<MemberCount; i++) {
                            printf("0x%lx\n", Members[i]);
                        }
                        DebugBreak();
                        TestStatus = FALSE;

                    } else {

                        if (Members[0] != AliasRid) {
                            printf("Failed\n");
                            printf("Service returned SUCCESS, but combined alias membership for 2 accounts not correct.\n");
                            printf("Combined Alias Membership :\n");
                            for (i=0; i<MemberCount; i++) {
                                printf("0x%lx\n", Members[i]);
                            }
                            DebugBreak();
                            TestStatus = FALSE;

                        } else {
                            printf("Succeeded\n");
                        }
                    }

                    if (Members != NULL) {
                        SamFreeMemory( Members );
                    }
                }
            }


        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


        printf("      Remove Member . . . . . . . . . . . . . . . . . . . .     ");

        //
        // The previous test sets this one up.
        //

        //
        // Now try to remove the user from the alias
        //

        NtStatus = SamRemoveMemberFromAlias(AliasHandle1, UserSid1);
        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamGetMembersInAlias(
                           AliasHandle1,
                           &AliasMembers,
                           &MemberCount
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            for ( i=0; i<MemberCount; i++) {
                if (RtlEqualSid(AliasMembers[i], UserSid1)) {
                    NtStatus = STATUS_MEMBER_IN_ALIAS;
                    break;
                }
            }

            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed\n");
                printf("Service returned SUCCESS, but user still in member list for alias.\n");
                printf("Member list :\n");
                for (i=0; i<MemberCount; i++) {
                    printfSid(AliasMembers[i]);
                    printf("\n");
                }
                DebugBreak();
                TestStatus = FALSE;
            }

            SamFreeMemory( AliasMembers );

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamGetAliasMembership(
                               DomainHandle,
                               1,
                               &UserSid1,
                               &MemberCount,
                               &Members
                               );
                ASSERT(NT_SUCCESS(NtStatus));

                for ( i=0; i<MemberCount; i++) {
                    if (Members[i] == AliasRid) {
                        NtStatus = STATUS_MEMBER_IN_ALIAS;
                        break;
                    }
                }

                if (!NT_SUCCESS(NtStatus)) {
                    printf("Failed\n");
                    printf("Service returned SUCCESS, but alias still in account alias membership list.\n");
                    printf("Alias Membership :\n");
                    for (i=0; i<MemberCount; i++) {
                        printf("0x%lx\n", Members[i]);
                    }
                    DebugBreak();
                    TestStatus = FALSE;
                }

                if (Members != NULL) {
                    SamFreeMemory( Members );
                }

                //
                // Check for correct alias membership for multiple accounts
                // User1 should be in no aliases
                // User2 should be in alias1.
                //

                if (NT_SUCCESS(NtStatus)) {

                    PSID    SidArray[2];
                    SidArray[0] = UserSid1;
                    SidArray[1] = UserSid2;

                    NtStatus = SamGetAliasMembership(
                                   DomainHandle,
                                   2,
                                   SidArray,
                                   &MemberCount,
                                   &Members
                                   );
                    ASSERT(NT_SUCCESS(NtStatus));

                    if (MemberCount != 1) {

                        printf("Failed\n");
                        printf("Service returned SUCCESS, but combined alias membership count for 2 accounts not correct.\n");
                        printf("Combined Alias Membership :\n");
                        for (i=0; i<MemberCount; i++) {
                            printf("0x%lx\n", Members[i]);
                        }
                        DebugBreak();
                        TestStatus = FALSE;

                    } else {

                        if (Members[0] != AliasRid) {
                            printf("Failed\n");
                            printf("Service returned SUCCESS, but combined alias membership for 2 accounts not correct.\n");
                            printf("Combined Alias Membership :\n");
                            for (i=0; i<MemberCount; i++) {
                                printf("0x%lx\n", Members[i]);
                            }
                            DebugBreak();
                            TestStatus = FALSE;

                        } else {
                            printf("Succeeded\n");
                        }
                    }

                    if (Members != NULL) {
                        SamFreeMemory( Members );
                    }
                }
            }

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }




        printf("      Add A User to ADMIN Alias . . . . . . . . . . . . . .     ");

        //
        // Make user2 a member of the ADMIN alias
        //

        NtStatus = SamOpenAlias(
                       BuiltinDomainHandle,
                       ALIAS_ALL_ACCESS,
                       DOMAIN_ALIAS_RID_ADMINS,
                       &AdminAliasHandle
                       );

        ASSERT( NT_SUCCESS( NtStatus ) );

        NtStatus = SamAddMemberToAlias(
                       AdminAliasHandle,
                       UserSid2
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamGetMembersInAlias(
                           AdminAliasHandle,
                           &AliasMembers,
                           &MemberCount
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
            for ( i=0; i<MemberCount; i++) {
                if (RtlEqualSid(AliasMembers[i], UserSid2)) {
                    NtStatus = STATUS_SUCCESS;
                    break;
                }
            }

            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed\n");
                printf("Service returned SUCCESS, but user not in member list for alias.\n");
                printf("Member list :\n");
                for (i=0; i<MemberCount; i++) {
                    printfSid(AliasMembers[i]);
                    printf("\n");
                }
                DebugBreak();
                TestStatus = FALSE;
            }


            if (AliasMembers != NULL) {
                SamFreeMemory( AliasMembers );
            }


            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamGetAliasMembership(
                               BuiltinDomainHandle,
                               1,
                               &UserSid2,
                               &MemberCount,
                               &Members
                               );
                ASSERT(NT_SUCCESS(NtStatus));

                NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
                for ( i=0; i<MemberCount; i++) {
                    if (Members[i] == DOMAIN_ALIAS_RID_ADMINS) {
                        NtStatus = STATUS_SUCCESS;
                        break;
                    }
                }

                if (!NT_SUCCESS(NtStatus)) {
                    printf("Failed\n");
                    printf("Service returned SUCCESS, but alias not in account alias membership list.\n");
                    printf("Alias Membership :\n");
                    for (i=0; i<MemberCount; i++) {
                        printf("0x%lx\n", Members[i]);
                    }
                    DebugBreak();
                    TestStatus = FALSE;

                } else {

                    printf("Succeeded\n");
                }

                if (Members != NULL) {
                    SamFreeMemory( Members );
                }
            }


        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


        printf("      Add A Group to ADMIN Alias . . . . . . . . . . . . . .     ");

        //
        // Make a group a member of the ADMIN alias
        //

        GroupSid = CreateUserSid(DomainSid, DOMAIN_GROUP_RID_USERS );
        ASSERT(GroupSid != NULL);

        NtStatus = SamAddMemberToAlias(
                       AdminAliasHandle,
                       GroupSid
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamGetMembersInAlias(
                           AdminAliasHandle,
                           &AliasMembers,
                           &MemberCount
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
            for ( i=0; i<MemberCount; i++) {
                if (RtlEqualSid(AliasMembers[i], GroupSid)) {
                    NtStatus = STATUS_SUCCESS;
                    break;
                }
            }

            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed\n");
                printf("Service returned SUCCESS, but user not in member list for alias.\n");
                printf("Member list :\n");
                for (i=0; i<MemberCount; i++) {
                    printfSid(AliasMembers[i]);
                    printf("\n");
                }
                DebugBreak();
                TestStatus = FALSE;
            }


            if (AliasMembers != NULL) {
                SamFreeMemory( AliasMembers );
            }


            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamGetAliasMembership(
                               BuiltinDomainHandle,
                               1,
                               &GroupSid,
                               &MemberCount,
                               &Members
                               );
                ASSERT(NT_SUCCESS(NtStatus));

                NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
                for ( i=0; i<MemberCount; i++) {
                    if (Members[i] == DOMAIN_ALIAS_RID_ADMINS) {
                        NtStatus = STATUS_SUCCESS;
                        break;
                    }
                }

                if (!NT_SUCCESS(NtStatus)) {
                    printf("Failed\n");
                    printf("Service returned SUCCESS, but alias not in account alias membership list.\n");
                    printf("Alias Membership :\n");
                    for (i=0; i<MemberCount; i++) {
                        printf("0x%lx\n", Members[i]);
                    }
                    DebugBreak();
                    TestStatus = FALSE;

                } else {

                    printf("Succeeded\n");
                }

                if (Members != NULL) {
                    SamFreeMemory( Members );
                }
            }


        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


// NOTE: user is already created in the group below.  Should keep this
// test, AND add another with an all-new group that's been added to the ADMIN
// alias (then ADD user to group, rather than create in it).
        printf("      Create user in ADMIN ALIAS'd Group. . . . . . . . . . .     ");

        RtlInitString( &AccountNameAnsi, USER_NAME3 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        UserRid3 = 0;
        UserHandle3 = NULL;
        NtStatus = SamCreateUserInDomain(
                       DomainHandle,
                       &AccountName,
                       USER_ALL_ACCESS,
                       &UserHandle3,
                       &UserRid3
                       );
        RtlFreeUnicodeString( &AccountName );

        if ( NT_SUCCESS( NtStatus ) ) {

            printf("Succeeded\n");

        } else {

            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }



//NOTE: doesn't work because this is primary group.
//put back in when all-new group is created, above
//        printf("      Remove user from ADMIN ALIAS'd Group. . . . . . . . . . .     ");
//
//        NtStatus = SamOpenGroup(
//                       DomainHandle,
//                       GROUP_ALL_ACCESS,
//                       DOMAIN_GROUP_RID_USERS,
//                       &GroupHandle
//                       );
//
//        ASSERT(NT_SUCCESS(NtStatus));
//
//        NtStatus = SamRemoveMemberFromGroup(
//                       GroupHandle,
//                       UserRid3
//                       );
//
//        if ( NT_SUCCESS( NtStatus ) ) {
//
//            printf("Succeeded\n");
//
//        } else {
//
//            printf("Failed\n");
//            printf("        Completion status is 0x%lx\n", NtStatus);
//            TestStatus = FALSE;
//        }
//
//        IgnoreStatus = SamCloseHandle( GroupHandle );
//        ASSERT(NT_SUCCESS(IgnoreStatus));
        IgnoreStatus = SamCloseHandle( UserHandle3 );
        ASSERT(NT_SUCCESS(IgnoreStatus));



        printf("      Remove User from ADMIN alias. . . . . . . . . . .     ");

        //
        // The previous test sets this one up.
        //
        // Now try to remove the user from the alias
        //

        NtStatus = SamRemoveMemberFromAlias(AdminAliasHandle, UserSid2);
        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamGetMembersInAlias(
                           AdminAliasHandle,
                           &AliasMembers,
                           &MemberCount
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            for ( i=0; i<MemberCount; i++) {
                if (RtlEqualSid(AliasMembers[i], UserSid2)) {
                    NtStatus = STATUS_MEMBER_IN_ALIAS;
                    break;
                }
            }

            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed\n");
                printf("Service returned SUCCESS, but user still in member list for alias.\n");
                printf("Member list :\n");
                for (i=0; i<MemberCount; i++) {
                    printfSid(AliasMembers[i]);
                    printf("\n");
                }
                DebugBreak();
                TestStatus = FALSE;
            }

            SamFreeMemory( AliasMembers );

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamGetAliasMembership(
                               BuiltinDomainHandle,
                               1,
                               &UserSid2,
                               &MemberCount,
                               &Members
                               );
                ASSERT(NT_SUCCESS(NtStatus));

                for ( i=0; i<MemberCount; i++) {
                    if (Members[i] == DOMAIN_ALIAS_RID_ADMINS) {
                        NtStatus = STATUS_MEMBER_IN_ALIAS;
                        break;
                    }
                }

                if (!NT_SUCCESS(NtStatus)) {
                    printf("Failed\n");
                    printf("Service returned SUCCESS, but alias still in account alias membership list.\n");
                    printf("Alias Membership :\n");
                    for (i=0; i<MemberCount; i++) {
                        printf("0x%lx\n", Members[i]);
                    }
                    DebugBreak();
                    TestStatus = FALSE;

                } else {

                    printf("Succeeded\n");
                }

                if (Members != NULL) {
                    SamFreeMemory( Members );
                }
            }

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }




        //
        // Make user2 a member of the ADMIN alias again, so we can test
        // the new function SamRemoveMemberFromForeignDomain().
        // NOTE: we should make this a real test item.
        //

        NtStatus = SamAddMemberToAlias(
                       AdminAliasHandle,
                       UserSid2
                       );

        ASSERT (NT_SUCCESS(NtStatus));

        NtStatus = SamRemoveMemberFromForeignDomain(
                       BuiltinDomainHandle,
                       UserSid2 );

        ASSERT (NT_SUCCESS(NtStatus));



        printf("      Remove Group from ADMIN alias. . . . . . . . . . .     ");

        //
        // The previous test sets this one up.
        //
        // Now try to remove the group from the alias
        //

        NtStatus = SamRemoveMemberFromAlias(AdminAliasHandle, GroupSid);
        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamGetMembersInAlias(
                           AdminAliasHandle,
                           &AliasMembers,
                           &MemberCount
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            for ( i=0; i<MemberCount; i++) {
                if (RtlEqualSid(AliasMembers[i], GroupSid)) {
                    NtStatus = STATUS_MEMBER_IN_ALIAS;
                    break;
                }
            }

            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed\n");
                printf("Service returned SUCCESS, but user still in member list for alias.\n");
                printf("Member list :\n");
                for (i=0; i<MemberCount; i++) {
                    printfSid(AliasMembers[i]);
                    printf("\n");
                }
                DebugBreak();
                TestStatus = FALSE;
            }

            SamFreeMemory( AliasMembers );

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamGetAliasMembership(
                               BuiltinDomainHandle,
                               1,
                               &GroupSid,
                               &MemberCount,
                               &Members
                               );
                ASSERT(NT_SUCCESS(NtStatus));

                for ( i=0; i<MemberCount; i++) {
                    if (Members[i] == DOMAIN_ALIAS_RID_ADMINS) {
                        NtStatus = STATUS_MEMBER_IN_ALIAS;
                        break;
                    }
                }

                if (!NT_SUCCESS(NtStatus)) {
                    printf("Failed\n");
                    printf("Service returned SUCCESS, but alias still in account alias membership list.\n");
                    printf("Alias Membership :\n");
                    for (i=0; i<MemberCount; i++) {
                        printf("0x%lx\n", Members[i]);
                    }
                    DebugBreak();
                    TestStatus = FALSE;

                } else {

                    printf("Succeeded\n");
                }

                if (Members != NULL) {
                    SamFreeMemory( Members );
                }
            }

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }

        IgnoreStatus = SamCloseHandle( AdminAliasHandle );
        ASSERT( NT_SUCCESS(IgnoreStatus) );



        printf("      Delete account while member of alias. . . . . . . . .     ");


        //
        // Now delete user2 and check the alias member list is updated
        //

        NtStatus = SamDeleteUser( UserHandle2 );
        ASSERT(NT_SUCCESS(NtStatus));

        NtStatus = SamGetMembersInAlias(
                       AliasHandle1,
                       &AliasMembers,
                       &MemberCount
                       );
        ASSERT(NT_SUCCESS(NtStatus));

        for ( i=0; i<MemberCount; i++) {
            if (RtlEqualSid(AliasMembers[i], UserSid2)) {
                NtStatus = STATUS_MEMBER_IN_ALIAS;
                break;
            }
        }

        if (!NT_SUCCESS(NtStatus)) {
            printf("Failed\n");
            printf("Service returned SUCCESS, but user still in member list for alias.\n");
            printf("Member list :\n");
            for (i=0; i<MemberCount; i++) {
                printfSid(AliasMembers[i]);
                printf("\n");
            }
            DebugBreak();
            TestStatus = FALSE;
        }

        SamFreeMemory( AliasMembers );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamGetAliasMembership(
                           DomainHandle,
                           1,
                           &UserSid2,
                           &MemberCount,
                           &Members
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            if (MemberCount != 0) {
                printf("Failed\n");
                printf("Service returned SUCCESS, but alias still in alias membership list for account.\n");
                printf("Alias Membership :\n");
                for (i=0; i<MemberCount; i++) {
                    printf("0x%lx\n", Members[i]);
                }
                DebugBreak();
                TestStatus = FALSE;
            }

            if (Members != NULL) {
                SamFreeMemory( Members );
            }

            //
            // Check for correct alias membership for multiple accounts
            // User1 should be in no aliases
            // User2 should be in no aliases.
            //

            if (NT_SUCCESS(NtStatus)) {

                PSID    SidArray[2];
                SidArray[0] = UserSid1;
                SidArray[1] = UserSid2;

                NtStatus = SamGetAliasMembership(
                               DomainHandle,
                               2,
                               SidArray,
                               &MemberCount,
                               &Members
                               );
                ASSERT(NT_SUCCESS(NtStatus));

                if (MemberCount != 0) {

                    printf("Failed\n");
                    printf("Service returned SUCCESS, but combined alias membership count for 2 accounts not correct.\n");
                    printf("Combined Alias Membership :\n");
                    for (i=0; i<MemberCount; i++) {
                        printf("0x%lx\n", Members[i]);
                    }
                    DebugBreak();
                    TestStatus = FALSE;

                } else {
                    printf("Succeeded\n");
                }

                if (Members != NULL) {
                    SamFreeMemory( Members );
                }
            }
        }




        printf("      Delete alias with members . . . . . . . . . . . . . .     ");

        //
        // Make the user a member of this alias (again)
        //

        NtStatus = SamAddMemberToAlias(
                       AliasHandle1,
                       UserSid1
                       );
        ASSERT(NT_SUCCESS(NtStatus));

        //
        // Now delete the alias and check the membership list for user is updated
        //

        NtStatus = SamDeleteAlias( AliasHandle1 );
        ASSERT(NT_SUCCESS(NtStatus));

        NtStatus = SamGetAliasMembership(
                       DomainHandle,
                       1,
                       &UserSid1,
                       &MemberCount,
                       &Members
                       );
        ASSERT(NT_SUCCESS(NtStatus));

        for ( i=0; i<MemberCount; i++) {
            if (Members[i] == AliasRid) {
                NtStatus = STATUS_MEMBER_IN_ALIAS;
                break;
            }
        }

        if (NT_SUCCESS(NtStatus)) {
            printf("Succeeded\n");
        } else {
            printf("Failed\n");
            printf("Service returned SUCCESS, but alias still in account alias membership list.\n");
            printf("Alias Membership :\n");
            for (i=0; i<MemberCount; i++) {
                printf("0x%lx\n", Members[i]);
            }
            DebugBreak();
            TestStatus = FALSE;
        }

        if (Members != NULL) {
            SamFreeMemory( Members );
        }



        DeleteUserSid(UserSid1);
        DeleteUserSid(UserSid2);

        //
        // and clean up
        //

        if (DeleteUser == TRUE) {
            NtStatus = SamDeleteUser( UserHandle1 );
            ASSERT(NT_SUCCESS(NtStatus));
        } else {
            NtStatus = SamCloseHandle( UserHandle1 );
            ASSERT(NT_SUCCESS(NtStatus));
        }






        printf("      Add Foreign Domain Member . . . . . . . . . . . . . .     ");

        //
        // create the alias
        //

        RtlInitString( &AccountNameAnsi, ALIAS_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        AliasRid = 0;
        AliasHandle1 = NULL;
        NtStatus = SamCreateAliasInDomain(
                       DomainHandle,
                       &AccountName,
                       ALIAS_ALL_ACCESS,
                       &AliasHandle1,
                       &AliasRid
                       );
        RtlFreeUnicodeString( &AccountName );
        ASSERT(NT_SUCCESS(NtStatus));

        //
        // Specify a non-existant user be added to this alias
        //


        {
            PSID    ForeignDomainSid;

            ForeignDomainSid = CreateUserSid(DomainSid, 307333); // random domain sub-authority
            ASSERT(ForeignDomainSid != NULL);

            UserRid = 45728;    // Random user rid

            UserSid1 = CreateUserSid(ForeignDomainSid, UserRid);
            ASSERT(UserSid1 != NULL);

            DeleteUserSid(ForeignDomainSid);
        }


        NtStatus = SamAddMemberToAlias(
                       AliasHandle1,
                       UserSid1
                       );

        if (NtStatus == STATUS_SUCCESS) {

            NtStatus = SamGetMembersInAlias(
                           AliasHandle1,
                           &AliasMembers,
                           &MemberCount
                           );
            ASSERT(NT_SUCCESS(NtStatus));

            NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
            for ( i=0; i<MemberCount; i++) {
                if (RtlEqualSid(AliasMembers[i], UserSid1)) {
                    NtStatus = STATUS_SUCCESS;
                    break;
                }
            }

            if (!NT_SUCCESS(NtStatus)) {
                printf("Failed\n");
                printf("Service returned SUCCESS, but user not in member list for alias.\n");
                printf("Member list :\n");
                for (i=0; i<MemberCount; i++) {
                    printfSid(AliasMembers[i]);
                    printf("\n");
                }
                DebugBreak();
                TestStatus = FALSE;
            }


            if (AliasMembers != NULL) {
                SamFreeMemory( AliasMembers );
            }


            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamGetAliasMembership(
                               DomainHandle,
                               1,
                               &UserSid1,
                               &MemberCount,
                               &Members
                               );
                ASSERT(NT_SUCCESS(NtStatus));

                NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
                for ( i=0; i<MemberCount; i++) {
                    if (Members[i] == AliasRid) {
                        NtStatus = STATUS_SUCCESS;
                        break;
                    }
                }

                if (NT_SUCCESS(NtStatus)) {
                    printf("Succeeded\n");
                } else {
                    printf("Failed\n");
                    printf("Service returned SUCCESS, but alias not in account alias membership list.\n");
                    printf("Alias Membership :\n");
                    for (i=0; i<MemberCount; i++) {
                        printf("0x%lx\n", Members[i]);
                    }
                    DebugBreak();
                    TestStatus = FALSE;
                }

                if (Members != NULL) {
                    SamFreeMemory( Members );
                }
            }

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }

        DeleteUserSid(UserSid1);




        printf("      Add alias as member . . . . . . . . . . . . . . . . .     ");

        //
        // Specify an alias in the current domain be added to this alias
        //


        UserSid1 = CreateUserSid(DomainSid, AliasRid2);
        ASSERT(UserSid1 != NULL);


        NtStatus = SamAddMemberToAlias(
                       AliasHandle1,
                       UserSid1
                       );

        if (NtStatus != STATUS_INVALID_MEMBER) {

                printf("Failed\n");
                printf("Expected service to return STATUS_INVALID_MEMBER, actually returned 0x%lx.\n", NtStatus);
                DebugBreak();
                TestStatus = FALSE;
        } else {
                printf("Succeeded\n");
        }

        DeleteUserSid(UserSid1);



        printf("      Add non-existant account in this domain as member . .     ");

        //
        // Specify a non-existant account in the current domain be added to this alias
        //


        UserSid1 = CreateUserSid(DomainSid, 32567); // Random rid
        ASSERT(UserSid1 != NULL);


        NtStatus = SamAddMemberToAlias(
                       AliasHandle1,
                       UserSid1
                       );

        if (NtStatus != STATUS_NO_SUCH_MEMBER) {

                printf("Failed\n");
                printf("Expected service to return STATUS_NO_SUCH_MEMBER, actually returned 0x%lx.\n", NtStatus);
                DebugBreak();
                TestStatus = FALSE;
        } else {
                printf("Succeeded\n");
        }

        DeleteUserSid(UserSid1);



        printf("      Remove Non-member . . . . . . . . . . . . . . . . . .      ");

        //
        // Specify a non-existant user be removed from this alias
        //

        {
            PSID    ForeignDomainSid;

            ForeignDomainSid = CreateUserSid(DomainSid, 35775); // random domain sub-authority
            ASSERT(ForeignDomainSid != NULL);

            UserRid = 623545;    // Random user rid

            UserSid1 = CreateUserSid(ForeignDomainSid, UserRid);
            ASSERT(UserSid1 != NULL);

            DeleteUserSid(ForeignDomainSid);
        }

        NtStatus = SamRemoveMemberFromAlias( AliasHandle1, UserSid1 );

        if (NtStatus == STATUS_MEMBER_NOT_IN_ALIAS) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }

        DeleteUserSid(UserSid1);

        NtStatus = SamDeleteAlias( AliasHandle1 );
        ASSERT(NT_SUCCESS(NtStatus));




    }

    return(TestStatus);

}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// User Object Test Suite                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


BOOLEAN
UserTestSuite(
    HANDLE DomainHandle,
    ULONG Pass
    )


{

    PUSER_ALL_INFORMATION All, All2;
    NTSTATUS            NtStatus, IgnoreStatus, TmpStatus;
    HANDLE              UserHandle1, UserHandle2, GroupHandle1;
    ULONG               CountReturned, NameLength, MembershipCount, i;
    ULONG               UserRid, GroupRid;
    PVOID               Buffer, Buffer1, Buffer2;
    SAM_ENUMERATE_HANDLE EnumerationContext;
    USER_GENERAL_INFORMATION GeneralInformation;
    USER_LOGON_INFORMATION LogonInformation;
    USER_ACCOUNT_INFORMATION AccountInformation;
    PSID_NAME_USE       LookedUpUses;
    PULONG              LookedUpRids;
    UNICODE_STRING      AccountNames[10], AccountName;
    STRING              AccountNameAnsi, TmpAnsiString;




    BOOLEAN             IndividualTestSucceeded, DeleteUser;
    BOOLEAN             TestStatus = TRUE;




    if (Pass == 1) {
        // This test suite assumes that lookup and enumeration API funciton
        // properly.
        //

        printf("\n");
        printf("\n");
        printf("  User  (Pass #1) . . . . . . . . . . . . . . . . . . .   Test\n");

        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Open User  Suite                                                      //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("    Open User   . . . . . . . . . . . . . . . . . . . . .   Suite\n");
        printf("      Open Users  . . . . . . . . . . . . . . . . . . . . .     ");
        IndividualTestSucceeded = TRUE;
        EnumerationContext = 0;
        NtStatus = SamEnumerateUsersInDomain(
                       DomainHandle,
                       &EnumerationContext,
                       0,
                       &Buffer,
                       12000,                   // PreferedMaximumLength
                       &CountReturned
                       );

        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(Buffer != NULL);
        ASSERT(CountReturned > 0);

        for (i=0; i<CountReturned; i++) {

            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_ALL_ACCESS,
                           ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId,
                           &UserHandle1
                           );

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamOpenUser(
                               DomainHandle,
                               GENERIC_READ,
                               ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId,
                               &UserHandle2
                               );

                if (NT_SUCCESS(NtStatus)) {
                    IgnoreStatus = SamCloseHandle( UserHandle2 );
                    ASSERT( NT_SUCCESS(IgnoreStatus) );
                } else {
                    printf("Failed\n");
                    printf("        Completion status is 0x%lx\n", NtStatus);
                    printf("        Failed opening User  second time.\n");
                    printf("        Rid of account is:   0x%lx\n",
                        ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId);
                    printf("        Name of account is:  %wZ\n",
                        &((PSAM_RID_ENUMERATION)(Buffer))[i].Name );
                    TestStatus = FALSE;
                    IndividualTestSucceeded = FALSE;
                }

                IgnoreStatus = SamCloseHandle( UserHandle1 );
                ASSERT( NT_SUCCESS(IgnoreStatus) );

            } else {

                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                printf("        Failed opening User  for first time.\n");
                printf("        Rid of account is:   0x%lx\n",
                    ((PSAM_RID_ENUMERATION)(Buffer))[i].RelativeId);
                printf("        Name of account is:  %wZ\n",
                    &((PSAM_RID_ENUMERATION)(Buffer))[i].Name );
                TestStatus = FALSE;
                IndividualTestSucceeded = FALSE;
            }

        }


        SamFreeMemory( Buffer );
        if (IndividualTestSucceeded) {
            printf("Succeeded\n");
        }



        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Query User Suite                                                      //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Query User  . . . . . . . . . . . . . . . . . . . . .   Suite\n");

        printf("      Query User  General Information . . . . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_GENERAL,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserGeneralInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((USER_GENERAL_INFORMATION *)Buffer)->UserName.MaximumLength
                    >= 0) &&
                     (((USER_GENERAL_INFORMATION *)Buffer)->UserName.Buffer != NULL)
                         ) {

                    printf("Succeeded\n");

                    printf("      Primary Group is:   0x%lx\n",
                     (((USER_GENERAL_INFORMATION *)Buffer)->PrimaryGroupId) );
                    printf("        User  Name is:    *%wZ*\n",
                     &(((USER_GENERAL_INFORMATION *)Buffer)->UserName) );
                    printf("        Full  Name is:    *%wZ*\n",
                     &(((USER_GENERAL_INFORMATION *)Buffer)->FullName) );
                    printf("     Admin Comment is:    *%wZ*\n",
                     &(((USER_GENERAL_INFORMATION *)Buffer)->AdminComment) );
                    printf("      User Comment is:    *%wZ*\n",
                     &(((USER_GENERAL_INFORMATION *)Buffer)->UserComment) );


                } else {
                    printf("Failed\n");
                    printf("        One of the UNICODE_STRINGs  not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query User Name Information . . . . . . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_GENERAL,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserNameInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((USER_NAME_INFORMATION *)Buffer)->UserName.MaximumLength > 0) &&
                     (((USER_NAME_INFORMATION *)Buffer)->UserName.Buffer != NULL)
                         ) {

                    printf("Succeeded\n");

                    printf("        User  Name is:    *%wZ*\n",
                     &(((USER_NAME_INFORMATION *)Buffer)->UserName) );
                    printf("        Full  Name is:    *%wZ*\n",
                     &(((USER_NAME_INFORMATION *)Buffer)->FullName) );



                } else {
                    printf("Failed\n");
                    printf("        One of the UNICODE_STRINGs not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query User Account Name Information . . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_GENERAL,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserAccountNameInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((USER_ACCOUNT_NAME_INFORMATION *)Buffer)->UserName.MaximumLength > 0) &&
                     (((USER_ACCOUNT_NAME_INFORMATION *)Buffer)->UserName.Buffer != NULL)
                         ) {

                    printf("Succeeded\n");

                    printf("        User  Name is:    *%wZ*\n",
                     &(((USER_ACCOUNT_NAME_INFORMATION *)Buffer)->UserName) );



                } else {
                    printf("Failed\n");
                    printf("        UNICODE_STRING not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query User Full Name Information  . . . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_GENERAL,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserFullNameInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((USER_FULL_NAME_INFORMATION *)Buffer)->FullName.MaximumLength
                    >= 0)
                         ) {

                    printf("Succeeded\n");

                    printf("        Full Name is:    *%wZ*\n",
                     &(((USER_FULL_NAME_INFORMATION *)Buffer)->FullName) );



                } else {
                    printf("Failed\n");
                    printf("        UNICODE_STRING not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query User  Admin Comment Information . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_GENERAL,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserAdminCommentInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((USER_ADMIN_COMMENT_INFORMATION *)Buffer)->AdminComment.MaximumLength
                    >= 0)
                         ) {

                    printf("Succeeded\n");

                    printf("     Admin Comment is:    *%wZ*\n",
                     &(((USER_ADMIN_COMMENT_INFORMATION *)Buffer)->AdminComment) );

                } else {
                    printf("Failed\n");
                    printf("        User  Admin Comment not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query User  Primary Group Information . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_GENERAL,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserPrimaryGroupInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {


                printf("Succeeded\n");

                printf("     Primary Group  is:   0x%lx\n",
                 (((USER_PRIMARY_GROUP_INFORMATION *)Buffer)->PrimaryGroupId) );

                SamFreeMemory( Buffer );

            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query User Control Information  . . . . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_ACCOUNT,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserControlInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {


                printf("Succeeded\n");

                printf(" Account Control is:      0x%lx\n",
                 (((USER_CONTROL_INFORMATION *)Buffer)->UserAccountControl) );

                SamFreeMemory( Buffer );


            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query User Expiration Information . . . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_ACCOUNT,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserExpiresInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {


                printf("Succeeded\n");

                printf(" Account Expires on:      (0x%lx, 0x%lx)\n",
                 (((USER_EXPIRES_INFORMATION *)Buffer)->AccountExpires.HighPart),
                 (((USER_EXPIRES_INFORMATION *)Buffer)->AccountExpires.LowPart) );

                SamFreeMemory( Buffer );


            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );


        printf("      Query User Preferences Information  . . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_PREFERENCES | USER_READ_GENERAL,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserPreferencesInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((USER_PREFERENCES_INFORMATION *)Buffer)->UserComment.MaximumLength
                    >= 0)
                         ) {

                    printf("Succeeded\n");

                    printf("     User Comment  is:    *%wZ*\n",
                     &(((USER_PREFERENCES_INFORMATION *)Buffer)->UserComment) );

                } else {
                    printf("Failed\n");
                    printf("        One of the UNICODE_STRINGs not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );





        printf("      Query User Home Directory Information . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_LOGON,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserHomeInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((USER_HOME_INFORMATION *)Buffer)->HomeDirectory.MaximumLength
                    >= 0) &&
                     (((USER_HOME_INFORMATION *)Buffer)->HomeDirectoryDrive.MaximumLength
                     >= 0)
                         ) {

                    printf("Succeeded\n");

                    printf("    Home Directory is:    *%wZ*\n",
                     &(((USER_HOME_INFORMATION *)Buffer)->HomeDirectory) );
                    printf("    Home Directory Drive is:    *%wZ*\n",
                     &(((USER_HOME_INFORMATION *)Buffer)->HomeDirectoryDrive) );


                } else {
                    printf("Failed\n");
                    printf("        String not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query User Script Path Information  . . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_LOGON,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserScriptInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((USER_SCRIPT_INFORMATION *)Buffer)->ScriptPath.MaximumLength
                    >= 0)
                         ) {

                    printf("Succeeded\n");

                    printf("      Script Path  is:    *%wZ*\n",
                     &(((USER_SCRIPT_INFORMATION *)Buffer)->ScriptPath) );


                } else {
                    printf("Failed\n");
                    printf("        String not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );



        printf("      Query User ProfilePath Information  . . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_LOGON,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserProfileInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((USER_PROFILE_INFORMATION *)Buffer)->ProfilePath.MaximumLength
                    >= 0)
                         ) {

                    printf("Succeeded\n");

                    printf("      Profile Path  is:    *%wZ*\n",
                     &(((USER_PROFILE_INFORMATION *)Buffer)->ProfilePath) );


                } else {
                    printf("Failed\n");
                    printf("        String not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );



        printf("      Query User Logon Information  . . . . . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_ACCOUNT | USER_READ_GENERAL | USER_READ_PREFERENCES | USER_READ_LOGON,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserLogonInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((USER_LOGON_INFORMATION *)Buffer)->UserName.MaximumLength > 0)       &&
                     (((USER_LOGON_INFORMATION *)Buffer)->UserName.Buffer != NULL)
                         ) {

                    printf("Succeeded\n");

                    printf("          User RID is:    0x%lx\n",
                     (((USER_LOGON_INFORMATION *)Buffer)->UserId) );
                    printf("     Primary Group is:    0x%lx\n",
                     (((USER_LOGON_INFORMATION *)Buffer)->PrimaryGroupId) );
                    printf("      Logon Units are:    0x%lx\n",
                     (((USER_LOGON_INFORMATION *)Buffer)->LogonHours.UnitsPerWeek) );
                    printf("     Bad PWD count is:    0x%lx\n",
                     (((USER_LOGON_INFORMATION *)Buffer)->BadPasswordCount) );
                    printf("       Logon count is:    0x%lx\n",
                     (((USER_LOGON_INFORMATION *)Buffer)->LogonCount) );

                    printf("        last Logon is:    (0x%lx, 0x%lx)\n",
                     (((USER_LOGON_INFORMATION *)Buffer)->LastLogon.HighPart),
                     (((USER_LOGON_INFORMATION *)Buffer)->LastLogon.LowPart)  );
                    printf("       last Logoff is:    (0x%lx, 0x%lx)\n",
                     (((USER_LOGON_INFORMATION *)Buffer)->LastLogoff.HighPart),
                     (((USER_LOGON_INFORMATION *)Buffer)->LastLogoff.LowPart)  );


                    printf("        User  Name is:    *%wZ*\n",
                     &(((USER_LOGON_INFORMATION *)Buffer)->UserName) );
                    printf("        Full  Name is:    *%wZ*\n",
                     &(((USER_LOGON_INFORMATION *)Buffer)->FullName) );
                    printf("          Home Dir is:    *%wZ*\n",
                     &(((USER_LOGON_INFORMATION *)Buffer)->HomeDirectory) );
                    printf("    Home Dir Drive is:    *%wZ*\n",
                     &(((USER_LOGON_INFORMATION *)Buffer)->HomeDirectoryDrive) );
                    printf("      Script Path  is:    *%wZ*\n",
                     &(((USER_LOGON_INFORMATION *)Buffer)->ScriptPath) );
                    printf("      Profile Path is:    *%wZ*\n",
                     &(((USER_LOGON_INFORMATION *)Buffer)->ProfilePath) );
                    printf("     WorkStations are:    *%wZ*\n",
                     &(((USER_LOGON_INFORMATION *)Buffer)->WorkStations) );




                } else {
                    printf("Failed\n");
                    printf("        One of the UNICODE_STRINGs  not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query User Logon Hours  . . . . . . . . . . . . . . .     ");


        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_LOGON,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserLogonHoursInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                printf("Succeeded\n");

                printf("      Logon Units are:    0x%lx\n",
                 (((USER_LOGON_HOURS_INFORMATION *)Buffer)->LogonHours.UnitsPerWeek) );


                SamFreeMemory( Buffer );

            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        printf("      Query Account Information . . . . . . . . . . . . . .     ");

        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_GENERAL | USER_READ_PREFERENCES |
                       USER_READ_LOGON   | USER_READ_ACCOUNT,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserAccountInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((USER_ACCOUNT_INFORMATION *)Buffer)->UserName.MaximumLength > 0)       &&
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->UserName.Buffer != NULL)
                         ) {

                    printf("Succeeded\n");

                    printf("          User RID is:    0x%lx\n",
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->UserId) );
                    printf("     Primary Group is:    0x%lx\n",
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->PrimaryGroupId) );
                    printf("      Logon Units are:    0x%lx\n",
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->LogonHours.UnitsPerWeek) );
                    printf("     Bad PWD count is:    0x%lx\n",
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->BadPasswordCount) );
                    printf("       Logon count is:    0x%lx\n",
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->LogonCount) );
                    printf("      Account Ctrl is:    0x%lx\n",
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->UserAccountControl) );

                    printf("        last Logon is:    (0x%lx, 0x%lx)\n",
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->LastLogon.HighPart),
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->LastLogon.LowPart)  );
                    printf("       last Logoff is:    (0x%lx, 0x%lx)\n",
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->LastLogoff.HighPart),
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->LastLogoff.LowPart)  );
                    printf("      Pwd Last Set is:    (0x%lx, 0x%lx)\n",
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->PasswordLastSet.HighPart),
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->PasswordLastSet.LowPart)  );
                    printf("   Account Expires is:    (0x%lx, 0x%lx)\n",
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->AccountExpires.HighPart),
                     (((USER_ACCOUNT_INFORMATION *)Buffer)->AccountExpires.LowPart)  );


                    printf("        User  Name is:    *%wZ*\n",
                     &(((USER_ACCOUNT_INFORMATION *)Buffer)->UserName) );
                    printf("        Full  Name is:    *%wZ*\n",
                     &(((USER_ACCOUNT_INFORMATION *)Buffer)->FullName) );
                    printf("          Home Dir is:    *%wZ*\n",
                     &(((USER_ACCOUNT_INFORMATION *)Buffer)->HomeDirectory) );
                    printf("    Home Dir Drive is:    *%wZ*\n",
                     &(((USER_ACCOUNT_INFORMATION *)Buffer)->HomeDirectoryDrive) );
                    printf("      Script Path  is:    *%wZ*\n",
                     &(((USER_ACCOUNT_INFORMATION *)Buffer)->ScriptPath) );
                    printf("     Profile Path  is:    *%wZ*\n",
                     &(((USER_ACCOUNT_INFORMATION *)Buffer)->ProfilePath) );
                    printf("     Admin Comment is:    *%wZ*\n",
                     &(((USER_ACCOUNT_INFORMATION *)Buffer)->AdminComment) );
                    printf("     WorkStations are:    *%wZ*\n",
                     &(((USER_ACCOUNT_INFORMATION *)Buffer)->WorkStations) );



                } else {
                    printf("Failed\n");
                    printf("        One of the UNICODE_STRINGs  not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );








        printf("      Query Workstations Information  . . . . . . . . . . .     ");

        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_LOGON,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserWorkStationsInformation,
                       &Buffer
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                if ( (((USER_WORKSTATIONS_INFORMATION *)Buffer)->WorkStations.MaximumLength
                    >= 0)
                         ) {

                    printf("Succeeded\n");

                    printf("      Workstations is:    *%wZ*\n",
                     &(((USER_WORKSTATIONS_INFORMATION *)Buffer)->WorkStations) );


                } else {
                    printf("Failed\n");
                    printf("        String not returned.\n");
                    TestStatus = FALSE;
                }
                SamFreeMemory( Buffer );
            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );





        printf("      Query Internal1 Information  . . . . . . . . . . .     ");

        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_LOGON,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserInternal1Information,
                       &Buffer
                       );

        if ( NtStatus == STATUS_INVALID_INFO_CLASS ) {

            //
            // We're not a trusted client, so we expected this to fail.
            //

            printf("Succeeded\n");

        } else {

            printf("Failed\n");
            printf("        Status was %lx.\n", NtStatus );
            TestStatus = FALSE;
            if ( NT_SUCCESS( NtStatus ) ) {

                SamFreeMemory( Buffer );
            }
        }

// This is the code that USED to test this function, when it was allowed
// for non-trusted clients.
//
//        if (NT_SUCCESS(NtStatus)) {
//            if (Buffer != NULL) {
//
//                if ( (((USER_INTERNAL1_INFORMATION *)Buffer)->CaseInsensitiveDbcs.MaximumLength > 0) &&
//                     (((USER_INTERNAL1_INFORMATION *)Buffer)->CaseInsensitiveDbcs.Buffer != NULL) &&
//                     (((USER_INTERNAL1_INFORMATION *)Buffer)->CaseSensitiveUnicode.MaximumLength > 0) &&
//                     (((USER_INTERNAL1_INFORMATION *)Buffer)->CaseSensitiveUnicode.Buffer != NULL)
//                         ) {
//
//                     printf("Succeeded\n");
//
//                     //
//                     // Print them out as strings, even though they've been
//                     // through a OWF.
//                     //
//
//                     printf("      CaseInsensitiveDbcs is:    *%s*\n",
//                      &(((USER_INTERNAL1_INFORMATION *)Buffer)->CaseInsensitiveDbcs) );
//
//                     printf("      CaseSensitiveUnicode is:    *%s*\n",
//                      &(((USER_INTERNAL1_INFORMATION *)Buffer)->CaseSensitiveUnicode) );
//
//
//                } else {
//                    printf("Failed\n");
//                    printf("        One of the strings not returned.\n");
//                    TestStatus = FALSE;
//                }
//                SamFreeMemory( Buffer );
//            } else {
//                printf("Failed\n");
//                printf("        Buffer address not set on return.\n");
//                printf("        RPC should have allocated a buffer.\n");
//                TestStatus = FALSE;
//            }
//        } else {
//            printf("Failed\n");
//            printf("        Completion status is 0x%lx\n", NtStatus);
//            TestStatus = FALSE;
//        }

        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );





        printf("      Query Internal2 Information  . . . . . . . . . . .     ");

        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_LOGON,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserInternal2Information,
                       &Buffer
                       );

        if ( NtStatus == STATUS_INVALID_INFO_CLASS ) {

            //
            // We're not a trusted client, so we don't expect to be able
            // to do this.
            //

            printf("Succeeded.\n");

        } else {

            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
            SamFreeMemory( Buffer );
        }

// This is the code that USED to test this function, when non-trusted
// clients were allowed to do this...
//
//        if (NT_SUCCESS(NtStatus)) {
//            if (Buffer != NULL) {
//
//                printf("Succeeded\n");
//
//                printf("        last Logon is:    (0x%lx, 0x%lx)\n",
//                 (((USER_INTERNAL2_INFORMATION *)Buffer)->LastLogon.HighPart),
//                 (((USER_INTERNAL2_INFORMATION *)Buffer)->LastLogon.LowPart)  );
//                printf("       last Logoff is:    (0x%lx, 0x%lx)\n",
//                 (((USER_INTERNAL2_INFORMATION *)Buffer)->LastLogoff.HighPart),
//                 (((USER_INTERNAL2_INFORMATION *)Buffer)->LastLogoff.LowPart)  );
//                printf("       BadPwdCount is:    (0x%x)\n",
//                 ((USER_INTERNAL2_INFORMATION *)Buffer)->BadPasswordCount );
//                printf("       LogonCount  is:    (0x%x)\n",
//                 ((USER_INTERNAL2_INFORMATION *)Buffer)->LogonCount );
//
//                SamFreeMemory( Buffer );
//            } else {
//                printf("Failed\n");
//                printf("        Buffer address not set on return.\n");
//                printf("        RPC should have allocated a buffer.\n");
//                TestStatus = FALSE;
//            }
//        } else {
//            printf("Failed\n");
//            printf("        Completion status is 0x%lx\n", NtStatus);
//            TestStatus = FALSE;
//        }

        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );





        printf("      Query Set Password Information  . . . . . . . . . . .     ");




        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_READ_LOGON,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserSetPasswordInformation,
                       &Buffer
                       );
        if (NtStatus == STATUS_INVALID_INFO_CLASS ) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            printf("        Expected 0x%lx (INVALID_INFO_CLASS)\n", STATUS_INVALID_INFO_CLASS);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );




        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Get Groups For User Suite                                             //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Get Groups For User . . . . . . . . . . . . . . . . .   Suite\n");

        printf("      Get Groups For Well-Known Account . . . . . . . . . .     ");

        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_LIST_GROUPS,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;
        NtStatus = SamGetGroupsForUser(
                       UserHandle1,
                       (PGROUP_MEMBERSHIP *)&Buffer,
                       &MembershipCount
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (Buffer != NULL) {

                printf("Succeeded\n");


                printf("          Member of:    %d groups\n", MembershipCount);
                for ( i=0; i<MembershipCount; i++) {

                    printf("      Group[%d] Rid/Attributes:      0x%lx/0x%lx\n",
                        i,
                        (((PGROUP_MEMBERSHIP)Buffer)[i].RelativeId),
                        (((PGROUP_MEMBERSHIP)Buffer)[i].Attributes)
                        );

                }

                SamFreeMemory( Buffer );


            } else {
                printf("Failed\n");
                printf("        Buffer address not set on return.\n");
                printf("        RPC should have allocated a buffer.\n");
                TestStatus = FALSE;
            }
        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );



        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Set User Suite                                                        //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Set User  . . . . . . . . . . . . . . . . . . . . . .   Suite\n");

        printf("      Set General Information . . . . . . . . . . . . . . .     ");
        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_ALL_ACCESS,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        //
        // Make the parameter marshallable, but don't worry about values.
        //

        GeneralInformation.UserName = DummyName1;
        GeneralInformation.FullName = DummyName1;
        GeneralInformation.AdminComment = DummyName1;
        GeneralInformation.UserComment  = DummyName1;

        Buffer = &GeneralInformation;
        NtStatus = SamSetInformationUser(
                       UserHandle1,
                       UserGeneralInformation,
                       Buffer
                       );
        if (NtStatus == STATUS_INVALID_INFO_CLASS ) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            printf("        Expected 0x%lx (INVALID_INFO_CLASS)\n", STATUS_INVALID_INFO_CLASS);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );



        printf("      Set Preferences Information . . . . . . . . . . . . .     ");
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_READ_GENERAL | USER_WRITE_PREFERENCES | USER_READ_PREFERENCES,
                           DOMAIN_USER_RID_ADMIN,
                           &UserHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            //
            // Get the current value...
            //

            Buffer1 = NULL;
            NtStatus = SamQueryInformationUser(
                           UserHandle1,
                           UserPreferencesInformation,
                           &Buffer1
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(Buffer1 != NULL);


            //
            // Change the fields to  new values and write them out.
            //

            NameLength = ((USER_PREFERENCES_INFORMATION *)Buffer1)->UserComment.Length;
            if (  NameLength == DummyString1.Length ) {
                ((USER_PREFERENCES_INFORMATION *)Buffer1)->UserComment = DummyString2;
            } else {
                ((USER_PREFERENCES_INFORMATION *)Buffer1)->UserComment = DummyString1;
            }

            ((USER_PREFERENCES_INFORMATION *)Buffer1)->CountryCode += 1;
            ((USER_PREFERENCES_INFORMATION *)Buffer1)->CodePage += 1;

            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserPreferencesInformation,
                           Buffer1
                           );
            if ( NT_SUCCESS(NtStatus) ) {

                //
                // Now check that the change was really made...
                //

                NtStatus = SamQueryInformationUser(
                               UserHandle1,
                               UserPreferencesInformation,
                               &Buffer2
                               );
                ASSERT(NT_SUCCESS( NtStatus ) );
                if (
                    !RtlCompareString(
                        (PSTRING)&((USER_PREFERENCES_INFORMATION *)Buffer1)->UserComment,
                        (PSTRING)&((USER_PREFERENCES_INFORMATION *)Buffer2)->UserComment,
                        TRUE)
                        &&
                        (((USER_PREFERENCES_INFORMATION *)Buffer1)->CountryCode ==
                         ((USER_PREFERENCES_INFORMATION *)Buffer2)->CountryCode)
                        &&
                        (((USER_PREFERENCES_INFORMATION *)Buffer1)->CodePage ==
                         ((USER_PREFERENCES_INFORMATION *)Buffer2)->CodePage)
                    ) {

                    printf("Succeeded\n");

                    //
                    // Change back some fields to keep from screwing up our database
                    //

                    ((USER_PREFERENCES_INFORMATION *)Buffer1)->CountryCode -= 1;
                    ((USER_PREFERENCES_INFORMATION *)Buffer1)->CodePage    -= 1;

                    IgnoreStatus = SamSetInformationUser(
                                       UserHandle1,
                                       UserPreferencesInformation,
                                       Buffer1
                                       );
                    ASSERT(NT_SUCCESS(IgnoreStatus));

                } else {

                    printf("Failed\n");
                    printf("        Values queried don't match values written\n");
                    printf("        UserComment Written is   %wZ\n",
                        (PUNICODE_STRING)&((USER_PREFERENCES_INFORMATION *)Buffer1)->UserComment);
                    printf("        UserComment Retrieved is %wZ\n",
                        (PUNICODE_STRING)&((USER_PREFERENCES_INFORMATION *)Buffer2)->UserComment);
                    printf("        CountryCode Written is   0x%lx\n",
                        (ULONG)((USER_PREFERENCES_INFORMATION *)Buffer1)->CountryCode);
                    printf("        CountryCode Retrieved is 0x%lx\n",
                        (ULONG)((USER_PREFERENCES_INFORMATION *)Buffer2)->CountryCode);
                    printf("        CodePage Written is   0x%lx\n",
                        (ULONG)((USER_PREFERENCES_INFORMATION *)Buffer1)->CodePage);
                    printf("        CodePage Retrieved is 0x%lx\n",
                        (ULONG)((USER_PREFERENCES_INFORMATION *)Buffer2)->CodePage);

                    TestStatus = FALSE;

                }

                SamFreeMemory( Buffer1 );
                SamFreeMemory( Buffer2 );

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
                SamFreeMemory( Buffer1 );

            }




        printf("      Set Logon Information . . . . . . . . . . . . . . . .     ");
        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_ALL_ACCESS,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        //
        // Make the parameter marshallable, but don't worry about values.
        //

        LogonInformation.UserName       = DummyName1;
        LogonInformation.FullName       = DummyName1;
        LogonInformation.HomeDirectory  = DummyName1;
        LogonInformation.HomeDirectoryDrive = DummyName1;
        LogonInformation.ScriptPath     = DummyName1;
        LogonInformation.ProfilePath    = DummyName1;
        LogonInformation.WorkStations   = DummyName1;

        LogonInformation.LogonHours     = DummyLogonHours;

        Buffer = &LogonInformation;
        NtStatus = SamSetInformationUser(
                       UserHandle1,
                       UserLogonInformation,
                       Buffer
                       );
        if (NtStatus == STATUS_INVALID_INFO_CLASS ) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            printf("        Expected 0x%lx (INVALID_INFO_CLASS)\n", STATUS_INVALID_INFO_CLASS);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );



        printf("      Set Logon Hours Information . . . . . . . . . . . . .     ");
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_WRITE_ACCOUNT | USER_READ_LOGON,
                           DOMAIN_USER_RID_ADMIN,
                           &UserHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            //
            // Get the current value...
            //

            Buffer1 = NULL;
            NtStatus = SamQueryInformationUser(
                           UserHandle1,
                           UserLogonHoursInformation,
                           &Buffer1
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(Buffer1 != NULL);
            ASSERT( ((USER_LOGON_HOURS_INFORMATION *)Buffer1)->LogonHours.LogonHours
                    != NULL);  //Don't support zero length bit masks in this test yet.


            //
            // Change the field to a new value and write it out.
            // We have two choices for out test:
            //                                      NoLogonRestriction
            //                                      DummyLogonHours
            //
            // They are guaranteed to have different values in the
            // LOGON_HOURS_DIFFERENT_OFFSET byte of their respective bit masks.
            //

            if ( 0 == ((USER_LOGON_HOURS_INFORMATION *)Buffer1)->LogonHours.LogonHours[LOGON_HOURS_DIFFERENT_OFFSET]) {
                ((USER_LOGON_HOURS_INFORMATION *)Buffer1)->LogonHours = DummyLogonHours;
            } else {
                ((USER_LOGON_HOURS_INFORMATION *)Buffer1)->LogonHours = NoLogonRestriction;
            }

            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserLogonHoursInformation,
                           Buffer1
                           );
            if ( NT_SUCCESS(NtStatus) ) {

                //
                // Now check that the change was really made...
                //

                NtStatus = SamQueryInformationUser(
                               UserHandle1,
                               UserLogonHoursInformation,
                               &Buffer2
                               );
                ASSERT(NT_SUCCESS( NtStatus ) );
                if (
                    ((USER_LOGON_HOURS_INFORMATION *)Buffer1)->LogonHours.LogonHours[LOGON_HOURS_DIFFERENT_OFFSET]
                    ==
                    ((USER_LOGON_HOURS_INFORMATION *)Buffer2)->LogonHours.LogonHours[LOGON_HOURS_DIFFERENT_OFFSET]
                    ) {

                    printf("Succeeded\n");

                } else {

                    printf("Failed\n");
                    printf("        Value queried doesn't match value written\n");
                    printf("        Units Written are   0x%lx\n",
                        ((USER_LOGON_HOURS_INFORMATION *)Buffer1)->LogonHours.UnitsPerWeek);
                    printf("        Units Retrieved are 0x%lx\n",
                        ((USER_LOGON_HOURS_INFORMATION *)Buffer2)->LogonHours.UnitsPerWeek);

                    printf("        Byte 0x%lx of the written bit mask is    0x%lx\n",
                        LOGON_HOURS_DIFFERENT_OFFSET,
                        (ULONG)((USER_LOGON_HOURS_INFORMATION *)Buffer1)->LogonHours.LogonHours[LOGON_HOURS_DIFFERENT_OFFSET]
                        );
                    printf("        Byte 0x%lx of the retrieved bit mask is  0x%lx\n",
                        LOGON_HOURS_DIFFERENT_OFFSET,
                        (ULONG)((USER_LOGON_HOURS_INFORMATION *)Buffer2)->LogonHours.LogonHours[LOGON_HOURS_DIFFERENT_OFFSET]
                        );

                    TestStatus = FALSE;

                }

                SamFreeMemory( Buffer1 );
                SamFreeMemory( Buffer2 );

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
                SamFreeMemory( Buffer1 );

            }





        printf("      Set Account Information . . . . . . . . . . . . . . .     ");
        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_WRITE_ACCOUNT        |
                           USER_READ_GENERAL     |
                           USER_READ_PREFERENCES |
                           USER_READ_LOGON,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        //
        // Make the parameter marshallable, but don't worry about values.
        //

        AccountInformation.UserName       = DummyName1;
        AccountInformation.FullName       = DummyName1;
        AccountInformation.HomeDirectory  = DummyName1;
        AccountInformation.HomeDirectoryDrive = DummyName1;
        AccountInformation.ScriptPath     = DummyName1;
        AccountInformation.ProfilePath    = DummyName1;
        AccountInformation.AdminComment   = DummyName1;
        AccountInformation.WorkStations   = DummyName1;

        AccountInformation.LogonHours     = DummyLogonHours;

        Buffer = &AccountInformation;
        NtStatus = SamSetInformationUser(
                       UserHandle1,
                       UserAccountInformation,
                       Buffer
                       );
        if (NtStatus == STATUS_INVALID_INFO_CLASS ) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            printf("        Expected 0x%lx (INVALID_INFO_CLASS)\n", STATUS_INVALID_INFO_CLASS);
            TestStatus = FALSE;
        }
        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );


        printf("      Set Home  . . . . . . . . . . . . . . . . . . . . . .     ");
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_WRITE_ACCOUNT | USER_READ_LOGON,
                           DOMAIN_USER_RID_ADMIN,
                           &UserHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            //
            // Get the current value...
            //

            Buffer1 = NULL;
            NtStatus = SamQueryInformationUser(
                           UserHandle1,
                           UserHomeInformation,
                           &Buffer1
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(Buffer1 != NULL);


            //
            // Change the field to a new value and write it out.
            //

            NameLength = ((USER_HOME_INFORMATION *)Buffer1)->HomeDirectory.Length;
            if (  NameLength == DummyString1.Length ) {
                ((USER_HOME_INFORMATION *)Buffer1)->HomeDirectory = DummyString2;
            } else {
                ((USER_HOME_INFORMATION *)Buffer1)->HomeDirectory = DummyString1;
            }

            NameLength = ((USER_HOME_INFORMATION *)Buffer1)->HomeDirectoryDrive.Length;
            if (  NameLength == DummyString1.Length ) {
                ((USER_HOME_INFORMATION *)Buffer1)->HomeDirectoryDrive = DummyString2;
            } else {
                ((USER_HOME_INFORMATION *)Buffer1)->HomeDirectoryDrive = DummyString1;
            }

            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserHomeInformation,
                           Buffer1
                           );
            if ( NT_SUCCESS(NtStatus) ) {

                //
                // Now check that the change was really made...
                //

                NtStatus = SamQueryInformationUser(
                               UserHandle1,
                               UserHomeInformation,
                               &Buffer2
                               );
                ASSERT(NT_SUCCESS( NtStatus ) );

                if (!RtlCompareString(
                        (PSTRING)&((USER_HOME_INFORMATION *)Buffer1)->HomeDirectory,
                        (PSTRING)&((USER_HOME_INFORMATION *)Buffer2)->HomeDirectory,
                        TRUE) ) {

                    if (!RtlCompareString(
                            (PSTRING)&((USER_HOME_INFORMATION *)Buffer1)->HomeDirectoryDrive,
                            (PSTRING)&((USER_HOME_INFORMATION *)Buffer2)->HomeDirectoryDrive,
                            TRUE)
                    ) {
                        printf("Succeeded\n");
                    } else {

                        printf("Failed\n");
                        printf("        Drive Value queried doesn't match value written\n");
                        printf("        Value Written is   %wZ\n",
                            (PUNICODE_STRING)&((USER_HOME_INFORMATION *)Buffer1)->HomeDirectoryDrive);
                        printf("        Value Retrieved is %wZ\n",
                            (PUNICODE_STRING)&((USER_HOME_INFORMATION *)Buffer2)->HomeDirectoryDrive);

                        TestStatus = FALSE;
                    }

                } else {

                    printf("Failed\n");
                    printf("        Directory Value queried doesn't match value written\n");
                    printf("        Value Written is   %wZ\n",
                        (PUNICODE_STRING)&((USER_HOME_INFORMATION *)Buffer1)->HomeDirectory);
                    printf("        Value Retrieved is %wZ\n",
                        (PUNICODE_STRING)&((USER_HOME_INFORMATION *)Buffer2)->HomeDirectory);

                    TestStatus = FALSE;

                }

                SamFreeMemory( Buffer1 );
                SamFreeMemory( Buffer2 );

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
                SamFreeMemory( Buffer1 );

            }




        printf("      Set Script  . . . . . . . . . . . . . . . . . . . . .     ");
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_WRITE_ACCOUNT | USER_READ_LOGON,
                           DOMAIN_USER_RID_ADMIN,
                           &UserHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            //
            // Get the current value...
            //

            Buffer1 = NULL;
            NtStatus = SamQueryInformationUser(
                           UserHandle1,
                           UserScriptInformation,
                           &Buffer1
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(Buffer1 != NULL);


            //
            // Change the field to a new value and write it out.
            //

            NameLength = ((USER_SCRIPT_INFORMATION *)Buffer1)->ScriptPath.Length;
            if (  NameLength == DummyString1.Length ) {
                ((USER_SCRIPT_INFORMATION *)Buffer1)->ScriptPath = DummyString2;
            } else {
                ((USER_SCRIPT_INFORMATION *)Buffer1)->ScriptPath = DummyString1;
            }

            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserScriptInformation,
                           Buffer1
                           );
            if ( NT_SUCCESS(NtStatus) ) {

                //
                // Now check that the change was really made...
                //

                NtStatus = SamQueryInformationUser(
                               UserHandle1,
                               UserScriptInformation,
                               &Buffer2
                               );
                ASSERT(NT_SUCCESS( NtStatus ) );
                if (
                    !RtlCompareString(
                        (PSTRING)&((USER_SCRIPT_INFORMATION *)Buffer1)->ScriptPath,
                        (PSTRING)&((USER_SCRIPT_INFORMATION *)Buffer2)->ScriptPath,
                        TRUE)
                    ) {

                    printf("Succeeded\n");

                } else {

                    printf("Failed\n");
                    printf("        Value queried doesn't match value written\n");
                    printf("        Value Written is   %wZ\n",
                        (PUNICODE_STRING)&((USER_SCRIPT_INFORMATION *)Buffer1)->ScriptPath);
                    printf("        Value Retrieved is %wZ\n",
                        (PUNICODE_STRING)&((USER_SCRIPT_INFORMATION *)Buffer2)->ScriptPath);

                    TestStatus = FALSE;

                }

                SamFreeMemory( Buffer1 );
                SamFreeMemory( Buffer2 );

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
                SamFreeMemory( Buffer1 );

            }




        printf("      Set Profile . . . . . . . . . . . . . . . . . . . . .     ");
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_WRITE_ACCOUNT | USER_READ_LOGON,
                           DOMAIN_USER_RID_ADMIN,
                           &UserHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            //
            // Get the current value...
            //

            Buffer1 = NULL;
            NtStatus = SamQueryInformationUser(
                           UserHandle1,
                           UserProfileInformation,
                           &Buffer1
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(Buffer1 != NULL);


            //
            // Change the field to a new value and write it out.
            //

            NameLength = ((USER_PROFILE_INFORMATION *)Buffer1)->ProfilePath.Length;
            if (  NameLength == DummyString1.Length ) {
                ((USER_PROFILE_INFORMATION *)Buffer1)->ProfilePath = DummyString2;
            } else {
                ((USER_PROFILE_INFORMATION *)Buffer1)->ProfilePath = DummyString1;
            }

            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserProfileInformation,
                           Buffer1
                           );
            if ( NT_SUCCESS(NtStatus) ) {

                //
                // Now check that the change was really made...
                //

                NtStatus = SamQueryInformationUser(
                               UserHandle1,
                               UserProfileInformation,
                               &Buffer2
                               );
                ASSERT(NT_SUCCESS( NtStatus ) );
                if (
                    !RtlCompareString(
                        (PSTRING)&((USER_PROFILE_INFORMATION *)Buffer1)->ProfilePath,
                        (PSTRING)&((USER_PROFILE_INFORMATION *)Buffer2)->ProfilePath,
                        TRUE)
                    ) {

                    printf("Succeeded\n");

                } else {

                    printf("Failed\n");
                    printf("        Value queried doesn't match value written\n");
                    printf("        Value Written is   %wZ\n",
                        (PUNICODE_STRING)&((USER_PROFILE_INFORMATION *)Buffer1)->ProfilePath);
                    printf("        Value Retrieved is %wZ\n",
                        (PUNICODE_STRING)&((USER_PROFILE_INFORMATION *)Buffer2)->ProfilePath);

                    TestStatus = FALSE;

                }

                SamFreeMemory( Buffer1 );
                SamFreeMemory( Buffer2 );

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
                SamFreeMemory( Buffer1 );

            }




        printf("      Set Admin Comment . . . . . . . . . . . . . . . . . .     ");

            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_WRITE_ACCOUNT | USER_READ_GENERAL,
                           DOMAIN_USER_RID_ADMIN,
                           &UserHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            //
            // Get the current value...
            //

            Buffer1 = NULL;
            NtStatus = SamQueryInformationUser(
                           UserHandle1,
                           UserAdminCommentInformation,
                           &Buffer1
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(Buffer1 != NULL);


            //
            // Change the field to a new value and write it out.
            //

            NameLength = ((USER_ADMIN_COMMENT_INFORMATION *)Buffer1)->AdminComment.Length;
            if (  NameLength == DummyString1.Length ) {
                ((USER_ADMIN_COMMENT_INFORMATION *)Buffer1)->AdminComment = DummyString2;
            } else {
                ((USER_ADMIN_COMMENT_INFORMATION *)Buffer1)->AdminComment = DummyString1;
            }

            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserAdminCommentInformation,
                           Buffer1
                           );
            if ( NT_SUCCESS(NtStatus) ) {

                //
                // Now check that the change was really made...
                //

                NtStatus = SamQueryInformationUser(
                               UserHandle1,
                               UserAdminCommentInformation,
                               &Buffer2
                               );
                ASSERT(NT_SUCCESS( NtStatus ) );
                if (
                    !RtlCompareString(
                        (PSTRING)&((USER_ADMIN_COMMENT_INFORMATION *)Buffer1)->AdminComment,
                        (PSTRING)&((USER_ADMIN_COMMENT_INFORMATION *)Buffer2)->AdminComment,
                        TRUE)
                    ) {

                    printf("Succeeded\n");

                } else {

                    printf("Failed\n");
                    printf("        Value queried doesn't match value written\n");
                    printf("        Value Written is   %wZ\n",
                        (PUNICODE_STRING)&((USER_ADMIN_COMMENT_INFORMATION *)Buffer1)->AdminComment);
                    printf("        Value Retrieved is %wZ\n",
                        (PUNICODE_STRING)&((USER_ADMIN_COMMENT_INFORMATION *)Buffer2)->AdminComment);

                    TestStatus = FALSE;

                }

                SamFreeMemory( Buffer1 );
                SamFreeMemory( Buffer2 );

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
                SamFreeMemory( Buffer1 );

            }


        printf("      Set Workstations  . . . . . . . . . . . . . . . . . .     ");
        printf("BROKEN TEST - NOT TESTED\n");
#ifdef BROKEN
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_WRITE_ACCOUNT | USER_READ_LOGON,
                           DOMAIN_USER_RID_ADMIN,
                           &UserHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            //
            // Get the current value...
            //

            Buffer1 = NULL;
            NtStatus = SamQueryInformationUser(
                           UserHandle1,
                           UserWorkStationsInformation,
                           &Buffer1
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(Buffer1 != NULL);


            //
            // Change the field to a new value and write it out.
            //

            NameLength = ((USER_WORKSTATIONS_INFORMATION *)Buffer1)->WorkStations.Length;
            if (  NameLength == DummyString1.Length ) {
                ((USER_WORKSTATIONS_INFORMATION *)Buffer1)->WorkStations = DummyString2;
            } else {
                ((USER_WORKSTATIONS_INFORMATION *)Buffer1)->WorkStations = DummyString1;
            }

            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserWorkStationsInformation,
                           Buffer1
                           );
            if ( NT_SUCCESS(NtStatus) ) {

                //
                // Now check that the change was really made...
                //

                NtStatus = SamQueryInformationUser(
                               UserHandle1,
                               UserWorkStationsInformation,
                               &Buffer2
                               );
                ASSERT(NT_SUCCESS( NtStatus ) );
                if (
                    !RtlCompareString(
                        (PSTRING)&((USER_WORKSTATIONS_INFORMATION *)Buffer1)->WorkStations,
                        (PSTRING)&((USER_WORKSTATIONS_INFORMATION *)Buffer2)->WorkStations,
                        TRUE)
                    ) {

                    printf("Succeeded\n");

                } else {

                    printf("Failed\n");
                    printf("        Value queried doesn't match value written\n");
                    printf("        Value Written is   %wZ\n",
                        (PUNICODE_STRING)&((USER_WORKSTATIONS_INFORMATION *)Buffer1)->WorkStations);
                    printf("        Value Retrieved is %wZ\n",
                        (PUNICODE_STRING)&((USER_WORKSTATIONS_INFORMATION *)Buffer2)->WorkStations);

                    TestStatus = FALSE;

                }

                SamFreeMemory( Buffer1 );
                SamFreeMemory( Buffer2 );

            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
                SamFreeMemory( Buffer1 );

            }
#endif //BROKEN


        printf("      Set Internal1   . . . . . . . . . . . . . . . . . . .     ");

            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_WRITE_ACCOUNT | USER_READ_LOGON | USER_FORCE_PASSWORD_CHANGE,
                           DOMAIN_USER_RID_ADMIN,
                           &UserHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            //
            // We can't get the current values, since this level is only
            // queryable by trusted clients.  So just try setting a couple
            // of values and make sure that we don't get an error.
            //

            Buffer1 = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof(USER_INTERNAL1_INFORMATION) );
            ASSERT( Buffer1 != NULL );

            ((PUSER_INTERNAL1_INFORMATION)Buffer1)->NtPasswordPresent = FALSE;
            ((PUSER_INTERNAL1_INFORMATION)Buffer1)->LmPasswordPresent = FALSE;

            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserInternal1Information,
                           Buffer1
                           );

            if (NtStatus != STATUS_PASSWORD_RESTRICTION) {

                printf("Failed\n");
                printf("    Expected Status = 0x%lx\n", STATUS_PASSWORD_RESTRICTION);
                printf("    Received Status = 0x%lx\n", NtStatus );
                TestStatus = FALSE;

            } else {

                //
                // The NULL password worked, so let's try a real password.
                //

                NtStatus = RtlCalculateNtOwfPassword(
                    &DummyName1,
                    &((PUSER_INTERNAL1_INFORMATION)Buffer1)->NtOwfPassword
                    );
                ASSERT(NT_SUCCESS(NtStatus));

                ((PUSER_INTERNAL1_INFORMATION)Buffer1)->NtPasswordPresent = TRUE;

                NtStatus = RtlCalculateLmOwfPassword(
                    DUMMY_STRING1,
                    &((PUSER_INTERNAL1_INFORMATION)Buffer1)->LmOwfPassword
                    );
                ASSERT(NT_SUCCESS(NtStatus));

                ((PUSER_INTERNAL1_INFORMATION)Buffer1)->LmPasswordPresent = TRUE;

                NtStatus = SamSetInformationUser(
                               UserHandle1,
                               UserInternal1Information,
                               Buffer1
                               );

                if ( NT_SUCCESS(NtStatus) ) {

                    printf("Succeeded\n");

                } else {

                    printf("Failed\n");
                    printf("    Return status was %lx\n", NtStatus );
                    TestStatus = FALSE;
                }
            }

            RtlFreeHeap( RtlProcessHeap(), 0, Buffer1 );


// This is the code that used to be here, when UserInternal1Information was
// queryable by non-trusted clients...
//
//            Buffer1 = NULL;
//            NtStatus = SamQueryInformationUser(
//                           UserHandle1,
//                           UserInternal1Information,
//                           &Buffer1
//                           );
//            TST_SUCCESS_ASSERT(NtStatus);
//            ASSERT(Buffer1 != NULL);
//
//            //
//            // The passwords were initially empty.  Put in some random
//            // OWF passwords, and have them written out.
//            //
//
//            NtStatus = RtlCalculateNtOwfPassword(
//                (PNT_PASSWORD)&DummyName1,
//                &EncryptedPasswordBuffer
//                );
//
//            ((USER_INTERNAL1_INFORMATION *)Buffer1)->CaseSensitiveUnicode.Buffer = (PCHAR)&EncryptedPasswordBuffer;
//            ((USER_INTERNAL1_INFORMATION *)Buffer1)->CaseSensitiveUnicode.Length = 16;
//            ((USER_INTERNAL1_INFORMATION *)Buffer1)->CaseSensitiveUnicode.MaximumLength = 16;
//
//            NtStatus = RtlCalculateNtOwfPassword(
//                (PNT_PASSWORD)&DummyName2,
//                &EncryptedPasswordBuffer2
//                );
//
//            ((USER_INTERNAL1_INFORMATION *)Buffer1)->CaseInsensitiveDbcs.Buffer = (PCHAR)&EncryptedPasswordBuffer2;
//            ((USER_INTERNAL1_INFORMATION *)Buffer1)->CaseInsensitiveDbcs.Length = 16;
//            ((USER_INTERNAL1_INFORMATION *)Buffer1)->CaseInsensitiveDbcs.MaximumLength = 16;
//
//            NtStatus = SamSetInformationUser(
//                           UserHandle1,
//                           UserInternal1Information,
//                           Buffer1
//                           );
//            if ( NT_SUCCESS(NtStatus) ) {
//
//                //
//                // Now check that the change was really made...
//                //
//
//                NtStatus = SamQueryInformationUser(
//                               UserHandle1,
//                               UserInternal1Information,
//                               &Buffer2
//                               );
//                ASSERT(NT_SUCCESS( NtStatus ) );
//
//                if ( (
//                    !RtlCompareString(
//                        (PSTRING)&((USER_INTERNAL1_INFORMATION *)Buffer1)->CaseSensitiveUnicode,
//                        (PSTRING)&((USER_INTERNAL1_INFORMATION *)Buffer2)->CaseSensitiveUnicode,
//                        TRUE)
//                    ) || (
//                    !RtlCompareString(
//                        (PSTRING)&((USER_INTERNAL1_INFORMATION *)Buffer1)->CaseInsensitiveDbcs,
//                        (PSTRING)&((USER_INTERNAL1_INFORMATION *)Buffer2)->CaseInsensitiveDbcs,
//                        TRUE)
//                    ) ) {
//
//                    printf("Succeeded\n");
//
//                } else {
//
//                    printf("Failed\n");
//                    printf("        Value queried doesn't match value written\n");
//                    printf("        CaseInsensitiveDbcs Written is   %wZ\n",
//                        (PUNICODE_STRING)&((USER_INTERNAL1_INFORMATION *)Buffer1)->CaseInsensitiveDbcs);
//                    printf("        CaseInsensitiveDbcs Retrieved is %wZ\n",
//                        (PUNICODE_STRING)&((USER_INTERNAL1_INFORMATION *)Buffer2)->CaseInsensitiveDbcs);
//                    printf("        CaseSensitiveUnicode Written is   %wZ\n",
//                        (PUNICODE_STRING)&((USER_INTERNAL1_INFORMATION *)Buffer1)->CaseSensitiveUnicode);
//                    printf("        CaseSensitiveUnicode Retrieved is %wZ\n",
//                        (PUNICODE_STRING)&((USER_INTERNAL1_INFORMATION *)Buffer2)->CaseSensitiveUnicode);
//
//                    TestStatus = FALSE;
//
//                }
//
//                SamFreeMemory( Buffer1 );
//                SamFreeMemory( Buffer2 );
//
//            } else {
//                printf("Failed\n");
//                printf("        Completion status is 0x%lx\n", NtStatus);
//                TestStatus = FALSE;
//                SamFreeMemory( Buffer1 );
//
//            }



        printf("      Set Internal2   . . . . . . . . . . . . . . . . . . .     ");

            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_WRITE_ACCOUNT | USER_READ_LOGON,
                           DOMAIN_USER_RID_ADMIN,
                           &UserHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            //
            // We can't get the current values, since this level is only
            // queryable by trusted clients.  We can't set either, but
            // try it and make sure we get the correct error.
            //

            Buffer1 = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof(USER_INTERNAL2_INFORMATION) );
            ASSERT( Buffer1 != NULL );

            ((USER_INTERNAL2_INFORMATION *)Buffer1)->LastLogon.HighPart = 1;
            ((USER_INTERNAL2_INFORMATION *)Buffer1)->LastLogoff.HighPart = 2;
            ((USER_INTERNAL2_INFORMATION *)Buffer1)->LastLogon.LowPart = 3;
            ((USER_INTERNAL2_INFORMATION *)Buffer1)->LastLogoff.LowPart = 4;
            ((USER_INTERNAL2_INFORMATION *)Buffer1)->BadPasswordCount = 5;
            ((USER_INTERNAL2_INFORMATION *)Buffer1)->LogonCount = 6;

            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserInternal2Information,
                           Buffer1
                           );

            RtlFreeHeap( RtlProcessHeap(), 0, Buffer1 );

            if ( NtStatus == STATUS_INVALID_INFO_CLASS ) {

                printf("Succeeded\n");

            } else {

                printf("Failed\n");
                printf("    Expected Status = 0x%lx\n", STATUS_INVALID_INFO_CLASS);
                printf("    Received Status = 0x%lx\n", NtStatus );
                TestStatus = FALSE;
            }

// This is the code that was here when UserInternal2Information could be
// queried and set by non-trusted clients...
//
//            //
//            // Get the current values...
//            //
//
//            Buffer1 = NULL;
//            NtStatus = SamQueryInformationUser(
//                           UserHandle1,
//                           UserInternal2Information,
//                           &Buffer1
//                           );
//            TST_SUCCESS_ASSERT(NtStatus);
//            ASSERT(Buffer1 != NULL);
//
//            //
//            // Now change the fields and write them out.
//            //
//
//            ((USER_INTERNAL2_INFORMATION *)Buffer1)->LastLogon.HighPart += 1;
//            ((USER_INTERNAL2_INFORMATION *)Buffer1)->LastLogoff.HighPart += 1;
//            ((USER_INTERNAL2_INFORMATION *)Buffer1)->LastLogon.LowPart += 2;
//            ((USER_INTERNAL2_INFORMATION *)Buffer1)->LastLogoff.LowPart += 2;
//            ((USER_INTERNAL2_INFORMATION *)Buffer1)->BadPasswordCount += 1;
//            ((USER_INTERNAL2_INFORMATION *)Buffer1)->LogonCount += 1;
//
//            NtStatus = SamSetInformationUser(
//                           UserHandle1,
//                           UserInternal2Information,
//                           Buffer1
//                           );
//            if ( NT_SUCCESS(NtStatus) ) {
//
//                //
//                // Now check that the change was really made...
//                //
//
//                NtStatus = SamQueryInformationUser(
//                               UserHandle1,
//                               UserInternal2Information,
//                               &Buffer2
//                               );
//                ASSERT(NT_SUCCESS( NtStatus ) );
//                if (
//                    (((USER_INTERNAL2_INFORMATION *)Buffer1)->LastLogon.HighPart ==
//                    ((USER_INTERNAL2_INFORMATION *)Buffer2)->LastLogon.HighPart) &&
//                    (((USER_INTERNAL2_INFORMATION *)Buffer1)->LastLogon.LowPart ==
//                    ((USER_INTERNAL2_INFORMATION *)Buffer2)->LastLogon.LowPart) &&
//                    (((USER_INTERNAL2_INFORMATION *)Buffer1)->LastLogoff.HighPart ==
//                    ((USER_INTERNAL2_INFORMATION *)Buffer2)->LastLogoff.HighPart) &&
//                    (((USER_INTERNAL2_INFORMATION *)Buffer1)->LastLogoff.LowPart ==
//                    ((USER_INTERNAL2_INFORMATION *)Buffer2)->LastLogoff.LowPart) &&
//                    (((USER_INTERNAL2_INFORMATION *)Buffer1)->BadPasswordCount ==
//                    ((USER_INTERNAL2_INFORMATION *)Buffer2)->BadPasswordCount) &&
//                    (((USER_INTERNAL2_INFORMATION *)Buffer1)->LogonCount ==
//                    ((USER_INTERNAL2_INFORMATION *)Buffer2)->LogonCount)
//                     ) {
//
//                    printf("Succeeded\n");
//
//                } else {
//
//                    printf("Failed\n");
//                    printf("        Value queried doesn't match value written\n");
//
//                    TestStatus = FALSE;
//
//                }
//
//                SamFreeMemory( Buffer1 );
//                SamFreeMemory( Buffer2 );
//
//            } else {
//                printf("Failed\n");
//                printf("        Completion status is 0x%lx\n", NtStatus);
//                TestStatus = FALSE;
//                SamFreeMemory( Buffer1 );
//
//            }



        printf("      Set Password  . . . . . . . . . . . . . . . . . . . .     ");

            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_FORCE_PASSWORD_CHANGE,
                           DOMAIN_USER_RID_ADMIN,
                           &UserHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            //
            // Create a fake cleartext UNICODE password and write it out.
            //

            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserSetPasswordInformation,
                           &DummyName2
                           );
            if ( NT_SUCCESS(NtStatus) ) {

                //
                // We can't verify that it really worked, so we just have
                // to trust the return code.
                //

                printf("Succeeded\n");

            } else {

                printf("Failed\n");
                printf("    Return code was %lx\n", NtStatus );
                TestStatus = FALSE;
            }



        printf("      Set Control . . . . . . . . . . . . . . . . . . . . .     ");
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_WRITE_ACCOUNT | USER_READ_ACCOUNT,
                           DOMAIN_USER_RID_ADMIN,
                           &UserHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            Buffer1 = NULL;
            NtStatus = SamQueryInformationUser(
                           UserHandle1,
                           UserControlInformation,
                           &Buffer1
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(Buffer1 != NULL);

            //
            // Change the value and write it back
            //

            ((USER_CONTROL_INFORMATION *)Buffer1)->UserAccountControl ^= USER_HOME_DIRECTORY_REQUIRED;


            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserControlInformation,
                           Buffer1
                           );
            if (NT_SUCCESS(NtStatus)) {

                //
                // Check the written value to make sure it stuck
                //

                Buffer2 = NULL;
                NtStatus = SamQueryInformationUser(
                               UserHandle1,
                               UserControlInformation,
                               &Buffer2
                               );
                TST_SUCCESS_ASSERT(NtStatus);
                ASSERT(Buffer2 != NULL);

                if ( ((USER_CONTROL_INFORMATION *)Buffer1)->UserAccountControl  ==
                     ((USER_CONTROL_INFORMATION *)Buffer2)->UserAccountControl ) {

                    printf("Succeeded\n");

                    SamFreeMemory( Buffer2 );

                    //
                    // Make sure the account is left enabled to prevent problems.
                    //

                    ((USER_CONTROL_INFORMATION *)Buffer1)->UserAccountControl &= ~USER_ACCOUNT_DISABLED;

                    IgnoreStatus = SamSetInformationUser(
                                       UserHandle1,
                                       UserControlInformation,
                                       Buffer1
                                       );
                    ASSERT(NT_SUCCESS(IgnoreStatus));

                } else {
                    printf("Failed\n");
                    printf("        Returned Value Doesn't Match Set Value.\n");
                    TestStatus = FALSE;
                }
            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }
            SamFreeMemory( Buffer1 );
            IgnoreStatus = SamCloseHandle( UserHandle1 );
            ASSERT( NT_SUCCESS(IgnoreStatus) );


        printf("      Set Expires . . . . . . . . . . . . . . . . . . . . .     ");
        printf("BROKEN TEST - NOT TESTED\n");
#ifdef BROKEN
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_WRITE_ACCOUNT | USER_READ_ACCOUNT,
                           DOMAIN_USER_RID_ADMIN,
                           &UserHandle1
                           );
            ASSERT(NT_SUCCESS(NtStatus) );

            Buffer1 = NULL;
            NtStatus = SamQueryInformationUser(
                           UserHandle1,
                           UserExpiresInformation,
                           &Buffer1
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(Buffer1 != NULL);

            //
            // Change the value and write it back
            //

            ((USER_EXPIRES_INFORMATION *)Buffer1)->AccountExpires.LowPart  += 1234;
            ((USER_EXPIRES_INFORMATION *)Buffer1)->AccountExpires.HighPart += 1234;


            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserExpiresInformation,
                           Buffer1
                           );
            if (NT_SUCCESS(NtStatus)) {

                //
                // Check the written value to make sure it stuck
                //

                Buffer2 = NULL;
                NtStatus = SamQueryInformationUser(
                               UserHandle1,
                               UserExpiresInformation,
                               &Buffer2
                               );
                TST_SUCCESS_ASSERT(NtStatus);
                ASSERT(Buffer2 != NULL);

                if ( ( ((USER_EXPIRES_INFORMATION *)Buffer1)->AccountExpires.LowPart  ==
                       ((USER_EXPIRES_INFORMATION *)Buffer2)->AccountExpires.LowPart )  &&
                     ( ((USER_EXPIRES_INFORMATION *)Buffer1)->AccountExpires.HighPart  ==
                       ((USER_EXPIRES_INFORMATION *)Buffer2)->AccountExpires.HighPart ) ) {

                    printf("Succeeded\n");

                    SamFreeMemory( Buffer2 );

                    //
                    // Change the values back
                    //

                    ((USER_EXPIRES_INFORMATION *)Buffer1)->AccountExpires.LowPart  += 1234;
                    ((USER_EXPIRES_INFORMATION *)Buffer1)->AccountExpires.HighPart += 1234;

                    IgnoreStatus = SamSetInformationUser(
                                       UserHandle1,
                                       UserExpiresInformation,
                                       Buffer1
                                       );
                    ASSERT(NT_SUCCESS(IgnoreStatus));

                } else {
                    printf("Failed\n");
                    printf("        Returned Value Doesn't Match Set Value.\n");
                    TestStatus = FALSE;
                }
            } else {
                printf("Failed\n");
                printf("        Completion status is 0x%lx\n", NtStatus);
                TestStatus = FALSE;
            }
            SamFreeMemory( Buffer1 );
            IgnoreStatus = SamCloseHandle( UserHandle1 );
            ASSERT( NT_SUCCESS(IgnoreStatus) );
#endif //BROKEN



        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Change Password For User Suite                                        //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Change Password For User  . . . . . . . . . . . . . .   Suite\n");

        printf("      Change Password For Well-Known User . . . . . . . . .     ");

        NtStatus = SamOpenUser(
                       DomainHandle,
                       USER_CHANGE_PASSWORD,
                       DOMAIN_USER_RID_ADMIN,
                       &UserHandle1
                       );
        ASSERT(NT_SUCCESS(NtStatus) );

        Buffer = NULL;

        //
        // The current password is DummyName2.  Using DummyName2 as the
        // old password, change it to DummyName1 and make sure we get
        // STATUS_SUCCESS.
        //

        NtStatus = SamChangePasswordUser(
                       UserHandle1,
                       &DummyName2,
                       &DummyName1
                       );

        //
        // The current password is DummyName1.  Using something WRONG for
        // the old password, try to change it to DummyName2 and make sure
        // it doesn't succeed.
        //

        if ( NtStatus == STATUS_SUCCESS ) {

            NtStatus = SamChangePasswordUser(
                           UserHandle1,
                           &DummyName2,
                           &DummyName2
                           );

            if ( NtStatus == STATUS_SUCCESS ) {

                NtStatus = STATUS_UNSUCCESSFUL;

            } else {

                NtStatus = STATUS_SUCCESS;
            }
        }

        //
        // The current password is DummyName1.  Using DummyName1 as the
        // old password, change it to DummyName2 and make sure it works
        // since by default there is no password history.
        //

        if ( NtStatus == STATUS_SUCCESS ) {

            NtStatus = SamChangePasswordUser(
                           UserHandle1,
                           &DummyName1,
                           &DummyName2
                           );
        }

        if ( NT_SUCCESS( NtStatus ) ) {

            printf("Succeeded\n");

        } else {

            printf("Failed\n");
            printf("        Status is %lx\n", NtStatus);

            TestStatus = FALSE;
        }

        IgnoreStatus = SamCloseHandle( UserHandle1 );
        ASSERT( NT_SUCCESS(IgnoreStatus) );

    }

// END PASS #1

    if (Pass == 2) {

        printf("\n");
        printf("\n");
        printf("  User  (Pass #2) . . . . . . . . . . . . . . . . . . .   Test\n");


        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Delete User  Suite                                                    //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Delete User   . . . . . . . . . . . . . . . . . . . .   Suite\n");



        printf("      Delete Normal User  . . . . . . . . . . . . . . . . .     ");

        //
        // This User was created in pass #1
        //

        RtlInitString( &AccountNameAnsi, USER_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        NtStatus = SamLookupNamesInDomain(
                       DomainHandle,
                       1,
                       &AccountNames[0],
                       &LookedUpRids,
                       &LookedUpUses
                       );
        TST_SUCCESS_ASSERT(NtStatus);
        ASSERT(LookedUpUses[0] == SidTypeUser);
        RtlFreeUnicodeString( &AccountNames[0] );



        UserHandle1 = NULL;

        NtStatus = SamOpenUser( DomainHandle, DELETE, LookedUpRids[0], &UserHandle1 );
        TST_SUCCESS_ASSERT(NtStatus);
        SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );

        NtStatus = SamDeleteUser( UserHandle1 );
        if (NT_SUCCESS(NtStatus)) {
            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }




        printf("      Delete Admin Group Member . . . . . . . . . . . . . .     ");
        printf("(Unimplemented)\n");

        printf("      Delete Last Admin Group Member  . . . . . . . . . . .     ");
        printf("(Unimplemented)\n");





        ///////////////////////////////////////////////////////////////////////////
        //                                                                       //
        // Set User Suite                                                        //
        //                                                                       //
        ///////////////////////////////////////////////////////////////////////////

        printf("\n");
        printf("    Set User (Pass 2) . . . . . . . . . . . . . . . . . .   Suite\n");

        printf("      Set ALL information. . . . . . . . . . . .     ");
        printf("BROKEN TEST - NOT TESTED\n");
#ifdef BROKEN

        RtlInitString( &AccountNameAnsi, "AllUser" );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        UserRid = 0;
        UserHandle1 = NULL;
        NtStatus = SamCreateUserInDomain(
                       DomainHandle,
                       &AccountName,
                       USER_ALL_ACCESS,
                       &UserHandle1,
                       &UserRid
                       );
        RtlFreeUnicodeString( &AccountName );

        ASSERT(NT_SUCCESS(NtStatus));

        All = NULL;

        NtStatus = SamQueryInformationUser(
                       UserHandle1,
                       UserAllInformation,
                       &All
                       );

        if ( NT_SUCCESS( NtStatus ) ) {

            //
            // Now change some of the data, and set it
            //

            RtlInitString( &TmpAnsiString, "FullName" );
            TmpStatus = RtlAnsiStringToUnicodeString(
                            (PUNICODE_STRING)(&All->FullName),
                            &TmpAnsiString,
                            TRUE );
            ASSERT( NT_SUCCESS( TmpStatus ) );

            RtlInitString( &TmpAnsiString, "HomeDirectory" );
            TmpStatus = RtlAnsiStringToUnicodeString(
                            (PUNICODE_STRING)(&All->HomeDirectory),
                            &TmpAnsiString,
                            TRUE );
            ASSERT( NT_SUCCESS( TmpStatus ) );

            RtlInitString( &TmpAnsiString, "HomeDirectoryDrive" );
            TmpStatus = RtlAnsiStringToUnicodeString(
                            (PUNICODE_STRING)(&All->HomeDirectoryDrive),
                            &TmpAnsiString,
                            TRUE );
            ASSERT( NT_SUCCESS( TmpStatus ) );

            RtlInitString( &TmpAnsiString, "ScriptPath" );
            TmpStatus = RtlAnsiStringToUnicodeString(
                            (PUNICODE_STRING)(&All->ScriptPath),
                            &TmpAnsiString,
                            TRUE );
            ASSERT( NT_SUCCESS( TmpStatus ) );

            RtlInitString( &TmpAnsiString, "ProfilePath" );
            TmpStatus = RtlAnsiStringToUnicodeString(
                            (PUNICODE_STRING)(&All->ProfilePath),
                            &TmpAnsiString,
                            TRUE );
            ASSERT( NT_SUCCESS( TmpStatus ) );

            RtlInitString( &TmpAnsiString, "AdminComment" );
            TmpStatus = RtlAnsiStringToUnicodeString(
                            (PUNICODE_STRING)(&All->AdminComment),
                            &TmpAnsiString,
                            TRUE );
            ASSERT( NT_SUCCESS( TmpStatus ) );

            RtlInitString( &TmpAnsiString, "WorkStations" );
            TmpStatus = RtlAnsiStringToUnicodeString(
                            (PUNICODE_STRING)(&All->WorkStations),
                            &TmpAnsiString,
                            TRUE );
            ASSERT( NT_SUCCESS( TmpStatus ) );

            RtlInitString( &TmpAnsiString, "UserComment" );
            TmpStatus = RtlAnsiStringToUnicodeString(
                            (PUNICODE_STRING)(&All->UserComment),
                            &TmpAnsiString,
                            TRUE );
            ASSERT( NT_SUCCESS( TmpStatus ) );

            RtlInitString( &TmpAnsiString, "Parameters" );
            TmpStatus = RtlAnsiStringToUnicodeString(
                            (PUNICODE_STRING)(&All->Parameters),
                            &TmpAnsiString,
                            TRUE );
            ASSERT( NT_SUCCESS( TmpStatus ) );

            All->CountryCode = 7;
            All->CodePage = 8;

            All->PasswordExpired = TRUE;
            All->NtPasswordPresent = TRUE;
            All->LmPasswordPresent = FALSE;

            RtlInitString( &TmpAnsiString, "NtPassword" );
            TmpStatus = RtlAnsiStringToUnicodeString(
                            (PUNICODE_STRING)(&All->NtPassword),
                            &TmpAnsiString,
                            TRUE );
            ASSERT( NT_SUCCESS( TmpStatus ) );

            All->LogonHours.UnitsPerWeek = 7;

            All->WhichFields =  ( USER_ALL_FULLNAME |
                                USER_ALL_HOMEDIRECTORY |
                                USER_ALL_HOMEDIRECTORYDRIVE |
                                USER_ALL_SCRIPTPATH |
                                USER_ALL_PROFILEPATH |
                                USER_ALL_ADMINCOMMENT |
                                USER_ALL_WORKSTATIONS |
                                USER_ALL_USERCOMMENT |
                                USER_ALL_PARAMETERS |
                                USER_ALL_COUNTRYCODE |
                                USER_ALL_CODEPAGE |
                                USER_ALL_PASSWORDEXPIRED |
                                USER_ALL_NTPASSWORDPRESENT |
                                USER_ALL_LOGONHOURS );

            NtStatus = SamSetInformationUser(
                           UserHandle1,
                           UserAllInformation,
                           All
                           );

            if ( NT_SUCCESS( NtStatus ) ) {

                NtStatus = SamQueryInformationUser(
                               UserHandle1,
                               UserAllInformation,
                               &All2
                               );

                if ( NT_SUCCESS( NtStatus ) ) {

                    //
                    // Verify that queried info is as we set it
                    //

                    if (

                        //
                        // Fields that we didn't touch.  Note that
                        // PasswordMustChange changed anyway, since we
                        // changed from a null to a non-null password.
                        //

                        ( All2->WhichFields != (USER_ALL_READ_GENERAL_MASK    |
                                               USER_ALL_READ_PREFERENCES_MASK |
                                               USER_ALL_READ_ACCOUNT_MASK     |
                                               USER_ALL_READ_LOGON_MASK) ) ||
                        ( All->LastLogon.QuadPart != All2->LastLogon.QuadPart) ||
                        ( All->LastLogoff.QuadPart != All2->LastLogoff.QuadPart) ||
                        ( All->PasswordLastSet.QuadPart != All2->PasswordLastSet.QuadPart) ||
                        ( All->AccountExpires.QuadPart != All2->AccountExpires.QuadPart) ||
                        ( All->PasswordCanChange.QuadPart != All2->PasswordCanChange.QuadPart) ||
                        ( All->PasswordMustChange.QuadPart == All2->PasswordMustChange.QuadPart) ||
                        (RtlCompareUnicodeString(
                            &(All->UserName),
                            &(All2->UserName),
                            FALSE) != 0) ||
                        ( All->UserId != All2->UserId ) ||
                        ( All->PrimaryGroupId != All2->PrimaryGroupId ) ||
                        ( All->UserAccountControl != All2->UserAccountControl ) ||
                        ( All->PrivateDataSensitive !=
                            All2->PrivateDataSensitive ) ||

                        // Fields that we changed.  Note that we set
                        // NtPasswordSet, but it shouldn't be set on return.

                        (RtlCompareUnicodeString(
                            &(All->FullName),
                            &(All2->FullName),
                            FALSE) != 0) ||
                        (RtlCompareUnicodeString(
                            &(All->HomeDirectory),
                            &(All2->HomeDirectory),
                            FALSE) != 0) ||
                        (RtlCompareUnicodeString(
                            &(All->HomeDirectoryDrive),
                            &(All2->HomeDirectoryDrive),
                            FALSE) != 0) ||
                        (RtlCompareUnicodeString(
                            &(All->ScriptPath),
                            &(All2->ScriptPath),
                            FALSE) != 0) ||
                        (RtlCompareUnicodeString(
                            &(All->ProfilePath),
                            &(All2->ProfilePath),
                            FALSE) != 0) ||
                        (RtlCompareUnicodeString(
                            &(All->AdminComment),
                            &(All2->AdminComment),
                            FALSE) != 0) ||
                        (RtlCompareUnicodeString(
                            &(All->WorkStations),
                            &(All2->WorkStations),
                            FALSE) != 0) ||
                        (RtlCompareUnicodeString(
                            &(All->UserComment),
                            &(All2->UserComment),
                            FALSE) != 0) ||
                        (RtlCompareUnicodeString(
                            &(All->Parameters),
                            &(All2->Parameters),
                            FALSE) != 0) ||
                        ( All->CountryCode != All2->CountryCode ) ||
                        ( All->CodePage != All2->CodePage ) ||
                        ( All->LmPasswordPresent != All2->LmPasswordPresent ) ||
                        ( All->NtPasswordPresent == All2->NtPasswordPresent ) ||
                        ( All->LogonHours.UnitsPerWeek !=
                            All2->LogonHours.UnitsPerWeek )
                        ) {

                        NtStatus = STATUS_DATA_ERROR;
                    }

                    SamFreeMemory( All2 );
                }
            }

            SamFreeMemory( All );
        }

        if (NtStatus == STATUS_SUCCESS) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }

        //
        // Now get rid of the user account if necessary
        //

        NtStatus = SamDeleteUser( UserHandle1 );
        ASSERT(NT_SUCCESS(NtStatus));
#endif //BROKEN


        printf("      Set Primary Group (non member). . . . . . . . . . . .     ");
        //
        // The following user might already exist (from earlier in the test)
        //

        RtlInitString( &AccountNameAnsi, USER_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );


        UserRid = 0;
        UserHandle1 = NULL;
        NtStatus = SamCreateUserInDomain(
                       DomainHandle,
                       &AccountName,
                       USER_ALL_ACCESS,
                       &UserHandle1,
                       &UserRid
                       );
        RtlFreeUnicodeString( &AccountName );
        DeleteUser = TRUE;
        if (NtStatus == STATUS_USER_EXISTS) {
            DeleteUser = FALSE;
            RtlInitString( &AccountNameAnsi, USER_NAME1 );
            NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
            TST_SUCCESS_ASSERT(NtStatus);

            NtStatus = SamLookupNamesInDomain(
                           DomainHandle,
                           1,
                           &AccountNames[0],
                           &LookedUpRids,
                           &LookedUpUses
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(LookedUpUses[0] == SidTypeUser);
            RtlFreeUnicodeString( &AccountNames[0] );
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_ALL_ACCESS,
                           LookedUpRids[0],
                           &UserHandle1);
            SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );
        }

        ASSERT(NT_SUCCESS(NtStatus));


        //
        // The user is not a member of DOMAIN_GROUP_RID_ADMINS.
        // See if we can make this group the user's primary group
        //

        ASSERT(sizeof(GroupRid) == sizeof(USER_PRIMARY_GROUP_INFORMATION));
        GroupRid = DOMAIN_GROUP_RID_ADMINS;
        NtStatus = SamSetInformationUser(
                       UserHandle1,
                       UserPrimaryGroupInformation,
                       &GroupRid
                       );

        if (NtStatus == STATUS_MEMBER_NOT_IN_GROUP) {

            printf("Succeeded\n");

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


        //
        // Now get rid of the user account if necessary
        //

        if (DeleteUser == TRUE) {
            NtStatus = SamDeleteUser( UserHandle1 );
            ASSERT(NT_SUCCESS(NtStatus));
        } else {
            NtStatus = SamCloseHandle( UserHandle1 );
            ASSERT(NT_SUCCESS(NtStatus));
        }



        printf("      Set Primary Group (member). . . . . . . . . . . . . .     ");

        //
        // Make a user (might already exist)
        // Make a group
        // Make the group the user's primary group
        // Change the user so the group isn't the primary group
        // remove the group
        // delete the group
        // If we created the user, delete it.

        //
        // The following user might already exist (from earlier in the test)
        //

        RtlInitString( &AccountNameAnsi, USER_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );

        UserRid = 0;
        UserHandle1 = NULL;
        NtStatus = SamCreateUserInDomain(
                       DomainHandle,
                       &AccountName,
                       USER_ALL_ACCESS,
                       &UserHandle1,
                       &UserRid
                       );
        RtlFreeUnicodeString( &AccountName );
        DeleteUser = TRUE;
        if (NtStatus == STATUS_USER_EXISTS) {
            DeleteUser = FALSE;
            RtlInitString( &AccountNameAnsi, USER_NAME1 );
            NtStatus = RtlAnsiStringToUnicodeString( &AccountNames[0], &AccountNameAnsi, TRUE );
            TST_SUCCESS_ASSERT(NtStatus);

            NtStatus = SamLookupNamesInDomain(
                           DomainHandle,
                           1,
                           &AccountNames[0],
                           &LookedUpRids,
                           &LookedUpUses
                           );
            RtlFreeUnicodeString( &AccountNames[0] );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(LookedUpUses[0] == SidTypeUser);
            UserRid = LookedUpRids[0];
            NtStatus = SamOpenUser(
                           DomainHandle,
                           USER_ALL_ACCESS,
                           UserRid,
                           &UserHandle1);
            SamFreeMemory( LookedUpUses ); SamFreeMemory( LookedUpRids );
        }

        ASSERT(NT_SUCCESS(NtStatus));


        //
        // create the group
        //

        RtlInitString( &AccountNameAnsi, GROUP_NAME1 );
        NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi, TRUE );
        TST_SUCCESS_ASSERT(NtStatus);

        //InitializeObjectAttributes( &ObjectAttributes, &AccountName, 0, 0, NULL );

        GroupRid = 0;
        GroupHandle1 = NULL;
        NtStatus = SamCreateGroupInDomain(
                       DomainHandle,
                       &AccountName,
                       GROUP_ALL_ACCESS,
                       &GroupHandle1,
                       &GroupRid
                       );
        RtlFreeUnicodeString( &AccountName );
        ASSERT(NT_SUCCESS(NtStatus));

        //
        // Make the user a member of this group
        //

        NtStatus = SamAddMemberToGroup(
                       GroupHandle1,
                       UserRid,
                       SE_GROUP_MANDATORY              |
                           SE_GROUP_ENABLED_BY_DEFAULT |
                           SE_GROUP_ENABLED
                       );
        ASSERT(NT_SUCCESS(NtStatus));


        //
        // Set the user's primary group Id to be this group
        //

        NtStatus = SamSetInformationUser(
                       UserHandle1,
                       UserPrimaryGroupInformation,
                       &GroupRid
                       );
        if (NT_SUCCESS(NtStatus)) {

            Buffer1 = NULL;
            NtStatus = SamQueryInformationUser(
                           UserHandle1,
                           UserPrimaryGroupInformation,
                           &Buffer1
                           );
            TST_SUCCESS_ASSERT(NtStatus);
            ASSERT(Buffer1 != NULL);

            if ( ((USER_PRIMARY_GROUP_INFORMATION *)Buffer1)->PrimaryGroupId  ==
                 GroupRid ) {

                printf("Succeeded\n");

                SamFreeMemory( Buffer1 );
            } else {

                printf("Failed\n");
                printf("        Returned Value Doesn't Match Set Value.\n");
                printf("        Value written is: 0x%lx\n", GroupRid);
                printf("      Value retrieved is: 0x%lx\n",
                    ((USER_PRIMARY_GROUP_INFORMATION *)Buffer1)->PrimaryGroupId);
                TestStatus = FALSE;

            }

        } else {
            printf("Failed\n");
            printf("        Completion status is 0x%lx\n", NtStatus);
            TestStatus = FALSE;
        }


        //
        // Set the user's primary group Id back and remove the user
        // from the group
        //

        GroupRid = DOMAIN_GROUP_RID_USERS;
        NtStatus = SamSetInformationUser(
                       UserHandle1,
                       UserPrimaryGroupInformation,
                       &GroupRid
                       );
        ASSERT(NT_SUCCESS(NtStatus));
        NtStatus = SamRemoveMemberFromGroup(GroupHandle1, UserRid);
        ASSERT(NT_SUCCESS(NtStatus));



        //
        // Now get rid of the group and possibly the user account
        //


        NtStatus = SamDeleteGroup( GroupHandle1 );
        ASSERT(NT_SUCCESS(NtStatus));

        if (DeleteUser == TRUE) {
            NtStatus = SamDeleteUser( UserHandle1 );
            ASSERT(NT_SUCCESS(NtStatus));
        } else {
            NtStatus = SamCloseHandle( UserHandle1 );
            ASSERT(NT_SUCCESS(NtStatus));
        }









        printf("      Set Name Information  . . . . . . . . . . . . . . . .     ");
        printf("(Untested)\n");


    }

    return(TestStatus);



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\client\tshut.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tshut.c

Abstract:

    This test is used to shut-down a SAM server.  This might be useful
    for killing SAM without rebooting during development.

Author:

    Jim Kelly    (JimK)  12-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntsam.h>
#include <ntrtl.h>      // DbgPrint()





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID
main (
    VOID
    )

/*++

Routine Description:

    This is the main entry routine for this test.

Arguments:

    None.

Return Value:


    Note:


--*/
{
    NTSTATUS            NtStatus;
    SAM_HANDLE          ServerHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;


    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL );


    NtStatus = SamConnect(
                  NULL,                     // ServerName (Local machine)
                  &ServerHandle,
                  SAM_SERVER_ALL_ACCESS,
                  &ObjectAttributes
                  );

    DbgPrint("SAM TEST (Tshut): Status of SamConnect() is: 0x%lx\n", NtStatus);
    if (!NT_SUCCESS(NtStatus)) { return; }


    NtStatus = SamShutdownSamServer( ServerHandle );
    DbgPrint("SAM TEST (Tshut): Status of SamShutdownSamServer() is: 0x%lx\n", NtStatus);
    if (!NT_SUCCESS(NtStatus)) { return; }


    //
    // I'm not sure why, but it seems to take another awakening of the
    // server to make it die.
    //

    NtStatus = SamConnect(
                  NULL,                     // ServerName (Local machine)
                  &ServerHandle,
                  SAM_SERVER_ALL_ACCESS,
                  &ObjectAttributes
                  );



    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\idl\makefile.inc ===
#
# This is the MIDL compile phase of the build process.
#
# The following symbols should be defined in your environment:
#       NOTE: This file is designed to provide separate generation
#             of client and server stubs.  Right now, it uses an
#             .acf for only the client stub generation.  However,
#             lines to cause a server .acf file to be used are present
#             but commented out.
# The following is where you put the name of your .idl file without
# the .idl extension:


CLIENT_ACF = samcli.acf
SERVER_ACF = $(PROJECT_ROOT)\published\ds\sam\idl\samsrv.acf

CLIENT_INC_FILE= $(IDL_NAME)_c.h
SERVER_INC_FILE= $(IDL_NAME).h

CLIENT_TARGETS = \
        $(O)\$(IDL_NAME)_c.c \
        $(O)\$(CLIENT_INC_FILE)

SERVER_TARGETS = \
        $(O)\$(IDL_NAME)_s.c \
        $(O)\$(SERVER_INC_FILE)

MIDL_INCS= -I$(SDK_INC_PATH)  -I$(CRT_INC_PATH) -I$(DS_INC_PATH) -I$(PROJECT_ROOT)\published\ds\sam\idl
MIDL_OPTIMIZATION_NT5=-Oicf -robust -error all

CLIENT_FLAGS  = $(MIDL_OPTIMIZATION_NT5) -oldnames -c_ext -ms_ext $(MIDL_FLAGS) -acf $(CLIENT_ACF) -server none -out .\$(O) -header $(CLIENT_INC_FILE)
SERVER_FLAGS  = $(MIDL_OPTIMIZATION_NT5) -oldnames -c_ext -ms_ext $(MIDL_FLAGS) -acf $(SERVER_ACF) -client none -out .\$(O) -header $(SERVER_INC_FILE)

CPP = -cpp_cmd "$(MIDL_CPP)"

TARGETS: \
        $(CLIENT_TARGETS) \
        $(SERVER_TARGETS)

clean:
    -del /F /Q $(CLIENT_TARGETS)
    -del /F /Q $(SERVER_TARGETS)

$(CLIENT_TARGETS): $(PROJECT_ROOT)\published\ds\sam\idl\$(IDL_NAME).idl $(CLIENT_ACF)
    $(MIDL) $(CPP) $(CLIENT_FLAGS) $(MIDL_INCS) $(PROJECT_ROOT)\published\ds\sam\idl\$(IDL_NAME).idl

$(SERVER_TARGETS): $(PROJECT_ROOT)\published\ds\sam\idl\$(IDL_NAME).idl $(SERVER_ACF)
    $(MIDL) $(CPP) $(SERVER_FLAGS) $(MIDL_INCS) $(PROJECT_ROOT)\published\ds\sam\idl\$(IDL_NAME).idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\lib\recmem.c ===
#include <ntosp.h>
#include <nturtl.h>
#include "recmem.h"



#ifdef RECOVERY_KERNELMODE


PVOID
RecSamAlloc(
    ULONG Size
    )
{
    return ExAllocatePool( PagedPool, Size );
}

VOID
RecSamFree(
    PVOID p
    )
{
    ExFreePool( p );
}


#else  // RECOVERY_KERNELMODE


PVOID
RecSamAlloc(
    ULONG Size
    )
{
    return RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, Size);
}
VOID
RecSamFree(
    PVOID p
    )
{
    RtlFreeHeap(RtlProcessHeap(), 0, p);
}



#endif // RECOVERY_KERNELMODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\lib\recmem.h ===
PVOID
RecSamAlloc(
    ULONG Size
    );

VOID
RecSamFree(
    PVOID p
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\lib\recovery.c ===
/*++

Copyright (C) Microsoft Corporation, 1998.
              Microsoft Windows

Module Name:

    RECOVERY.C

Abstract:

    This file provides the implement which using SysKey to decrypt password.
    It is used by recovery tool during system recovery, so that the local
    machine's administrator gets authenticated before we grant system access
    for recovery.

    The argorithm used here is stated as follows:

    1. Looks into SAM Account Domain's Fixed Length Attribute.
       Checks the boot option type, determines how the local machine is syskey'd.
       If the machine is syskey'd, then retrieve the Encrypted Password
       Encryption Key.

    2. Looks up the User Account by Rid passed in. If we finds the User
       Account whose Rid equal to the Rid passed in. Retrieves it's
       Encrypted NT OWF Password

    3. Depending on how the machine is syekey'd. Tring to get the SysKey.

       3.1 SysKey is not enabled on this machine. Ok. nothing special to do.

       3.2 Syskey is stored in Registry, go ahead retrieve it.

       3.3 Syskey is derived from Boot Password or stored in floppy disk,
           then check the optional Parameter, if caller passed it to us,
           use it. Otherwise, if caller passed NULL, return error, let
           caller handle this through appropriate promots.


    4. At this point, we should have all information we might need.

       4.1 Machine is syskey enabled.

           Use SysKey to decrypt Encrypted Password Encryption Key, then
           use the Clear Password Encryption Key to decrypt NT Owf Password,
           Return the Clear NT OWF password.

       4.2 Machine is not syskey enabled.

           Return the NT OWF Password with minial modification.

    5. End

Author:

    09-Jan-99 ShaoYin

Environment:

    Kernel Mode - Win32

Revision History:

    08-Jan-99 ShaoYin Created Initial File.

--*/


//////////////////////////////////////////////////////////////////////////
//                                                                      //
//    Include header files                                              //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


//
// NT header files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <zwapi.h>


//
// Windows header files
//

#include <nturtl.h>
#include <windows.h>

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>

//
// header files related to recovery authenticate
//
#include <samsrvp.h>
#include <enckey.h>
#include <rc4.h>
#include <md5.h>
#include <wxlpc.h>
#include "recovery.h"
#include "recmem.h"



#define SAMP_SERVER_KEY_NAME            L"SAM"
#define SAMP_ACCOUNT_DOMAIN_KEY_NAME    L"SAM\\Domains\\Account"
#define SAMP_USERS_KEY_NAME             L"SAM\\Domains\\Account\\Users\\"
#define SAMP_USERSNAME_KEY_NAME         L"SAM\\Domains\\Account\\Users\\Names\\"
#define SECURITY_POLICY_POLSECRETENCRYPTIONKEY  L"Policy\\PolSecretEncryptionKey"



#define DwordAlignUlong( v ) (((v)+3) & 0xfffffffc)
//
// Helper macro to make object attribute initialization a little cleaner.
//
#define INIT_OBJA(Obja,UnicodeString,UnicodeText)           \
                                                            \
    RtlInitUnicodeString((UnicodeString),(UnicodeText));    \
                                                            \
    InitializeObjectAttributes(                             \
        (Obja),                                             \
        (UnicodeString),                                    \
        OBJ_CASE_INSENSITIVE,                               \
        NULL,                                               \
        NULL                                                \
        )



//
// Domain Information Class
// 

typedef enum _REC_DOMAIN_INFO_CLASS {
    RecDomainBootAndSessionKeyInfo = 1,
    RecDomainRidInfo
} REC_DOMAIN_INFO_CLASS;


//
// the following typedef should be in sync with 
// nt\private\security\lsa\server\dspolicy\dbp.h
// in stead of include <dbp.h>, just put what we need here.
//


typedef struct _LSAP_DB_ENCRYPTION_KEY {
    ULONG   Revision;
    ULONG   BootType;
    ULONG   Flags;
    GUID    Authenticator;
    UCHAR   Key [16];//128 bit key
    UCHAR   OldSyskey[16]; // for recovery
    UCHAR   Salt[16];//128 bit Salt
} LSAP_DB_ENCRYPTION_KEY, *PLSAP_DB_ENCRYPTION_KEY;


static GUID LsapDbPasswordAuthenticator = {0xf0ce3a80,0x155f,0x11d3,0xb7,0xe6,0x00,0x80,0x5f,0x48,0xca,0xeb};







//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Forward declaration                                                  //
//                                                                      //
//////////////////////////////////////////////////////////////////////////



NTSTATUS
WxReadSysKeyForRecovery(
    IN HANDLE hSystemRootKey,
    IN OUT PULONG BufferLength,
    OUT PVOID  Key
    );

NTSTATUS
DuplicateUnicodeString(
    OUT PUNICODE_STRING OutString,
    IN  PUNICODE_STRING InString
    );

NTSTATUS
SampRetrieveRegistryAttribute(
    IN HANDLE   hKey,
    IN PVOID    Buffer,
    IN ULONG    BufferLength,
    IN PUNICODE_STRING AttributeName,
    OUT PULONG  RequiredLength
    );

NTSTATUS
SampGetEncryptionKeyDataFromSecurityHive(
    IN  HANDLE  hSecurityRootKey,
    OUT PLSAP_DB_ENCRYPTION_KEY EncryptionKeyData
    );

NTSTATUS
SampDecryptOldSyskeyWithNewSyskey(
    IN LSAP_DB_ENCRYPTION_KEY  * KeyToDecrypt,
    IN PVOID   Syskey,
    IN ULONG   SyskeyLength
    );

NTSTATUS
SampGetFixedDomainInfo(
    IN  HANDLE  hSamRootKey,
    IN  REC_DOMAIN_INFO_CLASS   RecDomainInfoClass,
    IN  ULONG   ServerRevision,
    OUT ULONG   *BootAuthType OPTIONAL,
    OUT ULONG   *CurrentKeyId,
    OUT ULONG   *PreviousKeyId,
    OUT KEEncKey *EncryptedSessionKey,
    OUT KEEncKey *EncryptedSessionKeyPrevious,
    OUT BOOLEAN *PreviousSessionKeyExists,
    OUT ULONG   *NextRid
    );

NTSTATUS
SampRetrieveSysKeyFromRegistry(
    IN HANDLE  hSystemRootKey,
    IN ULONG   BootAuthType,
    OUT KEClearKey *SysKey
    );


NTSTATUS
SampRetrieveVariableAttr(
    IN PUCHAR Buffer,
    IN ULONG AttributeIndex,
    OUT PUNICODE_STRING StoredBuffer
    );

NTSTATUS
SampGetPwdByRid(
    IN ULONG Rid,
    IN HANDLE hSamRootKey,
    OUT PUNICODE_STRING StoredBuffer
    );

NTSTATUS
SampGetRidAndPwdByAccountName(
    IN PWCHAR AccountName,
    IN HANDLE hSamRootKey,
    OUT ULONG *Rid,
    OUT PUNICODE_STRING EncryptedOwfPwd
    );

NTSTATUS
SampDecryptOwfPwd(
    IN ULONG Rid,
    IN ULONG BootAuthType,
    IN BOOLEAN PreviousSessionKeyExists,
    IN ULONG CurrentKeyId,
    IN ULONG PreviousKeyId,
    IN KEClearKey *ClearSessionKey,
    IN KEClearKey *ClearSessionKeyPrevious,
    IN UNICODE_STRING *EncryptedNtOwfPwd,
    OUT UNICODE_STRING *ClearNtOwfPwd
    );

NTSTATUS
SampDecryptSessionKey(
    IN BOOLEAN      OldSyskeyAvailable,
    IN PLSAP_DB_ENCRYPTION_KEY StoredEncryptionKeyData,
    IN KEClearKey   *DecryptionKey,
    IN KEEncKey     *EncryptedSessionKey,
    OUT KEClearKey  *ClearSessionKey
    );

NTSTATUS
SampGetServerRevision(
    IN HANDLE   hSamRootKey, 
    OUT ULONG   *ServerRevision
    );

//////////////////////////////////////////////////////////////////////////
//                                                                      //
//     Exported API                                                     //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

                
NTSTATUS
SampGetServerRevision(
    IN HANDLE   hSamRootKey, 
    OUT ULONG   *ServerRevision
    )
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    HANDLE      hServerKey = INVALID_HANDLE_VALUE;
    OBJECT_ATTRIBUTES Attributes;
    UNICODE_STRING    ServerKeyName;
    UNICODE_STRING    CombinedAttributeName;
    PUCHAR            Buffer = NULL;
    ULONG             BufferLength = 0;
    ULONG             RequiredLength = 0;
    PSAMP_V1_FIXED_LENGTH_SERVER ServerFixedAttr = NULL;

    //
    // Create the object we will be opening in the registry
    //
    INIT_OBJA(&Attributes, &ServerKeyName, SAMP_SERVER_KEY_NAME);
    Attributes.RootDirectory = hSamRootKey;

    //
    // Try to open for read control
    //
    NtStatus = ZwOpenKey(
                    &hServerKey,
                    KEY_READ,
                    &Attributes
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        return( NtStatus );
    }

    //
    // Retrieve Fixed attribute
    //
    RtlInitUnicodeString(&CombinedAttributeName, L"C");

    NtStatus = SampRetrieveRegistryAttribute(
                        hServerKey,
                        Buffer,
                        BufferLength,
                        &CombinedAttributeName,
                        &RequiredLength
                        );

    if (STATUS_BUFFER_TOO_SMALL == NtStatus ||
        STATUS_BUFFER_OVERFLOW == NtStatus)
    {
        BufferLength = DwordAlignUlong(RequiredLength);
        Buffer = RecSamAlloc( BufferLength );

        if (NULL == Buffer)
        {
            NtStatus = STATUS_NO_MEMORY;
            goto Error;
        }
        RtlZeroMemory(Buffer, BufferLength);

        NtStatus = SampRetrieveRegistryAttribute(
                            hServerKey,
                            Buffer,
                            BufferLength,
                            &CombinedAttributeName,
                            &RequiredLength
                            );
    }

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    ServerFixedAttr = (PSAMP_V1_FIXED_LENGTH_SERVER) (Buffer +
                       FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

    *ServerRevision = ServerFixedAttr->RevisionLevel;
                       

Error:

    //
    // close the handle
    //

    if (INVALID_HANDLE_VALUE != hServerKey)
    {
        ZwClose(hServerKey);
    }

    if (NULL != Buffer)
    {
        RecSamFree(Buffer);
        Buffer = NULL;
    }


    return( NtStatus );
}

//
// Only retrieve NT OWF Password only,
// if required, we can add support to retrieve LM OWF PWD.
//

NTSTATUS
SampDecryptSessionKey(
    IN BOOLEAN      OldSyskeyAvailable,
    IN PLSAP_DB_ENCRYPTION_KEY StoredEncryptionKeyData,
    IN KEClearKey   *DecryptionKey,
    IN KEEncKey     *EncryptedSessionKey,
    OUT KEClearKey  *ClearSessionKey
    )
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       DecryptStatus = 0;
    KEEncKey    TempEncryptedSessionKey;
    KEClearKey  OldDecryptionKey;

    //
    // init local variables
    //  
    RtlZeroMemory(&TempEncryptedSessionKey, sizeof(KEEncKey));
    RtlZeroMemory(&OldDecryptionKey, sizeof(KEClearKey));

    //
    // Save the EncryptedSessionKey, KEDecryptKey() will destroy EncryptedSessionKey
    // before return.
    // 
    TempEncryptedSessionKey = (*EncryptedSessionKey);

    //
    // use syskey (DecryptionKey) to decrypt session key
    // 
    DecryptStatus = KEDecryptKey(
                        DecryptionKey,            // KEClearKey - syskey
                        EncryptedSessionKey,      // KEEncKey - encrypted password encryption key
                        ClearSessionKey,          // KEClearKey - clear password encryption key
                        0);

    if ((KE_BAD_PASSWORD == DecryptStatus) &&
        OldSyskeyAvailable)
    {
        // 
        // Decrypt Old Syskey
        // 

        NtStatus = SampDecryptOldSyskeyWithNewSyskey(
                        StoredEncryptionKeyData,
                        DecryptionKey->ClearKey,
                        KE_KEY_SIZE
                        );

        if (STATUS_SUCCESS != NtStatus)
        {
            goto Error;
        }

        OldDecryptionKey.dwVersion = KE_CUR_VERSION;
        OldDecryptionKey.dwLength = sizeof(KEClearKey);
        RtlCopyMemory(OldDecryptionKey.ClearKey,
                      StoredEncryptionKeyData->OldSyskey,
                      KE_KEY_SIZE
                      );

        //
        // Try using the Old Syskey to get the session key
        // 

        DecryptStatus = KEDecryptKey(
                            &OldDecryptionKey,
                            &TempEncryptedSessionKey,
                            ClearSessionKey,
                            0);
    }

    if (KE_OK != DecryptStatus)
    {
        NtStatus = STATUS_INTERNAL_ERROR;
    }

Error:
    //
    // Cleanup and return
    // 
    RtlZeroMemory(&TempEncryptedSessionKey, sizeof(KEEncKey));
    RtlZeroMemory(&OldDecryptionKey, sizeof(KEClearKey));

    return( NtStatus );
}


NTSTATUS
SamRetrieveOwfPasswordUser(
    IN ULONG    Rid,
    IN HANDLE   hSecurityRootKey,
    IN HANDLE   hSamRootKey,
    IN HANDLE   hSystemRootKey,
    IN PUNICODE_STRING BootKey OPTIONAL,
    IN USHORT   BootKeyType OPTIONAL,
    OUT PNT_OWF_PASSWORD NtOwfPassword,
    OUT PBOOLEAN NtPasswordPresent,
    OUT PBOOLEAN NtPasswordNonNull
    )
/*++
Routine Description:

    This routine will return the desired User's NT OWF(One Way Function)
    password to caller. If the local machine is syskey'ed, this routine
    will do the decryption work as well. Depending on how this machine is
    syskey'd, it might require the caller to provide the BootKey information.
    If caller does not pass in the BootKey, this routine will fail gracefully
    and return proper status code to indicate what we require.

Parameters:

    Rid - Logon user's Relative ID

    hSecurityRootKey - Handle of the Root of SECURITY hive

    hSamRootKey - Handle of the Root of the SAM hive

    hSystemRootKey - Handle of the Root of the System Hive

                     caller should Load the SAM hive and System hive,
                     and Unload them after this API returns

    BootKey - Optional, caller should provide this parameter if the local
              machine's syskey is stored as Boot Password or stored in
              separate floppy disk

    BootKeyType - Optional, accociated with BootKey. If BootKey is NULL,
                  BootKeyType is never been used. Otherwise, indicate
                  what kind of info BootKey contains.
                  Valid Value:
                        SamBootKeyPassword - BootKey contains the boot password
                                             in UNICODE_STRING format
                        SamBootKeyDisk - BootKey contains the syskey read from
                                         Disk. We are going to use the syskey
                                         without any modification.

    NtOwfPassword - Used to return the NT OWF Password if we found one.

    NtPasswordPresent - return to caller to indicate the NT OWF password
                        is presented or not.

    NtPasswordNonNull - indicate the password in Null or not.

Return Values:

    NTSTATUS code
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG    BootAuthType = 0;
    KEEncKey EncryptedSessionKey;
    KEEncKey EncryptedSessionKeyPrevious;
    KEClearKey DecryptionKey;
    KEClearKey ClearSessionKey;
    KEClearKey ClearSessionKeyPrevious;
    UNICODE_STRING EncryptedNtOwfPwd;
    UNICODE_STRING ClearNtOwfPwd;
    UNICODE_STRING  NullPassword;
    NT_OWF_PASSWORD NullNtOwfPassword;
    ULONG       CryptIndex = Rid;
    ULONG       CurrentKeyId = 1;
    ULONG       PreviousKeyId = 0;
    ULONG       ServerRevision = 0;
    LSAP_DB_ENCRYPTION_KEY StoredEncryptionKeyData;
    BOOLEAN     OldSyskeyAvailable = FALSE;
    BOOLEAN     PreviousSessionKeyExists = FALSE;

    //
    // Check parameters
    //
    if (INVALID_HANDLE_VALUE == hSamRootKey ||
        INVALID_HANDLE_VALUE == hSystemRootKey ||
        INVALID_HANDLE_VALUE == hSecurityRootKey ||
        NULL == NtOwfPassword ||
        NULL == NtPasswordPresent ||
        NULL == NtPasswordNonNull )
    {
        return (STATUS_INVALID_PARAMETER);
    }

    //
    // Initialize local variable
    //
    RtlInitUnicodeString(&NullPassword, NULL);

    NtStatus = RtlCalculateNtOwfPassword(
                        &NullPassword,
                        &NullNtOwfPassword
                        );

    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    RtlZeroMemory(&EncryptedNtOwfPwd, sizeof(UNICODE_STRING));
    RtlZeroMemory(&ClearNtOwfPwd, sizeof(UNICODE_STRING));
    RtlZeroMemory(&EncryptedSessionKey, sizeof(KEEncKey));
    RtlZeroMemory(&EncryptedSessionKeyPrevious, sizeof(KEEncKey));
    RtlZeroMemory(&DecryptionKey, sizeof(KEClearKey));
    RtlZeroMemory(&ClearSessionKey, sizeof(KEClearKey));
    RtlZeroMemory(&ClearSessionKeyPrevious, sizeof(KEClearKey));
    RtlZeroMemory(&StoredEncryptionKeyData, sizeof(StoredEncryptionKeyData));


    //
    // Get SAM Server Object Revision first
    // 
    NtStatus = SampGetServerRevision(hSamRootKey,
                                     &ServerRevision
                                     );
                
    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    //
    // Get Boot Key Type from security hive
    //
    
    NtStatus = SampGetEncryptionKeyDataFromSecurityHive(
                        hSecurityRootKey,
                        &StoredEncryptionKeyData
                        );

    if (STATUS_OBJECT_NAME_NOT_FOUND == NtStatus)
    {
        //
        // Before build 2078, we store the boot option in SAM hive.
        // for the old build < 2078, switch to SAM hive to get the 
        // boot key type
        // 
        NtStatus = SampGetFixedDomainInfo(
                        hSamRootKey,                    // SamHiveRootKey
                        RecDomainBootAndSessionKeyInfo, // InfoClass
                        ServerRevision,                 // Server Revision
                        &BootAuthType,                  // BootAuthType
                        &CurrentKeyId,                  // CurrentKeyId
                        &PreviousKeyId,                 // PreviousKeyId
                        &EncryptedSessionKey,           // EncryptedSessionkey
                        &EncryptedSessionKeyPrevious,   // EncryptedSessionKeyPrevious
                        &PreviousSessionKeyExists,      // PreviousSessionKeyExists
                        NULL                            // NextRid
                        );

    }
    else if (STATUS_SUCCESS == NtStatus)
    {
        OldSyskeyAvailable = TRUE;
        BootAuthType = StoredEncryptionKeyData.BootType;
        //
        // Get Encrypted Session Key (ONLY) 
        // from Account Domain (in registry)
        //
        NtStatus = SampGetFixedDomainInfo(
                        hSamRootKey,                    // SamHiveRootKey
                        RecDomainBootAndSessionKeyInfo, // InfoClass
                        ServerRevision,                 // Server Revision
                        NULL,                           // BootAuthType
                        &CurrentKeyId,                  // CurrentKeyId
                        &PreviousKeyId,                 // PreviousKeyId
                        &EncryptedSessionKey,           // EncryptedSessionkey
                        &EncryptedSessionKeyPrevious,   // EncryptedSessionKeyPrevious
                        &PreviousSessionKeyExists,      // PreviousSessionKeyExists
                        NULL                            // NextRid
                        );

    }


    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }


    //
    // Get the SysKey (Boot Key)
    //
    switch (BootAuthType)
    {
    case WxStored:

        // retrieve the Key from registry

        NtStatus = SampRetrieveSysKeyFromRegistry(
                                hSystemRootKey,
                                BootAuthType,
                                &DecryptionKey
                                );
        break;

    case WxPrompt:

        //
        // Caller should provide this information
        //

        if (NULL == BootKey)
        {
            //
            // set return error code, so that the caller
            // will know we need logon user to enter
            // the boot key (syskey).
            //
            NtStatus = STATUS_SAM_NEED_BOOTKEY_PASSWORD;
        }
        else
        {
            MD5_CTX Md5;

            if (SamBootKeyPassword != BootKeyType)
            {
                NtStatus = STATUS_INVALID_PARAMETER;
                goto Error;
            }

            //
            // derive the syskey from the boot password
            //

            MD5Init( &Md5 );
            MD5Update( &Md5, (PUCHAR) BootKey->Buffer, BootKey->Length );
            MD5Final( &Md5 );

            DecryptionKey.dwVersion = KE_CUR_VERSION;
            DecryptionKey.dwLength = sizeof(KEClearKey);
            RtlCopyMemory(DecryptionKey.ClearKey,
                          Md5.digest,
                          KE_KEY_SIZE
                          );
        }
        break;

    case WxDisk:

        //
        // Caller should provide this information
        //

        if (NULL == BootKey || NULL == BootKey->Buffer)
        {
            //
            // set error return code, so that the caller
            // can who what we need, then read the floppy
            // disk to get the boot key.
            //
            NtStatus = STATUS_SAM_NEED_BOOTKEY_FLOPPY;
        }
        else if (BootKey->Length > KE_KEY_SIZE ||
                 (SamBootKeyDisk != BootKeyType))
        {
            NtStatus = STATUS_INVALID_PARAMETER;
        }
        else
        {
            //
            // this is the syskey, use it.
            //

            DecryptionKey.dwVersion = KE_CUR_VERSION;
            DecryptionKey.dwLength = sizeof(KEClearKey);
            RtlCopyMemory(DecryptionKey.ClearKey,
                          BootKey->Buffer,
                          BootKey->Length
                          );
        }
        break;

    case WxNone:

        //
        // Machine is not syskey enabled
        // nothing to do
        //

        break;

    default:

        NtStatus = STATUS_INVALID_PARAMETER;
        break;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }


    //
    // Get the User's Encrypted Password
    //

    NtStatus = SampGetPwdByRid(Rid,
                               hSamRootKey,
                               &EncryptedNtOwfPwd
                               );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // we have the encrypted session key and the Boot Key (SysKey),
    // Now, try to get the clear session key, which is the
    // password encryption key.
    //
    if (SamBootKeyNone != BootAuthType )
    {

        NtStatus = SampDecryptSessionKey(OldSyskeyAvailable,
                                         &StoredEncryptionKeyData,
                                         &DecryptionKey,
                                         &EncryptedSessionKey,
                                         &ClearSessionKey
                                         );

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        if (PreviousSessionKeyExists)
        {
            NtStatus = SampDecryptSessionKey(OldSyskeyAvailable,
                                             &StoredEncryptionKeyData,
                                             &DecryptionKey,
                                             &EncryptedSessionKeyPrevious,
                                             &ClearSessionKeyPrevious
                                             );
            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }
        }
    }

    //
    // Decrypt the encrypted password using the clear password encryption key
    //
    NtStatus = SampDecryptOwfPwd(Rid,
                                 BootAuthType,
                                 PreviousSessionKeyExists,
                                 CurrentKeyId,
                                 PreviousKeyId,
                                 &ClearSessionKey,  // clear Password encryption key
                                 &ClearSessionKeyPrevious,   // clear pwd encryption key previous
                                 &EncryptedNtOwfPwd,// encrypted NT OWF PWD
                                 &ClearNtOwfPwd     // return clear NT Owf Pwd
                                 );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    *NtPasswordPresent = (BOOLEAN) (ClearNtOwfPwd.Length != 0);

    if (*NtPasswordPresent)
    {
        NtStatus = RtlDecryptNtOwfPwdWithIndex(
                        (PENCRYPTED_NT_OWF_PASSWORD)ClearNtOwfPwd.Buffer,
                        &CryptIndex,
                        NtOwfPassword
                        );

        if (NT_SUCCESS(NtStatus))
        {
            *NtPasswordNonNull = (BOOLEAN)!RtlEqualNtOwfPassword(
                                    NtOwfPassword,
                                    &NullNtOwfPassword
                                    );
        }
    } else {

        //
        // Fill in the NULL password for caller convenience
        //

        RtlCopyMemory(NtOwfPassword,
                      &NullNtOwfPassword,
                      sizeof(NT_OWF_PASSWORD)
                      );

        *NtPasswordNonNull = FALSE;
    }

Error:

    RtlZeroMemory(&EncryptedSessionKey, sizeof(KEEncKey));
    RtlZeroMemory(&EncryptedSessionKeyPrevious, sizeof(KEEncKey));
    RtlZeroMemory(&DecryptionKey, sizeof(KEClearKey));
    RtlZeroMemory(&ClearSessionKey, sizeof(KEClearKey));
    RtlZeroMemory(&ClearSessionKeyPrevious, sizeof(KEClearKey));
    RtlZeroMemory(&StoredEncryptionKeyData, sizeof(LSAP_DB_ENCRYPTION_KEY));

    if (NULL != EncryptedNtOwfPwd.Buffer)
    {
        RtlZeroMemory(EncryptedNtOwfPwd.Buffer, EncryptedNtOwfPwd.Length);
        RecSamFree(EncryptedNtOwfPwd.Buffer);
        RtlZeroMemory(&EncryptedNtOwfPwd, sizeof(UNICODE_STRING));
    }

    if (NULL != ClearNtOwfPwd.Buffer)
    {
        RtlZeroMemory(ClearNtOwfPwd.Buffer, ClearNtOwfPwd.Length);
        RecSamFree(ClearNtOwfPwd.Buffer);
        RtlZeroMemory(&ClearNtOwfPwd, sizeof(UNICODE_STRING));
    }

    return (NtStatus);
}





//////////////////////////////////////////////////////////////////////////
//                                                                      //
//     Private API                                                      //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

NTSTATUS
SampGetEncryptionKeyDataFromSecurityHive(
    IN  HANDLE  hSecurityRootKey,
    OUT PLSAP_DB_ENCRYPTION_KEY EncryptionKeyData
    )
/*++
Routine Description:

    This routine get the Boot Option from SECURITY hive

Parameters:

    hSeurityRootKey - Handle of the root of SECURITY hive
    
    BootAuthType - return Boot Type if success
    
Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    HANDLE      hPolSecretEncryptionKey = INVALID_HANDLE_VALUE;
    OBJECT_ATTRIBUTES   Attributes;
    UNICODE_STRING      PolSecretEncryptionKeyName;
    UNICODE_STRING      NullName;
    PKEY_VALUE_PARTIAL_INFORMATION  KeyPartialInformation = NULL;
    ULONG       KeyPartialInformationSize = 0;

    INIT_OBJA(&Attributes, &PolSecretEncryptionKeyName, SECURITY_POLICY_POLSECRETENCRYPTIONKEY);
    Attributes.RootDirectory = hSecurityRootKey;

    //
    // try to open for read control
    //
    NtStatus = ZwOpenKey(
                    &hPolSecretEncryptionKey,
                    KEY_READ,
                    &Attributes
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }


    NullName.Length = 0;
    NullName.MaximumLength = 0;
    NullName.Buffer = NULL;

    NtStatus = ZwQueryValueKey(
                    hPolSecretEncryptionKey,
                    &NullName,
                    KeyValuePartialInformation,
                    KeyPartialInformation,
                    KeyPartialInformationSize,
                    &KeyPartialInformationSize
                    );

    if (STATUS_BUFFER_TOO_SMALL == NtStatus)
    {
        KeyPartialInformation = RecSamAlloc(KeyPartialInformationSize);

        if (KeyPartialInformation)
        {
            NtStatus = ZwQueryValueKey(
                            hPolSecretEncryptionKey,
                            &NullName,
                            KeyValuePartialInformation,
                            KeyPartialInformation,
                            KeyPartialInformationSize,
                            &KeyPartialInformationSize
                            );
        }
        else
        {
            NtStatus = STATUS_NO_MEMORY;
        }
    }

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    RtlCopyMemory(EncryptionKeyData,
                  (LSAP_DB_ENCRYPTION_KEY *)KeyPartialInformation->Data,
                  sizeof(LSAP_DB_ENCRYPTION_KEY)
                  );

Error:

    if (KeyPartialInformation)
    {
        RecSamFree(KeyPartialInformation);
        KeyPartialInformation = NULL;
    }

    if (INVALID_HANDLE_VALUE != hPolSecretEncryptionKey)
    {
        NtStatus = ZwClose(hPolSecretEncryptionKey);
    }

    return( NtStatus );
}





NTSTATUS
SampDecryptOldSyskeyWithNewSyskey(
    IN LSAP_DB_ENCRYPTION_KEY  * KeyToDecrypt,
    IN PVOID   Syskey,
    IN ULONG   SyskeyLength
    )
/*++
Routine Description:

    The propose of this routine is using the New Syskey to decrypt the (encrypted)
    Old Syskey, so that we get the clear Old Syskey
    
Parameters:

    KeyToDecrypt - LSA Encryption Key Data, which contains the (encrypted) old syskey
    
    Syskey - New Syskey (clear)
    
    SyskeyLength - Length
    
Return Values:
    
    STATUS_SUCCESS - decrypted with no error
    
    STATUS_UNSUCCESSFUL - for some reason. failed. 

--*/
{
    MD5_CTX Md5Context;
    struct RC4_KEYSTRUCT Rc4Key;
    ULONG  i;
    
    //
    // Create an MD5 hash of the key and salt
    //

    MD5Init(&Md5Context);

    MD5Update(
        &Md5Context,
        Syskey,
        SyskeyLength
        );
    //
    // Hash in the salt many many times. This slows down 
    // attackers employing a brute force approach to attack
    //

    for (i=0;i<1000;i++)
    {
        MD5Update(
            &Md5Context,
            KeyToDecrypt->Salt,
            sizeof(KeyToDecrypt->Salt)
            );
    }
   
    MD5Final(
        &Md5Context
        );

    //
    // Initialize the RC4 key sequence.
    //

    rc4_key(
        &Rc4Key,
        MD5DIGESTLEN,
        Md5Context.digest
        );

   

    rc4(
        &Rc4Key,
        sizeof(KeyToDecrypt->Key)+ sizeof(KeyToDecrypt->Authenticator)+sizeof(KeyToDecrypt->OldSyskey),
        (PUCHAR) &KeyToDecrypt->Authenticator
        
        );


    if (!RtlEqualMemory(&KeyToDecrypt->Authenticator,&LsapDbPasswordAuthenticator,sizeof(GUID))) 
    {
        return( STATUS_UNSUCCESSFUL );
    }

    return( STATUS_SUCCESS );

}


NTSTATUS
SampGetFixedDomainInfo(
    IN  HANDLE  hSamRootKey,
    IN  REC_DOMAIN_INFO_CLASS   RecDomainInfoClass,
    IN  ULONG   ServerRevision,
    OUT ULONG   *BootAuthType OPTIONAL,
    OUT ULONG   *CurrentKeyId,
    OUT ULONG   *PreviousKeyId,
    OUT KEEncKey *EncryptedSessionKey,
    OUT KEEncKey *EncryptedSessionKeyPrevious,
    OUT BOOLEAN *PreviousSessionKeyExists,
    OUT ULONG   *NextRid
    )
/*++
Routine Description:

    This routine queries the Account Domain's Fixed Length Attribute stored
    in registry. Find out the Boot Type, whether the local machine is syskey'ed
    or not. And fill the EncryptedSessionKey properly.

Parameters:

    hSamRootKey - Handle of the Root of the hive

    RecDomainInfoClass - specify desired domain information

    BootAuthType - return How the machine is syskey. 
                   Since build 2078, we no longer store BootAuthType in SAM hive,
                   instead, we put the boot option in Security Hive.
                   So if this argument is not present, it means caller has already
                   got it from security hive.

    EncryptedSessionKey - once returned, contains the Encrypted Password
                          Encryption Key

    NextRid - Return the value of next available Rid                          

Return Values:

--*/
{
    NTSTATUS          NtStatus = STATUS_SUCCESS, IgnoreStatus = STATUS_SUCCESS;
    HANDLE            hDomainKey = INVALID_HANDLE_VALUE;
    OBJECT_ATTRIBUTES Attributes;
    UNICODE_STRING    DomainKeyName;
    UNICODE_STRING    FixedAttributeName;
    PUCHAR            Buffer = NULL;
    ULONG             BufferLength = 0;
    ULONG             RequiredLength = 0;

    //
    // Create the object we will be opening in the registry
    //
    INIT_OBJA(&Attributes, &DomainKeyName, SAMP_ACCOUNT_DOMAIN_KEY_NAME);
    Attributes.RootDirectory = hSamRootKey;

    //
    // Try to open for read control
    //
    NtStatus = ZwOpenKey(
                    &hDomainKey,
                    KEY_READ,
                    &Attributes
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Set value to retrieve account domain fixed attribute
    // allocate enough buffer size
    //
    BufferLength = DwordAlignUlong(sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN)) +
                   DwordAlignUlong(FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));


    Buffer = RecSamAlloc(BufferLength);

    if (NULL == Buffer)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Error;
    }

    RtlZeroMemory(Buffer, BufferLength);

    //
    // Retrieve Fixed attribute
    //
    RtlInitUnicodeString(&FixedAttributeName, L"F");

    NtStatus = SampRetrieveRegistryAttribute(
                        hDomainKey,
                        Buffer,
                        BufferLength,
                        &FixedAttributeName,
                        &RequiredLength
                        );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }


    //
    // retrieve encrypted session key depends on SAM revision
    //

    if (ServerRevision <= SAMP_WIN2K_REVISION)
    {
        PSAMP_V1_0A_WIN2K_FIXED_LENGTH_DOMAIN V1aFixed = NULL;

        V1aFixed = (PSAMP_V1_0A_WIN2K_FIXED_LENGTH_DOMAIN)(Buffer +
                    FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

        switch (RecDomainInfoClass)
        {
        case RecDomainBootAndSessionKeyInfo:

            //
            // get the boot key type
            //
            if (NULL != BootAuthType)
            {
                *BootAuthType = (ULONG) V1aFixed->DomainKeyAuthType;
            }

            //
            // if applicable, get the encrypted session key
            //
            if (V1aFixed->DomainKeyFlags & SAMP_DOMAIN_SECRET_ENCRYPTION_ENABLED)
            {
                RtlCopyMemory(EncryptedSessionKey,
                              V1aFixed->DomainKeyInformation,
                              sizeof(KEEncKey)
                              );
            }

            *CurrentKeyId = SAMP_DEFAULT_SESSION_KEY_ID;
            *PreviousKeyId = 0;
            *PreviousSessionKeyExists = FALSE;

            break;

        case RecDomainRidInfo:

            //
            // get next available rid
            //

            if (NULL != NextRid)
            {
                *NextRid = (ULONG) V1aFixed->NextRid;
            }
            else
            {
                NtStatus = STATUS_INVALID_PARAMETER;
            }
            break;

        default:
            NtStatus = STATUS_INVALID_PARAMETER;
            break;
        }
    }
    else if (ServerRevision == SAMP_WHISTLER_OR_W2K_SYSPREP_FIX_REVISION)
    {
        PSAMP_V1_0A_FIXED_LENGTH_DOMAIN V1aFixed = NULL;

        V1aFixed = (PSAMP_V1_0A_FIXED_LENGTH_DOMAIN)(Buffer +
                    FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

        switch (RecDomainInfoClass)
        {
        case RecDomainBootAndSessionKeyInfo:

            //
            // get the boot key type
            //
            if (NULL != BootAuthType)
            {
                *BootAuthType = (ULONG) V1aFixed->DomainKeyAuthType;
            }

            //
            // if applicable, get the encrypted session key
            //
            if (V1aFixed->DomainKeyFlags & SAMP_DOMAIN_SECRET_ENCRYPTION_ENABLED)
            {
                RtlCopyMemory(EncryptedSessionKey,
                              V1aFixed->DomainKeyInformation,
                              sizeof(KEEncKey)
                              );
            }

            *CurrentKeyId = V1aFixed->CurrentKeyId;
            *PreviousKeyId = V1aFixed->PreviousKeyId;
            if (V1aFixed->PreviousKeyId != 0)
            {
                *PreviousSessionKeyExists = TRUE;

                RtlCopyMemory(EncryptedSessionKeyPrevious,
                              V1aFixed->DomainKeyInformationPrevious,
                              sizeof(KEEncKey)
                              );
            }

            break;

        case RecDomainRidInfo:

            //
            // get next available rid
            //

            if (NULL != NextRid)
            {
                *NextRid = (ULONG) V1aFixed->NextRid;
            }
            else
            {
                NtStatus = STATUS_INVALID_PARAMETER;
            }
            break;

        default:
            NtStatus = STATUS_INVALID_PARAMETER;
            break;
        }

    }
    else
    {
        NtStatus = STATUS_INTERNAL_ERROR;
    }


Error:

    //
    // close the handle
    //

    if (INVALID_HANDLE_VALUE != hDomainKey)
    {
        IgnoreStatus = ZwClose(hDomainKey);
    }

    if (NULL != Buffer)
    {
        RecSamFree(Buffer);
        Buffer = NULL;
    }

    return NtStatus;
}




NTSTATUS
SampRetrieveSysKeyFromRegistry(
    IN HANDLE  hSystemRootKey,
    IN ULONG   BootAuthType,
    OUT KEClearKey *SysKey
    )
/*++
Routine Description:

    Retrieve the SysKey buried in Registry.
    Caller should only call us when BootAuthType is WxStored

Parameters:

    hSystemRootKey - handle of the root of the System Hive

    BootAuthType - Indicate How the machine is syskey'ed

        Valid Values:
            WxStored - SysKey stored in registry

        Invalid Value: (Should not call this function)
            WxPrompt - SysKey stored as boot password
            WxDisk - SysKey stored in floppy disk
            WxNone - SysKey is not enabled.

    SysKey - Once success, contains the syskey

Return Values:

    STATUS_SUCCESS
    STATUS_UNSUCCESSFUL
    STATUS_INVALID_PARAMETER
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    WXHASH OldHash;
    ULONG KeyLen = 0;


    if (WxStored != BootAuthType)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // retrieve the Key from registry
    //

    KeyLen = sizeof(OldHash.Digest);

    NtStatus = WxReadSysKeyForRecovery(hSystemRootKey,
                                       &KeyLen,
                                       &(OldHash.Digest)
                                       );

    if (!NT_SUCCESS(NtStatus))
    {
        return (NtStatus);
    }

    SysKey->dwVersion = KE_CUR_VERSION;
    SysKey->dwLength = sizeof(KEClearKey);
    RtlCopyMemory(SysKey->ClearKey,
                  OldHash.Digest,
                  KE_KEY_SIZE
                  );

    return (STATUS_SUCCESS);

}


NTSTATUS
SampRetrieveVariableAttr(
    IN PUCHAR Buffer,
    IN ULONG AttributeIndex,
    OUT PUNICODE_STRING StoredBuffer
    )
/*++
Routine Description:

    This routine retrieves one variable lengthed attribute from the
    attributes array.

Parameters:

    Buffer - Buffer contains the variable lengthed attributes and all
             related information

    AttributeIndex - Index of the desired attribute in the attributes array

    StoredBuffer - Used to returned the value of attribute

Return Values:

    STATUS_NO_MEMORY
    STATUS_SUCCESS
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE AttributeArray = NULL;
    PUCHAR  AttributeAddress = NULL;
    ULONG   VariableArrayOffset = 0;
    ULONG   VariableDataOffset = 0;
    ULONG   AttributeLength = 0;


    VariableArrayOffset = DwordAlignUlong(FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

    VariableDataOffset = DwordAlignUlong(VariableArrayOffset +
                                         (SAMP_USER_VARIABLE_ATTRIBUTES *
                                          sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE))
                                         );

    AttributeArray = (PSAMP_VARIABLE_LENGTH_ATTRIBUTE) (Buffer + VariableArrayOffset);

    AttributeAddress = (PUCHAR) (Buffer + VariableDataOffset +
                                 AttributeArray[AttributeIndex].Offset);

    AttributeLength = AttributeArray[AttributeIndex].Length;
    StoredBuffer->Length = (USHORT) AttributeLength;
    StoredBuffer->MaximumLength = (USHORT) AttributeLength;

    StoredBuffer->Buffer = RecSamAlloc(AttributeLength);

    if (NULL == StoredBuffer->Buffer)
    {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(StoredBuffer->Buffer, AttributeLength);

    RtlCopyMemory(StoredBuffer->Buffer, AttributeAddress, AttributeLength);

    return NtStatus;
}



NTSTATUS
SampGetPwdByRid(
    IN ULONG Rid,
    IN HANDLE hSamRootKey,
    OUT PUNICODE_STRING StoredBuffer
    )
/*++
Routine Description:

    This routine queries the fixed length attribute of the user account
    (specified by UserName). If the user account'd Relative ID matches the
    Rid passed in, then further retrieve this user's Encrypted NT OWF Pwd.

Parameters:

    Rid - Relative ID of the user account which we are interested in.

    hSamRootKey -- Root of the Hive

    StoredBuffer - hold this user's encrypted NT OWF Pwd.

Return Values:

    STATUS_NO_MEMORY;
    STATUS_SUCCESS;

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    HANDLE   hUserKey = INVALID_HANDLE_VALUE;
    OBJECT_ATTRIBUTES UserAttributes;
    UNICODE_STRING  UserKeyName;
    UNICODE_STRING  VariableAttributeName;
    WCHAR    UserName[REGISTRY_KEY_NAME_LENGTH_MAX];

    PUCHAR  Buffer = NULL;
    ULONG   BufferLength = 0;
    PSAMP_V1_0A_FIXED_LENGTH_USER   V1aFixed = NULL;
    ULONG   RequiredUserLength = 0;

    //
    // Construct the User Key Name
    //
    RtlZeroMemory(UserName, sizeof(UserName));


    swprintf(UserName, L"%s%8.8lx", SAMP_USERS_KEY_NAME, Rid);

    INIT_OBJA(&UserAttributes, &UserKeyName, UserName);
    UserAttributes.RootDirectory = hSamRootKey;

    //
    // Try to open for read control
    //
    NtStatus = ZwOpenKey(&hUserKey,
                         KEY_READ,
                         &UserAttributes
                         );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }


    RtlInitUnicodeString(&VariableAttributeName, L"V");

    NtStatus = SampRetrieveRegistryAttribute(
                            hUserKey,
                            NULL,
                            0,
                            &VariableAttributeName,
                            &RequiredUserLength
                            );

    if ((STATUS_BUFFER_OVERFLOW == NtStatus) ||
        (STATUS_BUFFER_TOO_SMALL == NtStatus))
    {
        BufferLength = RequiredUserLength;

        Buffer = RecSamAlloc(BufferLength);

        if (NULL == Buffer)
        {
            NtStatus = STATUS_NO_MEMORY;
            goto Error;
        }

        RtlZeroMemory(Buffer, BufferLength);
        NtStatus = SampRetrieveRegistryAttribute(
                            hUserKey,
                            Buffer,
                            BufferLength,
                            &VariableAttributeName,
                            &RequiredUserLength
                            );
    }

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    NtStatus = SampRetrieveVariableAttr(Buffer,
                                        SAMP_USER_UNICODE_PWD,
                                        StoredBuffer
                                        );

Error:

    if (INVALID_HANDLE_VALUE != hUserKey)
    {
        ZwClose(hUserKey);
    }

    if (NULL != Buffer)
    {
        RecSamFree(Buffer);
    }

    return NtStatus;
}




NTSTATUS
SampGetRidAndPwdByAccountName(
    IN PWCHAR AccountName,
    IN HANDLE hSamRootKey,
    OUT ULONG *Rid,
    OUT PUNICODE_STRING EncryptedOwfPwd
    )
/*++
Routine Description:

    This routine opens the Key in the Account Domain whose name is equal to
    the AccountName passed in. Gets its Rid from "type" of the key.
    Then calls SampGetPwdByRid()

Parameters:

    AccountName -- Logon Account Name

    hSamRootKey -- Handle of the root of the SAM hive

    Rid - return the Relative ID of the user account which we are interested in.

    EncryptedOwfPwd - once succeed, filled with that user's Nt Owf Pwd.

Return Values:

    STATUS_SUCCESS
    STATUS_NO_MEMORY;
    STATUS_NO_SUCH_USER
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES Attributes;
    HANDLE  hUserKey = INVALID_HANDLE_VALUE;
    WCHAR   UserName[REGISTRY_KEY_NAME_LENGTH_MAX];
    UNICODE_STRING  UserKeyName;
    UNICODE_STRING  UnicodeString;

    PKEY_VALUE_PARTIAL_INFORMATION  KeyPartialInformation = NULL;
    ULONG   KeyPartialInformationSize = 0;


    //
    // initialize variables
    //
    RtlZeroMemory(UserName, REGISTRY_KEY_NAME_LENGTH_MAX * sizeof(WCHAR));
    RtlZeroMemory(&UnicodeString, sizeof(UNICODE_STRING));

    //
    // construct the key name
    //
    wcscpy(UserName, SAMP_USERSNAME_KEY_NAME);
    wcscat(UserName, AccountName);

    INIT_OBJA(&Attributes, &UserKeyName, UserName);
    Attributes.RootDirectory = hSamRootKey;

    //
    // Try to open for read control
    //
    NtStatus = ZwOpenKey(&hUserKey,
                         KEY_READ,
                         &Attributes
                         );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Get the RID of the user
    //
    UnicodeString.Length = 0;
    UnicodeString.MaximumLength = 0;
    UnicodeString.Buffer = NULL;

    NtStatus = ZwQueryValueKey(hUserKey,
                               &UnicodeString,
                               KeyValuePartialInformation,
                               KeyPartialInformation,
                               KeyPartialInformationSize,
                               &KeyPartialInformationSize
                               );

    if (STATUS_BUFFER_TOO_SMALL == NtStatus)
    {
        KeyPartialInformation = RecSamAlloc(KeyPartialInformationSize);

        if (KeyPartialInformation)
        {
            NtStatus = ZwQueryValueKey(hUserKey,
                                       &UnicodeString,
                                       KeyValuePartialInformation,
                                       KeyPartialInformation,
                                       KeyPartialInformationSize,
                                       &KeyPartialInformationSize
                                       );

        }
        else
        {
            NtStatus = STATUS_NO_MEMORY;
        }
    }

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    *Rid = KeyPartialInformation->Type;

    //
    // Get the encrypted owf password
    //
    NtStatus = SampGetPwdByRid(*Rid,
                               hSamRootKey,
                               EncryptedOwfPwd
                               );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

Error:

    if (KeyPartialInformation)
    {
        RecSamFree(KeyPartialInformation);
        KeyPartialInformation = NULL;
    }

    if (INVALID_HANDLE_VALUE != hUserKey)
    {
        ZwClose(hUserKey);
    }

    return (NtStatus);
}




NTSTATUS
SampDecryptOwfPwd(
    IN ULONG Rid,
    IN ULONG BootAuthType,
    IN BOOLEAN PreviousSessionKeyExists,
    IN ULONG CurrentKeyId,
    IN ULONG PreviousKeyId,
    IN KEClearKey *ClearSessionKey,
    IN KEClearKey *ClearSessionKeyPrevious,
    IN UNICODE_STRING *EncryptedNtOwfPwd,
    OUT UNICODE_STRING *ClearNtOwfPwd
    )
/*++
Routine Description:

    This routine decrypts the Encrypted NT OWF Password properly.

Parameter:

    Rid - Relative ID of the logon user

    BootAuthType - Indicate whether this password has been encrypted or not

    ClearSessionKey - Pointer to the password encryption key

    EncryptedNtOwfPwd - Encrypted NT OWF password

    ClearNtOwfPwd - returns the clear NT OWF password

Return Values:

    STATUS_SUCCESS
    STATUS_INTERNAL_ERROR
    STATUS_NO_MEMORY

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMP_SECRET_DATA SecretData;
    struct RC4_KEYSTRUCT Rc4Key;
    MD5_CTX Md5Context;
    UCHAR * KeyToUse = NULL;
    ULONG   KeyLength = 0;
    ULONG   Key = 0;

    //
    // If encryption is not enabled, do nothing special
    // copy the Nt Owf Pwd and return immediately
    //
    if (WxNone == BootAuthType || 
        (!SampIsDataEncrypted(EncryptedNtOwfPwd)) )
    {
        return (DuplicateUnicodeString(ClearNtOwfPwd,
                                       EncryptedNtOwfPwd
                                       ));
    }

    //
    // health check of the encrypted nt owf pwd
    //
    SecretData = (PSAMP_SECRET_DATA) EncryptedNtOwfPwd->Buffer;

    if ((SecretData->KeyId != CurrentKeyId) &&
        ((!PreviousSessionKeyExists) || (SecretData->KeyId != PreviousKeyId))
        )
    {
        return (STATUS_INTERNAL_ERROR);
    }

    //
    // Compute the size of the output buffer and allocate it
    //
    ClearNtOwfPwd->Length = SampClearDataSize(EncryptedNtOwfPwd->Length);
    ClearNtOwfPwd->MaximumLength = ClearNtOwfPwd->Length;

    //
    // If there was no data we can return now.
    //
    if (0 == ClearNtOwfPwd->Length)
    {
        ClearNtOwfPwd->Buffer = NULL;
        return (STATUS_SUCCESS);
    }

    ClearNtOwfPwd->Buffer = (LPWSTR) RecSamAlloc(ClearNtOwfPwd->Length);

    if (NULL == ClearNtOwfPwd->Buffer)
    {
        return (STATUS_NO_MEMORY);
    }

    //
    // Find the Key to use
    // 
    if (SecretData->KeyId == CurrentKeyId)
    {
        KeyToUse = (PUCHAR) ClearSessionKey->ClearKey;
        KeyLength = SAMP_SESSION_KEY_LENGTH;
    }
    else if (PreviousSessionKeyExists &&
             (SecretData->KeyId == PreviousKeyId))
    {
        KeyToUse = (PUCHAR) ClearSessionKeyPrevious->ClearKey;
        KeyLength = SAMP_SESSION_KEY_LENGTH;
    }
    else
    {
        return( STATUS_INTERNAL_ERROR );
    }

    MD5Init(&Md5Context);

    MD5Update(
        &Md5Context,
        KeyToUse,
        KeyLength
        );

    MD5Update(
        &Md5Context,
        (PUCHAR) &Rid,
        sizeof(ULONG)
        );

    if (SecretData->Flags & SAMP_ENCRYPTION_FLAG_PER_TYPE_CONST)
    {
        MD5Update(
          &Md5Context,
          "NTPASSWORD",
          sizeof("NTPASSWORD")
          );
    }

    MD5Final(&Md5Context);

    rc4_key(
        &Rc4Key,
        MD5DIGESTLEN,
        Md5Context.digest
        );

    RtlCopyMemory(
        ClearNtOwfPwd->Buffer,
        SecretData->Data,
        ClearNtOwfPwd->Length
        );

    rc4(
        &Rc4Key,
        ClearNtOwfPwd->Length,
        (PUCHAR) ClearNtOwfPwd->Buffer
        );

    return (STATUS_SUCCESS);
}





NTSTATUS
SampRetrieveRegistryAttribute(
    IN HANDLE   hKey,
    IN PVOID    Buffer,
    IN ULONG    BufferLength,
    IN PUNICODE_STRING AttributeName,
    OUT PULONG  RequiredLength
    )
/*++
Routine Description:

    This Routine retrieves the value of either Fixed attribute or variable
    length attribute

Parameters:

    hKey - Registry Key, should be opened before calling this routine.

    Buffer - Pointer to a buffer to hold the value

    BufferLength - Indicate the length of the buffer

    AttirubteName - Name of the attribute

    RequiredLength - The actual length of attribute's value

Return Values:

    NtStatus - STATUS_SUCCESS
               STATUS_BUFFER_OVERFLOW or STATUS_BUFFER_TOO_SMALL

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    NtStatus = ZwQueryValueKey(hKey,
                               AttributeName,
                               KeyValuePartialInformation,
                               (PVOID) Buffer,
                               BufferLength,
                               RequiredLength
                               );

    return NtStatus;
}



NTSTATUS
SampSetRegistryAttribute(
    IN HANDLE   hKey,
    IN PUNICODE_STRING AttributeName,
    IN PVOID    Buffer,
    IN ULONG    BufferLength
    )
/*++
Routine Description:

    This Routine set the value of either Fixed attribute or variable
    length attribute to disk

Parameters:

    hKey - Registry Key, should be opened before calling this routine.

    AttirubteName - Name of the attribute

    Buffer - Pointer to a buffer to hold the value

    BufferLength - Indicate the length of the buffer

Return Values:

    NtStatus - STATUS_SUCCESS or error code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    NtStatus = ZwSetValueKey(hKey,              // KeyHandle
                             AttributeName,     // ValueName
                             0,                 // TitleIndex
                             REG_BINARY,        // Type
                             Buffer,            // Data
                             BufferLength       // DataSize
                             );

    return( NtStatus );
}




NTSTATUS
DuplicateUnicodeString(
    OUT PUNICODE_STRING OutString,
    IN  PUNICODE_STRING InString
    )
/*++
Routine Decription:

    Duplicate a unicode string

Parameter:

    OutString - Destination Unicode String
    InString - Source Unicode String

Return Value:

    NtStatus - STATUS_INVALID_PARAMETER, STATUS_NO_MEMORY
               STATUS_SUCCESS
--*/
{
    if (NULL == InString || NULL == OutString)
    {
        return STATUS_INVALID_PARAMETER;
    }

    if (InString->Length > 0)
    {
        OutString->Buffer = RecSamAlloc(InString->Length);

        if (NULL == OutString->Buffer)
        {
            return STATUS_NO_MEMORY;
        }
        OutString->MaximumLength = InString->Length;
        RtlCopyUnicodeString(OutString, InString);

    }
    else
    {
        RtlInitUnicodeString(OutString, NULL);
    }

    return(STATUS_SUCCESS);
}




NTSTATUS
SamGetNextAvailableRid(
    IN HANDLE  hSamRootKey,
    OUT PULONG pNextRid
    )
/*++
Routine Description:

    This routine reads the SAM Account Domain infomation from SAM hive, passed
    in through hSamRootKey, and returns the value of next available RID of 
    this account domain.  

Parameters:

    hSamRootKey - Handle of the Root of SAM hive

            SAM hive is located in %windir%\system32\config, name is SAM

    pNextRid - Return the value of next available Rid if success. 

Return Values:

    STATUS_SUCCESS
    or other error status code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       ServerRevision = 0;

    if ((INVALID_HANDLE_VALUE != hSamRootKey) && (NULL != pNextRid))
    {

        //
        // Get SAM Server Object Revision first
        // 
        NtStatus = SampGetServerRevision(hSamRootKey,
                                         &ServerRevision
                                         );

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = SampGetFixedDomainInfo(
                                hSamRootKey,        // SamHiveRootKey
                                RecDomainRidInfo,   // InfoClass
                                ServerRevision,     // Server Revision
                                NULL,               // BootAuthType
                                NULL,               // CurrentKeyId
                                NULL,               // PreviousKeyId
                                NULL,               // EncryptedSessionKey
                                NULL,               // EncryptedSessionKeyPrevious
                                NULL,               // PreviousSessionKeyExists
                                pNextRid
                                );
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return( NtStatus );
}


NTSTATUS
SamSetNextAvailableRid(
    IN HANDLE  hSamRootKey,
    IN ULONG   NextRid
    )
/*++
Routine Description:

    This routine queries the Account Domain's Fixed Length Attribute stored
    in registry. Update it with the passed in NextRid value.

Parameters:

    hSamRootKey - Handle of the Root of the hive

    NextRid - Set the domain next available rid to the passed in value

Return Values:

--*/
{
    NTSTATUS          NtStatus = STATUS_SUCCESS, IgnoreStatus = STATUS_SUCCESS;
    HANDLE            hDomainKey = INVALID_HANDLE_VALUE;
    OBJECT_ATTRIBUTES Attributes;
    UNICODE_STRING    DomainKeyName;
    UNICODE_STRING    FixedAttributeName;
    PUCHAR            Buffer = NULL;
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN V1aFixed = NULL;
    ULONG             BufferLength = 0;
    ULONG             RequiredLength = 0;

    //
    // Create the object we will be opening in the registry
    //
    INIT_OBJA(&Attributes, &DomainKeyName, SAMP_ACCOUNT_DOMAIN_KEY_NAME);
    Attributes.RootDirectory = hSamRootKey;

    //
    // Try to open for read control
    //
    NtStatus = ZwOpenKey(
                    &hDomainKey,
                    KEY_READ | KEY_WRITE,
                    &Attributes
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Set value to retrieve account domain fixed attribute
    //
    BufferLength = DwordAlignUlong(sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN)) +
                   DwordAlignUlong(FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));


    Buffer = RecSamAlloc(BufferLength);

    if (NULL == Buffer)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Error;
    }

    RtlZeroMemory(Buffer, BufferLength);

    //
    // Retrieve Fixed attribute
    //
    RtlInitUnicodeString(&FixedAttributeName, L"F");

    NtStatus = SampRetrieveRegistryAttribute(
                        hDomainKey,
                        Buffer,
                        BufferLength,
                        &FixedAttributeName,
                        &RequiredLength
                        );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Let the pointer point to the right place (actual data)
    //

    V1aFixed = (PSAMP_V1_0A_FIXED_LENGTH_DOMAIN)(Buffer +
                FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));


    //
    // Set next available rid to passed in value
    //

    (ULONG) V1aFixed->NextRid = NextRid;

    NtStatus = SampSetRegistryAttribute(
                        hDomainKey,
                        &FixedAttributeName,
                        V1aFixed,
                        sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN)
                        );

Error:

    //
    // close the handle
    //

    if (INVALID_HANDLE_VALUE != hDomainKey)
    {
        IgnoreStatus = ZwClose(hDomainKey);
    }

    if (NULL != Buffer)
    {
        RecSamFree(Buffer);
        Buffer = NULL;
    }

    return( NtStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\client\wrappers.c ===
/*++    

Copyright (c) 1991  Microsoft Corporation

Module Name:

    wrappers.c

Abstract:

    This file contains all SAM rpc wrapper routines.

Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "samclip.h"
#include <md5.h>
#include <rpcasync.h>
#include <wxlpc.h>

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private defines                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SAMP_MAXIMUM_SUB_LOOKUP_COUNT   ((ULONG) 0x00000200)

// Simple tracing routine for client-side API -- this should be removed once
// we understand how the DS-based SAM works. This macro is only called from
// within wrappers.c.

#define SAMP_TRACE_CLIENT_API 0

#if SAMP_TRACE_CLIENT_API == 1

#define SampOutputDebugString(Message) \
    OutputDebugStringA("SAM API = ");  \
    OutputDebugStringA(Message);       \
    OutputDebugStringA("\n");          \

#else

#define SampOutputDebugString(Message)

#endif



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Local data types                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// This structure is used to pass a (potentially) very large
// user requested name lookup into (possibly many) smaller
// remote lookup requests.  This is necessary to prevent the
// server from being asked to allocate huge chunks of memory,
// potentially running out of memory.
//
// There will be one of these structures for each server call
// that is necessary.
//

typedef struct _SAMP_NAME_LOOKUP_CALL {

    //
    // Each call is represented by one of these structures.
    // The structures are chained together to show the order
    // the calls were made (allowing an easy way to build the
    // buffer that is to be returned to the user).
    //

    LIST_ENTRY          Link;

    //
    // These fields define the beginning and ending indexes into
    // the user passed Names buffer that are being represented by
    // this call.
    //

    ULONG               StartIndex;
    ULONG               Count;


    //
    // These fields will receive the looked up RIDs and USE buffers.
    // Notice that the .Element fields of these fields will receive
    // pointers to the bulk of the returned information.
    //

    SAMPR_ULONG_ARRAY   RidBuffer;
    SAMPR_ULONG_ARRAY   UseBuffer;

} SAMP_NAME_LOOKUP_CALL, *PSAMP_NAME_LOOKUP_CALL;

//
// This is the handle returned to clients
//
typedef struct _SAMP_CLIENT_INFO
{
    // RPC context handle
    SAMPR_HANDLE ContextHandle;

    // Information about the server we are connected to
    SAMPR_REVISION_INFO_V1 ServerInfo;

    // The domain sid of the handle -- not set on handles returned
    // from SamConnect
    PSID DomainSid;  OPTIONAL

} SAMP_CLIENT_INFO, *PSAMP_CLIENT_INFO;

typedef PSAMP_CLIENT_INFO SAMP_HANDLE;



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
SampLookupIdsInDomain(
    IN SAM_HANDLE DomainHandle,
    IN ULONG Count,
    IN PULONG RelativeIds,
    OUT PUNICODE_STRING *Names,
    OUT PSID_NAME_USE *Use OPTIONAL
    );

NTSTATUS
SampMapCompletionStatus(
    IN NTSTATUS Status
    );

NTSTATUS
SampCheckStrongPasswordRestrictions(
    PUNICODE_STRING Password
    );

NTSTATUS
SampCheckPasswordRestrictions(
    IN SAMPR_HANDLE RpcContextHandle,
    IN PUNICODE_STRING NewNtPassword,
    OUT PBOOLEAN UseOwfPasswords
    );

NTSTATUS
SampCreateNewHandle(
    IN  SAMP_HANDLE RequestingHandle,
    IN  PSID        DomainSid,
    OUT SAMP_HANDLE* NewHandle
    );

VOID
SampFreeHandle(
    IN OUT SAMP_HANDLE *Handle
    );

BOOLEAN
SampIsValidClientHandle(
    IN     SAM_HANDLE  SampHandle,
    IN OUT SAMPR_HANDLE *RpcHandle OPTIONAL
    );

NTSTATUS
SampMakeSid(
    IN PSID  DomainSid,
    IN ULONG Rid,
    OUT PSID* Sid
    );


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// General services                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
SamFreeMemory(
    IN PVOID Buffer
    )

/*++
Routine Description:


    Some SAM services that return a potentially large amount of memory,
    such as an enumeration might, allocate the buffer in which the data
    is returned.  This function is used to free those buffers when they
    are no longer needed.

Parameters:

    Buffer - Pointer to the buffer to be freed.  This buffer must
        have been allocated by a previous SAM service call.

Return Values:

    STATUS_SUCCESS - normal, successful completion.


--*/
{
    if (NULL != Buffer)
    {
        MIDL_user_free( Buffer );
    }
    return(STATUS_SUCCESS);
}



NTSTATUS
SamSetSecurityObject(
    IN SAM_HANDLE ObjectHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++
Routine Description:


    This function (SamSetSecurityObject) takes a well formed Security
    Descriptor provided by the caller and assigns specified portions of
    it to an object.  Based on the flags set in the SecurityInformation
    parameter and the caller's access rights, this procedure will
    replace any or all of the security information associated with an
    object.

    This is the only function available to users and applications for
    changing security information, including the owner ID, group ID, and
    the discretionary and system ACLs of an object.  The caller must
    have WRITE_OWNER access to the object to change the owner or primary
    group of the object.  The caller must have WRITE_DAC access to the
    object to change the discretionary ACL.  The caller must have
    ACCESS_SYSTEM_SECURITY access to an object to assign a system ACL
    to the object.

    This API is modelled after the NtSetSecurityObject() system service.


Parameters:

    ObjectHandle - A handle to an existing object.

    SecurityInformation - Indicates which security information is to
        be applied to the object.  The value(s) to be assigned are
        passed in the SecurityDescriptor parameter.

    SecurityDescriptor - A pointer to a well formed Security
        Descriptor.


Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_ACCESS_DENIED - The specified handle was not opened for
        either WRITE_OWNER, WRITE_DAC, or ACCESS_SYSTEM_SECURITY
        access.

    STATUS_INVALID_HANDLE - The specified handle is not that of an
        opened SAM object.

    STATUS_BAD_DESCRIPTOR_FORMAT - Indicates something about security descriptor
        is not valid.  This may indicate that the structure of the descriptor is
        not valid or that a component of the descriptor specified via the
        SecurityInformation parameter is not present in the security descriptor.

    STATUS_INVALID_PARAMETER - Indicates no security information was specified.



--*/
{
    NTSTATUS                        NtStatus;

    ULONG                           SDLength;
    SAMPR_SR_SECURITY_DESCRIPTOR    DescriptorToPass;
    SAMPR_HANDLE                    RpcContextHandle;

    SampOutputDebugString("SamSetSecurityObject");

    if (!SampIsValidClientHandle(ObjectHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Make a self relative security descriptor for use in the RPC call..
    //


    SDLength = 0;
    NtStatus = RtlMakeSelfRelativeSD(
                   SecurityDescriptor,
                   NULL,
                   &SDLength
                   );

    if (NtStatus != STATUS_BUFFER_TOO_SMALL) {

        return(STATUS_INVALID_PARAMETER);

    } else {


        DescriptorToPass.SecurityDescriptor = MIDL_user_allocate( SDLength );
        DescriptorToPass.Length = SDLength;
        if (DescriptorToPass.SecurityDescriptor == NULL) {

            NtStatus = STATUS_INSUFFICIENT_RESOURCES;

        } else {


            //
            // make an appropriate self-relative security descriptor
            //

            NtStatus = RtlMakeSelfRelativeSD(
                           SecurityDescriptor,
                           (PSECURITY_DESCRIPTOR)DescriptorToPass.SecurityDescriptor,
                           &SDLength
                           );
        }

    }







    //
    // Call the server ...
    //

    if (NT_SUCCESS(NtStatus)) {
        RpcTryExcept{

            NtStatus =
                SamrSetSecurityObject(
                    (SAMPR_HANDLE)RpcContextHandle,
                    SecurityInformation,
                    &DescriptorToPass
                    );



        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

        } RpcEndExcept;
    }

    MIDL_user_free( DescriptorToPass.SecurityDescriptor );

    return(SampMapCompletionStatus(NtStatus));
}



NTSTATUS
SamQuerySecurityObject(
    IN SAM_HANDLE ObjectHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR * SecurityDescriptor
    )
/*++

Routine Description:


    This function (SamQuerySecurityObject) returns to the caller requested
    security information currently assigned to an object.

    Based on the caller's access rights this procedure
    will return a security descriptor containing any or all of the
    object's owner ID, group ID, discretionary ACL or system ACL.  To
    read the owner ID, group ID, or the discretionary ACL the caller
    must be granted READ_CONTROL access to the object.  To read the
    system ACL the caller must be granted ACCESS_SYSTEM_SECURITY
    access.

    This API is modelled after the NtQuerySecurityObject() system
    service.


Parameters:

    ObjectHandle - A handle to an existing object.

    SecurityInformation - Supplies a value describing which pieces of
        security information are being queried.

    SecurityDescriptor - Receives a pointer to the buffer containing
        the requested security information.  This information is
        returned in the form of a self-relative security descriptor.
        The caller is responsible for freeing the returned buffer
        (using SamFreeMemory()) when the security descriptor
        is no longer needed.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_ACCESS_DENIED - The specified handle was not opened for
        either READ_CONTROL or ACCESS_SYSTEM_SECURITY
        access.

    STATUS_INVALID_HANDLE - The specified handle is not that of an
        opened SAM object.



--*/
{
    NTSTATUS                        NtStatus;
    SAMPR_SR_SECURITY_DESCRIPTOR    ReturnedSD;
    PSAMPR_SR_SECURITY_DESCRIPTOR   PReturnedSD;

    SAMPR_HANDLE                    RpcContextHandle;

    SampOutputDebugString("SamQuerySecurityObject");

    //
    // The retrieved security descriptor is returned via a data structure that
    // looks like:
    //
    //             +-----------------------+
    //             | Length (bytes)        |
    //             |-----------------------|          +--------------+
    //             | SecurityDescriptor ---|--------->| Self-Relative|
    //             +-----------------------+          | Security     |
    //                                                | Descriptor   |
    //                                                +--------------+
    //
    // The first of these buffers is a local stack variable.  The buffer containing
    // the self-relative security descriptor is allocated by the RPC runtime.  The
    // pointer to the self-relative security descriptor is what is passed back to our
    // caller.
    //
    //

    if (!SampIsValidClientHandle(ObjectHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // To prevent RPC from trying to marshal a self-relative security descriptor,
    // make sure its field values are appropriately initialized to zero and null.
    //

    ReturnedSD.Length = 0;
    ReturnedSD.SecurityDescriptor = NULL;



    //
    // Call the server ...
    //


    RpcTryExcept{

        PReturnedSD = &ReturnedSD;
        NtStatus =
            SamrQuerySecurityObject(
                (SAMPR_HANDLE)RpcContextHandle,
                SecurityInformation,
                &PReturnedSD
                );



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    (*SecurityDescriptor) = ReturnedSD.SecurityDescriptor;
    return(SampMapCompletionStatus(NtStatus));
}



NTSTATUS
SamCloseHandle(
    OUT SAM_HANDLE SamHandle
    )

/*++
Routine Description:

    This API closes a currently opened SAM object.

Arguments:

    SamHandle - Specifies the handle of a previously opened SAM object to
        close.


Return Value:


    STATUS_SUCCESS - The object was successfully closed.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        TmpHandle;

    SampOutputDebugString("SamCloseHandle");

    if (!SampIsValidClientHandle(SamHandle, &TmpHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus = SamrCloseHandle(
                       (SAMPR_HANDLE *)(&TmpHandle)
                       );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        ULONG Code = RpcExceptionCode();
// Don't assert when clients pass in bad handles; also this can happen legally
// in stress scenarios
//        ASSERT(Code != RPC_X_SS_CONTEXT_MISMATCH);
        ASSERT(Code != RPC_S_INVALID_BINDING);
        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    if ( !NT_SUCCESS(NtStatus)
      && (0 != TmpHandle)  ) {
        //
        // Make sure in all error cases to remove the client side resources
        // consumed by this handle.
        //
        RpcTryExcept  {
            (void) RpcSsDestroyClientContext(&TmpHandle);
        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
            //
            // The try/except is for app compat so that bad handles don't bring
            // the process down
            //
            NOTHING;
        } RpcEndExcept;
    }

    SampFreeHandle((SAMP_HANDLE*)&SamHandle);

    return(SampMapCompletionStatus(NtStatus));
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Server object related services                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SamConnect(
    IN PUNICODE_STRING ServerName,
    OUT PSAM_HANDLE ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++
Routine Description:

    Establish a session with a SAM subsystem and subsequently open the
    SamServer object of that subsystem.  The caller must have
    SAM_SERVER_CONNECT access to the SamServer object of the subsystem
    being connected to.

    The handle returned is for use in future calls.


Arguments:

    ServerName - Name of the server to use, or NULL if local.

    ServerHandle - A handle to be used in future requests.  This handle
        represents both the handle to the SamServer object and the RPC
        context handle for the connection to the SAM subsystem.

    DesiredAccess - Is an access mask indicating which access types are
        desired to the SamServer.  These access types are reconciled
        with the Discretionary Access Control list of the SamServer to
        determine whether the accesses will be granted or denied.  The
        access type of SAM_SERVER_CONNECT is always implicitly included
        in this access mask.

    ObjectAttributes - Pointer to the set of object attributes to use for
        this connection.  Only the security Quality Of Service
        information is used and should provide SecurityIdentification
        level of impersonation.

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Access was denied.


--*/
{
    NTSTATUS            NtStatus;

    PSAMPR_SERVER_NAME  RServerName;
    PSAMPR_SERVER_NAME  RServerNameWithNull;
    USHORT              RServerNameWithNullLength;
    TlsInfo             *pTlsInfo;
    SAMP_HANDLE         SampServerHandle = NULL;
    SAMPR_HANDLE        RpcContextHandle;

    SAMPR_REVISION_INFO_V1 SamServerInfo;

    RtlZeroMemory(&SamServerInfo, sizeof(SamServerInfo));

    SampOutputDebugString("SamConnect");

    if (IsBadWritePtr(ServerHandle, sizeof(SAM_HANDLE))) {
        return STATUS_INVALID_PARAMETER;
    }

    NtStatus = SampCreateNewHandle(NULL,
                                   NULL,
                                   &SampServerHandle);
    if ( !NT_SUCCESS(NtStatus) ) {
        return NtStatus;
    }

    //
    // Hmmm - what to do with security QOS???
    //

    //
    // Call the server, passing either a NULL Server Name pointer, or
    // a pointer to a Unicode Buffer with a Wide Character NULL terminator.
    // Since the input name is contained in a counted Unicode String, there
    // is no NULL terminator necessarily provided, so we must append one.
    //

    RServerNameWithNull = NULL;

    if (ARGUMENT_PRESENT(ServerName) &&
        (ServerName->Buffer != NULL) &&
            (ServerName->Length != 0)) {

        RServerName = (PSAMPR_SERVER_NAME)(ServerName->Buffer);
        RServerNameWithNullLength = ServerName->Length + (USHORT) sizeof(WCHAR);
        if (RServerNameWithNullLength < sizeof(WCHAR)) {
           return(STATUS_INVALID_PARAMETER_1);
        }
        RServerNameWithNull = MIDL_user_allocate( RServerNameWithNullLength );

        if (RServerNameWithNull == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlCopyMemory( RServerNameWithNull, RServerName, ServerName->Length);
        RServerNameWithNull[ServerName->Length/sizeof(WCHAR)] = L'\0';
    }

    RpcTryExcept {

        SAMPR_REVISION_INFO InInfo;
        SAMPR_REVISION_INFO OutInfo;
        ULONG               OutInfoVersion;

        RtlZeroMemory(&InInfo, sizeof(InInfo));
        RtlZeroMemory(&OutInfo, sizeof(OutInfo));

        InInfo.V1.Revision = SAM_NETWORK_REVISION_LATEST;

        NtStatus = SamrConnect5(
                       RServerNameWithNull,
                       DesiredAccess,
                       1, // in info version
                       &InInfo,
                       &OutInfoVersion,
                       &OutInfo,
                       &RpcContextHandle);

        if (NT_SUCCESS(NtStatus)) {

            ASSERT(OutInfoVersion == 1);
            ASSERT(sizeof(SamServerInfo) == sizeof(OutInfo.V1));

            RtlCopyMemory(&SamServerInfo, &OutInfo.V1, sizeof(SamServerInfo));

        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    if ((NtStatus == RPC_NT_UNKNOWN_IF) ||
        (NtStatus == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        RpcTryExcept {
    
            NtStatus = SamrConnect4(
                           RServerNameWithNull,
                           (SAMPR_HANDLE *)&RpcContextHandle,
                           SAM_CLIENT_NT5,
                           DesiredAccess
                           );
    
        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
    
            NtStatus = I_RpcMapWin32Status(RpcExceptionCode());
    
        } RpcEndExcept;
    }

    if (    NT_SUCCESS(NtStatus)
         && (pTlsInfo = (TlsInfo *) TlsGetValue(gTlsIndex)) )
    {
        pTlsInfo->fDstIsW2K = TRUE;
    }

    //
    // If the new connect  call failed because it didn't exist,
    // try the old one.
    //

    if ((NtStatus == RPC_NT_UNKNOWN_IF) ||
        (NtStatus == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        RpcTryExcept {

            NtStatus = SamrConnect2(
                           RServerNameWithNull,
                           (SAMPR_HANDLE *)&RpcContextHandle,
                           DesiredAccess
                           );

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

        } RpcEndExcept;
    }

    if ((NtStatus == RPC_NT_UNKNOWN_IF) ||
        (NtStatus == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        RpcTryExcept {

            NtStatus = SamrConnect(
                           RServerNameWithNull,
                           (SAMPR_HANDLE *)&RpcContextHandle,
                           DesiredAccess
                           );

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

        } RpcEndExcept;
    }

    if (RServerNameWithNull != NULL) {
        MIDL_user_free( RServerNameWithNull );
    }

    //
    // Store the RPC context handle
    //
    if (NT_SUCCESS(NtStatus)) {
        SampServerHandle->ContextHandle = RpcContextHandle;
        SampServerHandle->ServerInfo = SamServerInfo;
    } else {
        SampFreeHandle(&SampServerHandle);
    }
    *ServerHandle = (SAM_HANDLE) SampServerHandle;

#if DBG
    if (!NT_SUCCESS(NtStatus))
    {
        DbgPrint("SAM: SamConnect() failed. NtStatus %x\n", NtStatus);
    }
#endif // DBG

    return(SampMapCompletionStatus(NtStatus));

    DBG_UNREFERENCED_PARAMETER(ObjectAttributes);

}


NTSTATUS
SamShutdownSamServer(
    IN SAM_HANDLE ServerHandle
    )

/*++
Routine Description:

    This is the wrapper routine for SamShutdownSamServer().

Arguments:

    ServerHandle - Handle from a previous SamConnect() call.

Return Value:


    STATUS_SUCCESS The service completed successfully or the server
        has already shutdown.


    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.

--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;


    if (!SampIsValidClientHandle(ServerHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //


    RpcTryExcept{

        NtStatus = SamrShutdownSamServer(RpcContextHandle);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());


        //
        // If the error status is one that would result from a server
        // not being there, then replace it with success.
        //

        if (NtStatus == RPC_NT_CALL_FAILED) {
            NtStatus = STATUS_SUCCESS;
        }

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));
}


NTSTATUS
SamLookupDomainInSamServer(
    IN SAM_HANDLE ServerHandle,
    IN PUNICODE_STRING Name,
    OUT PSID *DomainId
    )

/*++

Routine Description:

    This service returns the SID corresponding to the specified domain.
    The domain is specified by name.


Arguments:

    ServerHandle - Handle from a previous SamConnect() call.

    Name - The name of the domain whose ID is to be looked up.  A
        case-insensitive comparison of this name will be performed for
        the lookup operation.

    DomainId - Receives a pointer to a buffer containing the SID of the
        looked up domain.  This buffer must be freed using
        SamFreeMemory() when no longer needed.


Return Value:


    STATUS_SUCCESS - The service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.  SAM_SERVER_LOOKUP_DOMAIN access is
        needed.

    STATUS_NO_SUCH_DOMAIN - The specified domain does not exist at this
        server.

    STATUS_INVALID_SERVER_STATE - Indicates the SAM server is currently
        disabled.

--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamLookupDomainInSamServer");

    if (!SampIsValidClientHandle(ServerHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //


    RpcTryExcept{

        (*DomainId) = 0;

        NtStatus =
            SamrLookupDomainInSamServer(
                (SAMPR_HANDLE)RpcContextHandle,
                (PRPC_UNICODE_STRING)Name,
                (PRPC_SID *)DomainId
                );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));
}


NTSTATUS
SamEnumerateDomainsInSamServer(
    IN SAM_HANDLE ServerHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PVOID * Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
)

/*++

Routine Description:

    This API lists all the domains defined in the account database.
    Since there may be more domains than can fit into a buffer, the
    caller is provided with a handle that can be used across calls to
    the API.  On the initial call, EnumerationContext should point to a
    SAM_ENUMERATE_HANDLE variable that is set to 0.

    If the API returns STATUS_MORE_ENTRIES, then the API should be
    called again with EnumerationContext.  When the API returns
    STATUS_SUCCESS or any error return, the handle becomes invalid for
    future use.

    This API requires SAM_SERVER_ENUMERATE_DOMAINS access to the
    SamServer object.


Parameters:

    ServerHandle - Handle obtained from a previous SamConnect call.

    EnumerationContext - API specific handle to allow multiple calls
        (see routine description).  This is a zero based index.

    Buffer - Receives a pointer to the buffer where the information
        is placed.  The information returned is contiguous
        SAM_RID_ENUMERATION data structures.  However, the
        RelativeId field of each of these structures is not valid.
        This buffer must be freed when no longer needed using
        SamFreeMemory().

    PreferedMaximumLength - Prefered maximum length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves
        as a guide to the server.  Due to data conversion between
        systems with different natural data sizes, the actual amount
        of data returned may be greater than this value.

    CountReturned - Number of entries returned.

Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.

    STATUS_MORE_ENTRIES - There are more entries, so call again.
        This is a successful return.

    STATUS_ACCESS_DENIED - Caller does not have the access required
        to enumerate the domains.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_SERVER_STATE - Indicates the SAM server is
        currently disabled.

--*/
{

    NTSTATUS            NtStatus;
    PSAMPR_ENUMERATION_BUFFER LocalBuffer;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamEnumerateDomainsInSamServer");

    //
    // Make sure we aren't trying to have RPC allocate the EnumerationContext.
    //

    if ( !ARGUMENT_PRESENT(EnumerationContext) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(Buffer) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(CountReturned) ) {
        return(STATUS_INVALID_PARAMETER);
    }

    if (!SampIsValidClientHandle(ServerHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }


    //
    // Call the server ...
    //

    (*Buffer) = NULL;
     LocalBuffer = NULL;

    RpcTryExcept{

        NtStatus = SamrEnumerateDomainsInSamServer(
                       (SAMPR_HANDLE)RpcContextHandle,
                       EnumerationContext,
                       (PSAMPR_ENUMERATION_BUFFER *)&LocalBuffer,
                       PreferedMaximumLength,
                       CountReturned
                       );

        if (LocalBuffer != NULL) {

            //
            // What comes back is a three level structure:
            //
            //  Local       +-------------+
            //  Buffer ---> | EntriesRead |
            //              |-------------|    +-------+
            //              | Enumeration |--->| Name0 | --- > (NameBuffer0)
            //              | Return      |    |-------|            o
            //              | Buffer      |    |  ...  |            o
            //              +-------------+    |-------|            o
            //                                 | NameN | --- > (NameBufferN)
            //                                 +-------+
            //
            //   The buffer containing the EntriesRead field is not returned
            //   to our caller.  Only the buffers containing name information
            //   are returned.
            //

            if (LocalBuffer->Buffer != NULL) {
                (*Buffer) = LocalBuffer->Buffer;
            }

            MIDL_user_free( LocalBuffer);


        }


    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Domain object related services                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
SamOpenDomain(
    IN SAM_HANDLE ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN PSID DomainId,
    OUT PSAM_HANDLE DomainHandle
    )

/*++
Routine Description:

    This API opens a domain object.  It returns a handle to the newly
    opened domain that must be used for successive operations on the
    domain.  This handle may be closed with the SamCloseHandle API.


Arguments:

    ServerHandle - Handle from a previous SamConnect() call.

    DesiredAccess - Is an access mask indicating which access types are
        desired to the domain.  These access types are reconciled with
        the Discretionary Access Control list of the domain to determine
        whether the accesses will be granted or denied.

    DomainId - The SID assigned to the domain to open.

    DomainHandle - Receives a handle referencing the newly opened domain.
        This handle will be required in successive calls to operate on
        the domain.

Return Value:


    STATUS_SUCCESS - The domain was successfully opened.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.

    STATUS_INVALID_SERVER_STATE - Indicates the SAM server is currently
        disabled.

--*/
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
    SAMPR_HANDLE        DomainRpcContextHandle, ServerRpcContextHandle;
    SAMP_HANDLE         SampDomainHandle;

    SampOutputDebugString("SamOpenDomain");

    //
    // Parameter check
    //
    if (IsBadWritePtr(DomainHandle, sizeof(SAM_HANDLE))) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!SampIsValidClientHandle(ServerHandle, &ServerRpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    _try {
        if (!RtlValidSid(DomainId)) {
            NtStatus = STATUS_INVALID_PARAMETER;
        }
    } _except( EXCEPTION_EXECUTE_HANDLER ) {
        NtStatus = STATUS_INVALID_PARAMETER;
    }
    if ( !NT_SUCCESS(NtStatus) ) {
        return NtStatus;
    }

    //
    // Prepare the returned handle
    //
    NtStatus = SampCreateNewHandle((SAMP_HANDLE)ServerHandle,
                                   DomainId,
                                   &SampDomainHandle);
    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }

    //
    // Call the server ...
    //


    RpcTryExcept{

        (*DomainHandle) = 0;

        NtStatus =
            SamrOpenDomain(
                (SAMPR_HANDLE)ServerRpcContextHandle,
                DesiredAccess,
                (PRPC_SID)DomainId,
                (SAMPR_HANDLE *)&DomainRpcContextHandle
                );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    if (NT_SUCCESS(NtStatus)) {
        SampDomainHandle->ContextHandle = DomainRpcContextHandle;
    } else {
        SampFreeHandle(&SampDomainHandle);
    }
    *DomainHandle = SampDomainHandle;

    return(SampMapCompletionStatus(NtStatus));
}


NTSTATUS
SamQueryInformationDomain(
    IN SAM_HANDLE DomainHandle,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass,
    OUT PVOID *Buffer
    )

/*++
Routine Description:

    This API retrieves the domain information.  This API requires either
    DOMAIN_READ_PASSWORD_PARAMETERS or DOMAIN_READ_OTHER_PARAMETERS.


Arguments:

    DomainHandle - Handle from a previous SamOpenDomain() call.

    DomainInformationClass - Class of information desired.  The accesses
        required for each class is shown below:

            Info Level                      Required Access Type
            ---------------------------     -------------------------------
            DomainGeneralInformation        DOMAIN_READ_OTHER_PARAMETERS
            DomainPasswordInformation       DOMAIN_READ_PASSWORD_PARAMS
            DomainLogoffInformation         DOMAIN_READ_OTHER_PARAMETERS
            DomainOemInformation            DOMAIN_READ_OTHER_PARAMETERS
            DomainNameInformation           DOMAIN_READ_OTHER_PARAMETERS
            DomainServerRoleInformation     DOMAIN_READ_OTHER_PARAMETERS
            DomainReplicationInformation    DOMAIN_READ_OTHER_PARAMETERS
            DomainModifiedInformation       DOMAIN_READ_OTHER_PARAMETERS
            DomainStateInformation          DOMAIN_READ_OTHER_PARAMETERS
            DomainUasInformation            DOMAIN_READ_OTHER_PARAMETERS
       Added for NT1.0A...
            DomainGeneralInformation2       DOMAIN_READ_OTHER_PARAMETERS
            DomainLockoutInformation        DOMAIN_READ_OTHER_PARAMETERS


    Buffer - Receives a pointer to a buffer containing the requested
        information.  When this information is no longer needed, this buffer
        must be freed using SamFreeMemory().

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamQueryInformationDomain");

    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //


    (*Buffer) = NULL;

    RpcTryExcept{

        if (DomainInformationClass <= DomainUasInformation) {
            NtStatus = SamrQueryInformationDomain(
                           (SAMPR_HANDLE)RpcContextHandle,
                           DomainInformationClass,
                           (PSAMPR_DOMAIN_INFO_BUFFER *)Buffer
                           );
        } else {
            NtStatus = SamrQueryInformationDomain2(
                           (SAMPR_HANDLE)RpcContextHandle,
                           DomainInformationClass,
                           (PSAMPR_DOMAIN_INFO_BUFFER *)Buffer
                           );

        }



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        //
        // If the exception indicates the server doesn't have
        // the selected api, that means the server doesn't know
        // about the info level we passed.  Set our completion
        // status appropriately.
        //

        if (RpcExceptionCode() == RPC_S_INVALID_LEVEL         ||
            RpcExceptionCode() == RPC_S_PROCNUM_OUT_OF_RANGE  ||
            RpcExceptionCode() == RPC_NT_PROCNUM_OUT_OF_RANGE ) {
            NtStatus = STATUS_INVALID_INFO_CLASS;
        } else {
            NtStatus = I_RpcMapWin32Status(RpcExceptionCode());
        }

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));
}


NTSTATUS
SamSetInformationDomain(
    IN SAM_HANDLE DomainHandle,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass,
    IN PVOID DomainInformation
)

/*++

Routine Description:

    This API sets the domain information to the values passed in the
    buffer.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    DomainInformationClass - Class of information desired.  The
        accesses required for each class is shown below:

        Info Level                      Required Access Type
        -------------------------       ----------------------------

        DomainPasswordInformation       DOMAIN_WRITE_PASSWORD_PARAMS

        DomainLogoffInformation         DOMAIN_WRITE_OTHER_PARAMETERS

        DomainOemInformation            DOMAIN_WRITE_OTHER_PARAMETERS

        DomainNameInformation           (not valid for set operations.)

        DomainServerRoleInformation     DOMAIN_ADMINISTER_SERVER

        DomainReplicationInformation    DOMAIN_ADMINISTER_SERVER

        DomainModifiedInformation       (not valid for set operations.)

        DomainStateInformation          DOMAIN_ADMINISTER_SERVER

        DomainUasInformation            DOMAIN_WRITE_OTHER_PARAMETERS

    DomainInformation - Buffer where the domain information can be
        found.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be disabled before role
        changes can be made.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

--*/
{

    NTSTATUS            NtStatus;

    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamSetInformationDomain");


    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //


    RpcTryExcept{

        NtStatus =
            SamrSetInformationDomain(
                (SAMPR_HANDLE)RpcContextHandle,
                DomainInformationClass,
                (PSAMPR_DOMAIN_INFO_BUFFER)DomainInformation
                );



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamCreateGroupInDomain(
    IN SAM_HANDLE DomainHandle,
    IN PUNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    OUT PSAM_HANDLE GroupHandle,
    OUT PULONG RelativeId
    )
/*++

Routine Description:

    This API creates a new group in the account database.  Initially,
    this group does not contain any users.  Note that creating a group
    is a protected operation, and requires the DOMAIN_CREATE_GROUP
    access type.

    This call returns a handle to the newly created group that may be
    used for successive operations on the group.  This handle may be
    closed with the SamCloseHandle API.

    A newly created group will have the following initial field value
    settings.  If another value is desired, it must be explicitly
    changed using the group object manipulation services.

        Name - The name of the group will be as specified in the
               creation API.

        Attributes - The following attributes will be set:

                                Mandatory
                                EnabledByDefault

        MemberCount - Zero.  Initially the group has no members.

        RelativeId - will be a uniquelly allocated ID.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    AccountName - Points to the name of the new account.  A
        case-insensitive comparison must not find a group, alias or user
        with this name already defined.

    DesiredAccess - Is an access mask indicating which access types
        are desired to the group.

    GroupHandle - Receives a handle referencing the newly created
        group.  This handle will be required in successive calls to
        operate on the group.

    RelativeId - Receives the relative ID of the newly created group
        account.  The SID of the new group account is this relative
        ID value prefixed with the domain's SID value.

Return Values:

    STATUS_SUCCESS - The group was added successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_ACCOUNT_NAME - The name was poorly formed, e.g.
        contains non-printable characters.

    STATUS_GROUP_EXISTS - The name is already in use as a group.

    STATUS_USER_EXISTS - The name is already in use as a user.

    STATUS_ALIAS_EXISTS - The name is already in use as an alias.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled before groups
        can be created in it.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.  The domain server must be a primary server to
        create group accounts.


--*/
{

    NTSTATUS            NtStatus;
    SAMPR_HANDLE        DomainRpcContextHandle, GroupRpcContextHandle;
    SAMP_HANDLE         SampGroupHandle;

    SampOutputDebugString("SamCreateGroupInDomain");


    if (IsBadWritePtr(GroupHandle, sizeof(SAM_HANDLE))) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!SampIsValidClientHandle(DomainHandle, &DomainRpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Prepare the new handle to return
    //
    NtStatus = SampCreateNewHandle((SAMP_HANDLE)DomainHandle,
                                   NULL,
                                   &SampGroupHandle);
    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }

    //
    // Call the server ...
    //


    (*GroupHandle) = NULL;
    (*RelativeId)  = 0;

    RpcTryExcept{

        NtStatus =
            SamrCreateGroupInDomain(
                (SAMPR_HANDLE)DomainRpcContextHandle,
                (PRPC_UNICODE_STRING)AccountName,
                DesiredAccess,
                (SAMPR_HANDLE *)&GroupRpcContextHandle,
                RelativeId
                );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    if (NT_SUCCESS(NtStatus)) {
        SampGroupHandle->ContextHandle = GroupRpcContextHandle;
    } else {
        SampFreeHandle(&SampGroupHandle);
    }
    *GroupHandle = SampGroupHandle;

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamEnumerateGroupsInDomain(
    IN SAM_HANDLE DomainHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    IN PVOID * Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
)

/*++

Routine Description:

    This API lists all the groups defined in the account database.
    Since there may be more groups than can fit into a buffer, the
    caller is provided with a handle that can be used across calls to
    the API.  On the initial call, EnumerationContext should point to a
    SAM_ENUMERATE_HANDLE variable that is set to 0.

    If the API returns STATUS_MORE_ENTRIES, then the API should be
    called again with EnumerationContext.  When the API returns
    STATUS_SUCCESS or any error return, the handle becomes invalid for
    future use.

    This API requires DOMAIN_LIST_ACCOUNTS access to the Domain object.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    EnumerationContext - API specific handle to allow multiple calls
        (see routine description).  This is a zero based index.

    Buffer - Receives a pointer to the buffer containing the
        requested information.  The information returned is
        structured as an array of SAM_RID_ENUMERATION data
        structures.  When this information is no longer needed, the
        buffer must be freed using SamFreeMemory().

    PreferedMaximumLength - Prefered maximum length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves
        as a guide to the server.  Due to data conversion between
        systems with different natural data sizes, the actual amount
        of data returned may be greater than this value.

    CountReturned - Number of entries returned.

Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.

    STATUS_MORE_ENTRIES - There are more entries, so call again.
        This is a successful return.

    STATUS_ACCESS_DENIED - Caller does not have privilege required to
        request that data.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

--*/
{

    NTSTATUS            NtStatus;
    PSAMPR_ENUMERATION_BUFFER LocalBuffer;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamEnumerateGroupsInDomain");



    //
    // Make sure we aren't trying to have RPC allocate the EnumerationContext.
    //

    if ( !ARGUMENT_PRESENT(EnumerationContext) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(Buffer) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(CountReturned) ) {
        return(STATUS_INVALID_PARAMETER);
    }

    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    (*Buffer) = NULL;
     LocalBuffer = NULL;


    RpcTryExcept{

        NtStatus = SamrEnumerateGroupsInDomain(
                       (SAMPR_HANDLE)RpcContextHandle,
                       EnumerationContext,
                       (PSAMPR_ENUMERATION_BUFFER *)&LocalBuffer,
                       PreferedMaximumLength,
                       CountReturned
                       );


        if (LocalBuffer != NULL) {

            //
            // What comes back is a three level structure:
            //
            //  Local       +-------------+
            //  Buffer ---> | EntriesRead |
            //              |-------------|    +-------+
            //              | Enumeration |--->| Name0 | --- > (NameBuffer0)
            //              | Return      |    |-------|            o
            //              | Buffer      |    |  ...  |            o
            //              +-------------+    |-------|            o
            //                                 | NameN | --- > (NameBufferN)
            //                                 +-------+
            //
            //   The buffer containing the EntriesRead field is not returned
            //   to our caller.  Only the buffers containing name information
            //   are returned.
            //

            if (LocalBuffer->Buffer != NULL) {
                (*Buffer) = LocalBuffer->Buffer;
            }

            MIDL_user_free( LocalBuffer);


        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}


NTSTATUS
SamCreateUser2InDomain(
    IN SAM_HANDLE DomainHandle,
    IN PUNICODE_STRING AccountName,
    IN ULONG AccountType,
    IN ACCESS_MASK DesiredAccess,
    OUT PSAM_HANDLE UserHandle,
    OUT PULONG GrantedAccess,
    OUT PULONG RelativeId
)

/*++

Routine Description:

    This API adds a new user to the account database.  The account is
    created in a disabled state.  Default information is assigned to all
    fields except the account name.  A password must be provided before
    the account may be enabled, unless the PasswordNotRequired control
    field is set.

    This api may be used in either of two ways:

        1) An administrative utility may use this api to create
           any type of user account.  In this case, the DomainHandle
           is expected to be open for DOMAIN_CREATE_USER access.

        2) A non-administrative user may use this api to create
           a machine account.  In this case, the caller is expected
           to have the SE_CREATE_MACHINE_ACCOUNT_PRIV privilege
           and the DomainHandle is expected to be open for DOMAIN_LOOKUP
           access.


    For the normal administrative model ( #1 above), the creator will
    be assigned as the owner of the created user account.  Furthermore,
    the new account will be give USER_WRITE access to itself.

    For the special machine-account creation model (#2 above), the
    "Administrators" will be assigned as the owner of the account.
    Furthermore, the new account will be given NO access to itself.
    Instead, the creator of the account will be give USER_WRITE and
    DELETE access to the account.


    This call returns a handle to the newly created user that may be
    used for successive operations on the user.  This handle may be
    closed with the SamCloseHandle() API.  If a machine account is
    being created using model #2 above, then this handle will have
    only USER_WRITE and DELETE access.  Otherwise, it will be open
    for USER_ALL_ACCESS.


    A newly created user will automatically be made a member of the
    DOMAIN_USERS group.

    A newly created user will have the following initial field value
    settings.  If another value is desired, it must be explicitly
    changed using the user object manipulation services.

        UserName - the name of the account will be as specified in the
             creation API.

        FullName - will be null.

        UserComment - will be null.

        Parameters - will be null.

        CountryCode - will be zero.

        UserId - will be a uniquelly allocated ID.

        PrimaryGroupId - Will be DOMAIN_USERS.

        PasswordLastSet - will be the time the account was created.

        HomeDirectory - will be null.

        HomeDirectoryDrive - will be null.

        UserAccountControl - will have the following flags set:

              UserAccountDisable,
              UserPasswordNotRequired,
              and the passed account type.


        ScriptPath - will be null.

        WorkStations - will be null.

        CaseInsensitiveDbcs - will be null.

        CaseSensitiveUnicode - will be null.

        LastLogon - will be zero delta time.

        LastLogoff - will be zero delta time

        AccountExpires - will be very far into the future.

        BadPasswordCount - will be negative 1 (-1).

        LastBadPasswordTime - will be SampHasNeverTime ( [High,Low] = [0,0] ).

        LogonCount - will be negative 1 (-1).

        AdminCount - will be zero.

        AdminComment - will be null.

        Password - will be "".


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    AccountName - Points to the name of the new account.  A case-insensitive
        comparison must not find a group or user with this name already defined.

    AccountType - Indicates what type of account is being created.
        Exactly one account type must be provided:

              USER_INTERDOMAIN_TRUST_ACCOUNT
              USER_WORKSTATION_TRUST_ACCOUNT
              USER_SERVER_TRUST_ACCOUNT
              USER_TEMP_DUPLICATE_ACCOUNT
              USER_NORMAL_ACCOUNT
              USER_MACHINE_ACCOUNT_MASK


    DesiredAccess - Is an access mask indicating which access types
        are desired to the user.

    UserHandle - Receives a handle referencing the newly created
        user.  This handle will be required in successive calls to
        operate on the user.

    GrantedAccess - Receives the accesses actually granted to via
        the UserHandle.  When creating an account on a down-level
        server, this value may be unattainable.  In this case, it
        will be returned as zero (0).

    RelativeId - Receives the relative ID of the newly created user
        account.  The SID of the new user account is this relative ID
        value prefixed with the domain's SID value.


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_GROUP_EXISTS - The name is already in use as a group.

    STATUS_USER_EXISTS - The name is already in use as a user.

    STATUS_ALIAS_EXISTS - The name is already in use as an alias.

    STATUS_INVALID_ACCOUNT_NAME - The name was poorly formed, e.g.
        contains non-printable characters.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled before users
        can be created in it.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.  The domain server must be a primary server to
        create user accounts.


--*/
{
    NTSTATUS
        NtStatus,
        IgnoreStatus;


    USER_CONTROL_INFORMATION
        UserControlInfoBuffer;

    SAMP_HANDLE         
        SampUserHandle;

    SAMPR_HANDLE
        DomainRpcContextHandle,
        UserRpcContextHandle;
        

    SampOutputDebugString("SamCreateUser2InDomain");


    if (IsBadWritePtr(UserHandle, sizeof(SAM_HANDLE))) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!SampIsValidClientHandle(DomainHandle, &DomainRpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }
   
    //
    // Prepare the new handle to return
    //
    NtStatus = SampCreateNewHandle((SAMP_HANDLE)DomainHandle,
                                   NULL,
                                   &SampUserHandle);
    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }

    //
    // Call the server ...
    //


    (*UserHandle) = NULL;
    (*RelativeId)  = 0;

    RpcTryExcept{

        NtStatus =
            SamrCreateUser2InDomain(
                (SAMPR_HANDLE)DomainRpcContextHandle,
                (PRPC_UNICODE_STRING)AccountName,
                AccountType,
                DesiredAccess,
                (SAMPR_HANDLE *)&UserRpcContextHandle,
                GrantedAccess,
                RelativeId
                );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        if (RpcExceptionCode() == RPC_S_PROCNUM_OUT_OF_RANGE  ||
            RpcExceptionCode() == RPC_NT_PROCNUM_OUT_OF_RANGE ) {
            NtStatus = RPC_NT_PROCNUM_OUT_OF_RANGE;
        } else {
            NtStatus = I_RpcMapWin32Status(RpcExceptionCode());
        }

    } RpcEndExcept;



    //
    // If the server doesn't support the new api, then
    // do the equivalent work with the old apis.
    //

    if (NtStatus == RPC_NT_PROCNUM_OUT_OF_RANGE) {

        DesiredAccess = DesiredAccess | USER_WRITE_ACCOUNT;
        NtStatus =
            SamCreateUserInDomain(
                                   DomainRpcContextHandle,
                                   AccountName,
                                   DesiredAccess,
                                   &UserRpcContextHandle,
                                   RelativeId );

        if (NT_SUCCESS(NtStatus)) {


            SampUserHandle->ContextHandle = UserRpcContextHandle;

            //
            // Set the AccountType (unless it is normal)
            //

            if (~(AccountType & USER_NORMAL_ACCOUNT)) {

                UserControlInfoBuffer.UserAccountControl =
                        AccountType             |
                        USER_ACCOUNT_DISABLED   |
                        USER_PASSWORD_NOT_REQUIRED;

                NtStatus = SamSetInformationUser(
                               (SAM_HANDLE)SampUserHandle,
                               UserControlInformation,
                               &UserControlInfoBuffer
                               );
                if (!NT_SUCCESS(NtStatus)) {
                    IgnoreStatus = SamDeleteUser( (SAM_HANDLE)SampUserHandle );
                    if (NT_SUCCESS(IgnoreStatus)) {
                        SampUserHandle = NULL;
                    }
                }

                //
                // We can't be positive what accesses have been
                // granted, so don't try lying.
                //

                (*GrantedAccess) = 0;

            }
        }
    }

    if (NT_SUCCESS(NtStatus)) {
        SampUserHandle->ContextHandle = UserRpcContextHandle;
    } else {
        if (SampUserHandle) {
            SampFreeHandle(&SampUserHandle);
        }
    }
    *UserHandle = (SAM_HANDLE) SampUserHandle;

#if DBG
    if (!NT_SUCCESS(NtStatus))
    {
        DbgPrint("SAM: SamCreateUser2InDomain() failed. NtStatus 0x%x\n", NtStatus);
    }
#endif // DBG

    return(SampMapCompletionStatus(NtStatus));
}


NTSTATUS
SamCreateUserInDomain(
    IN SAM_HANDLE DomainHandle,
    IN PUNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    OUT PSAM_HANDLE UserHandle,
    OUT PULONG RelativeId
)

/*++

Routine Description:

    This API adds a new user to the account database.  The account is
    created in a disabled state.  Default information is assigned to all
    fields except the account name.  A password must be provided before
    the account may be enabled, unless the PasswordNotRequired control
    field is set.

    Note that DOMAIN_CREATE_USER access type is needed by this API.
    Also, the caller of this API becomes the owner of the user object
    upon creation.

    This call returns a handle to the newly created user that may be
    used for successive operations on the user.  This handle may be
    closed with the SamCloseHandle() API.

    A newly created user will automatically be made a member of the
    DOMAIN_USERS group.

    A newly created user will have the following initial field value
    settings.  If another value is desired, it must be explicitly
    changed using the user object manipulation services.

        UserName - the name of the account will be as specified in the
             creation API.

        FullName - will be null.

        UserComment - will be null.

        Parameters - will be null.

        CountryCode - will be zero.

        UserId - will be a uniquelly allocated ID.

        PrimaryGroupId - Will be DOMAIN_USERS.

        PasswordLastSet - will be the time the account was created.

        HomeDirectory - will be null.

        HomeDirectoryDrive - will be null.

        UserAccountControl - will have the following flags set:

              USER_ACCOUNT_DISABLED,
              USER_NORMAL_ACCOUNT,
              USER_PASSWORD_NOT_REQUIRED

        ScriptPath - will be null.

        WorkStations - will be null.

        CaseInsensitiveDbcs - will be null.

        CaseSensitiveUnicode - will be null.

        LastLogon - will be zero.

        LastLogoff - will be zero.

        AccountExpires - will be very far into the future.

        BadPasswordCount - will be negative 1 (-1).

        LogonCount - will be negative 1 (-1).

        AdminComment - will be null.

        Password - will contain any value, but is not used because the
             USER_PASSWORD_NOT_REQUIRED control flag is set.  If a password
             is to be required, then this field must be set to a
             specific value and the USER_PASSWORD_NOT_REQUIRED flag must be
             cleared.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    AccountName - The name to be assigned to the new account.

    DesiredAccess - Is an access mask indicating which access types
        are desired to the user.

    UserHandle - Receives a handle referencing the newly created
        user.  This handle will be required in successive calls to
        operate on the user.

    RelativeId - Receives the relative ID of the newly created user
        account.  The SID of the new user account is this relative ID
        value prefixed with the domain's SID value.


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_GROUP_EXISTS - The name is already in use as a group.

    STATUS_USER_EXISTS - The name is already in use as a user.

    STATUS_ALIAS_EXISTS - The name is already in use as an alias.

    STATUS_INVALID_ACCOUNT_NAME - The name was poorly formed, e.g.
        contains non-printable characters.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled before users
        can be created in it.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.  The domain server must be a primary server to
        create user accounts.


--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        DomainRpcContextHandle, UserRpcContextHandle;
    SAMP_HANDLE         SampUserHandle;


    SampOutputDebugString("SamCreateUserInDomain");

    if (IsBadWritePtr(UserHandle, sizeof(SAM_HANDLE))) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!SampIsValidClientHandle(DomainHandle, &DomainRpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Prepare the new handle to return
    //
    NtStatus = SampCreateNewHandle((SAMP_HANDLE)DomainHandle,
                                   NULL,
                                   &SampUserHandle);
    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }

    //
    // Call the server ...
    //


    UserRpcContextHandle = NULL;
    (*RelativeId)  = 0;

    RpcTryExcept{

        NtStatus =
            SamrCreateUserInDomain(
                (SAMPR_HANDLE)DomainRpcContextHandle,
                (PRPC_UNICODE_STRING)AccountName,
                DesiredAccess,
                (SAMPR_HANDLE *)&UserRpcContextHandle,
                RelativeId
                );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    if (NT_SUCCESS(NtStatus)) {
        SampUserHandle->ContextHandle = UserRpcContextHandle;
    } else {
        SampFreeHandle(&SampUserHandle);
    }
    *UserHandle = SampUserHandle;

#if DBG
    if (!NT_SUCCESS(NtStatus))
    {
        DbgPrint("SAM: SamCreateUserInDomain() failed. NtStatus 0x%x\n", NtStatus);
    }
#endif // DBG

    return(SampMapCompletionStatus(NtStatus));
}




NTSTATUS
SamEnumerateUsersInDomain(
    IN SAM_HANDLE DomainHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    IN ULONG UserAccountControl,
    OUT PVOID * Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
)

/*++

Routine Description:

    This API lists all the users defined in the account database.  Since
    there may be more users than can fit into a buffer, the caller is
    provided with a handle that can be used across calls to the API.  On
    the initial call, EnumerationContext should point to a
    SAM_ENUMERATE_HANDLE variable that is set to 0.

    If the API returns STATUS_MORE_ENTRIES, then the API should be
    called again with EnumerationContext.  When the API returns
    STATUS_SUCCESS or any error return, the handle becomes invalid for
    future use.

    This API requires DOMAIN_LIST_ACCOUNTS access to the Domain object.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    EnumerationContext - API specific handle to allow multiple calls
        (see routine description).  This is a zero based index.

    UserAccountControl - Provides enumeration filtering information.  Any
        characteristics specified here will cause that type of User account
        to be included in the enumeration process.

    Buffer - Receives a pointer to the buffer containing the
        requested information.  The information returned is
        structured as an array of SAM_RID_ENUMERATION data
        structures.  When this information is no longer needed, the
        buffer must be freed using SamFreeMemory().

    PreferedMaximumLength - Prefered maximum length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves
        as a guide to the server.  Due to data conversion between
        systems with different natural data sizes, the actual amount
        of data returned may be greater than this value.

    CountReturned - Number of entries returned.

Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.

    STATUS_MORE_ENTRIES - There are more entries, so call again.
        This is a successful return.

    STATUS_ACCESS_DENIED - Caller does not have privilege required to
        request that data.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

--*/
{

    NTSTATUS            NtStatus;
    PSAMPR_ENUMERATION_BUFFER LocalBuffer;

    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamEnumerateUsersInDomain");

    //
    // Make sure we aren't trying to have RPC allocate the EnumerationContext.
    //

    if ( !ARGUMENT_PRESENT(EnumerationContext) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(Buffer) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(CountReturned) ) {
        return(STATUS_INVALID_PARAMETER);
    }


    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    (*Buffer) = NULL;
    LocalBuffer = NULL;


    RpcTryExcept{

        NtStatus = SamrEnumerateUsersInDomain(
                       (SAMPR_HANDLE)RpcContextHandle,
                       EnumerationContext,
                       UserAccountControl,
                       (PSAMPR_ENUMERATION_BUFFER *)&LocalBuffer,
                       PreferedMaximumLength,
                       CountReturned
                       );


        if (LocalBuffer != NULL) {

            //
            // What comes back is a three level structure:
            //
            //  Local       +-------------+
            //  Buffer ---> | EntriesRead |
            //              |-------------|    +-------+
            //              | Enumeration |--->| Name0 | --- > (NameBuffer0)
            //              | Return      |    |-------|            o
            //              | Buffer      |    |  ...  |            o
            //              +-------------+    |-------|            o
            //                                 | NameN | --- > (NameBufferN)
            //                                 +-------+
            //
            //   The buffer containing the EntriesRead field is not returned
            //   to our caller.  Only the buffers containing name information
            //   are returned.
            //

            if (LocalBuffer->Buffer != NULL) {
                (*Buffer) = LocalBuffer->Buffer;
            }

            MIDL_user_free( LocalBuffer);


        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamCreateAliasInDomain(
    IN SAM_HANDLE DomainHandle,
    IN PUNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    OUT PSAM_HANDLE AliasHandle,
    OUT PULONG RelativeId
)

/*++

Routine Description:

    This API adds a new alias to the account database.  Initially, this
    alias does not contain any members.

    This call returns a handle to the newly created account that may be
    used for successive operations on the object.  This handle may be
    closed with the SamCloseHandle API.

    A newly created group will have the following initial field value
    settings.  If another value is desired, it must be explicitly changed
    using the Alias object manipulation services.

        Name - the name of the account will be as specified in the creation
            API.

        MemberCount - Zero.  Initially the alias has no members.

        RelativeId - will be a uniquelly allocated ID.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.  The handle must be open for DOMAIN_CREATE_ALIAS
        access.

    AccountName - The name of the alias to be added.

    DesiredAccess - Is an access mask indicating which access types
        are desired to the alias.

    AliasHandle - Receives a handle referencing the newly created
        alias.  This handle will be required in successive calls to
        operate on the alias.

    RelativeId - Receives the relative ID of the newly created alias.
        The SID of the new alias is this relative ID value prefixed with
        the domain's SID value.


Return Values:

    STATUS_SUCCESS - The account was added successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_ACCOUNT_NAME - The name was poorly formed, e.g.
        contains non-printable characters.

    STATUS_GROUP_EXISTS - The name is already in use as a group.

    STATUS_USER_EXISTS - The name is already in use as a user.

    STATUS_ALIAS_EXISTS - The name is already in use as an alias.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled before aliases
        can be created in it.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.  The domain server must be a primary server to
        create aliases.


--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        DomainRpcContextHandle, AliasRpcContextHandle;
    SAMP_HANDLE         SampAliasHandle;

    SampOutputDebugString("SamCreateAliasInDomain");

    if (IsBadWritePtr(AliasHandle, sizeof(SAM_HANDLE))) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!SampIsValidClientHandle(DomainHandle, &DomainRpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Prepare the new handle to return
    //
    NtStatus = SampCreateNewHandle((SAMP_HANDLE)DomainHandle,
                                   NULL,
                                   &SampAliasHandle);
    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }


    //
    // Call the server ...
    //


    (*AliasHandle) = NULL;
    (*RelativeId)  = 0;

    RpcTryExcept{

        NtStatus =
            SamrCreateAliasInDomain(
                (SAMPR_HANDLE)DomainRpcContextHandle,
                (PRPC_UNICODE_STRING)AccountName,
                DesiredAccess,
                (SAMPR_HANDLE *)&AliasRpcContextHandle,
                RelativeId
                );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    if (NT_SUCCESS(NtStatus)) {
        SampAliasHandle->ContextHandle = AliasRpcContextHandle;
    } else {
        SampFreeHandle(&SampAliasHandle);
    }
    *AliasHandle = (SAM_HANDLE)SampAliasHandle;


    return(SampMapCompletionStatus(NtStatus));
}



NTSTATUS
SamEnumerateAliasesInDomain(
    IN SAM_HANDLE DomainHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    IN PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
)

/*++

Routine Description:

    This API lists all the aliases defined in the account database.  Since
    there may be more aliases than can fit into a buffer, the caller is
    provided with a handle that can be used across calls to the API.  On
    the initial call, EnumerationContext should point to a
    SAM_ENUMERATE_HANDLE variable that is set to 0.

    If the API returns STATUS_MORE_ENTRIES, then the API should be
    called again with EnumerationContext.  When the API returns
    STATUS_SUCCESS or any error return, the handle becomes invalid for
    future use.

    This API requires DOMAIN_LIST_ACCOUNTS access to the Domain object.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    EnumerationContext - API specific handle to allow multiple calls
        (see routine description).  This is a zero based index.

    Buffer - Receives a pointer to the buffer containing the
        requested information.  The information returned is
        structured as an array of SAM_RID_ENUMERATION data
        structures.  When this information is no longer needed, the
        buffer must be freed using SamFreeMemory().

    PreferedMaximumLength - Prefered maximum length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves
        as a guide to the server.  Due to data conversion between
        systems with different natural data sizes, the actual amount
        of data returned may be greater than this value.

    CountReturned - Number of entries returned.

Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.

    STATUS_MORE_ENTRIES - There are more entries, so call again.
        This is a successful return.

    STATUS_ACCESS_DENIED - Caller does not have privilege required to
        request that data.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

--*/
{

    NTSTATUS            NtStatus;
    PSAMPR_ENUMERATION_BUFFER LocalBuffer;
    SAMPR_HANDLE        RpcContextHandle;


    SampOutputDebugString("SamEnumerateAliasesInDomain");

    //
    // Make sure we aren't trying to have RPC allocate the EnumerationContext.
    //

    if ( !ARGUMENT_PRESENT(EnumerationContext) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(Buffer) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(CountReturned) ) {
        return(STATUS_INVALID_PARAMETER);
    }

    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    (*Buffer) = NULL;
    LocalBuffer = NULL;


    RpcTryExcept{

        NtStatus = SamrEnumerateAliasesInDomain(
                       (SAMPR_HANDLE)RpcContextHandle,
                       EnumerationContext,
                       (PSAMPR_ENUMERATION_BUFFER *)&LocalBuffer,
                       PreferedMaximumLength,
                       CountReturned
                       );


        if (LocalBuffer != NULL) {

            //
            // What comes back is a three level structure:
            //
            //  Local       +-------------+
            //  Buffer ---> | EntriesRead |
            //              |-------------|    +-------+
            //              | Enumeration |--->| Name0 | --- > (NameBuffer0)
            //              | Return      |    |-------|            o
            //              | Buffer      |    |  ...  |            o
            //              +-------------+    |-------|            o
            //                                 | NameN | --- > (NameBufferN)
            //                                 +-------+
            //
            //   The buffer containing the EntriesRead field is not returned
            //   to our caller.  Only the buffers containing name information
            //   are returned.
            //

            if (LocalBuffer->Buffer != NULL) {
                (*Buffer) = LocalBuffer->Buffer;
            }

            MIDL_user_free( LocalBuffer);


        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}




NTSTATUS
SamGetAliasMembership(
    IN SAM_HANDLE DomainHandle,
    IN ULONG PassedCount,
    IN PSID *Sids,
    OUT PULONG MembershipCount,
    OUT PULONG *Aliases
)

/*++

Routine Description:

    This API searches the set of aliases in the specified domain to see
    which aliases, if any, the passed SIDs are members of.  Any aliases
    that any of the SIDs are found to be members of are returned.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    PassedCount - Specifies the number of Sids being passed.

    Sids - Pointer to an array of Count pointers to Sids whose alias
        memberships are to be looked up.

    MembershipCount - Receives the number of aliases that are being
        returned via the Aliases parameter.

    Aliases - Receives a pointer to an array of SIDs.  This is the set
        of aliases the passed SIDs were found to be members of.  If
        MembershipCount is returned as zero, then a null value will be
        returned here.

        When this information is no longer needed, it must be released
        by passing the returned pointer to SamFreeMemory().

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have privilege required to
        request that data.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

--*/
{

    NTSTATUS            NtStatus;
    SAMPR_PSID_ARRAY    Accounts;
    SAMPR_ULONG_ARRAY   Membership;

    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamAliasMembership");

    //
    // Make sure we aren't trying to have RPC allocate the EnumerationContext.
    //

    if ( !ARGUMENT_PRESENT(Sids) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(MembershipCount) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(Aliases) ) {
        return(STATUS_INVALID_PARAMETER);
    }

    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    Membership.Element = NULL;

    RpcTryExcept{

        Accounts.Count = PassedCount;
        Accounts.Sids = (PSAMPR_SID_INFORMATION)Sids;

        NtStatus = SamrGetAliasMembership(
                       (SAMPR_HANDLE)RpcContextHandle,
                       &Accounts,
                       &Membership
                       );

        if (NT_SUCCESS(NtStatus)) {
            (*MembershipCount) = Membership.Count;
            if ((Membership.Count == 0) && (NULL != Membership.Element))
            {
                MIDL_user_free(Membership.Element);
                Membership.Element = NULL;
            }
            (*Aliases)         = Membership.Element;
        } else {

            //
            // Deallocate any returned buffers on error
            //

            if (Membership.Element != NULL) {
                MIDL_user_free(Membership.Element);
            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}





NTSTATUS
SamLookupNamesInDomain(
    IN SAM_HANDLE DomainHandle,
    IN ULONG Count,
    IN PUNICODE_STRING Names,
    OUT PULONG *RelativeIds,
    OUT PSID_NAME_USE *Use
)

/*++

Routine Description:

    This API attempts to find relative IDs corresponding to name
    strings.  If a name can not be mapped to a relative ID, a zero is
    placed in the corresponding relative ID array entry, and translation
    continues.

    DOMAIN_LOOKUP access to the domain is needed to use this service.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    Count - Number of names to translate.

    Names - Pointer to an array of Count UNICODE_STRINGs that contain
        the names to map to relative IDs.  Case-insensitive
        comparisons of these names will be performed for the lookup
        operation.

    RelativeIds - Receives a pointer to an array of Count Relative IDs
        that have been filled in.  The relative ID of the nth name will
        be the nth entry in this array.  Any names that could not be
        translated will have a zero relative ID.  This buffer must be
        freed when no longer needed using SamFreeMemory().

    Use - Recieves a pointer to an array of Count SID_NAME_USE
        entries that have been filled in with what significance each
        name has.  The nth entry in this array indicates the meaning
        of the nth name passed.  This buffer must be freed when no longer
        needed using SamFreeMemory().

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The domain handle passed is invalid.

    STATUS_SOME_NOT_MAPPED - Some of the names provided could not be
        mapped.  This is a successful return.

    STATUS_NONE_MAPPED - No names could be mapped.  This is an error
        return.


--*/
{


    NTSTATUS
        ReturnStatus = STATUS_SUCCESS,
        NtStatus = STATUS_SUCCESS;

    LIST_ENTRY
        CallHead;

    PSAMP_NAME_LOOKUP_CALL
        Next;

    PSID_NAME_USE
        UseBuffer;

    PULONG
        RidBuffer;

    ULONG
        Calls,
        CallLength,
        i;

    BOOLEAN
        NoneMapped = TRUE,
        SomeNotMapped = FALSE;

    SAMPR_HANDLE
        RpcContextHandle;

    SampOutputDebugString("SamLookupNamesInDomain");


    if ( (Count == 0)   ||  (Names == NULL)    ) {
        return(STATUS_INVALID_PARAMETER);
    }


    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Default error return
    //

    (*Use)         = UseBuffer = NULL;
    (*RelativeIds) = RidBuffer = NULL;


    //
    // Set up the call structures list
    //

    InitializeListHead( &CallHead );
    Calls = 0;


    //
    // By default we will return NONE_MAPPED.
    // This will get superseded by either STATUS_SUCCESS
    // or STATUS_SOME_NOT_MAPPED.
    //

    //
    // Now build up and make each call
    //

    i = 0;
    while ( i < Count ) {

        //
        // Make sure the next entry isn't too long.
        // That would put us in an infinite loop.
        //

        if (Names[i].Length > SAM_MAXIMUM_LOOKUP_LENGTH) {
            ReturnStatus = STATUS_INVALID_PARAMETER;
            goto SampNameLookupFreeAndReturn;
        }

        //
        // Get the next call structure
        //

        Next = (PSAMP_NAME_LOOKUP_CALL)MIDL_user_allocate( sizeof(SAMP_NAME_LOOKUP_CALL) );

        if (Next == NULL) {
            ReturnStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto SampNameLookupFreeAndReturn;
        }

        //
        // Fill in the call structure.
        // It takes a little to figure out how many entries to send in
        // this call.  It is limited by both Count (sam_MAXIMUM_LOOKUP_COUNT)
        // and by size (SAM_MAXIMUM_LOOKUP_LENGTH).
        //

        Next->Count             = 0;
        Next->StartIndex        = i;
        Next->RidBuffer.Element = NULL;
        Next->UseBuffer.Element = NULL;

        CallLength = 0;
        for ( i=i;
              ( (i < Count)                                             &&
                (CallLength+Names[i].Length < SAM_MAXIMUM_LOOKUP_LENGTH) &&
                (Next->Count < SAM_MAXIMUM_LOOKUP_COUNT)
              );
              i++ ) {

            //
            // Add in the next length and increment the number of entries
            // being processed by this call.
            //

            CallLength += Names[i].Length;
            Next->Count ++;

        }



        //
        // Add this call structure to the list of call structures
        //

        Calls ++;
        InsertTailList( &CallHead, &Next->Link );


        //
        // Now make the call
        //

        RpcTryExcept{

            NtStatus = SamrLookupNamesInDomain(
                                 (SAMPR_HANDLE)RpcContextHandle,
                                 Next->Count,
                                 (PRPC_UNICODE_STRING)(&Names[Next->StartIndex]),
                                 &Next->RidBuffer,
                                 &Next->UseBuffer
                                 );


        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

        } RpcEndExcept;


        //
        // Keep track of what our completion status should be.
        //

        if (!NT_SUCCESS(NtStatus)    &&
            NtStatus != STATUS_NONE_MAPPED) {
                ReturnStatus = NtStatus;      // Unexpected error
                goto SampNameLookupFreeAndReturn;
        }

        if (NT_SUCCESS(NtStatus)) {
            NoneMapped = FALSE;
            if (NtStatus == STATUS_SOME_NOT_MAPPED) {
                SomeNotMapped = TRUE;
            }
        }
    }


    //
    // Set our return status...
    //

    if (NoneMapped) {
        ASSERT(SomeNotMapped == FALSE);
        ReturnStatus = STATUS_NONE_MAPPED;
    } else  if (SomeNotMapped) {
        ReturnStatus = STATUS_SOME_NOT_MAPPED;
    } else {
        ReturnStatus = STATUS_SUCCESS;
    }




    //
    // At this point we have (potentially) a lot of call structures.
    // The RidBuffer and UseBuffer elements of each call structure
    // is allocated and returned by the RPC call and looks
    // like:
    //
    //              RidBuffer
    //              +-------------+
    //              |   Count     |
    //              |-------------|    +-------+ *
    //              | Element  ---|--->| Rid-0 |  |    /
    //              +-------------+    |-------|  |   / Only this part
    //                                 |  ...  |   > <  is allocated by
    //                                 |-------|  |   \ the rpc call.
    //                                 | Rid-N |  |    \
    //                                 +-------+ *
    //
    //   If only one RPC call was made, we can return this information
    //   directly.  Otherwise, we need to copy the information from
    //   all the calls into a single large buffer and return that buffer
    //   (freeing all the individual call buffers).
    //
    //   The user is responsible for freeing whichever buffer we do
    //   return.
    //

    ASSERT(Calls != 0);  // Error go around this path, success always has calls


    //
    // Optimize for a single call
    //

    if (Calls == 1) {
        (*Use) = (PSID_NAME_USE)
                  (((PSAMP_NAME_LOOKUP_CALL)(CallHead.Flink))->
                     UseBuffer.Element);
        (*RelativeIds) = ((PSAMP_NAME_LOOKUP_CALL)(CallHead.Flink))->
                            RidBuffer.Element;
        MIDL_user_free( CallHead.Flink ); // Free the call structure
        return(ReturnStatus);
    }


    //
    // More than one call.
    // Allocate return buffers large enough to copy all the information into.
    //

    RidBuffer = MIDL_user_allocate( sizeof(ULONG) * Count );
    if (RidBuffer == NULL) {
        ReturnStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto SampNameLookupFreeAndReturn;
    }

    UseBuffer = MIDL_user_allocate( sizeof(SID_NAME_USE) * Count );
    if (UseBuffer == NULL) {
        MIDL_user_free( RidBuffer );
        RidBuffer = NULL;
        ReturnStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto SampNameLookupFreeAndReturn;
    }




SampNameLookupFreeAndReturn:

    //
    // Walk the list of calls.
    // For each call:
    //
    //      If we have a return buffer, copy the results into it.
    //      Free the call buffers.
    //      Free the call structure itself.
    //
    // Completion status has already been set appropriatly in ReturnStatus.
    //

    Next = (PSAMP_NAME_LOOKUP_CALL)RemoveHeadList( &CallHead );
    while (Next != (PSAMP_NAME_LOOKUP_CALL)&CallHead) {

        //
        // Copy RID information and then free the call buffer
        //

        if (RidBuffer != NULL) {
            RtlMoveMemory(
                &RidBuffer[ Next->StartIndex ],     // Destination
                &Next->RidBuffer.Element[0],        // Source
                Next->Count * sizeof(ULONG)         // Length
                );
        }

        if (Next->RidBuffer.Element != NULL) {
            MIDL_user_free( Next->RidBuffer.Element );
        }


        //
        // Copy USE information and then free the call buffer
        //

        if (UseBuffer != NULL) {
            RtlMoveMemory(
                &UseBuffer[ Next->StartIndex ],     // Destination
                &Next->UseBuffer.Element[0],        // Source
                Next->Count * sizeof(SID_NAME_USE)  // Length
                );
        }

        if (Next->UseBuffer.Element != NULL) {
            MIDL_user_free( Next->UseBuffer.Element );
        }

        //
        // Free the call structure itself
        //

        MIDL_user_free( Next );

        Next = (PSAMP_NAME_LOOKUP_CALL)RemoveHeadList( &CallHead );
    }  // end-while



    //
    // For better or worse, we're all done
    //

    (*Use)         = UseBuffer;
    (*RelativeIds) = RidBuffer;


    return(SampMapCompletionStatus(ReturnStatus));
}

NTSTATUS
SamLookupIdsInDomain(
    IN SAM_HANDLE DomainHandle,
    IN ULONG Count,
    IN PULONG RelativeIds,
    OUT PUNICODE_STRING *Names,
    OUT PSID_NAME_USE *Use OPTIONAL
    )

/*++

Routine Description:

    This API maps a number of relative IDs to their corresponding names.
    The use of the name (domain, group, alias, user, or unknown) is also
    returned.

    The API stores the actual names in Buffer, then creates an array of
    UNICODE_STRINGs in the Names OUT parameter.  If a relative ID can
    not be mapped, a NULL value is placed in the slot for the
    UNICODE_STRING, and STATUS_SOME_NOT_MAPPED is returned.

    DOMAIN_LOOKUP access to the domain is needed to use this service.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    Count - Provides the number of relative IDs to translate.

    RelativeIds - Array of Count relative IDs to be mapped.

    Names - Receives a pointer to an array of Count UNICODE_STRINGs that
        have been filled in.  The nth pointer within this array will
        correspond the nth relative id passed .  Each name string buffer
        will be in a separately allocated block of memory.  Any entry is
        not successfully translated will have a NULL name buffer pointer
        returned.  This Names buffer must be freed using SamFreeMemory()
        when no longer needed.

    Use - Optionally, receives a pointer to an array of Count SID_NAME_USE
        entries that have been filled in with what significance each
        name has.  The nth entry in this array indicates the meaning
        of the nth name passed.  This buffer must be freed when no longer
        needed using SamFreeMemory().

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The domain handle passed is invalid.

    STATUS_SOME_NOT_MAPPED - Some of the names provided could not be
        mapped.  This is a successful return.

    STATUS_NONE_MAPPED - No names could be mapped.  This is an error
        return.
--*/

{
    NTSTATUS                        NtStatus;
    ULONG                           SubRequest, SubRequests;
    ULONG                           TotalCountToDate;
    ULONG                           Index, UsedLength, Length, NamesLength;
    ULONG                           UsesLength, LastSubRequestCount;
    PULONG_PTR                      UstringStructDisps = NULL;
    PULONG                          Counts = NULL;
    PULONG                          RidIndices = NULL;
    NTSTATUS                        *SubRequestStatus = NULL;
    PUNICODE_STRING                 *SubRequestNames = NULL;
    PSID_NAME_USE                   *SubRequestUses = NULL;
    PUNICODE_STRING                 OutputNames = NULL;
    PSID_NAME_USE                   OutputUses = NULL;
    PUCHAR                          Destination = NULL, Source = NULL;
    PUNICODE_STRING                 DestUstring = NULL;
    ULONG                           SomeNotMappedStatusCount = 0;
    ULONG                           NoneMappedStatusCount = 0;

    SAMPR_HANDLE                    RpcContextHandle;

    SampOutputDebugString("SamLookupIdsInDomain");

    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // If the Count for this request does not exceed the maximum limit that
    // can be looked up in a single call, just call the Sub Request version
    // of the routine.
    //


    if (Count <= SAM_MAXIMUM_LOOKUP_COUNT) {

        NtStatus = SampLookupIdsInDomain(
                       DomainHandle,
                       Count,
                       RelativeIds,
                       Names,
                       Use
                       );

        return(NtStatus);
    }

    //
    // Break down larger requests into smaller chunks
    //

    SubRequests = Count / SAMP_MAXIMUM_SUB_LOOKUP_COUNT;
    LastSubRequestCount = Count % SAMP_MAXIMUM_SUB_LOOKUP_COUNT;

    if (LastSubRequestCount > 0) {

        SubRequests++;
    }

    //
    // Allocate memory for array of starting Rid Indices, Rid Counts and
    // Unicode String block offsets for each SubRequest.
    //

    NtStatus = STATUS_NO_MEMORY;

    RidIndices = MIDL_user_allocate( SubRequests * sizeof(ULONG) );

    if (RidIndices == NULL) {

        goto LookupIdsInDomainError;
    }
    RtlZeroMemory( RidIndices, SubRequests * sizeof(ULONG) );

    Counts = MIDL_user_allocate( SubRequests * sizeof(ULONG) );

    if (Counts == NULL) {

        goto LookupIdsInDomainError;
    }
    RtlZeroMemory( Counts, SubRequests * sizeof(ULONG) );

    SubRequestStatus = MIDL_user_allocate( SubRequests * sizeof(NTSTATUS) );

    if (SubRequestStatus == NULL) {

        goto LookupIdsInDomainError;
    }
    RtlZeroMemory( SubRequestStatus, SubRequests * sizeof(NTSTATUS) );

    SubRequestNames = MIDL_user_allocate( SubRequests * sizeof(PUNICODE_STRING) );

    if (SubRequestNames == NULL) {

        goto LookupIdsInDomainError;
    }
    RtlZeroMemory( SubRequestNames, SubRequests * sizeof(PUNICODE_STRING) );

    SubRequestUses = MIDL_user_allocate( SubRequests * sizeof(PSID_NAME_USE) );

    if (SubRequestUses == NULL) {

        goto LookupIdsInDomainError;
    }
    RtlZeroMemory( SubRequestUses, SubRequests * sizeof(PSID_NAME_USE) );

    UstringStructDisps = MIDL_user_allocate( SubRequests * sizeof(ULONG_PTR) );

    if (UstringStructDisps == NULL) {

        goto LookupIdsInDomainError;
    }
    RtlZeroMemory( UstringStructDisps, SubRequests * sizeof(ULONG_PTR) );

    NtStatus = STATUS_SUCCESS;

    TotalCountToDate = 0;

    for (SubRequest = 0; SubRequest < SubRequests; SubRequest++) {

        RidIndices[SubRequest] = TotalCountToDate;

        if ((Count - TotalCountToDate) > SAMP_MAXIMUM_SUB_LOOKUP_COUNT) {

            Counts[SubRequest] = SAMP_MAXIMUM_SUB_LOOKUP_COUNT;

        } else {

            Counts[SubRequest] = Count - TotalCountToDate;
        }

        TotalCountToDate += Counts[SubRequest];

        NtStatus = SampLookupIdsInDomain(
                       DomainHandle,
                       Counts[SubRequest],
                       &RelativeIds[RidIndices[SubRequest]],
                       &SubRequestNames[SubRequest],
                       &SubRequestUses[SubRequest]
                       );

        //
        // SubRequestStatus[] is an array to keep the return 
        // status of each Sub Request when calling SampLookupIdsInDomain. 
        // The reason why we will need it is that 
        // if SampLookupIdsInDomain returns STATUS_NONE_MAPPED, 
        // no memory will be allocated for SubRequestNames[SubRequest] and 
        // SubRequestUses[SubRequest]
        //

        SubRequestStatus[SubRequest] = NtStatus;

        //
        // We keep a tally of the number of times STATUS_SOME_NOT_MAPPED
        // and STATUS_NONE_MAPPED were returned.  This is so that we
        // can return the appropriate status at the end based on the
        // global picture.  We continue lookups after either status code
        // is encountered.
        //

        if (NtStatus == STATUS_SOME_NOT_MAPPED) {

            SomeNotMappedStatusCount++;

        } else if (NtStatus == STATUS_NONE_MAPPED) {

            NoneMappedStatusCount++;
            NtStatus = STATUS_SUCCESS;

        }

        if (!NT_SUCCESS(NtStatus)) {

            break;
        }
    }

    if (!NT_SUCCESS(NtStatus)) {

        goto LookupIdsInDomainError;
    }

    //
    // Now allocate a single buffer for the Names
    //

    NamesLength = Count * sizeof(UNICODE_STRING);

    for (SubRequest = 0; SubRequest < SubRequests; SubRequest++) {

        if (SubRequestStatus[SubRequest] == STATUS_NONE_MAPPED) {
            continue;
        }

        for (Index = 0; Index < Counts[SubRequest]; Index++) {

            NamesLength += (SubRequestNames[SubRequest] + Index)->MaximumLength;
        }
    }

    NtStatus = STATUS_INSUFFICIENT_RESOURCES;

    OutputNames = MIDL_user_allocate( NamesLength );

    if (OutputNames == NULL) {

        goto LookupIdsInDomainError;
    }
    RtlZeroMemory(OutputNames, NamesLength);


    NtStatus = STATUS_SUCCESS;

    //
    // Now copy in the Unicode String Structures for the Names returned from
    // each subrequest.  We will later overwrite the Buffer fields in them
    // when we assign space and move in each Unicode String.
    //

    Destination = (PUCHAR) OutputNames;
    UsedLength = 0;

    for (SubRequest = 0; SubRequest < SubRequests; SubRequest++) {

        if (SubRequestStatus[SubRequest] == STATUS_NONE_MAPPED) {
            continue;
        }

        Source = (PUCHAR) SubRequestNames[SubRequest];
        Length = Counts[SubRequest] * sizeof(UNICODE_STRING);
        UstringStructDisps[SubRequest] = (ULONG_PTR)(Destination - Source);
        RtlMoveMemory( Destination, Source, Length );
        Destination += Length;
        UsedLength += Length;
    }

    //
    // Now copy in the Unicode Strings themselves.  These are appended to
    // the array of Unicode String structures.  As we go, update the
    // Unicode string buffer pointers to point to the copied version
    // of each string.
    //

    for (SubRequest = 0; SubRequest < SubRequests; SubRequest++) {

        if (STATUS_NONE_MAPPED == SubRequestStatus[SubRequest]) {
            continue;
        }

        for (Index = 0; Index < Counts[SubRequest]; Index++) {

            Source = (PUCHAR)(SubRequestNames[SubRequest] + Index)->Buffer;
            Length = (ULONG)(SubRequestNames[SubRequest] + Index)->MaximumLength;

            //
            // It is possible that a returned Unicode String has 0 length
            // because an Id was not mapped.  In this case, skip to the next
            // one.
            //

            if (Length == 0) {

                continue;
            }

            DestUstring = (PUNICODE_STRING)
               (((PUCHAR)(SubRequestNames[SubRequest] + Index)) +
                  UstringStructDisps[SubRequest]);

            DestUstring->Buffer = (PWSTR) Destination;

            ASSERT(UsedLength + Length <= NamesLength);

            RtlMoveMemory( Destination, Source, Length );
            Destination += Length;
            UsedLength += Length;
            continue;
        }
    }

    if (!NT_SUCCESS(NtStatus)) {

        goto LookupIdsInDomainError;
    }

    //
    // Now allocate a single buffer for the Uses
    //

    UsesLength = Count * sizeof(SID_NAME_USE);

    NtStatus = STATUS_INSUFFICIENT_RESOURCES;

    OutputUses = MIDL_user_allocate( UsesLength );

    if (OutputUses == NULL) {

        goto LookupIdsInDomainError;
    }
    RtlZeroMemory( OutputUses, UsesLength );

    NtStatus = STATUS_SUCCESS;

    //
    // Now copy in the SID_NAME_USE Structures for the Uses returned from
    // each subrequest.
    //

    Destination = (PUCHAR) OutputUses;
    UsedLength = 0;

    for (SubRequest = 0; SubRequest < SubRequests; SubRequest++) {

        if (STATUS_NONE_MAPPED == SubRequestStatus[SubRequest]) {
            continue;
        }

        Source = (PUCHAR) SubRequestUses[SubRequest];
        Length = Counts[SubRequest] * sizeof(SID_NAME_USE);
        RtlMoveMemory( Destination, Source, Length );
        Destination += Length;
        UsedLength += Length;
    }

    if (!NT_SUCCESS(NtStatus)) {

        goto LookupIdsInDomainError;
    }

    *Names = OutputNames;

    if (ARGUMENT_PRESENT(Use))
    {
        *Use = OutputUses;
    }

    //
    // Determine the final status to return.  This is the normal NtStatus code
    // except that if NtStatus is a success status and none/not all Ids were
    // mapped, NtStatus will be set to either STATUS_SOME_NOT_MAPPED or
    // STATUS_NONE_MAPPED as appropriate.  If STATUS_SOME_NOT_MAPPED was
    // returned on at least one call, return that status.  If STATUS_NONE_MAPPED
    // was returned on all calls, return that status.
    //

    if (NT_SUCCESS(NtStatus)) {

        if (SomeNotMappedStatusCount > 0) {

            NtStatus = STATUS_SOME_NOT_MAPPED;

        } else if (NoneMappedStatusCount == SubRequests) {

            NtStatus = STATUS_NONE_MAPPED;

        } else if (NoneMappedStatusCount > 0) {

            //
            // One or more calls returned STATUS_NONE_MAPPED but not all.
            // So at least one Id was mapped, but not all ids.
            //

            NtStatus = STATUS_SOME_NOT_MAPPED;
        }
    }

LookupIdsInDomainFinish:

    //
    // If necessary, free the buffer containing the starting Rid Indices for
    // each Sub Request.
    //

    if (RidIndices != NULL) {

        MIDL_user_free(RidIndices);
        RidIndices = NULL;
    }

    //
    // If necessary, free the buffer containing the Rid Counts for
    // each Sub Request.
    //

    if (Counts != NULL) {

        MIDL_user_free(Counts);
        Counts = NULL;
    }

    //
    // if necessary, free the buffer containing the NtStatus for 
    // each Sub Request.
    // 

    if (SubRequestStatus != NULL) {

        MIDL_user_free(SubRequestStatus);
        SubRequestStatus = NULL;
    }

    //
    // If necessary, free the buffer containing the offsets from the
    // source and destination Unicode String structures.
    //

    if (UstringStructDisps != NULL) {

        MIDL_user_free(UstringStructDisps);
        UstringStructDisps = NULL;
    }

    //
    // If necessary, free the SubRequestNames output returned for each
    // Sub Request.
    //

    if (SubRequestNames != NULL) {

        for (SubRequest = 0; SubRequest < SubRequests; SubRequest++) {

            if (SubRequestNames[SubRequest] != NULL) {

                MIDL_user_free(SubRequestNames[SubRequest]);
                SubRequestNames[SubRequest] = NULL;
            }
        }

        MIDL_user_free(SubRequestNames);
        SubRequestNames = NULL;
    }

    //
    // If necessary, free the SubRequestUses output returned for each
    // Sub Request.
    //

    if (SubRequestUses != NULL) {

        for (SubRequest = 0; SubRequest < SubRequests; SubRequest++) {

            if (SubRequestUses[SubRequest] != NULL) {

                MIDL_user_free(SubRequestUses[SubRequest]);
                SubRequestUses[SubRequest] = NULL;
            }
        }

        MIDL_user_free(SubRequestUses);
        SubRequestUses = NULL;
    }

    return(NtStatus);

LookupIdsInDomainError:

    //
    // If necessary, free the buffers we would hande returned for
    // Names and Use.
    //

    if (OutputNames != NULL) {

        MIDL_user_free(OutputNames);
        OutputNames = NULL;
    }

    if (OutputUses != NULL) {

        MIDL_user_free(OutputUses);
        OutputUses = NULL;
    }

    *Names = NULL;
    *Use = NULL;

    goto LookupIdsInDomainFinish;
}



NTSTATUS
SampLookupIdsInDomain(
    IN SAM_HANDLE DomainHandle,
    IN ULONG Count,
    IN PULONG RelativeIds,
    OUT PUNICODE_STRING *Names,
    OUT PSID_NAME_USE *Use OPTIONAL
    )

/*++

Routine Description:

    This API maps a number of relative IDs to their corresponding names.
    The use of the name (domain, group, alias, user, or unknown) is also
    returned.

    The API stores the actual names in Buffer, then creates an array of
    UNICODE_STRINGs in the Names OUT parameter.  If a relative ID can
    not be mapped, a NULL value is placed in the slot for the
    UNICODE_STRING, and STATUS_SOME_NOT_MAPPED is returned.

    DOMAIN_LOOKUP access to the domain is needed to use this service.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    Count - Provides the number of relative IDs to translate.

    RelativeIds - Array of Count relative IDs to be mapped.

    Names - Receives a pointer to an array of Count UNICODE_STRINGs that
        have been filled in.  The nth pointer within this array will
        correspond the nth relative id passed .  Each name string buffer
        will be in a separately allocated block of memory.  Any entry is
        not successfully translated will have a NULL name buffer pointer
        returned.  This Names buffer must be freed using SamFreeMemory()
        when no longer needed.

    Use - Optionally, receives a pointer to an array of Count SID_NAME_USE
        entries that have been filled in with what significance each
        name has.  The nth entry in this array indicates the meaning
        of the nth name passed.  This buffer must be freed when no longer
        needed using SamFreeMemory().

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The domain handle passed is invalid.

    STATUS_SOME_NOT_MAPPED - Some of the names provided could not be
        mapped.  This is a successful return.

    STATUS_NONE_MAPPED - No names could be mapped.  This is an error
        return.


--*/

{

    NTSTATUS                        NtStatus = STATUS_SUCCESS;
    SAMPR_RETURNED_USTRING_ARRAY    NameBuffer;
    SAMPR_ULONG_ARRAY               UseBuffer;
    SAMPR_HANDLE                    RpcContextHandle;

    SampOutputDebugString("SamLookupIdsInDomain");

    //
    // Make sure our parameters are within bounds
    //

    if (0 == Count)
    {
        (*Names) = NULL;
        if ( ARGUMENT_PRESENT(Use) ) {
            (*Use) = NULL;
        }
        return(STATUS_SUCCESS);
    }

    if (RelativeIds == NULL) {
        return(STATUS_INVALID_PARAMETER);
    }

    if (Count > SAM_MAXIMUM_LOOKUP_COUNT) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }


    //
    // Call the server ...
    //


    NameBuffer.Element = NULL;
    UseBuffer.Element  = NULL;


    RpcTryExcept{

        NtStatus = SamrLookupIdsInDomain(
                       (SAMPR_HANDLE)RpcContextHandle,
                       Count,
                       RelativeIds,
                       &NameBuffer,
                       &UseBuffer
                       );


    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    //
    // What comes back for the "Names" OUT parameter is a two level
    // structure, the first level of which is on our stack:
    //
    //              NameBuffer
    //              +-------------+
    //              |   Count     |
    //              |-------------|    +-------+
    //              | Element  ---|--->| Name0 | --- > (NameBuffer0)
    //              +-------------+    |-------|            o
    //                                 |  ...  |            o
    //                                 |-------|            o
    //                                 | NameN | --- > (NameBufferN)
    //                                 +-------+
    //
    //   The buffer containing the EntriesRead field is not returned
    //   to our caller.  Only the buffers containing name information
    //   are returned.
    //
    //   NOTE:  The buffers containing name information are allocated
    //          by the RPC runtime in a single buffer.  This is caused
    //          by a line the the client side .acf file.
    //

    //
    // What comes back for the "Use" OUT parameter is a two level
    // structure, the first level of which is on our stack:
    //
    //              UseBuffer
    //              +-------------+
    //              |   Count     |
    //              |-------------|    +-------+
    //              | Element  ---|--->| Use-0 |
    //              +-------------+    |-------|
    //                                 |  ...  |
    //                                 |-------|
    //                                 | Use-N |
    //                                 +-------+
    //
    //   The Pointer in the Element field is what gets returned
    //   to our caller.  The caller is responsible for deallocating
    //   this when no longer needed.
    //

    (*Names) = (PUNICODE_STRING)NameBuffer.Element;
    if ( ARGUMENT_PRESENT(Use) ) {
        (*Use) = (PSID_NAME_USE) UseBuffer.Element;
    } else {
        if (UseBuffer.Element != NULL) {
            MIDL_user_free(UseBuffer.Element);
            UseBuffer.Element = NULL;
        }
    }


    //
    // Don't force our caller to deallocate things on unexpected
    // return value.
    //

    if (NtStatus != STATUS_SUCCESS         &&
        NtStatus != STATUS_SOME_NOT_MAPPED
       ) {
        if ( ARGUMENT_PRESENT(Use) ) {
            (*Use) = NULL;
        }
        if (UseBuffer.Element != NULL) {
            MIDL_user_free(UseBuffer.Element);
            UseBuffer.Element = NULL;
        }

        (*Names) = NULL;
        if (NameBuffer.Element != NULL) {
            MIDL_user_free(NameBuffer.Element);
            NameBuffer.Element = NULL;
        }

    }


    return(SampMapCompletionStatus(NtStatus));




}



NTSTATUS
SamQueryDisplayInformation (
      IN    SAM_HANDLE DomainHandle,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    ULONG      Index,
      IN    ULONG      EntryCount,
      IN    ULONG      PreferredMaximumLength,
      OUT   PULONG     TotalAvailable,
      OUT   PULONG     TotalReturned,
      OUT   PULONG     ReturnedEntryCount,
      OUT   PVOID      *SortedBuffer
      )
/*++

Routine Description:

    This routine provides fast return of information commonly
    needed to be displayed in user interfaces.

    NT User Interface has a requirement for quick enumeration of SAM
    accounts for display in list boxes.  (Replication has similar but
    broader requirements.)


Parameters:

    DomainHandle - A handle to an open domain for DOMAIN_LIST_ACCOUNTS.

    DisplayInformation - Indicates which information is to be enumerated.

    Index - The index of the first entry to be retrieved.

    PreferedMaximumLength - A recommended upper limit to the number of
        bytes to be returned.  The returned information is allocated by
        this routine.

    TotalAvailable - Total number of bytes availabe in the specified info
        class.  This parameter is optional (and is not returned) for
        the following info levels:

                DomainDisplayOemUser
                DomainDisplayOemGroup


    TotalReturned - Number of bytes actually returned for this call.  Zero
        indicates there are no entries with an index as large as that
        specified.

    ReturnedEntryCount - Number of entries returned by this call.  Zero
        indicates there are no entries with an index as large as that
        specified.


    SortedBuffer - Receives a pointer to a buffer containing a sorted
        list of the requested information.  This buffer is allocated
        by this routine and contains the following structure:


            DomainDisplayUser     --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_USER.  This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_USER structures.

            DomainDisplayMachine  --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_MACHINE.  This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_MACHINE structures.

            DomainDisplayGroup    --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_GROUP.  This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_GROUP structures.

            DomainDisplayOemUser  --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_OEM_USER.  This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_OEM_user structures.

            DomainDisplayOemGroup --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_OEM_GROUP.  This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_OEM_GROUP structures.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_ACCESS_DENIED - The specified handle was not opened for
        the necessary access.

    STATUS_INVALID_HANDLE - The specified handle is not that of an
        opened Domain object.

    STATUS_INVALID_INFO_CLASS - The requested class of information
        is not legitimate for this service.


--*/
{
    NTSTATUS
        NtStatus;

    SAMPR_DISPLAY_INFO_BUFFER
        DisplayInformationBuffer;

    ULONG
        LocalTotalAvailable;

    SAMPR_HANDLE
        RpcContextHandle;

    SampOutputDebugString("SamQueryDisplayInformation");

    //
    // Check parameters
    //

    if ( !ARGUMENT_PRESENT(TotalAvailable)           &&
        (DisplayInformation != DomainDisplayOemUser) &&
        (DisplayInformation != DomainDisplayOemGroup)   ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(TotalReturned) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(ReturnedEntryCount) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(SortedBuffer) ) {
        return(STATUS_INVALID_PARAMETER);
    }

    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        if (DisplayInformation  <= DomainDisplayMachine) {
            NtStatus = SamrQueryDisplayInformation(
                           (SAMPR_HANDLE)RpcContextHandle,
                           DisplayInformation,
                           Index,
                           EntryCount,
                           PreferredMaximumLength,
                           &LocalTotalAvailable,
                           TotalReturned,
                           &DisplayInformationBuffer);

        } else if (DisplayInformation <= DomainDisplayGroup) {
            NtStatus = SamrQueryDisplayInformation2(
                           (SAMPR_HANDLE)RpcContextHandle,
                           DisplayInformation,
                           Index,
                           EntryCount,
                           PreferredMaximumLength,
                           &LocalTotalAvailable,
                           TotalReturned,
                           &DisplayInformationBuffer);
        } else {
            NtStatus = SamrQueryDisplayInformation3(
                           (SAMPR_HANDLE)RpcContextHandle,
                           DisplayInformation,
                           Index,
                           EntryCount,
                           PreferredMaximumLength,
                           &LocalTotalAvailable,
                           TotalReturned,
                           &DisplayInformationBuffer);
        }

        if (NT_SUCCESS(NtStatus)) {

            if (ARGUMENT_PRESENT(TotalAvailable)) {
                (*TotalAvailable) = LocalTotalAvailable;
            }

            switch (DisplayInformation) {

            case DomainDisplayUser:
                *ReturnedEntryCount = DisplayInformationBuffer.UserInformation.EntriesRead;
                *SortedBuffer = DisplayInformationBuffer.UserInformation.Buffer;
                break;

            case DomainDisplayMachine:
                *ReturnedEntryCount = DisplayInformationBuffer.MachineInformation.EntriesRead;
                *SortedBuffer = DisplayInformationBuffer.MachineInformation.Buffer;
                break;

            case DomainDisplayGroup:
                *ReturnedEntryCount = DisplayInformationBuffer.GroupInformation.EntriesRead;
                *SortedBuffer = DisplayInformationBuffer.GroupInformation.Buffer;
                break;

            case DomainDisplayOemUser:
                *ReturnedEntryCount = DisplayInformationBuffer.OemUserInformation.EntriesRead;
                *SortedBuffer = DisplayInformationBuffer.OemUserInformation.Buffer;
                break;

            case DomainDisplayOemGroup:
                *ReturnedEntryCount = DisplayInformationBuffer.OemGroupInformation.EntriesRead;
                *SortedBuffer = DisplayInformationBuffer.OemGroupInformation.Buffer;
                break;

            }

        } else {
            *ReturnedEntryCount = 0;
            *SortedBuffer = NULL;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        //
        // If the exception indicates the server doesn't have
        // the selected api, that means the server doesn't know
        // about the info level we passed.  Set our completion
        // status appropriately.
        //

        if (RpcExceptionCode() == RPC_S_INVALID_LEVEL         ||
            RpcExceptionCode() == RPC_S_PROCNUM_OUT_OF_RANGE  ||
            RpcExceptionCode() == RPC_NT_PROCNUM_OUT_OF_RANGE ) {
            NtStatus = STATUS_INVALID_INFO_CLASS;
        } else {
            NtStatus = I_RpcMapWin32Status(RpcExceptionCode());
        }

    } RpcEndExcept;


    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamGetDisplayEnumerationIndex (
      IN    SAM_HANDLE        DomainHandle,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    PUNICODE_STRING   Prefix,
      OUT   PULONG            Index
      )
/*++

Routine Description:

    This routine returns the index of the entry which alphabetically
    immediatly preceeds a specified prefix.  If no such entry exists,
    then zero is returned as the index.

Parameters:

    DomainHandle - A handle to an open domain for DOMAIN_LIST_ACCOUNTS.

    DisplayInformation - Indicates which sorted information class is
        to be searched.

    Prefix - The prefix to compare.

    Index - Receives the index of the entry of the information class
        with a LogonName (or MachineName) which immediatly preceeds the
        provided prefix string.  If there are no elements which preceed
        the prefix, then zero is returned.


Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_ACCESS_DENIED - The specified handle was not opened for
        the necessary access.

    STATUS_INVALID_HANDLE - The specified handle is not that of an
        opened Domain object.

    STATUS_NO_MORE_ENTRIES - There are no entries for this information class.
                             The returned index is invalid.

--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    //
    // Check parameters
    //

    if ( !ARGUMENT_PRESENT(Prefix) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(Index) ) {
        return(STATUS_INVALID_PARAMETER);
    }

    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{
        if (DisplayInformation <= DomainDisplayMachine) {
            //
            // Info levels supported via original API in NT1.0
            //

            NtStatus = SamrGetDisplayEnumerationIndex (
                            (SAMPR_HANDLE)RpcContextHandle,
                            DisplayInformation,
                            (PRPC_UNICODE_STRING)Prefix,
                            Index
                            );
        } else {

            //
            // Info levels added in NT1.0A via new API
            //

            NtStatus = SamrGetDisplayEnumerationIndex2 (
                            (SAMPR_HANDLE)RpcContextHandle,
                            DisplayInformation,
                            (PRPC_UNICODE_STRING)Prefix,
                            Index
                            );
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));


}




NTSTATUS
SamOpenGroup(
    IN SAM_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG GroupId,
    OUT PSAM_HANDLE GroupHandle
    )

/*++

Routine Description:

    This API opens an existing group in the account database.  The group
    is specified by a ID value that is relative to the SID of the
    domain.  The operations that will be performed on the group must be
    declared at this time.

    This call returns a handle to the newly opened group that may be
    used for successive operations on the group.  This handle may be
    closed with the SamCloseHandle API.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    DesiredAccess - Is an access mask indicating which access types
        are desired to the group.  These access types are reconciled
        with the Discretionary Access Control list of the group to
        determine whether the accesses will be granted or denied.

    GroupId - Specifies the relative ID value of the group to be
        opened.

    GroupHandle - Receives a handle referencing the newly opened
        group.  This handle will be required in successive calls to
        operate on the group.

Return Values:

    STATUS_SUCCESS - The group was successfully opened.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_NO_SUCH_GROUP - The specified group does not exist.

    STATUS_INVALID_HANDLE - The domain handle passed is invalid.

--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        DomainRpcContextHandle, GroupRpcContextHandle;
    SAMP_HANDLE         SampGroupHandle;

    SampOutputDebugString("SamOpenGroup");


    if (IsBadWritePtr(GroupHandle, sizeof(SAM_HANDLE))) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!SampIsValidClientHandle(DomainHandle, &DomainRpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Prepare the new handle to return
    //
    NtStatus = SampCreateNewHandle((SAMP_HANDLE)DomainHandle,
                                   NULL,
                                   &SampGroupHandle);
    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }

    //
    // Call the server ...
    //


    RpcTryExcept{

        (*GroupHandle) = 0;

        NtStatus =
            SamrOpenGroup(
                (SAMPR_HANDLE)DomainRpcContextHandle,
                DesiredAccess,
                GroupId,
                (SAMPR_HANDLE *)&GroupRpcContextHandle
                );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    if (NT_SUCCESS(NtStatus)) {
        SampGroupHandle->ContextHandle = GroupRpcContextHandle;
    } else {
        SampFreeHandle(&SampGroupHandle);
    }
    *GroupHandle = SampGroupHandle;

    return(SampMapCompletionStatus(NtStatus));
}



NTSTATUS
SamQueryInformationGroup(
    IN SAM_HANDLE GroupHandle,
    IN GROUP_INFORMATION_CLASS GroupInformationClass,
    OUT PVOID * Buffer
)

/*++

Routine Description:

    This API retrieves information on the group specified.


Parameters:

    GroupHandle - The handle of an opened group to operate on.

    GroupInformationClass - Class of information to retrieve.  The
        accesses required for each class is shown below:

        Info Level                      Required Access Type
        ----------------------          ----------------------
        GroupGeneralInformation         GROUP_READ_INFORMATION
        GroupNameInformation            GROUP_READ_INFORMATION
        GroupAttributeInformation       GROUP_READ_INFORMATION
        GroupAdminInformation           GROUP_READ_INFORMATION

    Buffer - Receives a pointer to a buffer containing the requested
        information.  When this information is no longer needed, this
        buffer must be freed using SamFreeMemory().

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.


--*/
{

    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;


    SampOutputDebugString("SamQueryInformationGroup");

    if (!SampIsValidClientHandle(GroupHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }


    //
    // Call the server ...
    //


    (*Buffer) = NULL;

    RpcTryExcept{

        NtStatus =
            SamrQueryInformationGroup(
                (SAMPR_HANDLE)RpcContextHandle,
                GroupInformationClass,
                (PSAMPR_GROUP_INFO_BUFFER *)Buffer
                );



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    if ( ((NtStatus == RPC_NT_INVALID_TAG)
      ||  (NtStatus == STATUS_INVALID_INFO_CLASS))
      && (GroupInformationClass == GroupReplicationInformation)  ) {

        //
        // GroupReplicationInformation is supported over RPC in the 
        // 5.1 release (.NET).  When calling downlevel servers, back down
        // to GroupGeneralInformation which retrieves the necessary information
        // in addition to the potentially expensive MemberCount field.
        //

        RpcTryExcept{
    
            NtStatus =
                SamrQueryInformationGroup(
                    (SAMPR_HANDLE)RpcContextHandle,
                    GroupGeneralInformation,
                    (PSAMPR_GROUP_INFO_BUFFER *)Buffer
                    );
    
        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
    
            NtStatus = I_RpcMapWin32Status(RpcExceptionCode());
    
        } RpcEndExcept;

    }


    return(SampMapCompletionStatus(NtStatus));
}



NTSTATUS
SamSetInformationGroup(
    IN SAM_HANDLE GroupHandle,
    IN GROUP_INFORMATION_CLASS GroupInformationClass,
    IN PVOID Buffer
)
/*++


Routine Description:

    This API allows the caller to modify group information.


Parameters:

    GroupHandle - The handle of an opened group to operate on.

    GroupInformationClass - Class of information to retrieve.  The
        accesses required for each class is shown below:

        Info Level                      Required Access Type
        ------------------------        -------------------------

        GroupGeneralInformation         (can't write)

        GroupNameInformation            GROUP_WRITE_ACCOUNT
        GroupAttributeInformation       GROUP_WRITE_ACCOUNT
        GroupAdminInformation           GROUP_WRITE_ACCOUNT

    Buffer - Buffer where information retrieved is placed.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_NO_SUCH_GROUP - The group specified is unknown.

    STATUS_SPECIAL_GROUP - The group specified is a special group and
        cannot be operated on in the requested fashion.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{

    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamSetInformationGroup");


    if (!SampIsValidClientHandle(GroupHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus =
            SamrSetInformationGroup(
                (SAMPR_HANDLE)RpcContextHandle,
                GroupInformationClass,
                Buffer
                );



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));
}



NTSTATUS
SamAddMemberToGroup(
    IN SAM_HANDLE GroupHandle,
    IN ULONG MemberId,
    IN ULONG Attributes
)

/*++

Routine Description:

    This API adds a member to a group.  Note that this API requires the
    GROUP_ADD_MEMBER access type for the group.


Parameters:

    GroupHandle - The handle of an opened group to operate on.

    MemberId - Relative ID of the member to add.

    Attributes - The attributes of the group assigned to the user.  The
        attributes assigned here must be compatible with the attributes
        assigned to the group as a whole.  Compatible attribute
        assignments are:

          Mandatory - If the Mandatory attribute is assigned to the
                    group as a whole, then it must be assigned to the
                    group for each member of the group.

          EnabledByDefault - This attribute may be set to any value
                    for each member of the group.  It does not matter
                    what the attribute value for the group as a whole
                    is.

          Enabled - This attribute may be set to any value for each
                    member of the group.  It does not matter what the
                    attribute value for the group as a whole is.

          Owner -   The Owner attribute may be assigned any value.
                    However, if the Owner attribute of the group as a
                    whole is not set, then the value assigned to
                    members is ignored.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_NO_SUCH_MEMBER - The member specified is unknown.

    STATUS_MEMBER_IN_GROUP - The member already belongs to the group.

    STATUS_INVALID_GROUP_ATTRIBUTES - Indicates the group attribute
        values being assigned to the member are not compatible with
        the attribute values of the group as a whole.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;


    SampOutputDebugString("SamAddMemberToGroup");

    if (!SampIsValidClientHandle(GroupHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus =
            SamrAddMemberToGroup(
                (SAMPR_HANDLE)RpcContextHandle,
                MemberId,
                Attributes
                );



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamDeleteGroup(
    IN SAM_HANDLE GroupHandle
)

/*++

Routine Description:

    This API removes a group from the account database.  There may be no
    members in the group or the deletion request will be rejected.  Note
    that this API requires DELETE access to the specific group being
    deleted.


Parameters:

    GroupHandle - The handle of an opened group to operate on.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_SPECIAL_GROUP - The group specified is a special group and
        cannot be operated on in the requested fashion.

    STATUS_MEMBER_IN_GROUP - The group still has members.  A group may
        not be deleted unless it has no members.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{

    NTSTATUS            NtStatus;
    SAMPR_HANDLE        LocalHandle;

    SampOutputDebugString("SamDeleteGroup");

    if (!SampIsValidClientHandle(GroupHandle, &LocalHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus =  SamrDeleteGroup( &LocalHandle );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    if (NT_SUCCESS(NtStatus)) {
        SampFreeHandle((SAMP_HANDLE *)&GroupHandle);
    }

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamRemoveMemberFromGroup(
    IN SAM_HANDLE GroupHandle,
    IN ULONG MemberId
)

/*++

Routine Description:

    This API removes a single member from a group.  Note that this API
    requires the GROUP_REMOVE_MEMBER access type.


Parameters:

    GroupHandle - The handle of an opened group to operate on.

    MemberId - Relative ID of the member to remove.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_SPECIAL_GROUP - The group specified is a special group and
        cannot be operated on in the requested fashion.

    STATUS_MEMBER_NOT_IN_GROUP - The specified user does not belong
        to the group.

    STATUS_MEMBERS_PRIMARY_GROUP - A user may not be removed from its
        primary group.  The primary group of the user account must first
        be changed.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamRemoveMemberFromGroup");

    if (!SampIsValidClientHandle(GroupHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus =
            SamrRemoveMemberFromGroup(
                (SAMPR_HANDLE)RpcContextHandle,
                MemberId
                );



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamGetMembersInGroup(
    IN SAM_HANDLE GroupHandle,
    OUT PULONG * MemberIds,
    OUT PULONG * Attributes,
    OUT PULONG MemberCount
)

/*++

Routine Description:

    This API lists all the members in a group.  This API requires
    GROUP_LIST_MEMBERS access to the group.


Parameters:

    GroupHandle - The handle of an opened group to operate on.

    MemberIds - Receives a pointer to a buffer containing An array of
        ULONGs.  These ULONGs contain the relative IDs of the members
        of the group.  When this information is no longer needed,
        this buffer must be freed using SamFreeMemory().

    Attributes - Receives a pointer to a buffer containing an array of
        ULONGs.  These ULONGs contain the attributes of the
        corresponding member ID returned via the MemberId paramter.

    MemberCount - number of members in the group (and, thus, the
        number relative IDs returned).

Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.

    STATUS_ACCESS_DENIED - Caller does not have privilege required to
        request that data.

    STATUS_INVALID_HANDLE - The handle passed is invalid.


--*/
{

    NTSTATUS                    NtStatus;
    PSAMPR_GET_MEMBERS_BUFFER   GetMembersBuffer;
    SAMPR_HANDLE                RpcContextHandle;


    SampOutputDebugString("SamGetMembersInGroup");

    if (!SampIsValidClientHandle(GroupHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }


    //
    // Call the server ...
    //


    GetMembersBuffer = NULL;

    RpcTryExcept{

        NtStatus =
            SamrGetMembersInGroup(
                (SAMPR_HANDLE)RpcContextHandle,
                &GetMembersBuffer
                );

        //
        // What we get back is the following:
        //
        //               +-------------+
        //     --------->| MemberCount |
        //               |-------------+                    +-------+
        //               |  Members  --|------------------->| Rid-0 |
        //               |-------------|   +------------+   |  ...  |
        //               |  Attributes-|-->| Attribute0 |   |       |
        //               +-------------+   |    ...     |   | Rid-N |
        //                                 | AttributeN |   +-------+
        //                                 +------------+
        //
        // Each block allocated with MIDL_user_allocate.  We return the
        // RID and ATTRIBUTE blocks, and free the block containing
        // the MemberCount ourselves.
        //


        if (NT_SUCCESS(NtStatus)) {
            (*MemberCount)  = GetMembersBuffer->MemberCount;
            (*MemberIds)    = GetMembersBuffer->Members;
            (*Attributes)   = GetMembersBuffer->Attributes;
            MIDL_user_free( GetMembersBuffer );
        } else {

            //
            // Deallocate any returned buffers on error
            //

            if (GetMembersBuffer != NULL) {
                if (GetMembersBuffer->Members != NULL) {
                    MIDL_user_free(GetMembersBuffer->Members);
                }
                if (GetMembersBuffer->Attributes != NULL) {
                    MIDL_user_free(GetMembersBuffer->Attributes);
                }
                MIDL_user_free(GetMembersBuffer);
            }
        }


    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));


}



NTSTATUS
SamSetMemberAttributesOfGroup(
    IN SAM_HANDLE GroupHandle,
    IN ULONG MemberId,
    IN ULONG Attributes
)

/*++

Routine Description:

    This routine modifies the group attributes of a member of the group.


Parameters:

    GroupHandle - The handle of an opened group to operate on.  This
        handle must be open for GROUP_ADD_MEMBER access to the group.

    MemberId - Contains the relative ID of member whose attributes
        are to be modified.

    Attributes - The group attributes to set for the member.  These
        attributes must not conflict with the attributes of the group
        as a whole.  See SamAddMemberToGroup() for more information
        on compatible attribute settings.

Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_NO_SUCH_USER - The user specified does not exist.

    STATUS_MEMBER_NOT_IN_GROUP - Indicates the specified relative ID
        is not a member of the group.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamSetMemberAttributesOfGroup");

    if (!SampIsValidClientHandle(GroupHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus =
            SamrSetMemberAttributesOfGroup(
                (SAMPR_HANDLE)RpcContextHandle,
                MemberId,
                Attributes
                );



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamOpenAlias(
    IN SAM_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG AliasId,
    OUT PSAM_HANDLE AliasHandle
    )

/*++

Routine Description:

    This API opens an existing Alias object.  The Alias is specified by
    a ID value that is relative to the SID of the domain.  The operations
    that will be performed on the Alias must be declared at this time.

    This call returns a handle to the newly opened Alias that may be used
    for successive operations on the Alias.  This handle may be closed
    with the SamCloseHandle API.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    DesiredAccess - Is an access mask indicating which access types are
        desired to the alias.

    AliasId - Specifies the relative ID value of the Alias to be opened.

    AliasHandle - Receives a handle referencing the newly opened Alias.
        This handle will be required in successive calls to operate on
        the Alias.

Return Values:

    STATUS_SUCCESS - The Alias was successfully opened.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.

    STATUS_NO_SUCH_ALIAS - The specified Alias does not exist.

    STATUS_INVALID_HANDLE - The domain handle passed is invalid.


--*/

{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        DomainRpcContextHandle, AliasRpcContextHandle;
    SAMP_HANDLE         SampAliasHandle;

    SampOutputDebugString("SamOpenAlias");


    if (IsBadWritePtr(AliasHandle, sizeof(SAM_HANDLE))) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!SampIsValidClientHandle(DomainHandle, &DomainRpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Prepare the new handle to return
    //
    NtStatus = SampCreateNewHandle((SAMP_HANDLE)DomainHandle,
                                   NULL,
                                   &SampAliasHandle);
    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }

    //
    // Call the server ...
    //


    RpcTryExcept{

        (*AliasHandle) = 0;

        NtStatus =
            SamrOpenAlias(
                (SAMPR_HANDLE)DomainRpcContextHandle,
                DesiredAccess,
                AliasId,
                (SAMPR_HANDLE *)&AliasRpcContextHandle
                );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    
    if (NT_SUCCESS(NtStatus)) {
        SampAliasHandle->ContextHandle = AliasRpcContextHandle;
    } else {
        SampFreeHandle(&SampAliasHandle);
    }
    *AliasHandle = SampAliasHandle;

    return(SampMapCompletionStatus(NtStatus));
}



NTSTATUS
SamQueryInformationAlias(
    IN SAM_HANDLE AliasHandle,
    IN ALIAS_INFORMATION_CLASS AliasInformationClass,
    OUT PVOID * Buffer
)

/*++

Routine Description:

    This API retrieves information on the alias specified.


Parameters:

    AliasHandle - The handle of an opened alias to operate on.

    AliasInformationClass - Class of information to retrieve.  The
        accesses required for each class is shown below:

        Info Level                      Required Access Type
        ----------------------          ----------------------
        AliasGeneralInformation         ALIAS_READ_INFORMATION
        AliasNameInformation            ALIAS_READ_INFORMATION
        AliasAdminInformation           ALIAS_READ_INFORMATION

    Buffer - Receives a pointer to a buffer containing the requested
        information.  When this information is no longer needed, this
        buffer and any memory pointed to through this buffer must be
        freed using SamFreeMemory().

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.


--*/
{

    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamQueryInformationAlias");

    if (!SampIsValidClientHandle(AliasHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }


    //
    // Call the server ...
    //


    (*Buffer) = NULL;

    RpcTryExcept{

        NtStatus =
            SamrQueryInformationAlias(
                (SAMPR_HANDLE)RpcContextHandle,
                AliasInformationClass,
                (PSAMPR_ALIAS_INFO_BUFFER *)Buffer
                );



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));
}



NTSTATUS
SamSetInformationAlias(
    IN SAM_HANDLE AliasHandle,
    IN ALIAS_INFORMATION_CLASS AliasInformationClass,
    IN PVOID Buffer
)
/*++


Routine Description:

    This API allows the caller to modify alias information.


Parameters:

    AliasHandle - The handle of an opened alias to operate on.

    AliasInformationClass - Class of information to retrieve.  The
        accesses required for each class is shown below:

        Info Level                      Required Access Type
        ------------------------        -------------------------

        AliasGeneralInformation         (can't write)

        AliasNameInformation            ALIAS_WRITE_ACCOUNT
        AliasAdminInformation           ALIAS_WRITE_ACCOUNT

    Buffer - Buffer where information retrieved is placed.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_NO_SUCH_ALIAS - The alias specified is unknown.

    STATUS_SPECIAL_ALIAS - The alias specified is a special alias and
        cannot be operated on in the requested fashion.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{

    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamSetInformationAlias");

    if (!SampIsValidClientHandle(AliasHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus =
            SamrSetInformationAlias(
                (SAMPR_HANDLE)RpcContextHandle,
                AliasInformationClass,
                Buffer
                );



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));
}



NTSTATUS
SamDeleteAlias(
    IN SAM_HANDLE AliasHandle
)

/*++

Routine Description:

    This API deletes an Alias from the account database.  The Alias does
    not have to be empty.

    Note that following this call, the AliasHandle is no longer valid.


Parameters:

    AliasHandle - The handle of an opened Alias to operate on.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        LocalHandle;

    SampOutputDebugString("SamDeleteAlias");

    if (!SampIsValidClientHandle(AliasHandle, &LocalHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus =  SamrDeleteAlias( &LocalHandle );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    if (NT_SUCCESS(NtStatus)) {
        SampFreeHandle((SAMP_HANDLE *)&AliasHandle);
    }

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamAddMemberToAlias(
    IN SAM_HANDLE AliasHandle,
    IN PSID MemberId
    )

/*++

Routine Description:

    This API adds a member to an Alias.


Parameters:

    AliasHandle - The handle of an opened Alias object to operate on.
        The handle must be open for ALIAS_ADD_MEMBER.

    MemberId - The SID of the member to add.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_MEMBER_IN_ALIAS - The member already belongs to the Alias.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the correct
        state (disabled or enabled) to perform the requested operation.
        The domain server must be enabled for this operation.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the incorrect
        role (primary or backup) to perform the requested operation.


--*/

{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamAddMemberToAlias");

    if (!SampIsValidClientHandle(AliasHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus =
            SamrAddMemberToAlias(
                (SAMPR_HANDLE)RpcContextHandle,
                MemberId
                );



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

#if DBG
    if (!NT_SUCCESS(NtStatus))
    {
        DbgPrint("SAM: SamAddMemberToAlias() failed. NtStatus 0x%x\n", NtStatus);
    }
#endif // DBG

    return(SampMapCompletionStatus(NtStatus));

}




NTSTATUS
SamRemoveMemberFromAlias(
    IN SAM_HANDLE AliasHandle,
    IN PSID MemberId
    )

/*++

Routine Description:

    This API removes a member from an Alias.


Parameters:

    AliasHandle - The handle of an opened Alias object to operate on.
        The handle must be open for ALIAS_REMOVE_MEMBER.

    MemberId - The SID of the member to remove.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_SPECIAL_ALIAS - The group specified is a special alias and
        cannot be operated on in the requested fashion.

    STATUS_MEMBER_NOT_IN_ALIAS - The specified member does not belong to
        the Alias.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the correct
        state (disabled or enabled) to perform the requested operation.
        The domain server must be enabled for this operation.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the incorrect
        role (primary or backup) to perform the requested operation.


--*/

{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamRemoveMemberFromAlias");

    if (!SampIsValidClientHandle(AliasHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus =
            SamrRemoveMemberFromAlias(
                (SAMPR_HANDLE)RpcContextHandle,
                MemberId
                );



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}




NTSTATUS
SamRemoveMemberFromForeignDomain(
    IN SAM_HANDLE DomainHandle,
    IN PSID MemberId
    )

/*++

Routine Description:

    This API removes a member from an all Aliases in the domain specified.


Parameters:

    DomainHandle - The handle of an opened domain to operate in.  All
        aliases in the domain that the member is a part of must be
        accessible by the caller with ALIAS_REMOVE_MEMBER.

    MemberId - The SID of the member to remove.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the correct
        state (disabled or enabled) to perform the requested operation.
        The domain server must be enabled for this operation.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the incorrect
        role (primary or backup) to perform the requested operation.


--*/

{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamRemoveMemberFromForeignDomain");

    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus =
            SamrRemoveMemberFromForeignDomain(
                (SAMPR_HANDLE)RpcContextHandle,
                MemberId
                );



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}




NTSTATUS
SamGetMembersInAlias(
    IN SAM_HANDLE AliasHandle,
    OUT PSID **MemberIds,
    OUT PULONG MemberCount
    )

/*++

Routine Description:

    This API lists all members in an Alias.  This API requires
    ALIAS_LIST_MEMBERS access to the Alias.


Parameters:

    AliasHandle - The handle of an opened Alias to operate on.

    MemberIds - Receives a pointer to a buffer containing an array of
        pointers to SIDs.  These SIDs are the SIDs of the members of the
        Alias.  When this information is no longer needed, this buffer
        must be freed using SamFreeMemory().

    MemberCount - number of members in the Alias (and, thus, the number
        of relative IDs returned).

Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there are
        no additional entries.

    STATUS_ACCESS_DENIED - Caller does not have privilege required to
        request that data.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

--*/

{
    NTSTATUS                    NtStatus;
    SAMPR_PSID_ARRAY            MembersBuffer;
    SAMPR_HANDLE                RpcContextHandle;

    SampOutputDebugString("SamGetMembersInAlias");

    //
    // Validate parameters
    //

    if ( !ARGUMENT_PRESENT(MemberIds) ) {
        return(STATUS_INVALID_PARAMETER_2);
    }
    if ( !ARGUMENT_PRESENT(MemberCount) ) {
        return(STATUS_INVALID_PARAMETER_3);
    }

    if (!SampIsValidClientHandle(AliasHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    RpcTryExcept{

        //
        // Prepare for failure
        //

        *MemberIds = NULL;
        *MemberCount = 0;

        //
        // Call the server ...
        //

        MembersBuffer.Sids = NULL;

        NtStatus = SamrGetMembersInAlias(
                        (SAMPR_HANDLE)RpcContextHandle,
                        &MembersBuffer
                        );

        if (NT_SUCCESS(NtStatus)) {

            //
            // Return the member list
            //

            *MemberCount = MembersBuffer.Count;
            *MemberIds = (PSID *)(MembersBuffer.Sids);

        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;



    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamAddMultipleMembersToAlias(
    IN SAM_HANDLE   AliasHandle,
    IN PSID         *MemberIds,
    IN ULONG        MemberCount
    )

/*++

Routine Description:

    This API adds the SIDs listed in MemberIds to the specified Alias.


Parameters:

    AliasHandle - The handle of an opened Alias to operate on.

    MemberIds - Points to an array of SID pointers containing MemberCount
        entries.

    MemberCount - number of members in the array.


Return Values:

    STATUS_SUCCESS - The Service completed successfully.  All of the
        listed members are now members of the alias.  However, some of
        the members may already have been members of the alias (this is
        NOT an error or warning condition).

    STATUS_ACCESS_DENIED - Caller does not have the object open for
        the required access.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_MEMBER - The member has the wrong account type.

    STATUS_INVALID_SID - The member sid is corrupted.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.
--*/

{
    NTSTATUS                    NtStatus;
    SAMPR_PSID_ARRAY            MembersBuffer;
    SAMPR_HANDLE                RpcContextHandle;

    SampOutputDebugString("SamAddMultipleMembersToAlias");

    //
    // Validate parameters
    //

    if ( !ARGUMENT_PRESENT(MemberIds) ) {
        return(STATUS_INVALID_PARAMETER_2);
    }

    if (!SampIsValidClientHandle(AliasHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    RpcTryExcept{

        //
        // Call the server ...
        //

        MembersBuffer.Count = MemberCount;
        MembersBuffer.Sids  = (PSAMPR_SID_INFORMATION)MemberIds;

        NtStatus = SamrAddMultipleMembersToAlias(
                        (SAMPR_HANDLE)RpcContextHandle,
                        &MembersBuffer
                        );


    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamRemoveMultipleMembersFromAlias(
    IN SAM_HANDLE   AliasHandle,
    IN PSID         *MemberIds,
    IN ULONG        MemberCount
    )

/*++

Routine Description:

    This API Removes the SIDs listed in MemberIds from the specified Alias.


Parameters:

    AliasHandle - The handle of an opened Alias to operate on.

    MemberIds - Points to an array of SID pointers containing MemberCount
        entries.

    MemberCount - number of members in the array.


Return Values:

    STATUS_SUCCESS - The Service completed successfully.  All of the
        listed members are now NOT members of the alias.  However, some of
        the members may already have not been members of the alias (this
        is NOT an error or warning condition).

    STATUS_ACCESS_DENIED - Caller does not have the object open for
        the required access.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

--*/

{
    NTSTATUS                    NtStatus;
    SAMPR_PSID_ARRAY            MembersBuffer;
    SAMPR_HANDLE                RpcContextHandle;

    SampOutputDebugString("SamRemoveMultipleMembersFromAlias");

    //
    // Validate parameters
    //

    if ( !ARGUMENT_PRESENT(MemberIds) ) {
        return(STATUS_INVALID_PARAMETER_2);
    }

    if (!SampIsValidClientHandle(AliasHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    RpcTryExcept{

        //
        // Call the server ...
        //

        MembersBuffer.Count = MemberCount;
        MembersBuffer.Sids  = (PSAMPR_SID_INFORMATION)MemberIds;

        NtStatus = SamrRemoveMultipleMembersFromAlias(
                        (SAMPR_HANDLE)RpcContextHandle,
                        &MembersBuffer
                        );


    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamOpenUser(
    IN SAM_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG UserId,
    OUT PSAM_HANDLE UserHandle
    )
/*++

Routine Description:

    This API opens an existing user in the account database.  The user
    is specified by SID value.  The operations that will be performed on
    the user must be declared at this time.

    This call returns a handle to the newly opened user that may be used
    for successive operations on the user.  This handle may be closed
    with the SamCloseHandle API.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    DesiredAccess - Is an access mask indicating which access types
        are desired to the user.  These access types are reconciled
        with the Discretionary Access Control list of the user to
        determine whether the accesses will be granted or denied.

    UserId - Specifies the relative ID value of the user account to
        be opened.

    UserHandle - Receives a handle referencing the newly opened User.
        This handle will be required in successive calls to operate
        on the user.

Return Values:

    STATUS_SUCCESS - The group was successfully opened.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_NO_SUCH_USER - The specified user does not exist.

    STATUS_INVALID_HANDLE - The domain handle passed is invalid.



--*/
{

    NTSTATUS            NtStatus;
    SAMPR_HANDLE        DomainRpcContextHandle, UserRpcContextHandle;
    SAMP_HANDLE         SampUserHandle;

    SampOutputDebugString("SamOpenUser");

    if (IsBadWritePtr(UserHandle, sizeof(SAM_HANDLE))) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!SampIsValidClientHandle(DomainHandle, &DomainRpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Prepare the new handle to return
    //
    NtStatus = SampCreateNewHandle((SAMP_HANDLE)DomainHandle,
                                   NULL,
                                   &SampUserHandle);
    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }

    //
    // Call the server ...
    //


    RpcTryExcept{

        (*UserHandle) = 0;

        NtStatus =
            SamrOpenUser(
                (SAMPR_HANDLE)DomainRpcContextHandle,
                DesiredAccess,
                UserId,
                (SAMPR_HANDLE *)&UserRpcContextHandle
                );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    if (NT_SUCCESS(NtStatus)) {
        SampUserHandle->ContextHandle = UserRpcContextHandle;
    } else {
        SampFreeHandle(&SampUserHandle);
    }
    *UserHandle = SampUserHandle;

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamDeleteUser(
    IN SAM_HANDLE UserHandle
)

/*++

Routine Description:

    This API deletes a user from the account database.  If the account
    being deleted is the last account in the database in the ADMIN
    group, then STATUS_LAST_ADMIN is returned, and the Delete fails.  Note
    that this API required DOMAIN_DELETE_USER access.

    Note that following this call, the UserHandle is no longer valid.


Parameters:

    UserHandle - The handle of an opened user to operate on.  The handle
        must be opened for DELETE access.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_LAST_ADMIN - Cannot delete the last administrator.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        LocalHandle;

    SampOutputDebugString("SamDeleteUser");

    if (!SampIsValidClientHandle(UserHandle, &LocalHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus =  SamrDeleteUser( &LocalHandle );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    if (NT_SUCCESS(NtStatus)) {
        SampFreeHandle((SAMP_HANDLE *)&UserHandle);
    }

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamQueryInformationUser(
    IN SAM_HANDLE UserHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    OUT PVOID * Buffer
)

/*++


Routine Description:

    This API looks up some level of information about a particular user.


Parameters:

    UserHandle - The handle of an opened user to operate on.

    UserInformationClass - Class of information desired about this
        user.  The accesses required for each class is shown below:

        Info Level                      Required Access Type
        ----------------------          --------------------------

        UserGeneralInformation          USER_READ_GENERAL
        UserPreferencesInformation      USER_READ_PREFERENCES
        UserLogonInformation            USER_READ_GENERAL and
                                        USER_READ_PREFERENCES and
                                        USER_READ_LOGON

        UserLogonHoursInformation       USER_READ_LOGON

        UserAccountInformation          USER_READ_GENERAL and
                                        USER_READ_PREFERENCES and
                                        USER_READ_LOGON and
                                        USER_READ_ACCOUNT

        UserParametersInformation       USER_READ_ACCOUNT

        UserNameInformation             USER_READ_GENERAL
        UserAccountNameInformation      USER_READ_GENERAL
        UserFullNameInformation         USER_READ_GENERAL
        UserPrimaryGroupInformation     USER_READ_GENERAL
        UserHomeInformation             USER_READ_LOGON
        UserScriptInformation           USER_READ_LOGON
        UserProfileInformation          USER_READ_LOGON
        UserAdminCommentInformation     USER_READ_GENERAL
        UserWorkStationsInformation     USER_READ_LOGON

        UserSetPasswordInformation      (Can't query)

        UserControlInformation          USER_READ_ACCOUNT
        UserExpiresInformation          USER_READ_ACCOUNT

        UserInternal1Information        (trusted client use only)
        UserInternal2Information        (trusted client use only)

        UserAllInformation              Will return fields that user
                                        has access to.

    Buffer - Receives a pointer to a buffer containing the requested
        information.  When this information is no longer needed, this
        buffer must be freed using SamFreeMemory().


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.


--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamQueryInformationUser");


    if (!SampIsValidClientHandle(UserHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //


    (*Buffer) = NULL;

    RpcTryExcept{

        NtStatus =
            SamrQueryInformationUser(
                (SAMPR_HANDLE)RpcContextHandle,
                UserInformationClass,
                (PSAMPR_USER_INFO_BUFFER *)Buffer
                );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SampOwfPassword(
    IN SAMPR_HANDLE RpcContextHandle,
    IN PUNICODE_STRING UnicodePassword,
    IN BOOLEAN IgnorePasswordRestrictions,
    OUT PBOOLEAN NtPasswordPresent,
    OUT PNT_OWF_PASSWORD NtOwfPassword,
    OUT PBOOLEAN LmPasswordPresent,
    OUT PLM_OWF_PASSWORD LmOwfPassword
)

/*++

Routine Description:

    This routine takes a cleartext unicode NT password from the user,
    makes sure it meets our high standards for password quality,
    converts it to an LM password if possible, and runs both passwords
    through a one-way function (OWF).

Parameters:

    RpcContextHandle - The handle of an opened user to operate on.

    UnicodePassword - the cleartext unicode NT password.

    IgnorePasswordRestrictions - When TRUE, indicates that the password
        should be accepted as legitimate regardless of what the domain's
        password restrictions indicate (e.g., can be less than
        required password length).  This is expected to be used when
        setting up a new machine account.

    NtPasswordPresent - receives a boolean that says whether the NT
        password is present or not.

    NtOwfPassword - receives the OWF'd version of the NT password.

    LmPasswordPresent - receives a boolean that says whether the LM
        password is present or not.

    LmOwfPassword - receives the OWF'd version of the LM password.


Return Values:

    STATUS_SUCCESS - the service has completed.  The booleans say which
        of the OWFs are valid.

    Errors are returned by SampCheckPasswordRestrictions(),
    RtlCalculateNtOwfPassword(), SampCalculateLmPassword(), and
    RtlCalculateLmOwfPassword().

--*/
{
    NTSTATUS            NtStatus;
    PCHAR               LmPasswordBuffer;
    BOOLEAN             UseOwfPasswords;

    //
    // We ignore the UseOwfPasswords flag since we already are.
    //

    if (IgnorePasswordRestrictions) {
        NtStatus = STATUS_SUCCESS;
    } else {
        NtStatus = SampCheckPasswordRestrictions(
                       RpcContextHandle,
                       UnicodePassword,
                       &UseOwfPasswords
                       );
    }

    //
    // Compute the NT One-Way-Function of the password
    //

    if ( NT_SUCCESS( NtStatus ) ) {

        *NtPasswordPresent = TRUE;

        NtStatus = RtlCalculateNtOwfPassword(
                    UnicodePassword,
                    NtOwfPassword
                    );

        if ( NT_SUCCESS( NtStatus ) ) {

            //
            // Calculate the LM version of the password
            //

            NtStatus = SampCalculateLmPassword(
                        UnicodePassword,
                        &LmPasswordBuffer);

            if (NT_SUCCESS(NtStatus)) {

                //
                // Compute the One-Way-Function of the LM password
                //

                *LmPasswordPresent = TRUE;

                NtStatus = RtlCalculateLmOwfPassword(
                                LmPasswordBuffer,
                                LmOwfPassword);

                //
                // We're finished with the LM password
                //

                MIDL_user_free(LmPasswordBuffer);
            }
        }
    }

    return( NtStatus );
}




NTSTATUS
SampEncryptClearPasswordNew(
    IN SAMPR_HANDLE RpcContextHandle,
    IN PUNICODE_STRING UnicodePassword,
    OUT PSAMPR_ENCRYPTED_USER_PASSWORD_NEW EncryptedUserPassword
)

/*++

Routine Description:

    This routine takes a cleartext unicode NT password from the user,
    and encrypts it with the session key.

    Note: The encryption algorithm changed since Win2K Service Pack 2.

    Prior to Win2000 SP2:
        
        Clear password is encrypted by session key directly.

        This exposes the problem, which clear text password can be cracked
        by examining two network frames and apply certain encryption 
        algorithm. Refer to WinSE Bug 9254 / 9587 for more details. 

    The Fix:
    
        Apply MD5 hash on a random bit stream, then use Session key to hash 
        it again, then use the hash result to encrypt clear text password. 

    Client Side:
    
        NT4, Windows 2000 client without this fix will continue to use the old
        encryption method with Information Level - UserInternal4Information or 
        UserInternal5Information. 

        NT4 with this fix, Windows 2000 SP2 and above, (Whistler) will have 
        this fix and using UserInternal4InformationNew and 
        UserInternal5InformationNew. 
    
    The server side:

        Without the fix, server side will continue to use the old encryption 
        method.
        
        With the fix, server side will check UserInformationClass to determine
        which decryption method to use.  
        
Parameters:

    RpcContextHandle - SAM_HANDLE used to acquiring a session key.

    UnicodePassword - the cleartext unicode NT password.

    EncryptedUserPassword - receives the encrypted cleartext password.

Return Values:

    STATUS_SUCCESS - the service has completed.  The booleans say which
        of the OWFs are valid.


--*/
{
    NTSTATUS             NtStatus;
    USER_SESSION_KEY     UserSessionKey;
    struct RC4_KEYSTRUCT Rc4Key;
    PSAMPR_USER_PASSWORD_NEW UserPassword = (PSAMPR_USER_PASSWORD_NEW) EncryptedUserPassword;
    MD5_CTX              Md5Context;


    if (UnicodePassword->Length > SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) {
        return(STATUS_PASSWORD_RESTRICTION);
    }

    NtStatus = RtlGetUserSessionKeyClient(
                   (RPC_BINDING_HANDLE)RpcContextHandle,
                   &UserSessionKey
                   );

    if (NT_SUCCESS(NtStatus))
    {
        RtlCopyMemory(
            ((PCHAR) UserPassword->Buffer) +
                (SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                UnicodePassword->Length,
            UnicodePassword->Buffer,
            UnicodePassword->Length
            );
        UserPassword->Length = UnicodePassword->Length;

        NtStatus = SampRandomFill(
                    (SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                        UnicodePassword->Length,
                    (PUCHAR) UserPassword->Buffer
                    );
    }

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = SampRandomFill(
                    (SAM_PASSWORD_ENCRYPTION_SALT_LEN),
                    (PUCHAR) UserPassword->ClearSalt
                    );
    }

    if (NT_SUCCESS(NtStatus))
    {

        MD5Init(&Md5Context); 

        MD5Update(&Md5Context,
                  (PUCHAR) UserPassword->ClearSalt, 
                  SAM_PASSWORD_ENCRYPTION_SALT_LEN
                  );

        MD5Update(&Md5Context,
                  (PUCHAR) &UserSessionKey,
                  sizeof(UserSessionKey)
                  );

        MD5Final(&Md5Context);

        //
        // Convert the MD5 Hash into an RC4 key
        //

        rc4_key(
            &Rc4Key,
            MD5DIGESTLEN,
            Md5Context.digest
            );

        rc4(&Rc4Key,
            sizeof(SAMPR_ENCRYPTED_USER_PASSWORD_NEW) - SAM_PASSWORD_ENCRYPTION_SALT_LEN,
            (PUCHAR) UserPassword
            );

    }

    return( NtStatus );
}



NTSTATUS
SampEncryptClearPassword(
    IN SAMPR_HANDLE RpcContextHandle,
    IN PUNICODE_STRING UnicodePassword,
    OUT PSAMPR_ENCRYPTED_USER_PASSWORD EncryptedUserPassword
)

/*++

Routine Description:

    This routine takes a cleartext unicode NT password from the user,
    and encrypts it with the session key.

Parameters:

    RpcContextHandle - SAM_HANDLE used to acquiring a session key.

    UnicodePassword - the cleartext unicode NT password.

    EncryptedUserPassword - receives the encrypted cleartext password.

Return Values:

    STATUS_SUCCESS - the service has completed.  The booleans say which
        of the OWFs are valid.


--*/
{
    NTSTATUS             NtStatus;
    USER_SESSION_KEY     UserSessionKey;
    struct RC4_KEYSTRUCT Rc4Key;
    PSAMPR_USER_PASSWORD UserPassword = (PSAMPR_USER_PASSWORD) EncryptedUserPassword;

    if (UnicodePassword->Length > SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) {
        return(STATUS_PASSWORD_RESTRICTION);
    }

    NtStatus = RtlGetUserSessionKeyClient(
                   (RPC_BINDING_HANDLE)RpcContextHandle,
                   &UserSessionKey
                   );

    //
    // Convert the session key into an RC4 key
    //

    if (NT_SUCCESS(NtStatus)) {

        rc4_key(
            &Rc4Key,
            sizeof(USER_SESSION_KEY),
            (PUCHAR) &UserSessionKey
            );

        RtlCopyMemory(
            ((PCHAR) UserPassword->Buffer) +
                (SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                UnicodePassword->Length,
            UnicodePassword->Buffer,
            UnicodePassword->Length
            );
        UserPassword->Length = UnicodePassword->Length;

        NtStatus = SampRandomFill(
                    (SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                        UnicodePassword->Length,
                    (PUCHAR) UserPassword->Buffer
                    );

        if (NT_SUCCESS(NtStatus)) {
            rc4(
                &Rc4Key,
                sizeof(SAMPR_ENCRYPTED_USER_PASSWORD),
                (PUCHAR) UserPassword
                );

        }


    }


    return( NtStatus );
}






NTSTATUS
SampEncryptOwfs(
    IN SAMPR_HANDLE RpcContextHandle,
    IN BOOLEAN NtPasswordPresent,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN BOOLEAN LmPasswordPresent,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
)

/*++

Routine Description:

    This routine takes NT and LM passwords that have already been OWF'd,
    and encrypts them so that they can be safely sent to the server.


Parameters:

    RpcContextHandle - The handle of an opened user to operate on.

    NtPasswordPresent - indicates whether NtOwfPassword is valid or not.

    NtOwfPassword - an OWF'd NT password, if NtPasswordPresent is true.

    EncryptedNtOwfPassword - an encrypted version of the OWF'd NT password
        that can be safely sent to the server.

    LmPasswordPresent - indicates whether LmOwfPassword is valid or not.

    LmOwfPassword - an OWF'd LM password, if LmPasswordPresent is true.

    EncryptedLmOwfPassword - an encrypted version of the OWF'd LM password
        that can be safely sent to the server.

Return Values:

    STATUS_SUCCESS - the passwords were encrypted and may be sent to the
        server.

    Errors may be returned by RtlGetUserSessionKeyClient(),
    RtlEncryptNtOwfPwdWithUserKey(), and RtlEncryptLmOwfPwdWithUserKey().

--*/
{
    NTSTATUS            NtStatus;
    USER_SESSION_KEY    UserSessionKey;


    NtStatus = RtlGetUserSessionKeyClient(
                   (RPC_BINDING_HANDLE)RpcContextHandle,
                   &UserSessionKey
                   );

    if ( NT_SUCCESS( NtStatus ) ) {

        if (NtPasswordPresent) {

            //
            // Encrypt the Nt OWF Password with the user session key
            // and store it the buffer to send
            //

            NtStatus = RtlEncryptNtOwfPwdWithUserKey(
                           NtOwfPassword,
                           &UserSessionKey,
                           EncryptedNtOwfPassword
                           );
        }


        if ( NT_SUCCESS( NtStatus ) ) {

            if (LmPasswordPresent) {

                //
                // Encrypt the Lm OWF Password with the user session key
                // and store it the buffer to send
                //

                NtStatus = RtlEncryptLmOwfPwdWithUserKey(
                               LmOwfPassword,
                               &UserSessionKey,
                               EncryptedLmOwfPassword
                               );
            }
        }
    }

    return( NtStatus );
}



NTSTATUS
SampSetInfoUserUseOldInfoClass(
    IN SAMPR_HANDLE RpcContextHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    IN PVOID Buffer,
    IN PUNICODE_STRING  pClearPassword
    )
/*++

Routine Description:

    This routine reverts password encryption to old algorithm with old
    UserInformationClass, so that new Client (with the patch) can talk
    to the old server (without fix). 

Parameters:

    RpcContextHandle - SAM Handle
    
    UserInformationClass - Indicates Information Level, 
    
    BufferToPass - User attribute to set, including password
    
    pClearPassword - Pointer to clear text password.

Return Value:

    STATUS_SUCCESS - success
    error code 

--*/

{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    SAMPR_USER_INTERNAL4_INFORMATION Internal4RpcBuffer;
    SAMPR_USER_INTERNAL5_INFORMATION Internal5RpcBuffer;
    USER_INFORMATION_CLASS  ClassToUse;
    PVOID                   BufferToPass = NULL; 

    if (UserInternal4InformationNew == UserInformationClass)
    {
        ClassToUse = UserInternal4Information;

        Internal4RpcBuffer.I1 = ((PSAMPR_USER_INTERNAL4_INFORMATION_NEW)Buffer)->I1;

        BufferToPass = &Internal4RpcBuffer;

        NtStatus = SampEncryptClearPassword(
                            RpcContextHandle,
                            pClearPassword,
                            &Internal4RpcBuffer.UserPassword
                            );

        RtlZeroMemory(
                &Internal4RpcBuffer.I1.NtOwfPassword, 
                sizeof(UNICODE_STRING)
                );

    }
    else if (UserInternal5InformationNew == UserInformationClass)
    {
        ClassToUse = UserInternal5Information;

        Internal5RpcBuffer.PasswordExpired =
                ((PSAMPR_USER_INTERNAL5_INFORMATION_NEW)Buffer)->PasswordExpired;

        BufferToPass = &Internal5RpcBuffer;

        NtStatus = SampEncryptClearPassword(
                            RpcContextHandle,
                            pClearPassword,
                            &Internal5RpcBuffer.UserPassword
                            );
    }
    else
    {
        NtStatus = STATUS_INTERNAL_ERROR;
    }

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = SamrSetInformationUser2(
                        (SAMPR_HANDLE)RpcContextHandle,
                        ClassToUse,
                        BufferToPass
                        );
    }

    return( NtStatus );
}



NTSTATUS
SamSetInformationUser(
    IN SAM_HANDLE UserHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    IN PVOID Buffer
)

/*++


Routine Description:

    This API modifies information in a user record.  The data modified
    is determined by the UserInformationClass parameter.  To change
    information here requires access to the user object defined above.
    Each structure has both a read and write access type associated with
    it.  In general, a user may call GetInformation with class
    UserLogonInformation, but may only call SetInformation with class
    UserPreferencesInformation.  Access type USER_WRITE_ACCOUNT allows
    changes to be made to all fields.

    NOTE: If the password is set to a new password then the password-
    set timestamp is reset as well.


Parameters:

    UserHandle - The handle of an opened user to operate on.

    UserInformationClass - Class of information provided.  The
        accesses required for each class is shown below:

        Info Level                      Required Access Type
        -----------------------         ------------------------
        UserGeneralInformation          (Can't set)

        UserPreferencesInformation      USER_WRITE_PREFERENCES

        UserParametersInformation       USER_WRITE_ACCOUNT

        UserLogonInformation            (Can't set)

        UserLogonHoursInformation       USER_WRITE_ACCOUNT

        UserAccountInformation          (Can't set)

        UserNameInformation             USER_WRITE_ACCOUNT
        UserAccountNameInformation      USER_WRITE_ACCOUNT
        UserFullNameInformation         USER_WRITE_ACCOUNT
        UserPrimaryGroupInformation     USER_WRITE_ACCOUNT
        UserHomeInformation             USER_WRITE_ACCOUNT
        UserScriptInformation           USER_WRITE_ACCOUNT
        UserProfileInformation          USER_WRITE_ACCOUNT
        UserAdminCommentInformation     USER_WRITE_ACCOUNT
        UserWorkStationsInformation     USER_WRITE_ACCOUNT
        UserSetPasswordInformation      USER_FORCE_PASSWORD_CHANGE (also see note below)
        UserControlInformation          USER_WRITE_ACCOUNT
        UserExpiresInformation          USER_WRITE_ACCOUNT
        UserInternal1Information        USER_FORCE_PASSWORD_CHANGE (also see note below)
        UserInternal2Information        (trusted client use only)
        UserAllInformation              Will set fields that user
                                        specifies, if accesses are
                                        held as described above.


        NOTE: When setting a password (with either
              UserSetPasswordInformation or UserInternal1Information),
              you MUST open the user account via a DomainHandle that
              was opened for DOMAIN_READ_PASSWORD_PARAMETERS.

    Buffer - Buffer containing a user info struct.





Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    SAMPR_USER_INTERNAL1_INFORMATION Internal1RpcBuffer;
    USER_INTERNAL1_INFORMATION       Internal1Buffer;
    SAMPR_USER_INTERNAL4_INFORMATION_NEW Internal4RpcBufferNew;
    SAMPR_USER_INTERNAL5_INFORMATION_NEW Internal5RpcBufferNew;
    PVOID                            BufferToPass;
    PUSER_ALL_INFORMATION            UserAll;
    USER_ALL_INFORMATION             LocalAll;
    NTSTATUS                         NtStatus = STATUS_SUCCESS;
    BOOLEAN                          IgnorePasswordRestrictions;
    ULONG                            Pass = 0;
    USER_INFORMATION_CLASS           ClassToUse = UserInformationClass;
    BOOLEAN                          SendOwfs = FALSE;
    SAMPR_HANDLE                     RpcContextHandle;
    PUNICODE_STRING                  pClearPassword = NULL;

    SampOutputDebugString("SamSetInformationUser");

    if (!SampIsValidClientHandle(UserHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    do
    {

        RpcTryExcept{

            //
            // Normally just pass the info buffer through to rpc
            //

            BufferToPass = Buffer;


            //
            // Deal with special cases
            //

            switch (UserInformationClass) {


            case UserPreferencesInformation: {

                //
                // Field is unused, but make sure RPC doesn't choke on it.
                //

                ((PUSER_PREFERENCES_INFORMATION)(Buffer))->Reserved1.Length = 0;
                ((PUSER_PREFERENCES_INFORMATION)(Buffer))->Reserved1.MaximumLength = 0;
                ((PUSER_PREFERENCES_INFORMATION)(Buffer))->Reserved1.Buffer = NULL;

                break;
            }

            case UserSetPasswordInformation:

                if (Pass == 0) {

                    //
                    // On the zeroth pass try sending a UserInternal5 structure.
                    // This is only available on 3.51 and above releases.
                    //

                    //
                    // Check password restrictions.
                    //

                    NtStatus = SampCheckPasswordRestrictions(
                                    RpcContextHandle,
                                    &((PUSER_SET_PASSWORD_INFORMATION)(Buffer))->Password,
                                    &SendOwfs
                                    );

                    //
                    // If password restrictions told us we could send reversibly
                    // encrypted passwords, compute them. Otherwise drop through
                    // to the OWF case.
                    //

                    if (!SendOwfs) {

                        //
                        // Encrypt the cleatext password - we don't need to
                        // restrictions because that can be done on the server.
                        //

                        NtStatus = SampEncryptClearPasswordNew(
                                        RpcContextHandle,
                                        &((PUSER_SET_PASSWORD_INFORMATION)(Buffer))->Password,
                                        &Internal5RpcBufferNew.UserPassword
                                        );

                        if (!NT_SUCCESS(NtStatus)) {
                            break;
                        }

                        pClearPassword = &((PUSER_SET_PASSWORD_INFORMATION)(Buffer))->Password; 

                        Internal5RpcBufferNew.PasswordExpired =
                            ((PUSER_SET_PASSWORD_INFORMATION)(Buffer))->PasswordExpired;


                        //
                        // Set the class and buffer to send over.
                        //

                        ClassToUse = UserInternal5InformationNew;
                        BufferToPass = &Internal5RpcBufferNew;
                        break;

                    }

                } else {

                    //
                    // Set the pass counter to one since we aren't trying a new
                    // interface and don't want to retry.
                    //

                    Pass = 1;
                    SendOwfs = TRUE;
                }

                ASSERT(SendOwfs);

                //
                // We're going to calculate the OWFs for the password and
                // turn this into an INTERNAL1 set info request by dropping
                // through to the INTERNAL1 code with Buffer pointing at our
                // local INTERNAL1 buffer.  First, make sure that the password
                // meets our quality requirements.
                //

                NtStatus = SampOwfPassword(
                               RpcContextHandle,
                               &((PUSER_SET_PASSWORD_INFORMATION)(Buffer))->Password,
                               FALSE,      // Don't ignore password restrictions
                               &Internal1Buffer.NtPasswordPresent,
                               &Internal1Buffer.NtOwfPassword,
                               &Internal1Buffer.LmPasswordPresent,
                               &Internal1Buffer.LmOwfPassword
                               );

                if (!NT_SUCCESS(NtStatus)) {
                    break;
                }


                //
                // Copy the PasswordExpired flag
                //

                Internal1Buffer.PasswordExpired =
                    ((PUSER_SET_PASSWORD_INFORMATION)(Buffer))->PasswordExpired;


                //
                // We now have a USER_INTERNAL1_INFO buffer in Internal1Buffer.
                // Point Buffer at Internal1buffer and drop through to the code
                // that handles INTERNAL1 requests

                Buffer = &Internal1Buffer;
                ClassToUse = UserInternal1Information;

                //
                // drop through.....
                //


            case UserInternal1Information:


                //
                // We're going to pass a different data structure to rpc
                //

                BufferToPass = &Internal1RpcBuffer;


                //
                // Copy the password present flags
                //

                Internal1RpcBuffer.NtPasswordPresent =
                    ((PUSER_INTERNAL1_INFORMATION)Buffer)->NtPasswordPresent;

                Internal1RpcBuffer.LmPasswordPresent =
                    ((PUSER_INTERNAL1_INFORMATION)Buffer)->LmPasswordPresent;


                //
                // Copy the PasswordExpired flag
                //

                Internal1RpcBuffer.PasswordExpired =
                    ((PUSER_INTERNAL1_INFORMATION)Buffer)->PasswordExpired;


                //
                // Encrypt the OWFs with the user session key before we send
                // them over the Rpc link
                //

                NtStatus = SampEncryptOwfs(
                               RpcContextHandle,
                               Internal1RpcBuffer.NtPasswordPresent,
                               &((PUSER_INTERNAL1_INFORMATION)Buffer)->NtOwfPassword,
                               &Internal1RpcBuffer.EncryptedNtOwfPassword,
                               Internal1RpcBuffer.LmPasswordPresent,
                               &((PUSER_INTERNAL1_INFORMATION)Buffer)->LmOwfPassword,
                               &Internal1RpcBuffer.EncryptedLmOwfPassword
                               );

                break;



            case UserAllInformation:

                UserAll = (PUSER_ALL_INFORMATION)Buffer;

                //
                // If the caller is passing passwords we need to convert them
                // into OWFs and encrypt them.
                //

                if (UserAll->WhichFields & (USER_ALL_LMPASSWORDPRESENT |
                                            USER_ALL_NTPASSWORDPRESENT) ) {

                    //
                    // We'll need a private copy of the buffer which we can edit
                    // and then send over RPC.
                    //




                    if (UserAll->WhichFields & USER_ALL_OWFPASSWORD) {

                        LocalAll = *UserAll;
                        BufferToPass = &LocalAll;
                        SendOwfs = TRUE;

                        //
                        // The caller is passing OWFS directly
                        // Check they're valid and copy them into the
                        // Internal1Buffer in preparation for encryption.
                        //

                        if (LocalAll.WhichFields & USER_ALL_NTPASSWORDPRESENT) {

                            if (LocalAll.NtPasswordPresent) {

                                if (LocalAll.NtPassword.Length != NT_OWF_PASSWORD_LENGTH) {
                                    NtStatus = STATUS_INVALID_PARAMETER;
                                } else {
                                    Internal1Buffer.NtOwfPassword =
                                      *((PNT_OWF_PASSWORD)LocalAll.NtPassword.Buffer);
                                }

                            } else {
                                LocalAll.NtPasswordPresent = FALSE;
                            }
                        }

                        if (LocalAll.WhichFields & USER_ALL_LMPASSWORDPRESENT) {

                            if (LocalAll.LmPasswordPresent) {

                                if (LocalAll.LmPassword.Length != LM_OWF_PASSWORD_LENGTH) {
                                    NtStatus = STATUS_INVALID_PARAMETER;
                                } else {
                                    Internal1Buffer.LmOwfPassword =
                                      *((PNT_OWF_PASSWORD)LocalAll.LmPassword.Buffer);
                                }

                            } else {
                                LocalAll.LmPasswordPresent = FALSE;
                            }
                        }


                        //
                        // Always remove the OWF_PASSWORDS flag. This is used
                        // only on the client side to determine the mode
                        // of password input and will be rejected by the server
                        //

                        LocalAll.WhichFields &= ~USER_ALL_OWFPASSWORD;



                    } else {



                        //
                        // The caller is passing text passwords.
                        // Check for validity and convert to OWFs.
                        //

                        if (UserAll->WhichFields & USER_ALL_LMPASSWORDPRESENT) {

                            //
                            // User clients are only allowed to put a unicode string
                            // in the NT password. We always calculate the LM password
                            //

                            NtStatus = STATUS_INVALID_PARAMETER;

                        } else {

                            //
                            // The caller might be simultaneously setting
                            // the password and changing the account to be
                            // a machine or trust account.  In this case,
                            // we don't validate the password (e.g., length).
                            //

                            IgnorePasswordRestrictions = FALSE;
                            if (UserAll->WhichFields &
                                USER_ALL_USERACCOUNTCONTROL) {
                                if (UserAll->UserAccountControl &
                                    (USER_WORKSTATION_TRUST_ACCOUNT | USER_SERVER_TRUST_ACCOUNT)
                                   ) {
                                    IgnorePasswordRestrictions = TRUE;
                                }
                            }


                            SendOwfs = TRUE;
                            if (Pass == 0) {

                                //
                                // On the first pass, try sending the cleatext
                                // password.
                                //

                                Internal4RpcBufferNew.I1 = *(PSAMPR_USER_ALL_INFORMATION)
                                                            UserAll;

                                BufferToPass = &Internal4RpcBufferNew;
                                ClassToUse = UserInternal4InformationNew;
                                SendOwfs = FALSE;

                                //
                                // Check the password restrictions.  We also
                                // want to get the information on whether
                                // we can send reversibly encrypted passwords.
                                //

                                NtStatus = SampCheckPasswordRestrictions(
                                                RpcContextHandle,
                                                &UserAll->NtPassword,
                                                &SendOwfs
                                                );

                                if (IgnorePasswordRestrictions) {
                                    NtStatus = STATUS_SUCCESS;
                                }

                                if (!SendOwfs) {
                                    //
                                    // Encrypt the clear password
                                    //

                                    NtStatus = SampEncryptClearPasswordNew(
                                                    RpcContextHandle,
                                                    &UserAll->NtPassword,
                                                    &Internal4RpcBufferNew.UserPassword
                                                    );
                                    if (!NT_SUCCESS(NtStatus)) {
                                        break;
                                    }

                                    pClearPassword = &UserAll->NtPassword;

                                    //
                                    // Zero the password NT password
                                    //

                                    RtlZeroMemory(
                                        &Internal4RpcBufferNew.I1.NtOwfPassword,
                                        sizeof(UNICODE_STRING)
                                        );

                                }
                            }

                            if (SendOwfs) {


                                //
                                // On the second pass, do the normal thing.
                                //

                                LocalAll = *UserAll;
                                BufferToPass = &LocalAll;
                                SendOwfs = TRUE;

                                ClassToUse = UserAllInformation;
                                if ( LocalAll.WhichFields & USER_ALL_NTPASSWORDPRESENT ) {

                                    //
                                    // The user specified a password.  We must validate
                                    // it, convert it to LM, and calculate the OWFs
                                    //

                                    LocalAll.WhichFields |= USER_ALL_LMPASSWORDPRESENT;


                                    //
                                    // Stick the OWFs in the Internal1Buffer - just
                                    // until we use them in the SampEncryptOwfs().
                                    //

                                    NtStatus = SampOwfPassword(
                                                   RpcContextHandle,
                                                   &LocalAll.NtPassword,
                                                   IgnorePasswordRestrictions,
                                                   &LocalAll.NtPasswordPresent,
                                                   &(Internal1Buffer.NtOwfPassword),
                                                   &LocalAll.LmPasswordPresent,
                                                   &(Internal1Buffer.LmOwfPassword)
                                                   );
                                }
                            }

                        }
                    }




                    //
                    // We now have one or more OWFs in Internal1 buffer.
                    // We got these either directly or we calculated them
                    // from the text strings.
                    // Encrypt these OWFs with the session key and
                    // store the result in Internal1RpcBuffer.
                    //
                    // Note the Password present flags are in LocalAll.
                    // (The ones in Internal1Buffer are not used.)
                    //

                    if ( NT_SUCCESS( NtStatus ) && SendOwfs ) {

                        //
                        // Make all LocalAll's password strings point to
                        // the buffers in Internal1RpcBuffer
                        //

                        LocalAll.NtPassword.Length =
                            sizeof( ENCRYPTED_NT_OWF_PASSWORD );
                        LocalAll.NtPassword.MaximumLength =
                            sizeof( ENCRYPTED_NT_OWF_PASSWORD );
                        LocalAll.NtPassword.Buffer = (PWSTR)
                            &Internal1RpcBuffer.EncryptedNtOwfPassword;

                        LocalAll.LmPassword.Length =
                            sizeof( ENCRYPTED_LM_OWF_PASSWORD );
                        LocalAll.LmPassword.MaximumLength =
                            sizeof( ENCRYPTED_LM_OWF_PASSWORD );
                        LocalAll.LmPassword.Buffer = (PWSTR)
                            &Internal1RpcBuffer.EncryptedLmOwfPassword;

                        //
                        // Encrypt the Owfs
                        //

                        NtStatus = SampEncryptOwfs(
                                       RpcContextHandle,
                                       LocalAll.NtPasswordPresent,
                                       &Internal1Buffer.NtOwfPassword,
                                       &Internal1RpcBuffer.EncryptedNtOwfPassword,
                                       LocalAll.LmPasswordPresent,
                                       &Internal1Buffer.LmOwfPassword,
                                       &Internal1RpcBuffer.EncryptedLmOwfPassword
                                       );
                    }
                }

                break;

            default:

                break;

            } // switch




            //
            // Call the server ...
            //

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // If we are trying one of the new info levels, use the new
                // api.
                //

                if ((ClassToUse == UserInternal4InformationNew) ||
                     (ClassToUse == UserInternal5InformationNew)) {

                    RpcTryExcept{

                        NtStatus =
                            SamrSetInformationUser2(
                                (SAMPR_HANDLE)RpcContextHandle,
                                ClassToUse,
                                BufferToPass
                                );
                        
                    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                          NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

                    } RpcEndExcept;

                    if ((RPC_NT_INVALID_TAG == NtStatus) ||
                        (STATUS_INVALID_INFO_CLASS == NtStatus))
                    {
                        NtStatus = SampSetInfoUserUseOldInfoClass(
                                        RpcContextHandle,
                                        ClassToUse,
                                        BufferToPass,
                                        pClearPassword
                                        );
                    }

                } else {
                    NtStatus =
                        SamrSetInformationUser(
                            (SAMPR_HANDLE)RpcContextHandle,
                            ClassToUse,
                            BufferToPass
                            );
                }
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

        } RpcEndExcept;

        Pass++;

        //
        // If this is the first pass and the status indicated that the
        // server did not support the info class or the api
        // and we were trying one of the new info levels, try again.
        //

    } while ( (Pass < 2) &&
              ((NtStatus == RPC_NT_INVALID_TAG) ||
               (NtStatus == RPC_NT_UNKNOWN_IF) ||
               (NtStatus == RPC_NT_PROCNUM_OUT_OF_RANGE)));

    return(SampMapCompletionStatus(NtStatus));

}





NTSTATUS
SamiLmChangePasswordUser(
    IN SAM_HANDLE UserHandle,
    IN PENCRYPTED_LM_OWF_PASSWORD LmOldEncryptedWithLmNew,
    IN PENCRYPTED_LM_OWF_PASSWORD LmNewEncryptedWithLmOld
)

/*++


Routine Description:

    Changes the password of a user account. This routine is intended to be
    called by down-level system clients who have only the cross-encrypted
    LM passwords available to them.
    Password will be set to NewPassword only if OldPassword matches the
    current user password for this user and the NewPassword is not the
    same as the domain password parameter PasswordHistoryLength
    passwords.  This call allows users to change their own password if
    they have access USER_CHANGE_PASSWORD.  Password update restrictions
    apply.

    This api will fail unless UAS Compatibility is enabled for the domain.


Parameters:

    UserHandle - The handle of an opened user to operate on.

    LmOldEncryptedWithLmNew - the OWF of the old LM password encrypted using
                 the OWF of the new LM password as a key.

    LmNewEncryptedWithLmOld - the OWF of the new LM password encrypted using
                 the OWF of the old LM password as a key.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - The old password is incorrect.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    //
    // Check parameter validity
    //

    if (LmOldEncryptedWithLmNew == NULL) {
        return(STATUS_INVALID_PARAMETER_1);
    }
    if (LmNewEncryptedWithLmOld == NULL) {
        return(STATUS_INVALID_PARAMETER_2);
    }

    if (!SampIsValidClientHandle(UserHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus = SamrChangePasswordUser(
                            (SAMPR_HANDLE)RpcContextHandle,

                            TRUE,   // LmOldPresent
                            LmOldEncryptedWithLmNew,
                            LmNewEncryptedWithLmOld,

                            FALSE,  // NtPresent
                            NULL,   // NtOldEncryptedWithNtNew
                            NULL,   // NtNewEncryptedWithNtOld

                            FALSE,  // NtCrossEncryptionPresent
                            NULL,

                            FALSE,  // LmCrossEncryptionPresent
                            NULL

                            );

        //
        // We should never get asked for cross-encrypted data
        // since the server knows we don't have any NT data.
        //

        ASSERT (NtStatus != STATUS_NT_CROSS_ENCRYPTION_REQUIRED);
        ASSERT (NtStatus != STATUS_LM_CROSS_ENCRYPTION_REQUIRED);


    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}





NTSTATUS
SamiChangePasswordUser(
    IN SAM_HANDLE UserHandle,
    IN BOOLEAN LmOldPresent,
    IN PLM_OWF_PASSWORD LmOldOwfPassword,
    IN PLM_OWF_PASSWORD LmNewOwfPassword,
    IN BOOLEAN NtPresent,
    IN PNT_OWF_PASSWORD NtOldOwfPassword,
    IN PNT_OWF_PASSWORD NtNewOwfPassword
)

/*++


Routine Description:

    Changes the password of a user account. This is the worker routine for
    SamChangePasswordUser and can be called by OWF-aware clients.
    Password will be set to NewPassword only if OldPassword matches the
    current user password for this user and the NewPassword is not the
    same as the domain password parameter PasswordHistoryLength
    passwords.  This call allows users to change their own password if
    they have access USER_CHANGE_PASSWORD.  Password update restrictions
    apply.


Parameters:

    UserHandle - The handle of an opened user to operate on.

    LMOldPresent - TRUE if the LmOldOwfPassword is valid. This should only
                   be FALSE if the old password is too long to be represented
                   by a LM password. (Complex NT password).
                   Note the LMNewOwfPassword must always be valid.
                   If the new password is complex, the LMNewOwfPassword should
                   be the well-known LM OWF of a NULL password.

    LmOldOwfPassword - One-way-function of the current LM password for the user.
                     - Ignored if LmOldPresent == FALSE

    LmNewOwfPassword - One-way-function of the new LM password for the user.

    NtPresent - TRUE if the NT one-way-functions are valid.
              - i.e. This will be FALSE if we're called from a down-level client.

    NtOldOwfPassword - One-way-function of the current NT password for the user.

    NtNewOwfPassword - One-way-function of the new NT password for the user.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

    STATUS_INVALID_PARAMETER_MIX - LmOldPresent or NtPresent or both
        must be TRUE.

--*/
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
    ENCRYPTED_NT_OWF_PASSWORD NtNewEncryptedWithNtOld;
    ENCRYPTED_NT_OWF_PASSWORD NtOldEncryptedWithNtNew;
    ENCRYPTED_NT_OWF_PASSWORD NtNewEncryptedWithLmNew;
    ENCRYPTED_LM_OWF_PASSWORD LmNewEncryptedWithLmOld;
    ENCRYPTED_LM_OWF_PASSWORD LmOldEncryptedWithLmNew;
    ENCRYPTED_LM_OWF_PASSWORD LmNewEncryptedWithNtNew;

    PENCRYPTED_NT_OWF_PASSWORD pNtNewEncryptedWithNtOld;
    PENCRYPTED_NT_OWF_PASSWORD pNtOldEncryptedWithNtNew;
    PENCRYPTED_LM_OWF_PASSWORD pLmNewEncryptedWithLmOld;
    PENCRYPTED_LM_OWF_PASSWORD pLmOldEncryptedWithLmNew;
    SAMPR_HANDLE               RpcContextHandle;

    //
    // Check parameter validity
    //

    if (!LmOldPresent && !NtPresent) {
        return(STATUS_INVALID_PARAMETER_MIX);
    }

    if (!SampIsValidClientHandle(UserHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        //
        // We're going to encrypt the oldLM with the newLM and vice-versa.
        // We're going to encrypt the oldNT with the newNT and vice-versa.
        // We're going to send these 4 encryptions and see if we're successful.
        //
        // If we get a return code of STATUS_LM_CROSS_ENCRYPTION_REQUIRED,
        // we'll also encrypt the newLM with the newNT and send it all again.
        //
        // If we get a return code of STATUS_NT_CROSS_ENCRYPTION_REQUIRED,
        // we'll also encrypt the newNT with the newLM and send it all again.
        //
        // We don't always send the cross-encryption otherwise we would be
        // compromising security on pure NT systems with long passwords.
        //

        //
        // Do the LM Encryption
        //

        if (!LmOldPresent) {

            pLmOldEncryptedWithLmNew = NULL;
            pLmNewEncryptedWithLmOld = NULL;

        } else {

            pLmOldEncryptedWithLmNew = &LmOldEncryptedWithLmNew;
            pLmNewEncryptedWithLmOld = &LmNewEncryptedWithLmOld;

            NtStatus = RtlEncryptLmOwfPwdWithLmOwfPwd(
                            LmOldOwfPassword,
                            LmNewOwfPassword,
                            &LmOldEncryptedWithLmNew);

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = RtlEncryptLmOwfPwdWithLmOwfPwd(
                                LmNewOwfPassword,
                                LmOldOwfPassword,
                                &LmNewEncryptedWithLmOld);
            }
        }

        //
        // Do the NT Encryption
        //

        if (NT_SUCCESS(NtStatus)) {

            if (!NtPresent) {

                pNtOldEncryptedWithNtNew = NULL;
                pNtNewEncryptedWithNtOld = NULL;

            } else {

                pNtOldEncryptedWithNtNew = &NtOldEncryptedWithNtNew;
                pNtNewEncryptedWithNtOld = &NtNewEncryptedWithNtOld;

                NtStatus = RtlEncryptNtOwfPwdWithNtOwfPwd(
                                NtOldOwfPassword,
                                NtNewOwfPassword,
                                &NtOldEncryptedWithNtNew);

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = RtlEncryptNtOwfPwdWithNtOwfPwd(
                                    NtNewOwfPassword,
                                    NtOldOwfPassword,
                                    &NtNewEncryptedWithNtOld);
                }
            }
        }


        //
        // Call the server (with no cross-encryption)
        //

        if ( NT_SUCCESS( NtStatus ) ) {

            NtStatus = SamrChangePasswordUser(
                                (SAMPR_HANDLE)RpcContextHandle,

                                LmOldPresent,
                                pLmOldEncryptedWithLmNew,
                                pLmNewEncryptedWithLmOld,

                                NtPresent,
                                pNtOldEncryptedWithNtNew,
                                pNtNewEncryptedWithNtOld,

                                FALSE,  // NtCrossEncryptionPresent
                                NULL,

                                FALSE,  // LmCrossEncryptionPresent
                                NULL

                                );

            if (NtStatus == STATUS_NT_CROSS_ENCRYPTION_REQUIRED) {

                //
                // We should only get this if we have both LM and NT data
                // (This is not obvious - it results from the server-side logic)
                //

                ASSERT(NtPresent && LmOldPresent);

                //
                // Compute the cross-encryption of the new Nt password
                //

                ASSERT(LM_OWF_PASSWORD_LENGTH == NT_OWF_PASSWORD_LENGTH);

                NtStatus = RtlEncryptNtOwfPwdWithNtOwfPwd(
                                NtNewOwfPassword,
                                (PNT_OWF_PASSWORD)LmNewOwfPassword,
                                &NtNewEncryptedWithLmNew);


                //
                // Call the server (with NT cross-encryption)
                //

                if ( NT_SUCCESS( NtStatus ) ) {

                    NtStatus = SamrChangePasswordUser(
                                        (SAMPR_HANDLE)RpcContextHandle,

                                        LmOldPresent,
                                        pLmOldEncryptedWithLmNew,
                                        pLmNewEncryptedWithLmOld,

                                        NtPresent,
                                        pNtOldEncryptedWithNtNew,
                                        pNtNewEncryptedWithNtOld,

                                        TRUE,
                                        &NtNewEncryptedWithLmNew,

                                        FALSE,
                                        NULL
                                        );
                }

            } else {

                if (NtStatus == STATUS_LM_CROSS_ENCRYPTION_REQUIRED) {

                    //
                    // We should only get this if we have NT but no old LM data
                    // (This is not obvious - it results from the server-side logic)
                    //

                    ASSERT(NtPresent && !LmOldPresent);

                    //
                    // Compute the cross-encryption of the new Nt password
                    //

                    ASSERT(LM_OWF_PASSWORD_LENGTH == NT_OWF_PASSWORD_LENGTH);

                    NtStatus = RtlEncryptLmOwfPwdWithLmOwfPwd(
                                    LmNewOwfPassword,
                                    (PLM_OWF_PASSWORD)NtNewOwfPassword,
                                    &LmNewEncryptedWithNtNew);


                    //
                    // Call the server (with LM cross-encryption)
                    //

                    if ( NT_SUCCESS( NtStatus ) ) {

                        NtStatus = SamrChangePasswordUser(
                                            (SAMPR_HANDLE)RpcContextHandle,

                                            LmOldPresent,
                                            pLmOldEncryptedWithLmNew,
                                            pLmNewEncryptedWithLmOld,

                                            NtPresent,
                                            pNtOldEncryptedWithNtNew,
                                            pNtNewEncryptedWithNtOld,

                                            FALSE,
                                            NULL,

                                            TRUE,
                                            &LmNewEncryptedWithNtNew
                                            );
                    }
                }
            }

        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamChangePasswordUser(
    IN SAM_HANDLE UserHandle,
    IN PUNICODE_STRING OldNtPassword,
    IN PUNICODE_STRING NewNtPassword
)

/*++


Routine Description:

    Password will be set to NewPassword only if OldPassword matches the
    current user password for this user and the NewPassword is not the
    same as the domain password parameter PasswordHistoryLength
    passwords.  This call allows users to change their own password if
    they have access USER_CHANGE_PASSWORD.  Password update restrictions
    apply.


Parameters:

    UserHandle - The handle of an opened user to operate on.

    OldPassword - Current password for the user.

    NewPassword - Desired new password for the user.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    LM_OWF_PASSWORD     NewLmOwfPassword, OldLmOwfPassword;
    NT_OWF_PASSWORD     NewNtOwfPassword, OldNtOwfPassword;
    BOOLEAN             LmOldPresent;
    PCHAR               LmPassword;
    NTSTATUS            NtStatus;
    BOOLEAN             UseOwfPasswords;
    SAMPR_HANDLE        RpcContextHandle;

    if (!SampIsValidClientHandle(UserHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus = SampCheckPasswordRestrictions(
                       RpcContextHandle,
                       NewNtPassword,
                       &UseOwfPasswords
                       );

        if ( NT_SUCCESS( NtStatus ) ) {

            //
            // Calculate the one-way-functions of the NT passwords
            //

            NtStatus = RtlCalculateNtOwfPassword(
                           OldNtPassword,
                           &OldNtOwfPassword
                           );

            if ( NT_SUCCESS( NtStatus ) ) {

                NtStatus = RtlCalculateNtOwfPassword(
                               NewNtPassword,
                               &NewNtOwfPassword
                               );
            }


            //
            // Calculate the one-way-functions of the LM passwords
            //

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // Calculate the LM version of the old password
                //

                NtStatus = SampCalculateLmPassword(
                            OldNtPassword,
                            &LmPassword);

                if (NT_SUCCESS(NtStatus)) {

                    if (NtStatus == STATUS_NULL_LM_PASSWORD) {
                        LmOldPresent = FALSE;
                    } else {
                        LmOldPresent = TRUE;

                        //
                        // Compute the One-Way-Function of the old LM password
                        //

                        NtStatus = RtlCalculateLmOwfPassword(
                                        LmPassword,
                                        &OldLmOwfPassword);
                    }

                    //
                    // We're finished with the LM password
                    //

                    MIDL_user_free(LmPassword);
                }

                //
                // Calculate the LM version of the new password
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampCalculateLmPassword(
                                NewNtPassword,
                                &LmPassword);

                    if (NT_SUCCESS(NtStatus)) {

                        //
                        // Compute the One-Way-Function of the new LM password
                        //

                        NtStatus = RtlCalculateLmOwfPassword(
                                        LmPassword,
                                        &NewLmOwfPassword);

                        //
                        // We're finished with the LM password
                        //

                        MIDL_user_free(LmPassword);
                    }
                }
            }


            //
            // Call our worker routine with the one-way-functions
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamiChangePasswordUser(
                                UserHandle,
                                LmOldPresent,
                                &OldLmOwfPassword,
                                &NewLmOwfPassword,
                                TRUE,               // NT present
                                &OldNtOwfPassword,
                                &NewNtOwfPassword
                           );
            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamGetGroupsForUser(
    IN SAM_HANDLE UserHandle,
    OUT PGROUP_MEMBERSHIP * Groups,
    OUT PULONG MembershipCount
)

/*++


Routine Description:

    This service returns the list of groups that a user is a member of.
    It returns a structure for each group that includes the relative ID
    of the group, and the attributes of the group that are assigned to
    the user.

    This service requires USER_LIST_GROUPS access to the user account
    object.


Parameters:

    UserHandle - The handle of an opened user to operate on.

    Groups - Receives a pointer to a buffer containing an array of
        GROUP_MEMBERSHIPs data structures.  When this information is
        no longer needed, this buffer must be freed using
        SamFreeMemory().

    MembershipCount - Receives the number of groups the user is a
        member of, and, thus, the number elements returned in the
        Groups array.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.


--*/
{
    NTSTATUS                    NtStatus;
    PSAMPR_GET_GROUPS_BUFFER    GetGroupsBuffer;
    SAMPR_HANDLE                RpcContextHandle;


    SampOutputDebugString("SamGetGroupsForUser");

    if (!SampIsValidClientHandle(UserHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //


    GetGroupsBuffer = NULL;

    RpcTryExcept{

        NtStatus =
            SamrGetGroupsForUser(
                (SAMPR_HANDLE)RpcContextHandle,
                &GetGroupsBuffer
                );

        if (NT_SUCCESS(NtStatus)) {
            (*MembershipCount) = GetGroupsBuffer->MembershipCount;
            (*Groups)          = GetGroupsBuffer->Groups;
            MIDL_user_free( GetGroupsBuffer );
        } else {

            //
            // Deallocate any returned buffers on error
            //

            if (GetGroupsBuffer != NULL) {
                if (GetGroupsBuffer->Groups != NULL) {
                    MIDL_user_free(GetGroupsBuffer->Groups);
                }
                MIDL_user_free(GetGroupsBuffer);
            }
        }


    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamTestPrivateFunctionsDomain(
    IN SAM_HANDLE DomainHandle
    )

/*++

Routine Description:

    This service is called to test functions that are normally only
    accessible inside the security process.


Arguments:

    DomainHandle - Handle to a domain to be tested.

Return Value:

    STATUS_SUCCESS - The tests completed successfully.

    Any errors are as propogated from the tests.


--*/
{
#ifdef SAM_SERVER_TESTS

    NTSTATUS NtStatus;

    SAMPR_HANDLE        RpcContextHandle;

    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    return( SamrTestPrivateFunctionsDomain( RpcContextHandle ) );
#else
    return( STATUS_NOT_IMPLEMENTED );
    UNREFERENCED_PARAMETER(DomainHandle);
#endif
}



NTSTATUS
SamTestPrivateFunctionsUser(
    IN SAM_HANDLE UserHandle
    )

/*++

Routine Description:

    This service is called to test functions that are normally only
    accessible inside the security process.


Arguments:

    UserHandle - Handle to a user to be tested.

Return Value:

    STATUS_SUCCESS - The tests completed successfully.

    Any errors are as propogated from the tests.


--*/
{
#ifdef SAM_SERVER_TESTS
    SAMPR_HANDLE        RpcContextHandle;

    if (!SampIsValidClientHandle(SamUserHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    return( SamrTestPrivateFunctionsUser( RpcContextHandle ) );
#else
    return( STATUS_NOT_IMPLEMENTED );
    UNREFERENCED_PARAMETER(UserHandle);
#endif
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private services                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SampMapCompletionStatus(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This service maps completion status received back from an RPC call
    into a completion status to be returned from SAM api.


Parameters:

    Status - Status value to be mapped.

Return Values:

    The mapped SAM status value.


--*/
{

    if (Status == RPC_NT_INVALID_BINDING) {
        Status =  STATUS_INVALID_HANDLE;
    }
//    if (Status == RPC_ACCESS_DENIED) {
//        Status = STATUS_ACCESS_DENIED;
//    }



    return( Status );

}






////////////////////////////////////////////////////////////////////////

NTSTATUS
SampCheckStrongPasswordRestrictions(
    PUNICODE_STRING Password
    )

/*++

Routine Description:

    This routine is notified of a password change. It will check the
    password's complexity. The new Strong Password must meet the
    following criteria:
    1. Password must contain characters from at least 3 of the
       following 5 classes:

       Description                             Examples:
       1       English Upper Case Letters      A, B, C,   Z
       2       English Lower Case Letters      a, b, c,  z
       3       Westernized Arabic Numerals     0, 1, 2,  9
       4       Non-alphanumeric             ("Special characters")
                                            (`~!@#$%^&*_-+=|\\{}[]:;\"'<>,.?)
       5       Any linguistic character: alphabetic, syllabary, or ideographic 
               (localization issue)

    Note: The following restriction (No. 2) can only be enforced on 
          the server side. Because when users change their password, 
          the client code opens the User Account with WRITE access 
          right only. Then samlib can not READ any user info (for 
          example: Account Name and Full name). Thus we have to 
          rely on the server side SAMSRV.dll to enforce restriction
          No. 2. The only exception would be when client send OWF 
          password to server, then server can not do any restriction
          check at all. 
          

          2. Password can not contain your account name or any part of
             user's full name.


    Note: This routine does NOT check password's length, since password
          length restriction has already been enforced by NT4 SAM if you
          set it correctly.

Arguments:

    Password - Cleartext new password for the user

Return Value:

    STATUS_SUCCESS if the specified Password is suitable (complex, long, etc).
        The system will continue to evaluate the password update request
        through any other installed password change packages.

    STATUS_PASSWORD_RESTRICTION
        if the specified Password is unsuitable. The password change
         on the specified account will fail.

    STATUS_NO_MEMORY

--*/
{

                    // assume the password in not complex enough
    NTSTATUS NtStatus = STATUS_PASSWORD_RESTRICTION;
    USHORT     cchPassword = 0;
    USHORT     i = 0;
    USHORT     NumInPassword = 0;
    USHORT     UpperInPassword = 0;
    USHORT     LowerInPassword = 0;
    USHORT     AlphaInPassword = 0;
    USHORT     SpecialCharInPassword = 0;
    PWSTR      _password = NULL;
    PWORD      CharType = NULL;


    // check if the password contains at least 3 of 4 classes.

    CharType = MIDL_user_allocate( Password->Length );

    if ( CharType == NULL ) {

        NtStatus = STATUS_NO_MEMORY;
        goto SampCheckStrongPasswordFinish;
    }

    cchPassword = Password->Length / sizeof(WCHAR);
    if(GetStringTypeW(
           CT_CTYPE1,
           Password->Buffer,
           cchPassword,
           CharType)) {

        for(i = 0 ; i < cchPassword ; i++) {

            //
            // keep track of what type of characters we have encountered
            //

            if(CharType[i] & C1_DIGIT) {
                NumInPassword = 1;
                continue;
            }

            if(CharType[i] & C1_UPPER) {
                UpperInPassword = 1;
                continue;
            }

            if(CharType[i] & C1_LOWER) {
                LowerInPassword = 1;
                continue;
            }

            if(CharType[i] & C1_ALPHA) {
                AlphaInPassword = 1;
                continue;
            }

        } // end of track character type.

        _password = MIDL_user_allocate(Password->Length + sizeof(WCHAR));

        if ( _password == NULL ) {

            NtStatus = STATUS_NO_MEMORY;
            goto SampCheckStrongPasswordFinish;
        }
        else {

            RtlZeroMemory( _password, Password->Length + sizeof(WCHAR));
        }

        wcsncpy(_password,
                Password->Buffer,
                Password->Length/sizeof(WCHAR)
                );

        if (wcspbrk (_password, L"(`~!@#$%^&*_-+=|\\{}[]:;\"'<>,.?)") != NULL) {

                SpecialCharInPassword = 1 ;
        }

        //
        // Indicate whether we encountered enough password complexity
        //

        if( (NumInPassword + LowerInPassword + UpperInPassword + AlphaInPassword +
                SpecialCharInPassword) < 3) 
        {
            NtStatus = STATUS_PASSWORD_RESTRICTION;
            goto SampCheckStrongPasswordFinish;

        } else 
        {
            NtStatus = STATUS_SUCCESS ;
        }

    } // if GetStringTypeW failed, NtStatus will by default equal to
      // STATUS_PASSWORD_RESTRICTION


SampCheckStrongPasswordFinish:

    if ( CharType != NULL ) {
        RtlZeroMemory( CharType, Password->Length );
        MIDL_user_free( CharType );
    }

    if ( _password != NULL ) {
        RtlZeroMemory( _password, Password->Length + sizeof(WCHAR) );
        MIDL_user_free( _password );
    }

    return ( NtStatus );
}

/////////////////////////////////////////////////////////////////////





NTSTATUS
SampCheckPasswordRestrictions(
    IN SAMPR_HANDLE RpcContextHandle,
    IN PUNICODE_STRING NewNtPassword,
    OUT PBOOLEAN UseOwfPasswords
    )

/*++

Routine Description:

    This service is called to make sure that the password presented meets
    our quality requirements.


Arguments:

    RpcContextHandle - Handle to a user.

    NewNtPassword - Pointer to the UNICODE_STRING containing the new
        password.

    UseOwfPasswords - Indicates that reversibly encrypted passwords should
        not be sent over the network.


Return Value:

    STATUS_SUCCESS - The password is acceptable.

    STATUS_PASSWORD_RESTRICTION - The password is too short, or is not
        complex enough, etc.

    STATUS_INVALID_RESOURCES - There was not enough memory to do the
        password checking.


--*/
{
    USER_DOMAIN_PASSWORD_INFORMATION  DomainPasswordInformationBuffer;
    NTSTATUS                          NtStatus;

    //
    // If the new password is zero length the server side will do
    // the necessary checking.
    //

    if (NewNtPassword->Length == 0) {
        return(STATUS_SUCCESS);
    }

    //
    // The password should be less than PWLEN -- 256
    // 
    if ((NewNtPassword->Length / sizeof(WCHAR)) > PWLEN)
    {
        return(STATUS_PASSWORD_RESTRICTION);
    }

    *UseOwfPasswords = FALSE;


    //
    // Query information domain to get password length and
    // complexity requirements.
    //

    NtStatus = SamrGetUserDomainPasswordInformation(
                   RpcContextHandle,
                   &DomainPasswordInformationBuffer
                   );

    if ( NT_SUCCESS( NtStatus ) ) {

        if ( (USHORT)( NewNtPassword->Length / sizeof(WCHAR) ) < DomainPasswordInformationBuffer.MinPasswordLength ) {

            NtStatus = STATUS_PASSWORD_RESTRICTION;

        } else {

            //
            // Check whether policy allows us to send reversibly encrypted
            // passwords.
            //

            if ( DomainPasswordInformationBuffer.PasswordProperties &
                 DOMAIN_PASSWORD_NO_CLEAR_CHANGE ) {
                *UseOwfPasswords = TRUE;
            }

            //
            // Check password complexity.
            //

            if ( DomainPasswordInformationBuffer.PasswordProperties & DOMAIN_PASSWORD_COMPLEX ) {

                //
                // Make sure that the password meets our requirements for
                // complexity.  If it's got an odd byte count, it's
                // obviously not a hand-entered UNICODE string so we'll
                // consider it complex by default.
                //

                if ( !( NewNtPassword->Length & 1 ) ) {

                    //
                    // Apply Strong password restrictions
                    //

                    NtStatus = SampCheckStrongPasswordRestrictions( NewNtPassword );
                }
            }
        }
    }

    return( NtStatus );
}


NTSTATUS
SampChangePasswordUser2(
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword
)

/*++


Routine Description:

    Password will be set to NewPassword only if OldPassword matches the
    current user password for this user and the NewPassword is not the
    same as the domain password parameter PasswordHistoryLength
    passwords.  This call allows users to change their own password if
    they have access USER_CHANGE_PASSWORD.  Password update restrictions
    apply.


Parameters:

    UserHandle - The handle of an opened user to operate on.

    OldPassword - Current password for the user.

    NewPassword - Desired new password for the user.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    NTSTATUS NtStatus;
    SAM_HANDLE SamServerHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;
    SAM_HANDLE UserHandle = NULL;
    LSA_HANDLE PolicyHandle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo = NULL;
    PULONG UserId = NULL;
    PSID_NAME_USE NameUse = NULL;

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0,
        NULL,
        NULL
        );

    //
    // The InitializeObjectAttributes call doesn't initialize the
    // quality of serivce, so do that separately.
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;



    NtStatus = LsaOpenPolicy(
                ServerName,
                &ObjectAttributes,
                POLICY_VIEW_LOCAL_INFORMATION,
                &PolicyHandle
                );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    NtStatus = LsaQueryInformationPolicy(
                PolicyHandle,
                PolicyAccountDomainInformation,
                &AccountDomainInfo
                );
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    NtStatus = SamConnect(
                ServerName,
                &SamServerHandle,
                SAM_SERVER_LOOKUP_DOMAIN,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    NtStatus = SamOpenDomain(
                SamServerHandle,
                GENERIC_EXECUTE,
                AccountDomainInfo->DomainSid,
                &DomainHandle
                );
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    NtStatus = SamLookupNamesInDomain(
                DomainHandle,
                1,
                UserName,
                &UserId,
                &NameUse
                );

    if (!NT_SUCCESS(NtStatus)) {
        if (NtStatus == STATUS_NONE_MAPPED) {
            NtStatus = STATUS_NO_SUCH_USER;
        }
        goto Cleanup;
    }

    NtStatus = SamOpenUser(
                DomainHandle,
                USER_CHANGE_PASSWORD,
                *UserId,
                &UserHandle
                );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    NtStatus = SamChangePasswordUser(
                UserHandle,
                OldPassword,
                NewPassword
                );
Cleanup:
    if (UserHandle != NULL) {
        SamCloseHandle(UserHandle);
    }
    if (DomainHandle != NULL) {
        SamCloseHandle(DomainHandle);
    }
    if (SamServerHandle != NULL) {
        SamCloseHandle(SamServerHandle);
    }
    if (PolicyHandle != NULL){
        LsaClose(PolicyHandle);
    }
    if (AccountDomainInfo != NULL) {
        LsaFreeMemory(AccountDomainInfo);
    }
    if (UserId != NULL) {
        SamFreeMemory(UserId);
    }
    if (NameUse != NULL) {
        SamFreeMemory(NameUse);
    }

    return(NtStatus);

}

NTSTATUS
SampGetPasswordChangeFailureInfo(
    IN PUNICODE_STRING UncComputerName,
    PDOMAIN_PASSWORD_INFORMATION * EffectivePasswordPolicy,
    PUSER_PWD_CHANGE_FAILURE_INFORMATION *PasswordChangeFailureInfo 
    )
/*++

    This routine obtains the domain password policy pertaining
    to the account domain of a particular server.

    Parameters

        UncComputerName -- THe name of the server

    ReturnValues

        STATUS_SUCCESS
        Other Error codes upon failure
--*/
{
    NTSTATUS                    Status;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQos;
    SAM_HANDLE                  SamHandle = NULL;
    SAM_HANDLE                  DomainHandle = NULL;
    LSA_HANDLE                  LSAPolicyHandle = NULL;
    OBJECT_ATTRIBUTES           LSAObjectAttributes;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo = NULL;
    


    //
    // Initialize Return values
    //

    *PasswordChangeFailureInfo = NULL;

   
    //
    // Get the SID of the account domain from LSA
    //

    InitializeObjectAttributes( &LSAObjectAttributes,
                                  NULL,             // Name
                                  0,                // Attributes
                                  NULL,             // Root
                                  NULL );           // Security Descriptor

    Status = LsaOpenPolicy( UncComputerName,
                            &LSAObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &LSAPolicyHandle );

    if( !NT_SUCCESS(Status) ) {
        KdPrint(("MspChangePasswordSam: LsaOpenPolicy(%wZ) failed, status %x\n",
                 UncComputerName, Status));
        LSAPolicyHandle = NULL;
        goto Cleanup;
    }

    Status = LsaQueryInformationPolicy(
                    LSAPolicyHandle,
                    PolicyAccountDomainInformation,
                    (PVOID *) &AccountDomainInfo );

    if( !NT_SUCCESS(Status) ) {
        KdPrint(("MspChangePasswordSam: LsaQueryInformationPolicy(%wZ) failed, status %x\n",
                 UncComputerName, Status));
        AccountDomainInfo = NULL;
        goto Cleanup;
    }

    //
    // Setup ObjectAttributes for SamConnect call.
    //

    InitializeObjectAttributes(&ObjectAttributes, NULL, 0, 0, NULL);
    ObjectAttributes.SecurityQualityOfService = &SecurityQos;

    SecurityQos.Length = sizeof(SecurityQos);
    SecurityQos.ImpersonationLevel = SecurityIdentification;
    SecurityQos.ContextTrackingMode = SECURITY_STATIC_TRACKING;
    SecurityQos.EffectiveOnly = FALSE;

    Status = SamConnect(
                 UncComputerName,
                 &SamHandle,
                 SAM_SERVER_LOOKUP_DOMAIN,
                 &ObjectAttributes
                 );


    if ( !NT_SUCCESS(Status) ) {
       
        DomainHandle = NULL;
        goto Cleanup;
    }


    //
    // Open the Account domain in SAM.
    //

    Status = SamOpenDomain(
                 SamHandle,
                 GENERIC_EXECUTE,
                 AccountDomainInfo->DomainSid,
                 &DomainHandle
                 );

    if ( !NT_SUCCESS(Status) ) {
        
        DomainHandle = NULL;
        goto Cleanup;
    }


    Status = SamQueryInformationDomain(
                    DomainHandle,
                    DomainPasswordInformation,
                    (PVOID *)EffectivePasswordPolicy );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // O.K Compose the PasswordChangeFailureInfo structure
    //
        
    *PasswordChangeFailureInfo = MIDL_user_allocate(sizeof(USER_PWD_CHANGE_FAILURE_INFORMATION));
    if (NULL==*PasswordChangeFailureInfo)                            
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(*PasswordChangeFailureInfo,
                   sizeof(USER_PWD_CHANGE_FAILURE_INFORMATION));

Cleanup:

    //
    // Free Locally used resources
    //


    if (SamHandle) {
        SamCloseHandle(SamHandle);
    }

    if (DomainHandle) {
        SamCloseHandle(DomainHandle);
    }

    if( LSAPolicyHandle != NULL ) {
        LsaClose( LSAPolicyHandle );
    }

    if ( AccountDomainInfo != NULL ) {
        (VOID) LsaFreeMemory( AccountDomainInfo );
    }

    return Status;    
}


NTSTATUS
SamiChangePasswordUser3(
    PUNICODE_STRING ServerName,
    PUNICODE_STRING UserName,
    PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldNt,
    PENCRYPTED_NT_OWF_PASSWORD OldNtOwfPasswordEncryptedWithNewNt,
    BOOLEAN LmPresent,
    PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm,
    PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPasswordEncryptedWithNewLmOrNt,
    PDOMAIN_PASSWORD_INFORMATION * EffectivePasswordPolicy, OPTIONAL
    PUSER_PWD_CHANGE_FAILURE_INFORMATION *PasswordChangeFailureInfo OPTIONAL
    )
/*++


Routine Description:

    Changes the password of a user account. This is the worker routine for
    SamChangePasswordUser2 and can be called by OWF-aware clients.
    Password will be set to NewPassword only if OldPassword matches the
    current user password for this user and the NewPassword is not the
    same as the domain password parameter PasswordHistoryLength
    passwords.  This call allows users to change their own password if
    they have access USER_CHANGE_PASSWORD.  Password update restrictions
    apply.


Parameters:

    ServerName - The server to operate on, or NULL for this machine.

    UserName - Name of user whose password is to be changed

    NewPasswordEncryptedWithOldNt - The new cleartext password encrypted
        with the old NT OWF password.

    OldNtOwfPasswordEncryptedWithNewNt - The old NT OWF password encrypted
        with the new NT OWF password.

    LmPresent - If TRUE, indicates that the following two last parameter
        was encrypted with the LM OWF password not the NT OWF password.

    NewPasswordEncryptedWithOldLm - The new cleartext password encrypted
        with the old LM OWF password.

    OldLmOwfPasswordEncryptedWithNewLmOrNt - The old LM OWF password encrypted
        with the new LM OWF password.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

--*/

{
    handle_t BindingHandle = NULL;
    PSAMPR_SERVER_NAME RServerNameWithNull;
    USHORT RServerNameWithNullLength;
    PSAMPR_SERVER_NAME  RServerName;
    ULONG Tries = 2;
    NTSTATUS NtStatus;
    USER_DOMAIN_PASSWORD_INFORMATION PasswordInformation;
    PUSER_PWD_CHANGE_FAILURE_INFORMATION PasswordChangeFailureInformationLocal = NULL;
    PDOMAIN_PASSWORD_INFORMATION         EffectivePasswordPolicyLocal = NULL;;


    RServerNameWithNull = NULL;

    if (ARGUMENT_PRESENT(ServerName)) {

        RServerName = (PSAMPR_SERVER_NAME)(ServerName->Buffer);
        RServerNameWithNullLength = ServerName->Length + (USHORT) sizeof(WCHAR);
        RServerNameWithNull = MIDL_user_allocate( RServerNameWithNullLength );

        if (RServerNameWithNull == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlCopyMemory( RServerNameWithNull, RServerName, ServerName->Length);
        RServerNameWithNull[ServerName->Length/sizeof(WCHAR)] = L'\0';

    }

    //
    // Initialize return values
    //

    if (ARGUMENT_PRESENT(PasswordChangeFailureInfo))
    {
        *PasswordChangeFailureInfo = NULL;
    }
    if (ARGUMENT_PRESENT(EffectivePasswordPolicy))
    {
        *EffectivePasswordPolicy = NULL;
    }

    do
    {
        //
        // Try privacy level first, and if that failed with unknown authn
        // level or invalid binding try with a lower level (none).
        //

        if (Tries == 2) {
            BindingHandle = SampSecureBind(
                                RServerNameWithNull,
                                RPC_C_AUTHN_LEVEL_PKT_PRIVACY
                                );


        } else if ((NtStatus == RPC_NT_UNKNOWN_AUTHN_LEVEL) ||
                   (NtStatus == RPC_NT_UNKNOWN_AUTHN_TYPE) ||
                   (NtStatus == RPC_NT_UNKNOWN_AUTHN_SERVICE) ||
                   (NtStatus == RPC_NT_INVALID_BINDING) ||
                   (NtStatus == STATUS_ACCESS_DENIED) ) {
            SampSecureUnbind(BindingHandle);

            BindingHandle = SampSecureBind(
                                RServerNameWithNull,
                                RPC_C_AUTHN_LEVEL_NONE
                                );

        } else {
            break;
        }

        if (BindingHandle != NULL) {

            RpcTryExcept{

                //
                // Get password information to make sure this operation
                // is allowed.  We do it now because we wanted to bind
                // before trying it.
                //

                NtStatus = SamrGetDomainPasswordInformation(
                               BindingHandle,
                               (PRPC_UNICODE_STRING) ServerName,
                               &PasswordInformation
                               );

                if ((( NtStatus == STATUS_SUCCESS ) &&
                    (( PasswordInformation.PasswordProperties &
                        DOMAIN_PASSWORD_NO_CLEAR_CHANGE ) == 0 ) ) ||
                    (NtStatus == STATUS_ACCESS_DENIED ) ) {



                   RpcTryExcept { 

                       //
                       // Try the latest call
                       //

                        NtStatus = SamrUnicodeChangePasswordUser3(
                                       BindingHandle,
                                       (PRPC_UNICODE_STRING) ServerName,
                                       (PRPC_UNICODE_STRING) UserName,
                                       NewPasswordEncryptedWithOldNt,
                                       OldNtOwfPasswordEncryptedWithNewNt,
                                       LmPresent,
                                       NewPasswordEncryptedWithOldLm,
                                       OldLmOwfPasswordEncryptedWithNewLmOrNt,
                                       NULL,
                                       &EffectivePasswordPolicyLocal,
                                       &PasswordChangeFailureInformationLocal
                                      );
                   } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                          NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

                   } RpcEndExcept;

                    if ((NtStatus == RPC_NT_UNKNOWN_IF) ||
                        (NtStatus == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

                           NtStatus = SamrUnicodeChangePasswordUser2(
                                       BindingHandle,
                                       (PRPC_UNICODE_STRING) ServerName,
                                       (PRPC_UNICODE_STRING) UserName,
                                       NewPasswordEncryptedWithOldNt,
                                       OldNtOwfPasswordEncryptedWithNewNt,
                                       LmPresent,
                                       NewPasswordEncryptedWithOldLm,
                                       OldLmOwfPasswordEncryptedWithNewLmOrNt
                                       );

                           if (STATUS_PASSWORD_RESTRICTION==NtStatus)
                           {
                               NTSTATUS IgnoreStatus;

                               //
                               // Obtain the domain policy and a default
                               // password change failure info by reading
                               // the domain policy. Ignore the resulting
                               // NtStatus -- if the call failed, 
                               // PasswordChangeFailureInfo would be NULL
                               //

                               IgnoreStatus = SampGetPasswordChangeFailureInfo(
                                                ServerName,
                                                &EffectivePasswordPolicyLocal,
                                                &PasswordChangeFailureInformationLocal
                                                );
                           }

                    }

                } else {

                    //
                    // Set the error to indicate that we should try the
                    // downlevel way to change passwords.
                    //

                    NtStatus = STATUS_NOT_SUPPORTED;
                }



            } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {


                //
                // The mapping function doesn't handle this error so
                // special case it by hand.
                //
                NtStatus = RpcExceptionCode();

                if (NtStatus == RPC_S_SEC_PKG_ERROR) {
                    NtStatus = STATUS_ACCESS_DENIED;
                } else {
                    NtStatus = I_RpcMapWin32Status(NtStatus);
                }


            } RpcEndExcept;

        } else {
            NtStatus = RPC_NT_INVALID_BINDING;
        }

        Tries--;
    } while ( (Tries > 0) && (!NT_SUCCESS(NtStatus)) );
    if (RServerNameWithNull != NULL) {
        MIDL_user_free( RServerNameWithNull );
    }

    if (BindingHandle != NULL) {
        SampSecureUnbind(BindingHandle);
    }

    //
    // Map these errors to STATUS_NOT_SUPPORTED
    //

    if ((NtStatus == RPC_NT_UNKNOWN_IF) ||
        (NtStatus == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        NtStatus = STATUS_NOT_SUPPORTED;
    }

    if (ARGUMENT_PRESENT(PasswordChangeFailureInfo))
    {
        *PasswordChangeFailureInfo = PasswordChangeFailureInformationLocal;
    }
    else if (NULL!=PasswordChangeFailureInformationLocal)
    {
        if (NULL!=PasswordChangeFailureInformationLocal->FilterModuleName.Buffer)
        {
            SamFreeMemory(PasswordChangeFailureInformationLocal->FilterModuleName.Buffer);
        }
        SamFreeMemory(PasswordChangeFailureInformationLocal);
    }

    if (ARGUMENT_PRESENT(EffectivePasswordPolicy))
    {
        *EffectivePasswordPolicy = EffectivePasswordPolicyLocal;
    }
    else if (NULL!=EffectivePasswordPolicyLocal)
    {
        SamFreeMemory(EffectivePasswordPolicyLocal);
    }

    return(SampMapCompletionStatus(NtStatus));


}



NTSTATUS
SamiChangePasswordUser2(
    PUNICODE_STRING ServerName,
    PUNICODE_STRING UserName,
    PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldNt,
    PENCRYPTED_NT_OWF_PASSWORD OldNtOwfPasswordEncryptedWithNewNt,
    BOOLEAN LmPresent,
    PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm,
    PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPasswordEncryptedWithNewLmOrNt
    )
/*++


Routine Description:

    Changes the password of a user account. This is the worker routine for
    SamChangePasswordUser2 and can be called by OWF-aware clients.
    Password will be set to NewPassword only if OldPassword matches the
    current user password for this user and the NewPassword is not the
    same as the domain password parameter PasswordHistoryLength
    passwords.  This call allows users to change their own password if
    they have access USER_CHANGE_PASSWORD.  Password update restrictions
    apply.


Parameters:

    ServerName - The server to operate on, or NULL for this machine.

    UserName - Name of user whose password is to be changed

    NewPasswordEncryptedWithOldNt - The new cleartext password encrypted
        with the old NT OWF password.

    OldNtOwfPasswordEncryptedWithNewNt - The old NT OWF password encrypted
        with the new NT OWF password.

    LmPresent - If TRUE, indicates that the following two last parameter
        was encrypted with the LM OWF password not the NT OWF password.

    NewPasswordEncryptedWithOldLm - The new cleartext password encrypted
        with the old LM OWF password.

    OldLmOwfPasswordEncryptedWithNewLmOrNt - The old LM OWF password encrypted
        with the new LM OWF password.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

--*/

{
    handle_t BindingHandle;
    PSAMPR_SERVER_NAME RServerNameWithNull;
    USHORT RServerNameWithNullLength;
    PSAMPR_SERVER_NAME  RServerName;
    ULONG Tries = 2;
    NTSTATUS NtStatus;
    USER_DOMAIN_PASSWORD_INFORMATION PasswordInformation;

    RServerNameWithNull = NULL;

    if (ARGUMENT_PRESENT(ServerName)) {

        RServerName = (PSAMPR_SERVER_NAME)(ServerName->Buffer);
        RServerNameWithNullLength = ServerName->Length + (USHORT) sizeof(WCHAR);
        RServerNameWithNull = MIDL_user_allocate( RServerNameWithNullLength );

        if (RServerNameWithNull == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlCopyMemory( RServerNameWithNull, RServerName, ServerName->Length);
        RServerNameWithNull[ServerName->Length/sizeof(WCHAR)] = L'\0';

    }


    do
    {
        //
        // Try privacy level first, and if that failed with unknown authn
        // level or invalid binding try with a lower level (none).
        //

        if (Tries == 2) {
            BindingHandle = SampSecureBind(
                                RServerNameWithNull,
                                RPC_C_AUTHN_LEVEL_PKT_PRIVACY
                                );


        } else if ((NtStatus == RPC_NT_UNKNOWN_AUTHN_LEVEL) ||
                   (NtStatus == RPC_NT_UNKNOWN_AUTHN_TYPE) ||
                   (NtStatus == RPC_NT_UNKNOWN_AUTHN_SERVICE) ||
                   (NtStatus == RPC_NT_INVALID_BINDING) ||
                   (NtStatus == STATUS_ACCESS_DENIED) ) {
            SampSecureUnbind(BindingHandle);

            BindingHandle = SampSecureBind(
                                RServerNameWithNull,
                                RPC_C_AUTHN_LEVEL_NONE
                                );

        } else {
            break;
        }

        if (BindingHandle != NULL) {

            RpcTryExcept{

                //
                // Get password information to make sure this operation
                // is allowed.  We do it now because we wanted to bind
                // before trying it.
                //

                NtStatus = SamrGetDomainPasswordInformation(
                               BindingHandle,
                               (PRPC_UNICODE_STRING) ServerName,
                               &PasswordInformation
                               );

                if ((( NtStatus == STATUS_SUCCESS ) &&
                    (( PasswordInformation.PasswordProperties &
                        DOMAIN_PASSWORD_NO_CLEAR_CHANGE ) == 0 ) ) ||
                    (NtStatus == STATUS_ACCESS_DENIED ) ) {


                    NtStatus = SamrUnicodeChangePasswordUser2(
                                       BindingHandle,
                                       (PRPC_UNICODE_STRING) ServerName,
                                       (PRPC_UNICODE_STRING) UserName,
                                       NewPasswordEncryptedWithOldNt,
                                       OldNtOwfPasswordEncryptedWithNewNt,
                                       LmPresent,
                                       NewPasswordEncryptedWithOldLm,
                                       OldLmOwfPasswordEncryptedWithNewLmOrNt
                                       );

                } else {

                    //
                    // Set the error to indicate that we should try the
                    // downlevel way to change passwords.
                    //

                    NtStatus = STATUS_NOT_SUPPORTED;
                }



            } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {


                //
                // The mapping function doesn't handle this error so
                // special case it by hand.
                //
                NtStatus = RpcExceptionCode();

                if (NtStatus == RPC_S_SEC_PKG_ERROR) {
                    NtStatus = STATUS_ACCESS_DENIED;
                } else {
                    if (NtStatus == ERROR_PASSWORD_MUST_CHANGE) {
                        //
                        // I_RpcMapWin32Status returns WinError's
                        // when it can't map the error
                        //
                        NtStatus = STATUS_PASSWORD_MUST_CHANGE;
                    } else {
                        NtStatus = I_RpcMapWin32Status(NtStatus);
                    }
                }


            } RpcEndExcept;

        } else {
            NtStatus = RPC_NT_INVALID_BINDING;
        }

        Tries--;
    } while ( (Tries > 0) && (!NT_SUCCESS(NtStatus)) );
    if (RServerNameWithNull != NULL) {
        MIDL_user_free( RServerNameWithNull );
    }

    if (BindingHandle != NULL) {
        SampSecureUnbind(BindingHandle);
    }

    //
    // Map these errors to STATUS_NOT_SUPPORTED
    //

    if ((NtStatus == RPC_NT_UNKNOWN_IF) ||
        (NtStatus == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        NtStatus = STATUS_NOT_SUPPORTED;
    }
    return(SampMapCompletionStatus(NtStatus));


}
NTSTATUS
SamiOemChangePasswordUser2(
    PSTRING ServerName,
    PSTRING UserName,
    PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm,
    PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPasswordEncryptedWithNewLm
    )
/*++


Routine Description:

    Changes the password of a user account. This  can be called by OWF-aware
    clients. Password will be set to NewPassword only if OldPassword matches
    the current user password for this user and the NewPassword is not the
    same as the domain password parameter PasswordHistoryLength
    passwords.  This call allows users to change their own password if
    they have access USER_CHANGE_PASSWORD.  Password update restrictions
    apply.


Parameters:

    ServerName - The server to operate on, or NULL for this machine.

    UserName - Name of user whose password is to be changed


    NewPasswordEncryptedWithOldLm - The new cleartext password encrypted
        with the old LM OWF password.

    OldLmOwfPasswordEncryptedWithNewLm - The old LM OWF password encrypted
        with the new LM OWF password.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

--*/

{
    handle_t BindingHandle = NULL;
    UNICODE_STRING RemoteServerName;
    ULONG Tries = 2;
    NTSTATUS NtStatus;
    USER_DOMAIN_PASSWORD_INFORMATION PasswordInformation;

    RemoteServerName.Buffer = NULL;
    RemoteServerName.Length = 0;

    if (ARGUMENT_PRESENT(ServerName)) {

        NtStatus = RtlAnsiStringToUnicodeString(
                        &RemoteServerName,
                        ServerName,
                        TRUE            // allocate destination
                        );

        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
        ASSERT(RemoteServerName.Buffer[RemoteServerName.Length/sizeof(WCHAR)] == L'\0');
    }


    do
    {
        //
        // Try privacy level first, and if that failed with unknown authn
        // level or invalid binding try with a lower level (none).
        //

        if (Tries == 2) {
            BindingHandle = SampSecureBind(
                                RemoteServerName.Buffer,
                                RPC_C_AUTHN_LEVEL_PKT_PRIVACY
                                );


        } else if ((NtStatus == RPC_NT_UNKNOWN_AUTHN_LEVEL) ||
                   (NtStatus == RPC_NT_UNKNOWN_AUTHN_TYPE) ||
                   (NtStatus == RPC_NT_INVALID_BINDING) ||
                   (NtStatus == STATUS_ACCESS_DENIED) ) {
            SampSecureUnbind(BindingHandle);

            BindingHandle = SampSecureBind(
                                RemoteServerName.Buffer,
                                RPC_C_AUTHN_LEVEL_NONE
                                );

        } else {
            break;
        }

        if (BindingHandle != NULL) {

            RpcTryExcept{

                //
                // Get password information to make sure this operation
                // is allowed.  We do it now because we wanted to bind
                // before trying it.
                //

                NtStatus = SamrGetDomainPasswordInformation(
                               BindingHandle,
                               (PRPC_UNICODE_STRING) ServerName,
                               &PasswordInformation
                               );


               if ((( NtStatus == STATUS_SUCCESS ) &&
                    (( PasswordInformation.PasswordProperties &
                    DOMAIN_PASSWORD_NO_CLEAR_CHANGE ) == 0 ) ) ||
                    (NtStatus == STATUS_ACCESS_DENIED ) ) {

                
                        NtStatus = SamrOemChangePasswordUser2(
                                       BindingHandle,
                                       (PRPC_STRING) ServerName,
                                       (PRPC_STRING) UserName,
                                       NewPasswordEncryptedWithOldLm,
                                       OldLmOwfPasswordEncryptedWithNewLm
                                       );

                } else {

                    //
                    // Set the error to indicate that we should try the
                    // downlevel way to change passwords.
                    //

                    NtStatus = STATUS_NOT_SUPPORTED;
                }
                


            } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {


                //
                // The mappin function doesn't handle this error so
                // special case it by hand.
                //

                if (NtStatus == RPC_S_SEC_PKG_ERROR) {
                    NtStatus = STATUS_ACCESS_DENIED;
                } else {
                    NtStatus = I_RpcMapWin32Status(RpcExceptionCode());
                }


            } RpcEndExcept;

        } else {
            NtStatus = RPC_NT_INVALID_BINDING;
        }

        Tries--;
    } while ( (Tries > 0) && (!NT_SUCCESS(NtStatus)) );

    RtlFreeUnicodeString( &RemoteServerName );

    if (BindingHandle != NULL) {
        SampSecureUnbind(BindingHandle);
    }

    //
    // Map these errors to STATUS_NOT_SUPPORTED
    //

    if ((NtStatus == RPC_NT_UNKNOWN_IF) ||
        (NtStatus == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        NtStatus = STATUS_NOT_SUPPORTED;
    }

    return(SampMapCompletionStatus(NtStatus));

}


NTSTATUS
SamChangePasswordUser3(
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword,
    OUT PDOMAIN_PASSWORD_INFORMATION * EffectivePasswordPolicy OPTIONAL,
    OUT PUSER_PWD_CHANGE_FAILURE_INFORMATION *PasswordChangeFailureInfo OPTIONAL
   )

/*++


Routine Description:

    Password will be set to NewPassword only if OldPassword matches the
    current user password for this user and the NewPassword is not the
    same as the domain password parameter PasswordHistoryLength
    passwords.  This call allows users to change their own password if
    they have access USER_CHANGE_PASSWORD.  Password update restrictions
    apply.


Parameters:

    ServerName - The server to operate on, or NULL for this machine.

    UserName - Name of user whose password is to be changed

    OldPassword - Current password for the user.

    NewPassword - Desired new password for the user.

    EffectivePasswordPolicy - returns the current effective password
                              policy
    
    PasswordChangeFailureInfo -- If the password change failed ( say due
                  to a password policy ) then this field might contain
                  additional info regarding the effective policy.

    if those optional parameters are supplied, then the caller is 
    responsible to release the memory by calling SamFreeMemory(). 
    (EffectivePasswordPolicy and PasswordChangeFailureInfo, plus
     PasswordChangeFailureInfo->FilterModuleName.Buffer != NULL )


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    SAMPR_ENCRYPTED_USER_PASSWORD NewNtEncryptedWithOldNt;
    SAMPR_ENCRYPTED_USER_PASSWORD NewNtEncryptedWithOldLm;
    ENCRYPTED_NT_OWF_PASSWORD OldNtOwfEncryptedWithNewNt;
    ENCRYPTED_NT_OWF_PASSWORD OldLmOwfEncryptedWithNewNt;
    NTSTATUS            NtStatus;
    BOOLEAN             LmPresent = TRUE;
    ULONG               AuthnLevel;
    ULONG               Tries = 2;
    USER_DOMAIN_PASSWORD_INFORMATION PasswordInformation;

    //
    // Initialize return values
    //

    if (ARGUMENT_PRESENT(PasswordChangeFailureInfo))
    {
        *PasswordChangeFailureInfo = NULL;
    }
    if (ARGUMENT_PRESENT(EffectivePasswordPolicy))
    {
        *EffectivePasswordPolicy = NULL;
    }

    //
    // Call the server, passing either a NULL Server Name pointer, or
    // a pointer to a Unicode Buffer with a Wide Character NULL terminator.
    // Since the input name is contained in a counted Unicode String, there
    // is no NULL terminator necessarily provided, so we must append one.
    //

    //
    // Encrypted the passwords
    //

    NtStatus = SamiEncryptPasswords(
                OldPassword,
                NewPassword,
                &NewNtEncryptedWithOldNt,
                &OldNtOwfEncryptedWithNewNt,
                &LmPresent,
                &NewNtEncryptedWithOldLm,
                &OldLmOwfEncryptedWithNewNt
                );

    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Try the remote call...
    //


    NtStatus = SamiChangePasswordUser3(
                   ServerName,
                   UserName,
                   &NewNtEncryptedWithOldNt,
                   &OldNtOwfEncryptedWithNewNt,
                   LmPresent,
                   &NewNtEncryptedWithOldLm,
                   &OldLmOwfEncryptedWithNewNt,
                   EffectivePasswordPolicy,
                   PasswordChangeFailureInfo
                   );


    //
    // If the new API failed, try calling the old API.
    //

    if (NtStatus == STATUS_NOT_SUPPORTED) {

        NtStatus = SampChangePasswordUser2(
                    ServerName,
                    UserName,
                    OldPassword,
                    NewPassword
                    );
    }

    return(SampMapCompletionStatus(NtStatus));

}


NTSTATUS
SamChangePasswordUser2(
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword
)

/*++


Routine Description:

    Password will be set to NewPassword only if OldPassword matches the
    current user password for this user and the NewPassword is not the
    same as the domain password parameter PasswordHistoryLength
    passwords.  This call allows users to change their own password if
    they have access USER_CHANGE_PASSWORD.  Password update restrictions
    apply.


Parameters:

    ServerName - The server to operate on, or NULL for this machine.

    UserName - Name of user whose password is to be changed

    OldPassword - Current password for the user.

    NewPassword - Desired new password for the user.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    SAMPR_ENCRYPTED_USER_PASSWORD NewNtEncryptedWithOldNt;
    SAMPR_ENCRYPTED_USER_PASSWORD NewNtEncryptedWithOldLm;
    ENCRYPTED_NT_OWF_PASSWORD OldNtOwfEncryptedWithNewNt;
    ENCRYPTED_NT_OWF_PASSWORD OldLmOwfEncryptedWithNewNt;
    NTSTATUS            NtStatus;
    BOOLEAN             LmPresent = TRUE;
    ULONG               AuthnLevel;
    ULONG               Tries = 2;
    USER_DOMAIN_PASSWORD_INFORMATION PasswordInformation;


    //
    // Call the server, passing either a NULL Server Name pointer, or
    // a pointer to a Unicode Buffer with a Wide Character NULL terminator.
    // Since the input name is contained in a counted Unicode String, there
    // is no NULL terminator necessarily provided, so we must append one.
    //

    //
    // Encrypted the passwords
    //

    NtStatus = SamiEncryptPasswords(
                OldPassword,
                NewPassword,
                &NewNtEncryptedWithOldNt,
                &OldNtOwfEncryptedWithNewNt,
                &LmPresent,
                &NewNtEncryptedWithOldLm,
                &OldLmOwfEncryptedWithNewNt
                );

    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Try the remote call...
    //


    NtStatus = SamiChangePasswordUser2(
                   ServerName,
                   UserName,
                   &NewNtEncryptedWithOldNt,
                   &OldNtOwfEncryptedWithNewNt,
                   LmPresent,
                   &NewNtEncryptedWithOldLm,
                   &OldLmOwfEncryptedWithNewNt
                   );


    //
    // If the new API failed, try calling the old API.
    //

    if (NtStatus == STATUS_NOT_SUPPORTED) {

        NtStatus = SampChangePasswordUser2(
                    ServerName,
                    UserName,
                    OldPassword,
                    NewPassword
                    );
    }

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamiSetBootKeyInformation(
    IN SAM_HANDLE DomainHandle,
    IN SAMPR_BOOT_TYPE BootOptions,
    IN PUNICODE_STRING OldBootKey, OPTIONAL
    IN PUNICODE_STRING NewBootKey OPTIONAL
    )
/*++

Routine Description:

    This routine sets the boot key

Arguments:

    DomainHandle - Handle to the account domain object.
    BootOptions - New boot options.
    OldBootKey - If changing the boot key, old key must be provided.
    NewBootKey - New key to require for booting if changing or setting.

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Access was denied.


--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;
    
    
    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //


    RpcTryExcept{


        NtStatus = SamrSetBootKeyInformation(
                    RpcContextHandle,
                    BootOptions,
                    (PRPC_UNICODE_STRING) OldBootKey,
                    (PRPC_UNICODE_STRING) NewBootKey
                    );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamiGetBootKeyInformation(
    IN SAM_HANDLE DomainHandle,
    OUT PSAMPR_BOOT_TYPE BootOptions
    )
/*++
Routine Description:

    Establish a session with a SAM subsystem and subsequently open the
    SamServer object of that subsystem.  The caller must have
    SAM_SERVER_CONNECT access to the SamServer object of the subsystem
    being connected to.

    The handle returned is for use in future calls.


Arguments:

    DomainHandle - Handle to the account domain object.
    BootOptions - Current boot options

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Access was denied.


--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;
    
    
    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //


    RpcTryExcept{

        NtStatus = SamrGetBootKeyInformation(
                    RpcContextHandle,
                    BootOptions
                    );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    return(SampMapCompletionStatus(NtStatus));

}

NTSTATUS
SamiChangeKeys()
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    SAMPR_HANDLE  ServerHandle = NULL;
    SAMPR_HANDLE  DomainHandle=NULL;
    LSA_HANDLE    PolicyHandle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo = NULL;
    SAMPR_BOOT_TYPE   BootOptions;
    UCHAR    OriginalSyskeyBuffer[16];
    ULONG    OriginalSyskeyLen = sizeof(OriginalSyskeyBuffer);
    UNICODE_STRING OriginalSyskey;
    UCHAR    NewSyskeyBuffer[16];
    ULONG    NewSyskeyLen = sizeof(NewSyskeyBuffer);
    UNICODE_STRING NewSyskey;
   
    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0,
        NULL,
        NULL
        );

    //
    // The InitializeObjectAttributes call doesn't initialize the
    // quality of serivce, so do that separately.
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;



    NtStatus = LsaOpenPolicy(
                NULL, // local LSA
                &ObjectAttributes,
                POLICY_VIEW_LOCAL_INFORMATION,
                &PolicyHandle
                );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    NtStatus = LsaQueryInformationPolicy(
                PolicyHandle,
                PolicyAccountDomainInformation,
                &AccountDomainInfo
                );
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    NtStatus = SamConnect(
                NULL, // Local SAM
                &ServerHandle,
                SAM_SERVER_LOOKUP_DOMAIN,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    NtStatus = SamOpenDomain(
                ServerHandle,
                DOMAIN_WRITE_PASSWORD_PARAMS|DOMAIN_READ_PASSWORD_PARAMETERS,
                AccountDomainInfo->DomainSid,
                &DomainHandle
                );
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    NtStatus = SamiGetBootKeyInformation(
                    DomainHandle,
                    &BootOptions
                    );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    if (SamBootKeyStored!=BootOptions) {
        NtStatus = STATUS_INVALID_SERVER_STATE;
        goto Cleanup;
    }

    //
    // Get the current syskey
    //

    NtStatus = WxReadSysKey(
                    &OriginalSyskeyLen,
                    OriginalSyskeyBuffer
                    );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Change the password encryption key
    // 
    
    OriginalSyskey.Length = OriginalSyskey.MaximumLength = (USHORT)OriginalSyskeyLen;
    OriginalSyskey.Buffer = (WCHAR * )OriginalSyskeyBuffer;

    NtStatus = SamiSetBootKeyInformation(
                    DomainHandle,
                    SamBootChangePasswordEncryptionKey,
                    &OriginalSyskey,
                    &OriginalSyskey
                    );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Generate the syskey
    //

    if (!RtlGenRandom( NewSyskeyBuffer, NewSyskeyLen)) {
     NtStatus = STATUS_UNSUCCESSFUL;
     goto Cleanup;
    }
     
    NewSyskey.Length = NewSyskey.MaximumLength 
                                    = (USHORT)NewSyskeyLen;
    NewSyskey.Buffer = (WCHAR * )NewSyskeyBuffer;

    //
    // Change state in LSA and Sam to use the new key
    //

    NtStatus = SamiSetBootKeyInformation(
                    DomainHandle,
                    SamBootKeyStored,
                    &OriginalSyskey,
                    &NewSyskey
                    );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Write the new syskey to disk
    //

    NtStatus = WxSaveSysKey(NewSyskey.Length,NewSyskey.Buffer);


Cleanup:

    if (DomainHandle != NULL) {
        SamCloseHandle(DomainHandle);
    }
    if (ServerHandle != NULL) {
        SamCloseHandle(ServerHandle);
    }
    if (PolicyHandle != NULL){
        LsaClose(PolicyHandle);
    }
    if (AccountDomainInfo != NULL) {
        LsaFreeMemory(AccountDomainInfo);
    }

    return(NtStatus);
    
}



NTSTATUS
SamGetCompatibilityMode(
    IN  SAM_HANDLE ObjectHandle,
    OUT ULONG*     Mode
    )
/*++

Routine Description:

    This routine returns the emulation mode of the server that the handle
    was returned from.
    
Arguments:

    ObjectHandle -- a SAM handle returned from a SAM client API
    
    Mode --  SAM_SID_COMPATIBILITY_ALL:  no extended sid work
    
             SAM_SID_COMPATIBILITY_LAX:  set rid field to zero for callers
             
             SAM_SID_COMPATIBILITY_STRICT:  don't allow levels with RID field

Return Value:

    STATUS_SUCCESS

    STATUS_INVALID_HANDLE
    
    STATUS_INVALID_PARAMETER


--*/
{
    SAMP_HANDLE SampHandle = (SAMP_HANDLE) ObjectHandle;

    if (!SampIsValidClientHandle(ObjectHandle, NULL)) {
        return STATUS_INVALID_HANDLE;
    }

    if (NULL == Mode) {
        return STATUS_INVALID_PARAMETER;
    }

    *Mode = SAM_SID_COMPATIBILITY_ALL;
    if ( (SampHandle->ServerInfo.SupportedFeatures & SAM_EXTENDED_SID_DOMAIN_COMPAT_1) ) {
        *Mode = SAM_SID_COMPATIBILITY_LAX;
    } else if (SampHandle->ServerInfo.SupportedFeatures & SAM_EXTENDED_SID_DOMAIN_COMPAT_2) {
        *Mode = SAM_SID_COMPATIBILITY_STRICT;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
SamConnectWithCreds(
    IN  PUNICODE_STRING             ServerName,
    OUT PSAM_HANDLE                 ServerHandle,
    IN  ACCESS_MASK                 DesiredAccess,
    IN  POBJECT_ATTRIBUTES          ObjectAttributes,
    IN  RPC_AUTH_IDENTITY_HANDLE    Creds,
    IN  PWCHAR                      Spn,
    OUT BOOL                        *pfDstIsW2K
    
    )
{
    NTSTATUS    status;
    TlsInfo     tlsInfo;

    *pfDstIsW2K = FALSE;

    if ( !Creds || !ServerName || !ServerName->Buffer || !ServerName->Length ) 
    {
        return(STATUS_INVALID_PARAMETER);
    }

    if ( !TlsSetValue(gTlsIndex, &tlsInfo) ) 
    {
        return(I_RpcMapWin32Status(GetLastError()));
    }

    tlsInfo.Creds = Creds;
    tlsInfo.Spn = Spn;
    tlsInfo.fDstIsW2K = FALSE;

    status = SamConnect(ServerName, ServerHandle, 
                        DesiredAccess, ObjectAttributes);

    if ( NT_SUCCESS(status) )
    {
        *pfDstIsW2K = tlsInfo.fDstIsW2K;
    }

    TlsSetValue(gTlsIndex, NULL);
    return(status);
}


NTSTATUS
SampCreateNewHandle(
    IN  SAMP_HANDLE RequestingHandle OPTIONAL,
    IN  PSID        DomainSid        OPTIONAL,
    OUT SAMP_HANDLE* NewHandle
    )
/*++

Routine Description:

    This routine allocates a new client side SAM handle.
    
Arguments:

    RequestingHandle -- handle the SAM client side function was called with
                        Used for transferring information about the server
                        to the new handle
                        
    DomainSid        -- the domain SID (used during SamOpenDomain)
    
    NewHandle        -- the created handle                        

Return Value:

    STATUS_SUCCESS

    STATUS_NO_MEMORY


--*/
{
    SAMP_HANDLE LocalHandle;
    ULONG Length;
    PSID  Sid = NULL;

    ASSERT(NewHandle);
    *NewHandle = NULL;

    //
    // Allocate the handle
    //
    LocalHandle = MIDL_user_allocate(sizeof(SAMP_CLIENT_INFO));
    if (NULL == LocalHandle) {
        return STATUS_NO_MEMORY;
    }
    RtlZeroMemory(LocalHandle, sizeof(SAMP_CLIENT_INFO));

    //
    // Copy in the server info, if any
    //
    if ( RequestingHandle ) {

        RtlCopyMemory(&LocalHandle->ServerInfo,
                      &RequestingHandle->ServerInfo,
                      sizeof(LocalHandle->ServerInfo));

        if (RequestingHandle->DomainSid) {
            Sid = RequestingHandle->DomainSid;
        }
    }

    if ( DomainSid ) {
        ASSERT( NULL == Sid );
        Sid = DomainSid;
    }

    //
    // Copy in the sid, if any
    //
    if ( Sid ) {
        Length = RtlLengthSid( Sid );
        LocalHandle->DomainSid = MIDL_user_allocate(Length);
        if (LocalHandle->DomainSid) {
            RtlCopySid(Length, LocalHandle->DomainSid, Sid);
        } else {
            MIDL_user_free(LocalHandle);
            return STATUS_NO_MEMORY;
        }
    }

    *NewHandle = LocalHandle;

    return STATUS_SUCCESS;

}



VOID
SampFreeHandle(
    IN OUT SAMP_HANDLE *Handle
    )
/*++

Routine Description:
    
    This routine frees the memory associated with Handle.
    It does not free the context handle

Arguments:

    Handle -- the handle to free; set to 0 on return                                       

Return Value:

    None.
    
--*/
{
    ASSERT(Handle);
    if (*Handle) {
        if ( (*Handle)->DomainSid) {
            MIDL_user_free((*Handle)->DomainSid);
        }
        RtlZeroMemory(*Handle, sizeof(SAMP_CLIENT_INFO));
        MIDL_user_free(*Handle);
        *Handle = NULL;
    }
    return;
}



NTSTATUS
SamRidToSid (
    IN SAM_HANDLE Handle,
    IN ULONG      Rid,
    OUT PSID*     Sid
    )
/*++

Routine Description:

    This routine creates a SID given a the SAM handle that was passed into
    the routine that return the Rid that is passed in. 

Arguments:

    Handle -- the SAM handle that was used to obtain the RID that is being
              passed in
              
    Rid    -- the "handle" relative id of a security principal
    
    Sid    -- the SID of principal referred to by Rid              

Return Value:

    STATUS_SUCCESS
    
    STATUS_NOT_FOUND the RID could not be found
    
    a fatal NT resource or network error otherwise

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    SAMP_HANDLE SampHandle = (SAMP_HANDLE) Handle;


    if (!SampIsValidClientHandle(Handle, NULL)) {
        return STATUS_INVALID_HANDLE;
    }

    if (IsBadWritePtr(Sid, sizeof(PSID))) {
        return STATUS_INVALID_PARAMETER;
    }

#define SAMP_EXTENDED_SID_DOMAIN(x)                               \
   ((x)->ServerInfo.SupportedFeatures & (SAM_EXTENDED_SID_DOMAIN))
   
    if ( SAMP_EXTENDED_SID_DOMAIN(SampHandle) ) {

        //
        // Make network call
        //
        *Sid = NULL;

        NtStatus = SamrRidToSid(SampHandle->ContextHandle,
                                Rid,
                                (PRPC_SID*) Sid);


    } else {

        //
        // Perform locally
        //
        if (NULL == SampHandle->DomainSid) {
            return STATUS_INVALID_PARAMETER;
        }

        NtStatus = SampMakeSid(SampHandle->DomainSid,
                               Rid,
                               Sid);
    }

    return NtStatus;
}


NTSTATUS
SampMakeSid(
    IN PSID  DomainSid,
    IN ULONG Rid,
    OUT PSID* Sid
    )
/*++

Routine Description:

    This routine creates an account SID given a ULONG Rid and DomainSid

Arguments:

    DomainSid - The template SID to use.

    Rid       - The relative Id to append to the DomainId.

    Sid       - Returns a pointer to an allocated buffer containing the resultant
                Sid.  Free this buffer using MIDL_user_free (or SamFreeMemory).

Return Value:

    STATUS_SUCCESS - if successful
    
    STATUS_NO_MEMORY - if cannot allocate memory for SID

--*/    
{
    UCHAR DomainIdSubAuthorityCount; // Number of sub authorities in domain ID
    ULONG SidLength;                 // Length of newly allocated SID

    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //
    DomainIdSubAuthorityCount = *(RtlSubAuthorityCountSid( DomainSid ));
    SidLength = RtlLengthRequiredSid(DomainIdSubAuthorityCount+1);

    if ((*Sid = (PSID) MIDL_user_allocate( SidLength )) == NULL ) {
        return STATUS_NO_MEMORY;
    }

    //
    // Initialize the new SID to have the same inital value as the
    // domain ID.
    //
    RtlCopySid( SidLength, *Sid, DomainSid );

    //
    // Adjust the sub-authority count and
    //  add the relative Id unique to the newly allocated SID
    //

    (*(RtlSubAuthorityCountSid( *Sid ))) ++;
    *RtlSubAuthoritySid( *Sid, DomainIdSubAuthorityCount ) = Rid;

    return STATUS_SUCCESS;
}


BOOLEAN
SampIsValidClientHandle(
    IN     SAM_HANDLE    SamHandle,
    IN OUT SAMPR_HANDLE *RpcHandle OPTIONAL
    )
/*++

Routine Description:

    This routine determines if the handle passed in from the client of 
    samlib.dll (SamHandle) is valid or not.
    
    Note all exceptions are handled during deferences.
    
Arguments:

    SamHandle - client provided handle
    
    RpcHandle - set to the RpcContextHandle embedded in SamHandle (if SamHandle
                is valid)

Return Value:

    TRUE if valid; FALSE otherwise

--*/    
{
    BOOLEAN fReturn = TRUE;
    SAMP_HANDLE SampHandle = (SAMP_HANDLE)SamHandle;
    SAMPR_HANDLE RpcContextHandle = NULL;

    if (NULL == SampHandle) {
        fReturn = FALSE;
    } else {
        _try {
            RpcContextHandle = SampHandle->ContextHandle;
            if (NULL == RpcContextHandle) {
                fReturn = FALSE;
            }
            if (SampHandle->DomainSid) {
                if (!RtlValidSid(SampHandle->DomainSid)) {
                    fReturn = FALSE;
                }
            }
        } _except ( EXCEPTION_EXECUTE_HANDLER ) {
            fReturn = FALSE;
        }
    }
    
    if (fReturn && RpcHandle) {
        *RpcHandle = RpcContextHandle;
    }

    return fReturn;
}



NTSTATUS
SampEncryptPasswordWithIndex(
    IN PUNICODE_STRING  ClearPassword,
    IN NT_OWF_PASSWORD  *PassedInNtOWFPassword,
    IN ULONG    Index, 
    OUT PENCRYPTED_NT_OWF_PASSWORD   EncryptedNtOwfPassword
    )
/*++

Routine Description:

    This routine generates NT OWF password, and furthe encrypts it 
    with passed in Index. 
    

Parameters: 

    ClearPassword - clear text password to be encrypted    

    Index - index to use 
    
    EncryptedNtOwfPassword - return encrypted NT OWF password
    
Return Value: 

    NTSTATUS code 

--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    NT_OWF_PASSWORD NtOwfPassword;
    CRYPT_INDEX     EncryptIndex = Index;
    


    if (ARGUMENT_PRESENT(ClearPassword))
    {
        NtStatus = RtlCalculateNtOwfPassword(ClearPassword,
                                         &NtOwfPassword
                                         );
    }
    else
    {
        RtlCopyMemory(
            &NtOwfPassword,
            PassedInNtOWFPassword, 
            sizeof(NT_OWF_PASSWORD)
            );
    }

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = RtlEncryptNtOwfPwdWithIndex(
                                    &NtOwfPassword,
                                    &EncryptIndex,
                                    EncryptedNtOwfPassword
                                    );
    }

    return( NtStatus );
}




NTSTATUS
SampSetDSRMPassword(
    IN PUNICODE_STRING  ServerName OPTIONAL,
    IN ULONG            UserId,
    IN PUNICODE_STRING  ClearPassword,
    IN PNT_OWF_PASSWORD NtOwfPassword
    )
/*++
Routine Description:

    This routine connects to the server passed in, then sets that server's 
    Directory Service Restore Mode User Account (specified by UserId) Password.

    Currently only Administrator Account Password Can be set.

Parameters:

    ServerName - Domain Controller's name to use. 
                 Local machine will be used if NULL passed in.

    UserId - Only Administrator Account Relative ID is valid right now.

    ClearPassword - new password

Return Value:

    NTSTATUS Code
    
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    handle_t    BindingHandle = NULL;
    PSAMPR_SERVER_NAME  RServerName = NULL;
    PSAMPR_SERVER_NAME  RServerNameWithNull = NULL;
    USHORT      RServerNameWithNullLength = 0;
    ENCRYPTED_NT_OWF_PASSWORD   EncryptedNtOwfPassword;


    //
    // check input parameter
    // 

    if ((NULL == ClearPassword) && (NULL==NtOwfPassword))
    {
        return( STATUS_INVALID_PARAMETER );
    }

    //
    // extract server name
    //

    RServerNameWithNull = NULL;

    if (ARGUMENT_PRESENT(ServerName)) {

        RServerName = (PSAMPR_SERVER_NAME)(ServerName->Buffer);
        RServerNameWithNullLength = ServerName->Length + (USHORT) sizeof(WCHAR);
        RServerNameWithNull = MIDL_user_allocate( RServerNameWithNullLength );

        if (RServerNameWithNull == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlCopyMemory( RServerNameWithNull, RServerName, ServerName->Length);
        RServerNameWithNull[ServerName->Length/sizeof(WCHAR)] = L'\0';
    }


    //
    // encrypt password
    // 

    NtStatus = SampEncryptPasswordWithIndex(ClearPassword,
                                            NtOwfPassword,
                                            UserId,
                                            &EncryptedNtOwfPassword
                                            );

    if (!NT_SUCCESS(NtStatus)) {
        goto Error;
    }

    //
    // make secure RPC connection
    // 

    BindingHandle = SampSecureBind(RServerNameWithNull,
                                   RPC_C_AUTHN_LEVEL_PKT_PRIVACY
                                   );

    if (NULL != BindingHandle)
    {
        //
        // talk to server, set DSRM admin password
        // 
        RpcTryExcept {

            NtStatus = SamrSetDSRMPassword(BindingHandle,
                                           (PRPC_UNICODE_STRING) ServerName,
                                           UserId,
                                           &EncryptedNtOwfPassword
                                           );

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

        } RpcEndExcept;
    }
    else
    {
        NtStatus = RPC_NT_INVALID_BINDING;
    }



Error:

    //
    // Clean up
    // 

    if (NULL != RServerNameWithNull) {
        MIDL_user_free( RServerNameWithNull );    
    }

    if (BindingHandle != NULL) {
        SampSecureUnbind(BindingHandle);
    }

    //
    // Map these errors to STATUS_NOT_SUPPORTED
    //

    if ((NtStatus == RPC_NT_UNKNOWN_IF) ||
        (NtStatus == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        NtStatus = STATUS_NOT_SUPPORTED;
    }

    return( NtStatus );
}


NTSTATUS
SamiSetDSRMPassword(
    IN PUNICODE_STRING  ServerName OPTIONAL,
    IN ULONG            UserId,
    IN PUNICODE_STRING  ClearPassword
    )
{
    return(SampSetDSRMPassword(
                    ServerName ,
                    UserId,
                    ClearPassword,
                    NULL
                    ));
}

NTSTATUS
SamiSetDSRMPasswordOWF(
    IN PUNICODE_STRING  ServerName OPTIONAL,
    IN ULONG            UserId,
    IN PNT_OWF_PASSWORD NtPassword
    )
{
    return(SampSetDSRMPassword(
                    ServerName ,
                    UserId,
                    NULL,
                    NtPassword
                    ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\lib\enckey.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1997-1997
//
// File:        enckey.h
//
// Contents:    Password based key encryption/decryption library.
//
// History:     17-Apr-97      terences created
//
//---------------------------------------------------------------------------



// consts

#define KE_KEY_SIZE     16
#define KE_CUR_VERSION  1

#define MAGIC_CONST_1   "0123456789012345678901234567890123456789"
#define MAGIC_CONST_2   "!@#$%^&*()qwertyUIOPAzxcvbnmQQQQQQQQQQQQ)(*@&%"

// error codes

#define KE_OK           0
#define KE_FAIL         1
#define KE_BAD_PASSWORD 2

typedef struct _EncKey {
    DWORD   dwVersion;      // 00000001 = 128 bit RC4
    DWORD   dwLength;       // = sizeof(KEEncKey)
    BYTE    Salt[16];       // 16 bytes of random salt
    BYTE    EncKey[KE_KEY_SIZE];     // Key encrypted with PW + Salt
    BYTE    Confirm[16];    // MD5(Key) encrypted with PW+Salt
} KEEncKey;

typedef struct _ClearKey {
    DWORD   dwVersion;          // 00000001 = 128 bit plain key
    DWORD   dwLength;           // = sizeof(KEClearKey)
    BYTE    ClearKey[KE_KEY_SIZE];   // 128 bits of key data
} KEClearKey;


//---------------------------------------------
// DecryptKey
//
//  Caller passes in hash of unicode password, enc key struct, struct to
//  get the clear key
//
//  DecryptKey will return the clear key if the password matches.
//
//  return codes:
//      KE_BAD_PASSWORD     Password will not decrypt key
//      KE_OK               Password decrypted key

DWORD KEDecryptKey(
    IN KEClearKey       *pszPassword,
    IN KEEncKey     *pEncBlock,
    OUT KEClearKey      *pSAMKey,
    IN DWORD            dwFlags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\lib\enckey.c ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1997-1997
//
// File:        enckey.c
//
// Contents:    Password based key encryption/decryption library.
//
// History:     17-Apr-97      terences created
//              
//              09-Jan-99       ShaoYin copy it from newsam2\server to support 
//                              recovery mode authentication
//
//---------------------------------------------------------------------------


//
// This file should keep sync with newsam2\server\enckey.c
// 
// This file is just a minimum subset of \newsam2\server\enckey.c
// only contains KEDecryptKey().
// 



#include <windows.h>
#include <rc4.h>
#include <md5.h>
#include <rng.h>
#include <enckey.h>



//---------------------------------------------
// DecryptKey
//
//  Caller passes in hash of unicode password, enc key struct, struct to
//  get the clear key
//
//  DecryptKey will return the clear key if the password matches.  Note that
//  this function is ALWAYS destructive to the passed encryption block.  In
//  the case of a decrypt, it will be zeroed out.
//
//  return codes:
//      KE_BAD_PASSWORD     Password will not decrypt key
//      KE_OK               Password decrypted key

DWORD KEDecryptKey(
    IN KEClearKey   *pPassword,
    IN KEEncKey     *pEncBlock,
    OUT KEClearKey  *pSAMKey,
    IN DWORD        dwFlags)
{
    MD5_CTX         LocalHash;
    struct RC4_KEYSTRUCT   LocalRC4Key;

    if ((pPassword == NULL) || (pEncBlock == NULL) || (pSAMKey == NULL))
        return KE_FAIL;

    if ((pEncBlock->dwVersion != KE_CUR_VERSION) ||
        (pPassword->dwVersion != KE_CUR_VERSION))
        return KE_FAIL;

    pSAMKey->dwVersion = KE_CUR_VERSION;
    pSAMKey->dwLength = sizeof(KEClearKey);

    // Decrypt the key and the confirmer
    MD5Init(&LocalHash);
    MD5Update(&LocalHash, pEncBlock->Salt, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_2, sizeof(MAGIC_CONST_2));
    MD5Update(&LocalHash, pPassword->ClearKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_1, sizeof(MAGIC_CONST_1));
    MD5Final(&LocalHash);
    rc4_key(&LocalRC4Key, KE_KEY_SIZE, (BYTE *) &(LocalHash.digest));
    rc4(&LocalRC4Key, KE_KEY_SIZE * 2, (BYTE *)&(pEncBlock->EncKey));

    // Clean up immediately

    memset(&(LocalHash), 0, sizeof(LocalHash));
    memset(&(LocalRC4Key), 0, sizeof(LocalRC4Key));

    // Generate the confirmer.

    MD5Init(&LocalHash);
    MD5Update(&LocalHash, pEncBlock->EncKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_1, sizeof(MAGIC_CONST_1));
    MD5Update(&LocalHash, pEncBlock->EncKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_2, sizeof(MAGIC_CONST_2));
    MD5Final(&LocalHash);

    // Check that the confirmer matches

    if (memcmp(&(LocalHash.digest), &(pEncBlock->Confirm), KE_KEY_SIZE))
    {
        // Failed.  Zero and leave.
        // No need to zero the block, since rc4 trashed it.

        memset(&(LocalHash), 0, sizeof(LocalHash));
        return KE_BAD_PASSWORD;
    }

    // Confirmer matched.

    memset(&(LocalHash), 0, sizeof(LocalHash));
    memcpy(pSAMKey->ClearKey, pEncBlock->EncKey, KE_KEY_SIZE);
    memset(pEncBlock, 0, sizeof(KEEncKey));

    return KE_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\lib\wxcli.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       wxcli.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-18-97   RichardW   Created
//
//              09-Jan-99 ShaoYin copied it from security project
//                        This file is just a mimimum subset of the original 
//                        file, only contains part of these original API(s)
// 
//
//----------------------------------------------------------------------------




#include <ntosp.h>

#include <ntrtl.h>
#include <nturtl.h>
#include <zwapi.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <ntlsa.h>

//#include <windows.h>
#include <md5.h>

#include <wxlpc.h>
//#include <wxlpcp.h>

#include "recovery.h"
#include "recmem.h"

#include <stdio.h>
#include <stdlib.h>


/*++

    The following code was moved from syskey to wxcli so as to commonalize this code
    between syskey and samsrv.dll 

--*/
#if DBG
#define HIDDEN
#else
#define HIDDEN static
#endif

HIDDEN
UCHAR KeyShuffle[ 16 ] = { 8, 10, 3, 7, 2, 1, 9, 15, 0, 5, 13, 4, 11, 6, 12, 14 };

HIDDEN
CHAR HexKey[ 17 ] = "0123456789abcdef" ;

#define ToHex( f ) (HexKey[f & 0xF])


#define CONTROL_SET             L"ControlSet"
#define LSA_JD_KEY_NAME         L"Control\\Lsa\\JD"
#define LSA_SKEW1_KEY_NAME      L"Control\\Lsa\\Skew1"
#define LSA_GBG_KEY_NAME        L"Control\\Lsa\\GBG"
#define LSA_DATA_KEY_NAME       L"Control\\Lsa\\Data"
#define SELECT_KEY_NAME         L"Select"
#define VALUE_NAME              L"Current"


#define DATA_SIZE       9
#define KEY_NAME_SIZE   64


#define FromHex( c )    ( ( ( c >= '0' ) && ( c <= '9') ) ? c - '0' :      \
                          ( ( c >= 'a' ) && ( c <= 'f') ) ? c - 'a' + 10:      \
                          ( ( c >= 'A' ) && ( c <= 'F' ) ) ? c - 'A' + 10: -1 )


#define ErrorReturn( c )   if (!NT_SUCCESS(c))  \
                           {                    \
                               return (c);      \
                           }




NTSTATUS
SampDetermineCorrectControlKey(
    IN HANDLE hSystemRootKey, 
    OUT ULONG  *ControlSetNumber
    )
/*++
Routine Description:

    Parses the select node and finds the correct ControlSetXXX to use.
    
Parameters: 

    hSystemRootKey - Handle of the root of the system hive
    
    ControlSetNumber - pointer to a ULONG which will contain the number
    
Return Values:
    
    NTSTATUS code
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES   Attributes;
    UNICODE_STRING      SelectKeyName;
    UNICODE_STRING      SelectValue;
    HANDLE              hSelectKey;
    ULONG               KeyPartialInformationSize = 0;
    PKEY_VALUE_PARTIAL_INFORMATION  KeyPartialInformation = NULL;

    *ControlSetNumber = -1;

    RtlInitUnicodeString(&SelectKeyName, SELECT_KEY_NAME);
    InitializeObjectAttributes(&Attributes, 
                               &SelectKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );
    Attributes.RootDirectory = hSystemRootKey;

    NtStatus = ZwOpenKey(&hSelectKey, KEY_ALL_ACCESS, &Attributes);

    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    RtlInitUnicodeString(&SelectValue, VALUE_NAME);

    NtStatus = ZwQueryValueKey(hSelectKey, 
                               &SelectValue, 
                               KeyValuePartialInformation, 
                               KeyPartialInformation, 
                               KeyPartialInformationSize, 
                               &KeyPartialInformationSize
                               );

    if (STATUS_BUFFER_TOO_SMALL == NtStatus)
    {
        KeyPartialInformation = RecSamAlloc(KeyPartialInformationSize);

        if (KeyPartialInformation)                   
        {
            NtStatus = ZwQueryValueKey(hSelectKey, 
                                       &SelectValue, 
                                       KeyValuePartialInformation, 
                                       KeyPartialInformation, 
                                       KeyPartialInformationSize, 
                                       &KeyPartialInformationSize
                                       );
        }
        else
        {
            NtStatus = STATUS_NO_MEMORY;
        }
    }
                              
    if (NT_SUCCESS(NtStatus))
    {
        if (KeyPartialInformation->Type == REG_DWORD)
        {
            *ControlSetNumber = *( (ULONG*) &(KeyPartialInformation->Data[0]) );
        }
        else
        {
            NtStatus = STATUS_OBJECT_NAME_NOT_FOUND; 
        }
    }

    ZwClose(hSelectKey);

    if (KeyPartialInformation)
    {
        RecSamFree(KeyPartialInformation);
    }

    return NtStatus;    
}



NTSTATUS                          
WxpDeobfuscateKeyForRecovery(
    HANDLE  hSystemRootKey,
    PWXHASH Hash
    )
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    WXHASH ProtoHash ;
    CHAR Class[ DATA_SIZE ];
    WCHAR WClass[ DATA_SIZE ];
    ULONG i ;
    PUCHAR j ;
    int t;
    int t2 ;
    HANDLE          JDKey ; 
    HANDLE          Skew1Key ; 
    HANDLE          GBGKey ; 
    HANDLE          DataKey ; 
    UNICODE_STRING  JDKeyName;
    UNICODE_STRING  Skew1KeyName;
    UNICODE_STRING  GBGKeyName;
    UNICODE_STRING  DataKeyName;
    UNICODE_STRING  UnicodeString;
    ANSI_STRING     AnsiString;
    OBJECT_ATTRIBUTES JDAttributes;
    OBJECT_ATTRIBUTES Skew1Attributes;
    OBJECT_ATTRIBUTES GBGAttributes;
    OBJECT_ATTRIBUTES DataAttributes;
    UCHAR    KeyInfo[sizeof(KEY_NODE_INFORMATION) + REGISTRY_KEY_NAME_LENGTH_MAX];
    ULONG   RequiredKeyInfoLength = 0;
    ULONG   ControlSetNumber = -1; 
    WCHAR   JdName[KEY_NAME_SIZE];
    WCHAR   Skew1Name[KEY_NAME_SIZE];
    WCHAR   GbgName[KEY_NAME_SIZE];
    WCHAR   DataName[KEY_NAME_SIZE];


    //
    // Get the Current Control Set Number
    // 
    NtStatus = SampDetermineCorrectControlKey(hSystemRootKey, 
                                              &ControlSetNumber
                                              );

    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    RtlZeroMemory(JdName, sizeof(WCHAR) * KEY_NAME_SIZE);
    RtlZeroMemory(Skew1Name, sizeof(WCHAR) * KEY_NAME_SIZE);
    RtlZeroMemory(GbgName, sizeof(WCHAR) * KEY_NAME_SIZE);
    RtlZeroMemory(DataName, sizeof(WCHAR) * KEY_NAME_SIZE);

    swprintf(JdName, 
             L"%s%03d\\%s", 
             CONTROL_SET, 
             ControlSetNumber, 
             LSA_JD_KEY_NAME
             );

    swprintf(Skew1Name, 
             L"%s%03d\\%s", 
             CONTROL_SET, 
             ControlSetNumber, 
             LSA_SKEW1_KEY_NAME
             );

    swprintf(GbgName, 
             L"%s%03d\\%s", 
             CONTROL_SET, 
             ControlSetNumber, 
             LSA_GBG_KEY_NAME
             );

    swprintf(DataName, 
             L"%s%03d\\%s", 
             CONTROL_SET, 
             ControlSetNumber, 
             LSA_DATA_KEY_NAME
             );

    //
    // Initialize Variables
    //
    RtlInitUnicodeString(&JDKeyName, JdName);

    RtlInitUnicodeString(&Skew1KeyName, Skew1Name); 

    RtlInitUnicodeString(&GBGKeyName, GbgName);

    RtlInitUnicodeString(&DataKeyName, DataName);

    InitializeObjectAttributes(
            &JDAttributes, 
            &JDKeyName, 
            OBJ_CASE_INSENSITIVE, 
            0, 
            NULL
            );
    JDAttributes.RootDirectory = hSystemRootKey;

    InitializeObjectAttributes(
            &Skew1Attributes, 
            &Skew1KeyName, 
            OBJ_CASE_INSENSITIVE, 
            0, 
            NULL
            );
    Skew1Attributes.RootDirectory = hSystemRootKey;

    InitializeObjectAttributes(
            &GBGAttributes, 
            &GBGKeyName, 
            OBJ_CASE_INSENSITIVE, 
            0, 
            NULL
            );
    GBGAttributes.RootDirectory = hSystemRootKey;

    InitializeObjectAttributes(
            &DataAttributes, 
            &DataKeyName, 
            OBJ_CASE_INSENSITIVE, 
            0, 
            NULL
            );
    DataAttributes.RootDirectory = hSystemRootKey;

    RtlZeroMemory(Class, sizeof(Class));
    RtlZeroMemory(WClass, sizeof(WClass));


    RtlInitUnicodeString(&UnicodeString, WClass);
    RtlInitAnsiString(&AnsiString, Class);

    UnicodeString.Length = (DATA_SIZE - 1) * sizeof(WCHAR);
    UnicodeString.MaximumLength = DATA_SIZE * sizeof(WCHAR);
    AnsiString.Length = (DATA_SIZE - 1) * sizeof(WCHAR);
    AnsiString.MaximumLength = DATA_SIZE * sizeof(CHAR);


    j = ProtoHash.Digest ;

    //
    // JD
    // 

    NtStatus = ZwOpenKey(&JDKey, 
                         KEY_READ, 
                         &JDAttributes
                         );

    ErrorReturn(NtStatus);

    NtStatus = ZwQueryKey(JDKey, 
                          KeyNodeInformation, 
                          KeyInfo, 
                          sizeof(KeyInfo), 
                          &RequiredKeyInfoLength
                          );

    ZwClose(JDKey);
    
    ErrorReturn(NtStatus);

    RtlCopyMemory(WClass, 
                  KeyInfo + ((PKEY_NODE_INFORMATION)KeyInfo)->ClassOffset, 
                  ((PKEY_NODE_INFORMATION)KeyInfo)->ClassLength 
                  );

    NtStatus = RtlUnicodeStringToAnsiString(&AnsiString, 
                                            &UnicodeString, 
                                            FALSE      // do not allocate buffer 
                                            );

    ErrorReturn(NtStatus);

    
    for ( i = 0 ; i < 8 ; i += 2 )
    {
        t = FromHex( Class[ i ] );
        t2 = FromHex( Class[ i+1 ] );
        if ( (t >= 0 ) && ( t2 >= 0 ) )
        {
            *j++ = (t << 4) + t2 ;
        }
        else
        {
            NtStatus = STATUS_INTERNAL_ERROR;
            ErrorReturn(NtStatus);
        }
    }

    //
    // Skew1 
    // 

    NtStatus = ZwOpenKey(&Skew1Key, 
                         KEY_READ, 
                         &Skew1Attributes
                         );

    ErrorReturn(NtStatus);

    NtStatus = ZwQueryKey(Skew1Key, 
                          KeyNodeInformation, 
                          KeyInfo, 
                          sizeof(KeyInfo), 
                          &RequiredKeyInfoLength
                          );

    ZwClose(Skew1Key);
    ErrorReturn(NtStatus);

    RtlCopyMemory(WClass, 
                  KeyInfo + ((PKEY_NODE_INFORMATION)KeyInfo)->ClassOffset, 
                  ((PKEY_NODE_INFORMATION)KeyInfo)->ClassLength 
                  );

    
    NtStatus = RtlUnicodeStringToAnsiString(&AnsiString, 
                                            &UnicodeString, 
                                            FALSE          // do not allocate buffer
                                            );

    ErrorReturn(NtStatus);

    for ( i = 0 ; i < 8 ; i += 2 )
    {
        t = FromHex( Class[ i ] );
        t2 = FromHex( Class[ i+1 ] );
        if ( (t >= 0 ) && ( t2 >= 0 ) )
        {
            *j++ = (t << 4) + t2 ;
        }
        else
        {
            NtStatus = STATUS_INTERNAL_ERROR;
            ErrorReturn(NtStatus);
        }
    }

    //
    // GBG 
    // 

    NtStatus = ZwOpenKey(&GBGKey, 
                         KEY_READ, 
                         &GBGAttributes
                         );

    ErrorReturn(NtStatus);

    NtStatus = ZwQueryKey(GBGKey, 
                          KeyNodeInformation, 
                          KeyInfo, 
                          sizeof(KeyInfo), 
                          &RequiredKeyInfoLength
                          );


    ZwClose(GBGKey);
    ErrorReturn(NtStatus);

    RtlCopyMemory(WClass, 
                  KeyInfo + ((PKEY_NODE_INFORMATION)KeyInfo)->ClassOffset, 
                  ((PKEY_NODE_INFORMATION)KeyInfo)->ClassLength 
                  );

    
    NtStatus = RtlUnicodeStringToAnsiString(&AnsiString, 
                                            &UnicodeString, 
                                            FALSE          // do not allocate buffer
                                            );

    ErrorReturn(NtStatus); 
   
    for ( i = 0 ; i < 8 ; i += 2 )
    {
        t = FromHex( Class[ i ] );
        t2 = FromHex( Class[ i+1 ] );
        if ( (t >= 0 ) && ( t2 >= 0 ) )
        {
            *j++ = (t << 4) + t2 ;
        }
        else
        {
            NtStatus = STATUS_INTERNAL_ERROR;
            ErrorReturn(NtStatus);
        }
    }


    //
    // Data 
    // 

    NtStatus = ZwOpenKey(&DataKey, 
                         KEY_READ, 
                         &DataAttributes
                         );

    ErrorReturn(NtStatus);

    NtStatus = ZwQueryKey(DataKey, 
                          KeyNodeInformation, 
                          KeyInfo, 
                          sizeof(KeyInfo), 
                          &RequiredKeyInfoLength
                          );

    ZwClose(DataKey);
    ErrorReturn(NtStatus);

    RtlCopyMemory(WClass, 
                  KeyInfo + ((PKEY_NODE_INFORMATION)KeyInfo)->ClassOffset, 
                  ((PKEY_NODE_INFORMATION)KeyInfo)->ClassLength 
                  );

    
    NtStatus = RtlUnicodeStringToAnsiString(&AnsiString, 
                                            &UnicodeString, 
                                            FALSE          // do not allocate buffer
                                            );

    ErrorReturn(NtStatus);

    for ( i = 0 ; i < 8 ; i += 2 )
    {
        t = FromHex( Class[ i ] );
        t2 = FromHex( Class[ i+1 ] );
        if ( (t >= 0 ) && ( t2 >= 0 ) )
        {
            *j++ = (t << 4) + t2 ;
        }
        else
        {
            NtStatus = STATUS_INTERNAL_ERROR;
            ErrorReturn(NtStatus);
        }
    }


    for ( i = 0 ; i < 16 ; i++ )
    {
        Hash->Digest[ KeyShuffle[ i ] ] = ProtoHash.Digest[ i ] ;
    }


    return NtStatus;

}




NTSTATUS
WxReadSysKeyForRecovery(
    IN HANDLE hSystemRootKey,
    IN OUT PULONG BufferLength,
    OUT PVOID  Key 
    )
 /*++

    Routine Description

    This routine is used to retrieve the syskey from
    the registry

    Paramaeters

        hSystemRootKey Handle of the root of the System Hive

        BufferLength  is filled in with the length required on output
                      is used to indicate the size of the buffer 
                      pointed to by Key.
        Key           Points to a buffer into which the key is recieved

    Return Values

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL
        STATUS_BUFFER_OVERFLOW
        STATUS_INTERNAL_ERROR
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    WXHASH H;

    if ((NULL==Key) || (*BufferLength <sizeof(H.Digest)))
    {
        *BufferLength = sizeof(H.Digest);
        return(STATUS_BUFFER_OVERFLOW);
    }

    NtStatus = WxpDeobfuscateKeyForRecovery(hSystemRootKey, 
                                            &H
                                            );

    if (NT_SUCCESS(NtStatus))
    {
          *BufferLength = sizeof(H.Digest);
          RtlCopyMemory(
                  Key,
                  &H.Digest,
                  *BufferLength
                  );

          return(STATUS_SUCCESS);
    }

    return (NtStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\ntdsupg\ntdsupg.c ===
/*++

Copyright (C) Microsoft Corporation, 1998.
              Microsoft Windows

Module Name:

    NTDSUPG.C

Abstract:   

    This file is used to check NT4 (or any downlevel) Backup Domain 
    Controller upgrading first problem. If the NT4 Primary Domain 
    Controller has not been upgraded yet, we should disable NT4 BDC
    upgrading.

Author:     

    ShaoYin 05/01/98

Environment:

    User Mode - Win32

Revision History:

    ShaoYin 05/01/98  Created Initial File.

--*/

#pragma hdrstop

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <tchar.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmcons.h>
#include <lmserver.h>
#include <lmerr.h>
#include <limits.h>

#include "comp.h"
#include "msgs.h"
#include "dsconfig.h"


#define NEEDED_DISK_SPACE_MB (250)
#define NEEDED_DISK_SPACE_BYTES (NEEDED_DISK_SPACE_MB * 1024 * 1024)


DWORD
GetDiskSpaceSizes (
    PULARGE_INTEGER dbSize, 
    PULARGE_INTEGER freeDiskBytes,
    char *driveAD
);


BOOL
WINAPI
DsUpgradeCompatibilityCheck(
    PCOMPAIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context)
{
    int         Response = 0;
    ULONG       Length = 0;
    HMODULE     ResourceDll;
    WCHAR       *DescriptionString = NULL;
    WCHAR       *CaptionString = NULL;
    WCHAR       *WarningString = NULL;
    TCHAR       TextFileName[] = TEXT("compdata\\ntdsupg.txt");
    TCHAR       HtmlFileName[] = TEXT("compdata\\ntdsupg.htm");
    TCHAR       DefaultCaption[] = TEXT("Windows NT Domain Controller Upgrade Checking");
    TCHAR       DefaultDescription[] = TEXT("Primary Domain Controller should be upgraded first");
    TCHAR       DefaultWarning[] = TEXT("Before upgrading any Backup Domain Controller, you should upgrade your Primary Domain Controller first.\n\nClick Yes to continue, click No to exit from setup.");
    
    WCHAR       *DiskSpaceCaptionString = NULL;
    WCHAR       *DiskSpaceDescriptionString = NULL;
    WCHAR       *DiskSpaceErrorString = NULL;
    WCHAR       *DiskSpaceWarningString = NULL;
    TCHAR       DiskSpaceTextFileName[] = TEXT("compdata\\ntdsupgd.txt");
    TCHAR       DiskSpaceHtmlFileName[] = TEXT("compdata\\ntdsupgd.htm");
    TCHAR       DiskSpaceDefaultCaption[] = TEXT("Windows NT Domain Controller Disk Space Checking");
    TCHAR       DiskSpaceDefaultDescription[] = TEXT("Not enough disk space for Active Directory upgrade");
    TCHAR       DiskSpaceDefaultError[] = TEXT("Setup has detected that you may not have enough disk space for the Active Directory upgrade.\nTo complete the upgrade make sure that %1!u! MB of free space are available on drive %2!hs!.");
    TCHAR       DiskSpaceDefaultWarning[] = TEXT("Setup was unable to detect the amount of free space on the partition that the Active Directory resides. To complete the upgrade, make sure you have at least 250MB free on the partition the Active Directory resides, and press OK.\nTo exit Setup click Cancel.");

    ULARGE_INTEGER dbSize, diskFreeBytes, neededSpace;
    DWORD       dwNeededDiskSpaceMB = NEEDED_DISK_SPACE_MB;
    LPVOID      lppArgs[2];
    char        driveAD[10];
    DWORD       dwErr;

    COMPATIBILITY_ENTRY CompEntry;
    OSVERSIONINFO       OsVersion;
    NT_PRODUCT_TYPE     Type;
    BYTE*               pInfo = NULL;
    BYTE*               pPDCInfo = NULL;
    LPBYTE              pPDCName = NULL;
    PSERVER_INFO_101    pSrvInfo = NULL;
    NET_API_STATUS      NetStatus;

    
    //
    // initialize variables
    // 
    RtlZeroMemory(&CompEntry, sizeof(COMPATIBILITY_ENTRY));


    // get the string from resource table.
    ResourceDll = (HMODULE) LoadLibrary( L"NTDSUPG.DLL" );

    if (ResourceDll) {

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                        ResourceDll, 
                                        NTDSUPG_CAPTION,
                                        0, 
                                        (LPWSTR)&CaptionString, 
                                        0, 
                                        NULL
                                        );
        if (CaptionString) {
            // Messages from message file have a cr and lf appended to the end
            CaptionString[Length-2] = L'\0';
        }

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                        ResourceDll, 
                                        NTDSUPG_DESCRIPTION,
                                        0, 
                                        (LPWSTR)&DescriptionString, 
                                        0, 
                                        NULL
                                        );
        if (DescriptionString) {
            DescriptionString[Length-2] = L'\0';
        }

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                        ResourceDll, 
                                        NTDSUPG_WARNINGMESSAGE,
                                        0, 
                                        (LPWSTR)&WarningString, 
                                        0, 
                                        NULL
                                        );
        if (WarningString) {
            WarningString[Length-2] = L'\0';
        }


        // read the DiskSpace related messages
        //

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                        ResourceDll, 
                                        NTDSUPG_DISKSPACE_CAPTION,
                                        0, 
                                        (LPWSTR)&DiskSpaceCaptionString, 
                                        0, 
                                        NULL
                                        );
        if (DiskSpaceCaptionString) {
            DiskSpaceCaptionString[Length-2] = L'\0';
        }


        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                        ResourceDll, 
                                        NTDSUPG_DISKSPACE_DESC,
                                        0, 
                                        (LPWSTR)&DiskSpaceDescriptionString, 
                                        0, 
                                        NULL
                                        );

        if (DiskSpaceDescriptionString) {
            DiskSpaceDescriptionString[Length-2] = L'\0';
        }

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                        ResourceDll, 
                                        NTDSUPG_DISKSPACE_WARNING,
                                        0, 
                                        (LPWSTR)&DiskSpaceWarningString, 
                                        0, 
                                        NULL
                                        );
        if (DiskSpaceWarningString) {
            DiskSpaceWarningString[Length-2] = L'\0';
        }
    }

    // use default messages if read from DLL failed
    //

    if (DescriptionString == NULL) {
        DescriptionString = DefaultDescription;
    }

    if (CaptionString == NULL) {
        CaptionString = DefaultCaption;
    }

    if (WarningString == NULL) {
        WarningString = DefaultWarning;
    }

    if (DiskSpaceDescriptionString == NULL) {
        DiskSpaceDescriptionString = DiskSpaceDefaultDescription;
    }

    if (DiskSpaceCaptionString == NULL) {
        DiskSpaceCaptionString = DiskSpaceDefaultCaption;
    }

    if (DiskSpaceWarningString == NULL) {
        DiskSpaceWarningString = DiskSpaceDefaultWarning;
    }


    // check NT, upgrade, DC os, DC role, PDC os
    // in ProcessCompatibilityData, verify NT and Upgrade
    // so at here, only need to check OS version, and DC role, PDC OS.

    OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (!GetVersionEx(&OsVersion)) {
        goto DsUpgradeCompError;
    }
    
    if (OsVersion.dwMajorVersion < 5) {     // downlevel NT

        // The routine (DsUpgradeCompatibilityCheck) is called after
        // winnt32 determines the host machine is running NT, so 
        // ntdll.dll has been loaded. safe to call RtlGetNtProductType
        // directly.
        RtlGetNtProductType(&Type);

        if (Type == NtProductLanManNt) {    // DC

            NetStatus = NetServerGetInfo(NULL,
                                         101,
                                         &pInfo 
                                         );
            
            if (NetStatus != NERR_Success) {
                goto DsUpgradeCompError;
            }

            pSrvInfo = (PSERVER_INFO_101) pInfo;

            if (pSrvInfo->sv101_type & SV_TYPE_DOMAIN_BAKCTRL) { // BDC

                NetStatus = NetGetDCName(NULL,
                                         NULL,
                                         &pPDCName
                                         );

                if (NetStatus != NERR_Success) {
                    goto DsUpgradeCompError;
                }

                NetStatus = NetServerGetInfo((LPWSTR)pPDCName,
                                             101,
                                             &pPDCInfo
                                             );

                if (NetStatus != NERR_Success) {
                    goto DsUpgradeCompError;
                }

                pSrvInfo = (PSERVER_INFO_101) pPDCInfo;

                if (pSrvInfo->sv101_version_major < 5) { 
                    
                    // PDC has not been upgraded yet
                    // stop upgrading
                    CompEntry.Description   = DescriptionString;
                    CompEntry.HtmlName      = HtmlFileName;
                    CompEntry.TextName      = TextFileName;
                    CompEntry.RegKeyName    = NULL;
                    CompEntry.RegValName    = NULL;
                    CompEntry.RegValDataSize= 0;
                    CompEntry.RegValData    = NULL;
                    CompEntry.SaveValue     = NULL;
                    CompEntry.Flags         = 0;
                 
                    CompatibilityCallback(&CompEntry, Context);
                }
            }
        }
    }
    // this is an upgrade from win2K->win2k. we have to check for disk space
    // since AD might be running
    else {

        // if this is not a DC, then we don't have to check for diskspace
        //

        RtlGetNtProductType(&Type);
        
        if (Type != NtProductLanManNt) {
            goto DsUpgradeCompCleanup;
        }

        // check for enough free disk space for the DS database
        //

        if ((dwErr = GetDiskSpaceSizes (&dbSize, &diskFreeBytes, driveAD)) != ERROR_SUCCESS) {
            goto DsUpgradeDiskSpaceError;
        }

        // we need 10% of database size or at least 250MB 
        //

        if ((dbSize.QuadPart > 10 * diskFreeBytes.QuadPart) ||
            (diskFreeBytes.QuadPart < NEEDED_DISK_SPACE_BYTES )) {

            neededSpace.QuadPart = dbSize.QuadPart / 10;

            if (neededSpace.QuadPart < NEEDED_DISK_SPACE_BYTES) {
                dwNeededDiskSpaceMB = NEEDED_DISK_SPACE_MB;
            }
            else {
                // convert it to MB
                neededSpace.QuadPart = neededSpace.QuadPart / 1024;
                neededSpace.QuadPart = neededSpace.QuadPart / 1024;

                if (neededSpace.HighPart) {
                    dwNeededDiskSpaceMB = UINT_MAX;
                }
                else {
                    dwNeededDiskSpaceMB = neededSpace.LowPart;
                }
            }

            // now we have an estimate of the needed free space, so read string one more time
            //
            if (ResourceDll) {

                if (DiskSpaceWarningString != NULL && DiskSpaceWarningString != DiskSpaceDefaultWarning) {
                    LocalFree(DiskSpaceWarningString);
                    DiskSpaceWarningString = NULL;
                }

                lppArgs[0] = (void *)(DWORD_PTR)dwNeededDiskSpaceMB;
                lppArgs[1] = (void *)driveAD;

                Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                                FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                                                FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                                ResourceDll, 
                                                NTDSUPG_DISKSPACE_ERROR,
                                                0, 
                                                (LPWSTR)&DiskSpaceErrorString, 
                                                0, 
                                                (va_list *)lppArgs
                                                );

                if (DiskSpaceErrorString) {
                    DiskSpaceErrorString[Length-2] = L'\0';
                }
                else {
                    DiskSpaceErrorString = DiskSpaceDefaultError;
                }
            }

            Response = MessageBox(NULL, 
                                  DiskSpaceErrorString, 
                                  DiskSpaceCaptionString,
                                  MB_OK | MB_ICONQUESTION | 
                                  MB_SYSTEMMODAL | MB_DEFBUTTON2
                                  );

            CompEntry.Description   = DiskSpaceDescriptionString;
            CompEntry.HtmlName      = DiskSpaceHtmlFileName;
            CompEntry.TextName      = DiskSpaceTextFileName; 
            CompEntry.RegKeyName    = NULL;
            CompEntry.RegValName    = NULL;
            CompEntry.RegValDataSize= 0;
            CompEntry.RegValData    = NULL;
            CompEntry.SaveValue     = NULL;
            CompEntry.Flags         = 0;

            CompatibilityCallback(&CompEntry, Context);
        }

    }

    // exit 

    goto DsUpgradeCompCleanup;

DsUpgradeDiskSpaceError:

    Response = MessageBox(NULL, 
                          DiskSpaceWarningString, 
                          DiskSpaceCaptionString,
                          MB_OKCANCEL | MB_ICONQUESTION | 
                          MB_SYSTEMMODAL | MB_DEFBUTTON2
                          );

    if (Response == IDCANCEL) {

        CompEntry.Description   = DiskSpaceDescriptionString;
        CompEntry.HtmlName      = DiskSpaceHtmlFileName;
        CompEntry.TextName      = DiskSpaceTextFileName; 
        CompEntry.RegKeyName    = NULL;
        CompEntry.RegValName    = NULL;
        CompEntry.RegValDataSize= 0;
        CompEntry.RegValData    = NULL;
        CompEntry.SaveValue     = NULL;
        CompEntry.Flags         = 0;

        CompatibilityCallback(&CompEntry, Context);
    }

    goto DsUpgradeCompCleanup;


DsUpgradeCompError:

    Response = MessageBox(NULL, 
                          WarningString, 
                          CaptionString,
                          MB_YESNO | MB_ICONQUESTION | 
                          MB_SYSTEMMODAL | MB_DEFBUTTON2
                          );

    if (Response == IDNO) {

        CompEntry.Description   = DescriptionString;
        CompEntry.HtmlName      = NULL;
        CompEntry.TextName      = TextFileName; 
        CompEntry.RegKeyName    = NULL;
        CompEntry.RegValName    = NULL;
        CompEntry.RegValDataSize= 0;
        CompEntry.RegValData    = NULL;
        CompEntry.SaveValue     = NULL;
        CompEntry.Flags         = 0;
     
        CompatibilityCallback(&CompEntry, Context);
    }


DsUpgradeCompCleanup:

    FreeLibrary(ResourceDll);

    if (pInfo != NULL) {
        NetApiBufferFree(pInfo);
    }
    if (pPDCInfo != NULL) {
        NetApiBufferFree(pPDCInfo);
    }
    if (pPDCName != NULL) {
        NetApiBufferFree(pPDCName);
    }

    if (CaptionString != NULL && CaptionString != DefaultCaption) {
        LocalFree(CaptionString);
    }

    if (WarningString != NULL && WarningString != DefaultWarning) {
        LocalFree(WarningString);
    }

    if (DescriptionString != NULL && DescriptionString != DefaultDescription) {
        LocalFree(DescriptionString);
    }

    if (DiskSpaceCaptionString != NULL && DiskSpaceCaptionString != DiskSpaceDefaultCaption) {
        LocalFree(DiskSpaceCaptionString);
    }

    if (DiskSpaceDescriptionString != NULL && DiskSpaceDescriptionString != DiskSpaceDefaultDescription) {
        LocalFree(DiskSpaceDescriptionString);
    }
    
    if (DiskSpaceWarningString != NULL && DiskSpaceWarningString != DiskSpaceDefaultWarning) {
        LocalFree(DiskSpaceWarningString);
    }
    
    if (DiskSpaceErrorString != NULL && DiskSpaceErrorString != DiskSpaceDefaultError) {
        LocalFree(DiskSpaceErrorString);
    }
    
    return ((PCOMPATIBILITY_CONTEXT)Context)->Count;
}                
             


DWORD GetDiskSpaceSizes (PULARGE_INTEGER dbSize, PULARGE_INTEGER freeDiskBytes, char *driveAD)
{
    HKEY            hKey;
    DWORD           dwErr;
    DWORD           dwType;
    DWORD           cbData;
    char            pszDbFilePath[MAX_PATH];
    char            pszDbDir[MAX_PATH];
    char            *pTmp;
    DWORD           dwSuccess = ERROR_SUCCESS;
    HANDLE          hFind;
    WIN32_FIND_DATAA FindFileData;
    ULARGE_INTEGER i64FreeBytesToCaller, i64TotalBytes, i64FreeBytes;


    if ( dwErr = RegOpenKeyA(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hKey) )
    {
        return dwErr;
    }

    _try
    {
        cbData = sizeof(pszDbFilePath);
        dwErr = RegQueryValueExA(    hKey, 
                                    FILEPATH_KEY, 
                                    NULL,
                                    &dwType, 
                                    (LPBYTE) pszDbFilePath, 
                                    &cbData);

        if ( ERROR_SUCCESS != dwErr )
        {
            dwSuccess = dwErr;
            _leave;
        } 
        else if ( cbData > sizeof(pszDbFilePath) )
        {
            dwSuccess = 1;
            _leave;
        }
        else
        {
            strcpy(pszDbDir, pszDbFilePath);
            pTmp = strrchr(pszDbDir, (int) '\\');  //find last occurence
    
            if ( !pTmp )
            {
                dwSuccess = 2;
                _leave;
            }
            else
            {
                *pTmp = '\0';
            }

            driveAD[0] = pszDbDir[0];
            driveAD[1] = pszDbDir[1];
            driveAD[2] = '\0';
        }


        // find DB size

        _try
        {
            hFind = FindFirstFileA(pszDbFilePath, &FindFileData);

            if (hFind == INVALID_HANDLE_VALUE) {
                dwSuccess = 3;
            }
            else {
                dbSize->HighPart = FindFileData.nFileSizeHigh; 
                dbSize->LowPart  = FindFileData.nFileSizeLow; 
            }
        }
        _finally
        {
            FindClose(hFind);;
        }


        // find disk free size
        //

        if (dwSuccess == ERROR_SUCCESS) {
            if (!GetDiskFreeSpaceExA (pszDbDir,
                (PULARGE_INTEGER)&i64FreeBytesToCaller,
                (PULARGE_INTEGER)&i64TotalBytes,
                (PULARGE_INTEGER)&i64FreeBytes) ) {

                dwSuccess = 4;
            }
            else {
                *freeDiskBytes = i64FreeBytes;
            }
        }
    }
    _finally
    {
        RegCloseKey(hKey);
    }

    return dwSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\alias.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    alias.c

Abstract:

    This file contains services related to the SAM "alias" object.


Author:

    Chad Schwitters (chads) 15-Jan-1992

Environment:

    User Mode - Win32

Revision History:

    7-1-96  - MURLIS - Modified to Use DS.


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



#include <samsrvp.h>
#include <msaudite.h>
#include <dslayer.h>
#include <dsmember.h>
#include <ridmgr.h>
#include <samtrace.h>



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
SampAddAccountToAlias(
    IN PSAMP_OBJECT AccountContext,
    IN PSID AccountSid,
    IN DSNAME * AccountDn OPTIONAL
    );

NTSTATUS
SampRemoveAccountFromAlias(
    IN PSAMP_OBJECT AccountContext,
    IN PSID AccountSid,
    IN DSNAME * AccountDn OPTIONAL
    );

NTSTATUS
SampAddAliasToAccountMembership(
    IN PSAMP_OBJECT AliasContext,
    IN PSID AccountSid
    );

NTSTATUS
SampRemoveAliasFromAccountMembership(
    IN PSAMP_OBJECT AliasContext,
    IN PSID AccountSid
    );

NTSTATUS
SampRemoveAliasFromAllAccounts(
    IN PSAMP_OBJECT AliasContext
    );

NTSTATUS
SampDeleteAliasKeys(
    IN PSAMP_OBJECT Context
    );

NTSTATUS
SampRetrieveAliasMembers(
    IN PSAMP_OBJECT AliasContext,
    IN PULONG MemberCount,
    IN PSID **Members OPTIONAL
    );

NTSTATUS
SampDeleteAliasMembershipKeysForAccount(
    IN PSID AccountSid
    );

NTSTATUS
SampAdjustAliasDomainsCount(
    IN BOOLEAN Increment
    );

NTSTATUS
SampValidateNewAliasMember(
    IN PSAMP_OBJECT AccountContext,
    IN PSID MemberId,
    IN DSNAME * MemberName OPTIONAL
    );

NTSTATUS
SampAddMemberToAliasActual(
    IN  PSAMP_OBJECT    AccountContext,
    IN  PSID            MemberId,
    IN  DSNAME          *MemberName OPTIONAL
    );

NTSTATUS
SampRemoveMemberFromAliasActual(
    IN  PSAMP_OBJECT    AccountContext,
    IN  PSID            MemberId,
    IN  DSNAME          *MemberName OPTIONAL
    );

NTSTATUS
SampGetDomainSidListForSam(
    PULONG pcDomainSids,
    PSID   **rgDomainSids,
    PULONG pcEnterpriseSids,
    PSID   **rgEnterpriseSids
   );


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Exposed RPC'able Services                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////




NTSTATUS
SamrOpenAlias(
    IN SAM_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG AliasId,
    OUT PSAM_HANDLE AliasHandle
    )

/*++

Routine Description:

    This API opens an existing Alias object.  The Alias is specified by
    a ID value that is relative to the SID of the domain.  The operations
    that will be performed on the Alias must be declared at this time.

    This call returns a handle to the newly opened Alias that may be used
    for successive operations on the Alias.  This handle may be closed
    with the SamCloseHandle API.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    DesiredAccess - Is an access mask indicating which access types are
        desired to the alias.

    AliasId - Specifies the relative ID value of the Alias to be opened.

    AliasHandle - Receives a handle referencing the newly opened Alias.
        This handle will be required in successive calls to operate on
        the Alias.

Return Values:

    STATUS_SUCCESS - The Alias was successfully opened.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.

    STATUS_NO_SUCH_ALIAS - The specified Alias does not exist.

    STATUS_INVALID_HANDLE - The domain handle passed is invalid.


--*/
{
    NTSTATUS            NtStatus;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrOpenAlias");

    // WMI event trace
    
    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidOpenAlias
                   );

    NtStatus = SampOpenAccount(
                   SampAliasObjectType,
                   DomainHandle,
                   DesiredAccess,
                   AliasId,
                   FALSE,
                   AliasHandle
                   );

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    // WMI event trace
    
    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidOpenAlias
                   );

    return(NtStatus);
}



NTSTATUS
SamrQueryInformationAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN ALIAS_INFORMATION_CLASS AliasInformationClass,
    OUT PSAMPR_ALIAS_INFO_BUFFER *Buffer
    )

/*++

Routine Description:

    This API retrieves information on the alias specified.



Parameters:

    AliasHandle - The handle of an opened alias to operate on.

    AliasInformationClass - Class of information to retrieve.  The
        accesses required for each class is shown below:

        Info Level                      Required Access Type
        -----------------------         ----------------------

        AliasGeneralInformation         ALIAS_READ_INFORMATION
        AliasNameInformation            ALIAS_READ_INFORMATION
        AliasAdminInformation           ALIAS_READ_INFORMATION

    Buffer - Receives a pointer to a buffer containing the requested
        information.  When this information is no longer needed, this
        buffer and any memory pointed to through this buffer must be
        freed using SamFreeMemory().

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

--*/
{

    NTSTATUS                NtStatus;
    NTSTATUS                IgnoreStatus;
    PSAMP_OBJECT            AccountContext;
    SAMP_OBJECT_TYPE        FoundType;
    ACCESS_MASK             DesiredAccess;
    ULONG                   i;
    BOOLEAN                 fLockAcquired = FALSE;
   

    //
    // Used for tracking allocated blocks of memory - so we can deallocate
    // them in case of error.  Don't exceed this number of allocated buffers.
    //                                      ||
    //                                      vv
    PVOID                   AllocatedBuffer[10];
    ULONG                   AllocatedBufferCount = 0;
    DECLARE_CLIENT_REVISION(AliasHandle);

    SAMTRACE_EX("SamrQueryInformationAlias");

    // WMI event trace
    
    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidQueryInformationAlias
                   );


    #define RegisterBuffer(Buffer)                                      \
        {                                                               \
            if ((Buffer) != NULL) {                                     \
                                                                        \
                ASSERT(AllocatedBufferCount <                           \
                       sizeof(AllocatedBuffer) / sizeof(*AllocatedBuffer)); \
                                                                        \
                AllocatedBuffer[AllocatedBufferCount++] = (Buffer);     \
            }                                                           \
        }

    #define AllocateBuffer(NewBuffer, Size)                             \
        {                                                               \
            (NewBuffer) = MIDL_user_allocate(Size);                     \
            RegisterBuffer(NewBuffer);                                  \
        }                                                               \



    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (Buffer != NULL);
    ASSERT ((*Buffer) == NULL);

    if (!((Buffer!=NULL)&&(*Buffer==NULL)))
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }


    //
    // Set the desired access based upon the Info class
    //

    switch (AliasInformationClass) {

    case AliasGeneralInformation:
    case AliasNameInformation:
    case AliasAdminCommentInformation:
    case AliasReplicationInformation:

        DesiredAccess = ALIAS_READ_INFORMATION;
        break;

    default:
        (*Buffer) = NULL;
        NtStatus = STATUS_INVALID_INFO_CLASS;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;


    } // end_switch



    //
    // Allocate the info structure
    //

    AllocateBuffer( *Buffer, sizeof(SAMPR_ALIAS_INFO_BUFFER) );
    if ((*Buffer) == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }


    //
    // Acquire the read lock if required
    //

    AccountContext = (PSAMP_OBJECT)AliasHandle;
    SampMaybeAcquireReadLock(AccountContext, 
                             DEFAULT_LOCKING_RULES,
                             &fLockAcquired);


    //
    // Validate type of, and access to object.
    //


    NtStatus = SampLookupContext(
                   AccountContext,
                   DesiredAccess,
                   SampAliasObjectType,           // ExpectedType
                   &FoundType
                   );


    if (NT_SUCCESS(NtStatus)) {

        //
        // case on the type information requested
        //

        switch (AliasInformationClass) {

        case AliasGeneralInformation:
        case AliasReplicationInformation:


            if (AliasGeneralInformation==AliasInformationClass)
            {

                //
                // Get the member count
                //

                NtStatus = SampRetrieveAliasMembers(
                               AccountContext,
                               &(*Buffer)->General.MemberCount,
                               NULL                                 // Only need members
                               );
            }
            else
            {
                (*Buffer)->General.MemberCount=0;
            }

            if (NT_SUCCESS(NtStatus)) {

                //
                // Get copies of the strings we must retrieve from
                // the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_ALIAS_NAME,
                               TRUE,    // Make copy
                               (PUNICODE_STRING)&((*Buffer)->General.Name)
                               );

                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->General.Name.Buffer);

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_ALIAS_ADMIN_COMMENT,
                                   TRUE,    // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->General.AdminComment)
                                   );

                    if (NT_SUCCESS(NtStatus)) {
                        RegisterBuffer((*Buffer)->General.AdminComment.Buffer);
                    }
                }
            }


            break;


        case AliasNameInformation:

            //
            // Get copies of the strings we must retrieve from
            // the registry.
            //

            NtStatus = SampGetUnicodeStringAttribute(
                           AccountContext,
                           SAMP_ALIAS_NAME,
                           TRUE,    // Make copy
                           (PUNICODE_STRING)&((*Buffer)->Name.Name)
                           );

            if (NT_SUCCESS(NtStatus)) {
                RegisterBuffer((*Buffer)->Name.Name.Buffer);
            }

            break;


        case AliasAdminCommentInformation:

            //
            // Get copies of the strings we must retrieve from
            // the registry.
            //

            NtStatus = SampGetUnicodeStringAttribute(
                           AccountContext,
                           SAMP_ALIAS_ADMIN_COMMENT,
                           TRUE,    // Make copy
                           (PUNICODE_STRING)&((*Buffer)->AdminComment.AdminComment)
                           );

            if (NT_SUCCESS(NtStatus)) {
                RegisterBuffer((*Buffer)->AdminComment.AdminComment.Buffer);
            }


            break;

        }   // end_switch


        //
        // De-reference the object, discard any changes
        //

        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Free the read lock
    //

    SampMaybeReleaseReadLock(fLockAcquired);



    //
    // If we didn't succeed, free any allocated memory
    //

    if (!NT_SUCCESS(NtStatus)) {
        for ( i=0; i<AllocatedBufferCount ; i++ ) {
            MIDL_user_free( AllocatedBuffer[i] );
        }

        (*Buffer) = NULL;
    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    // WMI event trace
    
    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidQueryInformationAlias
                   );

    return(NtStatus);
}



NTSTATUS
SamrSetInformationAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN ALIAS_INFORMATION_CLASS AliasInformationClass,
    IN PSAMPR_ALIAS_INFO_BUFFER Buffer
    )

/*++

Routine Description:

    This API allows the caller to modify alias information.


Parameters:

    AliasHandle - The handle of an opened alias to operate on.

    AliasInformationClass - Class of information to retrieve.  The
        accesses required for each class is shown below:

        Info Level                      Required Access Type
        ------------------------        -------------------------

        AliasGeneralInformation         (can't write)

        AliasNameInformation            ALIAS_WRITE_ACCOUNT
        AliasAdminCommentInformation    ALIAS_WRITE_ACCOUNT

    Buffer - Buffer where information retrieved is placed.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_NO_SUCH_ALIAS - The alias specified is unknown.

    STATUS_SPECIAL_ALIAS - The alias specified is a special alias and
        cannot be operated on in the requested fashion.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

--*/
{

    NTSTATUS                NtStatus;
    NTSTATUS                TmpStatus;
    NTSTATUS                IgnoreStatus;

    PSAMP_OBJECT            AccountContext;

    SAMP_OBJECT_TYPE        FoundType;

    ACCESS_MASK             DesiredAccess;

    UNICODE_STRING          OldAccountName,
                            NewAccountName;

    ULONG                   AliasRid = 0;

    BOOLEAN                 Modified = FALSE,
                            RemoveAccountNameFromTable = FALSE, 
                            AccountNameChanged = FALSE;
    DECLARE_CLIENT_REVISION(AliasHandle);

    SAMTRACE_EX("SamrSetInformationAlias");

    // WMI event trace
    
    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidSetInformationAlias
                   );


    RtlInitUnicodeString(&OldAccountName, NULL);
    RtlInitUnicodeString(&NewAccountName, NULL);



    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    if (Buffer == NULL) {
        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }



    //
    // Set the desired access based upon the Info class
    //

    switch (AliasInformationClass) {

    case AliasNameInformation:
    case AliasAdminCommentInformation:

        DesiredAccess = ALIAS_WRITE_ACCOUNT;
        break;


    case AliasGeneralInformation:
    default:

        NtStatus = STATUS_INVALID_INFO_CLASS;
        goto  Error;

    } // end_switch



    //
    // Grab the lock
    //

    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }



    //
    // Validate type of, and access to object.
    //

    AccountContext = (PSAMP_OBJECT)AliasHandle;
    NtStatus = SampLookupContext(
                   AccountContext,
                   DesiredAccess,
                   SampAliasObjectType,           // ExpectedType
                   &FoundType
                   );



    if (NT_SUCCESS(NtStatus)) {


        //
        // case on the type information requested
        //

        switch (AliasInformationClass) {

        case AliasNameInformation:

            NtStatus = SampChangeAliasAccountName(
                            AccountContext,
                            (PUNICODE_STRING)&(Buffer->Name.Name),
                            &OldAccountName
                            );

            if (!NT_SUCCESS(NtStatus)) {
                OldAccountName.Buffer = NULL;
            }

            //
            // RemoveAccountNameFromTable tells us whether
            // the caller (this routine) is responsable 
            // to remove the name from the table. 
            // 
            RemoveAccountNameFromTable = 
                    AccountContext->RemoveAccountNameFromTable;

            // 
            // Reset to FALSE 
            //
            AccountContext->RemoveAccountNameFromTable = FALSE;

            //
            // Don't delete the old account name yet; we'll still need
            // to pass it to Netlogon below.
            //

            AccountNameChanged = TRUE;

            break;


        case AliasAdminCommentInformation:

            NtStatus = SampSetUnicodeStringAttribute(
                           AccountContext,
                           SAMP_ALIAS_ADMIN_COMMENT,
                           (PUNICODE_STRING)&(Buffer->AdminComment.AdminComment)
                           );

            break;


        } // end_switch

        //
        // Go fetch AccountName  
        // Do this before we dereference the context
        //

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_ALIAS_NAME,
                               TRUE,    // Make copy
                               &NewAccountName
                               );
        }


        //
        // Dereference the account context
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // Save object RID before dereferencing context.
            // RID is used in SampNotifyNetlogonOfDelta() call.
            //

            AliasRid = AccountContext->TypeBody.Alias.Rid;

            //
            // De-reference the object, write out any change to current xaction.
            //

            NtStatus = SampDeReferenceContext( AccountContext, TRUE );

        } else {

            //
            // De-reference the object, ignore changes
            //

            TmpStatus = SampDeReferenceContext( AccountContext, FALSE );
            ASSERT(NT_SUCCESS(TmpStatus));
        }

    } //end_if

    //
    // Commit the transaction and notify netlogon of any changes
    //

    if ( NT_SUCCESS(NtStatus) ) {

        NtStatus = SampCommitAndRetainWriteLock();

        //
        // Generate audit if necessary, after Commit() succeeded.
        //

        if ((NT_SUCCESS(NtStatus) &&
            SampDoAccountAuditing(AccountContext->DomainIndex))) {

            // audit account name change
            if (AccountNameChanged)
            {
                SampAuditAccountNameChange(AccountContext, 
                                           (PUNICODE_STRING)&(Buffer->Name.Name),
                                           &OldAccountName
                                           );
            }

            //
            // generate a more generic alias change audit
            // the following audit is generated for RPC client only.   
            // ldap client (loopback) client will not go through this code 
            // path, GroupChange audit is generate in SampNotifyReplicatedinChange()
            // for loopback client. 
            // 
            // RPC client can modify Security Enabled Resource Group Only.
            // 

            SampAuditGroupChange(AccountContext->DomainIndex,
                                 &NewAccountName,
                                 &(AccountContext->TypeBody.Alias.Rid),
                                 (GROUP_TYPE_SECURITY_ENABLED | GROUP_TYPE_RESOURCE_GROUP)
                                 );
        }


        if (( NT_SUCCESS(NtStatus) ) &&
            (AccountContext->TypeBody.Alias.SecurityEnabled)){

            ASSERT((0 != AliasRid) && "AliasRid not been initialized\n");

            if ( AliasInformationClass == AliasNameInformation ) {

                SampNotifyNetlogonOfDelta(
                    SecurityDbRename,
                    SecurityDbObjectSamAlias,
                    AliasRid,
                    &OldAccountName,
                    (DWORD) FALSE,  // Replicate immediately
                    NULL            // Delta data
                    );

            } else {

                SampNotifyNetlogonOfDelta(
                    SecurityDbChange,
                    SecurityDbObjectSamAlias,
                    AliasRid,
                    NULL,
                    (DWORD) FALSE,  // Replicate immediately
                    NULL            // Delta data
                    );
            }
        }
    }


    //
    // Free up our old account name if we have one
    //

    SampFreeUnicodeString( &OldAccountName );
    SampFreeUnicodeString( &NewAccountName );

    //
    // Remove the New Account Name from the Global
    // SAM Account Name Table
    // 
    if (RemoveAccountNameFromTable)
    {
        IgnoreStatus = SampDeleteElementFromAccountNameTable(
                            (PUNICODE_STRING)&(Buffer->Name.Name),
                            SampAliasObjectType
                            );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Now release the write lock and return, propogating any errors.
    //

    TmpStatus = SampReleaseWriteLock( FALSE );
    ASSERT(NT_SUCCESS(TmpStatus));


    if (NT_SUCCESS(NtStatus)) {
        NtStatus = TmpStatus;
    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    // WMI event trace
    
    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidSetInformationAlias
                   );

    return(NtStatus);

}



NTSTATUS
SamrDeleteAlias(
    IN SAM_HANDLE *AliasHandle
    )

/*++

Routine Description:

    This API deletes an Alias from the account database.  The Alias does
    not have to be empty.

    Note that following this call, the AliasHandle is no longer valid.



Parameters:

    AliasHandle - The handle of an opened Alias to operate on.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.



--*/
{
    UNICODE_STRING          AliasName;
    NTSTATUS                NtStatus, TmpStatus, IgnoreStatus;
    PSAMP_OBJECT            AccountContext = (PSAMP_OBJECT) (*AliasHandle);
    PSAMP_DEFINED_DOMAINS   Domain;
    SAMP_OBJECT_TYPE        FoundType;
    BOOLEAN                 fLockAcquired = FALSE;
    ULONG                   AliasRid,
                            DomainIndex;
    DECLARE_CLIENT_REVISION(*AliasHandle);


    SAMTRACE_EX("SamrDeleteAlias");


    // WMI event trace
    
    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidDeleteAlias
                   );


    //
    // Grab the lock
    //

    NtStatus = SampMaybeAcquireWriteLock(AccountContext, &fLockAcquired);
    if (!NT_SUCCESS(NtStatus)) {
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }



    //
    // Validate type of, and access to object.
    //

    NtStatus = SampLookupContext(
                   AccountContext,
                   DELETE,
                   SampAliasObjectType,           // ExpectedType
                   &FoundType
                   );



    if (NT_SUCCESS(NtStatus)) {

        AliasRid = AccountContext->TypeBody.Alias.Rid;

        //
        // Get a pointer to the domain this object is in.
        // This is used for auditing.
        //

        DomainIndex = AccountContext->DomainIndex;
        Domain = &SampDefinedDomains[ DomainIndex ];

        //
        // Make sure the account is one that can be deleted.
        // Can't be a built-in account, unless caller is trusted.
        //

        if ( !AccountContext->TrustedClient ) {

            NtStatus = SampIsAccountBuiltIn( AliasRid );
        }

        if (NT_SUCCESS(NtStatus)) {


            //
            // Remove this alias from every account's alias-membership list
            //

            NtStatus = SampRemoveAliasFromAllAccounts(AccountContext);


            if (NT_SUCCESS(NtStatus)) {

                //
                // First get and save the account name for
                // I_NetNotifyLogonOfDelta.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_ALIAS_NAME,
                               TRUE,    // Make copy
                               &AliasName
                               );

                if (NT_SUCCESS(NtStatus)) {

                    //
                    // This must be done before we invalidate contexts, because our
                    // own handle to the alias gets closed as well.
                    //

                    if (IsDsObject(AccountContext))
                    {
                        NtStatus = SampDsDeleteObject(AccountContext->ObjectNameInDs, 
                                                      0             // Delete the object itself
                                                      );
                                                      
                        //
                        // In Windows 2000 (NT5), an object has children cannot be
                        // deleted till its children are deleted first. Thus for 
                        // Net API compatibility, we have to change the 
                        // delete behavior from a delete object to delete tree.
                        // 
                    
                        if ((!AccountContext->LoopbackClient) &&
                            (STATUS_DS_CANT_ON_NON_LEAF == NtStatus)
                           )
                        {
                            //
                            // We only checked the right and access control for
                            // deleting the object itself, not check the right to 
                            // delete all the children underneath, so turn off fDSA
                            // here, let core DS do the rest of check.
                            // 
                        
                            SampSetDsa(FALSE);
                        
                            NtStatus = SampDsDeleteObject(AccountContext->ObjectNameInDs, 
                                                          SAM_DELETE_TREE
                                                          );
                        }
                                                      
                        if (NT_SUCCESS(NtStatus) && (!IsDsObject(AccountContext)) )
                        {
                            //
                            // Decrement the group count ONLY in Registry case
                            //

                            NtStatus = SampAdjustAccountCount(SampAliasObjectType, FALSE);
                        }

                    }
                    else
                    {
                        NtStatus = SampDeleteAliasKeys( AccountContext );
                    }

                    if (NT_SUCCESS(NtStatus)) {

                        //
                        // We must invalidate any open contexts to this alias
                        // This will close all handles to the alias's keys.
                        // THIS IS AN IRREVERSIBLE PROCESS.
                        //

                        SampInvalidateObjectContexts( AccountContext, AliasRid );

                        //
                        // Commit the whole mess
                        //

                        NtStatus = SampCommitAndRetainWriteLock();

                        if ( NT_SUCCESS( NtStatus ) ) {

                            //
                            // Update the Alias Information Cache in Registry Mode
                            //

                            if (!IsDsObject(AccountContext))
                            {
                                IgnoreStatus = SampAlDeleteAlias( AliasHandle );
                            }

                            //
                            // Audit the deletion before we free the write lock
                            // so that we have access to the context block.
                            //

                            //
                            // N.B. Deletion audits in the DS are performed in 
                            // the notification routine on transaction commit.
                            //
                            if (SampDoAccountAuditing(DomainIndex) &&
                                (!IsDsObject(AccountContext)) &&
                                NT_SUCCESS(NtStatus) ) {

                                SampAuditGroupDelete(DomainIndex,
                                                     &AliasName,
                                                     &AliasRid,
                                                     GROUP_TYPE_RESOURCE_GROUP |
                                                     GROUP_TYPE_SECURITY_ENABLED);

                            }

                            //
                            // Notify netlogon of the change
                            //

                            if (AccountContext->TypeBody.Alias.SecurityEnabled)
                            {
                                SampNotifyNetlogonOfDelta(
                                    SecurityDbDelete,
                                    SecurityDbObjectSamAlias,
                                    AliasRid,
                                    &AliasName,
                                    (DWORD) FALSE,  // Replicate immediately
                                    NULL            // Delta data
                                    );
                            }

                            //
                            // Do delete auditing
                            //

                            if (NT_SUCCESS(NtStatus)) {
                                (VOID) NtDeleteObjectAuditAlarm(
                                            &SampSamSubsystem,
                                            *AliasHandle,
                                            AccountContext->AuditOnClose
                                            );
                            }


                        }
                    }

                    SampFreeUnicodeString( &AliasName );
                }
            }
        }



        //
        // De-reference the object, discard any changes
        //

        TmpStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(TmpStatus));


        if ( NT_SUCCESS( NtStatus ) ) {

            //
            // If we actually deleted the alias, then delete the context
            // and let RPC know that the handle is invalid.
            //

            SampDeleteContext( AccountContext );

            (*AliasHandle) = NULL;
        }

    } //end_if

    //
    // Free the lock -
    //
    // Everything has already been committed above, so we must indicate
    // no additional changes have taken place.
    //

    TmpStatus = SampMaybeReleaseWriteLock( fLockAcquired, FALSE );

    if (NtStatus == STATUS_SUCCESS) {
        NtStatus = TmpStatus;
    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    // WMI event trace
    
    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidDeleteAlias
                   );

    return(NtStatus);

}


NTSTATUS
SamrAddMemberToAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN PRPC_SID MemberId
    )

/*++

Routine Description:

    This API adds a member to an alias.  Note that this API requires the
    ALIAS_ADD_MEMBER access type for the alias.


Parameters:

    AliasHandle - The handle of an opened alias to operate on.

    MemberId - SID of the member to add.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.


    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_NO_SUCH_MEMBER - The member specified is unknown.

    STATUS_MEMBER_IN_ALIAS - The member already belongs to the alias.

    STATUS_INVALID_MEMBER - The member has the wrong account type.

    STATUS_INVALID_SID - The member sid is corrupted.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

--*/
{

    NTSTATUS                NtStatus, TmpStatus, IgnoreStatus;
    PSAMP_OBJECT            AccountContext = (PSAMP_OBJECT)(AliasHandle);
    SAMP_OBJECT_TYPE        FoundType;
    DSNAME                  **MemberName=NULL;
    ULONG                   ObjectRid = 0;
    DECLARE_CLIENT_REVISION(AliasHandle);


    SAMTRACE_EX("SamrAddMemberToAlias");
    
    SampTraceEvent(EVENT_TRACE_TYPE_START, 
                   SampGuidAddMemberToAlias
                   ); 

    SampUpdatePerformanceCounters(
        DSSTAT_MEMBERSHIPCHANGES,
        FLAG_COUNTER_INCREMENT,
        0
        );



    //
    // Validate the Sid
    //
    if (!RtlValidSid(MemberId))
    {
        // 
        // the sid doesn't seem all right
        // 
        NtStatus = STATUS_INVALID_SID;
        goto Error;
    }


    //
    // Resolve Sids if necessary. This call can also reference the
    // G.C in the DS case to resolve the Sid to a DS Name. This is
    // a No Op in the registry case. In case the G.C is referenced
    // a thread state will be left behind by this call. This thread
    // state will contain the list of validated names. For the foriegn
    // security principal case an FPO object might be added as a 
    // result of this call.
    //

    NtStatus = SampDsResolveSids(
                    &MemberId,
                    1,
                    RESOLVE_SIDS_ADD_FORIEGN_SECURITY_PRINCIPAL|
                    RESOLVE_SIDS_VALIDATE_AGAINST_GC,
                    &MemberName
                    );

    if (NT_SUCCESS(NtStatus))
    {

        //
        // Grab the lock
        //

        NtStatus = SampAcquireWriteLock();
        if (!NT_SUCCESS(NtStatus)) {

            //
            // Resolve Sids will  leave a thread state in the
            // DS in case it needs to go to the G.C.
            // Need to make sure we close it.
            //

           goto Error;
        }


        //
        // Validate type of, and access to object.
        //

        NtStatus = SampLookupContext(
                       AccountContext,
                       ALIAS_ADD_MEMBER,
                       SampAliasObjectType,           // ExpectedType
                       &FoundType
                       );

        // If this is a (B)DC, then allow new members to be added to an alias.

        SampDiagPrint(INFORM,
                  ("SAMSS: AddMemberToAlias SampLookupContext status = 0x%lx\n",
                   NtStatus));


        if (NT_SUCCESS(NtStatus))
        {
            if (IsDsObject(AccountContext))
            {

                //
                // If it is a DS object then  verify whether the member was
                // resolved to a DS Name, as resolve Sids does not check for this
                //

                if ((NULL==MemberName) || (NULL==*MemberName))
                {
                    NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
                }
            }

            if (NT_SUCCESS(NtStatus)) {

                NtStatus =  SampAddMemberToAliasActual(
                                AccountContext,
                                MemberId,
                                MemberName?*MemberName:NULL
                                );



            }

            //
            // Dereference the account context
            //

            if (NT_SUCCESS(NtStatus)) {

                //
                // Save object RID before dereferencing context.
                // RID is used in SampNotifyNetlogonOfDelta() call.
                //

                ObjectRid = AccountContext->TypeBody.Alias.Rid;

                //
                // De-reference the object, write out any change to current xaction.
                //

                NtStatus = SampDeReferenceContext( AccountContext, TRUE );

            } else {

                //
                // De-reference the object, ignore changes
                //

                TmpStatus = SampDeReferenceContext( AccountContext, FALSE );
                ASSERT(NT_SUCCESS(TmpStatus));
            }


            if (NT_SUCCESS(NtStatus)) {

                //
                // Commit the whole mess
                //

                NtStatus = SampCommitAndRetainWriteLock();

                if ( NT_SUCCESS( NtStatus ) ) {

                    SAM_DELTA_DATA DeltaData;

                    //
                    // Update the Alias Information Cache in Registry Mode
                    //

                    SAMPR_PSID_ARRAY MemberSids;
                    MemberSids.Count = 1;
                    MemberSids.Sids = (PSAMPR_SID_INFORMATION) &MemberId;

                    if (!IsDsObject(AccountContext))
                    {
                        IgnoreStatus = SampAlAddMembersToAlias(
                                           (SAMPR_HANDLE) AccountContext,
                                           0,
                                           &MemberSids
                                           );
                    }


                    //
                    // Fill in id of member being added
                    //

                    DeltaData.AliasMemberId.MemberSid = MemberId;

                    if (AccountContext->TypeBody.Alias.SecurityEnabled)
                    {
                        ASSERT(ObjectRid && "ObjectRid not initialized\n");

                        SampNotifyNetlogonOfDelta(
                            SecurityDbChangeMemberAdd,
                            SecurityDbObjectSamAlias,
                            ObjectRid,
                            (PUNICODE_STRING) NULL,
                            (DWORD) FALSE,  // Replicate immediately
                            &DeltaData
                            );
                    }
                }

            }
            
        }

        //
        // Release the Lock
        //

        TmpStatus = SampReleaseWriteLock( FALSE );
        ASSERT(NT_SUCCESS(TmpStatus));

    }

Error:

    //
    // Free any memory associated with resolved Sids
    //

    if (NULL!=MemberName)
    {
        if (NULL!=*MemberName)
        {
            MIDL_user_free(*MemberName);
        }

        MIDL_user_free(MemberName);
    }

    if (SampUseDsData)
        SampMaybeEndDsTransaction(TransactionCommit);


    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);
    
    SampTraceEvent(EVENT_TRACE_TYPE_END, 
                   SampGuidAddMemberToAlias
                   );

    return(NtStatus);
}




NTSTATUS
SamrAddMultipleMembersToAlias(
    IN    SAMPR_HANDLE            AliasHandle,
    IN    PSAMPR_PSID_ARRAY       MembersBuffer
    )

/*++

Routine Description:

    This api adds multiple members to an alias.

    NOTE:  For now, this routine takes a brute force approach.
           I tried to do it in a better (more efficient) manner,
           but kept running into problems.  Finally, when I ran
           into problems in the way SAM uses RXACT, I gave up
           and did this brute force approach.

Parameters:

    AliasHandle - The handle of an opened Alias to operate on.

    MembersBuffer - Contains a count of SIDs to be added to the
        alias and a pointer to a buffer containing an array of
        pointers to SIDs.  These SIDs are the SIDs of the members to
        be added to the Alias.


Return Values:

    STATUS_SUCCESS - The Service completed successfully.  All of the
        listed members are now members of the alias.  However, some of
        the members may already have been members of the alias (this is
        NOT an error or warning condition).

    STATUS_ACCESS_DENIED - Caller does not have the object open for
        the required access.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_MEMBER - The member has the wrong account type.

    STATUS_INVALID_SID - The member sid is corrupted.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

--*/
{

    NTSTATUS
        NtStatus;

    LONG
        MemberCount,
        i;

    PSID
        *MemberId;
    DECLARE_CLIENT_REVISION(AliasHandle);


    SAMTRACE_EX("SamrAddMultipleMembersToAlias");

    MemberCount = (LONG)MembersBuffer->Count;
    MemberId    = (PSID *)MembersBuffer->Sids;
    
    //
    // Set completion status in case there are no members
    //

    NtStatus = STATUS_SUCCESS;

    //
    // Validate Parameters
    // 
    if (0 != MemberCount)
    {
        //
        // make sure the client passed us exactly number of SIDs. 
        // 
        if (NULL == MemberId)
        {
            NtStatus = STATUS_INVALID_PARAMETER;
            SAMTRACE_RETURN_CODE_EX(NtStatus);
            return (NtStatus);
        }
    }

    //
    // Loop through the SIDs, adding them to the alias.
    // Ignore any status value indicating the member is already
    // a member.  Other errors, however, will cause us to abort.
    //

    for (i=0; i<MemberCount; i++) {

        NtStatus = SamrAddMemberToAlias( AliasHandle, MemberId[i] );

        if (NtStatus == STATUS_MEMBER_IN_ALIAS) {
            NtStatus = STATUS_SUCCESS;
        }

        if (!NT_SUCCESS(NtStatus)) {
            break; //for loop
        }

    } //end_for
    
    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return(NtStatus);
}


NTSTATUS
SamrRemoveMemberFromAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN PRPC_SID MemberId
    )

/*++

Routine Description:

    This API removes a member from an alias.  Note that this API requires the
    ALIAS_REMOVE_MEMBER access type for the alias.


Parameters:

    AliasHandle - The handle of an opened alias to operate on.

    MemberId - SID of the member to remove.

Return Value:


    ????


--*/
{
    NTSTATUS                NtStatus, TmpStatus, IgnoreStatus;
    PSAMP_OBJECT            AccountContext;
    SAMP_OBJECT_TYPE        FoundType;
    DSNAME                  **MemberName = NULL;
    ULONG                   ObjectRid = 0;
    DECLARE_CLIENT_REVISION(AliasHandle);


    SAMTRACE_EX("SamrRemoveMemberFromAlias");
    
    SampTraceEvent(EVENT_TRACE_TYPE_START, 
                   SampGuidRemoveMemberFromAlias
                   );

    SampUpdatePerformanceCounters(
        DSSTAT_MEMBERSHIPCHANGES,
        FLAG_COUNTER_INCREMENT,
        0
        );

    //
    // Validate the Sid
    //

    if (!RtlValidSid(MemberId))
    {
        // The Sid doesn't have correct structure.
        NtStatus = STATUS_INVALID_SID;
        goto Error;
    }



    //
    // Resolve Sids if necessary. This call can also reference the
    // G.C in the DS case to resolve the Sid to a DS Name. This is
    // a No Op in the registry case. In case the G.C is referenced
    // a thread state will be left behind by this call. This thread
    // state will contain the list of validated names.
    //

    NtStatus = SampDsResolveSids(
                    &MemberId,
                    1,
                    RESOLVE_SIDS_VALIDATE_AGAINST_GC,
                    &MemberName
                    );
    if (NT_SUCCESS(NtStatus))
    {
        //
        // Grab the lock
        //

        NtStatus = SampAcquireWriteLock();
        if (!NT_SUCCESS(NtStatus)) {

            //
            // Resolve Sids will  leave a thread state in the
            // DS in case it needs to go to the G.C.
            // Need to make sure we close it.
            //

           goto Error;
        }

        //
        // Validate type of, and access to object.
        //

        AccountContext = (PSAMP_OBJECT)(AliasHandle);
        NtStatus = SampLookupContext(
                       AccountContext,
                       ALIAS_REMOVE_MEMBER,
                       SampAliasObjectType,           // ExpectedType
                       &FoundType
                       );
        // If this is a (B)DC, then allow members to be removed from an alias.

        SampDiagPrint(INFORM,
                      ("SAMSS: AddMemberToAlias SampLookupContext status = 0x%lx\n",
                       NtStatus));



        //
        // If it is a DS object then  verify whether the member was
        // resolved to a DS Name, as resolve Sids does not check for this
        //

        if (NT_SUCCESS(NtStatus))
        {
            if (IsDsObject(AccountContext))
            {
                if ((NULL==MemberName) || (NULL==*MemberName))
                {
                    NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
                }
            }

            if (NT_SUCCESS(NtStatus)) {

                //
                // Call the actual worker routine
                //

                NtStatus = SampRemoveMemberFromAliasActual(
                                AccountContext,
                                MemberId,
                                MemberName?*MemberName:NULL
                                );


            }

            //
            // Dereference the account context
            //

            if (NT_SUCCESS(NtStatus)) {

                //
                // Save object RID before dereferencing context.
                // RID is used in SampNotifyNetlogonOfDelta() call.
                //

                ObjectRid = AccountContext->TypeBody.Alias.Rid;

                //
                // De-reference the object, write out any change to current xaction.
                //

                NtStatus = SampDeReferenceContext( AccountContext, TRUE );

            } else {

                //
                // De-reference the object, ignore changes
                //

                TmpStatus = SampDeReferenceContext( AccountContext, FALSE );
                ASSERT(NT_SUCCESS(TmpStatus));
            }


            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampCommitAndRetainWriteLock();

                if ( NT_SUCCESS( NtStatus ) ) {

                    SAM_DELTA_DATA DeltaData;

                    //
                    // Update the Alias Information Cache in Registry Mode
                    //

                    SAMPR_PSID_ARRAY MemberSids;
                    MemberSids.Count = 1;
                    MemberSids.Sids = (PSAMPR_SID_INFORMATION) &MemberId;

                    if (!IsDsObject(AccountContext))
                    {
                        IgnoreStatus = SampAlRemoveMembersFromAlias(
                                           (SAMPR_HANDLE) AccountContext,
                                           0,
                                           &MemberSids
                                           );
                    }


                    //
                    // Fill in id of member being deleted
                    //

                    DeltaData.AliasMemberId.MemberSid = MemberId;

                    if (AccountContext->TypeBody.Alias.SecurityEnabled)
                    {
                        ASSERT(ObjectRid && "ObjectRid not initialized\n"); 
                    
                        SampNotifyNetlogonOfDelta(
                            SecurityDbChangeMemberDel,
                            SecurityDbObjectSamAlias,
                            ObjectRid,
                            (PUNICODE_STRING) NULL,
                            (DWORD) FALSE,      // Replicate immediately
                            &DeltaData
                            );
                    }

                }
            }
            
        }

        //
        //  Release the Lock
        //

        TmpStatus = SampReleaseWriteLock( FALSE );
        ASSERT(NT_SUCCESS(TmpStatus));


    }

Error:

    //
    // Free any memory associated with resolved Sids
    //

    if (NULL!=MemberName)
    {
        if (NULL!=*MemberName)
        {
            MIDL_user_free(*MemberName);
        }

        MIDL_user_free(MemberName);
    }

    //
    // Resolve Sids will  leave a thread state in the
    // DS in case it needs to go to the G.C.
    // Need to make sure we close it.
    //

    if (SampUseDsData)
        SampMaybeEndDsTransaction(TransactionCommit);

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);
    
    SampTraceEvent(EVENT_TRACE_TYPE_END, 
                   SampGuidRemoveMemberFromAlias
                   );

    return(NtStatus);

}


NTSTATUS
SamrRemoveMultipleMembersFromAlias(
    IN    SAMPR_HANDLE            AliasHandle,
    IN    PSAMPR_PSID_ARRAY       MembersBuffer
    )

/*++

Routine Description:

    This API removes members from an alias.  Note that this API requires
    the ALIAS_REMOVE_MEMBER access type for the alias.

    NOTE:  This api currently uses a brute-force approach to adding
           members to the alias.  This is because of problems
           encountered when trying to do "the right thing".


Parameters:

    AliasHandle - The handle of an opened alias to operate on.

    MembersBuffer - Contains a count of SIDs to be added to the
        alias and a pointer to a buffer containing an array of
        pointers to SIDs.  These SIDs are the SIDs of the members to
        be added to the Alias.


Return Values:

    STATUS_SUCCESS - The Service completed successfully.  All of the
        listed members are now members of the alias.  However, some of
        the members may already have been members of the alias (this is
        NOT an error or warning condition).

    STATUS_ACCESS_DENIED - Caller does not have the object open for
        the required access.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_SID - The member sid is corrupted.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{

    NTSTATUS
        NtStatus;

    LONG
        MemberCount,
        i;

    PSID
        *MemberId;
    DECLARE_CLIENT_REVISION(AliasHandle);


    SAMTRACE_EX("SamrRemoveMultipleMembersFromAlias");

    MemberCount = (LONG)MembersBuffer->Count;
    MemberId    = (PSID *)MembersBuffer->Sids;
    

    //
    // Set completion status in case there are no members
    //

    NtStatus = STATUS_SUCCESS;
    
    //
    // Validate Parameters
    // 
    if (0 != MemberCount)
    {
        //
        // make sure the client passed us exactly number of SIDs. 
        // 
        if (NULL == MemberId)
        {
            NtStatus = STATUS_INVALID_PARAMETER;
            SAMTRACE_RETURN_CODE_EX(NtStatus);
            return (NtStatus);
        }
    }

    //
    // Loop through the SIDs, adding them to the alias.
    // Ignore any status value indicating the member is already
    // a member.  Other errors, however, will cause us to abort.
    //

    for (i=0; i<MemberCount; i++) {

        NtStatus = SamrRemoveMemberFromAlias( AliasHandle, MemberId[i] );

        if (NtStatus == STATUS_MEMBER_NOT_IN_ALIAS) {
            NtStatus = STATUS_SUCCESS;
        }

        if (!NT_SUCCESS(NtStatus)) {
            break; //for loop
        }

    } //end_for

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return(NtStatus);

}


NTSTATUS
SamrGetMembersInAlias(
    IN SAM_HANDLE AliasHandle,
    OUT PSAMPR_PSID_ARRAY GetMembersBuffer
    )

/*++

Routine Description:

    This API lists all members in an Alias.  This API requires
    ALIAS_LIST_MEMBERS access to the Alias.

    NOTE:  This function does not use the Alias cache.


Parameters:

    AliasHandle - The handle of an opened Alias to operate on.

    MemberIds - Receives a pointer to a buffer containing an array of
        pointers to SIDs.  These SIDs are the SIDs of the members of the
        Alias.  When this information is no longer needed, this buffer
        must be freed using SamFreeMemory().

    MemberCount - number of members in the Alias (and, thus, the number
        of relative IDs returned).

Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there are
        no additional entries.

    STATUS_ACCESS_DENIED - Caller does not have privilege required to
        request that data.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

--*/
{
    NTSTATUS                NtStatus, IgnoreStatus;
    PSAMP_OBJECT            AccountContext;
    SAMP_OBJECT_TYPE        FoundType;
    BOOLEAN                 fLockAcquired = FALSE;
    DECLARE_CLIENT_REVISION(AliasHandle);

    SAMTRACE_EX("SamrGetMembersInAlias");

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidGetMembersInAlias
                   );

    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (GetMembersBuffer != NULL);

    //
    // Grab the lock
    //

    AccountContext = (PSAMP_OBJECT)AliasHandle;

    SampMaybeAcquireReadLock(AccountContext, 
                             DEFAULT_LOCKING_RULES,
                             &fLockAcquired);


    //
    // Validate type of, and access to object.
    //


    NtStatus = SampLookupContext(
                   AccountContext,
                   ALIAS_LIST_MEMBERS,
                   SampAliasObjectType,           // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampRetrieveAliasMembers(
                       AccountContext,
                       &(GetMembersBuffer->Count),
                       (PSID **)&(GetMembersBuffer->Sids)
                       );

        //
        // De-reference the object, discarding changes
        //

        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Free the read lock
    //

    SampMaybeReleaseReadLock(fLockAcquired);


    //
    // Tidy up on failure
    //

    if (!NT_SUCCESS(NtStatus)){

        GetMembersBuffer->Count = 0;
        GetMembersBuffer->Sids = NULL;
    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidGetMembersInAlias
                   );

    return(NtStatus);
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Internal Services Available For Use in Other SAM Modules                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
SampRemoveAccountFromAllAliases(
    IN PSID AccountSid,
    IN PDSNAME AccountDsName OPTIONAL,
    IN BOOLEAN CheckAccess,
    IN OPTIONAL SAMPR_HANDLE DomainHandle,
    IN PULONG MembershipCount OPTIONAL,
    IN PULONG *Membership OPTIONAL
    )

/*++

Routine Description:

    This routine removes the specified account from the member list of all
    aliases in this domain.


    The caller of this service is expected to be in the middle of a
    RXACT transaction.  This service simply adds some actions to that
    RXACT transaction.

    This routine is used while deleting a user or a group and hence should
    never be called on a DS domain. ( The DS will maintain the cross consi-
    stency when a user or group is deleted ).



Arguments:

    AccountSid - The SID of the account being Removed.

    AccountDsName -- Optional Parameter specifying the DS Name of the
                Account. This is used in the DS Case.

    CheckAccess - if TRUE, this routine will make sure that the caller
        is allowed REMOVE_ALIAS_MEMBER access to this alias.  If FALSE,
        the caller is already known to have proper access.

    DomainHandle - if CheckAccess is TRUE, this handle must be provided
        to allow access to be checked.  This Handle is also required in
        order to specify wether the Domain is in the DS or registry.

    MembershipCount - if CheckAccess is TRUE, this pointer must be
        provided to receive the number of aliases the account was
        deleted from.

    Membership - if CheckAccess is TRUE, this pointer must be provided
        to point to a list of aliases the account was removed from.  The
        caller must free this list with MIDL_user_free().

Return Value:


    STATUS_SUCCESS - The user has been Removed from all aliases.

--*/
{
    NTSTATUS                NtStatus, IgnoreStatus;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    UNICODE_STRING          DomainKeyName, AccountKeyName;
    HANDLE                  TempHandle, AliasHandle;
    ULONG                   LocalMembershipCount;
    PULONG                  LocalMembership;
    ULONG                   KeyValueLength;
    ULONG                   i;
    PSAMP_OBJECT            DomainContext = (PSAMP_OBJECT)DomainHandle;

    SAMTRACE("SampRemoveAccountFromAllAliases");



    //
    // Need to do Different things for the Ds and Registry cases
    // The way this routine will be called is
    //   1. Either Deleting a Group or User in the Registry Case
    //   2. Or Somebody made a SamrRemoveAccountFromForignDomain call
    //   on us. This is done by the Net API to while deleting a user or
    //   group, to remove their memberships from the aliases in the builtin
    //   domain.
    //
    // In the DS case neither code path have a need to call this function and
    // they do not !!! This is because the Link Table autmotaically maintains
    // Group membership-Reverse Membership Consistency.
    //

    // Assert that nobody calls this in the DS case
    ASSERT(FALSE==SampUseDsData);


    if ((DomainHandle!=NULL) && (IsDsObject(DomainContext)))
    {
        //
        // The Code inside this If Statement will Correctly execute the operations
        // specified by this call in the DS case. Currently it is never called
        // however.
        //
        PSID DomainSid = NULL;
        ULONG cDsNames;
        PDSNAME  *rpDsNames;

        ASSERT(ARGUMENT_PRESENT(AccountDsName));

        //
        // Somebody made a SamrRemoveAccountFromForiegn Domain call.
        //

        if ( CheckAccess ) {
            // In case there is an error, these should be set
            // accordingly
            ASSERT(Membership);
            ASSERT(MembershipCount);
            *Membership = NULL;
            *MembershipCount = 0;
        }

        //
        // Get the reverse membership list. Limit to current domain.
        // No transitive closure, limit to alias objects
        //

        NtStatus = SampGetMemberships(
                        &AccountDsName,
                        1,
                        DomainContext->ObjectNameInDs,   // limiting domain
                        RevMembGetAliasMembership,       // Limit to alias objects
                        &cDsNames,
                        &rpDsNames,
                        NULL,
                        NULL,
                        NULL);


        if (NT_SUCCESS(NtStatus))
        {
            ULONG Index;
            ULONG  Rid;
            PSAMP_OBJECT AliasContext;

            //
            // Set the return parameters so the caller of this function
            // knows what aliases have been changed
            //
            if ( CheckAccess ) {
                // We will increment *MembershipCount as they are opened
                *Membership = MIDL_user_allocate(cDsNames * sizeof(ULONG));
                if ( !*Membership ) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            //
            //  Walk the returned list of Sids and remove the Sid from the
            //  membership list.
            //


            for (Index=0;Index<cDsNames;Index++)
            {
                DSNAME * AliasObjectName = NULL;

                //
                // Split the Sid to find the Rid
                //

                ASSERT(rpDsNames[Index]->SidLen>0);

                NtStatus = SampSplitSid(
                                &(rpDsNames[Index]->Sid),
                                NULL,
                                &Rid
                                );

                if (NT_SUCCESS(NtStatus))
                {
                    //
                    // Do an Open account. This both finds the Object Name
                    // plus checks for any necessary permissions
                    //

                    SampSetTransactionWithinDomain(FALSE);

                    NtStatus = SampOpenAccount(
                                  SampAliasObjectType,
                                  DomainHandle,
                                  ALIAS_REMOVE_MEMBER,
                                  Rid,
                                  TRUE,
                                  (SAMPR_HANDLE *)&AliasContext
                                  );



                    if  (NT_SUCCESS(NtStatus))
                    {

                        //
                        //  Delete the Membership
                        //

                        IgnoreStatus = SampDsRemoveMembershipAttribute(
                                            AliasContext->ObjectNameInDs,
                                            SampAliasObjectType,
                                            AccountDsName
                                            );

                        SampDeleteContext((PSAMP_OBJECT)(AliasContext));

                        if (CheckAccess) {
                            (*Membership)[Index] = Rid;
                            *MembershipCount += 1;
                        }

                    }
                }
            }
        }

    }
    else
    {
        PSAMP_OBJECT AliasContext = NULL;

        //
        // Registry Case
        //

        ASSERT(FALSE==SampUseDsData);

        //
        // Get the alias membership for this account
        //

        NtStatus = SampBuildAliasMembersKeyName(
                       AccountSid,
                       &DomainKeyName,
                       &AccountKeyName
                       );
        if (NT_SUCCESS(NtStatus)) {

            InitializeObjectAttributes(
                &ObjectAttributes,
                &AccountKeyName,
                OBJ_CASE_INSENSITIVE,
                SampKey,
                NULL
                );

            SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

            NtStatus = RtlpNtOpenKey(
                           &TempHandle,
                           (KEY_READ),
                           &ObjectAttributes,
                           0
                           );

            if ((NtStatus == STATUS_OBJECT_PATH_NOT_FOUND) ||
                (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) ) {

                //
                // This account is not a member of any of our aliases
                //

                NtStatus = STATUS_SUCCESS;

                if ( CheckAccess ) {

                    //
                    // Return the list of aliases the account was
                    // removed from; in this case, none.
                    //

                    ( *MembershipCount ) = 0;
                    ( *Membership ) = NULL;
                }

            } else {

                //
                // Load in the alias membership list
                //

                if (NT_SUCCESS(NtStatus)) {

                    KeyValueLength = 0;

                    NtStatus = RtlpNtQueryValueKey( TempHandle,
                                                    &LocalMembershipCount,
                                                    NULL,
                                                    &KeyValueLength,
                                                    NULL);

                    SampDumpRtlpNtQueryValueKey(&LocalMembershipCount,
                                                NULL,
                                                &KeyValueLength,
                                                NULL);

                    if (NT_SUCCESS(NtStatus)) {
                        ASSERT(LocalMembershipCount == 0);
                    }

                    if (NtStatus == STATUS_BUFFER_OVERFLOW) {

                        LocalMembership = MIDL_user_allocate( KeyValueLength );

                        if (LocalMembership == NULL) {
                            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        } else {

                            NtStatus = RtlpNtQueryValueKey(
                                           TempHandle,
                                           NULL,
                                           LocalMembership,
                                           &KeyValueLength,
                                           NULL);

                            SampDumpRtlpNtQueryValueKey(NULL,
                                                        LocalMembership,
                                                        &KeyValueLength,
                                                        NULL);

                            if (NT_SUCCESS(NtStatus)) {

                                //
                                // Remove the account from each alias
                                //

                                for (i=0; i < LocalMembershipCount; i++) {

                                    if ( CheckAccess ) {

                                        //
                                        // If account is being removed from
                                        // the ADMIN alias, change ACL to
                                        // allow account operators to access
                                        // the account (unless account is an
                                        // admin some other way).  Kind of
                                        // useless since the account is about
                                        // to be deleted, but do it anyway
                                        // in case something bad happens and
                                        // it doesn't get deleted.
                                        //

                                        //
                                        // Admin Count on the object is checked
                                        // for these purpose inside of 
                                        // SampChangeAccountOperatorAccess
                                        // ToMember
                                        //

                                        if ( LocalMembership[i] ==
                                            DOMAIN_ALIAS_RID_ADMINS ) {

                                            NtStatus = SampChangeAccountOperatorAccessToMember(
                                                           AccountSid,
                                                           RemoveFromAdmin,
                                                           NoChange );
                                        }

                                        //
                                        // Just open and close the alias
                                        // to make sure we are allowed
                                        // the necessary access.
                                        //

                                        SampSetTransactionWithinDomain(FALSE);

                                        NtStatus = SampOpenAccount(
                                                       SampAliasObjectType,
                                                       DomainHandle,
                                                       ALIAS_REMOVE_MEMBER,
                                                       LocalMembership[i],
                                                       TRUE,
                                                       (SAMPR_HANDLE *)&AliasHandle
                                                       );

                                        if (NT_SUCCESS(NtStatus)) {

                                            SampDeleteContext(
                                                (PSAMP_OBJECT)( AliasHandle ) );
                                        }
                                    }

                                    if (!NT_SUCCESS(NtStatus)) {
                                        break;
                                    }

                                    NtStatus = SampCreateAccountContext(
                                                   SampAliasObjectType,
                                                   LocalMembership[i],
                                                   TRUE,  // Trusted client
                                                   FALSE, // Loopback client
                                                   TRUE,  // Account exists
                                                   &AliasContext
                                                   );

                                    if (NT_SUCCESS(NtStatus)) {

                                        NtStatus = SampRemoveAccountFromAlias(
                                                       AliasContext,
                                                       AccountSid,
                                                       NULL
                                                       );

                                        if (NT_SUCCESS(NtStatus)) {

                                            //
                                            // Save the alias changes we just
                                            // made.  We'll delete the context,
                                            // so don't let RXACT use the open
                                            // key handle in the context.
                                            //

                                            NtStatus = SampStoreObjectAttributes(
                                                           AliasContext,
                                                           FALSE
                                                           );
                                        }

                                        SampDeleteContext(AliasContext);
                                    }

                                    if (!NT_SUCCESS(NtStatus)) {
                                        break;
                                    }
                                }

                                //
                                // Delete the account membership keys
                                //

                                if (NT_SUCCESS(NtStatus)) {

                                    NtStatus = SampDeleteAliasMembershipKeysForAccount(
                                                    AccountSid);
                                }

                            }

                            if ( CheckAccess ) {

                                //
                                // Return the list of aliases the account was
                                // removed from.
                                //

                                ( *MembershipCount ) = LocalMembershipCount;
                                ( *Membership ) = LocalMembership;

                            } else {

                                MIDL_user_free(LocalMembership);
                            }
                        }
                    }

                    IgnoreStatus = NtClose( TempHandle );
                    ASSERT( NT_SUCCESS(IgnoreStatus) );
                }
            }

            SampFreeUnicodeString( &DomainKeyName );
            SampFreeUnicodeString( &AccountKeyName );

        }
    }

    return( NtStatus );
}




NTSTATUS
SampRetrieveAliasMembership(
    IN PSID Account,
    IN DSNAME * AccountDn OPTIONAL,
    OUT PULONG MemberCount OPTIONAL,
    IN OUT PULONG BufferSize OPTIONAL,
    OUT PULONG Buffer OPTIONAL
    )

/*++
Routine Description:

    This service retrieves the number of aliases in the current domain
    that the specified account is a member of. If desired it will also fill
    in a buffer with the alias rids.


    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().


Arguments:

    Account - the account whose membership we are interested in.

    AccountDn - The DN of the account. Is passed in during the DS case. NULL for
                the registry case.

    MemberCount - Receives the number of current-domain-aliases the
                  account is a member of.

    BufferSize - (Optional) Specified the size of memory pointer to by buffer.

    Buffer - (Otional) Is filled in with the list of alias membership rids.
        If this value is NULL, then this information
        is not returned.  The returned buffer is allocated using
        MIDL_user_allocate() and must be freed using MIDL_user_free() when
        no longer needed.

Return Value:


    STATUS_SUCCESS - The information has been retrieved.

    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated for the
        string to be returned in.

    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            NtQueryValueKey()



--*/
{

    NTSTATUS                NtStatus, IgnoreStatus;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    UNICODE_STRING          DomainKeyName, AccountKeyName;
    HANDLE                  TempHandle;
    PSAMP_OBJECT            DomainContext;

    SAMTRACE("SampRetrieveAliasMembership");


    DomainContext =  SampDefinedDomains[SampTransactionDomainIndex].Context;


    if (IsDsObject(DomainContext))
    {
        //
        // DS Case
        //

        ASSERT(ARGUMENT_PRESENT(AccountDn));

        NtStatus = SampDsGetAliasMembershipOfAccount(
                        DomainContext->ObjectNameInDs,
                        AccountDn,
                        MemberCount,
                        BufferSize,
                        Buffer
                        );
    }
    else
    {
        //
        // Get the membership count for this account
        //

        NtStatus = SampBuildAliasMembersKeyName(
                       Account,
                       &DomainKeyName,
                       &AccountKeyName
                       );
        if (NT_SUCCESS(NtStatus)) {

            InitializeObjectAttributes(
                &ObjectAttributes,
                &AccountKeyName,
                OBJ_CASE_INSENSITIVE,
                SampKey,
                NULL
                );

            SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

            NtStatus = RtlpNtOpenKey(
                           &TempHandle,
                           (KEY_READ),
                           &ObjectAttributes,
                           0
                           );

            if ((NtStatus == STATUS_OBJECT_PATH_NOT_FOUND) ||
                (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) ) {

                //
                // This account is not a member of any of our aliases
                //

                NtStatus = STATUS_SUCCESS;

                if (ARGUMENT_PRESENT(MemberCount)) {
                    *MemberCount = 0;
                }
                if (ARGUMENT_PRESENT(BufferSize)) {
                    *BufferSize = 0;
                }

            } else {

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = RtlpNtQueryValueKey( TempHandle,
                                                    MemberCount,
                                                    Buffer,
                                                    BufferSize,
                                                    NULL);

                    SampDumpRtlpNtQueryValueKey(MemberCount,
                                                Buffer,
                                                BufferSize,
                                                NULL);

                    IgnoreStatus = NtClose( TempHandle );
                    ASSERT( NT_SUCCESS(IgnoreStatus) );
                }
            }

            SampFreeUnicodeString( &DomainKeyName );
            SampFreeUnicodeString( &AccountKeyName );

        }
    }

    return( NtStatus );

}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Services Private to this file                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////




NTSTATUS
SampAddAccountToAlias(
    IN PSAMP_OBJECT AccountContext,
    IN PSID AccountSid,
    IN DSNAME * AccountDn OPTIONAL
    )

/*++

Routine Description:

    This service is used to add an account as a member of a specified alias
    This is done by simply adding the account SID to the list of SIDs
    in the MEMBERS attribute of the the specified alias


    The caller of this service is expected to be in the middle of a
    RXACT transaction.  This service simply edits the in-memory copy of
    the alias information.


Arguments:

    AccountContext - Context block Describing the Alias

    AccountSid - The Sid of the account being added as a new member.

    AccountDn  - For DS cases only, the DN of the account

Return Value:

    STATUS_SUCCESS - The account was added.

--*/

{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       MemberCount, i;
    ULONG       MemberArraySize;
    PSID        MemberArray;
    PWCHAR      MemberStringName = NULL;

    SAMTRACE("SampAddAccountToAlias");


    //
    // Need to do different things for DS and Registry
    //

    if (IsDsObject(AccountContext))
    {

        //
        // DS based Domain
        //

        ASSERT(AccountDn!=NULL);

        //
        // Get Member account string name if available, 
        // for auditing propose 
        // 
        if (AccountDn->NameLen && AccountDn->StringName)
        {
            MemberStringName = AccountDn->StringName;
        }

        //
        // Add this entry to the Ds. In Loopback case, buffer the membership operation in object 
        // context. By doing so, we can speed up multiple membership add / remove operations.
        //

        if (AccountContext->BufferWrites)
        {
            NtStatus = SampDsAddMembershipOperationToCache(
                                            AccountContext,
                                            ADD_VALUE,
                                            AccountDn 
                                            );
        }
        else 
        {
            NtStatus = SampDsAddMembershipAttribute(
                        AccountContext->ObjectNameInDs,
                        SampAliasObjectType,
                        AccountDn
                        );
        }

        //
        // Map Error Codes
        //

        if (STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS==NtStatus)
        {
            NtStatus = STATUS_MEMBER_IN_ALIAS;
        }

    }
    else
    {

        //
        //  Regisry based Domain
        //

        NtStatus = SampGetSidArrayAttribute(
                        AccountContext,
                        SAMP_ALIAS_MEMBERS,
                        FALSE,  // Reference directly
                        &MemberArray,
                        &MemberArraySize,
                        &MemberCount
                        );

        if (NT_SUCCESS(NtStatus)) {

            PSID MemberPointer = MemberArray;

            //
            // Check the member is really new
            //

            for (i = 0; i<MemberCount ; i++ ) {

                if (RtlEqualSid(MemberPointer, AccountSid)) {

                    NtStatus = STATUS_MEMBER_IN_ALIAS;
                    break;
                }

                ((PCHAR)MemberPointer) += RtlLengthSid(MemberPointer);
            }



            if (NT_SUCCESS(NtStatus)) {

                //
                // MemberPointer now points at the byte beyond the end of the
                // old member array
                //

                //
                // Allocate a new membership buffer large enough for the existing
                // member list and the new one.
                //

                ULONG OldTotalSize = (ULONG)(((PCHAR)MemberPointer) - ((PCHAR)MemberArray));
                ULONG NewMemberSize = RtlLengthSid(AccountSid);
                ULONG NewTotalSize = OldTotalSize + NewMemberSize;
                PSID NewMemberArray;


                NewMemberArray = MIDL_user_allocate( NewTotalSize );

                if (NewMemberArray == NULL) {

                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    //
                    // Copy the member list into the new array
                    //

                    RtlCopyMemory(NewMemberArray, MemberArray, OldTotalSize);

                    //
                    // Add the new member to the end
                    //

                    MemberCount += 1;

                    NtStatus = RtlCopySid(
                                        NewMemberSize,
                                        ((PCHAR)NewMemberArray) + OldTotalSize,
                                        AccountSid);

                    if (NT_SUCCESS(NtStatus)) {

                        //
                        // Update the alias with it's new member list
                        //

                        NtStatus = SampSetSidArrayAttribute(
                                        AccountContext,
                                        SAMP_ALIAS_MEMBERS,
                                        NewMemberArray,
                                        NewTotalSize,
                                        MemberCount
                                        );
                        }

                    //
                    // Free up the membership array we allocated
                    //

                    MIDL_user_free( NewMemberArray );
                }

            }
        }
    //
    // End of Registry Part
    //

    }

    //
    // Account has been added to alias membership
    // audit this, if necessary.
    //

    if (NT_SUCCESS(NtStatus) &&
        SampDoAccountAuditing(AccountContext->DomainIndex)) {

        //
        // Audit this member add operation
        // 
        SampAuditGroupMemberChange(AccountContext,  // Alias Context  
                                   TRUE,            // Add Member
                                   MemberStringName,// Member Name
                                   NULL,            // Member RID
                                   AccountSid       // Member SID
                                   );
    }

    return(NtStatus);
}



NTSTATUS
SampRemoveAccountFromAlias(
    IN PSAMP_OBJECT AccountContext,
    IN PSID AccountSid,
    IN DSNAME * AccountDn  OPTIONAL
    )

/*++

Routine Description:

    This routine is used to Remove an account from a specified alias.
    This is done by simply Removing the user's Sid From the list of Sids
    in the MEMBERS sub-key of the the specified alias.

    It is the caller's responsibility to know that the user is, in fact,
    currently a member of the alias.


    The caller of this service is expected to be in the middle of a
    RXACT transaction.  This service simply adds some actions to that
    RXACT transaction.


Arguments:

    AliasRid - The RID of the alias the account is to be removed from.

    AccountSid - The SID of the account being Removed.

    AccountDn  - The DS Name of the account for DS cases

Return Value:


    STATUS_SUCCESS - The user has been Removed.

    STATUS_MEMBER_NOT_IN_ALIAS - The account was not a member of the alias.

--*/
{
    NTSTATUS    NtStatus =STATUS_SUCCESS;
    ULONG       MemberCount, i;
    ULONG       MemberArraySize;
    PSID        MemberArray, Member, NextMember;
    PWCHAR      MemberStringName = NULL;

    ULONG RemovedMemberSize = RtlLengthSid(AccountSid);

    SAMTRACE("SampRemoveAccountFromAlias");

    //
    // Test wether we are DS based
    //

    if (IsDsObject(AccountContext))
    {

        ASSERT(AccountDn!=NULL);

        //
        // Get Member String Name if available for auditing propose
        //
        if (AccountDn->NameLen && AccountDn->StringName)
        {
            MemberStringName = AccountDn->StringName;
        }

        //
        // Remove the account from the membership list
        //
        
        if (AccountContext->BufferWrites)
        {
            NtStatus = SampDsAddMembershipOperationToCache(
                                            AccountContext,
                                            REMOVE_VALUE,
                                            AccountDn 
                                            );
        }
        else 
        {
            NtStatus = SampDsRemoveMembershipAttribute(
                            AccountContext->ObjectNameInDs,
                            SampAliasObjectType,
                            AccountDn
                            );
        }

        //
        // Re Map Error Codes
        //

        if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE==NtStatus)
        {
            NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
        }


    }
    else
    {

        //
        // We are registry based
        //

        //
        // Get a copy of the current member array.
        //

        NtStatus = SampGetSidArrayAttribute(
                        AccountContext,
                        SAMP_ALIAS_MEMBERS,
                        TRUE, // Make copy
                        &MemberArray,
                        &MemberArraySize,
                        &MemberCount
                        );

        if (NT_SUCCESS(NtStatus)) {

            //
            // For each member sid, copy it from old to new member
            // arrays if it is not the sid we're trying to delete
            //

            Member = MemberArray;

            for (i = 0; i < MemberCount ; i++ ) {

                NextMember = (PSID)(((PCHAR)Member) + RtlLengthSid(Member));

                if (RtlEqualSid(Member, AccountSid)) {

                    //
                    // Found the member to delete.  Shift subsequent members
                    //

                    while ((PCHAR)NextMember <
                        (((PCHAR)MemberArray) + MemberArraySize)) {

                        *((PCHAR)Member)++ = *((PCHAR)NextMember)++;
                    }

                    break;
                }

                //
                // Advance the old pointer
                //

                Member = NextMember;

                ASSERT((PCHAR)Member <= (((PCHAR)MemberArray) + MemberArraySize));
            }


            //
            // If nothing was removed, we didn't find the account
            //

            if (i == MemberCount) {

                NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;

            } else {

                //
                // The member has been removed, write out the new member list
                //

                ASSERT((PCHAR)Member ==
                    (((PCHAR)MemberArray)) + MemberArraySize - RemovedMemberSize);

                NtStatus = SampSetSidArrayAttribute(
                                AccountContext,
                                SAMP_ALIAS_MEMBERS,
                                MemberArray,
                                MemberArraySize - RemovedMemberSize,
                                MemberCount - 1
                                );
            }

            //
            // Free up the member array
            //

            MIDL_user_free(MemberArray);
        }
    }

    //
    // audit this, if necessary.
    //

    if (NT_SUCCESS(NtStatus) &&
        SampDoAccountAuditing(AccountContext->DomainIndex)) {

        //
        // Audit the member remove operation
        // 
        SampAuditGroupMemberChange(AccountContext,  // Alias Context 
                                   FALSE,           // Remove Member
                                   MemberStringName,// Member Name
                                   NULL,            // Member RID
                                   AccountSid       // Member SID
                                   );
    }

    return(NtStatus);
}



NTSTATUS
SampAddAliasToAccountMembership(
    IN PSAMP_OBJECT AliasContext,
    IN PSID AccountSid
    )

/*++

Routine Description:

    This service adds the specified alias to the account's membership
    list.  It is not assumed that the caller knows anything about
    the target account.  In particular, the caller doesn't know whether
    the account exists or not, nor whether the account is already a member
    of the alias.

    IN REGISTRY MODE THIS SERVICE MUST BE CALLED 
    WITH THE TRANSACTION DOMAIN SET.

    It is a No-Op for DS based accounts, as no reverse membership list
    is being maintained.

Arguments:

    AliasContext - Object Context of the Alias

    AccountSid - The SID of the account.


Return Value:


    STATUS_SUCCESS - The information has been updated and added to the
        RXACT.

    STATUS_MEMBER_IN_ALIAS - The account is already a member of the
        specified alias.

    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            NtQueryValueKey()
            RtlAddActionToRXact()


--*/
{

    NTSTATUS                NtStatus = STATUS_SUCCESS, IgnoreStatus;
    UNICODE_STRING          DomainKeyName;
    UNICODE_STRING          AccountKeyName;
    HANDLE                  TempHandle;
    ULONG                   MembershipCount, KeyValueLength;
    ULONG                   DomainRidCount;
    ULONG                   i;
    ULONG                   AliasRid = AliasContext->TypeBody.Alias.Rid;  
    PULONG                  MembershipArray = NULL;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    BOOLEAN                 NewAccount;
 

    SAMTRACE("SampAddAliasToAccountMembership");

  //
  // For the DS case this routine is a No Operation as , no reverse membership
  // list is ever maintained. We are guarenteed that the account Sid is in the DS
  // either locally or GC , if the alias is in the DS. If not the Samr Call will
  // fail anyhow
  //




    if (!IsDsObject(AliasContext))
    {

        //
        // Registry Case
        //

        //
        // Assume the account is a member of at least one of our aliases
        //

        NewAccount = FALSE;

        NtStatus = SampBuildAliasMembersKeyName(
                       AccountSid,
                       &DomainKeyName,
                       &AccountKeyName
                       );

        if (NT_SUCCESS(NtStatus)) {

            //
            // Try to open the domain alias/members/(domain) key for this account
            //

            InitializeObjectAttributes(
                &ObjectAttributes,
                &DomainKeyName,
                OBJ_CASE_INSENSITIVE,
                SampKey,
                NULL
                );

            SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

            NtStatus = RtlpNtOpenKey(
                           &TempHandle,
                           (KEY_READ),
                           &ObjectAttributes,
                           0
                           );

            if (NT_SUCCESS(NtStatus)) {

                //
                // Get the current domain rid count
                //

                NtStatus = RtlpNtQueryValueKey(
                                TempHandle,
                                &DomainRidCount,
                                NULL,
                                NULL,
                                NULL);

                SampDumpRtlpNtQueryValueKey(&DomainRidCount,
                                            NULL,
                                            NULL,
                                            NULL);

                IgnoreStatus = NtClose(TempHandle);
                ASSERT(NT_SUCCESS(IgnoreStatus));

            } else {

                if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {

                    //
                    // No other accounts in this domain are members of any of our
                    // aliases.
                    //
                    // Create a new key for this domain with no accounts (rids).
                    //

                    NewAccount = TRUE;

                    DomainRidCount = 0; // No accounts yet

                    NtStatus = RtlAddActionToRXact(
                                   SampRXactContext,
                                   RtlRXactOperationSetValue,
                                   &DomainKeyName,
                                   DomainRidCount,
                                   NULL,
                                   0
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        //
                        // Keep our domain count uptodate
                        //

                        NtStatus = SampAdjustAliasDomainsCount(TRUE);
                    }
                }
            }



            if (NT_SUCCESS(NtStatus)) {

                if (!NewAccount) {

                    //
                    // Try to open the domain alias/members/(domain)/(account) key
                    //

                    InitializeObjectAttributes(
                        &ObjectAttributes,
                        &AccountKeyName,
                        OBJ_CASE_INSENSITIVE,
                        SampKey,
                        NULL
                        );

                    SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

                    NtStatus = RtlpNtOpenKey(
                                   &TempHandle,
                                   (KEY_READ),
                                   &ObjectAttributes,
                                   0
                                   );
                }


                if (NewAccount || (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND)) {

                    //
                    // This account is not a member of any of our aliases yet.
                    //

                    NewAccount = TRUE;

                    //
                    // Set up it's initial membership
                    //

                    MembershipCount = 1;
                    MembershipArray = &AliasRid;

                    NtStatus = STATUS_SUCCESS;  // We're doing fine
                }


                if (NT_SUCCESS(NtStatus) && !NewAccount) {

                    //
                    // This account already exists
                    //
                    // Get the current membership buffer and add the new alias
                    //

                    KeyValueLength = 0;

                    NtStatus = RtlpNtQueryValueKey(
                                    TempHandle,
                                    &MembershipCount,
                                    NULL,
                                    &KeyValueLength,
                                    NULL);

                    SampDumpRtlpNtQueryValueKey(&MembershipCount,
                                                NULL,
                                                &KeyValueLength,
                                                NULL);

                    if (NT_SUCCESS(NtStatus) || (NtStatus == STATUS_BUFFER_OVERFLOW)) {

                        ASSERT(KeyValueLength == (MembershipCount * sizeof(ULONG)));

                        //
                        // Allocate a membership buffer large enough for an
                        // additional member.
                        //

                        KeyValueLength += sizeof(ULONG);
                        MembershipArray = MIDL_user_allocate( KeyValueLength );

                        if (MembershipArray == NULL) {
                            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        } else {

                            NtStatus = RtlpNtQueryValueKey(
                                           TempHandle,
                                           NULL,
                                           MembershipArray,
                                           &KeyValueLength,
                                           NULL);

                            SampDumpRtlpNtQueryValueKey(NULL,
                                                        MembershipArray,
                                                        &KeyValueLength,
                                                        NULL);

                            if (NT_SUCCESS(NtStatus)) {

                                //
                                // See if the account is already a member ...
                                //

                                for (i = 0; i<MembershipCount ; i++ ) {
                                    if ( MembershipArray[i] == AliasRid ) {
                                        MIDL_user_free(MembershipArray);
                                        MembershipArray = NULL;
                                        NtStatus = STATUS_MEMBER_IN_ALIAS;
                                        break;
                                    }
                                }

                                if (NT_SUCCESS(NtStatus)) {

                                    //
                                    // Add the new alias's RID to the end
                                    //

                                    MembershipCount += 1;
                                    MembershipArray[MembershipCount-1] = AliasRid;
                                }
                            }
                            else {
                                MIDL_user_free(MembershipArray);
                                MembershipArray = NULL;
                            }
                        }
                    }

                    //
                    // Close the account key handle
                    //

                    IgnoreStatus = NtClose( TempHandle );
                    ASSERT( NT_SUCCESS(IgnoreStatus) );

                }

                //
                // We now have a new membership list desribed by :
                // MembershipArray, MembershipCount
                //
                // Write it out and free it up
                //

                if (NT_SUCCESS(NtStatus)) {

                    KeyValueLength = MembershipCount * sizeof(ULONG);

                    NtStatus = RtlAddActionToRXact(
                                   SampRXactContext,
                                   RtlRXactOperationSetValue,
                                   &AccountKeyName,
                                   MembershipCount,
                                   MembershipArray,
                                   KeyValueLength
                                   );

                    if (MembershipArray != &AliasRid) {
                        MIDL_user_free( MembershipArray );
                    }
                }

                //
                // If this is a new account, we need to increment the rid count
                // in the account domain.
                //

                if (NewAccount) {

                    //
                    // Increment the domain rid count
                    //

                    NtStatus = RtlAddActionToRXact(
                                   SampRXactContext,
                                   RtlRXactOperationSetValue,
                                   &DomainKeyName,
                                   DomainRidCount + 1,
                                   NULL,
                                   0
                                   );
                }

            }

            SampFreeUnicodeString( &DomainKeyName );
            SampFreeUnicodeString( &AccountKeyName );

        }
    }

    return( NtStatus );

}



NTSTATUS
SampRemoveAliasFromAccountMembership(
    IN PSAMP_OBJECT AliasContext,
    IN PSID AccountSid
    )

/*++

Routine Description:

    This service removes the specified alias from the account's membership
    list.  It is not assumed that the caller knows anything about
    the target account.  In particular, the caller doesn't know whether
    the account exists or not, nor whether the account is really a member
    of the alias.

    This routine removes the reference to the alias from the account's
    membership list, removes the account key if there are no more aliases,
    and removes the domain-sid key if this is the last account in the
    domain.

    THIS SERVICE MUST BE CALLED WITH THE TRANSACTION DOMAIN SET.

    This routine is a No Op for the case where the Alias is in a domain
    defined in the DS.

Arguments:

    AliasContext - Alias Object Context

    AccountSid - The SID of the account.


Return Value:


    STATUS_SUCCESS - The information has been updated and added to the
        RXACT.

    STATUS_NO_SUCH_USER - The account does not exist.

    STATUS_MEMBER_NOT_IN_ALIAS - The account is not a member of the
        specified alias.

    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            NtQueryValueKey()
            RtlAddActionToRXact()



--*/
{

    NTSTATUS                NtStatus=STATUS_SUCCESS, IgnoreStatus;
    UNICODE_STRING          DomainKeyName;
    UNICODE_STRING          AccountKeyName;
    HANDLE                  TempHandle;
    ULONG                   MembershipCount, KeyValueLength, i;
    ULONG                   AliasRid = AliasContext->TypeBody.Alias.Rid;
    PULONG                  MembershipArray;
    OBJECT_ATTRIBUTES       ObjectAttributes;

    SAMTRACE("SampRemoveAliasFromAccountMembership");


    //
    // For the DS case this routine is a No Operation as , no reverse membership
    // list is ever maintained. We are guarenteed that the account Sid is in the DS
    // either locally or GC , if the alias is in the DS. If not the Samr Call will
    // fail anyhow
    //

     if (!IsDsObject(AliasContext))
     {

        //
        // Get the account membership
        //

        NtStatus = SampBuildAliasMembersKeyName(
                       AccountSid,
                       &DomainKeyName,
                       &AccountKeyName
                       );
        if (NT_SUCCESS(NtStatus)) {

            InitializeObjectAttributes(
                &ObjectAttributes,
                &AccountKeyName,
                OBJ_CASE_INSENSITIVE,
                SampKey,
                NULL
                );


            SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

            NtStatus = RtlpNtOpenKey(
                           &TempHandle,
                           (KEY_READ),
                           &ObjectAttributes,
                           0
                           );
            if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND     ||
                NtStatus == STATUS_OBJECT_PATH_NOT_FOUND) {

                NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
            }

            if (NT_SUCCESS(NtStatus)) {

                //
                // Retrieve the length of the membership buffer
                //

                KeyValueLength = 0;

                NtStatus = RtlpNtQueryValueKey(
                                TempHandle,
                                &MembershipCount,
                                NULL,
                                &KeyValueLength,
                                NULL);

                SampDumpRtlpNtQueryValueKey(&MembershipCount,
                                            NULL,
                                            &KeyValueLength,
                                            NULL);

                if (NT_SUCCESS(NtStatus)) {
                    ASSERT(MembershipCount == 0);

                    NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
                }

                if (NtStatus == STATUS_BUFFER_OVERFLOW) {

                    ASSERT(MembershipCount != 0);
                    ASSERT(KeyValueLength == (MembershipCount * sizeof(ULONG)));

                    MembershipArray = MIDL_user_allocate( KeyValueLength );

                    if (MembershipArray == NULL) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    } else {

                        NtStatus = RtlpNtQueryValueKey(
                                       TempHandle,
                                       NULL,
                                       MembershipArray,
                                       &KeyValueLength,
                                       NULL);

                        SampDumpRtlpNtQueryValueKey(NULL,
                                                    MembershipArray,
                                                    &KeyValueLength,
                                                    NULL);

                        if (NT_SUCCESS(NtStatus)) {

                            //
                            // See if the account is a member ...
                            //

                            NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;

                            for (i = 0; i<MembershipCount ; i++ ) {
                                if ( MembershipArray[i] == AliasRid ) {
                                    NtStatus = STATUS_SUCCESS;
                                    break;
                                }
                            }

                            if (NT_SUCCESS(NtStatus)) {

                                //
                                // Replace the removed alias information
                                // with the last entry's information.
                                // Then add it to the RXACT transaction
                                // to be written out.
                                //

                                MembershipCount -= 1;
                                KeyValueLength -= sizeof(ULONG);

                                if (MembershipCount > 0) {

                                    MembershipArray[i] = MembershipArray[MembershipCount];

                                    ASSERT(KeyValueLength == (MembershipCount * sizeof(ULONG)));
                                    NtStatus = RtlAddActionToRXact(
                                                   SampRXactContext,
                                                   RtlRXactOperationSetValue,
                                                   &AccountKeyName,
                                                   MembershipCount,
                                                   MembershipArray,
                                                   KeyValueLength
                                                   );
                                } else {

                                    //
                                    // This is the last alias membership for
                                    // this account. Delete the keys.
                                    //

                                    NtStatus = SampDeleteAliasMembershipKeysForAccount(
                                                    AccountSid);
                                }
                            }
                        }

                        MIDL_user_free( MembershipArray );
                    }

                }

                IgnoreStatus = NtClose( TempHandle );
                ASSERT( NT_SUCCESS(IgnoreStatus) );
            }


            SampFreeUnicodeString( &DomainKeyName );
            SampFreeUnicodeString( &AccountKeyName );

        }
    }

    return( NtStatus );

}



NTSTATUS
SampRemoveAliasFromAllAccounts(
    IN PSAMP_OBJECT AliasContext
    )

/*++

Routine Description:

    This service removes the specified alias from all account memberships

    THIS SERVICE MUST BE CALLED WITH THE TRANSACTION DOMAIN SET.

    This service leaves the alias membership list intact. It is assumed
    that the caller will delete the alias member list as part of the
    current transaction.

    This routine is a No OP for the DS case

Arguments:

    AliasRid - The relative ID of the alias.

Return Value:


    STATUS_SUCCESS - The information has been updated and added to the
        RXACT.

    STATUS_NO_SUCH_ALIAS - The alias does not exist.


    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            NtQueryValueKey()
            RtlAddActionToRXact()



--*/
{
    NTSTATUS                NtStatus=STATUS_SUCCESS;
    ULONG                   MemberCount, i;
    PSID                    *MemberArray;




    SAMTRACE("SampRemoveAliasFromAllAccounts");

    if (!IsDsObject(AliasContext))
    {

        //
        // Get the list of members in this alias
        //

        MemberArray = NULL;

        NtStatus = SampRetrieveAliasMembers(
                        AliasContext,
                        &MemberCount,
                        &MemberArray);

        if (NT_SUCCESS(NtStatus)) {

            ASSERT((MemberCount != 0) == (MemberArray != NULL));

            //
            // Remove this alias from each of our members in turn
            //

            for (i = 0; i < MemberCount ; i++ ) {

                NtStatus = SampRemoveAliasFromAccountMembership(
                                        AliasContext,       // Alias Context
                                        MemberArray[i]      // Member Object SID
                                        );

                if (!NT_SUCCESS(NtStatus)) {
                    break;
                }
            }

            if (MemberArray != NULL) {
                MIDL_user_free( MemberArray );
            }
        }
    }

    return(NtStatus);
}



NTSTATUS
SampRetrieveAliasMembers(
    IN PSAMP_OBJECT AliasContext,
    OUT PULONG MemberCount,
    OUT PSID **Members OPTIONAL
    )

/*++
Routine Description:

    This service retrieves the number of members in a alias.  If desired,
    it will also retrieve an array of SIDs of the members of the alias.

    THIS SERVICE MUST BE CALLED WITH THE TRANSACTION DOMAIN SET.

Arguments:

    Context - Points to the account context whose alias members are to
        to be retrieved.

    MemberCount - Receives the number of members currently in the alias.

    Members - (Otional) Receives a pointer to a buffer containing an array
        of member PSIDs.  If this value is NULL, then this information
        is not returned.  The returned buffer is allocated using
        MIDL_user_allocate() and must be freed using MIDL_user_free() when
        no longer needed.

Return Value:


    STATUS_SUCCESS - The information has been retrieved.

    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated for the
        string to be returned in.

    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            NtQueryValueKey()

    If this routine returns failure, *MemberCount will be zero and
    *Members will be NULL.


--*/
{

    NTSTATUS    NtStatus=STATUS_SUCCESS;
    PSID        MemberArray;
    ULONG       MemberArraySize;
    ULONG       i;

    SAMTRACE("SampRetieveAliasMembers");

    ASSERT(MemberCount);

    if (IsDsObject(AliasContext))
    {


        //
        // DS case, this routine in DS layer does all the
        // work
        //

        NtStatus = SampDsGetAliasMembershipList(
                        AliasContext->ObjectNameInDs,
                        MemberCount,
                        Members
                        );

    }
    else
    {

        //
        // Registry based case
        //
        //

        NtStatus = SampGetSidArrayAttribute(
                        AliasContext,
                        SAMP_ALIAS_MEMBERS,
                        FALSE,  // Reference directly
                        &MemberArray,
                        &MemberArraySize,
                        MemberCount
                        );

        if (NT_SUCCESS(NtStatus)) {

            if (ARGUMENT_PRESENT(Members)) {

                //
                // Allocate memory for the sid array and sid data
                //

                ULONG SidArraySize = *MemberCount * sizeof(PSID);
                ULONG SidDataSize = MemberArraySize;

                if ( *MemberCount == 0 ) {

                    //
                    // Nothing to copy, just return success.
                    //

                    *Members = NULL;
                    return( NtStatus );
                }

                (*Members) = (PSID *)MIDL_user_allocate(SidArraySize + SidDataSize);

                if ((*Members) == NULL) {

                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    //
                    // Copy the sid data into the last part of the block
                    //

                    PSID SidData = (PSID)(&((*Members)[*MemberCount]));

                    RtlCopyMemory(SidData, MemberArray, MemberArraySize);

                    //
                    // Fill in the sid pointer array
                    //

                    for (i = 0; i < *MemberCount ; i++) {

                        (*Members)[i] = SidData;

                        ((PCHAR)SidData) += RtlLengthSid(SidData);
                    }

                    ASSERT(SidData == ((PCHAR)(*Members)) + SidArraySize + SidDataSize);

                }
            }
        }
    }

    return( NtStatus );

}



NTSTATUS
SampDeleteAliasKeys(
    IN PSAMP_OBJECT Context
    )

/*++
Routine Description:

    This service deletes all registry keys related to a alias object.


Arguments:

    Context - Points to the alias context whose registry keys are
        being deleted.


Return Value:


    STATUS_SUCCESS - The information has been retrieved.


    Other status values that may be returned by:

        RtlAddActionToRXact()



--*/
{

    NTSTATUS                NtStatus;
    ULONG                   Rid;
    UNICODE_STRING          AccountName, KeyName;


    SAMTRACE("SampDeleteAliasKeys");

    Rid = Context->TypeBody.Alias.Rid;


    //
    // Aliases are arranged as follows:
    //
    //  +-- Aliases [Count]
    //      ---+--
    //         +--  Names
    //         |    --+--
    //         |      +--  (AliasName) [AliasRid,]
    //         |
    //         +--  (AliasRid) [Revision,SecurityDescriptor]
    //               ---+-----
    //                  +--  V1_Fixed [,SAM_V1_FIXED_LENGTH_ALIAS]
    //                  +--  Name [,Name]
    //                  +--  AdminComment [,unicode string]
    //                  +--  Members [Count,(Member0Sid, (...), MemberX-1Sid)]
    //
    // This all needs to be deleted from the bottom up.
    //


    //
    // Decrement the alias count
    //

    NtStatus = SampAdjustAccountCount(SampAliasObjectType, FALSE);




    //
    // Delete the registry key that has the alias's name to RID mapping.
    //

    if (NT_SUCCESS(NtStatus)) {

        //
        // Get the name
        //

        NtStatus = SampGetUnicodeStringAttribute(
                       Context,
                       SAMP_ALIAS_NAME,
                       TRUE,    // Make copy
                       &AccountName
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampBuildAccountKeyName(
                           SampAliasObjectType,
                           &KeyName,
                           &AccountName
                           );

            SampFreeUnicodeString( &AccountName );


            if (NT_SUCCESS(NtStatus)) {

                NtStatus = RtlAddActionToRXact(
                               SampRXactContext,
                               RtlRXactOperationDelete,
                               &KeyName,
                               0,
                               NULL,
                               0
                               );

                SampFreeUnicodeString( &KeyName );
            }
        }
    }



    //
    // Delete the attribute keys
    //

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampDeleteAttributeKeys(
                        Context
                        );
    }


    //
    // Delete the RID key
    //

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampBuildAccountSubKeyName(
                       SampAliasObjectType,
                       &KeyName,
                       Rid,
                       NULL
                       );

        if (NT_SUCCESS(NtStatus)) {


            NtStatus = RtlAddActionToRXact(
                           SampRXactContext,
                           RtlRXactOperationDelete,
                           &KeyName,
                           0,
                           NULL,
                           0
                           );

            SampFreeUnicodeString( &KeyName );
        }


    }



    return( NtStatus );

}



NTSTATUS
SampDeleteAliasMembershipKeysForAccount(
    IN PSID AccountSid
    )

/*++

Routine Description:

    This service deletes the alias membership keys for the specified account.

    This account rid key is deleted. If this was the last account-rid for
    the domain then the domain keys is deleted also.

    THIS SERVICE MUST BE CALLED WITH THE TRANSACTION DOMAIN SET.

    It is assumed we are in the middle of a registry transaction.

Arguments:

    AccountSid - The SID of the account.


Return Value:


    STATUS_SUCCESS - The transactions have been added.

    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            NtQueryValueKey()
            RtlAddActionToRXact()

--*/
{

    NTSTATUS                NtStatus, IgnoreStatus;
    UNICODE_STRING          DomainKeyName;
    UNICODE_STRING          AccountKeyName;
    HANDLE                  TempHandle;
    ULONG                   MembershipCount;
    OBJECT_ATTRIBUTES       ObjectAttributes;

    SAMTRACE("SampDeleteAliasMembershipKeysForAccount");

    //
    // Get the account membership key names
    //

    NtStatus = SampBuildAliasMembersKeyName(
                   AccountSid,
                   &DomainKeyName,
                   &AccountKeyName
                   );
    if (NT_SUCCESS(NtStatus)) {


        //
        // Delete the account rid key
        //

        NtStatus = RtlAddActionToRXact(
                       SampRXactContext,
                       RtlRXactOperationDelete,
                       &AccountKeyName,
                       0,
                       NULL,
                       0
                       );

        //
        // Adjust the rid count for the domain
        //

        if (NT_SUCCESS(NtStatus)) {

            InitializeObjectAttributes(
                &ObjectAttributes,
                &DomainKeyName,
                OBJ_CASE_INSENSITIVE,
                SampKey,
                NULL
                );


            SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

            NtStatus = RtlpNtOpenKey(
                           &TempHandle,
                           (KEY_READ),
                           &ObjectAttributes,
                           0
                           );
            ASSERT(NT_SUCCESS(NtStatus)); // We just opened a sub-key successfully !

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = RtlpNtQueryValueKey(
                               TempHandle,
                               &MembershipCount,
                               NULL,
                               NULL,
                               NULL);

                SampDumpRtlpNtQueryValueKey(&MembershipCount,
                                            NULL,
                                            NULL,
                                            NULL);

                if (NT_SUCCESS(NtStatus)) {

                    //
                    // Decrement the rid count, write out or delete key if 0
                    //

                    MembershipCount -= 1;
                    if (MembershipCount > 0) {

                        //
                        // Decrement the domain rid count
                        //

                        NtStatus = RtlAddActionToRXact(
                                       SampRXactContext,
                                       RtlRXactOperationSetValue,
                                       &DomainKeyName,
                                       MembershipCount,
                                       NULL,
                                       0
                                       );
                    } else {

                        //
                        // Delete the domain key
                        //

                        NtStatus = RtlAddActionToRXact(
                                       SampRXactContext,
                                       RtlRXactOperationDelete,
                                       &DomainKeyName,
                                       0,
                                       NULL,
                                       0
                                       );

                        //
                        // Adjust the count of domain keys
                        //

                        if (NT_SUCCESS(NtStatus)) {

                            NtStatus = SampAdjustAliasDomainsCount(FALSE);
                        }
                    }

                }

                //
                // Close the domain key handle
                //

                IgnoreStatus = NtClose( TempHandle );
                ASSERT( NT_SUCCESS(IgnoreStatus) );
            }
        }


        SampFreeUnicodeString( &DomainKeyName );
        SampFreeUnicodeString( &AccountKeyName );

    }



    return( NtStatus );

}



NTSTATUS
SampAdjustAliasDomainsCount(
    IN BOOLEAN Increment
    )

/*++
Routine Description:

    This service increments or decrements the number of domains that have
    at least one account that is a member of one of our aliases.

    This value is contained in the type of \(domain)\ALIASES\MEMBERS



    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().

Arguments:

    Increment - TRUE to increment, FALSE to decrement

Return Value:

    STATUS_SUCCESS - The value has been adjusted and the new value added
        to the current RXACT transaction.

    STATUS_INSUFFICIENT_RESOURCES - Not enough memory could be allocated
        to perform the requested operation.

    Other values are unexpected errors.  These may originate from
    internal calls to:

            NtOpenKey()
            NtQueryInformationKey()
            RtlAddActionToRXact()



--*/
{

    //
    // Don't maintain a count of domains for now
    //


    SAMTRACE("SampAdjustAliasDomainsCount");

    return(STATUS_SUCCESS);

    DBG_UNREFERENCED_PARAMETER(Increment);
}



NTSTATUS
SampValidateNewAliasMember(
    IN PSAMP_OBJECT AccountContext,
    IN PSID MemberId,
    IN DSNAME * MemberName OPTIONAL
    )

/*++

Routine Description:

    This service checks the passed Sid is acceptable as a potential new
    member of one of the aliases in the current domain.

    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().

Arguments:

    AccountContext - SAM context describing the Alias
    MemberId - the full Sid of the member to validate
    MemberName - For the DS case OPTIONAL DS name parameter
                 specifying the member name

Return Value:


    STATUS_SUCCESS - MemberId is a valid potential alias member

    STATUS_INVALID_MEMBER - MemberId has the wrong account type.

    STATUS_NO_SUCH_MEMBER - MemberId is not a valid account.

    STATUS_INVALID_SID - MemberId is not a valid sid.

--*/
{
    NTSTATUS                NtStatus;
    PSID                    MemberDomainSid = NULL,
                            CurrentDomainSid = NULL;
    ULONG                   MemberRid;
    SAMP_OBJECT_TYPE        MemberType;

    SAMTRACE("SampValidateNewAliasMember");

    //
    // Check the new member sid for structural soundness
    //

    if ((MemberId == NULL) || !RtlValidSid(MemberId)) {
        return(STATUS_INVALID_SID);
    }

    //
    // Get the current domain sid
    //

  
    CurrentDomainSid = SampDefinedDomains[AccountContext->DomainIndex].Sid;

    //
    // Break up the new member into domain and rid
    //

    NtStatus = SampSplitSid(MemberId, &MemberDomainSid, &MemberRid);

    if (!NT_SUCCESS(NtStatus)) {
        goto Error;
    }

    //
    // Check if the member is in the same domain
    //

    if (!RtlEqualSid(CurrentDomainSid, MemberDomainSid))
    {

        //
        // Cross domain case ----
        //   1. On a workstation need not do any checks
        //   2. On a DS need to enforce the cross domain checks
        //

        if (IsDsObject(AccountContext))
        {
            BOOLEAN  WellKnownSid = FALSE;
            BOOLEAN  LocalSid = FALSE;
            BOOLEAN  ForiegnSid = FALSE;
            BOOLEAN  EnterpriseSid = FALSE;
            BOOLEAN  BuiltinDomainSid = FALSE;

            //
            // Examine the SID. We probably have gone through this route
            // before but we have not cached the results of that examination.
            // ( SampValidateDsName and SampDsResolveSids )
            // However examining a SID is very cheap, so again take a peek
            // at it to get the information we need.
            //

            NtStatus = SampDsExamineSid(
                            MemberId,
                            &WellKnownSid,
                            &BuiltinDomainSid,
                            &LocalSid,
                            &ForiegnSid,
                            &EnterpriseSid
                            );

            if (!NT_SUCCESS(NtStatus))
                goto Error;

           
            //
            // Call the cross domain reverse membership routine
            // to perform the check regarding membership rules.
            //


            NtStatus = SampEnforceCrossDomainGroupMembershipChecks(
                            AccountContext,
                            MemberId,
                            MemberName
                            );
        }
        else
        {
            //
            // Workstation case , anything and everything including well known
            // SIDS can be members of local groups in a workstation. This is
            // exactly what NT4 enforced, and we will enforce this no matter.
            //

            NtStatus = STATUS_SUCCESS;
        }

    } else {

        //
        // The member is in our domain - check that the type of
        // account is acceptable.
        //

        NtStatus = SampLookupAccountName(
                            AccountContext->DomainIndex,
                            MemberRid,
                            NULL,
                            &MemberType
                            );

        if (NT_SUCCESS(NtStatus)) {

            switch (MemberType) {
            case SampUserObjectType:

                //
                // Users are always accepted as members
                //

                NtStatus = STATUS_SUCCESS;
                break;

            case SampAliasObjectType:

                //
                // In the workstation case fail the call with STATUS_INVALID_MEMBER
                // In the DS case, fall over to the next case, that will validate
                // whether the member group satisfies the "Group Type" restrictions.
                //

                if (!IsDsObject(AccountContext))
                {
                    NtStatus = STATUS_INVALID_MEMBER;
                    break;
                }


            case SampGroupObjectType:

                //
                // In the DS case validate the correct type of membership
                //

                NtStatus = STATUS_SUCCESS;

                if (IsDsObject(AccountContext))
                {
                    NtStatus = SampEnforceSameDomainGroupMembershipChecks(
                                    AccountContext,
                                    MemberRid
                                    );
                }

                break;



            case SampUnknownObjectType:
                NtStatus = STATUS_NO_SUCH_MEMBER;
                break;

            default:
                NtStatus = STATUS_INVALID_MEMBER;
                break;
            }
        }

    }
Error:

    if (NULL!=MemberDomainSid)
    {
        MIDL_user_free(MemberDomainSid);
        MemberDomainSid = NULL;
    }
    return(NtStatus);
}




NTSTATUS
SampChangeAliasAccountName(
    IN PSAMP_OBJECT Context,
    IN PUNICODE_STRING NewAccountName,
    OUT PUNICODE_STRING OldAccountName
    )

/*++
Routine Description:

    This routine changes the account name of an alias account.

    THIS SERVICE MUST BE CALLED WITH THE TRANSACTION DOMAIN SET.

Arguments:

    Context - Points to the account context whose name is to be changed.

    NewAccountName - New name to give this account

    OldAccountName - old name is returned here. The buffer should be freed
                     by calling MIDL_user_free.

Return Value:


    STATUS_SUCCESS - The information has been retrieved.


    Other status values that may be returned by:

        SampGetUnicodeStringAttribute()
        SampSetUnicodeStringAttribute()
        SampValidateAccountNameChange()
        RtlAddActionToRXact()



--*/
{

    NTSTATUS        NtStatus;
    UNICODE_STRING  KeyName;

    SAMTRACE("SampChangeAliasAccountName");




    //
    // Get the current name so we can delete the old Name->Rid
    // mapping key.
    //

    NtStatus = SampGetUnicodeStringAttribute(
                   Context,
                   SAMP_ALIAS_NAME,
                   TRUE, // Make copy
                   OldAccountName
                   );

    //
    // Make sure the name is valid and not already in use
    //

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampValidateAccountNameChange(
                       Context,
                       NewAccountName,
                       OldAccountName,
                       SampAliasObjectType
                       );

        if (!(IsDsObject(Context))) {

            //
            // For registry based Aliases re-create the
            // Name to Rid mapping keys
            //

            /////////////////////////////////////////////////////////////
            // There are two copies of the name of each account.       //
            // one is under the DOMAIN\(domainName)\ALIAS\NAMES key,   //
            // one is the value of the                                 //
            // DOMAIN\(DomainName)\ALIAS\(rid)\NAME key                //
            /////////////////////////////////////////////////////////////


            //
            // Delete the old name key
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampBuildAccountKeyName(
                               SampAliasObjectType,
                               &KeyName,
                               OldAccountName
                               );

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = RtlAddActionToRXact(
                                   SampRXactContext,
                                   RtlRXactOperationDelete,
                                   &KeyName,
                                   0,
                                   NULL,
                                   0
                                   );
                    SampFreeUnicodeString( &KeyName );
                }

            }

            //
            //
            // Create the new Name->Rid mapping key
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampBuildAccountKeyName(
                               SampAliasObjectType,
                               &KeyName,
                               NewAccountName
                               );

                if (NT_SUCCESS(NtStatus)) {

                    ULONG AliasRid = Context->TypeBody.Alias.Rid;

                    NtStatus = RtlAddActionToRXact(
                                   SampRXactContext,
                                   RtlRXactOperationSetValue,
                                   &KeyName,
                                   AliasRid,
                                   (PVOID)NULL,
                                   0
                                   );
                    SampFreeUnicodeString( &KeyName );
                }
            }
        }

        //
        // replace the account's name
        //

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampSetUnicodeStringAttribute(
                           Context,
                           SAMP_ALIAS_NAME,
                           NewAccountName
                           );
        }

        //
        // Free up the old account name if we failed
        //

        if (!NT_SUCCESS(NtStatus)) {
            SampFreeUnicodeString(OldAccountName);
        }

    }


    return(NtStatus);
}


NTSTATUS
SampAddMemberToAliasActual(
    IN  PSAMP_OBJECT    AccountContext,
    IN  PSID            MemberId,
    IN  OPTIONAL DSNAME *MemberName
    )
/*++

  Routine Description:

        This Routine does the actual work of adding the member to the Alias
        It does the following

                Updates any Reverse membership List
                Updates the Straight membership List
                Modifies ACL on Member if modification is required

    WARNING     This Routine must be called with the lock held for write access.

  Arguments:

        AccountContext  SAMP_OBJECT describing the Alias
        MemberId        Sid of Member
        MemberName      Specifies the Member for DS cases

  Return Values:

        STATUS_SUCCESS

--*/

{
    NTSTATUS                NtStatus, TmpStatus, IgnoreStatus;
    ULONG                   ObjectRid = 0;
    SAMP_MEMBERSHIP_DELTA   AdminChange = NoChange;
    SAMP_MEMBERSHIP_DELTA   OperatorChange = NoChange;


    //
    // Check the potential new member is OK. This involves validating
    // the group membership rules etc.
    //

    NtStatus = SampValidateNewAliasMember(
                    AccountContext,
                    MemberId,
                    MemberName
                    );

    //
    // In registry mode if the member is being added to an ADMIN alias, we 
    // must sure the member ACL(s) don't allow access by account operators.
    // Do not do this is DS mode, this operation is done by a background
    // task -- necessary because of support for nested groups.
    //

    if ( NT_SUCCESS( NtStatus ) && (!IsDsObject(AccountContext))) {
        if ( AccountContext->TypeBody.Alias.Rid == DOMAIN_ALIAS_RID_ADMINS ) {

            AdminChange = AddToAdmin;

        } else if ( ( AccountContext->TypeBody.Alias.Rid == DOMAIN_ALIAS_RID_SYSTEM_OPS ) ||
                    ( AccountContext->TypeBody.Alias.Rid == DOMAIN_ALIAS_RID_PRINT_OPS ) ||
                    ( AccountContext->TypeBody.Alias.Rid == DOMAIN_ALIAS_RID_BACKUP_OPS ) ||
                    ( AccountContext->TypeBody.Alias.Rid == DOMAIN_ALIAS_RID_ACCOUNT_OPS ) ) {

            OperatorChange = AddToAdmin;
        }

        //
        // If either of these are changing, change account operator
        // access to this member
        //

        if ( ( OperatorChange != NoChange ) ||
             ( AdminChange != NoChange ) ) {

            NtStatus = SampChangeAccountOperatorAccessToMember(
                            MemberId,
                            AdminChange,
                            OperatorChange
                            );
        }

    }

    if (NT_SUCCESS(NtStatus)) {

        //
        // Perform the account object side of things
        // In registry mode explicit reverse memberships are
        // maintained -- this routine updates that reverse membership
        // DS mode does not maintain explicit reverse memberships,
        // therefore this routine is a No Op in DS mode
        //

        NtStatus = SampAddAliasToAccountMembership(
                       AccountContext,      // Alias Context
                       MemberId             // Member Object SID
                       );


        //
        // Now perform the alias side of things
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // Add the user to the alias (should not fail)
            //

            NtStatus = SampAddAccountToAlias(
                           AccountContext,
                           MemberId,
                           MemberName
                           );

        }
    }

    return NtStatus;

}

NTSTATUS
SampRemoveMemberFromAliasActual(
    IN PSAMP_OBJECT AccountContext,
    IN PSID         MemberId,
    IN DSNAME *     MemberName OPTIONAL
    )
/*++

  Routine Description:

        This Routine does the actual work of removing the member from Alias
        It does the following

                Updates any Reverse membership List
                Updates the Straight membership List
                Modifies ACL on Member if modification is required

    WARNING     This Routine must be called with the lock held for write access.

  Arguments:

        AccountContext  SAMP_OBJECT describing the Alias
        MemberId        Sid of Member
        MemberName      DSNAME of Member , specifies the member for DS cases.

  Return Values:

        STATUS_SUCCESS

*/
{
    NTSTATUS                NtStatus=STATUS_SUCCESS, TmpStatus, IgnoreStatus;
    ULONG                   ObjectRid = 0;
    ULONG                   MemberRid;
    SAMP_MEMBERSHIP_DELTA   AdminChange = NoChange;
    SAMP_MEMBERSHIP_DELTA   OperatorChange = NoChange;


    SampReferenceContext(AccountContext);

    //
    // Validate the sid of the member. Block the call for the case of
    // the constant well known Sid's
    // enforce WellKnown Sid check only in DS case.
    // in registry case, since we do not enforce WellKnownSid check when 
    // adding a member, so we'd better do not enforce it when delete it.
    //

    if ((MemberId == NULL) || !RtlValidSid(MemberId)) 
    {

        SampDeReferenceContext(AccountContext,FALSE);
        return STATUS_INVALID_SID;
    }
    
    //
    // O.k If the account Administrator was being removed from the account Administrators
    // then fail the call, except if it were a trusted client
    //


    if ((DOMAIN_ALIAS_RID_ADMINS==AccountContext->TypeBody.Alias.Rid)
        && (RtlEqualSid(MemberId,SampAdministratorUserSid))
        && (!AccountContext->TrustedClient))
    {
        SampDeReferenceContext(AccountContext,FALSE);
        return STATUS_SPECIAL_ACCOUNT;
    }

    if (NT_SUCCESS(NtStatus)) {

        //
        // Perform the user object side of things
        //

        NtStatus = SampRemoveAliasFromAccountMembership(
                       AccountContext,  // Alias Context
                       (PSID)MemberId   // Member Object SID
                       );



        //
        // Now perform the alias side of things
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // Remove the user from the alias (should not fail)
            //

            NtStatus = SampRemoveAccountFromAlias(
                           AccountContext,
                           (PSID)MemberId,
                           MemberName
                           );

            //
            // If the member is being removed from an ADMIN alias, we must make
            // sure the member ACL(s) allow access by account operators. In the
            // DS case no ACL modification is done, as transitive groups are supported
            // and it is a huge task to do this manually. Instead there is a background 
            // task that periodically wakes up and lists out the set of security principals
            // that are members of administrative groups and modifies the security descriptors
            // on them 
            //

            if ( NT_SUCCESS( NtStatus ) && (!IsDsObject(AccountContext))) {
                if ( AccountContext->TypeBody.Alias.Rid == DOMAIN_ALIAS_RID_ADMINS ) {

                    AdminChange = RemoveFromAdmin;

                } else if ( ( AccountContext->TypeBody.Alias.Rid == DOMAIN_ALIAS_RID_SYSTEM_OPS ) ||
                            ( AccountContext->TypeBody.Alias.Rid == DOMAIN_ALIAS_RID_PRINT_OPS ) ||
                            ( AccountContext->TypeBody.Alias.Rid == DOMAIN_ALIAS_RID_BACKUP_OPS ) ||
                            ( AccountContext->TypeBody.Alias.Rid == DOMAIN_ALIAS_RID_ACCOUNT_OPS ) ) {

                    OperatorChange = RemoveFromAdmin;
                }

                //
                // If either of these are changing, change account operator
                // access to this member
                //

                if ( ( OperatorChange != NoChange ) ||
                     ( AdminChange != NoChange ) ) {

                    NtStatus = SampChangeAccountOperatorAccessToMember(
                                    MemberId,
                                    AdminChange,
                                    OperatorChange
                                    );
                }

            }
        }
    }

 

    return NtStatus;
}

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  Services Available to NT5 SAM In process clients                        //
//                                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

NTSTATUS
SamIAddDSNameToAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN DSNAME   *   DSName
    )
/*++
    Routine Description

        Adds the given DSNAME to membership list of the alias specified by
        Alias Handle

    Arguments:

        AliasHandle -- SAMPR_HANDLE returned by an Open Alias
        DSName      -- Pointer to a DSNAME structure. The caller is responsible for
                       Allocating / freeing this structure

    Return Values:

            STATUS_SUCCESS
            Other error codes from DsLayer

--*/
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
    NTSTATUS            TmpStatus;
    PSAMP_OBJECT        AccountContext;
    SAMP_OBJECT_TYPE    FoundType;
    BOOLEAN             SameDomain;
    BOOLEAN             DifferentDomain;
    BOOLEAN             Not_a_Security_Principal;
    BOOLEAN             ForeignSecurityPrincipal;
    PSID                Sid = NULL;
    DSNAME              *ImprovedDSName=NULL;

    SAMTRACE("SamIAddDSNameToAlias");
    
    SampTraceEvent(EVENT_TRACE_TYPE_START, 
                   SampGuidAddMemberToAlias
                   );

    SampUpdatePerformanceCounters(
        DSSTAT_MEMBERSHIPCHANGES,
        FLAG_COUNTER_INCREMENT,
        0
        );

    //
    // Reference the context.
    //

    AccountContext = (PSAMP_OBJECT)(AliasHandle);
    SampReferenceContext(AccountContext);
                  
    if (IsDsObject(AccountContext))
    {
       //
       // See what the DSNAME represents.
       //

       NtStatus = SampValidateDSName(
                    AccountContext,
                    DSName,
                    &Sid,
                    &ImprovedDSName
                    );

       if ( NT_SUCCESS(NtStatus))
       {
           if (NULL==Sid)
           {
               //
               // This is the case of a non security principal.
               //
           
               NtStatus = SampDsAddMembershipOperationToCache(AccountContext, 
                                                              ADD_VALUE,
                                                              ImprovedDSName
                                                              );
               
               if (NT_SUCCESS(NtStatus))
               {

                   //
                   // Commit Changes
                   //

                   SampCommitAndRetainWriteLock();
               }
           }
           else
           {
               DSNAME  * DSNameToAdd = ImprovedDSName;
               DSNAME  * ForeignSecurityPrincipalName = NULL;
               BOOLEAN   WellKnownSid =FALSE,
                         BuiltinDomainSid = FALSE,
                         LocalSid = FALSE,
                         ForeignSid = FALSE,
                         EnterpriseSid = FALSE;

               //
               // Check the type of the SID
               //

               NtStatus = SampDsExamineSid(
                                Sid,
                                &WellKnownSid,
                                &BuiltinDomainSid,
                                &LocalSid,
                                &ForeignSid,
                                &EnterpriseSid
                                );
                                

               if ((NT_SUCCESS(NtStatus)) && (ForeignSid || WellKnownSid ))
               {

                   //
                   // The passed in DSName, could have just the SID field,
                   // filled, in not the GUID or the DSName. The foreignSid,
                   // or WellKnown SID case, require manipulation of corresponding
                   // FPO objects that have the corresponding SIDs. SID positioning
                   // in the DS does not work for FPO objects ( works for all 
                   // security principals in the forest -- FPO's represent 
                   // security principals in different forests. Therefore resolve
                   // the SID to the DSNAME of the object ie GUID and Name fields 
                   // filled in before performing the Add Member operation.
                   //

                   NtStatus = SampDsObjectFromSid(
                                    Sid,
                                    &ForeignSecurityPrincipalName
                                    );


                   if ((STATUS_NOT_FOUND==NtStatus))
                   {

                       //
                       // If no FPO object exists then it is time to create one
                       // call the worker routine to create the corresponding
                       // FPO object.
                       //

                    NtStatus = SampDsCreateForeignSecurityPrincipal(
                                    Sid,
                                    ROOT_OBJECT,
                                    &ForeignSecurityPrincipalName
                                    );
                   }



                   DSNameToAdd = ForeignSecurityPrincipalName;

               }

               if (NT_SUCCESS(NtStatus))
               {
                   //
                   // Call the worker routine to add the member to the
                   // local group.
                   //

                   NtStatus = SampAddMemberToAliasActual(
                                    AccountContext,
                                    Sid,
                                    DSNameToAdd
                                    );
               }

               if (NULL!=ForeignSecurityPrincipalName)
               {
                   MIDL_user_free(ForeignSecurityPrincipalName);
               }

           }

       }
    }
    else
    {
       //
       // Should never expect to hit this call in registry mode
       //

       ASSERT(FALSE && "SamIAddDSNameToAlias in Registry Mode !!!!");
       NtStatus = STATUS_INVALID_PARAMETER;
    }


    

    //
    // Dereference the context
    //

    SampDeReferenceContext(AccountContext,FALSE);
   
    SampTraceEvent(EVENT_TRACE_TYPE_END,
               SampGuidAddMemberToAlias
               ); 

                   
    return NtStatus;

}

NTSTATUS
SamIRemoveDSNameFromAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN DSNAME   *   DSName
    )
/*++
    Routine Description

        Removes the given DSNAME to membership list of the alias specified by
        Alias Handle

    Arguments:

        AliasHandle -- SAMPR_HANDLE returned by an Open Alias
        DSName      -- Pointer to a DSNAME structure. The caller is responsible for
                       Allocating / freeing this structure

    Return Values:

            STATUS_SUCCESS
            Other error codes from DsLayer

--*/
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
    NTSTATUS            TmpStatus;
    PSAMP_OBJECT        AccountContext;
    SAMP_OBJECT_TYPE    FoundType;
    PSID                Sid = NULL;
    DSNAME              *ImprovedDSName;


    SAMTRACE("SamIRemoveDSNameFromAlias");


    SampTraceEvent(EVENT_TRACE_TYPE_START, 
                   SampGuidRemoveMemberFromAlias
                   );
                   
    SampUpdatePerformanceCounters(
        DSSTAT_MEMBERSHIPCHANGES,
        FLAG_COUNTER_INCREMENT,
        0
        );


    //
    // Reference the context
    //

    AccountContext = (PSAMP_OBJECT)(AliasHandle);
    SampReferenceContext(AccountContext);

   if (IsDsObject(AccountContext))
   {
       //
       // See what the DSNAME represents.
       //

       NtStatus = SampValidateDSName(
                    AccountContext,
                    DSName,
                    &Sid,
                    &ImprovedDSName
                    );

       if ( NT_SUCCESS(NtStatus))
       {
           if (NULL==Sid)
           {

               //
               // This is the case of a non Security principal,
               // no further checking is required; directly perform the 
               // update
               //
               
               NtStatus = SampDsAddMembershipOperationToCache(AccountContext, 
                                                              REMOVE_VALUE,
                                                              ImprovedDSName
                                                              );
           
               
           }
           else
           {
               PDSNAME DSNameToAdd = ImprovedDSName;
               BOOLEAN   WellKnownSid =FALSE,
                         BuiltinDomainSid = FALSE,
                         LocalSid = FALSE,
                         ForeignSid = FALSE,
                         EnterpriseSid = FALSE;

               //
               // Check the type of the SID
               //

               NtStatus = SampDsExamineSid(
                                Sid,
                                &WellKnownSid,
                                &BuiltinDomainSid,
                                &LocalSid,
                                &ForeignSid,
                                &EnterpriseSid
                                );
                                

               if ((NT_SUCCESS(NtStatus)) && (ForeignSid || WellKnownSid ))
               {

                   //
                   // The passed in DSName, could have just the SID field,
                   // filled, in not the GUID or the DSName. The foreignSid,
                   // or WellKnown SID case, require manipulation of corresponding
                   // FPO objects that have the corresponding SIDs. SID positioning
                   // in the DS does not work for FPO objects ( works for all 
                   // security principals in the forest -- FPO's represent 
                   // security principals in different forests. Therefore resolve
                   // the SID to the DSNAME of the object ie GUID and Name fields 
                   // filled in before performing the Remove Member operation.
                   //

                   NtStatus = SampDsObjectFromSid(
                                    Sid,
                                    &DSNameToAdd
                                    );

               }

               if (NT_SUCCESS(NtStatus))
               {
                    //
                    // Call the worker routine to remove the member
                    //

                    NtStatus = SampRemoveMemberFromAliasActual(
                                    AccountContext,
                                    Sid,
                                    DSNameToAdd
                                    );

                    if (ForeignSid || WellKnownSid )
                    {
                        MIDL_user_free(DSNameToAdd);
                        DSNameToAdd = NULL;
                    }
               }
           }

       }

   }
   else
   {
       //
       // Should never expect to hit this call in registry mode
       //

       ASSERT(FALSE && "SamIAddDSNameToAlias in Registry Mode !!!!");
       NtStatus = STATUS_INVALID_PARAMETER;
   }

   

    //
    // Dereference the context
    //

    SampDeReferenceContext(AccountContext,FALSE);

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidRemoveMemberFromAlias
                   );
                   
    return NtStatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\assert.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    assert.c

Abstract:

    This module implements the SampAssert function that is referenced by the
    debugging version of the ASSERT macro defined in sampsrv.h

Author:

    Colin Brace (ColinBr) 06-Aug-1996

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>

#include <samsrvp.h>

#if (SAMP_PRIVATE_ASSERT == 1)

VOID
SampAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
{

#if defined(USER_MODE_SAM)

    //
    // Here the assumption that if SAM is being run as a standalone process
    // it is being debugged locally so we want the message and breakpoint
    // to be handled locally.
    //

    DbgPrint(
     "\n*** Assertion failed: %s%s\n***   Source File: %s, line %ld\n\n",
                  Message ? Message : "",
                  FailedAssertion,
                  FileName,
                  LineNumber
                );
   DbgUserBreakPoint();

#else

    //
    // This code works with a remote debugger, which is presumably the
    // debugger of choice when SAM is running as a loaded dll.
    //

    char Response[ 2 ];

    while (TRUE) {
        DbgPrint( "\n*** Assertion failed: %s%s\n***   Source File: %s, line %ld\n\n",
                  Message ? Message : "",
                  FailedAssertion,
                  FileName,
                  LineNumber
                );

        DbgPrompt( "Break, Ignore, Terminate Process or Terminate Thread (bipt)? ",
                   Response,
                   sizeof( Response )
                 );
        switch (Response[0]) {
            case 'B':
            case 'b':
                DbgBreakPoint();
                break;

            case 'I':
            case 'i':
                return;

            case 'P':
            case 'p':
                NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
                break;

            case 'T':
            case 't':
                NtTerminateThread( NtCurrentThread(), STATUS_UNSUCCESSFUL );
                break;
            }
        }

    DbgBreakPoint();
    NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );

#endif  // USER_MODE_SAM

}

#endif // SAMP_PRIVATE_ASSERT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\almember.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    almember.c

Abstract:

    This file contains utilities related to membership of aliases.
    Alternative design


Author:

    Scott Birrell          01-Apr-1993

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <dsmember.h>
#include <samtrace.h>

#define SAMP_AL_FREE_OLD_LIST                         ((ULONG) 0x00000001L)
#define SAMP_AL_ERROR_IF_MEMBER                       ((ULONG) 0x00000002L)
#define SAMP_AL_ERROR_IF_NOT_MEMBER                   ((ULONG) 0x00000004L)
#define SAMP_AL_ASSIGN_NEW_REFERENCES                 ((ULONG) 0x00000008L)
#define SAMP_AL_LOOKUP_BY_SID                         ((ULONG) 0x00000010L)
#define SAMP_AL_LOOKUP_BY_REFERENCE                   ((ULONG) 0x00000020L)
#define SAMP_AL_VERIFY_NO_ALIASES_IN_ACCOUNT          ((ULONG) 0x00000040L)
#define SAMP_AL_VERIFY_ALL_ALIASES_IN_ACCOUNT         ((ULONG) 0x00000080L)
#define SAMP_AL_VERIFY_NO_MEMBERS_IN_ALIAS            ((ULONG) 0x00000100L)
#define SAMP_AL_VERIFY_ALL_MEMBERS_IN_ALIAS           ((ULONG) 0x00000200L)

#define SAMP_UNKNOWN_INDEX                            ((ULONG) 0xffffffffL)
#define SAMP_AL_ALIAS_LIST_DELTA                      ((ULONG) 0x00000100L)
#define SAMP_AL_ALIAS_DELTA                           ((ULONG) 0x00000040L)
#define SAMP_AL_REFERENCED_DOMAIN_LIST_DELTA          ((ULONG) 0x00000100L)
#define SAMP_AL_INITIAL_MEMBER_ALIAS_LIST_LENGTH      ((ULONG) 0x00001000L)
#define SAMP_AL_MAX_MEMBER_ALIAS_LIST_LENGTH          ((ULONG) 0x00010000L)
#define SAMP_AL_MEMBER_ALIAS_LIST_DELTA               ((ULONG) 0x00001000L)
#define SAMP_AL_INITIAL_REFERENCED_DOMAIN_LIST_LENGTH ((ULONG) 0x00000400L)
#define SAMP_AL_INITIAL_MEMBER_DOMAIN_LENGTH          ((ULONG) 0x00000040L)
#define SAMP_AL_INITIAL_MEMBER_ACCOUNT_ALIAS_CAPACITY ((ULONG) 0x00000004L)
#define SAMP_AL_ENUM_PREFERRED_LENGTH                 ((ULONG) 0x00001000L)
#define SAMP_AL_INITIAL_MEMBERSHIP_COUNT              ((ULONG) 0x0000000aL)
#define SAMP_AL_MEMBERSHIP_COUNT_DELTA                ((ULONG) 0x0000000aL)
#define SAMP_AL_MEMBER_ALIAS_LIST_SIGNATURE           ((ULONG) 0x53494c41)
#define SAMP_AL_MEMBER_DOMAIN_SIGNATURE               ((ULONG) 0x4d4f444d)
#define SAMP_AL_MEMBER_ACCOUNT_SIGNATURE              ((ULONG) 0x4343414d)

#define SAMP_AL_DR_ALIAS_LIST_KEY_NAME   L"Aliases\\Members\\AliasList"
#define SAMP_AL_DR_REFERENCED_DOMAIN_LIST_KEY_NAME \
    L"Aliases\\Members\\ReferencedDomainList"


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Private macro functions                                                 //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#define SampAlFirstMemberDomain( MemberAliasList )                          \
    (MemberAliasList->MemberDomains)

#define SampAlOffsetFirstMemberDomain( MemberAliasList )                      \
    (ULONG)(((PUCHAR) SampAlFirstMemberDomain(MemberAliasList)) - ((PUCHAR) MemberAliasList))

#define SampAlFirstMemberAccount( MemberDomain )                                \
    ((PSAMP_AL_MEMBER_ACCOUNT)                                                  \
    (((PUCHAR) &((MemberDomain)->DomainSid)) + RtlLengthSid(&((MemberDomain)->DomainSid))))

#define SampAlOffsetFirstMemberAccount( MemberDomain )                      \
    (ULONG)(((PUCHAR) SampAlFirstMemberAccount(MemberDomain)) - ((PUCHAR) MemberDomain))

#define SampAlNextMemberAccount( MemberAccount )                              \
    ((PSAMP_AL_MEMBER_ACCOUNT)(((PUCHAR) MemberAccount) + (MemberAccount)->MaximumLength))

#define SampAlOffsetFirstAlias( OutputMemberAccount )                       \
    ((ULONG) FIELD_OFFSET(SAMP_AL_MEMBER_ACCOUNT, AliasRids))

#define SampAlNextMemberDomain( MemberDomain )                              \
    ((PSAMP_AL_MEMBER_DOMAIN)(((PUCHAR) MemberDomain) + (MemberDomain)->MaximumLength))

#define SampAlNextNewAliasInMemberAccount( MemberAccount )                  \
    ((PULONG)(((PUCHAR) MemberAccount) + (MemberAccount)->UsedLength))

#define SampAlNextNewMemberAccount( MemberDomain )                                          \
    ((PSAMP_AL_MEMBER_ACCOUNT)(((PUCHAR) MemberDomain) + (MemberDomain)->UsedLength))

#define SampAlNextNewMemberDomain( MemberAliasList )                                          \
    ((PSAMP_AL_MEMBER_DOMAIN)(((PUCHAR) MemberAliasList) + (MemberAliasList)->UsedLength))

#define SampAlInfoIsValid(DomainIndex)                                      \
    ((SampDefinedDomains[DomainIndex].AliasInformation.Valid) ||            \
     (SampServiceState == SampServiceInitializing ))

#define SampAlInfoMakeValid(DomainIndex)                                                \
    (SampDefinedDomains[DomainIndex].AliasInformation.Valid = TRUE)

#define SampAlInfoMakeInvalid(DomainIndex)                                  \
    (SampDefinedDomains[DomainIndex].AliasInformation.Valid = FALSE)

#define SampAlDomainIndexToMemberAliasList( DomainIndex )                    \
    ((PSAMP_AL_MEMBER_ALIAS_LIST)                                            \
        SampDefinedDomains[ DomainIndex].AliasInformation.MemberAliasList)

#define SampAlDomainHandleToMemberAliasList( DomainHandle )                  \
    (SampAlDomainIndexToMemberAliasList(((PSAMP_OBJECT) DomainHandle)->DomainIndex))

#define SampAlAliasHandleToMemberAliasList( AliasHandle )                  \
    (SampAlDomainIndexToMemberAliasList(((PSAMP_OBJECT) AliasHandle)->DomainIndex))

#define SampAlMemberDomainToOffset( MemberAliasList, MemberDomain)          \
    (ULONG)(((PUCHAR) MemberDomain) - ((PUCHAR) MemberAliasList))

#define SampAlMemberDomainFromOffset( MemberDomain, MemberDomainOffset)  \
    ((PSAMP_AL_MEMBER_DOMAIN)(((PUCHAR) MemberDomain) + MemberDomainOffset))

#define SampAlMemberAccountToOffset( MemberDomain, MemberAccount)          \
    (ULONG)(((PUCHAR) MemberAccount) - ((PUCHAR) MemberDomain))

#define SampAlMemberAccountFromOffset( MemberDomain, MemberAccountOffset)  \
    ((PSAMP_AL_MEMBER_ACCOUNT)(((PUCHAR) MemberDomain) + MemberAccountOffset))

#define SampAlLengthRequiredMemberAccount( AliasCapacity )             \
    (sizeof(SAMP_AL_MEMBER_ACCOUNT) + ((AliasCapacity - 1) * sizeof(ULONG)))

#define SampAlUpdateMemberAliasList( AliasHandle, MemberAliasList )    \
    {                                                                  \
        PSAMP_OBJECT InternalAliasHandle = (PSAMP_OBJECT) AliasHandle; \
        SampDefinedDomains[InternalAliasHandle->DomainIndex].AliasInformation.MemberAliasList \
            = MemberAliasList;                                         \
    }

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Private Datatypes                                                               //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

// This datatype is not currently used.  It may be used if Alias information
// is every stored to Registry Keys.
//

typedef enum _SAMP_AL_LIST_TYPE {

    SampAlMemberAliasList = 1

} SAMP_AL_LIST_TYPE, *PSAMP_AL_LIST_TYPE;

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Private Static Data                                                     //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

UNICODE_STRING SampAlDrMemberAliasListKeyName;
BOOLEAN SampAlEnableBuildingOfList[SAMP_DEFINED_DOMAINS_COUNT] = { TRUE, TRUE };

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Prototypes of functions private to this module                          //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

NTSTATUS
SampAlCreateMemberAliasList(
    IN LONG DomainIndex,
    IN ULONG InitialMemberAliasListLength,
    OUT OPTIONAL PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList
    );

NTSTATUS
SampAlGrowMemberAliasList(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN ULONG ExtraSpaceRequired
    );

NTSTATUS
SampAlRebuildMemberAliasList(
    IN PVOID Parameter
    );

NTSTATUS
SampAlBuildMemberAliasList(
    IN LONG DomainIndex
    );

NTSTATUS
SampAlFreeMemberAliasList(
    IN PVOID Parameter
    );                             

NTSTATUS
SampAlInvalidateMemberAliasList(
    IN ULONG DomainIndex
    );                                

NTSTATUS
SampAlCreateMemberDomain(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSID DomainSid,
    OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain
    );

NTSTATUS
SampAlAllocateMemberDomain(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN ULONG MaximumLengthMemberDomain,
    OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain
    );

NTSTATUS
SampAlGrowMemberDomain(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN ULONG ExtraSpaceRequired
    );

NTSTATUS
SampAlDeleteMemberDomain(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN MemberDomain
    );

NTSTATUS
SampAlLookupMemberDomain(
    IN PSAMP_AL_MEMBER_ALIAS_LIST MemberAliasList,
    IN PSID DomainSid,
    OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain
    );

NTSTATUS
SampAlCreateMemberAccount(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN ULONG Rid,
    IN ULONG AliasCapacity,
    OUT PSAMP_AL_MEMBER_ACCOUNT *MemberAccount
    );

NTSTATUS
SampAlAllocateMemberAccount(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN ULONG MaximumLengthMemberAccount,
    OUT PSAMP_AL_MEMBER_ACCOUNT *MemberAccount
    );

NTSTATUS
SampAlGrowMemberAccount(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN OUT PSAMP_AL_MEMBER_ACCOUNT *MemberAccount,
    IN ULONG ExtraSpaceRequired
    );

NTSTATUS
SampAlDeleteMemberAccount(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN OUT PSAMP_AL_MEMBER_ACCOUNT MemberAccount,
    OUT    PBOOLEAN                MemberDomainDeleted
    );

NTSTATUS
SampAlLookupMemberAccount(
    IN PSAMP_AL_MEMBER_DOMAIN MemberDomain,
    IN ULONG MemberRid,
    OUT PSAMP_AL_MEMBER_ACCOUNT *MemberAccount
    );

NTSTATUS
SampAlAddAliasesToMemberAccount(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN OUT PSAMP_AL_MEMBER_ACCOUNT *MemberAccount,
    IN ULONG Options,
    IN PSAMPR_ULONG_ARRAY AliasRids
    );

NTSTATUS
SampAlRemoveAliasesFromMemberAccount(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN OUT PSAMP_AL_MEMBER_ACCOUNT *MemberAccount,
    IN ULONG Options,
    IN PSAMPR_ULONG_ARRAY AliasRids,
    OUT    PBOOLEAN MemberDomainDeleted,
    OUT    PBOOLEAN MemberAccountDeleted
    );

NTSTATUS
SampAlLookupAliasesInMemberAccount(
    IN PSAMP_AL_MEMBER_ACCOUNT MemberAccount,
    IN PSAMPR_ULONG_ARRAY AliasRids,
    OUT PULONG ExistingAliasCount
    );

NTSTATUS
SampAlSplitMemberSids(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN ULONG Options,
    IN PSAMPR_PSID_ARRAY MemberSids,
    OUT PSAMP_AL_SPLIT_MEMBER_SID_LIST SplitMemberSids
    );

BOOLEAN
SampAlInfoIsValidForDomain(
    IN SAMPR_HANDLE DomainHandle
    );

BOOLEAN
SampAlInfoIsValidForAlias(
    IN SAMPR_HANDLE AliasHandle
    );

VOID
SampInvalidateAliasNameCache(
    ULONG DomainIndex
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Code of Exported Routines                                                //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

NTSTATUS
SamrGetAliasMembership(
    IN SAMPR_HANDLE DomainHandle,
    IN PSAMPR_PSID_ARRAY SidArray,
    OUT PSAMPR_ULONG_ARRAY Membership
    )

/*++

Routine Description:

    This API searches the set of aliases in the specified domain to see
    which aliases, if any, the passed SIDs are members of.  Any aliases
    that any of the SIDs are found to be members of are returned.

    Note that any particular alias will appear only once in the returned list.

Parameters:

    DomainHandle - Handle from a SamOpenDomain call.

    PassedCount - Specifies the number of Sids being passed.

    Sids - Pointer to an arrray of Count pointers to Sids whose alias
        memberships are to be looked up.

    Membership - receives the array of rids rerpresenting the aliases
        in this domain that any of the sid(s) are members of.

Return Values:

    STATUS_SUCCESS - The combined alias membership is in Membership

    STATUS_INVALID_SID - One of the passed sids was invalid

--*/

{
    NTSTATUS                NtStatus=STATUS_SUCCESS, IgnoreStatus;
    PSAMP_OBJECT            DomainContext = NULL;
    SAMP_OBJECT_TYPE        FoundType;
    ULONG                   i;
    ULONG                   SidCount;
    PSID                    *Sids;
    BOOLEAN                 ObjectReferenced = FALSE;
    BOOLEAN                 LockAttempted = FALSE;
    BOOLEAN                 LockHeld = FALSE;
    DSNAME                  **DsNameArray = NULL;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrGetAliasMembership");

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidGetAliasMembership
                   );


    ASSERT(Membership != NULL);
    ASSERT(Membership->Element == NULL);

    SidCount = SidArray->Count;
    Sids = (PSID *)(SidArray->Sids);
    
    //
    //  Validate Parameters
    //
    
    if ((0 == SidCount) || (NULL == Sids))
    {
        // 
        // Nothing to resolve. Set return value properly.
        // 
        
        Membership->Element = NULL;
        Membership->Count = 0;
        
        if (0 != SidCount)
        {
            NtStatus = STATUS_INVALID_PARAMETER;
        }
        
        goto GetAliasMembershipFinish;
    }
    else
    {
        for (i = 0; i < SidCount; i++)
        {
            if (NULL == Sids[i])
            {
                NtStatus = STATUS_INVALID_SID;
                goto GetAliasMembershipFinish;
            }
        }
    }

    //
    // Resolve any Sids for the DS case. This function is a
    // No-Op for the non-DS case.
    //

    NtStatus = SampDsResolveSids(
                    (PSID) SidArray->Sids,
                    SidArray->Count,
                    RESOLVE_SIDS_SID_ONLY_NAMES_OK,
                    &DsNameArray
                    );

    if (NT_SUCCESS(NtStatus))
    {

        DomainContext = (PSAMP_OBJECT)DomainHandle;

       

        //
        // Grab the lock
        //

        SampMaybeAcquireReadLock(DomainContext, 
                                 DOMAIN_OBJECT_DONT_ACQUIRELOCK_EVEN_IF_SHARED,
                                 &LockHeld);
        LockAttempted = TRUE;
     



        //
        // Validate type of, and access to object.
        // 

        NtStatus = SampLookupContext(
                        DomainContext,
                        DOMAIN_GET_ALIAS_MEMBERSHIP,
                        SampDomainObjectType,
                        &FoundType
                        );

        if (STATUS_ACCESS_DENIED == NtStatus)
        {
            //
            // Fix Bug 403247. The NT4 Code checks DOMAIN_LOOKUP
            // access right, instead of GET_ALIAS_MEMBERSHIP. 
            // We are correcting this by checking GET_ALIAS_MEMBERSHIP
            // first. But for backwards compatibility, we have to give 
            // the caller a second try if they fail due to access denied. 
            // 

            if (SampCurrentThreadOwnsLock())
            {
                if(SampTransactionWithinDomain)
                {
                    // before calling into SampLookupContext again, 
                    // we need to make sure TranactionWithinDomain is
                    // not set.
                    SampSetTransactionWithinDomain(FALSE);
                }
            }
            NtStatus = SampLookupContext(
                            DomainContext,
                            DOMAIN_LOOKUP,
                            SampDomainObjectType,
                            &FoundType
                            );
        }

        if (!NT_SUCCESS(NtStatus)) {

            goto GetAliasMembershipError;
        }

        ObjectReferenced = TRUE;

        //
        // Validate the Sids.  if any are invalid, return an error.
        //

        for (i=0; i < SidCount; i++) {

            //
            // Check for valid sid
            //

            if ( (Sids[i] == NULL) || !RtlValidSid(Sids[i]) ) {

                NtStatus = STATUS_INVALID_SID;
                break;
            }
        }

        if (!NT_SUCCESS(NtStatus)) {

            goto GetAliasMembershipError;
        }

        //
        // If the in-memory Alias Membership information for this domain is valid,
        // use it to retrieve the Alias members.
        //

        if (SampAlInfoIsValidForDomain(DomainHandle)) {

            SampDiagPrint(LOGON,("[SAMSS]   SampAlQueryAliasMembership\n"));
            NtStatus = SampAlQueryAliasMembership(
                           DomainHandle,
                           SidArray,
                           Membership
                           );
        } else {

            SampDiagPrint(LOGON,("[SAMSS]   SampAlSlowQueryAliasMembership\n"));
            NtStatus = SampAlSlowQueryAliasMembership(
                           DomainHandle,
                           SidArray,
                           DsNameArray,
                           Membership
                           );
        }



    }

GetAliasMembershipFinish:

    //
    // If necessary, dereference the SAM server object.
    //

    if (ObjectReferenced)
    {
        IgnoreStatus = SampDeReferenceContext2( DomainContext, FALSE );
    }

   
    //
    // Free the read lock if required. Also ends transactions
    //

    if (LockAttempted)
    {
         SampMaybeReleaseReadLock(LockHeld);
    }

    //
    // Release any memory associated with the DSNAME array
    //

    if (NULL!=DsNameArray)
    {
        for (i=0; i<SidCount;i++)
        {
            if (NULL!=DsNameArray[i])
            {
                MIDL_user_free(DsNameArray[i]);
            }

        }

        MIDL_user_free(DsNameArray);
    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidGetAliasMembership
                   );

    return(NtStatus);

GetAliasMembershipError:

   
    goto GetAliasMembershipFinish;
}


NTSTATUS
SampAlQueryAliasMembership(
    IN SAMPR_HANDLE DomainHandle,
    IN PSAMPR_PSID_ARRAY SidArray,
    OUT PSAMPR_ULONG_ARRAY Membership
    )

/*++

Routine Description:

    This function is one of two worker routines for the SamrGetAliasMembership
    API.  This worker uses the Member Alias List to determine which aliases,
    if any, the passed SIDs are members of.  Any aliases that any of the SIDs
    are found to be members of are returned.

    Note that any particular alias will appear only once in the returned list.

    See also SampAlSlowQueryAliasMembership()

    WARNING:  The SAM Read Lock must be held while this function executes.

Parameters:

    DomainHandle - Handle from a SamrOpenDomain call.

    SidArray - Pointer to a counted array of pointers to Sids whose alias
        memberships are to be looked up.

    Membership - Receives the array of rids rerpresenting the aliases
        in this domain that any of the sid(s) are members of.

Return Values:

    STATUS_SUCCESS - The combined alias membership is in Membership

    STATUS_INVALID_SID - One of the passed sids was invalid

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSAMP_AL_MEMBER_ALIAS_LIST MemberAliasList = NULL;
    PSAMP_AL_MEMBER_DOMAIN MemberDomain = NULL;
    ULONG Rid, AliasRid;
    ULONG AliasIndex, SidIndex;
    PSAMP_AL_MEMBER_ACCOUNT MemberAccount = NULL;
    BOOLEAN AliasAlreadyFound;
    ULONG AliasFoundIndex, MembershipMaximumCount;
    PSID DomainSid = NULL;
    PSID Sid = NULL;
    PULONG NewMembership = NULL;

    SAMTRACE("SampAlQueryAliasMembership");
    
    Membership->Count = 0;
    Membership->Element = NULL;

    //
    // Obtain pointer to Alias Member List.
    //

    MemberAliasList = SampAlDomainHandleToMemberAliasList( DomainHandle );

    ASSERT(MemberAliasList != NULL);

    //
    // If there are no Member Domains in this Member Alias List, then just
    // finish.
    //

    if (MemberAliasList->DomainCount == 0) {

        goto QueryAliasMembershipFinish;
    }

    //
    // Allocate Scratch Sid buffer.  We will use this same buffer for splitting
    // each Sid.
    //

    DomainSid = MIDL_user_allocate( RtlLengthRequiredSid( 256 ));

    Status = STATUS_NO_MEMORY;

    if (DomainSid == NULL) {

        goto QueryAliasMembershipError;
    }

    Status = STATUS_SUCCESS;

    //
    // Allocate output array with a nominal initial size.  Reallocate it
    // as necessary
    //

    MembershipMaximumCount = SAMP_AL_INITIAL_MEMBERSHIP_COUNT;

    Membership->Element = MIDL_user_allocate( MembershipMaximumCount * sizeof(ULONG));

    Status = STATUS_NO_MEMORY;

    if (Membership->Element == NULL) {

        goto QueryAliasMembershipError;
    }

    Status = STATUS_SUCCESS;

    //
    // Now query the membership of the array of split Sids.  For each
    // Sid, we skip the Sid if it has an unknown MemberDomain, because
    // it does not belong to any aliases.  For each surviving Sid, we scan the
    // Alias List, skipping entries for aliases we've already entered in the
    // output list.  We search for the Rid only in the section of the
    // Alias List pertinent to the Sid's domain.
    //

    for (SidIndex = 0; SidIndex < SidArray->Count; SidIndex++) {

        Sid = SidArray->Sids[ SidIndex ].SidPointer;

        //
        // Split this Sid into a DomainSid and a Rid.  Note that we re-use
        // the buffer containing the Domain Sid for the next Sid.
        //

        Status = SampSplitSid( Sid, &DomainSid, &Rid);

        if (!NT_SUCCESS(Status)) {

            break;
        }

        //
        // Search the Member Alias List for the Sid's Member Domain
        // (if any).
        //

        Status = SampAlLookupMemberDomain(
                     MemberAliasList,
                     DomainSid,
                     &MemberDomain
                     );

        if (!NT_SUCCESS(Status)) {

            //
            // The only expected error is STATUS_NO_SUCH_DOMAIN.  If we
            // don't get this error, fail the request.  Otherwise, the
            // Sid is not a member of any aliases in the SAM local domain, so
            // just skip to the next Sid.
            //

            if (Status != STATUS_NO_SUCH_DOMAIN) {

                break;
            }

            Status = STATUS_SUCCESS;
            continue;
        }

        //
        // We've found the Member Domain.  Now find the Member Account.
        //

        Status = SampAlLookupMemberAccount(
                     MemberDomain,
                     Rid,
                     &MemberAccount
                     );

        if (!NT_SUCCESS(Status)) {

            //
            // The only expected error is STATUS_NO_SUCH_MEMBER.  If we
            // don't get this error, fail the request.  Otherwise, the
            // Sid is not a member of any aliases in the domain, so just
            // skip to the next Sid.
            //

            if (Status != STATUS_NO_SUCH_MEMBER) {

                break;
            }

            Status = STATUS_SUCCESS;
            continue;
        }

        //
        // We've found the Member Account.  For each of the aliases our Sid
        // belongs to, add the alias to the output list if not already there.
        //

        for (AliasIndex = 0; AliasIndex < MemberAccount->AliasCount; AliasIndex++) {

            AliasRid = MemberAccount->AliasRids[AliasIndex];

            AliasAlreadyFound = FALSE;

            for (AliasFoundIndex = 0;
                 AliasFoundIndex < Membership->Count;
                 AliasFoundIndex++) {

                if (AliasRid == Membership->Element[AliasFoundIndex]) {

                   AliasAlreadyFound = TRUE;
                   break;
                }
            }

            if (!AliasAlreadyFound) {

                //
                // If there isn't enough room in the output Membership
                // array, reallocate it.
                //

                if (Membership->Count == MembershipMaximumCount) {

                    MembershipMaximumCount += SAMP_AL_MEMBERSHIP_COUNT_DELTA;

                    NewMembership = MIDL_user_allocate(
                                        MembershipMaximumCount * sizeof(ULONG)
                                        );

                    Status = STATUS_NO_MEMORY;

                    if (NewMembership == NULL) {

                        break;
                    }

                    Status = STATUS_SUCCESS;

                    RtlMoveMemory(
                        NewMembership,
                        Membership->Element,
                        Membership->Count * sizeof(ULONG)
                        );

                    MIDL_user_free( Membership->Element);
                    Membership->Element = NewMembership;
                }

                Membership->Element[Membership->Count] = AliasRid;
                Membership->Count++;
            }
        }
    }

    //
    // If the buffer we've allocated turns out to be way overboard, allocate
    // a smaller one for the output.
    //

    // TBS

QueryAliasMembershipFinish:

    //
    // If we got as far as allocating a buffer for the DomainSids, free it.
    //

    if (DomainSid != NULL) {

        MIDL_user_free(DomainSid);
        DomainSid = NULL;
    }

    return(Status);

QueryAliasMembershipError:

    //
    // If necessary, free the output membership array.
    //

    if (Membership->Element != NULL) {

        MIDL_user_free( Membership->Element);
        Membership->Element = NULL;
    }

    goto QueryAliasMembershipFinish;
}


NTSTATUS
SampAlSlowQueryAliasMembership(
    IN SAMPR_HANDLE DomainHandle,
    IN PSAMPR_PSID_ARRAY SidArray,
    IN DSNAME   **DsNameArray OPTIONAL,
    OUT PSAMPR_ULONG_ARRAY Membership
    )

/*++

Routine Description:

    This function is the slow version of the worker routine for the
    SamrGetAliasMembership API searches.  It is called when the in-memory
    Alias Information is no longer valid.

    The NT4 version of this function used to make 2 passes at obtaining
    the reverse membership, the first phase will evaulate the reverse
    membership but use the results only to compute the amount of memory
    required, and the second phase will compute the reverse membership
    again, this time filling the buffer. This was acceptable in the NT4 version
    as the slow flavour routine was only used to build the alias membership
    cache and then logons were serviced from the cache.

    In the DS version there is no cache. So it is important that this routine
    be as fast as possible. Therefore this routine pre-allocates a chunk of memory
    and then tries to fill the buffer with the reverse membership. If the reverse
    membership is bigger than a certain number of entries then the call will fail
    with STATUS_TOO_MANY_CONTEXT_IDS. This in reality is not a problem as the
    logon token itself allows only about 1000 entries for Sids, and a reverse
    membership list bigger than that will anyway never fit into the token. Thus by
    allocating sufficient memory at the outset we can avoid evaluating reverse memberships
    twice without any real penalties

    WARNING! The caller of this function must hold the SAM Database Read
    Lock.

Parameters:

    DomainHandle - Handle from a SamOpenDomain call.

    SidArray - Pointer to a counted array of pointers to Sids whose alias
        memberships are to be looked up.

    DsNameArray - Pointer to an array of pointers to DSNm
    Membership - Receives the array of rids rerpresenting the aliases
        in this domain that any of the sid(s) are members of.

Return Values:

    STATUS_SUCCESS - The combined alias membership is in Membership

    STATUS_INVALID_SID - One of the passed sids was invalid

    STATUS_TOO_MANY_CONTEXT_IDS - The reverse membership list is too big to fit in a token

--*/

{
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    ULONG                   i;
    ULONG                   MembershipCount;
    ULONG                   TotalMembershipCount;
    ULONG                   MembershipIndex;
    ULONG                   BufferSize;
    ULONG                   TotalBufferSize;
    ULONG                   SidCount = SidArray->Count;
    PSID                    *Sids = (PSID *) &SidArray->Sids->SidPointer;

    SAMTRACE("SampAlSlowQueryAliasMembership");

    //
    // We preallocate a buffer of upto MAX_SECURITY_IDS defined in samsrvp.h If we reach
    // a buffer overflow condition we fail the call saying STATUS_TOO_MANY_CONTEXT_IDS
    //

    TotalMembershipCount = 0;
    TotalBufferSize = MAX_SECURITY_IDS * sizeof(ULONG);


    Membership->Element = MIDL_user_allocate(TotalBufferSize);

    if (Membership->Element == NULL)
    {

        NtStatus = STATUS_INSUFFICIENT_RESOURCES;

    }
    else
    {

        //
        // Fill in the allocated membership list
        //

        MembershipIndex = 0;

        for (i=0; i < SidCount; i++)
        {

            //
            // Get the membership list for this account
            //

            BufferSize = TotalBufferSize;

            if (IsDsObject(((PSAMP_OBJECT)DomainHandle)))
            {
                //
                // Ds mode, call the Ds API
                //

                ASSERT(ARGUMENT_PRESENT(DsNameArray));

                NtStatus = SampDsGetAliasMembershipOfAccount(
                            ((PSAMP_OBJECT)DomainHandle)->ObjectNameInDs,
                            DsNameArray[i],
                            &MembershipCount,
                            &BufferSize,
                            &(Membership->Element[MembershipIndex])
                            );
            }
            else
            {

                //
                // Call the registry API
                //

                ASSERT(SampCurrentThreadOwnsLock());
                ASSERT(TRUE==SampTransactionWithinDomain);
                ASSERT(SampTransactionDomainIndex==
                            ((PSAMP_OBJECT)DomainHandle)->DomainIndex);

                NtStatus = SampRetrieveAliasMembership(
                                Sids[i],
                                ARGUMENT_PRESENT(DsNameArray)?DsNameArray[i]:NULL,
                                &MembershipCount,
                                &BufferSize,
                                &(Membership->Element[MembershipIndex])
                                );
            }

            if (STATUS_BUFFER_OVERFLOW==NtStatus)
            {

                //
                // Buffer Overrun
                //

                NtStatus = STATUS_TOO_MANY_CONTEXT_IDS;
            }

            if (STATUS_OBJECT_NAME_NOT_FOUND==NtStatus)
            {
                //
                // If the object name was not found, its probaly O.K.
                // just that the Sid is not a member of anything. So
                // continue
                //
                NtStatus = STATUS_SUCCESS;
                continue;
            }
            else if (!NT_SUCCESS(NtStatus))
            {
                break;
            }

            ASSERT(BufferSize == (MembershipCount * sizeof(*(Membership->Element))));

            //
            // Remove duplicate aliases.
            // Membership Count is the number of members that were obtained in this call.
            // TotalShip is the total that we have found so far.
            //

            if (MembershipCount > 0)
            {

                ULONG   ExistingIndex, NewIndex;

                for (ExistingIndex = 0; ExistingIndex < MembershipIndex; ExistingIndex ++)
                {
                    //
                    // Walk through All existing reverse members
                    //

                    for (NewIndex = MembershipIndex; NewIndex < MembershipIndex + MembershipCount; NewIndex ++)
                    {

                        //
                        // Walk through all newly retrieved reverse members
                        //

                        if (Membership->Element[ExistingIndex]==Membership->Element[NewIndex])
                        {

                            //
                            // This alias is already in the list - forget it
                            //

                            //
                            // The way we forget is as follows, move the last element to the current one
                            // and decrement the current one such that we revisit the current element again.
                            //

                            if (NewIndex < MembershipIndex + MembershipCount - 1)
                            {

                                //
                                // Remove the duplicate alias
                                //

                                Membership->Element[NewIndex] =
                                  Membership->Element[MembershipIndex + MembershipCount - 1];

                                NewIndex --;    // So we come back to this alias again
                            }

                            MembershipCount --;
                        }

                    }
                }
            }

            MembershipIndex += MembershipCount;
            TotalMembershipCount = MembershipIndex;

            ASSERT(TotalBufferSize >= BufferSize);

            TotalBufferSize -= BufferSize;
        }

        if (!NT_SUCCESS(NtStatus)) {
            MIDL_user_free(Membership->Element);
            Membership->Element = NULL;
        } else {
            Membership->Count = TotalMembershipCount;
            if (0 == Membership->Count)
            {
                MIDL_user_free(Membership->Element);
                Membership->Element = NULL;
            }
        }
    }

    return NtStatus;
}


NTSTATUS
SampAlQueryMembersOfAlias(
    IN SAMPR_HANDLE AliasHandle,
    OUT PSAMPR_PSID_ARRAY MemberSids
    )

/*++

Routine Description:

    This function returns an array of Sids of accounts that are members of
    a specified alias.

Arguments:

    AliasHandle - Handle to an Alias object

    MemberSids - Receives an array of Sids that belong to the Alias

Return Value:

--*/

{
    NTSTATUS Status;
    PSID *Members = NULL;
    ULONG AliasMemberCount;

    SAMTRACE("SampAlQueryMembersOfAlias");

    Status = SampRetrieveAliasMembers(
                 AliasHandle,
                 &AliasMemberCount,
                 &Members
                 );

    if (!NT_SUCCESS(Status)) {

        goto QueryMembersOfAliasError;
    }

QueryMembersOfAliasFinish:

    MemberSids->Count = AliasMemberCount;
    MemberSids->Sids = (PSAMPR_SID_INFORMATION) Members;
    return(Status);

QueryMembersOfAliasError:

    AliasMemberCount = 0;
    Members = NULL;
    goto QueryMembersOfAliasFinish;
}


NTSTATUS
SampAlAddMembersToAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN ULONG Options,
    IN PSAMPR_PSID_ARRAY MemberSids
    )

/*++

Routine Description:

    This function adds one or more member to an alias.  Any failure results
    in the in-memory Alias Information being discarded.

    WARNING:  The calling function must perform all parameter validation and
    the SAM Database Write Lock must be held.

Parameters:

    AliasHandle - The handle of an opened alias to operate on.

    Options - Specifies optional actions to be taken

        SAMP_AL_VERIFY_NO_MEMBERS_IN_ALIAS - Verify that none of the
            Members are already present in the Alias.

    MemberSids - Array of member Sids to be added.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_MEMBER_IN_ALIAS - The member already belongs to the alias.

--*/

{
    NTSTATUS Status=STATUS_SUCCESS;
    PSAMP_AL_MEMBER_ALIAS_LIST MemberAliasList = NULL;
    PSAMP_AL_MEMBER_ALIAS_LIST OldMemberAliasList = NULL;
    PSAMP_AL_MEMBER_DOMAIN MemberDomain = NULL;
    PSAMP_AL_MEMBER_ACCOUNT MemberAccount = NULL;
    ULONG AliasRid = ((PSAMP_OBJECT) AliasHandle)->TypeBody.Alias.Rid;
    ULONG MemberRid, SidIndex, MembershipCount;
    PSID DomainSid = NULL;
    PSID MemberSid = NULL;
    SAMPR_ULONG_ARRAY AliasRids;

    SAMTRACE("SampAlAddMembersToAlias");

    AliasRids.Count = 0;
    AliasRids.Element = NULL;

    //
    // In Registry Mode, verify that the cached Alias Membership information is valid.
    // In DS Mode, it is NO-OP. but we would like to ASSERT MemberAliasList is invalid.
    // The reason is: 
    // 
    //     Registry Mode: We need to update MemeberAliasList. 
    //                    Before update, MemberAliasList should be valid.
    //     DS Mode: We NEVER update on MemberAliasList. 
    //              The ONLY chance we will call this function is because
    //              we want to build MemberAliasList from scratch. 
    //
    //
    
    if ( IsDsObject(((PSAMP_OBJECT)AliasHandle)) )
    {
        ASSERT( FALSE == SampAlInfoIsValidForAlias(AliasHandle) );
    }
    else 
    {
        if (!SampAlInfoIsValidForAlias(AliasHandle))
        {
            goto AddMembersToAliasFinish;
        }
    }
    
    if (!SampAlInfoIsValidForAlias(AliasHandle) && 
        !IsDsObject(((PSAMP_OBJECT)AliasHandle)) ) {
       goto AddMembersToAliasFinish;
    }

    //
    // If requested, verify that none of members already belong to the alias
    //

    if (Options & SAMP_AL_VERIFY_NO_MEMBERS_IN_ALIAS) {

        Status = SampAlLookupMembersInAlias(
                     AliasHandle,
                     AliasRid,
                     MemberSids,
                     &MembershipCount
                     );

        if (!NT_SUCCESS(Status)) {

            goto AddMembersToAliasError;
        }

        Status = STATUS_MEMBER_NOT_IN_ALIAS;

        if (MembershipCount > 0) {

            goto AddMembersToAliasError;
        }

        Status = STATUS_SUCCESS;
    }

    //
    // Allocate Scratch Sid buffer.  We will use this same buffer for splitting
    // each Sid.
    //

    DomainSid = MIDL_user_allocate( RtlLengthRequiredSid( 256 ));

    Status = STATUS_NO_MEMORY;

    if (DomainSid == NULL) {

        goto AddMembersToAliasError;
    }

    Status = STATUS_SUCCESS;

    //
    // Obtain pointer to Member Alias List.
    //

    MemberAliasList = SampAlAliasHandleToMemberAliasList( AliasHandle );

    ASSERT(MemberAliasList!=NULL);

    OldMemberAliasList = MemberAliasList;

    //
    // For each Sid, obtain its DomainSid and Rid.  Then lookup its
    // DomainSid to obtain the MemberDomain, creating one if necessary.
    // Then lookup its Rid to obtain its MemberAccount, creating one
    // if necessary.  Then add the Alias to the MemebrAccount.
    //

    for (SidIndex = 0; SidIndex < MemberSids->Count; SidIndex++ ) {

        MemberSid = MemberSids->Sids[ SidIndex ].SidPointer;

        Status = SampSplitSid( MemberSid, &DomainSid, &MemberRid );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        //
        // Lookup the Member Domain for this DomainSid in the Member Alias
        // List.
        //

        Status = SampAlLookupMemberDomain(
                     MemberAliasList,
                     DomainSid,
                     &MemberDomain
                     );

        if (!NT_SUCCESS(Status)) {

            if (Status != STATUS_NO_SUCH_DOMAIN) {

                break;
            }

            Status = STATUS_SUCCESS;

            //
            // The Member Domain was not found.  Create a new Member Domain
            //

            Status = SampAlCreateMemberDomain(
                         &MemberAliasList,
                         DomainSid,
                         &MemberDomain
                         );

            if (!NT_SUCCESS(Status)) {

                break;
            }

            //
            // Create a Member Account entry.
            //

            Status = SampAlCreateMemberAccount(
                         &MemberAliasList,
                         &MemberDomain,
                         MemberRid,
                         SAMP_AL_INITIAL_MEMBER_ACCOUNT_ALIAS_CAPACITY,
                         &MemberAccount
                         );

            if (!NT_SUCCESS(Status)) {

                break;
            }

        } else {

            //
            // We found the domain.  This means that we have to lookup
            // each Member Account.  If a Member Account does not exist,
            // we'll create one.  Note that we may already have one due
            // to this account being a member of another Alias.
            //

            Status = SampAlLookupMemberAccount(
                         MemberDomain,
                         MemberRid,
                         &MemberAccount
                         );

            if (!NT_SUCCESS(Status)) {

                if (Status != STATUS_NO_SUCH_MEMBER) {

                    break;
                }

                //
                // Create a Member Account for this Rid,
                //

                Status = SampAlCreateMemberAccount(
                             &MemberAliasList,
                             &MemberDomain,
                             MemberRid,
                             SAMP_AL_INITIAL_MEMBER_ACCOUNT_ALIAS_CAPACITY,
                             &MemberAccount
                             );

                if (!NT_SUCCESS(Status)) {

                    break;
                }
            }
        }

        //
        // We now have a MemberAccount.  Now add the Alias to it.
        //

        AliasRids.Count = 1;
        AliasRids.Element = &AliasRid;

        Status = SampAlAddAliasesToMemberAccount(
                     &MemberAliasList,
                     &MemberDomain,
                     &MemberAccount,
                     0,
                     &AliasRids
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        //
        // Deal with next Member Sid for the Alias.
        //
    }

 

    //
    // If the Member Alias List has been reallocated, store its new address.
    //

    if (MemberAliasList != OldMemberAliasList) {

        SampAlUpdateMemberAliasList( AliasHandle, MemberAliasList );
    }

    if (!NT_SUCCESS(Status)) {

        goto AddMembersToAliasError;
    }

AddMembersToAliasFinish:

    //
    // If necessary, free the DomainSid.
    //

    if (DomainSid != NULL) {

        MIDL_user_free( DomainSid );
        DomainSid = NULL;
    }

    return(Status);

AddMembersToAliasError:

    goto AddMembersToAliasFinish;
}


NTSTATUS
SampAlRemoveMembersFromAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN ULONG Options,
    IN PSAMPR_PSID_ARRAY MemberSids
    )

/*++

Routine Description:

    This function removes a list of members from an Alias.

Arguments:

    AliasHandle - The handle of an opened alias to operate on.

    Options - Specifies optional actions to be taken

        SAMP_AL_VERIFY_ALL_MEMBERS_IN_ALIAS - Verify that all of the
            Members belong to the Alias.

    MemberSids - Array of member Sids to be removed.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSAMP_AL_MEMBER_ALIAS_LIST MemberAliasList = NULL;
    PSAMP_AL_MEMBER_ALIAS_LIST OldMemberAliasList = NULL;
    PSAMP_AL_MEMBER_DOMAIN MemberDomain = NULL;
    PSAMP_AL_MEMBER_ACCOUNT MemberAccount = NULL;
    BOOLEAN MemberDomainDeleted;
    BOOLEAN MemberAccountDeleted;
    ULONG AliasRid = ((PSAMP_OBJECT) AliasHandle)->TypeBody.Alias.Rid;
    ULONG MemberRid, SidIndex, MembershipCount;
    PSID DomainSid = NULL;
    PSID MemberSid = NULL;
    SAMPR_ULONG_ARRAY AliasRids;

    SAMTRACE("SampAlRemoveMembersFromAlias");

    AliasRids.Count = 0;
    AliasRids.Element = NULL;

    //
    // If requested, verify that all of members already belong to the alias
    //

    if (Options & SAMP_AL_VERIFY_ALL_MEMBERS_IN_ALIAS) {

        Status = SampAlLookupMembersInAlias(
                     AliasHandle,
                     AliasRid,
                     MemberSids,
                     &MembershipCount
                     );

        if (!NT_SUCCESS(Status)) {

            goto RemoveMembersFromAliasError;
        }

        Status = STATUS_MEMBER_NOT_IN_ALIAS;

        if (MembershipCount < MemberSids->Count) {

            goto RemoveMembersFromAliasError;
        }

        Status = STATUS_SUCCESS;
    }

    //
    // Obtain pointer to Member Alias List.
    //

    MemberAliasList = SampAlAliasHandleToMemberAliasList( AliasHandle );

    OldMemberAliasList = MemberAliasList;

    if (!NT_SUCCESS(Status)) {

        goto RemoveMembersFromAliasError;
    }

    if (NULL!=MemberAliasList)
    {
        //
        //  Go further only if our cache is functioning
        //

        //
        // For each Sid, obtain its DomainSid and Rid.  Then lookup its
        // DomainSid to obtain the MemberDomain.  Then lookup its Rid to obtain
        // its MemberAccount.  Then remove the Alias from the MemberAccount.
        //

        for (SidIndex = 0; SidIndex < MemberSids->Count; SidIndex++ ) {

            MemberSid = MemberSids->Sids[ SidIndex ].SidPointer;

            Status = SampSplitSid( MemberSid, &DomainSid, &MemberRid );
            if (!NT_SUCCESS(Status))
            {
                break;
            }

            //
            // Lookup the Member Domain for this DomainSid in the Member Alias
            // List.
            //

            Status = SampAlLookupMemberDomain(
                         MemberAliasList,
                         DomainSid,
                         &MemberDomain
                         );

            if (!NT_SUCCESS(Status)) {

                break;
            }

            if (!NT_SUCCESS(Status)) {

                if (Status != STATUS_MEMBER_NOT_IN_ALIAS) {

                    break;
                }

                if (Options & SAMP_AL_VERIFY_ALL_MEMBERS_IN_ALIAS) {

                    ASSERT( FALSE );
                }

                Status = STATUS_SUCCESS;
                if (NULL!=DomainSid)
                {
                    MIDL_user_free(DomainSid);
                    DomainSid = NULL;
                }
                continue;
            }

            //
            // We found the domain.  This means that we have to lookup
            // each Member Account.  If a Member Account does not exist,
            // we'll just skip this account unless we already checked existence.
            // If we checked existence and we can't find it now, its an
            // internal error.
            //

            Status = SampAlLookupMemberAccount(
                         MemberDomain,
                         MemberRid,
                         &MemberAccount
                         );

            if (!NT_SUCCESS(Status)) {

                if (Status != STATUS_MEMBER_NOT_IN_ALIAS) {

                    break;
                }

                if (Options & SAMP_AL_VERIFY_ALL_MEMBERS_IN_ALIAS) {

                    ASSERT( FALSE);
                }

                Status = STATUS_SUCCESS;
                if (NULL!=DomainSid)
                {
                    MIDL_user_free(DomainSid);
                    DomainSid = NULL;
                }
                continue;
            }

            //
            // We now have the MemberAccount.  Now remove the Alias from it.
            //

            AliasRids.Count = 1;
            AliasRids.Element = &AliasRid;

            Status = SampAlRemoveAliasesFromMemberAccount(
                         &MemberAliasList,
                         &MemberDomain,
                         &MemberAccount,
                         0,
                         &AliasRids,
                         &MemberDomainDeleted,
                         &MemberAccountDeleted
                         );

            if (!NT_SUCCESS(Status)) {

                break;
            }

            //
            // Deal with next Member Sid for the Alias.
            //

            MIDL_user_free( DomainSid );
            DomainSid = NULL;
        }

        if (!NT_SUCCESS(Status)) {

            goto RemoveMembersFromAliasError;
        }

        //
        // If the Member Alias List has been reallocated, store its new address.
        //

        if (MemberAliasList != OldMemberAliasList) {

            SampAlUpdateMemberAliasList( AliasHandle, MemberAliasList );
        }
    }



RemoveMembersFromAliasFinish:

    return(Status);

RemoveMembersFromAliasError:

    if (NULL!=DomainSid)
        MIDL_user_free(DomainSid);

    goto RemoveMembersFromAliasFinish;
}


NTSTATUS
SampAlLookupMembersInAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN ULONG AliasRid,
    IN PSAMPR_PSID_ARRAY MemberSids,
    OUT PULONG MembershipCount
    )

/*++

Routine Description:

    This function checks how many of a given list of Member Sids belong
    to an Alias.  It is called prior to updating Alias Memberships.

Arguments:

    AliasHandle - Handle to Alias Object

    AliasRid - Specifies the Rid of the Alias

    MemberSids - Pointer to counted array of pointers to Member Sids

    MembershipCount - Receives count of member Sids in the given set
        that belong to the alias.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    SAMPR_PSID_ARRAY AliasMemberSids;
    ULONG OutputMembershipCount = 0;
    ULONG SidIndex, AliasMemberSidIndex;
    PSID Sid = NULL;
    PSID AliasMemberSid = NULL;

    SAMTRACE("SampAlLookupMembersInAlias");

    //
    // First, query the members of the Alias.
    //

    Status = SampAlQueryMembersOfAlias(
                 AliasHandle,
                 &AliasMemberSids
                 );

    if (!NT_SUCCESS(Status)) {

        // if !NT_SUCCESS(Statys)
        // no memory allocated.

        goto LookupMembersInAliasError;
    }

    //
    // Now scan each of the given Member Sids and count it if it is a member
    // of the Alias.
    //

    for (SidIndex = 0; SidIndex < MemberSids->Count; SidIndex++) {

        Sid = MemberSids->Sids[ SidIndex].SidPointer;

        for (AliasMemberSidIndex = 0;
             AliasMemberSidIndex = AliasMemberSids.Count;
             AliasMemberSidIndex++) {

            AliasMemberSid = AliasMemberSids.Sids[ AliasMemberSidIndex].SidPointer;

            if (RtlEqualSid( Sid, AliasMemberSid)) {

                OutputMembershipCount++;
            }
        }
    }

    *MembershipCount = OutputMembershipCount;

    MIDL_user_free(AliasMemberSids.Sids);  // free the memory allocated

LookupMembersInAliasFinish:

    return(Status);

LookupMembersInAliasError:

    *MembershipCount =0;
    goto LookupMembersInAliasFinish;
}


NTSTATUS
SampAlDeleteAlias(
    IN SAMPR_HANDLE *AliasHandle
    )

/*++

Routine Description:

    This function deletes an alias.

Arguments:

    AliasHandle - Pointer to Handle to Alias

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSAMP_AL_MEMBER_ALIAS_LIST MemberAliasList = NULL;
    PSAMP_AL_MEMBER_DOMAIN MemberDomain = NULL;
    PSAMP_AL_MEMBER_ACCOUNT MemberAccount = NULL;
    BOOLEAN MemberDomainDeleted = FALSE;
    BOOLEAN MemberAccountDeleted = FALSE;
    ULONG AliasRid = ((PSAMP_OBJECT) *AliasHandle)->TypeBody.Alias.Rid;
    LONG DomainIndex;
    ULONG RidCount;
    LONG DomainCount;
    ULONG AccountIndex;
    SAMPR_ULONG_ARRAY AliasRids;
    AliasRids.Count = 1;
    AliasRids.Element = &AliasRid;

    SAMTRACE("SampAlDeleteAlias");

    //
    // Obtain pointer to Member Alias List.
    //

    MemberAliasList = SampAlAliasHandleToMemberAliasList( *AliasHandle );

    if (NULL!= MemberAliasList)
    {
        
        //
        // Traverse the Member Alias List.  Look in every Member Account for the
        // Alias and remove it if present.  This is rather slow if there is a
        // large number of alias relationships for diverse domains.
        //
        DomainCount = (LONG) MemberAliasList->DomainCount;
        for (DomainIndex = 0,
             MemberDomain = SampAlFirstMemberDomain( MemberAliasList );
             DomainIndex < DomainCount;
             DomainIndex++ ) {

            RidCount = MemberDomain->RidCount;
            for (AccountIndex = 0,
                MemberAccount = SampAlFirstMemberAccount( MemberDomain );
                AccountIndex < RidCount;
                AccountIndex++ ) {

                ASSERT(MemberAccount->Signature == SAMP_AL_MEMBER_ACCOUNT_SIGNATURE);
                //
                // We now have the MemberAccount.  Now remove the Alias from it.
                //

                Status = SampAlRemoveAliasesFromMemberAccount(
                             &MemberAliasList,
                             &MemberDomain,
                             &MemberAccount,
                             0,
                             &AliasRids,
                             &MemberDomainDeleted,
                             &MemberAccountDeleted
                             );

                if (!NT_SUCCESS(Status)) {

                    if (Status == STATUS_MEMBER_NOT_IN_ALIAS) {

                        Status = STATUS_SUCCESS;
                        continue;
                    }

                    break;
                }

                //
                // Move the the next member account unless the one we were pointing
                // to was deleted (in which case the next one moved to us).
                //

                if (!MemberAccountDeleted) {
                    MemberAccount = SampAlNextMemberAccount( MemberAccount );
                }

                //
                // If the member domain was deleted, then the count of members
                // is off as is the member account pointer.
                //

                if (MemberDomainDeleted) {
                    break;
                }
            }

            if (!NT_SUCCESS(Status)) {

                break;
            }

            //
            // Move the the next member domain unless the one we were pointing
            // to was deleted (in which case the next one moved to us).
            //

            if (!MemberDomainDeleted) {
                MemberDomain = SampAlNextMemberDomain( MemberDomain );
            }
        }
        
    }

    if (!NT_SUCCESS(Status)) {

        goto DeleteAliasError;
    }

DeleteAliasFinish:

    return(Status);

DeleteAliasError:

    goto DeleteAliasFinish;

}


NTSTATUS
SampAlRemoveAccountFromAllAliases(
    IN PSID AccountSid,
    IN BOOLEAN CheckAccess,
    IN SAMPR_HANDLE DomainHandle OPTIONAL,
    IN PULONG MembershipCount OPTIONAL,
    IN PULONG *Membership OPTIONAL
    )

/*++

Routine Description:

    This routine removes the specified account from the member list of all
    aliases in this domain.

Arguments:

    AccountSid - The SID of the account being Removed.

    CheckAccess - if TRUE, this routine will make sure that the caller
        is allowed REMOVE_ALIAS_MEMBER access to this alias.  If FALSE,
        the caller is already known to have proper access.

    DomainHandle - if CheckAccess is TRUE, this handle must be provided
        to allow access to be checked.

    MembershipCount - if CheckAccess is TRUE, this pointer must be
        provided to receive the number of aliases the account was
        deleted from.

    Membership - if CheckAccess is TRUE, this pointer must be provided
        to point to a list of aliases the account was removed from.  The
        caller must free this list with MIDL_user_free().

Return Value:


    STATUS_SUCCESS - The user has been Removed from all aliases.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSAMP_AL_MEMBER_ALIAS_LIST MemberAliasList = NULL;
    PSAMP_AL_MEMBER_DOMAIN MemberDomain = NULL;
    PSAMP_AL_MEMBER_ACCOUNT MemberAccount = NULL;
    BOOLEAN MemberDomainDeleted;
    PSID DomainSid = NULL;
    LONG DomainIndex;
    ULONG MemberRid, AliasRid;
    SAMPR_ULONG_ARRAY AliasRids;
    AliasRids.Count = 1;
    AliasRids.Element = &AliasRid;

    SAMTRACE("SampAlRemoveAccountFromAllAliases");

    //
    // Obtain pointer to Member Alias List for the Current Transaction Domain.
    //

    DomainIndex = SampTransactionDomainIndex;
    MemberAliasList = SampAlDomainIndexToMemberAliasList( DomainIndex );

    if (NULL!=MemberAliasList)
    {
        //
        // We remove the Account from all aliases by locating its Member Account
        // structure and deleting it.  First, find the Member Domain.
        //

        Status = SampSplitSid( AccountSid, &DomainSid, &MemberRid );
        if (!NT_SUCCESS(Status))
        {
            goto RemoveAccountFromAllAliasesError;

        }

        //
        // Lookup the Member Domain for this DomainSid in the Member Alias
        // List.
        //

        Status = SampAlLookupMemberDomain(
                     MemberAliasList,
                     DomainSid,
                     &MemberDomain
                     );

        if (!NT_SUCCESS(Status)) {

            if (Status != STATUS_NO_SUCH_DOMAIN) {

                goto RemoveAccountFromAllAliasesError;
            }

            //
            // There is no member Domain object for this account.  This means
            // the account does not belong to any aliases.
            //

            Status = STATUS_SUCCESS;

            goto RemoveAccountFromAllAliasesFinish;
        }

        //
        // We found the Member Domain.  Now find the Member Account.
        //

        Status = SampAlLookupMemberAccount(
                     MemberDomain,
                     MemberRid,
                     &MemberAccount
                     );

        if (!NT_SUCCESS(Status)) {

            if (Status != STATUS_NO_SUCH_MEMBER) {

                goto RemoveAccountFromAllAliasesError;
            }

            Status = STATUS_SUCCESS;

            goto RemoveAccountFromAllAliasesFinish;
        }

        //
        // If CheckAccess = TRUE, return a list of Aliases that the account was
        // a member of.
        //

        if (CheckAccess) {

            *Membership = MIDL_user_allocate( MemberAccount->AliasCount * sizeof(ULONG));
            *MembershipCount = MemberAccount->AliasCount;

            Status = STATUS_NO_MEMORY;

            if (*Membership == NULL) {

                goto RemoveAccountFromAllAliasesError;
            }

            Status = STATUS_SUCCESS;
        }

        //
        // We now have the MemberAccount.  Now delete it, thereby removing the
        // account from all Aliases.
        //

        Status = SampAlDeleteMemberAccount(
                     &MemberAliasList,
                     &MemberDomain,
                     MemberAccount,
                     &MemberDomainDeleted
                     );

        if (!NT_SUCCESS(Status)) {

            goto RemoveAccountFromAllAliasesError;
        }
    }

RemoveAccountFromAllAliasesFinish:

    //
    // Free the Domain Sid buffer (if any)
    //

    if (DomainSid != NULL) {

        MIDL_user_free( DomainSid );
        DomainSid = NULL;
    }

    return(Status);

RemoveAccountFromAllAliasesError:

    if (CheckAccess) {

        if (NULL!=*Membership)
            MIDL_user_free(*Membership);
        *Membership = NULL;
        *MembershipCount = 0;
    }

    goto RemoveAccountFromAllAliasesFinish;
}


NTSTATUS
SampAlBuildAliasInformation(
    )

/*++

Routine Description:

    This function builds the Alias Information for each of the SAM Local
    Domains.  For each Domain, this information consists of the Member Alias
    List. 
    
    NOTE: in both DS Mode and Registry Mode, we need to acquire SAM Read Lock.

Arguments:

    None.

Return Values:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LONG DomainIndex;

    SAMTRACE("SampAlBuildAliasInformation");
    
    SampAcquireReadLock();
    
    // 
    // We need to Validate Domain Cache, because in SampAlBuildMemberAliasList(), we will 
    // try to call SampSetTransactionDomain().
    //
    Status = SampValidateDomainCache();
    
    if (!NT_SUCCESS(Status))
    {
        goto BuildAliasInformationError;
    }

    for (DomainIndex = SampDsGetPrimaryDomainStart(); 
         DomainIndex < (LONG) SampDefinedDomainsCount; 
         DomainIndex++) {

        if (SampUseDsData) {
            //
            // DS Mode, just enable Builtin Domain Alias Caching
            //
            
            if (IsBuiltinDomain(DomainIndex)) {


                Status = SampAlBuildMemberAliasList(DomainIndex);
            }
        }
        else {
            //
            // Register Mode, enable both Builtin Domain and Account Domain
            //
            
            if (SampAlEnableBuildingOfList[ DomainIndex]) {
                
                Status = SampAlBuildMemberAliasList(DomainIndex);

            }

        }

        //
        // if SampAlBuildMemberAliasList failed, do NOT try to build 
        // Alias Cache Information any more. And free the memory
        // allocated.
        //

        if (!NT_SUCCESS(Status))
        {
            PSAMP_AL_MEMBER_ALIAS_LIST MemberAliasList = 
                        SampAlDomainIndexToMemberAliasList(DomainIndex);

            //
            // if SampAlBuildMemberAliasList returns failure,
            // Alias Membership Information should already been marked as 
            // invalid in SampAlBuildMemberAliasList. 
            // ASSERT and make it invalid again just for safety reason.
            //

            ASSERT(FALSE==SampAlInfoIsValid(DomainIndex));
            SampAlInfoMakeInvalid(DomainIndex);

            if (MemberAliasList!=NULL)
            {
                SampDefinedDomains[DomainIndex].AliasInformation.MemberAliasList = NULL;
                MIDL_user_free(MemberAliasList);
                MemberAliasList = NULL;
            }

            break;
        }
    }

    if (!NT_SUCCESS(Status)) {

        goto BuildAliasInformationError;
    }

BuildAliasInformationFinish:

    SampReleaseReadLock();

    return(Status);

BuildAliasInformationError:

    goto BuildAliasInformationFinish;
}

NTSTATUS
SampAlDelayedBuildAliasInformation(
    IN PVOID Parameter                                   
    )
/*++

Routine Description:

    This function builds the Alias Information for each of the SAM Local 
    Domains. For each Domain, this information consists of the Member Alias
    List. Because this rountine is called 10 mins after the system been 
    booted, so we will acquire SAM Read lock in SampAlBuildAliasInformation.
    
    If the Alias Cache is not successfully built, we will reschedule 
    this routine for another time.
    
Arguments:

    Parameter - NULL. Nothing passed by Parameter and we do not use it at all. 
                Parameter exists because of LsaIRegisterNotification.
    
Return Values:

    NtStatus returned SampAlBuildAliasInformation.

--*/
                                   
{
    NTSTATUS    NtStatus = STATUS_SUCCESS, IgnoreStatus;
        
    SAMTRACE("SampAlDelayedBuildAliasInformation");
    
    
    NtStatus = SampAlBuildAliasInformation();
    
    if (!NT_SUCCESS(NtStatus))
    {
        goto DelayedBuildAliasInfoError;
    }
    
DelayedBuildAliasInfoFinish:

    return(NtStatus);


DelayedBuildAliasInfoError:

    //
    // If SampAlBuildAliasInformation failed due to the buffer size
    // limitation, don't schedule next attemp. For all the other error
    // Hope we can recovery later.
    // 

    if (STATUS_BUFFER_OVERFLOW != NtStatus)
    {
        LsaIRegisterNotification(
                SampAlDelayedBuildAliasInformation,
                NULL,
                NOTIFIER_TYPE_INTERVAL,
                0,            // no class
                NOTIFIER_FLAG_ONE_SHOT,
                600,          // wait for another 10 mins
                NULL          // no handle
                ); 
    }

    goto DelayedBuildAliasInfoFinish;

}


NTSTATUS
SampAlInvalidateAliasInformation(
    IN ULONG DomainIndex 
    )
/*++                                 

Routine Description:

    This function check the state of Member Alias List in the specified 
    Member Domain for the specified Alias referenced by AliasHandle. 
    If the Member Alias List is valid then call SampAlInvalidateMemberAliasList
    to invalidate it.

    This routine also invalidates all alias name caches.
    
    NOTE: The calling function should hold the SAM write lock.
    
Argument:

    AliasHandle - Pointer to an Alias Context
    
Return Value:

    
--*/
{
    
    NTSTATUS    NtStatus = STATUS_SUCCESS;
        
    SAMTRACE("SampAlInvalidateAliasInformation");
    
    ASSERT(SampCurrentThreadOwnsLock());

    SampInvalidateAliasNameCache(DomainIndex);
           
    // 
    // if Alias Informaiton is invalid, return immediately.    
    // this will prevent mutliple invalidations at the same time
    //
    
    if ( !SampAlInfoIsValid(DomainIndex) )
    {
        return( NtStatus );
    }
    
    NtStatus = SampAlInvalidateMemberAliasList( DomainIndex );
        
    return( NtStatus );
    
}



////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Private functions                                                      //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

NTSTATUS
SampAlCreateMemberAccount(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN ULONG Rid,
    IN ULONG AliasCapacity,
    OUT PSAMP_AL_MEMBER_ACCOUNT *MemberAccount
    )

/*++

Routine Description:

    This function creates an empty Member Account in the specified Member Domain
    for the specified Member Rid.  There must not already be al account for this
    Rid.  The Member Account is appended to the end of any existing ones in the
    Member Domain.

Arguments:

    MemberAliasList - Pointer to pointer to Member Alias List.

    MemberDomain - Pointer to Member Domain in which the Member Account is
        to be created.  The Member Domain must already exist.

    Rid - Specifies the Account Rid.

    AliasCapacity - Specifies the initial number of Alias Rids that the
        MemberAccount can hold.

    MemberAccount - Receives pointer to the newly created Member Account.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG MaximumLengthMemberAccount;
    PSAMP_AL_MEMBER_ACCOUNT OutputMemberAccount = NULL;

    SAMTRACE("SampAlCreateMemberAccount");

    //
    // Calculate the length of data needed for the new member Account entry.
    //

    MaximumLengthMemberAccount = SampAlLengthRequiredMemberAccount( AliasCapacity );

    //
    // Allocate space for the Member Account.
    //

    Status = SampAlAllocateMemberAccount(
                 MemberAliasList,
                 MemberDomain,
                 MaximumLengthMemberAccount,
                 &OutputMemberAccount
                 );

    if (!NT_SUCCESS(Status)) {

        goto CreateMemberAccountError;
    }

    //
    // Scratch the new Member Account
    //

    OutputMemberAccount->Signature = SAMP_AL_MEMBER_ACCOUNT_SIGNATURE;
    OutputMemberAccount->MaximumLength = MaximumLengthMemberAccount;
    OutputMemberAccount->UsedLength =
        SampAlOffsetFirstAlias( OutputMemberAccount );
    ASSERT(OutputMemberAccount->MaximumLength >=
           OutputMemberAccount->UsedLength);
    OutputMemberAccount->Rid = Rid;
    OutputMemberAccount->AliasCount = 0;

    ((*MemberDomain)->RidCount)++;
    *MemberAccount = OutputMemberAccount;

CreateMemberAccountFinish:

    return(Status);

CreateMemberAccountError:

    *MemberAccount = NULL;
    SampAlInfoMakeInvalid( (*MemberAliasList)->DomainIndex );

    goto CreateMemberAccountFinish;
}


NTSTATUS
SampAlAllocateMemberAccount(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN ULONG MaximumLengthMemberAccount,
    OUT PSAMP_AL_MEMBER_ACCOUNT *MemberAccount
    )

/*++

Routine Description:

    This function allocates the space for a new Member Account in a Member
    Domain.  If necessary, the Mmeber Domain and its associated Member Alias
    List will be grown.

Arguments:

    MemberAliasList - Pointer to pointer to the Member Alias List.

    MemberDomain - Pointer to pointer to the Member Domain

    MaximumLengthMemberAccount - Initial Maximum Length required for the
        Member Account

    MemberAccount - receives pointer to the newly allocated Member Account

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SpaceAvailable;

    SAMTRACE("SampAlAllocateMemberAccount");

    //
    // Calculate the space available in the Member Domain
    //

    SpaceAvailable = (*MemberDomain)->MaximumLength - (*MemberDomain)->UsedLength;

    if (MaximumLengthMemberAccount > SpaceAvailable) {

        Status = SampAlGrowMemberDomain(
                     MemberAliasList,
                     MemberDomain,
                     MaximumLengthMemberAccount - SpaceAvailable
                     );

        if (!NT_SUCCESS(Status)) {

            goto AllocateMemberAccountError;
        }
    }

    //
    // The Member Domain is now guaranteed to be large enough.  Reserve the
    // space for the new Member Account.
    //

    *MemberAccount = SampAlNextNewMemberAccount(*MemberDomain);
    (*MemberDomain)->UsedLength += MaximumLengthMemberAccount;
    ASSERT((*MemberDomain)->MaximumLength >=
           (*MemberDomain)->UsedLength);

AllocateMemberAccountFinish:

    return(Status);

AllocateMemberAccountError:

    SampAlInfoMakeInvalid( (*MemberAliasList)->DomainIndex );
    *MemberAccount = NULL;

    goto AllocateMemberAccountFinish;
}


NTSTATUS
SampAlGrowMemberAccount(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN OUT PSAMP_AL_MEMBER_ACCOUNT *MemberAccount,
    IN ULONG ExtraSpaceRequired
    )

/*++

Routine Description:

    This function grows a Member Account by at least the requested amount.  If
    necessary, the containing Member Domain and Member Alias List will also be
    grown.

Arguments:

    MemberAliasList - Pointer to pointer to the Member Alias List.

    MemberDomain - Pointer to pointer to the Member Domain

    MemberAccount - Pointer to Pointer to the Member Account.

    ExtraSpaceRequired - Extra space needed in the Member Account.

Return Values:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SpaceAvailable, MemberAccountOffset, CopyLength;
    PUCHAR Destination = NULL;
    PUCHAR Source = NULL;

    SAMTRACE("SampAlGrowMemberAccount");

    //
    // Calculate the space available in the Member Domain
    //

    SpaceAvailable = (*MemberDomain)->MaximumLength - (*MemberDomain)->UsedLength;

    if (ExtraSpaceRequired > SpaceAvailable) {

        //
        // We need to grow the Member Domain.  Calculate the offset of the
        // Member Account in the old Member Domain, grow the Member Domain
        // and then calculate the new address of the Member Account.
        //

        MemberAccountOffset = SampAlMemberAccountToOffset(
                                  *MemberDomain,
                                  *MemberAccount
                                  );

        Status = SampAlGrowMemberDomain(
                     MemberAliasList,
                     MemberDomain,
                     ExtraSpaceRequired - SpaceAvailable
                     );

        if (!NT_SUCCESS(Status)) {

            goto GrowMemberAccountError;
        }

        *MemberAccount = SampAlMemberAccountFromOffset(
                             *MemberDomain,
                             MemberAccountOffset
                             );

    }

    //
    // The Member Domain is now guaranteed to be large enough.
    // Now shift any Member Accounts that follow the one being grown
    // up to make room for the expanded Member Account.  The source address
    // for the move is the address of the next Member Account (if any) based
    // on the existing size of the Member Account.  The destination address
    // of the move is the address of the next Member Account (if any) based
    // on the new size of the Member Account.
    //

    Source = (PUCHAR) SampAlNextMemberAccount( *MemberAccount );
    (*MemberAccount)->MaximumLength += ExtraSpaceRequired;
    Destination = (PUCHAR) SampAlNextMemberAccount( *MemberAccount );
    CopyLength =
        (ULONG)(((PUCHAR)(SampAlNextNewMemberAccount(*MemberDomain))) - Source);

    //
    // Reserve the space in the Member Domain.  If all's well, the
    // end of the destination buffer should match the updated end of the
    // used area of the Member Domain.
    //

    (*MemberDomain)->UsedLength += ExtraSpaceRequired;
    ASSERT((*MemberDomain)->MaximumLength >=
           (*MemberDomain)->UsedLength);

    ASSERT( Destination + CopyLength ==
            (PUCHAR) SampAlNextNewMemberAccount( *MemberDomain ));
    ASSERT( Destination + CopyLength <=
            (PUCHAR)(*MemberAliasList) + (*MemberAliasList)->MaximumLength );
    ASSERT( Destination + CopyLength <=
            (PUCHAR)(*MemberDomain) + (*MemberDomain)->MaximumLength );

    if (CopyLength > 0) {

        RtlMoveMemory( Destination, Source, CopyLength );
    }

GrowMemberAccountFinish:

    return(Status);

GrowMemberAccountError:

    SampAlInfoMakeInvalid( (*MemberAliasList)->DomainIndex );

    goto GrowMemberAccountFinish;
}


NTSTATUS
SampAlLookupMemberAccount(
    IN PSAMP_AL_MEMBER_DOMAIN MemberDomain,
    IN ULONG MemberRid,
    OUT PSAMP_AL_MEMBER_ACCOUNT *MemberAccount
    )

/*++

Routine Description:

    This function looks up an Account Rid in a Member Domain to see if there
    is a Member Account structure for it.

Arguments:

    MemberDomain - Pointer to Member Domain

    MemberRid - Specifies the Account Rid

    MemberAccount - Receives pointer to Member Account if found.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSAMP_AL_MEMBER_ACCOUNT NextMemberAccount = NULL;
    ULONG RidIndex;
    BOOLEAN AccountFound = FALSE;

    SAMTRACE("SampAlLookupMemberAccount");


    for (RidIndex = 0,
         NextMemberAccount = SampAlFirstMemberAccount( MemberDomain );
         RidIndex < MemberDomain->RidCount;
         RidIndex++, NextMemberAccount = SampAlNextMemberAccount( NextMemberAccount)) {

        if (MemberRid == NextMemberAccount->Rid) {

            AccountFound = TRUE;

            break;
        }
    }

    Status = STATUS_NO_SUCH_MEMBER;

    if (!AccountFound) {

        goto LookupMemberAccountError;
    }

    *MemberAccount = NextMemberAccount;
    Status = STATUS_SUCCESS;

LookupMemberAccountFinish:

    return(Status);

LookupMemberAccountError:

    goto LookupMemberAccountFinish;
}


NTSTATUS
SampAlAddAliasesToMemberAccount(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN OUT PSAMP_AL_MEMBER_ACCOUNT *MemberAccount,
    IN ULONG Options,
    IN PSAMPR_ULONG_ARRAY AliasRids
    )

/*++

Routine Description:

    This function adds an array of aliases to a Member Account.  An error
    will be returned if any of the aliases exist in the Member Account.
    If necessary, the containing Member Account, Member Domain and Member
    Alias List will also be grown.

Arguments:

    MemberAliasList - Pointer to pointer to the Member Alias List.

    MemberDomain - Pointer to pointer to the Member Domain

    MemberAccount - Pointer to Pointer to the Member Account.

    Options - Specifies optional actions to be taken

        SAMP_AL_VERIFY_NO_ALIASES_IN_ACCOUNT - Verify that none of the
           Aliases presented belong to the various Member Accounts.

    AliasRids - Pointer to counted array of Alias Rids.

Return Values:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SpaceRequired, SpaceAvailable, CopyLength;
    PUCHAR Source = NULL;
    PUCHAR Destination = NULL;
    ULONG ExistingAliasCount=0;

    SAMTRACE("SampAlAddAliasesToMemberAccount");

    //
    // If requested, verify that none of the Aliases are already
    // in the Member Account
    //

    if (Options & SAMP_AL_VERIFY_NO_ALIASES_IN_ACCOUNT) {

        Status = SampAlLookupAliasesInMemberAccount(
                     *MemberAccount,
                     AliasRids,
                     &ExistingAliasCount
                     );

        if (!NT_SUCCESS(Status)) {

            goto AddAliasesToMemberAccountError;
        }

        Status = STATUS_MEMBER_IN_ALIAS;

        if (ExistingAliasCount > 0) {

            goto AddAliasesToMemberAccountError;
        }

        Status = STATUS_SUCCESS;
    }

    //
    // Calculate the space required for the new Aliases.
    //

    SpaceRequired = AliasRids->Count * sizeof( ULONG );

    //
    // If there is not enough space available in the Member Account,
    // grow it.
    //

    SpaceAvailable = (*MemberAccount)->MaximumLength - (*MemberAccount)->UsedLength;

    if (SpaceRequired > SpaceAvailable) {

        Status = SampAlGrowMemberAccount(
                     MemberAliasList,
                     MemberDomain,
                     MemberAccount,
                     SpaceRequired - SpaceAvailable
                     );

        if (!NT_SUCCESS(Status)) {

            goto AddAliasesToMemberAccountError;
        }
    }

    //
    // The Member Account is now large enough.  Copy in the aliases.
    //

    Destination = (PUCHAR) SampAlNextNewAliasInMemberAccount( *MemberAccount );
    Source = (PUCHAR) AliasRids->Element;
    CopyLength = SpaceRequired;
    (*MemberAccount)->UsedLength += SpaceRequired;
    ASSERT((*MemberAccount)->MaximumLength >=
           (*MemberAccount)->UsedLength);
    RtlMoveMemory( Destination, Source, CopyLength );

    //
    // Update the count of Aliases both in this Member Account and in the
    // Member Alias List.
    //

    (*MemberAccount)->AliasCount += AliasRids->Count;

AddAliasesToMemberAccountFinish:

    return(Status);

AddAliasesToMemberAccountError:

    goto AddAliasesToMemberAccountFinish;
}


NTSTATUS
SampAlLookupAliasesInMemberAccount(
    IN PSAMP_AL_MEMBER_ACCOUNT MemberAccount,
    IN PSAMPR_ULONG_ARRAY AliasRids,
    OUT PULONG ExistingAliasCount
    )

/*++

Routine Description:

    This function checks a set of Alias Rids to see if any are present in a
    Member Account.

Arguments:

    MemberAccount - Pointer to Member Account

    AliasRids - Specifies counted array of Alias Rids.

    ExistingAliasCount - Receives a count of the Alias Rids presented that
        are already in the Member Account.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG AliasIndex, AliasInMemberAccountIndex;

    SAMTRACE("SampAlLookupAliasesInMemberAccount");

    //
    // Scan the Alias Rids, looking each one up.
    //

    for (AliasIndex = 0; AliasIndex < AliasRids->Count; AliasRids++ ) {

        for (AliasInMemberAccountIndex = 0;
             AliasInMemberAccountIndex < MemberAccount->AliasCount;
             AliasInMemberAccountIndex++) {

            if (AliasRids->Element[ AliasIndex ] ==
                MemberAccount->AliasRids[ AliasInMemberAccountIndex ] ) {

                (*ExistingAliasCount)++;
            }
        }
    }

    return(Status);
}


NTSTATUS
SampAlRemoveAliasesFromMemberAccount(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN OUT PSAMP_AL_MEMBER_ACCOUNT *MemberAccount,
    IN ULONG Options,
    IN PSAMPR_ULONG_ARRAY AliasRids,
    OUT    PBOOLEAN MemberDomainDeleted,
    OUT    PBOOLEAN MemberAccountDeleted
    )

/*++

Routine Description:

    This function removes aliases from a Member Account.  The Aliases need
    not already exist unless an option to check that they do exist is
    specified.  No down sizing of the Member Account occurs, but an
    empty one will be deleted.

    NOTE: I don't know why ScottBi made MemberAliasList, MemberDomain, and
          MemberAccount parameters pointers to pointers.  He never updates
          the pointers so he could have passed them in directly.  JK

Arguments:

    MemberAliasList - Pointer to pointer to the Member Alias List.

    MemberDomain - Pointer to pointer to the Member Domain

    MemberAccount - Pointer to Pointer to the Member Account.

    Options - Specifies optional actions to be taken

        SAMP_AL_VERIFY_ALL_ALIASES_IN_ACCOUNT - Verify that none of the
           Aliases presented belong to the Member Account.

    MemberDomainDeleted - Will be set to TRUE if the member domain
        pointed to by MemberDomain was deleted.  Otherwise FALSE is returned.

    MemberAccountDeleted - Will be set to TRUE if the member account
        pointed to by MemberAccount was deleted.  Otherwise FALSE is returned.

    AliasRids - Pointer to counted array of Alias Rids.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ExistingAliasIndex, LastAliasIndex, RemoveAliasIndex, ExistingAlias;
    ULONG ExistingAliasCount=0;

    SAMTRACE("SampAlRemoveAliasesFromMemberAccount");

    (*MemberDomainDeleted)  = FALSE;
    (*MemberAccountDeleted) = FALSE;

    //
    // If requested, verify that all of the Aliases are already
    // in the Member Account
    //

    if (Options & SAMP_AL_VERIFY_ALL_ALIASES_IN_ACCOUNT) {

        Status = SampAlLookupAliasesInMemberAccount(
                     *MemberAccount,
                     AliasRids,
                     &ExistingAliasCount
                     );

        if (!NT_SUCCESS(Status)) {

            goto RemoveAliasesFromMemberAccountError;
        }

        Status = STATUS_MEMBER_IN_ALIAS;

        if (ExistingAliasCount < AliasRids->Count) {

            goto RemoveAliasesFromMemberAccountError;
        }

        Status = STATUS_SUCCESS;
    }
    
    //
    // If the Member Account is empty, then somebody forgot to delete it
    //

    ASSERT((*MemberAccount)->AliasCount != 0);


    LastAliasIndex = (*MemberAccount)->AliasCount - 1;

    for (ExistingAliasIndex = 0;
         ExistingAliasIndex < (*MemberAccount)->AliasCount;
         ExistingAliasIndex++) {

        ExistingAlias = (*MemberAccount)->AliasRids[ ExistingAliasIndex ];

        for (RemoveAliasIndex = 0;
             RemoveAliasIndex < AliasRids->Count;
             RemoveAliasIndex++) {

            if (ExistingAlias == AliasRids->Element[ RemoveAliasIndex ]) {

                //
                // We're to delete this Alias.  If this Alias Rid is not at the
                // end of the list contained in the Member Account, overwrite
                // it with the one at the end of the list.
                //

                if (ExistingAliasIndex < LastAliasIndex) {

                    (*MemberAccount)->AliasRids[ ExistingAliasIndex] =
                    (*MemberAccount)->AliasRids[ LastAliasIndex];
                }

                (*MemberAccount)->AliasCount--;
                (*MemberAccount)->UsedLength -= sizeof(ULONG);
                ASSERT((*MemberAccount)->MaximumLength >=
                       (*MemberAccount)->UsedLength);

                //
                // If the Member Account is now empty, quit.
                //

                if ((*MemberAccount)->AliasCount == 0) {

                    break;
                }

                LastAliasIndex--;
            }
        }

        //
        // If the Member Account is now empty, quit.
        //

        if ((*MemberAccount)->AliasCount == 0) {

            break;
        }
    }

    //
    // If the Member Account is now empty, delete it.
    //

    if ((*MemberAccount)->AliasCount == 0) {

        Status = SampAlDeleteMemberAccount(
                     MemberAliasList,
                     MemberDomain,
                     *MemberAccount,
                     MemberDomainDeleted
                     );
        if (NT_SUCCESS(Status)) {
            (*MemberAccountDeleted) = TRUE;
        }
    }

RemoveAliasesFromMemberAccountFinish:

    return(Status);

RemoveAliasesFromMemberAccountError:

    goto RemoveAliasesFromMemberAccountFinish;
}


NTSTATUS
SampAlDeleteMemberAccount(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN OUT PSAMP_AL_MEMBER_ACCOUNT MemberAccount,
    OUT    PBOOLEAN                MemberDomainDeleted
    )

/*++

Routine Description:

    This function deletes a Member Account.  Currently, the containing
    Member Domain and Member Alias List are not shrunk, but the containing
    Member Domain will be deleted if empty.

Arguments:

    MemberAliasList - Pointer to pointer to the Member Alias List.

    MemberDomain - Pointer to pointer to the Member Domain

    MemberAccount - Pointer to the Member Account.

    MemberDomainDeleted - Will be set to TRUE if the member domain
        pointed to by MemberDomain was deleted.  Otherwise FALSE is returned.


Return Values:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PUCHAR Source = NULL;
    PUCHAR Destination = NULL;
    ULONG CopyLength;

    SAMTRACE("SampAlDeleteMemberAccount");

    (*MemberDomainDeleted) = FALSE;

    //
    // Calculate pointers for moving the residual portion of the Member
    // Domain down to close the gap left by the extant Member Account.
    // unused space.  The start of the residual portion is the end of the
    // Member Account being deleted.  The length of the residual portion is
    // the distance from the start to the end of the used portion of the
    // Member Domain.
    //

    Source = (PUCHAR) SampAlNextMemberAccount( MemberAccount );
    Destination = (PUCHAR) MemberAccount;
    CopyLength = (ULONG)((PUCHAR) SampAlNextNewMemberAccount( *MemberDomain ) - Source);

    (*MemberDomain)->UsedLength -= MemberAccount->MaximumLength;
    ASSERT((*MemberDomain)->MaximumLength >=
           (*MemberDomain)->UsedLength);
    (*MemberDomain)->RidCount--;

    if (CopyLength > 0) {

        RtlMoveMemory( Destination, Source, CopyLength );
#if DBG
        {
            PSAMP_AL_MEMBER_ACCOUNT Member = (PSAMP_AL_MEMBER_ACCOUNT) Destination;
            ASSERT(Member->Signature == SAMP_AL_MEMBER_ACCOUNT_SIGNATURE);
        }

#endif
    }

    //
    // If the Member Domain now has no Member Accounts, delete it.
    //

    if ((*MemberDomain)->RidCount == 0) {

        Status = SampAlDeleteMemberDomain(
                     MemberAliasList,
                     *MemberDomain
                     );

        if (!NT_SUCCESS(Status)) {
            goto DeleteMemberAccountError;
        }
        (*MemberDomainDeleted) = TRUE;
    }

DeleteMemberAccountFinish:

    return(Status);

DeleteMemberAccountError:

    goto DeleteMemberAccountFinish;
}


NTSTATUS
SampAlCreateMemberDomain(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN PSID DomainSid,
    OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain
    )

/*++

Routine Description:

    This function creates a new Member Domain in the specified Alias Member
    List.

Arguments:

    MemberAliasList - Pointer to pointer to Alias Member List.

    DomainSid - Pointer to Sid of Domain to which this MemberDomain
        relates.

    MemberDomain - Receives pointer to the newly created Member Domain.

Return Values:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSAMP_AL_MEMBER_DOMAIN OutputMemberDomain = NULL;
    PSAMP_AL_MEMBER_ACCOUNT OutputMemberAccount = NULL;
    ULONG MaximumLengthMemberDomain;
    ULONG DomainSidLength = RtlLengthSid(DomainSid);
    ULONG AlternativeLength;

    SAMTRACE("SampAlCreateMemberDomain");


    //
    // Allocate the Member Domain.
    //

    MaximumLengthMemberDomain = SAMP_AL_INITIAL_MEMBER_DOMAIN_LENGTH;
    AlternativeLength = FIELD_OFFSET(SAMP_AL_MEMBER_DOMAIN, DomainSid)
                        + DomainSidLength;
    if (MaximumLengthMemberDomain < AlternativeLength) {
        MaximumLengthMemberDomain = AlternativeLength;
    }

    Status = SampAlAllocateMemberDomain(
                 MemberAliasList,
                 MaximumLengthMemberDomain,
                 &OutputMemberDomain
                 );

    if (!NT_SUCCESS(Status)) {

        goto CreateMemberDomainError;
    }

    //
    // Setup the new Member Domain entry.
    //

    OutputMemberDomain->MaximumLength = MaximumLengthMemberDomain;
    OutputMemberDomain->RidCount = 0;
    OutputMemberDomain->Signature = SAMP_AL_MEMBER_DOMAIN_SIGNATURE;

    RtlCopySid(
        DomainSidLength,
        &OutputMemberDomain->DomainSid,
        DomainSid
        );

    OutputMemberDomain->UsedLength = SampAlOffsetFirstMemberAccount(
                                         OutputMemberDomain
                                         );
    ASSERT(OutputMemberDomain->MaximumLength >=
           OutputMemberDomain->UsedLength);

    ((*MemberAliasList)->DomainCount)++;
    *MemberDomain = OutputMemberDomain;

CreateMemberDomainFinish:

    return(Status);

CreateMemberDomainError:

    *MemberDomain = NULL;
    goto CreateMemberDomainFinish;
}


NTSTATUS
SampAlAllocateMemberDomain(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN ULONG MaximumLengthMemberDomain,
    OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain
    )

/*++

Routine Description:

    This function allocates the space for a new Member Domain in a Member
    Alias List.  If necessary, the Member Alias List will be grown.

Arguments:

    MemberAliasList - Pointer to pointer to the Member Alias List.

    MaximumLengthMemberDomain - Initial Maximum Length required for the
        Member Domain

    MemberDomain - Receives pointer to the Member Domain

Return Values:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SpaceAvailable;

    SAMTRACE("SampAlAllocateMemberDomain");

    //
    // Calculate the space available in the Member Alias List
    //

    SpaceAvailable = (*MemberAliasList)->MaximumLength - (*MemberAliasList)->UsedLength;

    if (MaximumLengthMemberDomain > SpaceAvailable) {

        Status = SampAlGrowMemberAliasList(
                     MemberAliasList,
                     MaximumLengthMemberDomain - SpaceAvailable
                     );

        if (!NT_SUCCESS(Status)) {

            goto AllocateMemberDomainError;
        }
    }

    //
    // The Member Alias List is now guaranteed to be large enough.  Reserve the
    // space for the new Member Domain.
    //

    *MemberDomain = SampAlNextNewMemberDomain(*MemberAliasList);
    (*MemberAliasList)->UsedLength += MaximumLengthMemberDomain;
    ASSERT((*MemberAliasList)->MaximumLength >=
           (*MemberAliasList)->UsedLength);

AllocateMemberDomainFinish:

    return(Status);

AllocateMemberDomainError:

    SampAlInfoMakeInvalid( (*MemberAliasList)->DomainIndex );
    *MemberDomain = NULL;
    goto AllocateMemberDomainFinish;
}


NTSTATUS
SampAlGrowMemberDomain(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN ULONG ExtraSpaceRequired
    )

/*++

Routine Description:

    This function grows a Member Domain by at least the requested amount.  If
    necessary, the Member Alias List will also be grown.

Arguments:

    MemberAliasList - Pointer to pointer to the Member Alias List.

    MemberDomain - Pointer to pointer to the Member Domain

    ExtraSpaceRequired - Extra space needed in the Member Domain.

Return Values:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SpaceAvailable, MemberDomainOffset, CopyLength;
    PUCHAR Destination = NULL;
    PUCHAR Source = NULL;

    SAMTRACE("SampAlGrowMemberDomain");

    //
    // Calculate the space available in the Member Alias List
    //

    SpaceAvailable = (*MemberAliasList)->MaximumLength - (*MemberAliasList)->UsedLength;

    if (ExtraSpaceRequired > SpaceAvailable) {

        //
        // We need to grow the Member Alias List.  Calculate the offset of the
        // Member Domain in the old Member Alias List, grow the Member Alias
        // List and then calculate the new address of the Member Domain.
        //

        MemberDomainOffset = SampAlMemberDomainToOffset(
                                 *MemberAliasList,
                                 *MemberDomain
                                 );

        Status = SampAlGrowMemberAliasList(
                     MemberAliasList,
                     ExtraSpaceRequired - SpaceAvailable
                     );

        if (!NT_SUCCESS(Status)) {

            goto GrowMemberDomainError;
        }

        //
        // Calculate the new address of the Member Domain
        //

        *MemberDomain = SampAlMemberDomainFromOffset(
                            *MemberAliasList,
                            MemberDomainOffset
                            );
    }

    //
    // The Member Alias List is now guaranteed to be large enough.
    // Now shift any Member Domains that follow the one being grown
    // up to make room for the expanded Member Domain.  The source address
    // for the move is the address of the next Member Domain (if any) based
    // on the existing size of the Member Domain.  The destination address
    // of the move is the address of the next Member Domain (if any) based
    // on the new size of the Member Domain.
    //

    Source = (PUCHAR) SampAlNextMemberDomain( *MemberDomain );
    (*MemberDomain)->MaximumLength += ExtraSpaceRequired;
    Destination = (PUCHAR) SampAlNextMemberDomain( *MemberDomain );
    CopyLength =
        (ULONG)(((PUCHAR)(SampAlNextNewMemberDomain(*MemberAliasList))) - Source);

    //
    // Reserve the space in the Member Alias List.  If all's well, the
    // end of the destination buffer should match the updated end of the
    // used area of the member Alias List.
    //

    (*MemberAliasList)->UsedLength += ExtraSpaceRequired;
    ASSERT((*MemberAliasList)->MaximumLength >=
           (*MemberAliasList)->UsedLength);

    ASSERT( Destination + CopyLength ==
            (PUCHAR) SampAlNextNewMemberDomain( *MemberAliasList ));
    ASSERT( Destination + CopyLength <=
            (PUCHAR)(*MemberAliasList) + (*MemberAliasList)->MaximumLength );

    if (CopyLength > 0) {

        RtlMoveMemory( Destination, Source, CopyLength );
    }

GrowMemberDomainFinish:

    return(Status);

GrowMemberDomainError:

    SampAlInfoMakeInvalid( (*MemberAliasList)->DomainIndex );

    goto GrowMemberDomainFinish;
}


NTSTATUS
SampAlLookupMemberDomain(
    IN PSAMP_AL_MEMBER_ALIAS_LIST MemberAliasList,
    IN PSID DomainSid,
    OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain
    )

/*++

Routine Description:

This function looks up a Domain Sid in a Member Alias List to find its
Member Domain structure (if any).

Arguments:

    MemberAliasList - Pointer to pointer to Member Alias List

    DomainSid - Domain Sid whose Member Domain is to be found.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSAMP_AL_MEMBER_DOMAIN NextMemberDomain = NULL;
    LONG DomainIndex;
    BOOLEAN DomainFound = FALSE;

    SAMTRACE("SampAlLookupMemberDomain");


    for (DomainIndex = 0,
         NextMemberDomain = SampAlFirstMemberDomain( MemberAliasList );
         DomainIndex < (LONG) MemberAliasList->DomainCount;
         DomainIndex++, NextMemberDomain = SampAlNextMemberDomain( NextMemberDomain )
         ) {

        if (RtlEqualSid( DomainSid, &NextMemberDomain->DomainSid)) {

            DomainFound = TRUE;

            break;
        }
    }

    Status = STATUS_NO_SUCH_DOMAIN;

    if (!DomainFound) {

        goto LookupMemberDomainError;
    }

    *MemberDomain = NextMemberDomain;
    Status = STATUS_SUCCESS;

LookupMemberDomainFinish:

    return(Status);

LookupMemberDomainError:

    *MemberDomain = NULL;
    goto LookupMemberDomainFinish;
}


NTSTATUS
SampAlDeleteMemberDomain(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN MemberDomain
    )

/*++

Routine Description:

    This function deletes a Member Domain.  The Member Domain may contain
    zero or more Member Accounts.  The containing Member Alias List is shrunk.

Arguments:

    MemberAliasList - Pointer to pointer to the Member Alias List.

    MemberDomain - Pointer to the Member Domain

Return Values:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PUCHAR Source = NULL;
    PUCHAR Destination = NULL;
    ULONG CopyLength;

    SAMTRACE("SampAlDeleteMemberDomain");

    //
    // Calculate pointers for moving the residual portion of the
    // Member Alias List down to close the gap left by the extant Member
    // Domain.  The start of the residual portion is the next Member Domain.
    // The size of the portion is the distance between the start and the
    // used portion of the Member Alias List.
    //

    Source = (PUCHAR) SampAlNextMemberDomain( MemberDomain );
    Destination = (PUCHAR) MemberDomain;
    CopyLength = (ULONG)(((PUCHAR) SampAlNextNewMemberDomain( *MemberAliasList )) - Source);

    (*MemberAliasList)->UsedLength -= MemberDomain->MaximumLength;
    ASSERT((*MemberAliasList)->MaximumLength >=
           (*MemberAliasList)->UsedLength);
    (*MemberAliasList)->DomainCount--;

    if (CopyLength > 0) {

        RtlMoveMemory( Destination, Source, CopyLength );
    }

    return(Status);
}


NTSTATUS
SampAlCreateMemberAliasList(
    IN LONG DomainIndex,
    IN ULONG InitialMemberAliasListLength,
    OUT OPTIONAL PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList
    )

/*++

Routine Description:

    This function creates an empty Member Alias List for the specified SAM Local
    Domain.  The Member Alias List will be marked invalid.

Arguments:

    DomainIndex - Specifies the Local SAM Domain

    InitialMemberAliasListLength - Specifies the initial maximum length of the
        Member Alias List in bytes

    MemberAliasList - Optional pointer to location in which a pointer to the
        Member Alias List will be returned.  Note that the pointer can always
        be retrieved given the DomainIndex.

Return Values:

--*/

{
    NTSTATUS Status=STATUS_SUCCESS;
    PSAMP_AL_MEMBER_ALIAS_LIST OutputMemberAliasList = NULL;
    PSAMP_AL_ALIAS_INFORMATION AliasInformation = NULL;

    SAMTRACE("SampAlCreateMemberAliasList");

    //
    // Allocate memory for the list.
    //

    OutputMemberAliasList = MIDL_user_allocate( InitialMemberAliasListLength );


    if (OutputMemberAliasList == NULL) {

        Status = STATUS_NO_MEMORY;
        goto CreateMemberAliasListError;
    }


    //
    // Scratch the List header
    //

    OutputMemberAliasList->Signature = SAMP_AL_MEMBER_ALIAS_LIST_SIGNATURE;
    OutputMemberAliasList->MaximumLength = InitialMemberAliasListLength;
    OutputMemberAliasList->UsedLength = SampAlOffsetFirstMemberDomain(
                                            OutputMemberAliasList
                                            );
    ASSERT(OutputMemberAliasList->MaximumLength >=
           OutputMemberAliasList->UsedLength);

    OutputMemberAliasList->DomainIndex = DomainIndex;
    OutputMemberAliasList->DomainCount = 0;

    //
    // Link the Member Alias List to the SAM Local Domain info
    //

    AliasInformation = &(SampDefinedDomains[ DomainIndex].AliasInformation);
    AliasInformation->MemberAliasList = OutputMemberAliasList;

    *MemberAliasList = OutputMemberAliasList;

CreateMemberAliasListFinish:

    return(Status);

CreateMemberAliasListError:

    *MemberAliasList = NULL;
    goto CreateMemberAliasListFinish;
}


NTSTATUS
SampAlGrowMemberAliasList(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN ULONG ExtraSpaceRequired
    )

/*++

Routine Description:

    This function grows a Member Alias List by at least the requested amount.

Arguments:

    MemberAliasList - Pointer to pointer to the Member Alias List.

    ExtraSpaceRequired - Extra space needed in the Member Alias List.

Return Values:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG NewMaximumLengthMemberAliasList;
    PSAMP_AL_MEMBER_ALIAS_LIST OutputMemberAliasList = NULL;

    SAMTRACE("SampAlGrowMemberAliasList");

    //
    // Calculate the new size of the Member Alias List needed.  Round up to
    // a multiple of the granularity.
    //
    
    NewMaximumLengthMemberAliasList = (*MemberAliasList)->MaximumLength +
        ExtraSpaceRequired;

    NewMaximumLengthMemberAliasList +=
        (SAMP_AL_MEMBER_ALIAS_LIST_DELTA - (ULONG) 1);

    NewMaximumLengthMemberAliasList &=
        ((ULONG)(~(SAMP_AL_MEMBER_ALIAS_LIST_DELTA - (ULONG) 1)));
    
    //
    // We need to check Size Limitation in this routine only in DS Case
    // no cache size limitation for Registry Mode.
    //
    
    if ( (NewMaximumLengthMemberAliasList > SAMP_AL_MAX_MEMBER_ALIAS_LIST_LENGTH) &&
         SampUseDsData )
    {
        //   
        // in DS mode, enforce alias caching buffer size limitation.
        // use STATUS_BUFFER_OVERFLOW to specify this particular failure.
        // in Registry mode, no size limitation.
        // 
        Status = STATUS_BUFFER_OVERFLOW;
        goto GrowMemberAliasListError; 
    }
    

    //
    // Allocate memory for the grown Member Alias List.
    //

    OutputMemberAliasList = MIDL_user_allocate(
                                NewMaximumLengthMemberAliasList
                                );


    if (OutputMemberAliasList == NULL) {

        Status = STATUS_NO_MEMORY;
        goto GrowMemberAliasListError;
    }


    //
    // Copy the old list to the new list and the the new maximum length.
    // Return pointer to new list.
    //

    RtlMoveMemory(
        OutputMemberAliasList,
        *MemberAliasList,
        (*MemberAliasList)->UsedLength
        );

    OutputMemberAliasList->MaximumLength = NewMaximumLengthMemberAliasList;
    ASSERT(OutputMemberAliasList->MaximumLength >=
           OutputMemberAliasList->UsedLength);
    if (NULL!=*MemberAliasList)
    {
        MIDL_user_free(*MemberAliasList);
    }
    *MemberAliasList = OutputMemberAliasList;

GrowMemberAliasListFinish:

    return(Status);

GrowMemberAliasListError:

    SampAlInfoMakeInvalid( (*MemberAliasList)->DomainIndex );

    goto GrowMemberAliasListFinish;
}


NTSTATUS
SampAlRebuildMemberAliasList(
    IN PVOID Parameter
    )
/*++

Routine Description:

    This function will rebuild the Member Alias List for the specified
    SAM Local Domain. And free the old Member Alias List
    During Rebuild, the Member Alias List should have already been invalid state. 
    
    
    NOTE:  need to acquire SAM read lock before doing anything.

Arguments:

    Parameter - Pointer to DomainIndex, which specified the SAM Local Domain
                that should rebuild the Member Alias List

Return Value:

    Values returned by SampAlBuildMemberAliasList.                   
    
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS, IgnoreStatus;
    ULONG       DomainIndex;
    PSAMP_AL_MEMBER_ALIAS_LIST OldMemberAliasList = NULL;
    PSAMP_AL_MEMBER_ALIAS_LIST MemberAliasList = NULL;
        
    SAMTRACE("SampAlRebuildMemberAliasList");
    
    ASSERT(SampUseDsData);
    
    SampAcquireReadLock();
    
    // 
    // We need to Validate Domain Cache, because for loopback case, if the commit fails, the 
    // Domain Cache will be marked invalid, so before we use it, we need to validate it.
    //
    NtStatus = SampValidateDomainCache();
    
    if (!NT_SUCCESS(NtStatus))
    {
        goto RebuildMemberAliasListError;
    }
    
    DomainIndex = *(PULONG)Parameter;
    
    OldMemberAliasList = SampAlDomainIndexToMemberAliasList( DomainIndex );
    
    if (NULL != OldMemberAliasList)
    {
        SampDefinedDomains[ DomainIndex ].AliasInformation.MemberAliasList = NULL; 
        
        LsaIRegisterNotification(
                    SampAlFreeMemberAliasList, 
                    OldMemberAliasList, 
                    NOTIFIER_TYPE_INTERVAL,
                    0,
                    NOTIFIER_FLAG_ONE_SHOT,
                    600,        // wait for 10 minutes, then free
                    NULL 
                    ); 
    }
    
    NtStatus = SampAlBuildMemberAliasList(DomainIndex);
    
    // 
    // if SampAlBuildMemberAliasList failed because of
    // STATUS_BUFFER_OVERFLOW, do NOT try to build Alias Cache forever
    // and free the memory allocate by SampAlCreateMemberAliasList.
    // 
    // if failure due to other reason, try to rebuild later.
    //  
    
    if (!NT_SUCCESS(NtStatus))
    {
        //
        // if SampAlBuildMemberAliasList returns failure, 
        // Alias Membership Information should already been marked as invalid in SampAlBuildMemberAliasList
        // ASSERT and make it invalid again just for safety reason. 
        // 
        ASSERT( FALSE == SampAlInfoIsValid(DomainIndex) ); 
        SampAlInfoMakeInvalid( DomainIndex );
         
        if (NtStatus == STATUS_BUFFER_OVERFLOW)
        {
            MemberAliasList = SampAlDomainIndexToMemberAliasList( DomainIndex ); 
            
            if ( MemberAliasList != NULL)
            {
                SampDefinedDomains[ DomainIndex ].AliasInformation.MemberAliasList = NULL;
                MIDL_user_free(MemberAliasList);
                MemberAliasList = NULL;
            }
            
            NtStatus = STATUS_SUCCESS;
        }
        else 
        {
            goto RebuildMemberAliasListError;
        }
    }
    
    MIDL_user_free(Parameter);

    
RebuildMemberAliasListFinish:

    SampReleaseReadLock();
    
    return(NtStatus);


RebuildMemberAliasListError:

    // Reschedule rebuild Member Alias Cache routine
    LsaIRegisterNotification(
                SampAlRebuildMemberAliasList,
                Parameter,
                NOTIFIER_TYPE_INTERVAL,
                0,            // no class
                NOTIFIER_FLAG_ONE_SHOT,
                900,          // wait for another 15 mins
                NULL          // no handle
                ); 

    goto RebuildMemberAliasListFinish;

}



NTSTATUS
SampAlBuildMemberAliasList(
    IN LONG DomainIndex
    )

/*++

Routine Description:

    This function builds the Member Alias List for the specified SAM Local
    Domain.  For each Alias, its list of member Sids is read from backing
    storage and MemberDomain and MemberAccount blocks are created.

Arguments:

    DomainIndex - Specifies the SAM Local Domain

--*/

{
    NTSTATUS Status, EnumerationStatus;
    PSAMP_AL_MEMBER_ALIAS_LIST OutputMemberAliasList = NULL;
    SAMPR_ULONG_ARRAY AliasRids;
    ULONG Rids[1], EnumerationContext, AliasCount, AliasRid;
    ULONG AliasIndex;
    PSAMP_OBJECT AliasContext = NULL;
    SAMPR_PSID_ARRAY MemberSids;
    ULONG DomainSidMaximumLength = RtlLengthRequiredSid( 256 );
    PSAMPR_ENUMERATION_BUFFER EnumerationBuffer = NULL;

    SAMTRACE("SampAlBuildMemberAliasList");

    AliasRids.Element = Rids;

    SampAlInfoMakeInvalid( DomainIndex );

    //
    // Create an empty Member Alias List and connect it to the
    // local SAM Domain.
    //

    Status = SampAlCreateMemberAliasList(
                 DomainIndex,
                 SAMP_AL_INITIAL_MEMBER_ALIAS_LIST_LENGTH,
                 &OutputMemberAliasList
                 );

    if (!NT_SUCCESS(Status)) {

        goto BuildMemberAliasListError;
    }

    //
    // For each Alias in the SAM local domain, add its members to the
    // Alias List
    //

    EnumerationContext = 0;
    EnumerationStatus = STATUS_MORE_ENTRIES;

    //
    // It is currently necessary to set the Transaction Domain before
    // calling SampEnumerateAccountNames even though we're not modifying
    // anything.  The is because called routine SampBuildAccountKeyName()
    // uses this information.
    //

    SampSetTransactionWithinDomain(FALSE);
    SampSetTransactionDomain( DomainIndex );

    while (EnumerationStatus == STATUS_MORE_ENTRIES) {

        Status = SampEnumerateAccountNames(
                     SampAliasObjectType,
                     &EnumerationContext,
                     &EnumerationBuffer,
                     SAMP_AL_ENUM_PREFERRED_LENGTH,
                     0,
                     &AliasCount,
                     TRUE
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        EnumerationStatus = Status;

        for (AliasIndex = 0; AliasIndex < AliasCount; AliasIndex++) {

            AliasRid = EnumerationBuffer->Buffer[ AliasIndex ].RelativeId;

            //
            // Create a context for the account.
            //

            Status = SampCreateAccountContext(
                         SampAliasObjectType,
                         AliasRid,
                         TRUE,
                         FALSE,
                         TRUE,
                         &AliasContext
                         );

            if (NT_SUCCESS(Status)) {

                //
                // There is a rather ugly feature of the way the DomainIndex
                // field is used in context handles while initializing.  This
                // value is set to the count of SAM Local Domains!  So, I am
                // setting it to the DomainIndex for the SAM Local Domain we're
                // initializing, since this AliasContext is used only by me.
                //

                AliasContext->DomainIndex = DomainIndex;

                Status = SampAlQueryMembersOfAlias(
                             AliasContext,
                             &MemberSids
                             );

                if (NT_SUCCESS(Status)) {

                    //
                    // Add these members to the Alias.  No need to verify that
                    // they are already present since we're loading the Member Alias
                    // List from scratch.
                    //

                    Status = SampAlAddMembersToAlias(
                                 AliasContext,
                                 0,
                                 &MemberSids
                                 );
                }

                // 
                // free the memory allocated
                // 

                if (MemberSids.Sids!=NULL)
                {
                    MIDL_user_free(MemberSids.Sids);    
                    MemberSids.Sids = NULL;
                }

                SampDeleteContext( AliasContext );
            }

            if (!NT_SUCCESS(Status)) {

                break;
            }
        }

        //
        // Enumerate next set of Aliases
        //

        if (!NT_SUCCESS(Status)) {

            break;
        }

        //
        // Dispose of the Enumeration Buffer returned by SampEnumerateAccountNames
        //

        SamIFree_SAMPR_ENUMERATION_BUFFER( EnumerationBuffer );
        EnumerationBuffer = NULL;
    }

    if (!NT_SUCCESS(Status)) {

        goto BuildMemberAliasListError;
    }

    //
    // Mark the Member Alias List valid
    //

    SampAlInfoMakeValid( DomainIndex );

BuildMemberAliasListFinish:

    if (NULL!=EnumerationBuffer)
        SamIFree_SAMPR_ENUMERATION_BUFFER( EnumerationBuffer );

    SampSetTransactionWithinDomain(FALSE);
    return(Status);

BuildMemberAliasListError:

    goto BuildMemberAliasListFinish;
}

NTSTATUS
SampAlFreeMemberAliasList(
    IN PVOID Parameter
    )

/*++

Routine Description:

    This function frees the Member Alias List for a specific SAM
    Local Domain.
    
    NOTE: we do not acquire SAM Write Lock, since when we free that memory, hopefully, 
          no one else will still use it. 
    
Argument:

    Parameter - pointer to SAMP_AL_MEMBER_ALIAS_LIST
    
Return Value:
    
    none.
    
--*/
{
    SAMTRACE("SampAlFreeMemberAliasList"); 
    
    ASSERT(Parameter != NULL);
    
    if (Parameter != NULL)
    {
        MIDL_user_free( (PSAMP_AL_MEMBER_ALIAS_LIST) Parameter);
    }
    
    return(STATUS_SUCCESS);
}



BOOLEAN
SampAlInfoIsValidForDomain(
    IN SAMPR_HANDLE DomainHandle
    )

/*++

Routine Description:

    This function checks whether Alias Information is valid for a specific
    SAM Local Domain

Arguments:

    DomainHandle - Handle to SAM Local Domain

Return Values:

    BOOLEAN - TRUE if Alias Information is valid.  The Alias Information may
        be used in place of the backing storage to determine Alias membership
        FALSE if the Alias Information is not valid.  The Alias Information
        does not exist, or is not reliable.

--*/

{
    LONG DomainIndex;

    SAMTRACE("SampAlInfoIsValidForDomain");

    //
    // Get the Domain Index for the SAM Local Domain specified by DomainHandle.

    DomainIndex = ((PSAMP_OBJECT) DomainHandle)->DomainIndex;

    return(SampAlInfoIsValid( DomainIndex ));
}


BOOLEAN
SampAlInfoIsValidForAlias(
    IN SAMPR_HANDLE AliasHandle
    )

/*++

Routine Description:

    This function checks whether Alias Information is valid for a specific
    Alias.  The information is valid if it is valid for the SAM Local Domain
    containing the Alias.

Arguments:

    AliasHandle - Handle to SAM Alias

Return Values:

    BOOLEAN - TRUE if Alias Information is valid.  The Alias Information may
        be used in place of the backing storage to determine Alias membership
        FALSE if the Alias Information is not valid.  The Alias Information
        does not exist, or is not reliable.

--*/

{
    LONG DomainIndex;

    SAMTRACE("SampAlInfoIsValidForAlias");

    //
    // Get the Domain Index for the SAM Local Domain specified by DomainHandle.

    DomainIndex = ((PSAMP_OBJECT) AliasHandle)->DomainIndex;

    return(SampAlInfoIsValid( DomainIndex ));
}


NTSTATUS
SampAlInvalidateMemberAliasList(
    IN ULONG DomainIndex 
    )
                                
/*++

Routine Description:

    This funtion invalidate Memeber Alias List, delay Member Alias List
    rebuild routine. This routine is called by SampAlInvalidateAliasInformation. 
    The caller should hold Sam Write Lock.
    
Arguments:
    
    DomainIndex - Specify the SAM Local Domain 
    
Return Value:
    
--*/

{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PULONG      pDomainIndex;
    
    SAMTRACE("SampAlInvalidateMemberAliasList");
    
    // 
    // Invalidate Member Alias List at once.
    //
    
    SampAlInfoMakeInvalid(DomainIndex);
    
    pDomainIndex = MIDL_user_allocate(sizeof(ULONG));
    
    if (pDomainIndex == NULL)
    {
        return(STATUS_NO_MEMORY);
    }
    
    *pDomainIndex = DomainIndex;
    
    LsaIRegisterNotification(
                SampAlRebuildMemberAliasList,
                pDomainIndex,
                NOTIFIER_TYPE_INTERVAL,
                0,         // no class
                NOTIFIER_FLAG_ONE_SHOT,
                900,      // wait for 15 minutes 
                NULL       // no handle
                ); 
        
    return (NtStatus);
                        
}

NTSTATUS
SampFreeAliasNameCache(
    PVOID p
    )
/*++

Routine Description:

    This routine frees p, which is assumed to be a SAMP_ACCOUNT_NAME_CACHE.

Arguments:

    p -- a PVOID so this routine can be used as a callback

Return Values:

    STATUS_SUCCESS

--*/
{
    PSAMP_ACCOUNT_NAME_CACHE NameCache = (PSAMP_ACCOUNT_NAME_CACHE) p;
    ULONG i;

    if (NameCache) {

        if (NameCache->Entries) {

            ASSERT( NameCache->Count > 0);
            for (i = 0; i < NameCache->Count; i++) {
                if ( NameCache->Entries[i].Name.Buffer ) {
                    MIDL_user_free(NameCache->Entries[i].Name.Buffer);
                }
            }

            MIDL_user_free(NameCache->Entries);

        } else {

            ASSERT(NameCache->Count == 0);

        }

        MIDL_user_free(NameCache);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SampBuildAliasNameCache(
    ULONG DomainIndex
    )
/*++

Routine Description:

    This routine builds the account name cache for the domain at DomainIndex.
    This routine assumes that DomainIndex is a builtin domain since only
    the only accounts expected in the domain are a few aliases

Arguments:

    DomainIndex -- an index into the SampDefinedDomains structure

Return Values:

    STATUS_SUCCESS, or resource error

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DSNAME *ObjectNameInDs;
    ULONG EnumerationContext = 0;
    PSAMPR_RID_ENUMERATION RidList;
    PSAMPR_ENUMERATION_BUFFER Buffer = NULL;
    PSAMP_ACCOUNT_NAME_CACHE AccountNameCache = NULL;
    ULONG CountReturned = 0;
    ULONG Length;
    ULONG i;
    PVOID PtrToFree;

    //
    // N.B. Since SampEnumerateAccountNames2 is a thread safe routine
    // and only fixed values are referred in this routine, no SAM
    // lock is necessary.
    //

    //
    // This is only valid for builtin DS domains
    //
    ASSERT(IsBuiltinDomain(DomainIndex));
    ASSERT(IsDsObject(SampDefinedDomains[DomainIndex].Context));
    ObjectNameInDs = SampDefinedDomains[DomainIndex].Context->ObjectNameInDs;

    //
    // Query for the aliases  (this routine handles all transactioning)
    //
    NtStatus = SampEnumerateAccountNames2(
                            SampDefinedDomains[DomainIndex].Context,
                            SampAliasObjectType,
                            (PULONG) &EnumerationContext,  // largely ignored
                            &Buffer,   
                            0xFFFFFFFF,  // as much as possible
                            0, // no filter
                            &CountReturned,
                            TRUE // trusted client
                            );

    //
    // All the builtin aliases should be returned in one 
    // call
    //
    ASSERT(NtStatus != STATUS_MORE_ENTRIES);
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }
    ASSERT(CountReturned == Buffer->EntriesRead);
    RidList = Buffer->Buffer;

    //
    // Prepare the new cache structure
    //
    AccountNameCache = MIDL_user_allocate(sizeof(*AccountNameCache));
    if (NULL == AccountNameCache) {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(AccountNameCache, sizeof(*AccountNameCache));

    Length = sizeof(*AccountNameCache->Entries) * CountReturned;
    AccountNameCache->Entries = MIDL_user_allocate(Length);
    if (NULL == AccountNameCache->Entries) {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(AccountNameCache->Entries, Length);

    //
    // Copy the names and RID's into the cache
    //
    for (i = 0; i < CountReturned; i++) {
        AccountNameCache->Entries[i].Rid = RidList[i].RelativeId;
        // transfer the memory
        AccountNameCache->Entries[i].Name = *(PUNICODE_STRING)(&RidList[i].Name);
        RtlInitUnicodeString((PUNICODE_STRING)&RidList[i].Name, NULL);
    }
    AccountNameCache->Count = CountReturned;

    //
    // Carefully transfer to the global state
    //
    PtrToFree = InterlockedExchangePointer(&SampDefinedDomains[DomainIndex].AccountNameCache,
                                           AccountNameCache);
    AccountNameCache = NULL;

    if (PtrToFree) {
        //
        // In normal cases, PtrToFree will be NULL since the cache is only
        // build after it has been validated. However, in cases in which this
        // routine fails and is rescheduled and in the meantime a succesful 
        // rebuild as occurred, there will be something to free.
        //
        LsaIRegisterNotification(
                SampFreeAliasNameCache,
                PtrToFree,
                NOTIFIER_TYPE_INTERVAL,
                0,        // no class
                NOTIFIER_FLAG_ONE_SHOT,
                3600,     // wait for 60 min
                NULL      // no handle
                );
        PtrToFree = NULL;
    }

Cleanup:

    if (Buffer) {
        SamIFree_SAMPR_ENUMERATION_BUFFER(Buffer);
    }

    if (AccountNameCache) {
        if (AccountNameCache->Entries) {
            for (i = 0; i < AccountNameCache->Count; i++) {
                if (AccountNameCache->Entries[i].Name.Buffer) {
                    MIDL_user_free(AccountNameCache->Entries[i].Name.Buffer);
                }
            }
            MIDL_user_free(AccountNameCache->Entries);
        }
        MIDL_user_free(AccountNameCache);
    }

    return NtStatus;
}


NTSTATUS
SampBuildAliasNameCacheCallback(
    PVOID p
    )
/*++

Routine Description:

    This routine is a callback wrapper for SampBuildAliasNameCache()

Arguments:

    p -- pointer to ULONG which represents which domain index to rebuild

Return Values:

    STATUS_SUCCESS

--*/
{
    NTSTATUS Status;
    ULONG DomainIndex = *(PULONG)p;

    Status = SampBuildAliasNameCache(DomainIndex);
    if ( NT_SUCCESS(Status) ) {

        MIDL_user_free(p);

    } else {

        //
        // Try again in 5 minutes
        //
        LsaIRegisterNotification(
                SampBuildAliasNameCacheCallback,
                p,
                NOTIFIER_TYPE_INTERVAL,
                0,        // no class
                NOTIFIER_FLAG_ONE_SHOT,
                5 * 60,   // wait for 5 min
                NULL      // no handle
                );
    }

    return STATUS_SUCCESS;
}

VOID
SampInvalidateAliasNameCache(
    ULONG DomainIndex
    )
/*++

Routine Description:

    This routine invalidates the AccountName cache on the DomainIndex
    SampDefinedDomains structure.  It does this by NULL'ing out the field.
    Also, if the cache was in fact invalidating, a refresh is scheduled.

Arguments:

    DomainIndex -- an index into SampDefinedDomains

Return Values:

    None

--*/
{
    PVOID PtrToFree;

    //
    // Invalidate the domain wide cache, by setting the cache ptr to NULL
    //
    PtrToFree = InterlockedExchangePointer(&SampDefinedDomains[DomainIndex].AccountNameCache,
                                           NULL);
    if ( PtrToFree ) {

        PULONG pDomainIndex;
        //
        // Free the existing information (in an hour)
        //
        LsaIRegisterNotification(
                SampFreeAliasNameCache,
                PtrToFree,
                NOTIFIER_TYPE_INTERVAL,
                0,        // no class
                NOTIFIER_FLAG_ONE_SHOT,
                3600,     // wait for 60 min
                NULL      // no handle
                );

        //
        // Schedule a rebuild
        //
        // N.B. A rebuild is only scheduled when an existing cache is
        // invalidated
        //
        pDomainIndex = MIDL_user_allocate(sizeof(ULONG));
        if (pDomainIndex) {

            *pDomainIndex = DomainIndex;

            LsaIRegisterNotification(
                    SampBuildAliasNameCacheCallback,
                    pDomainIndex,
                    NOTIFIER_TYPE_INTERVAL,
                    0,        // no class
                    NOTIFIER_FLAG_ONE_SHOT,
                    5,        // wait for 5 seconds
                    NULL      // no handle
                    );
        }
    }

    return;

}


NTSTATUS
SampInitAliasNameCache(
    VOID
    )
/*++

Routine Description:

    This routine schedules a building of the account name cache for
    all DS builtin domains.
    
    This cache is a performance optimization only.  It creates a list if
    SamAccountNames and RID's that hang off of the SampDefinedDomains structure
    (field, AccountNameCache).  Typically it is NULL and hence does not affect
    normal lookups.  However, for DS builtin domains the value will be non NULL
    as it is simply to cache in memory the 10-15 aliases that live in the
    builtin domain.  Whenever a change occurs in the builtin domain, via
    a SAM call, an LDAP call, replication, etc, the cache is invalidated
    by setting AccountNameCache to NULL and a (asynchronous) rebuild is 
    scheduled.

Arguments:

    None

Return Values:

    STATUS_SUCCESS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG   DomainIndex;
    PULONG pDomainIndex;

    ASSERT(SampUseDsData);
    if (!SampUseDsData) {
        return STATUS_SUCCESS;
    }

    //
    // N.B. Since this routine only touches fixed fields of the 
    // SampDefinedDomains structure, no lock is necessary.
    //
    for (DomainIndex = SampDsGetPrimaryDomainStart(); 
         DomainIndex < SampDefinedDomainsCount; 
         DomainIndex++) {

        ASSERT(IsDsObject(SampDefinedDomains[DomainIndex].Context));
        if ( IsBuiltinDomain(DomainIndex) ) {

            pDomainIndex = MIDL_user_allocate(sizeof(ULONG));
            if ( NULL == pDomainIndex ) {
                Status = STATUS_NO_MEMORY;
                break;
            }
            *pDomainIndex = DomainIndex;

            LsaIRegisterNotification(
                    SampBuildAliasNameCacheCallback,
                    pDomainIndex,
                    NOTIFIER_TYPE_INTERVAL,
                    0,        // no class
                    NOTIFIER_FLAG_ONE_SHOT,
                    5,        // wait for 5 seconds
                    NULL      // no handle
                    );

            pDomainIndex = NULL;

        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\bldsam3.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    bldsam3.c

Abstract:

    This module provides an initialization capability to SAM.


    Approach
    --------

        This code has gone through a number of migrations that make it
        less than obvious what is going on.  To leverage off existing
        code and yet extend it to the initialization of two domains,
        with aliases, the following aproach has been taken:

           (1) Obtain the name and SID of the account domain.

           (2) Build the various security descriptors needed
               in the two domains.  These are kept in an array
               and the index is used to specify which applies
               to each new account.

           (3) Build up a list of alias memberships.  These, too,
               are selected by index, with one entry being the
               empty set.


Author:

    Jim Kelly  3-May-1991.

Revision History:

    08-Oct-1996 ChrisMay
        Added crash-recovery code, allowing SAM to initialize from the
        registry instead of the DS after a database corruption.

--*/

#include <nt.h>
#include <ntsam.h>
#include "ntlsa.h"
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "samsrvp.h"

//
// Constants used for Sam Global Data string buffers
//

#define SAMP_MAXIMUM_INTERNAL_NAME_LENGTH ((USHORT) 0x00000200L)





///////////////////////////////////////////////////////////////////////
//                                                                   //
// Global variables                                                  //
//                                                                   //
///////////////////////////////////////////////////////////////////////

static LSA_HANDLE SampBldPolicyHandle;  //Handle to LSA policy object

static NTSTATUS Status;

static BOOLEAN SampRealSetupWasRun;   //Indicates a real setup was run
static BOOLEAN SampDeveloperSetup;    //Indicates a developer setup is running

static NT_PRODUCT_TYPE SampBldProductType;
static DOMAIN_SERVER_ROLE SampServerRole;
static PPOLICY_PRIMARY_DOMAIN_INFO SampBldPrimaryDomain = NULL;



static PSID  WorldSid,
             LocalSystemSid,
             AdminsAliasSid,
             UsersAliasSid,
             PowerUsersAliasSid,
             AccountAliasSid,
             AnySidInAccountDomain;


static PACL  TokenDefaultDaclInformation;
static ULONG TokenDefaultDaclInformationSize;

//
// Handle to the registry key in which the SAM database resides
//

static HANDLE  SamParentKey = NULL;

//
// Handle to the root SAM key.
// This is the key that has the RXACT applied to it.
//

static HANDLE SamKey = NULL;

static PRTL_RXACT_CONTEXT SamRXactContext;

//
// Assorted names, buffers, and values used during registry key creation
//

static PSID    DomainSid;
static PUNICODE_STRING DomainNameU, FullDomainNameU;
static UNICODE_STRING  AccountInternalDomainNameU, BuiltinInternalDomainNameU;
static UNICODE_STRING  AccountExternalDomainNameU, BuiltinExternalDomainNameU;
static UNICODE_STRING  FullAccountInternalDomainNameU, FullBuiltinInternalDomainNameU;
static UNICODE_STRING  DomainNamePrefixU, TemporaryNamePrefixU, KeyNameU, TempStringU;

static WCHAR KeyNameBuffer[2000];
static WCHAR TempStringBuffer[2000];
static SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;




//
// Values that get placed in registry keys...
//

static LARGE_INTEGER DomainMaxPasswordAge = { 0, - 6L * 7L * 24L * 60L / 7L }; // 6 weeks
static LARGE_INTEGER ModifiedCount  = {0,0};
static UNICODE_STRING NullUnicodeString;

//
// Array of protection information for SAM objects
//

static SAMP_PROTECTION SampProtection[SAMP_PROT_TYPES];





//
// Internal routine definitions
//



NTSTATUS
SampGetDomainPolicy(
    IN PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo OPTIONAL
    );

VOID
SampGetServerRole( VOID );

VOID
SampGetPrimaryDomainInfo(
    IN PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo OPTIONAL
    );


VOID
GetDomainSids( VOID );

VOID
SetDomainName(
    IN BOOLEAN BuiltinDomain
    );


VOID
Usage ( VOID );



NTSTATUS
Initialize (
    WCHAR                      *SamParentKeyName,
    PNT_PRODUCT_TYPE            ProductType       OPTIONAL,
    PPOLICY_LSA_SERVER_ROLE     ServerRole        OPTIONAL,
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo OPTIONAL,
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo OPTIONAL
    );

BOOLEAN
InitializeSecurityDescriptors( VOID );

NTSTATUS
SampCreateDatabaseProtection(
    PISECURITY_DESCRIPTOR   SD
    );

NTSTATUS
SampBuildNewProtection(
    IN ULONG AceCount,
    IN PSID *AceSid,
    IN ACCESS_MASK *AceMask,
    IN PGENERIC_MAPPING GenericMap,
    IN BOOLEAN UserObject,
    OUT PSAMP_PROTECTION Result
    );

NTSTATUS
InitializeSam( VOID );

NTSTATUS
PrepDomain(
    IN SAMP_DOMAIN_SELECTOR Domain,
    IN BOOLEAN PreserveSyskeySettings
    );


VOID
SetCurrentDomain(
    IN SAMP_DOMAIN_SELECTOR Domain
    );


NTSTATUS
CreateBuiltinDomain( VOID );

NTSTATUS
CreateAccountDomain( IN BOOLEAN PreserveSyskeySettings );



NTSTATUS
CreateAlias(
    IN PUNICODE_STRING AccountNameU,
    IN PUNICODE_STRING AccountCommentU,
    IN BOOLEAN SpecialAccount,
    IN ULONG Rid,
    IN ULONG ProtectionIndex
    );


NTSTATUS
CreateGroup(
    IN PUNICODE_STRING AccountNameU,
    IN PUNICODE_STRING AccountCommentU,
    IN BOOLEAN SpecialAccount,
    IN ULONG Rid,
    IN BOOLEAN Admin
    );


NTSTATUS
CreateUser(
    IN PUNICODE_STRING AccountNameU,
    IN PUNICODE_STRING AccountCommentU,
    IN BOOLEAN SpecialAccount,
    IN ULONG UserRid,
    IN ULONG PrimaryGroup,
    IN BOOLEAN Admin,
    IN ULONG  UserControl,
    IN ULONG ProtectionIndex
    );



NTSTATUS
UpdateAliasXReference(
    IN ULONG AliasRid,
    IN PSID Sid
    );


NTSTATUS
OpenAliasMember(
    IN PSID Sid,
    OUT PHANDLE KeyHandle
    );


PSID
BuildPrimaryDomainSid(
    ULONG Rid
    );

PSID
BuildAccountSid(
    SAMP_DOMAIN_SELECTOR Domain,
    ULONG Rid
    );


NTSTATUS
OpenOrCreateAccountRidKey(
    IN PSID Sid,
    IN HANDLE AliasDomainHandle,
    OUT PHANDLE KeyHandle
    );

NTSTATUS
OpenOrCreateAliasDomainKey(
    IN PSID Sid,
    OUT PHANDLE KeyHandle
    );

NTSTATUS
AppendAliasDomainNameToUnicodeString(
    IN OUT PUNICODE_STRING Destination,
    IN PSID Sid
    );



NTSTATUS
SampInitilializeRegistry ( VOID );


NTSTATUS
SampDetermineSetupEnvironment( VOID );




///////////////////////////////////////////////////////////////////////
//                                                                   //
// Routines                                                          //
//                                                                   //
///////////////////////////////////////////////////////////////////////


VOID
Usage (
    VOID
    )
/*++


Routine Description:

    This routine prints the "Usage:" message.

Arguments:

    None.

Return Value:

    None.

--*/
{

#if DBG
    BldPrint( "\n");
    BldPrint( "\n");

    BldPrint( "We offer no assistance in this suicide.\n");
    BldPrint( "\n");
    BldPrint( "\n");
    BldPrint( "\n");
#endif

    return;
}


VOID
UnexpectedProblem (
    VOID
    )
/*++


Routine Description:

    This routine prints a message indicating that an unexpected
    problem has occured.

Arguments:

    None.

Return Value:

    None.

--*/
{

#if DBG
    BldPrint( "\n");
    BldPrint( "\n");
    BldPrint( "  An unexpected problem has prevented the command from\n");
    BldPrint( "  completing successfully.  Please contact one of the\n");
    BldPrint( "  members of the security group for assistance.\n");
    BldPrint( "\n");
#endif

    return;

}


NTSTATUS
Initialize (
    WCHAR                      *SamParentKeyName,
    PNT_PRODUCT_TYPE            ProductType       OPTIONAL,
    PPOLICY_LSA_SERVER_ROLE     ServerRole        OPTIONAL,
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo OPTIONAL,
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo OPTIONAL
    )
/*++


Routine Description:

    This routine performs initialization operations before creating
    each domain.

    This includes:

        - Setting the correct default owner and DACL for registry key
          operations.

        - opening the parent registry key for the SAM database.


Arguments:

    SamParentKeyName  : the registry path to the parent of the SAM database

    ProductType       : the product type of the database to be created; if not
                        present, RtlGetNtProductType will be called

    ServerRole        : the role of the product; if not present, LSA will be queried

    AccountDomainInfo : name and sid of the account domain; if not present, LSA will be queried

    PrimaryDomainIndo : name and sid of the primary domain; if not present, LSA will be queried

Return Value:

    TRUE - Indicates initialization was successful.

    FALSE - Indicates initialization was not successful.

--*/

{
    OBJECT_ATTRIBUTES SamParentAttributes, PolicyObjectAttributes;
    UNICODE_STRING SamParentNameU;
    ULONG Disposition;
    HANDLE Token;
    TOKEN_OWNER LocalSystemOwner;
    SID_IDENTIFIER_AUTHORITY NtAuthority       = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PACL Dacl;
    TOKEN_DEFAULT_DACL DefaultDacl;
    BOOLEAN CompletionStatus;
    BOOLEAN ProductTypeRetrieved;
    BOOLEAN CrashRecoveryMode = FALSE;
    BOOLEAN RegistryMode = FALSE;

    SAMTRACE("Initialize");

    //
    // Set up some of the well known account SIDs for use...
    //

    WorldSid      = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 1 ));
    ASSERT(WorldSid != NULL);
    if (NULL==WorldSid)
    {
        return(STATUS_NO_MEMORY);
    }
    RtlInitializeSid( WorldSid,      &WorldSidAuthority, 1 );
    *(RtlSubAuthoritySid( WorldSid, 0 ))        = SECURITY_WORLD_RID;

    AdminsAliasSid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 2 ));
    ASSERT(AdminsAliasSid != NULL);
    if (NULL==AdminsAliasSid)
    {
        return(STATUS_NO_MEMORY);
    }
    RtlInitializeSid( AdminsAliasSid,   &BuiltinAuthority, 2 );
    *(RtlSubAuthoritySid( AdminsAliasSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( AdminsAliasSid,  1 )) = DOMAIN_ALIAS_RID_ADMINS;

    PowerUsersAliasSid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 2 ));
    ASSERT(PowerUsersAliasSid != NULL);
    if (NULL==PowerUsersAliasSid)
    {
        return(STATUS_NO_MEMORY);
    }
    RtlInitializeSid( PowerUsersAliasSid,   &BuiltinAuthority, 2 );
    *(RtlSubAuthoritySid( PowerUsersAliasSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( PowerUsersAliasSid,  1 )) = DOMAIN_ALIAS_RID_POWER_USERS;

    UsersAliasSid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 2 ));
    ASSERT(UsersAliasSid != NULL);
    if (NULL==UsersAliasSid)
    {
        return(STATUS_NO_MEMORY);
    }
    RtlInitializeSid( UsersAliasSid,   &BuiltinAuthority, 2 );
    *(RtlSubAuthoritySid( UsersAliasSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( UsersAliasSid,  1 )) = DOMAIN_ALIAS_RID_USERS;

    AccountAliasSid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 2 ));
    ASSERT(AccountAliasSid != NULL);
    if (NULL==AccountAliasSid)
    {
        return(STATUS_NO_MEMORY);
    }
    RtlInitializeSid( AccountAliasSid,   &BuiltinAuthority, 2 );
    *(RtlSubAuthoritySid( AccountAliasSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( AccountAliasSid,  1 )) = DOMAIN_ALIAS_RID_ACCOUNT_OPS;

    LocalSystemSid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 1 ));
    ASSERT(LocalSystemSid != NULL);
    if (NULL==LocalSystemSid)
    {
        return(STATUS_NO_MEMORY);
    }
    RtlInitializeSid( LocalSystemSid,   &NtAuthority, 1 );
    *(RtlSubAuthoritySid( LocalSystemSid,  0 )) = SECURITY_LOCAL_SYSTEM_RID;

    //
    // Setup a buffer to use for all our key-name constructions
    //

    KeyNameU.MaximumLength = 2000;
    KeyNameU.Buffer = KeyNameBuffer;

    //
    // Setup temporary Unicode string buffer.
    //

    TempStringU.Buffer = TempStringBuffer;
    TempStringU.MaximumLength = 2000;

    //
    // Get a handle to the LSA Policy object
    //

    InitializeObjectAttributes(
        &PolicyObjectAttributes,
        NULL,             // Name
        0,                // Attributes
        NULL,             // Root
        NULL              // Security Descriptor
        );

    Status = LsaIOpenPolicyTrusted( &SampBldPolicyHandle );

    if (!NT_SUCCESS(Status)) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "newsam\\server\\bldsam3: Couldn't open LSA Policy object.\n"
                   "               Status: 0x%lx\n\n",
                   Status));

        return(Status);
    }

    //
    // Get the product type.
    //
    if (!ARGUMENT_PRESENT(ProductType)) {

        ProductTypeRetrieved = RtlGetNtProductType(&SampBldProductType);

        if (!ProductTypeRetrieved) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "Couldn't retrieve product type\n"));

            return(STATUS_UNSUCCESSFUL);
        }

    } else {

        SampBldProductType = *ProductType;

    }

    //
    // Figure out if we are being initialized following a real
    // setup, or it this is a developer setup.
    //

    SampDetermineSetupEnvironment();

    //
    // Domain name prefix is required by SampGetDomainPolicy() and
    // so must be initialized before that call.
    //

    RtlInitUnicodeString( &DomainNamePrefixU, L"Domains");

    //
    // Set up domain names/Sids.
    //

    Status = SampGetDomainPolicy(AccountDomainInfo);

    if (!NT_SUCCESS(Status)) {

        return(Status);
    }

    //
    // Get the role of this machine.
    //
    if (!ARGUMENT_PRESENT(ServerRole)) {

        if (NtProductLanManNt==SampBldProductType)
        {
            //
            // Domain Controllers are DS based. The server
            // role is set in them comes from the FSMO.
            // Therefore set their Server role here as a
            // Backup as a place holder
            //

            SampServerRole = DomainServerRoleBackup;
        }
        else
        {
            //
            // Else if we are a member server then the server
            // role is always set to primary. ServerRoles cannot
            // be backups in member servers or Workstations.
            //

            SampServerRole = DomainServerRolePrimary;
        }

    } else {

        SampServerRole = *